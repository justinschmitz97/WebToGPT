[{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Community Guide Vue's community growing incredibly fast reading this, there's good chance ready join it. So... welcome! we'll answer community community. Resources Code Conduct Code Conduct guide make easier enrich us technical communities participate. Stay Know - Follow official Twitter account. - Follow team members Twitter GitHub. - Follow RFC discussions. - Subscribe official blog. Get Support - Discord Chat: place Vue devs meet chat real time. - Forum: best place ask questions get answers Vue ecosystem. - DEV Community: Share discuss Vue related topics Dev.to. - Meetups: Want find local Vue enthusiasts like yourself? Interested becoming community leader? help support need right here! - GitHub: bug report feature request, that's GitHub issues for. Please respect rules specified repository's issue template. - Twitter Community (unofficial): Twitter community, meet Vue enthusiasts, get help, chat Vue. Explore Ecosystem - Awesome Vue Page: See awesome resources published awesome people. - Vue Telescope Explorer: Explore websites made Vue, insights framework / libraries use. - Made Vue.js: showcases projects libraries made Vue. - \"Show Tell\" Subforum: Another great place check others built growing Vue ecosystem. Help Fellow Users Code contribution form contribution Vue community. Answering question fellow Vue user Discord forum also considered valuable contribution. Help Triage Issues Triaging issue means gathering missing information, running reproduction, verifying issue's validity, investigating cause issue. receive many issues repositories GitHub every single day. bandwidth limited compared amount users have, issue triaging alone take enormous amount effort team. helping us triage issues, helping us become efficient, allowing us spend time higher priority work. triage issue goal fixing (although would nice too). Sharing result investigation, example commit led bug, already save us ton time. Contribute Code Contributing bug fixes new features direct form contribution make. Vue core repository provides contributing guide, contains pull request guidelines information regarding build setup high-level architecture. sub-project repositories may also contain contribution guide - please make sure read submitting pull requests. Bug fixes welcome time. new features, best discuss use case implementation details first RFC repo. Share (and Build) Experience Apart answering questions sharing resources forum chat, less obvious ways share expand know: - Develop learning materials. often said best way learn teach. there's something interesting Vue, strengthen expertise writing blog post, developing workshop, even publishing gist share social media. - Watch repo care about. send notifications whenever there's activity repository, giving insider knowledge ongoing discussions upcoming features. fantastic way build expertise eventually able help address issues pull requests. Translate Docs hope right now, reading sentence preferred language. not, would like help us get there? See Translations guide details get involved. Become Community Leader There's lot help Vue grow community: - Present local meetup. Whether giving talk running workshop, bring lot value community helping new experienced Vue developers continue grow. - Start meetup. there's already Vue meetup area, start own! Use resources events.vuejs.org help succeed! - Help meetup organizers. never much help comes running event, offer hand help local organizers help make every event success. questions get involved local Vue community, reach Twitter @vuejs_events!"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "API Reference Global API Application - createApp() - createSSRApp() - app.mount() - app.unmount() - app.onUnmount() - app.component() - app.directive() - app.use() - app.mixin() - app.provide() - app.runWithContext() - app.version - app.config - app.config.errorHandler - app.config.warnHandler - app.config.performance - app.config.compilerOptions - app.config.globalProperties - app.config.optionMergeStrategies - app.config.idPrefix - app.config.throwUnhandledErrorInProduction"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Application API createApp() Creates application instance. Type tsfunction createApp(rootComponent: Component, rootProps?: object): App Details first argument root component. second optional argument props passed root component. Example inline root component: jsimport { createApp } 'vue' const app = createApp({ /* root component options */ }) imported component: jsimport { createApp } 'vue' import App './App.vue' const app = createApp(App) See also Guide - Creating Vue Application createSSRApp() Creates application instance SSR Hydration mode. Usage exactly createApp() . app.mount() Mounts application instance container element. Type tsinterface App { mount(rootContainer: Element | string): ComponentPublicInstance } Details argument either actual DOM element CSS selector (the first matched element used). Returns root component instance. component template render function defined, replace existing DOM nodes inside container. Otherwise, runtime compiler available, innerHTML container used template.In SSR hydration mode, hydrate existing DOM nodes inside container. mismatches, existing DOM nodes morphed match expected output. app instance, mount() called once.Example jsimport { createApp } 'vue' const app = createApp(/* ... */) app.mount('#app') also mount actual DOM element: jsapp.mount(document.body.firstChild) app.unmount() Unmounts mounted application instance, triggering unmount lifecycle hooks components application's component tree. Type tsinterface App { unmount(): void } app.onUnmount() Registers callback called app unmounted. Type tsinterface App { onUnmount(callback: () => any): void } app.component() Registers global component passing name string component definition, retrieves already registered one name passed. Type tsinterface App { component(name: string): Component | undefined component(name: string, component: Component): } Example jsimport { createApp } 'vue' const app = createApp({}) // register options object app.component('MyComponent', { /* ... */ }) // retrieve registered component const MyComponent = app.component('MyComponent') See also Component Registration app.directive() Registers global custom directive passing name string directive definition, retrieves already registered one name passed. Type tsinterface App { directive(name: string): Directive | undefined directive(name: string, directive: Directive): } Example jsimport { createApp } 'vue' const app = createApp({ /* ... */ }) // register (object directive) app.directive('myDirective', { /* custom directive hooks */ }) // register (function directive shorthand) app.directive('myDirective', () => { /* ... */ }) // retrieve registered directive const myDirective = app.directive('myDirective') See also Custom Directives app.use() Installs plugin. Type tsinterface App { use(plugin: Plugin, ...options: any[]): } Details Expects plugin first argument, optional plugin options second argument. plugin either object install() method, function used theinstall() method. options (second argument ofapp.use() ) passed along plugin'sinstall() method.When app.use() called plugin multiple times, plugin installed once.Example jsimport { createApp } 'vue' import MyPlugin './plugins/MyPlugin' const app = createApp({ /* ... */ }) app.use(MyPlugin) See also Plugins app.mixin() Applies global mixin (scoped application). global mixin applies included options every component instance application. Recommended Mixins supported Vue 3 mainly backwards compatibility, due widespread use ecosystem libraries. Use mixins, especially global mixins, avoided application code. logic reuse, prefer Composables instead. Type tsinterface App { mixin(mixin: ComponentOptions): } app.provide() Provide value injected descendant components within application. Type tsinterface App { provide<T>(key: InjectionKey<T> | symbol | string, value: T): } Details Expects injection key first argument, provided value second. Returns application instance itself. Example jsimport { createApp } 'vue' const app = createApp(/* ... */) app.provide('message', 'hello') Inside component application: jsimport { inject } 'vue' export default { setup() { console.log(inject('message')) // 'hello' } } See also app.runWithContext() - supported 3.3+ Execute callback current app injection context. Type tsinterface App { runWithContext<T>(fn: () => T): } Details Expects callback function runs callback immediately. synchronous call callback, inject() calls able look injections values provided current app, even current active component instance. return value callback also returned.Example jsimport { inject } 'vue' app.provide('id', 1) const injected = app.runWithContext(() => { return inject('id') }) console.log(injected) // 1 app.version Provides version Vue application created with. useful inside plugins, might need conditional logic based different Vue versions. Type tsinterface App { version: string } Example Performing version check inside plugin: jsexport default { install(app) { const version = Number(app.version.split('.')[0]) (version < 3) { console.warn('This plugin requires Vue 3') } } } See also Global API - version app.config Every application instance exposes config object contains configuration settings application. modify properties (documented below) mounting application. js import { createApp } 'vue' const app = createApp(/* ... */) console.log(app.config) app.config.errorHandler Assign global handler uncaught errors propagating within application. Type tsinterface AppConfig { errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, // `info` Vue-specific error info, // e.g. lifecycle hook error thrown info: string ) => void } Details error handler receives three arguments: error, component instance triggered error, information string specifying error source type. capture errors following sources: - Component renders - Event handlers - Lifecycle hooks setup() function- Watchers - Custom directive hooks - Transition hooks TIP production, 3rd argument ( info ) shortened code instead full information string. find code string mapping Production Error Code Reference.Example jsapp.config.errorHandler = (err, instance, info) => { // handle error, e.g. report service } app.config.warnHandler Assign custom handler runtime warnings Vue. Type tsinterface AppConfig { warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) => void } Details warning handler receives warning message first argument, source component instance second argument, component trace string third. used filter specific warnings reduce console verbosity. Vue warnings addressed development, recommended debug sessions focus specific warnings among many, removed debugging done. TIP Warnings work development, config ignored production mode. Example jsapp.config.warnHandler = (msg, instance, trace) => { // `trace` component hierarchy trace } app.config.performance Set true enable component init, compile, render patch performance tracing browser devtool performance/timeline panel. works development mode browsers support performance.mark API. Type: boolean See also Guide - Performance app.config.compilerOptions Configure runtime compiler options. Values set object passed in-browser template compiler affect every component configured app. Note also override options per-component basis using compilerOptions option. Important config option respected using full build (i.e. standalone vue.js compile templates browser). using runtime-only build build setup, compiler options must passed @vue/compiler-dom via build tool configurations instead. vue-loader : pass via thecompilerOptions loader option. Also see configure invue-cli .For vite : pass via@vitejs/plugin-vue options. app.config.compilerOptions.isCustomElement Specifies check method recognize native custom elements. Type: (tag: string) => boolean Details return true tag treated native custom element. matched tag, Vue render native element instead attempting resolve Vue component.Native HTML SVG tags need matched function - Vue's parser recognizes automatically. Example js// treat tags starting 'ion-' custom elements app.config.compilerOptions.isCustomElement = (tag) => { return tag.startsWith('ion-') } See also Vue Web Components app.config.compilerOptions.whitespace Adjusts template whitespace handling behavior. Type: 'condense' | 'preserve' Default: 'condense' Details Vue removes / condenses whitespace characters templates produce efficient compiled output. default strategy \"condense\", following behavior: - Leading / ending whitespace characters inside element condensed single space. - Whitespace characters elements contain newlines removed. - Consecutive whitespace characters text nodes condensed single space. Setting option 'preserve' disable (2) (3).Example jsapp.config.compilerOptions.whitespace = 'preserve' app.config.compilerOptions.delimiters Adjusts delimiters used text interpolation within template. Type: [string, string] Default: ['{{', '}}'] Details typically used avoid conflicting server-side frameworks also use mustache syntax. Example js// Delimiters changed ES6 template string style app.config.compilerOptions.delimiters = ['${', '}'] app.config.compilerOptions.comments Adjusts treatment HTML comments templates. Type: boolean Default: false Details default, Vue remove comments production. Setting option true force Vue preserve comments even production. Comments always preserved development. option typically used Vue used libraries rely HTML comments.Example jsapp.config.compilerOptions.comments = true app.config.globalProperties object used register global properties accessed component instance inside application. Type tsinterface AppConfig { globalProperties: Record<string, any> } Details replacement Vue 2's Vue.prototype longer present Vue 3. anything global, used sparingly.If global property conflicts component\u2019s property, component's property higher priority. Usage jsapp.config.globalProperties.msg = 'hello' makes msg available inside component template application, also onthis component instance:jsexport default { mounted() { console.log(this.msg) // 'hello' } } See also Guide - Augmenting Global Properties app.config.optionMergeStrategies object defining merging strategies custom component options. Type tsinterface AppConfig { optionMergeStrategies: Record<string, OptionMergeFunction> } type OptionMergeFunction = (to: unknown, from: unknown) => Details plugins / libraries add support custom component options (by injecting global mixins). options may require special merging logic option needs \"merged\" multiple sources (e.g. mixins component inheritance). merge strategy function registered custom option assigning app.config.optionMergeStrategies object using option's name key.The merge strategy function receives value option defined parent child instances first second arguments, respectively. Example jsconst app = createApp({ // option self msg: 'Vue', // option mixin mixins: [ { msg: 'Hello ' } ], mounted() { // merged options exposed this.$options console.log(this.$options.msg) } }) // define custom merge strategy `msg` app.config.optionMergeStrategies.msg = (parent, child) => { return (parent || '') + (child || '') } app.mount('#app') // logs 'Hello Vue' See also Component Instance - $options app.config.idPrefix Configure prefix IDs generated via useId() inside application. Type: string Default: undefined Example jsapp.config.idPrefix = 'myApp' js// component: const id1 = useId() // 'myApp:0' const id2 = useId() // 'myApp:1' app.config.throwUnhandledErrorInProduction Force unhandled errors thrown production mode. Type: boolean Default: false Details default, errors thrown inside Vue application explicitly handled different behavior development production modes: development, error thrown possibly crash application. make error prominent noticed fixed development. production, error logged console minimize impact end users. However, may prevent errors happen production caught error monitoring services. setting app.config.throwUnhandledErrorInProduction totrue , unhandled errors thrown even production mode."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Built-in Components Registration Usage Built-in components used directly templates without needing registered. also tree-shakeable: included build used. using render functions, need imported explicitly. example: js import { h, Transition } 'vue' h(Transition, { /* props */ }) <Transition> Provides animated transition effects single element component. Props tsinterface TransitionProps { /** * Used automatically generate transition CSS class names. * e.g. `name: 'fade'` auto expand `.fade-enter`, * `.fade-enter-active`, etc. */ name?: string /** * Whether apply CSS transition classes. * Default: true */ css?: boolean /** * Specifies type transition events wait * determine transition end timing. * Default behavior auto detecting type * longer duration. */ type?: 'transition' | 'animation' /** * Specifies explicit durations transition. * Default behavior wait first `transitionend` * `animationend` event root transition element. */ duration?: number | { enter: number; leave: number } /** * Controls timing sequence leaving/entering transitions. * Default behavior simultaneous. */ mode?: 'in-out' | 'out-in' | 'default' /** * Whether apply transition initial render. * Default: false */ appear?: boolean /** * Props customizing transition classes. * Use kebab-case templates, e.g. enter-from-class=\"xxx\" */ enterFromClass?: string enterActiveClass?: string enterToClass?: string appearFromClass?: string appearActiveClass?: string appearToClass?: string leaveFromClass?: string leaveActiveClass?: string leaveToClass?: string } Events @before-enter @before-leave @enter @leave @appear @after-enter @after-leave @after-appear @enter-cancelled @leave-cancelled (v-show only)@appear-cancelled Example Simple element: template<Transition> <div v-if=\"ok\">toggled content</div> </Transition> Forcing transition changing key attribute:template<Transition> <div :key=\"text\">{{ text }}</div> </Transition> Dynamic component, transition mode + animate appear: template<Transition name=\"fade\" mode=\"out-in\" appear> <component :is=\"view\"></component> </Transition> Listening transition events: template<Transition @after-enter=\"onTransitionComplete\"> <div v-show=\"ok\">toggled content</div> </Transition> See also Guide - Transition <TransitionGroup> Provides transition effects multiple elements components list. Props <TransitionGroup> accepts props as<Transition> exceptmode , plus two additional props:tsinterface TransitionGroupProps extends Omit<TransitionProps, 'mode'> { /** * defined, renders fragment. */ tag?: string /** * customizing CSS class applied move transitions. * Use kebab-case templates, e.g. move-class=\"xxx\" */ moveClass?: string } Events <TransitionGroup> emits events as<Transition> .Details default, <TransitionGroup> render wrapper DOM element, one defined via thetag prop.Note every child <transition-group> must uniquely keyed animations work properly.<TransitionGroup> supports moving transitions via CSS transform. child's position screen changed update, get applied moving CSS class (auto generated thename attribute configured themove-class prop). CSStransform property \"transition-able\" moving class applied, element smoothly animated destination using FLIP technique.Example template<TransitionGroup tag=\"ul\" name=\"slide\"> <li v-for=\"item items\" :key=\"item.id\"> {{ item.text }} </li> </TransitionGroup> See also Guide - TransitionGroup <KeepAlive> Caches dynamically toggled components wrapped inside. Props tsinterface KeepAliveProps { /** * specified, components names matched * `include` cached. */ include?: MatchPattern /** * component name matched `exclude` * cached. */ exclude?: MatchPattern /** * maximum number component instances cache. */ max?: number | string } type MatchPattern = string | RegExp | (string | RegExp)[] Details wrapped around dynamic component, <KeepAlive> caches inactive component instances without destroying them.There one active component instance direct child <KeepAlive> time.When component toggled inside <KeepAlive> , itsactivated anddeactivated lifecycle hooks invoked accordingly, providing alternative tomounted andunmounted , called. applies direct child of<KeepAlive> well descendants.Example Basic usage: template<KeepAlive> <component :is=\"view\"></component> </KeepAlive> used v-if /v-else branches, must one component rendered time:template<KeepAlive> <comp-a v-if=\"a > 1\"></comp-a> <comp-b v-else></comp-b> </KeepAlive> Used together <Transition> :template<Transition> <KeepAlive> <component :is=\"view\"></component> </KeepAlive> </Transition> Using include /exclude :template<!-- comma-delimited string --> <KeepAlive include=\"a,b\"> <component :is=\"view\"></component> </KeepAlive> <!-- regex (use `v-bind`) --> <KeepAlive :include=\"/a|b/\"> <component :is=\"view\"></component> </KeepAlive> <!-- Array (use `v-bind`) --> <KeepAlive :include=\"['a', 'b']\"> <component :is=\"view\"></component> </KeepAlive> Usage max :template<KeepAlive :max=\"10\"> <component :is=\"view\"></component> </KeepAlive> See also Guide - KeepAlive <Teleport> Renders slot content another part DOM. Props tsinterface TeleportProps { /** * Required. Specify target container. * either selector actual element. */ to: string | HTMLElement /** * `true`, content remain original * location instead moved target container. * changed dynamically. */ disabled?: boolean /** * `true`, Teleport defer * parts application mounted * resolving target. (3.5+) */ defer?: boolean } Example Specifying target container: template<Teleport to=\"#some-id\" /> <Teleport to=\".some-class\" /> <Teleport to=\"[data-teleport]\" /> Conditionally disabling: template<Teleport to=\"#popup\" :disabled=\"displayVideoInline\"> <video src=\"./my-movie.mp4\"> </Teleport> Defer target resolution : template<Teleport defer to=\"#late-div\">...</Teleport> <!-- somewhere later template --> <div id=\"late-div\"></div> See also Guide - Teleport <Suspense> Used orchestrating nested async dependencies component tree. Props tsinterface SuspenseProps { timeout?: string | number suspensible?: boolean } Events @resolve @pending @fallback Details <Suspense> accepts two slots: the#default slot the#fallback slot. display content fallback slot rendering default slot memory.If encounters async dependencies (Async Components components async setup() ) rendering default slot, wait resolved displaying default slot.By setting Suspense suspensible , async dependency handling handled parent Suspense. See implementation detailsSee also Guide - Suspense"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Built-in Directives v-text Update element's text content. Expects: string Details v-text works setting element's textContent property, overwrite existing content inside element. need update part oftextContent , use mustache interpolations instead.Example template<span v-text=\"msg\"></span> <!-- --> <span>{{msg}}</span> See also Template Syntax - Text Interpolation v-html Update element's innerHTML. Expects: string Details Contents v-html inserted plain HTML - Vue template syntax processed. find trying compose templates usingv-html , try rethink solution using components instead.Security Note Dynamically rendering arbitrary HTML website dangerous easily lead XSS attacks. use v-html trusted content never user-provided content.In Single-File Components, scoped styles apply content insidev-html , HTML processed Vue's template compiler. want targetv-html content scoped CSS, instead use CSS modules additional, global<style> element manual scoping strategy BEM.Example template<div v-html=\"html\"></div> See also Template Syntax - Raw HTML v-show Toggle element's visibility based truthy-ness expression value. Expects: Details v-show works setting thedisplay CSS property via inline styles, try respect initialdisplay value element visible. also triggers transitions condition changes.See also Conditional Rendering - v-show v-if Conditionally render element template fragment based truthy-ness expression value. Expects: Details v-if element toggled, element contained directives / components destroyed re-constructed. initial condition falsy, inner content rendered all.Can used <template> denote conditional block containing text multiple elements.This directive triggers transitions condition changes. used together, v-if higher priority thanv-for . recommend using two directives together one element \u2014 see list rendering guide details.See also Conditional Rendering - v-if v-else Denote \"else block\" v-if v-if / v-else-if chain. expect expression Details Restriction: previous sibling element must v-if orv-else-if .Can used <template> denote conditional block containing text multiple elements. Example template<div v-if=\"Math.random() > 0.5\"> see </div> <div v-else> </div> See also Conditional Rendering - v-else v-else-if Denote \"else block\" v-if . chained. Expects: Details Restriction: previous sibling element must v-if orv-else-if .Can used <template> denote conditional block containing text multiple elements. Example template<div v-if=\"type === 'A'\"> </div> <div v-else-if=\"type === 'B'\"> B </div> <div v-else-if=\"type === 'C'\"> C </div> <div v-else> A/B/C </div> See also Conditional Rendering - v-else-if v-for Render element template block multiple times based source data. Expects: Array | Object | number | string | Iterable Details directive's value must use special syntax alias expression provide alias current element iterated on:template<div v-for=\"item items\"> {{ item.text }} </div> Alternatively, also specify alias index (or key used Object): template<div v-for=\"(item, index) items\"></div> <div v-for=\"(value, key) object\"></div> <div v-for=\"(value, name, index) object\"></div> default behavior v-for try patch elements in-place without moving them. force reorder elements, provide ordering hint thekey special attribute:template<div v-for=\"item items\" :key=\"item.id\"> {{ item.text }} </div> v-for also work values implement Iterable Protocol, including nativeMap andSet .See also v-on Attach event listener element. Shorthand: @ Expects: Function | Inline Statement | Object (without argument) Argument: event (optional using Object syntax)Modifiers .stop - callevent.stopPropagation() ..prevent - callevent.preventDefault() ..capture - add event listener capture mode..self - trigger handler event dispatched element..{keyAlias} - trigger handler certain keys..once - trigger handler once..left - trigger handler left button mouse events..right - trigger handler right button mouse events..middle - trigger handler middle button mouse events..passive - attaches DOM event with{ passive: true } . Details event type denoted argument. expression method name, inline statement, omitted modifiers present. used normal element, listens native DOM events only. used custom element component, listens custom events emitted child component. listening native DOM events, method receives native event argument. using inline statement, statement access special $event property:v-on:click=\"handle('ok', $event)\" .v-on also supports binding object event / listener pairs without argument. Note using object syntax, support modifiers.Example template<!-- method handler --> <button v-on:click=\"doThis\"></button> <!-- dynamic event --> <button v-on:[event]=\"doThis\"></button> <!-- inline statement --> <button v-on:click=\"doThat('hello', $event)\"></button> <!-- shorthand --> <button @click=\"doThis\"></button> <!-- shorthand dynamic event --> <button @[event]=\"doThis\"></button> <!-- stop propagation --> <button @click.stop=\"doThis\"></button> <!-- prevent default --> <button @click.prevent=\"doThis\"></button> <!-- prevent default without expression --> <form @submit.prevent></form> <!-- chain modifiers --> <button @click.stop.prevent=\"doThis\"></button> <!-- key modifier using keyAlias --> <input @keyup.enter=\"onEnter\" /> <!-- click event triggered --> <button v-on:click.once=\"doThis\"></button> <!-- object syntax --> <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button> Listening custom events child component (the handler called \"my-event\" emitted child): template<MyComponent @my-event=\"handleThis\" /> <!-- inline statement --> <MyComponent @my-event=\"handleThis(123, $event)\" /> See also v-bind Dynamically bind one attributes, component prop expression. Shorthand: : or. (when using.prop modifier)- Omitting value (when attribute bound value name, requires 3.4+) Expects: (with argument) | Object (without argument) Argument: attrOrProp (optional) Modifiers .camel - transform kebab-case attribute name camelCase..prop - force binding set DOM property (3.2+)..attr - force binding set DOM attribute (3.2+). Usage used bind class orstyle attribute,v-bind supports additional value types Array Objects. See linked guide section details.When setting binding element, Vue default checks whether element key defined property using operator check. property defined, Vue set value DOM property instead attribute. work cases, override behavior explicitly using.prop or.attr modifiers. sometimes necessary, especially working custom elements.When used component prop binding, prop must properly declared child component. used without argument, used bind object containing attribute name-value pairs. Example template<!-- bind attribute --> <img v-bind:src=\"imageSrc\" /> <!-- dynamic attribute name --> <button v-bind:[key]=\"value\"></button> <!-- shorthand --> <img :src=\"imageSrc\" /> <!-- same-name shorthand (3.4+), expands :src=\"src\" --> <img :src /> <!-- shorthand dynamic attribute name --> <button :[key]=\"value\"></button> <!-- inline string concatenation --> <img :src=\"'/path/to/images/' + fileName\" /> <!-- class binding --> <div :class=\"{ red: isRed }\"></div> <div :class=\"[classA, classB]\"></div> <div :class=\"[classA, { classB: isB, classC: isC }]\"></div> <!-- style binding --> <div :style=\"{ fontSize: size + 'px' }\"></div> <div :style=\"[styleObjectA, styleObjectB]\"></div> <!-- binding object attributes --> <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div> <!-- prop binding. \"prop\" must declared child component. --> <MyComponent :prop=\"someThing\" /> <!-- pass parent props common child component --> <MyComponent v-bind=\"$props\" /> <!-- XLink --> <svg><a :xlink:special=\"foo\"></a></svg> .prop modifier also dedicated shorthand,. :template<div :someProperty.prop=\"someObject\"></div> <!-- equivalent --> <div .someProperty=\"someObject\"></div> .camel modifier allows camelizing av-bind attribute name using in-DOM templates, e.g. SVGviewBox attribute:template<svg :view-box.camel=\"viewBox\"></svg> .camel needed using string templates, pre-compiling template build step.See also v-model Create two-way binding form input element component. Expects: varies based value form inputs element output components Limited to: <input> <select> <textarea> - components Modifiers See also v-slot Denote named slots scoped slots expect receive props. Shorthand: # Expects: JavaScript expression valid function argument position, including support destructuring. Optional - needed expecting props passed slot. Argument: slot name (optional, defaults default )Limited to: <template> - components (for lone default slot props) Example template<!-- Named slots --> <BaseLayout> <template v-slot:header> Header content </template> <template v-slot:default> Default slot content </template> <template v-slot:footer> Footer content </template> </BaseLayout> <!-- Named slot receives props --> <InfiniteScroll> <template v-slot:item=\"slotProps\"> <div class=\"item\"> {{ slotProps.item.text }} </div> </template> </InfiniteScroll> <!-- Default slot receive props, destructuring --> <Mouse v-slot=\"{ x, }\"> Mouse position: {{ x }}, {{ }} </Mouse> See also v-pre Skip compilation element children. expect expression Details Inside element v-pre , Vue template syntax preserved rendered as-is. common use case displaying raw mustache tags.Example template<span v-pre>{{ compiled }}</span> v-once Render element component only, skip future updates. expect expression Details subsequent re-renders, element/component children treated static content skipped. used optimize update performance. template<!-- single element --> <span v-once>This never change: {{msg}}</span> <!-- element children --> <div v-once> <h1>Comment</h1> <p>{{msg}}</p> </div> <!-- component --> <MyComponent v-once :comment=\"msg\"></MyComponent> <!-- `v-for` directive --> <ul> <li v-for=\"i list\" v-once>{{i}}</li> </ul> Since 3.2, also memoize part template invalidation conditions using v-memo .See also v-memo supported 3.2+ Expects: any[] Details Memoize sub-tree template. used elements components. directive expects fixed-length array dependency values compare memoization. every value array last render, updates entire sub-tree skipped. example: template<div v-memo=\"[valueA, valueB]\"> ... </div> component re-renders, valueA andvalueB remain same, updates this<div> children skipped. fact, even Virtual DOM VNode creation also skipped since memoized copy sub-tree reused.It important specify memoization array correctly, otherwise may skip updates indeed applied. v-memo empty dependency array (v-memo=\"[]\" ) would functionally equivalent tov-once .Usage v-for v-memo provided solely micro optimizations performance-critical scenarios rarely needed. common case may prove helpful rendering largev-for lists (wherelength > 1000 ):template<div v-for=\"item list\" :key=\"item.id\" v-memo=\"[item.id === selected]\"> <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p> <p>...more child nodes</p> </div> component's selected state changes, large amount VNodes created even though items remained exactly same. Thev-memo usage essentially saying \"only update item went non-selected selected, way around\". allows every unaffected item reuse previous VNode skip diffing entirely. Note need includeitem.id memo dependency array since Vue automatically infers item's:key .WARNING using v-memo withv-for , make sure used element.v-memo work insidev-for .v-memo also used components manually prevent unwanted updates certain edge cases child component update check de-optimized. again, developer's responsibility specify correct dependency arrays avoid skipping necessary updates.See also v-cloak Used hide un-compiled template ready. expect expression Details directive needed no-build-step setups. using in-DOM templates, \"flash un-compiled templates\": user may see raw mustache tags mounted component replaces rendered content. v-cloak remain element associated component instance mounted. Combined CSS rules as[v-cloak] { display: none } , used hide raw templates component ready.Example css[v-cloak] { display: none; } template<div v-cloak> {{ message }} </div> <div> visible compilation done."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Built-in Special Attributes key key special attribute primarily used hint Vue's virtual DOM algorithm identify vnodes diffing new list nodes old list. Expects: number | string | symbol Details Without keys, Vue uses algorithm minimizes element movement tries patch/reuse elements type in-place much possible. keys, reorder elements based order change keys, elements keys longer present always removed / destroyed. Children common parent must unique keys. Duplicate keys cause render errors. common use case combined v-for :template<ul> <li v-for=\"item items\" :key=\"item.id\">...</li> </ul> also used force replacement element/component instead reusing it. useful want to: - Properly trigger lifecycle hooks component - Trigger transitions example: template<transition> <span :key=\"text\">{{ text }}</span> </transition> text changes, the<span> always replaced instead patched, transition triggered.See also Guide - List Rendering - Maintaining State key ref Denotes template ref. Expects: string | Function Details ref used register reference element child component.In Options API, reference registered component's this.$refs object:template<!-- stored this.$refs.p --> <p ref=\"p\">hello</p> Composition API, reference stored ref matching name: vue<script setup> import { useTemplateRef } 'vue' const pRef = useTemplateRef('p') </script> <template> <p ref=\"p\">hello</p> </template> used plain DOM element, reference element; used child component, reference child component instance. Alternatively ref accept function value provides full control store reference:template<ChildComponent :ref=\"(el) => child = el\" /> important note ref registration timing: refs created result render function, must wait component mounted accessing them. this.$refs also non-reactive, therefore attempt use templates data-binding.See also Used binding dynamic components. Expects: string | Component Usage native elements - supported 3.1+ attribute used native HTML element, interpreted Customized built-in element, native web platform feature.There is, however, use case may need Vue replace native element Vue component, explained in-DOM Template Parsing Caveats. prefix value attribute withvue: Vue render element Vue component instead:template<table> <tr is=\"vue:my-row-component\"></tr> </table> See also"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Built-in Special Elements Components <component> , <slot> <template> component-like features part template syntax. true components compiled away template compilation. such, conventionally written lowercase templates. <component> \"meta component\" rendering dynamic components elements. Props tsinterface DynamicComponentProps { is: string | Component } Details actual component render determined prop.When string, could either HTML tag name component's registered name.Alternatively, also directly bound definition component. Example Rendering components registered name (Options API): vue<script> import Foo './Foo.vue' import Bar './Bar.vue' export default { components: { Foo, Bar }, data() { return { view: 'Foo' } } } </script> <template> <component :is=\"view\" /> </template> Rendering components definition (Composition API <script setup> ):vue<script setup> import Foo './Foo.vue' import Bar './Bar.vue' </script> <template> <component :is=\"Math.random() > 0.5 ? Foo : Bar\" /> </template> Rendering HTML elements: template<component :is=\"href ? 'a' : 'span'\"></component> built-in components passed , must register want pass name. example:vue<script> import { Transition, TransitionGroup } 'vue' export default { components: { Transition, TransitionGroup } } </script> <template> <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\"> ... </component> </template> Registration required pass component rather name, e.g. in<script setup> .If v-model used a<component> tag, template compiler expand amodelValue prop andupdate:modelValue event listener, much like would component. However, compatible native HTML elements, as<input> or<select> . result, usingv-model dynamically created native element work:vue<script setup> import { ref } 'vue' const tag = ref('input') const username = ref('') </script> <template> <!-- work 'input' native HTML element --> <component :is=\"tag\" v-model=\"username\" /> </template> practice, edge case common native form fields typically wrapped components real applications. need use native element directly split v-model attribute event manually.See also Dynamic Components <slot> Denotes slot content outlets templates. Props tsinterface SlotProps { /** * props passed <slot> passed arguments * scoped slots */ [key: string]: /** * Reserved specifying slot name. */ name?: string } Details <slot> element use thename attribute specify slot name. noname specified, render default slot. Additional attributes passed slot element passed slot props scoped slot defined parent.The element replaced matched slot content. <slot> elements Vue templates compiled JavaScript, confused native<slot> elements.See also Component - Slots <template> <template> tag used placeholder want use built-in directive without rendering element DOM. Details special handling <template> triggered used one directives:v-if ,v-else-if , orv-else v-for v-slot none directives present rendered native <template> element instead.A <template> av-for also akey attribute. attributes directives discarded, meaningful without corresponding element.Single-file components use top-level <template> tag wrap entire template. usage separate use of<template> described above. top-level tag part template support template syntax, directives.See also"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Compile-Time Flags TIP Compile-time flags apply using esm-bundler build Vue (i.e. vue/dist/vue.esm-bundler.js ). using Vue build step, possible configure number compile-time flags enable / disable certain features. benefit using compile-time flags features disabled way removed final bundle via tree-shaking. Vue work even flags explicitly configured. However, recommended always configure relevant features properly removed possible. See Configuration Guides configure depending build tool. __VUE_OPTIONS_API__ Default: true Enable / disable Options API support. Disabling result smaller bundles, may affect compatibility 3rd party libraries rely Options API. __VUE_PROD_DEVTOOLS__ Default: false Enable / disable devtools support production builds. result code included bundle, recommended enable debugging purposes. __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ Default: false Enable/disable detailed warnings hydration mismatches production builds. result code included bundle, recommended enable debugging purposes. available 3.4+ Configuration Guides Vite @vitejs/plugin-vue automatically provides default values flags. change default values, use Vite's define config option: js // vite.config.js import { defineConfig } 'vite' export default defineConfig({ define: { // enable hydration mismatch details production build __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'true' } }) vue-cli @vue/cli-service automatically provides default values flags. configure /change values: js // vue.config.js module.exports = { chainWebpack: (config) => { config.plugin('define').tap((definitions) => { Object.assign(definitions[0], { __VUE_OPTIONS_API__: 'true', __VUE_PROD_DEVTOOLS__: 'false', __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false' }) return definitions }) } } webpack Flags defined using webpack's DefinePlugin: js // webpack.config.js module.exports = { // ... plugins: [ new webpack.DefinePlugin({ __VUE_OPTIONS_API__: 'true', __VUE_PROD_DEVTOOLS__: 'false', __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false' }) ] } Rollup Flags defined using @rollup/plugin-replace: js // rollup.config.js import replace '@rollup/plugin-replace' export default { plugins: [ replace({ __VUE_OPTIONS_API__: 'true', __VUE_PROD_DEVTOOLS__: 'false', __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false' }) ] }"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Component Instance INFO page documents built-in properties methods exposed component public instance, i.e. . properties listed page readonly (except nested properties $data ). $data object returned data option, made reactive component. component instance proxies access properties data object. Type tsinterface ComponentPublicInstance { $data: object } $props object representing component's current, resolved props. Type tsinterface ComponentPublicInstance { $props: object } Details props declared via props option included. component instance proxies access properties props object. $el root DOM node component instance managing. Type tsinterface ComponentPublicInstance { $el: Node | undefined } Details $el beundefined component mounted.- components single root element, $el point element. - components text root, $el point text node. - components multiple root nodes, $el placeholder DOM node Vue uses keep track component's position DOM (a text node, comment node SSR hydration mode). TIP consistency, recommended use template refs direct access elements instead relying $el .- components single root element, $options resolved component options used instantiating current component instance. Type tsinterface ComponentPublicInstance { $options: ComponentOptions } Details $options object exposes resolved options current component merge result possible sources:- Global mixins - Component extends base - Component mixins typically used support custom component options: jsconst app = createApp({ customOption: 'foo', created() { console.log(this.$options.customOption) // => 'foo' } }) See also app.config.optionMergeStrategies $parent parent instance, current instance one. null root instance itself. Type tsinterface ComponentPublicInstance { $parent: ComponentPublicInstance | null } $root root component instance current component tree. current instance parents value itself. Type tsinterface ComponentPublicInstance { $root: ComponentPublicInstance } $slots object representing slots passed parent component. Type tsinterface ComponentPublicInstance { $slots: { [name: string]: Slot } } type Slot = (...args: any[]) => VNode[] Details Typically used manually authoring render functions, also used detect whether slot present. slot exposed this.$slots function returns array vnodes key corresponding slot's name. default slot exposed asthis.$slots.default .If slot scoped slot, arguments passed slot functions available slot slot props. See also Render Functions - Rendering Slots $refs object DOM elements component instances, registered via template refs. Type tsinterface ComponentPublicInstance { $refs: { [name: string]: Element | ComponentPublicInstance | null } } See also $attrs object contains component's fallthrough attributes. Type tsinterface ComponentPublicInstance { $attrs: object } Details Fallthrough Attributes attributes event handlers passed parent component, declared prop emitted event child. default, everything $attrs automatically inherited component's root element single root element. behavior disabled component multiple root nodes, explicitly disabled theinheritAttrs option.See also $watch() Imperative API creating watchers. Type tsinterface ComponentPublicInstance { $watch( source: string | (() => any), callback: WatchCallback, options?: WatchOptions ): StopHandle } type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void interface WatchOptions { immediate?: boolean // default: false deep?: boolean // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void } type StopHandle = () => void Details first argument watch source. component property name string, simple dot-delimited path string, getter function. second argument callback function. callback receives new value old value watched source. immediate : trigger callback immediately watcher creation. Old value beundefined first call.deep : force deep traversal source object, callback fires deep mutations. See Deep Watchers.flush : adjust callback's flush timing. See Callback Flush Timing andwatchEffect() .onTrack / onTrigger : debug watcher's dependencies. See Watcher Debugging. Example Watch property name: jsthis.$watch('a', (newVal, oldVal) => {}) Watch dot-delimited path: jsthis.$watch('a.b', (newVal, oldVal) => {}) Using getter complex expressions: jsthis.$watch( // every time expression `this.a + this.b` yields // different result, handler called. // watching computed property // without defining computed property itself. () => this.a + this.b, (newVal, oldVal) => {} ) Stopping watcher: jsconst unwatch = this.$watch('a', cb) // later... unwatch() See also $emit() Trigger custom event current instance. additional arguments passed listener's callback function. Type tsinterface ComponentPublicInstance { $emit(event: string, ...args: any[]): void } Example jsexport default { created() { // event this.$emit('foo') // additional arguments this.$emit('bar', 1, 2, 3) } } See also $forceUpdate() Force component instance re-render. Type tsinterface ComponentPublicInstance { $forceUpdate(): void } Details rarely needed given Vue's fully automatic reactivity system. cases may need explicitly created non-reactive component state using advanced reactivity APIs. $nextTick() Instance-bound version global nextTick() . Type tsinterface ComponentPublicInstance { $nextTick(callback?: (this: ComponentPublicInstance) => void): Promise<void> } Details difference global version nextTick() callback passed tothis.$nextTick() itsthis context bound current component instance.See also nextTick()"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composition API: Dependency Injection provide() Provides value injected descendant components. Type tsfunction provide<T>(key: InjectionKey<T> | string, value: T): void Details provide() takes two arguments: key, string symbol, value injected.When using TypeScript, key symbol casted InjectionKey - Vue provided utility type extendsSymbol , used sync value type betweenprovide() andinject() .Similar lifecycle hook registration APIs, provide() must called synchronously component'ssetup() phase.Example vue<script setup> import { ref, provide } 'vue' import { countSymbol } './injectionSymbols' // provide static value provide('path', '/project/') // provide reactive value const count = ref(0) provide('count', count) // provide Symbol keys provide(countSymbol, count) </script> See also inject() Injects value provided ancestor component application (via app.provide() ). Type ts// without default value function inject<T>(key: InjectionKey<T> | string): | undefined // default value function inject<T>(key: InjectionKey<T> | string, defaultValue: T): // factory function inject<T>( key: InjectionKey<T> | string, defaultValue: () => T, treatDefaultAsFactory: true ): Details first argument injection key. Vue walk parent chain locate provided value matching key. multiple components parent chain provides key, one closest injecting component \"shadow\" higher chain. value matching key found, inject() returnsundefined unless default value provided.The second argument optional default value used matching value found. second argument also factory function returns values expensive create. case, true must passed third argument indicate function used factory instead value itself.Similar lifecycle hook registration APIs, inject() must called synchronously component'ssetup() phase.When using TypeScript, key type InjectionKey - Vue-provided utility type extendsSymbol , used sync value type betweenprovide() andinject() .Example Assuming parent component provided values shown previous provide() example:vue<script setup> import { inject } 'vue' import { countSymbol } './injectionSymbols' // inject static value without default const path = inject('path') // inject reactive value const count = inject('count') // inject Symbol keys const count2 = inject(countSymbol) // inject default value const bar = inject('path', '/default-path') // inject function default value const fn = inject('function', () => {}) // inject default value factory const baz = inject('factory', () => new ExpensiveObject(), true) </script> See also hasInjectionContext() - supported 3.3+ Returns true inject() used without warning called wrong place (e.g. outside setup() ). method designed used libraries want use inject() internally without triggering warning end user. Type tsfunction hasInjectionContext(): boolean"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composition API: Helpers useAttrs() Returns attrs object Setup Context, includes fallthrough attributes current component. intended used <script setup> setup context object available. Type tsfunction useAttrs(): Record<string, unknown> useSlots() Returns slots object Setup Context, includes parent passed slots callable functions return Virtual DOM nodes. intended used <script setup> setup context object available. using TypeScript, defineSlots() preferred instead. Type tsfunction useSlots(): Record<string, (...args: any[]) => VNode[]> useModel() underlying helper powers defineModel() . using <script setup> , defineModel() preferred instead. available 3.4+ Type tsfunction useModel( props: Record<string, any>, key: string, options?: DefineModelOptions ): ModelRef type DefineModelOptions<T = any> = { get?: (v: T) => set?: (v: T) => } type ModelRef<T, extends PropertyKey = string, G = T, = T> = Ref<G, S> & [ ModelRef<T, M, G, S>, Record<M, true | undefined> ] Example jsexport default { props: ['count'], emits: ['update:count'], setup(props) { const msg = useModel(props, 'count') msg.value = 1 } } Details useModel() used non-SFC components, e.g. using rawsetup() function. expects theprops object first argument, model name second argument. optional third argument used declare custom getter setter resulting model ref. Note unlikedefineModel() , responsible declaring props emits yourself. useTemplateRef() Returns shallow ref whose value synced template element component matching ref attribute. Type tsfunction useTemplateRef<T>(key: string): Readonly<ShallowRef<T | null>> Example vue<script setup> import { useTemplateRef, onMounted } 'vue' const inputRef = useTemplateRef('input') onMounted(() => { inputRef.value.focus() }) </script> <template> <input ref=\"input\" /> </template> See also useId() Used generate unique-per-application IDs accessibility attributes form elements. Type tsfunction useId(): string Example vue<script setup> import { useId } 'vue' const id = useId() </script> <template> <form> <label :for=\"id\">Name:</label> <input :id=\"id\" type=\"text\" /> </form> </template> Details IDs generated useId() unique-per-application. used generate IDs form elements accessibility attributes. Multiple calls component generate different IDs; multiple instances component callinguseId() also different IDs.IDs generated useId() also guaranteed stable across server client renders, used SSR applications without leading hydration mismatches.If one Vue application instance page, avoid ID conflicts giving app ID prefix via app.config.idPrefix ."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composition API: Lifecycle Hooks Usage Note APIs listed page must called synchronously setup() phase component. See Guide - Lifecycle Hooks details. onMounted() Registers callback called component mounted. Type tsfunction onMounted(callback: () => void): void Details component considered mounted after: synchronous child components mounted (does include async components components inside <Suspense> trees).Its DOM tree created inserted parent container. Note guarantees component's DOM tree in-document application's root container also in-document. hook typically used performing side effects need access component's rendered DOM, limiting DOM-related code client server-rendered application. hook called server-side rendering. Example Accessing element via template ref: vue<script setup> import { ref, onMounted } 'vue' const el = ref() onMounted(() => { el.value // <div> }) </script> <template> <div ref=\"el\"></div> </template> onUpdated() Registers callback called component updated DOM tree due reactive state change. Type tsfunction onUpdated(callback: () => void): void Details parent component's updated hook called child components. hook called DOM update component, caused different state changes, multiple state changes batched single render cycle performance reasons. need access updated DOM specific state change, use nextTick() instead. hook called server-side rendering. WARNING mutate component state updated hook - likely lead infinite update loop! Example Accessing updated DOM: vue<script setup> import { ref, onUpdated } 'vue' const count = ref(0) onUpdated(() => { // text content current `count.value` console.log(document.getElementById('count').textContent) }) </script> <template> <button id=\"count\" @click=\"count++\">{{ count }}</button> </template> onUnmounted() Registers callback called component unmounted. Type tsfunction onUnmounted(callback: () => void): void Details component considered unmounted after: child components unmounted. associated reactive effects (render effect computed / watchers created setup() ) stopped. Use hook clean manually created side effects timers, DOM event listeners server connections. hook called server-side rendering. Example vue<script setup> import { onMounted, onUnmounted } 'vue' let intervalId onMounted(() => { intervalId = setInterval(() => { // ... }) }) onUnmounted(() => clearInterval(intervalId)) </script> onBeforeMount() Registers hook called right component mounted. Type tsfunction onBeforeMount(callback: () => void): void Details hook called, component finished setting reactive state, DOM nodes created yet. execute DOM render effect first time. hook called server-side rendering. onBeforeUpdate() Registers hook called right component update DOM tree due reactive state change. Type tsfunction onBeforeUpdate(callback: () => void): void Details hook used access DOM state Vue updates DOM. also safe modify component state inside hook. hook called server-side rendering. onBeforeUnmount() Registers hook called right component instance unmounted. Type tsfunction onBeforeUnmount(callback: () => void): void Details hook called, component instance still fully functional. hook called server-side rendering. onErrorCaptured() Registers hook called error propagating descendant component captured. Type tsfunction onErrorCaptured(callback: ErrorCapturedHook): void type ErrorCapturedHook = ( err: unknown, instance: ComponentPublicInstance | null, info: string ) => boolean | void Details Errors captured following sources: - Component renders - Event handlers - Lifecycle hooks setup() function- Watchers - Custom directive hooks - Transition hooks hook receives three arguments: error, component instance triggered error, information string specifying error source type. TIP production, 3rd argument ( info ) shortened code instead full information string. find code string mapping Production Error Code Reference.You modify component state errorCaptured() display error state user. However, important error state render original content caused error; otherwise component thrown infinite render loop.The hook return false stop error propagating further. See error propagation details below.Error Propagation Rules default, errors still sent application-level app.config.errorHandler defined, errors still reported analytics service single place.If multiple errorCaptured hooks exist component's inheritance chain parent chain, invoked error, order bottom top. similar bubbling mechanism native DOM events.If errorCaptured hook throws error, error original captured error sent toapp.config.errorHandler .An errorCaptured hook returnfalse prevent error propagating further. essentially saying \"this error handled ignored.\" prevent additionalerrorCaptured hooks orapp.config.errorHandler invoked error. onRenderTracked() Registers debug hook called reactive dependency tracked component's render effect. hook development-mode-only called server-side rendering. Type tsfunction onRenderTracked(callback: DebuggerHook): void type DebuggerHook = (e: DebuggerEvent) => void type DebuggerEvent = { effect: ReactiveEffect target: object type: TrackOpTypes /* 'get' | 'has' | 'iterate' */ key: } See also Reactivity Depth onRenderTriggered() Registers debug hook called reactive dependency triggers component's render effect re-run. hook development-mode-only called server-side rendering. Type tsfunction onRenderTriggered(callback: DebuggerHook): void type DebuggerHook = (e: DebuggerEvent) => void type DebuggerEvent = { effect: ReactiveEffect target: object type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */ key: newValue?: oldValue?: oldTarget?: Map<any, any> | Set<any> } See also Reactivity Depth onActivated() Registers callback called component instance inserted DOM part tree cached <KeepAlive> . hook called server-side rendering. Type tsfunction onActivated(callback: () => void): void See also Guide - Lifecycle Cached Instance onDeactivated() Registers callback called component instance removed DOM part tree cached <KeepAlive> . hook called server-side rendering. Type tsfunction onDeactivated(callback: () => void): void See also Guide - Lifecycle Cached Instance onServerPrefetch() Registers async function resolved component instance rendered server. Type tsfunction onServerPrefetch(callback: () => Promise<any>): void Details callback returns Promise, server renderer wait Promise resolved rendering component. hook called server-side rendering used perform server-only data fetching. Example vue<script setup> import { ref, onServerPrefetch, onMounted } 'vue' const data = ref(null) onServerPrefetch(async () => { // component rendered part initial request // pre-fetch data server faster client data.value = await fetchOnServer(/* ... */) }) onMounted(async () => { (!data.value) { // data null mount, means component // dynamically rendered client. Perform // client-side fetch instead. data.value = await fetchOnClient(/* ... */) } }) </script> See also Server-Side Rendering"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composition API: setup() Basic Usage setup() hook serves entry point Composition API usage components following cases: - Using Composition API without build step; - Integrating Composition-API-based code Options API component. Note using Composition API Single-File Components, <script setup> strongly recommended succinct ergonomic syntax. declare reactive state using Reactivity APIs expose template returning object setup() . properties returned object also made available component instance (if options used): vue <script> import { ref } 'vue' export default { setup() { const count = ref(0) // expose template options API hooks return { count } }, mounted() { console.log(this.count) // 0 } } </script> <template> <button @click=\"count++\">{{ count }}</button> </template> refs returned setup automatically shallow unwrapped accessed template need use .value accessing them. also unwrapped way accessed . setup() access component instance - value undefined inside setup() . access Composition-API-exposed values Options API, way around. setup() return object synchronously. case async setup() used component descendant Suspense component. Accessing Props first argument setup function props argument. would expect standard component, props inside setup function reactive updated new props passed in. js export default { props: { title: String }, setup(props) { console.log(props.title) } } Note destructure props object, destructured variables lose reactivity. therefore recommended always access props form props.xxx . really need destructure props, need pass prop external function retaining reactivity, toRefs() toRef() utility APIs: js import { toRefs, toRef } 'vue' export default { setup(props) { // turn `props` object refs, destructure const { title } = toRefs(props) // `title` ref tracks `props.title` console.log(title.value) // OR, turn single property `props` ref const title = toRef(props, 'title') } } Setup Context second argument passed setup function Setup Context object. context object exposes values may useful inside setup : js export default { setup(props, context) { // Attributes (Non-reactive object, equivalent $attrs) console.log(context.attrs) // Slots (Non-reactive object, equivalent $slots) console.log(context.slots) // Emit events (Function, equivalent $emit) console.log(context.emit) // Expose public properties (Function) console.log(context.expose) } } context object reactive safely destructured: js export default { setup(props, { attrs, slots, emit, expose }) { ... } } attrs slots stateful objects always updated component updated. means avoid destructuring always reference properties attrs.x slots.x . Also note that, unlike props , properties attrs slots reactive. intend apply side effects based changes attrs slots , inside onBeforeUpdate lifecycle hook. Exposing Public Properties expose function used explicitly limit properties exposed component instance accessed parent component via template refs: js export default { setup(props, { expose }) { // make instance \"closed\" - // i.e. expose anything parent expose() const publicCount = ref(0) const privateCount = ref(0) // selectively expose local state expose({ count: publicCount }) } } Usage Render Functions setup also return render function directly make use reactive state declared scope: js import { h, ref } 'vue' export default { setup() { const count = ref(0) return () => h('div', count.value) } } Returning render function prevents us returning anything else. Internally problem, problematic want expose methods component parent component via template refs. solve problem calling expose() : js import { h, ref } 'vue' export default { setup(props, { expose }) { const count = ref(0) const increment = () => ++count.value expose({ increment }) return () => h('div', count.value) } } increment method would available parent component via template ref."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Custom Elements API defineCustomElement() method accepts argument defineComponent , instead returns native Custom Element class constructor. Type tsfunction defineCustomElement( component: | (ComponentOptions & CustomElementsOptions) | ComponentOptions['setup'], options?: CustomElementsOptions ): { new (props?: object): HTMLElement } interface CustomElementsOptions { styles?: string[] // following options 3.5+ configureApp?: (app: App) => void shadowRoot?: boolean nonce?: string } Type simplified readability. Details addition normal component options, defineCustomElement() also supports number options custom-elements-specific:styles : array inlined CSS strings providing CSS injected element's shadow root.configureApp : function used configure Vue app instance custom element.shadowRoot :boolean , defaults totrue . Set tofalse render custom element without shadow root. means<style> custom element SFCs longer encapsulated.nonce :string , provided, set thenonce attribute style tags injected shadow root. Note instead passed part component itself, options also passed via second argument: jsimport Element './MyElement.ce.vue' defineCustomElement(Element, { configureApp(app) { // ... } }) return value custom element constructor registered using customElements.define() .Example jsimport { defineCustomElement } 'vue' const MyVueElement = defineCustomElement({ /* component options */ }) // Register custom element. customElements.define('my-vue-element', MyVueElement) See also Also note defineCustomElement() requires special config used Single-File Components. useHost() Composition API helper returns host element current Vue custom element. useShadowRoot() Composition API helper returns shadow root current Vue custom element. this.$host Options API property exposes host element current Vue custom element."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Custom Renderer API createRenderer() Creates custom renderer. providing platform-specific node creation manipulation APIs, leverage Vue's core runtime target non-DOM environments. Type tsfunction createRenderer<HostNode, HostElement>( options: RendererOptions<HostNode, HostElement> ): Renderer<HostElement> interface Renderer<HostElement> { render: RootRenderFunction<HostElement> createApp: CreateAppFunction<HostElement> } interface RendererOptions<HostNode, HostElement> { patchProp( el: HostElement, key: string, prevValue: any, nextValue: any, // rest unused custom renderers isSVG?: boolean, prevChildren?: VNode<HostNode, HostElement>[], parentComponent?: ComponentInternalInstance | null, parentSuspense?: SuspenseBoundary | null, unmountChildren?: UnmountChildrenFn ): void insert( el: HostNode, parent: HostElement, anchor?: HostNode | null ): void remove(el: HostNode): void createElement( type: string, isSVG?: boolean, isCustomizedBuiltIn?: string, vnodeProps?: (VNodeProps & { [key: string]: }) | null ): HostElement createText(text: string): HostNode createComment(text: string): HostNode setText(node: HostNode, text: string): void setElementText(node: HostElement, text: string): void parentNode(node: HostNode): HostElement | null nextSibling(node: HostNode): HostNode | null // optional, DOM-specific querySelector?(selector: string): HostElement | null setScopeId?(el: HostElement, id: string): void cloneNode?(node: HostNode): HostNode insertStaticContent?( content: string, parent: HostElement, anchor: HostNode | null, isSVG: boolean ): [HostNode, HostNode] } Example jsimport { createRenderer } '@vue/runtime-core' const { render, createApp } = createRenderer({ patchProp, insert, remove, createElement // ... }) // `render` low-level API // `createApp` returns app instance export { render, createApp } // re-export Vue core APIs export * '@vue/runtime-core' Vue's @vue/runtime-dom implemented using API. simpler implementation, check out@vue/runtime-test private package Vue's unit testing."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Global API: General version Exposes current version Vue. Type: string Example jsimport { version } 'vue' console.log(version) nextTick() utility waiting next DOM update flush. Type tsfunction nextTick(callback?: () => void): Promise<void> Details mutate reactive state Vue, resulting DOM updates applied synchronously. Instead, Vue buffers \"next tick\" ensure component updates matter many state changes made. nextTick() used immediately state change wait DOM updates complete. either pass callback argument, await returned Promise.Example vue<script setup> import { ref, nextTick } 'vue' const count = ref(0) async function increment() { count.value++ // DOM yet updated console.log(document.getElementById('counter').textContent) // 0 await nextTick() // DOM updated console.log(document.getElementById('counter').textContent) // 1 } </script> <template> <button id=\"counter\" @click=\"increment\">{{ count }}</button> </template> See also this.$nextTick() defineComponent() type helper defining Vue component type inference. Type ts// options syntax function defineComponent( component: ComponentOptions ): ComponentConstructor // function syntax (requires 3.3+) function defineComponent( setup: ComponentOptions['setup'], extraOptions?: ComponentOptions ): () => Type simplified readability. Details first argument expects component options object. return value options object, since function essentially runtime no-op type inference purposes only. Note return type bit special: constructor type whose instance type inferred component instance type based options. used type inference returned type used tag TSX. extract instance type component (equivalent type options) return type ofdefineComponent() like this:tsconst Foo = defineComponent(/* ... */) type FooInstance = InstanceType<typeof Foo> Function Signature - supported 3.3+ defineComponent() also alternative signature meant used Composition API render functions JSX.Instead passing options object, function expected instead. function works Composition API setup() function: receives props setup context. return value render function - bothh() JSX supported:jsimport { ref, h } 'vue' const Comp = defineComponent( (props) => { // use Composition API like <script setup> const count = ref(0) return () => { // render function JSX return h('div', count.value) } }, // extra options, e.g. declare props emits { props: { /* ... */ } } ) main use case signature TypeScript (and particular TSX), supports generics: tsxconst Comp = defineComponent( <T extends string | number>(props: { msg: T; list: T[] }) => { // use Composition API like <script setup> const count = ref(0) return () => { // render function JSX return <div>{count.value}</div> } }, // manual runtime props declaration currently still needed. { props: ['msg', 'list'] } ) future, plan provide Babel plugin automatically infers injects runtime props (like defineProps SFCs) runtime props declaration omitted.Note webpack Treeshaking defineComponent() function call, could look like would produce side-effects build tools, e.g. webpack. prevent component tree-shaken even component never used.To tell webpack function call safe tree-shaken, add /*#__PURE__*/ comment notation function call:jsexport default /*#__PURE__*/ defineComponent(/* ... */) Note necessary using Vite, Rollup (the underlying production bundler used Vite) smart enough determine defineComponent() fact side-effect-free without need manual annotations.See also Guide - Using Vue TypeScript defineAsyncComponent() Define async component lazy loaded rendered. argument either loader function, options object advanced control loading behavior. Type tsfunction defineAsyncComponent( source: AsyncComponentLoader | AsyncComponentOptions ): Component type AsyncComponentLoader = () => Promise<Component> interface AsyncComponentOptions { loader: AsyncComponentLoader loadingComponent?: Component errorComponent?: Component delay?: number timeout?: number suspensible?: boolean onError?: ( error: Error, retry: () => void, fail: () => void, attempts: number ) => } See also Guide - Async Components"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Options: Composition provide Provide values injected descendant components. Type tsinterface ComponentOptions { provide?: object | ((this: ComponentPublicInstance) => object) } Details provide andinject used together allow ancestor component serve dependency injector descendants, regardless deep component hierarchy is, long parent chain.The provide option either object function returns object. object contains properties available injection descendants. use Symbols keys object.Example Basic usage: jsconst = Symbol() export default { provide: { foo: 'foo', [s]: 'bar' } } Using function provide per-component state: jsexport default { data() { return { msg: 'foo' } } provide() { return { msg: this.msg } } } Note example, provided msg reactive. See Working Reactivity details.See also Provide / Inject inject Declare properties inject current component locating ancestor providers. Type tsinterface ComponentOptions { inject?: ArrayInjectOptions | ObjectInjectOptions } type ArrayInjectOptions = string[] type ObjectInjectOptions = { [key: string | symbol]: | string | symbol | { from?: string | symbol; default?: } } Details inject option either:- array strings, - object keys local binding name value either: - key (string Symbol) search available injections, - object where: - property key (string Symbol) search available injections, - default property used fallback value. Similar props default values, factory function needed object types avoid value sharing multiple component instances. - injected property undefined neither matching property default value provided.Note injected bindings reactive. intentional. However, injected value reactive object, properties object remain reactive. See Working Reactivity details. Example Basic usage: jsexport default { inject: ['foo'], created() { console.log(this.foo) } } Using injected value default prop: jsconst Child = { inject: ['foo'], props: { bar: { default() { return this.foo } } } } Using injected value data entry: jsconst Child = { inject: ['foo'], data() { return { bar: this.foo } } } Injections optional default value: jsconst Child = { inject: { foo: { default: 'foo' } } } needs injected property different name, use denote source property:jsconst Child = { inject: { foo: { from: 'bar', default: 'foo' } } } Similar prop defaults, need use factory function non-primitive values: jsconst Child = { inject: { foo: { from: 'bar', default: () => [1, 2, 3] } } } See also Provide / Inject mixins array option objects mixed current component. Type tsinterface ComponentOptions { mixins?: ComponentOptions[] } Details mixins option accepts array mixin objects. mixin objects contain instance options like normal instance objects, merged eventual options using certain option merging logic. example, mixin contains acreated hook component also one, functions called.Mixin hooks called order provided, called component's hooks. Longer Recommended Vue 2, mixins primary mechanism creating reusable chunks component logic. mixins continue supported Vue 3, Composable functions using Composition API preferred approach code reuse components. Example jsconst mixin = { created() { console.log(1) } } createApp({ created() { console.log(2) }, mixins: [mixin] }) // => 1 // => 2 extends \"base class\" component extend from. Type tsinterface ComponentOptions { extends?: ComponentOptions } Details Allows one component extend another, inheriting component options. implementation perspective, extends almost identical tomixins . component specified byextends treated though first mixin.However, extends andmixins express different intents. Themixins option primarily used compose chunks functionality, whereasextends primarily concerned inheritance.As mixins , options (except forsetup() ) merged using relevant merge strategy.Example jsconst CompA = { ... } const CompB = { extends: CompA, ... } Recommended Composition API extends designed Options API handle merging thesetup() hook.In Composition API, preferred mental model logic reuse \"compose\" \"inheritance\". logic component needs reused another one, consider extracting relevant logic Composable. still intend \"extend\" component using Composition API, call base component's setup() extending component'ssetup() :jsimport Base './Base.js' export default { extends: Base, setup(props, ctx) { return { ...Base.setup(props, ctx), // local bindings } } }"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Options: Lifecycle See also shared usage lifecycle hooks, see Guide - Lifecycle Hooks beforeCreate Called instance initialized. Type tsinterface ComponentOptions { beforeCreate?(this: ComponentPublicInstance): void } Details Called immediately instance initialized props resolved. props defined reactive properties state data() orcomputed set up.Note setup() hook Composition API called Options API hooks, evenbeforeCreate() . created Called instance finished processing state-related options. Type tsinterface ComponentOptions { created?(this: ComponentPublicInstance): void } Details hook called, following set up: reactive data, computed properties, methods, watchers. However, mounting phase started, $el property available yet. beforeMount Called right component mounted. Type tsinterface ComponentOptions { beforeMount?(this: ComponentPublicInstance): void } Details hook called, component finished setting reactive state, DOM nodes created yet. execute DOM render effect first time. hook called server-side rendering. mounted Called component mounted. Type tsinterface ComponentOptions { mounted?(this: ComponentPublicInstance): void } Details component considered mounted after: synchronous child components mounted (does include async components components inside <Suspense> trees).Its DOM tree created inserted parent container. Note guarantees component's DOM tree in-document application's root container also in-document. hook typically used performing side effects need access component's rendered DOM, limiting DOM-related code client server-rendered application. hook called server-side rendering. beforeUpdate Called right component update DOM tree due reactive state change. Type tsinterface ComponentOptions { beforeUpdate?(this: ComponentPublicInstance): void } Details hook used access DOM state Vue updates DOM. also safe modify component state inside hook. hook called server-side rendering. updated Called component updated DOM tree due reactive state change. Type tsinterface ComponentOptions { updated?(this: ComponentPublicInstance): void } Details parent component's updated hook called child components. hook called DOM update component, caused different state changes. need access updated DOM specific state change, use nextTick() instead. hook called server-side rendering. WARNING mutate component state updated hook - likely lead infinite update loop! beforeUnmount Called right component instance unmounted. Type tsinterface ComponentOptions { beforeUnmount?(this: ComponentPublicInstance): void } Details hook called, component instance still fully functional. hook called server-side rendering. unmounted Called component unmounted. Type tsinterface ComponentOptions { unmounted?(this: ComponentPublicInstance): void } Details component considered unmounted after: child components unmounted. associated reactive effects (render effect computed / watchers created setup() ) stopped. Use hook clean manually created side effects timers, DOM event listeners server connections. hook called server-side rendering. errorCaptured Called error propagating descendant component captured. Type tsinterface ComponentOptions { errorCaptured?( this: ComponentPublicInstance, err: unknown, instance: ComponentPublicInstance | null, info: string ): boolean | void } Details Errors captured following sources: - Component renders - Event handlers - Lifecycle hooks setup() function- Watchers - Custom directive hooks - Transition hooks hook receives three arguments: error, component instance triggered error, information string specifying error source type. TIP production, 3rd argument ( info ) shortened code instead full information string. find code string mapping Production Error Code Reference.You modify component state errorCaptured() display error state user. However, important error state render original content caused error; otherwise component thrown infinite render loop.The hook return false stop error propagating further. See error propagation details below.Error Propagation Rules default, errors still sent application-level app.config.errorHandler defined, errors still reported analytics service single place.If multiple errorCaptured hooks exist component's inheritance chain parent chain, invoked error, order bottom top. similar bubbling mechanism native DOM events.If errorCaptured hook throws error, error original captured error sent toapp.config.errorHandler .An errorCaptured hook returnfalse prevent error propagating further. essentially saying \"this error handled ignored.\" prevent additionalerrorCaptured hooks orapp.config.errorHandler invoked error. renderTracked Called reactive dependency tracked component's render effect. hook development-mode-only called server-side rendering. Type tsinterface ComponentOptions { renderTracked?(this: ComponentPublicInstance, e: DebuggerEvent): void } type DebuggerEvent = { effect: ReactiveEffect target: object type: TrackOpTypes /* 'get' | 'has' | 'iterate' */ key: } See also Reactivity Depth renderTriggered Called reactive dependency triggers component's render effect re-run. hook development-mode-only called server-side rendering. Type tsinterface ComponentOptions { renderTriggered?(this: ComponentPublicInstance, e: DebuggerEvent): void } type DebuggerEvent = { effect: ReactiveEffect target: object type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */ key: newValue?: oldValue?: oldTarget?: Map<any, any> | Set<any> } See also Reactivity Depth activated Called component instance inserted DOM part tree cached <KeepAlive> . hook called server-side rendering. Type tsinterface ComponentOptions { activated?(this: ComponentPublicInstance): void } See also Guide - Lifecycle Cached Instance deactivated Called component instance removed DOM part tree cached <KeepAlive> . hook called server-side rendering. Type tsinterface ComponentOptions { deactivated?(this: ComponentPublicInstance): void } See also Guide - Lifecycle Cached Instance serverPrefetch Async function resolved component instance rendered server. Type tsinterface ComponentOptions { serverPrefetch?(this: ComponentPublicInstance): Promise<any> } Details hook returns Promise, server renderer wait Promise resolved rendering component. hook called server-side rendering used perform server-only data fetching. Example jsexport default { data() { return { data: null } }, async serverPrefetch() { // component rendered part initial request // pre-fetch data server faster client this.data = await fetchOnServer(/* ... */) }, async mounted() { (!this.data) { // data null mount, means component // dynamically rendered client. Perform // client-side fetch instead. this.data = await fetchOnClient(/* ... */) } } } See also Server-Side Rendering"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Options: Misc name Explicitly declare display name component. Type tsinterface ComponentOptions { name?: string } Details name component used following: - Recursive self-reference component's template - Display Vue DevTools' component inspection tree - Display warning component traces use Single-File Components, component already infers name filename. example, file named MyComponent.vue inferred display name \"MyComponent\".Another case component registered globally app.component , global ID automatically set name.The name option allows override inferred name, explicitly provide name name inferred (e.g. using build tools, inlined non-SFC component).There one case name explicitly necessary: matching cacheable components in<KeepAlive> via itsinclude / exclude props.TIP Since version 3.2.34, single-file component using <script setup> automatically infer itsname option based filename, removing need manually declare name even used with<KeepAlive> . inheritAttrs Controls whether default component attribute fallthrough behavior enabled. Type tsinterface ComponentOptions { inheritAttrs?: boolean // default: true } Details default, parent scope attribute bindings recognized props \"fallthrough\". means single-root component, bindings applied root element child component normal HTML attributes. authoring component wraps target element another component, may always desired behavior. setting inheritAttrs tofalse , default behavior disabled. attributes available via the$attrs instance property explicitly bound non-root element usingv-bind .Example declaring option component uses <script setup> , use thedefineOptions macro:vue<script setup> defineProps(['label', 'value']) defineEmits(['input']) defineOptions({ inheritAttrs: false }) </script> <template> <label> {{ label }} <input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" /> </label> </template> See also components object registers components made available component instance. Type tsinterface ComponentOptions { components?: { [key: string]: Component } } Example jsimport Foo './Foo.vue' import Bar './Bar.vue' export default { components: { // shorthand Foo, // register different name RenamedBar: Bar } } See also Component Registration directives object registers directives made available component instance. Type tsinterface ComponentOptions { directives?: { [key: string]: Directive } } Example jsexport default { directives: { // enables v-focus template focus: { mounted(el) { el.focus() } } } } template<input v-focus> See also Custom Directives"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Options: Rendering template string template component. Type tsinterface ComponentOptions { template?: string } Details template provided via template option compiled on-the-fly runtime. supported using build Vue includes template compiler. template compiler included Vue builds wordruntime names, e.g.vue.runtime.esm-bundler.js . Consult dist file guide details different builds.If string starts # used aquerySelector use selected element'sinnerHTML template string. allows source template authored using native<template> elements.If render option also present component,template ignored.If root component application template orrender option specified, Vue try use theinnerHTML mounted element template instead.Security Note use template sources trust. use user-provided content template. See Security Guide details. render function programmatically returns virtual DOM tree component. Type tsinterface ComponentOptions { render?(this: ComponentPublicInstance) => VNodeChild } type VNodeChild = VNodeChildAtom | VNodeArrayChildren type VNodeChildAtom = | VNode | string | number | boolean | null | undefined | void type VNodeArrayChildren = (VNodeArrayChildren | VNodeChildAtom)[] Details render alternative string templates allows leverage full programmatic power JavaScript declare render output component.Pre-compiled templates, example Single-File Components, compiled render option build time. bothrender andtemplate present component,render take higher priority.See also compilerOptions Configure runtime compiler options component's template. Type tsinterface ComponentOptions { compilerOptions?: { isCustomElement?: (tag: string) => boolean whitespace?: 'condense' | 'preserve' // default: 'condense' delimiters?: [string, string] // default: ['{{', '}}'] comments?: boolean // default: false } } Details config option respected using full build (i.e. standalone vue.js compile templates browser). supports options app-level app.config.compilerOptions, higher priority current component.See also app.config.compilerOptions slots - supported 3.3+ option assist type inference using slots programmatically render functions. Details option's runtime value used. actual types declared via type casting using SlotsType type helper:tsimport { SlotsType } 'vue' defineComponent({ slots: Object SlotsType<{ default: { foo: string; bar: number } item: { data: number } }>, setup(props, { slots }) { expectType< undefined | ((scope: { foo: string; bar: number }) => any) >(slots.default) expectType<undefined | ((scope: { data: number }) => any)>( slots.item ) } })"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Options: State data function returns initial reactive state component instance. Type tsinterface ComponentOptions { data?( this: ComponentPublicInstance, vm: ComponentPublicInstance ): object } Details function expected return plain JavaScript object, made reactive Vue. instance created, reactive data object accessed this.$data . component instance also proxies properties found data object, sothis.a equivalent tothis.$data.a .All top-level data properties must included returned data object. Adding new properties this.$data possible, recommended. desired value property yet available empty value asundefined ornull included placeholder ensure Vue knows property exists.Properties start _ or$ proxied component instance may conflict Vue's internal properties API methods. access asthis.$data._property .It recommended return objects stateful behavior like browser API objects prototype properties. returned object ideally plain object represents state component. Example jsexport default { data() { return { a: 1 } }, created() { console.log(this.a) // 1 console.log(this.$data) // { a: 1 } } } Note use arrow function data property,this component's instance, still access instance function's first argument:jsdata: (vm) => ({ a: vm.myProp }) See also Reactivity Depth props Declare props component. Type tsinterface ComponentOptions { props?: ArrayPropsOptions | ObjectPropsOptions } type ArrayPropsOptions = string[] type ObjectPropsOptions = { [key: string]: Prop } type Prop<T = any> = PropOptions<T> | PropType<T> | null interface PropOptions<T> { type?: PropType<T> required?: boolean default?: | ((rawProps: object) => T) validator?: (value: unknown, rawProps: object) => boolean } type PropType<T> = { new (): } | { new (): }[] Types simplified readability. Details Vue, component props need explicitly declared. Component props declared two forms: - Simple form using array strings - Full form using object property key name prop, value prop's type (a constructor function) advanced options. object-based syntax, prop define following options: type : one following native constructors:String ,Number ,Boolean ,Array ,Object ,Date ,Function ,Symbol , custom constructor function array those. development mode, Vue check prop's value matches declared type, throw warning doesn't. See Prop Validation details.Also note prop Boolean type affects value casting behavior development production. See Boolean Casting details.default : Specifies default value prop passed parent hasundefined value. Object array defaults must returned using factory function. factory function also receives raw props object argument.required : Defines prop required. non-production environment, console warning thrown value truthy prop passed.validator : Custom validator function takes prop value sole argument. development mode, console warning thrown function returns falsy value (i.e. validation fails). Example Simple declaration: jsexport default { props: ['size', 'myMessage'] } Object declaration validations: jsexport default { props: { // type check height: Number, // type check plus validations age: { type: Number, default: 0, required: true, validator: (value) => { return value >= 0 } } } } See also computed Declare computed properties exposed component instance. Type tsinterface ComponentOptions { computed?: { [key: string]: ComputedGetter<any> | WritableComputedOptions<any> } } type ComputedGetter<T> = ( this: ComponentPublicInstance, vm: ComponentPublicInstance ) => type ComputedSetter<T> = ( this: ComponentPublicInstance, value: ) => void type WritableComputedOptions<T> = { get: ComputedGetter<T> set: ComputedSetter<T> } Details option accepts object key name computed property, value either computed getter, object get andset methods (for writable computed properties).All getters setters context automatically bound component instance.Note use arrow function computed property, point component's instance, still access instance function's first argument:jsexport default { computed: { aDouble: (vm) => vm.a * 2 } } Example jsexport default { data() { return { a: 1 } }, computed: { // readonly aDouble() { return this.a * 2 }, // writable aPlus: { get() { return this.a + 1 }, set(v) { this.a = v - 1 } } }, created() { console.log(this.aDouble) // => 2 console.log(this.aPlus) // => 2 this.aPlus = 3 console.log(this.a) // => 2 console.log(this.aDouble) // => 4 } } See also methods Declare methods mixed component instance. Type tsinterface ComponentOptions { methods?: { [key: string]: (this: ComponentPublicInstance, ...args: any[]) => } } Details Declared methods directly accessed component instance, used template expressions. methods context automatically bound component instance, even passed around.Avoid using arrow functions declaring methods, access component instance via .Example jsexport default { data() { return { a: 1 } }, methods: { plus() { this.a++ } }, created() { this.plus() console.log(this.a) // => 2 } } See also Event Handling watch Declare watch callbacks invoked data change. Type tsinterface ComponentOptions { watch?: { [key: string]: WatchOptionItem | WatchOptionItem[] } } type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void type ObjectWatchOptionItem = { handler: WatchCallback | string immediate?: boolean // default: false deep?: boolean // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void } Types simplified readability. Details watch option expects object keys reactive component instance properties watch (e.g. properties declared viadata orcomputed ) \u2014 values corresponding callbacks. callback receives new value old value watched source.In addition root-level property, key also simple dot-delimited path, e.g. a.b.c . Note usage support complex expressions - dot-delimited paths supported. need watch complex data sources, use imperative$watch() API instead.The value also string method name (declared via methods ), object contains additional options. using object syntax, callback declared thehandler field. Additional options include:immediate : trigger callback immediately watcher creation. Old value beundefined first call.deep : force deep traversal source object array, callback fires deep mutations. See Deep Watchers.flush : adjust callback's flush timing. See Callback Flush Timing andwatchEffect() .onTrack / onTrigger : debug watcher's dependencies. See Watcher Debugging. Avoid using arrow functions declaring watch callbacks access component instance via .Example jsexport default { data() { return { a: 1, b: 2, c: { d: 4 }, e: 5, f: 6 } }, watch: { // watching top-level property a(val, oldVal) { console.log(`new: ${val}, old: ${oldVal}`) }, // string method name b: 'someMethod', // callback called whenever watched object properties change regardless nested depth c: { handler(val, oldVal) { console.log('c changed') }, deep: true }, // watching single nested property: 'c.d': function (val, oldVal) { // something }, // callback called immediately start observation e: { handler(val, oldVal) { console.log('e changed') }, immediate: true }, // pass array callbacks, called one-by-one f: [ 'handle1', function handle2(val, oldVal) { console.log('handle2 triggered') }, { handler: function handle3(val, oldVal) { console.log('handle3 triggered') } /* ... */ } ] }, methods: { someMethod() { console.log('b changed') }, handle1() { console.log('handle 1 triggered') } }, created() { this.a = 3 // => new: 3, old: 1 } } See also Watchers emits Declare custom events emitted component. Type tsinterface ComponentOptions { emits?: ArrayEmitsOptions | ObjectEmitsOptions } type ArrayEmitsOptions = string[] type ObjectEmitsOptions = { [key: string]: EmitValidator | null } type EmitValidator = (...args: unknown[]) => boolean Details Emitted events declared two forms: - Simple form using array strings - Full form using object property key name event, value either null validator function. validation function receive additional arguments passed component's $emit call. example, ifthis.$emit('foo', 1) called, corresponding validator forfoo receive argument1 . validator function return boolean indicate whether event arguments valid.Note emits option affects event listeners considered component event listeners, rather native DOM event listeners. listeners declared events removed component's$attrs object, passed component's root element. See Fallthrough Attributes details.Example Array syntax: jsexport default { emits: ['check'], created() { this.$emit('check') } } Object syntax: jsexport default { emits: { // validation click: null, // validation submit: (payload) => { (payload.email && payload.password) { return true } else { console.warn(`Invalid submit event payload!`) return false } } } } See also expose Declare exposed public properties component instance accessed parent via template refs. Type tsinterface ComponentOptions { expose?: string[] } Details default, component instance exposes instance properties parent accessed via $parent ,$root , template refs. undesirable, since component likely internal state methods kept private avoid tight coupling.The expose option expects list property name strings. Whenexpose used, properties explicitly listed exposed component's public instance.expose affects user-defined properties - filter built-in component instance properties.Example jsexport default { // `publicMethod` available public instance expose: ['publicMethod'], methods: { publicMethod() { // ... }, privateMethod() { // ... } } }"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity API: Advanced shallowRef() Shallow version ref() . Type tsfunction shallowRef<T>(value: T): ShallowRef<T> interface ShallowRef<T> { value: } Details Unlike ref() , inner value shallow ref stored exposed as-is, made deeply reactive. the.value access reactive.shallowRef() typically used performance optimizations large data structures, integration external state management systems.Example jsconst state = shallowRef({ count: 1 }) // trigger change state.value.count = 2 // trigger change state.value = { count: 2 } See also triggerRef() Force trigger effects depends shallow ref. typically used making deep mutations inner value shallow ref. Type tsfunction triggerRef(ref: ShallowRef): void Example jsconst shallow = shallowRef({ greet: 'Hello, world' }) // Logs \"Hello, world\" first run-through watchEffect(() => { console.log(shallow.value.greet) }) // trigger effect ref shallow shallow.value.greet = 'Hello, universe' // Logs \"Hello, universe\" triggerRef(shallow) customRef() Creates customized ref explicit control dependency tracking updates triggering. Type tsfunction customRef<T>(factory: CustomRefFactory<T>): Ref<T> type CustomRefFactory<T> = ( track: () => void, trigger: () => void ) => { get: () => set: (value: T) => void } Details customRef() expects factory function, receivestrack andtrigger functions arguments return object withget andset methods.In general, track() called insideget() , andtrigger() called insideset() . However, full control called, whether called all.Example Creating debounced ref updates value certain timeout latest set call: jsimport { customRef } 'vue' export function useDebouncedRef(value, delay = 200) { let timeout return customRef((track, trigger) => { return { get() { track() return value }, set(newValue) { clearTimeout(timeout) timeout = setTimeout(() => { value = newValue trigger() }, delay) } } }) } Usage component: vue<script setup> import { useDebouncedRef } './debouncedRef' const text = useDebouncedRef('hello') </script> <template> <input v-model=\"text\" /> </template> Use caution using customRef, cautious return value getter, particularly generating new object datatypes time getter run. affects relationship parent child components, customRef passed prop. parent component's render function could triggered changes different reactive state. rerender, value customRef reevaluated, returning new object datatype prop child component. prop compared last value child component, since different, reactive dependencies customRef triggered child component. Meanwhile, reactive dependencies parent component run customRef's setter called, dependencies triggered result. shallowReactive() Shallow version reactive() . Type tsfunction shallowReactive<T extends object>(target: T): Details Unlike reactive() , deep conversion: root-level properties reactive shallow reactive object. Property values stored exposed as-is - also means properties ref values automatically unwrapped.Use Caution Shallow data structures used root level state component. Avoid nesting inside deep reactive object creates tree inconsistent reactivity behavior difficult understand debug. Example jsconst state = shallowReactive({ foo: 1, nested: { bar: 2 } }) // mutating state's properties reactive state.foo++ // ...but convert nested objects isReactive(state.nested) // false // reactive state.nested.bar++ shallowReadonly() Shallow version readonly() . Type tsfunction shallowReadonly<T extends object>(target: T): Readonly<T> Details Unlike readonly() , deep conversion: root-level properties made readonly. Property values stored exposed as-is - also means properties ref values automatically unwrapped.Use Caution Shallow data structures used root level state component. Avoid nesting inside deep reactive object creates tree inconsistent reactivity behavior difficult understand debug. Example jsconst state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // mutating state's properties fail state.foo++ // ...but works nested objects isReadonly(state.nested) // false // works state.nested.bar++ toRaw() Returns raw, original object Vue-created proxy. Type tsfunction toRaw<T>(proxy: T): Details toRaw() return original object proxies created byreactive() ,readonly() ,shallowReactive() orshallowReadonly() .This escape hatch used temporarily read without incurring proxy access / tracking overhead write without triggering changes. recommended hold persistent reference original object. Use caution. Example jsconst foo = {} const reactiveFoo = reactive(foo) console.log(toRaw(reactiveFoo) === foo) // true markRaw() Marks object never converted proxy. Returns object itself. Type tsfunction markRaw<T extends object>(value: T): Example jsconst foo = markRaw({}) console.log(isReactive(reactive(foo))) // false // also works nested inside reactive objects const bar = reactive({ foo }) console.log(isReactive(bar.foo)) // false Use Caution markRaw() shallow APIs asshallowReactive() allow selectively opt-out default deep reactive/readonly conversion embed raw, non-proxied objects state graph. used various reasons:Some values simply made reactive, example complex 3rd party class instance, Vue component object. Skipping proxy conversion provide performance improvements rendering large lists immutable data sources. considered advanced raw opt-out root level, set nested, non-marked raw object reactive object access again, get proxied version back. lead identity hazards - i.e. performing operation relies object identity using raw proxied version object: jsconst foo = markRaw({ nested: {} }) const bar = reactive({ // although `foo` marked raw, foo.nested not. nested: foo.nested }) console.log(foo.nested === bar.nested) // false Identity hazards general rare. However, properly utilize APIs safely avoiding identity hazards requires solid understanding reactivity system works. effectScope() Creates effect scope object capture reactive effects (i.e. computed watchers) created within effects disposed together. detailed use cases API, please consult corresponding RFC. Type tsfunction effectScope(detached?: boolean): EffectScope interface EffectScope { run<T>(fn: () => T): | undefined // undefined scope inactive stop(): void } Example jsconst scope = effectScope() scope.run(() => { const doubled = computed(() => counter.value * 2) watch(doubled, () => console.log(doubled.value)) watchEffect(() => console.log('Count: ', doubled.value)) }) // dispose effects scope scope.stop() getCurrentScope() Returns current active effect scope one. Type tsfunction getCurrentScope(): EffectScope | undefined onScopeDispose() Registers dispose callback current active effect scope. callback invoked associated effect scope stopped. method used non-component-coupled replacement onUnmounted reusable composition functions, since Vue component's setup() function also invoked effect scope. warning thrown function called without active effect scope. 3.5+, warning suppressed passing true second argument. Type tsfunction onScopeDispose(fn: () => void, failSilently?: boolean): void"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity API: Core See also better understand Reactivity APIs, recommended read following chapters guide: - Reactivity Fundamentals (with API preference set Composition API) - Reactivity Depth ref() Takes inner value returns reactive mutable ref object, single property .value points inner value. Type tsfunction ref<T>(value: T): Ref<UnwrapRef<T>> interface Ref<T> { value: } Details ref object mutable - i.e. assign new values .value . also reactive - i.e. read operations to.value tracked, write operations trigger associated effects.If object assigned ref's value, object made deeply reactive reactive(). also means object contains nested refs, deeply unwrapped. avoid deep conversion, use shallowRef() instead.Example jsconst count = ref(0) console.log(count.value) // 0 count.value = 1 console.log(count.value) // 1 See also computed() Takes getter function returns readonly reactive ref object returned value getter. also take object get set functions create writable ref object. Type ts// read-only function computed<T>( getter: (oldValue: | undefined) => T, // see \"Computed Debugging\" link debuggerOptions?: DebuggerOptions ): Readonly<Ref<Readonly<T>>> // writable function computed<T>( options: { get: (oldValue: | undefined) => set: (value: T) => void }, debuggerOptions?: DebuggerOptions ): Ref<T> Example Creating readonly computed ref: jsconst count = ref(1) const plusOne = computed(() => count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // error Creating writable computed ref: jsconst count = ref(1) const plusOne = computed({ get: () => count.value + 1, set: (val) => { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0 Debugging: jsconst plusOne = computed(() => count.value + 1, { onTrack(e) { debugger }, onTrigger(e) { debugger } }) See also reactive() Returns reactive proxy object. Type tsfunction reactive<T extends object>(target: T): UnwrapNestedRefs<T> Details reactive conversion \"deep\": affects nested properties. reactive object also deeply unwraps properties refs maintaining reactivity. also noted ref unwrapping performed ref accessed element reactive array native collection type like Map .To avoid deep conversion retain reactivity root level, use shallowReactive() instead. returned object nested objects wrapped ES Proxy equal original objects. recommended work exclusively reactive proxy avoid relying original object. Example Creating reactive object: jsconst obj = reactive({ count: 0 }) obj.count++ Ref unwrapping: tsconst count = ref(1) const obj = reactive({ count }) // ref unwrapped console.log(obj.count === count.value) // true // update `obj.count` count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // also update `count` ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3 Note refs unwrapped accessed array collection elements: jsconst books = reactive([ref('Vue 3 Guide')]) // need .value console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value console.log(map.get('count').value) assigning ref reactive property, ref also automatically unwrapped:tsconst count = ref(1) const obj = reactive({}) obj.count = count console.log(obj.count) // 1 console.log(obj.count === count.value) // true See also readonly() Takes object (reactive plain) ref returns readonly proxy original. Type tsfunction readonly<T extends object>( target: ): DeepReadonly<UnwrapNestedRefs<T>> Details readonly proxy deep: nested property accessed readonly well. also ref-unwrapping behavior reactive() , except unwrapped values also made readonly.To avoid deep conversion, use shallowReadonly() instead. Example jsconst original = reactive({ count: 0 }) const copy = readonly(original) watchEffect(() => { // works reactivity tracking console.log(copy.count) }) // mutating original trigger watchers relying copy original.count++ // mutating copy fail result warning copy.count++ // warning! watchEffect() Runs function immediately reactively tracking dependencies re-runs whenever dependencies changed. Type tsfunction watchEffect( effect: (onCleanup: OnCleanup) => void, options?: WatchEffectOptions ): WatchHandle type OnCleanup = (cleanupFn: () => void) => void interface WatchEffectOptions { flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void } interface WatchHandle { (): void // callable, `stop` pause: () => void resume: () => void stop: () => void } Details first argument effect function run. effect function receives function used register cleanup callback. cleanup callback called right next time effect re-run, used clean invalidated side effects, e.g. pending async request (see example below). second argument optional options object used adjust effect's flush timing debug effect's dependencies. default, watchers run prior component rendering. Setting flush: 'post' defer watcher component rendering. See Callback Flush Timing information. rare cases, might necessary trigger watcher immediately reactive dependency changes, e.g. invalidate cache. achieved usingflush: 'sync' . However, setting used caution, lead problems performance data consistency multiple properties updated time.The return value handle function called stop effect running again. Example jsconst count = ref(0) watchEffect(() => console.log(count.value)) // -> logs 0 count.value++ // -> logs 1 Stopping watcher: jsconst stop = watchEffect(() => {}) // watcher longer needed: stop() Pausing / resuming watcher: jsconst { stop, pause, resume } = watchEffect(() => {}) // temporarily pause watcher pause() // resume later resume() // stop stop() Side effect cleanup: jswatchEffect(async (onCleanup) => { const { response, cancel } = doAsyncWork(newId) // `cancel` called `id` changes, cancelling // previous request completed yet onCleanup(cancel) data.value = await response }) Side effect cleanup 3.5+: jsimport { onWatcherCleanup } 'vue' watchEffect(async () => { const { response, cancel } = doAsyncWork(newId) // `cancel` called `id` changes, cancelling // previous request completed yet onWatcherCleanup(cancel) data.value = await response }) Options: jswatchEffect(() => {}, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } }) See also watchPostEffect() Alias watchEffect() flush: 'post' option. watchSyncEffect() Alias watchEffect() flush: 'sync' option. watch() Watches one reactive data sources invokes callback function sources change. Type ts// watching single source function watch<T>( source: WatchSource<T>, callback: WatchCallback<T>, options?: WatchOptions ): WatchHandle // watching multiple sources function watch<T>( sources: WatchSource<T>[], callback: WatchCallback<T[]>, options?: WatchOptions ): WatchHandle type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void type WatchSource<T> = | Ref<T> // ref | (() => T) // getter | (T extends object ? : never) // reactive object interface WatchOptions extends WatchEffectOptions { immediate?: boolean // default: false deep?: boolean | number // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void once?: boolean // default: false (3.4+) } interface WatchHandle { (): void // callable, `stop` pause: () => void resume: () => void stop: () => void } Types simplified readability. Details watch() lazy default - i.e. callback called watched source changed.The first argument watcher's source. source one following: - getter function returns value - ref - reactive object - ...or array above. second argument callback called source changes. callback receives three arguments: new value, old value, function registering side effect cleanup callback. cleanup callback called right next time effect re-run, used clean invalidated side effects, e.g. pending async request. watching multiple sources, callback receives two arrays containing new / old values corresponding source array. third optional argument options object supports following options: immediate : trigger callback immediately watcher creation. Old value beundefined first call.deep : force deep traversal source object, callback fires deep mutations. 3.5+, also number indicating max traversal depth. See Deep Watchers.flush : adjust callback's flush timing. See Callback Flush Timing andwatchEffect() .onTrack / onTrigger : debug watcher's dependencies. See Watcher Debugging.once : (3.4+) run callback once. watcher automatically stopped first callback run. Compared watchEffect() ,watch() allows us to:- Perform side effect lazily; - specific state trigger watcher re-run; - Access previous current value watched state. Example Watching getter: jsconst state = reactive({ count: 0 }) watch( () => state.count, (count, prevCount) => { /* ... */ } ) Watching ref: jsconst count = ref(0) watch(count, (count, prevCount) => { /* ... */ }) watching multiple sources, callback receives arrays containing new / old values corresponding source array: jswatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => { /* ... */ }) using getter source, watcher fires getter's return value changed. want callback fire even deep mutations, need explicitly force watcher deep mode { deep: true } . Note deep mode, new value old object callback triggered deep mutation:jsconst state = reactive({ count: 0 }) watch( () => state, (newValue, oldValue) => { // newValue === oldValue }, { deep: true } ) directly watching reactive object, watcher automatically deep mode: jsconst state = reactive({ count: 0 }) watch(state, () => { /* triggers deep mutation state */ }) watch() shares flush timing debugging options withwatchEffect() :jswatch(source, callback, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } }) Stopping watcher: jsconst stop = watch(source, callback) // watcher longer needed: stop() Pausing / resuming watcher: jsconst { stop, pause, resume } = watch(() => {}) // temporarily pause watcher pause() // resume later resume() // stop stop() Side effect cleanup: jswatch(id, async (newId, oldId, onCleanup) => { const { response, cancel } = doAsyncWork(newId) // `cancel` called `id` changes, cancelling // previous request completed yet onCleanup(cancel) data.value = await response }) Side effect cleanup 3.5+: jsimport { onWatcherCleanup } 'vue' watch(id, async (newId) => { const { response, cancel } = doAsyncWork(newId) onWatcherCleanup(cancel) data.value = await response }) See also onWatcherCleanup() Register cleanup function executed current watcher re-run. called synchronous execution watchEffect effect function watch callback function (i.e. cannot called await statement async function.) Type tsfunction onWatcherCleanup( cleanupFn: () => void, failSilently?: boolean ): void Example tsimport { watch, onWatcherCleanup } 'vue' watch(id, (newId) => { const { response, cancel } = doAsyncWork(newId) // `cancel` called `id` changes, cancelling // previous request completed yet onWatcherCleanup(cancel) })"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity API: Utilities isRef() Checks value ref object. Type tsfunction isRef<T>(r: Ref<T> | unknown): r Ref<T> Note return type type predicate, means isRef used type guard:tslet foo: unknown (isRef(foo)) { // foo's type narrowed Ref<unknown> foo.value } unref() Returns inner value argument ref, otherwise return argument itself. sugar function val = isRef(val) ? val.value : val . Type tsfunction unref<T>(ref: | Ref<T>): Example tsfunction useFoo(x: number | Ref<number>) { const unwrapped = unref(x) // unwrapped guaranteed number } toRef() used normalize values / refs / getters refs (3.3+). also used create ref property source reactive object. created ref synced source property: mutating source property update ref, vice-versa. Type ts// normalization signature (3.3+) function toRef<T>( value: ): extends () => infer R ? Readonly<Ref<R>> : extends Ref ? : Ref<UnwrapRef<T>> // object property signature function toRef<T extends object, K extends keyof T>( object: T, key: K, defaultValue?: T[K] ): ToRef<T[K]> type ToRef<T> = extends Ref ? : Ref<T> Example Normalization signature (3.3+): js// returns existing refs as-is toRef(existingRef) // creates readonly ref calls getter .value access toRef(() => props.foo) // creates normal refs non-function values // equivalent ref(1) toRef(1) Object property signature: jsconst state = reactive({ foo: 1, bar: 2 }) // two-way ref syncs original property const fooRef = toRef(state, 'foo') // mutating ref updates original fooRef.value++ console.log(state.foo) // 2 // mutating original also updates ref state.foo++ console.log(fooRef.value) // 3 Note different from: jsconst fooRef = ref(state.foo) ref synced state.foo , theref() receives plain number value.toRef() useful want pass ref prop composable function:vue<script setup> import { toRef } 'vue' const props = defineProps(/* ... */) // convert `props.foo` ref, pass // composable useSomeFeature(toRef(props, 'foo')) // getter syntax - recommended 3.3+ useSomeFeature(toRef(() => props.foo)) </script> toRef used component props, usual restrictions around mutating props still apply. Attempting assign new value ref equivalent trying modify prop directly allowed. scenario may want consider usingcomputed withget andset instead. See guide usingv-model components information.When using object property signature, toRef() return usable ref even source property currently exist. makes possible work optional properties, picked bytoRefs . toValue() - supported 3.3+ Normalizes values / refs / getters values. similar unref(), except also normalizes getters. argument getter, invoked return value returned. used Composables normalize argument either value, ref, getter. Type tsfunction toValue<T>(source: | Ref<T> | (() => T)): Example jstoValue(1) // --> 1 toValue(ref(1)) // --> 1 toValue(() => 1) // --> 1 Normalizing arguments composables: tsimport type { MaybeRefOrGetter } 'vue' function useFeature(id: MaybeRefOrGetter<number>) { watch(() => toValue(id), id => { // react id changes }) } // composable supports following: useFeature(1) useFeature(ref(1)) useFeature(() => 1) toRefs() Converts reactive object plain object property resulting object ref pointing corresponding property original object. individual ref created using toRef() . Type tsfunction toRefs<T extends object>( object: ): { [K keyof T]: ToRef<T[K]> } type ToRef = extends Ref ? : Ref<T> Example jsconst state = reactive({ foo: 1, bar: 2 }) const stateAsRefs = toRefs(state) /* Type stateAsRefs: { foo: Ref<number>, bar: Ref<number> } */ // ref original property \"linked\" state.foo++ console.log(stateAsRefs.foo.value) // 2 stateAsRefs.foo.value++ console.log(state.foo) // 3 toRefs useful returning reactive object composable function consuming component destructure/spread returned object without losing reactivity:jsfunction useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // ...logic operating state // convert refs returning return toRefs(state) } // destructure without losing reactivity const { foo, bar } = useFeatureX() toRefs generate refs properties enumerable source object call time. create ref property may exist yet, usetoRef instead. isProxy() Checks object proxy created reactive() , readonly() , shallowReactive() shallowReadonly() . Type tsfunction isProxy(value: any): boolean isReactive() Checks object proxy created reactive() shallowReactive() . Type tsfunction isReactive(value: unknown): boolean isReadonly() Checks whether passed value readonly object. properties readonly object change, can't assigned directly via passed object. proxies created readonly() shallowReadonly() considered readonly, computed() ref without set function. Type tsfunction isReadonly(value: unknown): boolean"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Render Function APIs h() Creates virtual DOM nodes (vnodes). Type ts// full signature function h( type: string | Component, props?: object | null, children?: Children | Slot | Slots ): VNode // omitting props function h(type: string | Component, children?: Children | Slot): VNode type Children = string | number | boolean | VNode | null | Children[] type Slot = () => Children type Slots = { [name: string]: Slot } Types simplified readability. Details first argument either string (for native elements) Vue component definition. second argument props passed, third argument children. creating component vnode, children must passed slot functions. single slot function passed component expects default slot. Otherwise, slots must passed object slot functions. convenience, props argument omitted children slots object. Example Creating native elements: jsimport { h } 'vue' // arguments except type optional h('div') h('div', { id: 'foo' }) // attributes properties used props // Vue automatically picks right way assign h('div', { class: 'bar', innerHTML: 'hello' }) // class style object / array // value support like templates h('div', { class: [foo, { bar }], style: { color: 'red' } }) // event listeners passed onXxx h('div', { onClick: () => {} }) // children string h('div', { id: 'foo' }, 'hello') // props omitted props h('div', 'hello') h('div', [h('span', 'hello')]) // children array contain mixed vnodes strings h('div', ['hello', h('span', 'hello')]) Creating components: jsimport Foo './Foo.vue' // passing props h(Foo, { // equivalent some-prop=\"hello\" someProp: 'hello', // equivalent @update=\"() => {}\" onUpdate: () => {} }) // passing single default slot h(Foo, () => 'default slot') // passing named slots // notice `null` required avoid // slots object treated props h(MyComponent, null, { default: () => 'default slot', foo: () => h('div', 'foo'), bar: () => [h('span', 'one'), h('span', 'two')] }) mergeProps() Merge multiple props objects special handling certain props. Type tsfunction mergeProps(...args: object[]): object Details mergeProps() supports merging multiple props objects special handling following props:class style onXxx event listeners - multiple listeners name merged array. need merge behavior want simple overwrites, native object spread used instead. Example jsimport { mergeProps } 'vue' const one = { class: 'foo', onClick: handlerA } const two = { class: { bar: true }, onClick: handlerB } const merged = mergeProps(one, two) /** { class: 'foo bar', onClick: [handlerA, handlerB] } */ cloneVNode() Clones vnode. Type tsfunction cloneVNode(vnode: VNode, extraProps?: object): VNode Details Returns cloned vnode, optionally extra props merge original. Vnodes considered immutable created, mutate props existing vnode. Instead, clone different / extra props. Vnodes special internal properties, cloning simple object spread. cloneVNode() handles internal logic.Example jsimport { h, cloneVNode } 'vue' const original = h('div') const cloned = cloneVNode(original, { id: 'foo' }) isVNode() Checks value vnode. Type tsfunction isVNode(value: unknown): boolean resolveComponent() manually resolving registered component name. Type tsfunction resolveComponent(name: string): Component | string Details Note: need import component directly. resolveComponent() must called inside eithersetup() render function order resolve correct component context.If component found, runtime warning emitted, name string returned. Example jsimport { h, resolveComponent } 'vue' export default { setup() { const ButtonCounter = resolveComponent('ButtonCounter') return () => { return h(ButtonCounter) } } } resolveDirective() manually resolving registered directive name. Type tsfunction resolveDirective(name: string): Directive | undefined Details Note: need import directive directly. resolveDirective() must called inside eithersetup() render function order resolve correct component context.If directive found, runtime warning emitted, function returns undefined . withDirectives() adding custom directives vnodes. Type tsfunction withDirectives( vnode: VNode, directives: DirectiveArguments ): VNode // [Directive, value, argument, modifiers] type DirectiveArguments = Array< | [Directive] | [Directive, any] | [Directive, any, string] | [Directive, any, string, DirectiveModifiers] > Details Wraps existing vnode custom directives. second argument array custom directives. custom directive also represented array form [Directive, value, argument, modifiers] . Tailing elements array omitted needed.Example jsimport { h, withDirectives } 'vue' // custom directive const pin = { mounted() { /* ... */ }, updated() { /* ... */ } } // <div v-pin:top.animate=\"200\"></div> const vnode = withDirectives(h('div'), [ [pin, 200, 'top', { animate: true }] ]) withModifiers() adding built-in v-on modifiers event handler function. Type tsfunction withModifiers(fn: Function, modifiers: ModifierGuardsKeys[]): Function Example jsimport { h, withModifiers } 'vue' const vnode = h('button', { // equivalent v-on:click.stop.prevent onClick: withModifiers(() => { // ... }, ['stop', 'prevent']) })"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "SFC CSS Features Scoped CSS <style> tag scoped attribute, CSS apply elements current component only. similar style encapsulation found Shadow DOM. comes caveats, require polyfills. achieved using PostCSS transform following: vue <style scoped> .example { color: red; } </style> <template> <div class=\"example\">hi</div> </template> following: vue <style> .example[data-v-f3f3eg9] { color: red; } </style> <template> <div class=\"example\" data-v-f3f3eg9>hi</div> </template> Child Component Root Elements scoped , parent component's styles leak child components. However, child component's root node affected parent's scoped CSS child's scoped CSS. design parent style child root element layout purposes. Deep Selectors want selector scoped styles \"deep\", i.e. affecting child components, use :deep() pseudo-class: vue <style scoped> .a :deep(.b) { /* ... */ } </style> compiled into: css .a[data-v-f3f3eg9] .b { /* ... */ } TIP DOM content created v-html affected scoped styles, still style using deep selectors. Slotted Selectors default, scoped styles affect contents rendered <slot/> , considered owned parent component passing in. explicitly target slot content, use :slotted pseudo-class: vue <style scoped> :slotted(div) { color: red; } </style> Global Selectors want one rule apply globally, use :global pseudo-class rather creating another <style> (see below): vue <style scoped> :global(.red) { color: red; } </style> Mixing Local Global Styles also include scoped non-scoped styles component: vue <style> /* global styles */ </style> <style scoped> /* local styles */ </style> Scoped Style Tips Scoped styles eliminate need classes. Due way browsers render various CSS selectors, p { color: red } many times slower scoped (i.e. combined attribute selector). use classes ids instead, in.example { color: red } , virtually eliminate performance hit.Be careful descendant selectors recursive components! CSS rule selector .a .b , element matches.a contains recursive child component, all.b child component matched rule. CSS Modules <style module> tag compiled CSS Modules exposes resulting CSS classes component object key $style : vue <template> <p :class=\"$style.red\">This red</p> </template> <style module> .red { color: red; } </style> resulting classes hashed avoid collision, achieving effect scoping CSS current component only. Refer CSS Modules spec details global exceptions composition. Custom Inject Name customize property key injected classes object giving module attribute value: vue <template> <p :class=\"classes.red\">red</p> </template> <style module=\"classes\"> .red { color: red; } </style> Usage Composition API injected classes accessed setup() <script setup> via useCssModule API. <style module> blocks custom injection names, useCssModule accepts matching module attribute value first argument: js import { useCssModule } 'vue' // inside setup() scope... // default, returns classes <style module> useCssModule() // named, returns classes <style module=\"classes\"> useCssModule('classes') - Example vue <script setup lang=\"ts\"> import { useCssModule } 'vue' const classes = useCssModule() </script> <template> <p :class=\"classes.red\">red</p> </template> <style module> .red { color: red; } </style> v-bind() CSS SFC <style> tags support linking CSS values dynamic component state using v-bind CSS function: vue <template> <div class=\"text\">hello</div> </template> <script> export default { data() { return { color: 'red' } } } </script> <style> .text { color: v-bind(color); } </style> syntax works <script setup> , supports JavaScript expressions (must wrapped quotes): vue <script setup> import { ref } 'vue' const theme = ref({ color: 'red', }) </script> <template> <p>hello</p> </template> <style scoped> p { color: v-bind('theme.color'); } </style> actual value compiled hashed CSS custom property, CSS still static. custom property applied component's root element via inline styles reactively updated source value changes."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "<script setup> <script setup> compile-time syntactic sugar using Composition API inside Single-File Components (SFCs). recommended syntax using SFCs Composition API. provides number advantages normal <script> syntax: - succinct code less boilerplate - Ability declare props emitted events using pure TypeScript - Better runtime performance (the template compiled render function scope, without intermediate proxy) - Better IDE type-inference performance (less work language server extract types code) Basic Syntax opt-in syntax, add setup attribute <script> block: vue <script setup> console.log('hello script setup') </script> code inside compiled content component's setup() function. means unlike normal <script> , executes component first imported, code inside <script setup> execute every time instance component created. Top-level bindings exposed template using <script setup> , top-level bindings (including variables, function declarations, imports) declared inside <script setup> directly usable template: vue <script setup> // variable const msg = 'Hello!' // functions function log() { console.log(msg) } </script> <template> <button @click=\"log\">{{ msg }}</button> </template> Imports exposed fashion. means directly use imported helper function template expressions without expose via methods option: vue <script setup> import { capitalize } './helpers' </script> <template> <div>{{ capitalize('hello') }}</div> </template> Reactivity Reactive state needs explicitly created using Reactivity APIs. Similar values returned setup() function, refs automatically unwrapped referenced templates: vue <script setup> import { ref } 'vue' const count = ref(0) </script> <template> <button @click=\"count++\">{{ count }}</button> </template> Using Components Values scope <script setup> also used directly custom component tag names: vue <script setup> import MyComponent './MyComponent.vue' </script> <template> <MyComponent /> </template> Think MyComponent referenced variable. used JSX, mental model similar here. kebab-case equivalent <my-component> also works template - however PascalCase component tags strongly recommended consistency. also helps differentiating native custom elements. Dynamic Components Since components referenced variables instead registered string keys, use dynamic :is binding using dynamic components inside <script setup> : vue <script setup> import Foo './Foo.vue' import Bar './Bar.vue' </script> <template> <component :is=\"Foo\" /> <component :is=\"someCondition ? Foo : Bar\" /> </template> Note components used variables ternary expression. Recursive Components SFC implicitly refer via filename. E.g. file named FooBar.vue refer <FooBar/> template. Note lower priority imported components. named import conflicts component's inferred name, alias import: js import { FooBar FooBarChild } './components' Namespaced Components use component tags dots like <Foo.Bar> refer components nested object properties. useful import multiple components single file: vue <script setup> import * Form './form-components' </script> <template> <Form.Input> <Form.Label>label</Form.Label> </Form.Input> </template> Using Custom Directives Globally registered custom directives work normal. Local custom directives need explicitly registered <script setup> , must follow naming scheme vNameOfDirective : vue <script setup> const vMyDirective = { beforeMount: (el) => { // something element } } </script> <template> <h1 v-my-directive>This Heading</h1> </template> importing directive elsewhere, renamed fit required naming scheme: vue <script setup> import { myDirective vMyDirective } './MyDirective.js' </script> defineProps() & defineEmits() declare options like props emits full type inference support, use defineProps defineEmits APIs, automatically available inside <script setup> : vue <script setup> const props = defineProps({ foo: String }) const emit = defineEmits(['change', 'delete']) // setup code </script> defineProps anddefineEmits compiler macros usable inside<script setup> . need imported, compiled away when<script setup> processed.defineProps accepts value theprops option, whiledefineEmits accepts value theemits option.defineProps anddefineEmits provide proper type inference based options passed.The options passed defineProps anddefineEmits hoisted setup module scope. Therefore, options cannot reference local variables declared setup scope. result compile error. However, reference imported bindings since module scope well. Type-only props/emit declarations Props emits also declared using pure-type syntax passing literal type argument defineProps defineEmits : ts const props = defineProps<{ foo: string bar?: number }>() const emit = defineEmits<{ (e: 'change', id: number): void (e: 'update', value: string): void }>() // 3.3+: alternative, succinct syntax const emit = defineEmits<{ change: [id: number] // named tuple syntax update: [value: string] }>() defineProps ordefineEmits use either runtime declaration type declaration. Using time result compile error.When using type declaration, equivalent runtime declaration automatically generated static analysis remove need double declaration still ensure correct runtime behavior. dev mode, compiler try infer corresponding runtime validation types. example foo: String inferred thefoo: string type. type reference imported type, inferred result befoo: null (equal toany type) since compiler information external files.In prod mode, compiler generate array format declaration reduce bundle size (the props compiled ['foo', 'bar'] ) version 3.2 below, generic type parameter defineProps() limited type literal reference local interface.This limitation resolved 3.3. latest version Vue supports referencing imported limited set complex types type parameter position. However, type runtime conversion still AST-based, complex types require actual type analysis, e.g. conditional types, supported. use conditional types type single prop, entire props object. Reactive Props Destructure Vue 3.5 above, variables destructured return value defineProps reactive. Vue's compiler automatically prepends props. code <script setup> block accesses variables destructured defineProps : ts const { foo } = defineProps(['foo']) watchEffect(() => { // runs 3.5 // re-runs \"foo\" prop changes 3.5+ console.log(foo) }) compiled following equivalent: js const props = defineProps(['foo']) watchEffect(() => { // `foo` transformed `props.foo` compiler console.log(props.foo) }) addition, use JavaScript's native default value syntax declare default values props. particularly useful using type-based props declaration: ts interface Props { msg?: string labels?: string[] } const { msg = 'hello', labels = ['one', 'two'] } = defineProps<Props>() Default props values using type declaration 3.5 above, default values naturally declared using Reactive Props Destructure. 3.4 below, Reactive Props Destructure enabled default. order declare props default values type-based declaration, withDefaults compiler macro needed: ts interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps<Props>(), { msg: 'hello', labels: () => ['one', 'two'] }) compiled equivalent runtime props default options. addition, withDefaults helper provides type checks default values, ensures returned props type optional flags removed properties default values declared. INFO Note default values mutable reference types (like arrays objects) wrapped functions using withDefaults avoid accidental modification external side effects. ensures component instance gets copy default value. necessary using default values destructure. defineModel() - available 3.4+ macro used declare two-way binding prop consumed via v-model parent component. Example usage also discussed Component v-model guide. hood, macro declares model prop corresponding value update event. first argument literal string, used prop name; Otherwise prop name default \"modelValue\" . cases, also pass additional object include prop's options model ref's value transform options. js // declares \"modelValue\" prop, consumed parent via v-model const model = defineModel() // OR: declares \"modelValue\" prop options const model = defineModel({ type: String }) // emits \"update:modelValue\" mutated model.value = 'hello' // declares \"count\" prop, consumed parent via v-model:count const count = defineModel('count') // OR: declares \"count\" prop options const count = defineModel('count', { type: Number, default: 0 }) function inc() { // emits \"update:count\" mutated count.value++ } WARNING default value defineModel prop provide value prop parent component, cause de-synchronization parent child components. example below, parent's myRef undefined, child's model 1: js // child component: const model = defineModel({ default: 1 }) // parent component: const myRef = ref() html <Child v-model=\"myRef\"></Child> Modifiers Transformers access modifiers used v-model directive, destructure return value defineModel() like this: js const [modelValue, modelModifiers] = defineModel() // corresponds v-model.trim (modelModifiers.trim) { // ... } modifier present, likely need transform value reading syncing back parent. achieve using get set transformer options: js const [modelValue, modelModifiers] = defineModel({ // get() omitted needed set(value) { // .trim modifier used, return trimmed value (modelModifiers.trim) { return value.trim() } // otherwise, return value as-is return value } }) Usage TypeScript Like defineProps defineEmits , defineModel also receive type arguments specify types model value modifiers: ts const modelValue = defineModel<string>() // ^? Ref<string | undefined> // default model options, required removes possible undefined values const modelValue = defineModel<string>({ required: true }) // ^? Ref<string> const [modelValue, modifiers] = defineModel<string, 'trim' | 'uppercase'>() // ^? Record<'trim' | 'uppercase', true | undefined> defineExpose() Components using <script setup> closed default - i.e. public instance component, retrieved via template refs $parent chains, expose bindings declared inside <script setup> . explicitly expose properties <script setup> component, use defineExpose compiler macro: vue <script setup> import { ref } 'vue' const = 1 const b = ref(2) defineExpose({ a, b }) </script> parent gets instance component via template refs, retrieved instance shape { a: number, b: number } (refs automatically unwrapped like normal instances). defineOptions() - supported 3.3+ macro used declare component options directly inside <script setup> without use separate <script> block: vue <script setup> defineOptions({ inheritAttrs: false, customOptions: { /* ... */ } }) </script> - macro. options hoisted module scope cannot access local variables <script setup> literal constants. defineSlots() - supported 3.3+ macro used provide type hints IDEs slot name props type checking. defineSlots() accepts type parameter runtime arguments. type parameter type literal property key slot name, value type slot function. first argument function props slot expects receive, type used slot props template. return type currently ignored , may leverage slot content checking future. also returns slots object, equivalent slots object exposed setup context returned useSlots() . vue <script setup lang=\"ts\"> const slots = defineSlots<{ default(props: { msg: string }): }>() </script> useSlots() & useAttrs() Usage slots attrs inside <script setup> relatively rare, since access directly $slots $attrs template. rare case need them, use useSlots useAttrs helpers respectively: vue <script setup> import { useSlots, useAttrs } 'vue' const slots = useSlots() const attrs = useAttrs() </script> useSlots useAttrs actual runtime functions return equivalent setupContext.slots setupContext.attrs . used normal composition API functions well. Usage alongside normal <script> <script setup> used alongside normal <script> . normal <script> may needed cases need to: - Declare options cannot expressed <script setup> , exampleinheritAttrs custom options enabled via plugins (Can replaced bydefineOptions 3.3+). - Declaring named exports. - Run side effects create objects execute once. vue <script> // normal <script>, executed module scope (only once) runSideEffectOnce() // declare additional options export default { inheritAttrs: false, customOptions: {} } </script> <script setup> // executed setup() scope (for instance) </script> Support combining <script setup> <script> component limited scenarios described above. Specifically: - use separate <script> section options already defined using<script setup> , asprops andemits . - Variables created inside <script setup> added properties component instance, making inaccessible Options API. Mixing APIs way strongly discouraged. find one scenarios supported consider switching explicit setup() function, instead using <script setup> . Top-level await Top-level await used inside <script setup> . resulting code compiled async setup() : vue <script setup> const post = await fetch(`/api/post/1`).then((r) => r.json()) </script> addition, awaited expression automatically compiled format preserves current component instance context await . Note async setup() must used combination Suspense , currently still experimental feature. plan finalize document future release - curious now, refer tests see works. Import Statements Import statements vue follow ECMAScript module specification. addition, use aliases defined build tool configuration: vue <script setup> import { ref } 'vue' import { componentA } './Components' import { componentB } '@/Components' import { componentC } '~/Components' </script> Generics Generic type parameters declared using generic attribute <script> tag: vue <script setup lang=\"ts\" generic=\"T\"> defineProps<{ items: T[] selected: }>() </script> value generic works exactly parameter list <...> TypeScript. example, use multiple parameters, extends constraints, default types, reference imported types: vue <script setup lang=\"ts\" generic=\"T extends string | number, U extends Item\" > import type { Item } './types' defineProps<{ id: list: U[] }>() </script> order use reference generic component ref need use vue-component-type-helpers library InstanceType work. vue <script setup lang=\"ts\" > import componentWithoutGenerics '../component-without-generics.vue'; import genericComponent '../generic-component.vue'; import type { ComponentExposed } 'vue-component-type-helpers'; // Works component without generics ref<InstanceType<typeof componentWithoutGenerics>>(); ref<ComponentExposed<typeof genericComponent>>(); Restrictions - Due difference module execution semantics, code inside <script setup> relies context SFC. moved external.js or.ts files, may lead confusion developers tools. Therefore,<script setup> cannot used thesrc attribute. <script setup> support In-DOM Root Component Template.(Related Discussion)"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "SFC Syntax Specification Overview Vue Single-File Component (SFC), conventionally using *.vue file extension, custom file format uses HTML-like syntax describe Vue component. Vue SFC syntactically compatible HTML. *.vue file consists three types top-level language blocks: <template> , <script> , <style> , optionally additional custom blocks: vue <template> <div class=\"example\">{{ msg }}</div> </template> <script> export default { data() { return { msg: 'Hello world!' } } } </script> <style> .example { color: red; } </style> <custom1> could e.g. documentation component. </custom1> Language Blocks <template> *.vue file contain one top-level<template> block.Contents extracted passed @vue/compiler-dom , pre-compiled JavaScript render functions, attached exported component itsrender option. <script> *.vue file contain one<script> block (excluding<script setup> ).The script executed ES Module. default export Vue component options object, either plain object return value defineComponent. <script setup> *.vue file contain one<script setup> block (excluding normal<script> ).The script pre-processed used component's setup() function, means executed instance component. Top-level bindings in<script setup> automatically exposed template. details, see dedicated documentation on<script setup> . <style> single *.vue file contain multiple<style> tags.A <style> tag havescoped ormodule attributes (see SFC Style Features details) help encapsulate styles current component. Multiple<style> tags different encapsulation modes mixed component. Custom Blocks Additional custom blocks included *.vue file project-specific needs, example <docs> block. real-world examples custom blocks include: Handling Custom Blocks depend tooling - want build custom block integrations, see SFC custom block integrations tooling section details. Automatic Name Inference SFC automatically infers component's name filename following cases: - Dev warning formatting - DevTools inspection - Recursive self-reference, e.g. file named FooBar.vue refer as<FooBar/> template. lower priority explicitly registered/imported components. Pre-Processors Blocks declare pre-processor languages using lang attribute. common case using TypeScript <script> block: template <script lang=\"ts\"> // use TypeScript </script> lang applied block - example use <style> Sass <template> Pug: template <template lang=\"pug\"> p {{ msg }} </template> <style lang=\"scss\"> $primary-color: #333; body { color: $primary-color; } </style> Note integration various pre-processors may differ toolchain. Check respective documentation examples: src Imports prefer splitting *.vue components multiple files, use src attribute import external file language block: vue <template src=\"./template.html\"></template> <style src=\"./style.css\"></style> <script src=\"./script.js\"></script> Beware src imports follow path resolution rules webpack module requests, means: - Relative paths need start ./ - import resources npm dependencies: vue <!-- import file installed \"todomvc-app-css\" npm package --> <style src=\"todomvc-app-css/index.css\" /> src imports also work custom blocks, e.g.: vue <unit-test src=\"./unit-test.js\"> </unit-test> Note using aliases src , start ~ , anything interpreted module request. means reference assets inside node modules: vue <img src=\"~some-npm-package/foo.png\"> Comments Inside block shall use comment syntax language used (HTML, CSS, JavaScript, Pug, etc.). top-level comments, use HTML comment syntax: <!-- comment contents -->"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Server-Side Rendering API renderToString() Exported vue/server-renderer Type tsfunction renderToString( input: App | VNode, context?: SSRContext ): Promise<string> Example jsimport { createSSRApp } 'vue' import { renderToString } 'vue/server-renderer' const app = createSSRApp({ data: () => ({ msg: 'hello' }), template: `<div>{{ msg }}</div>` }) ;(async () => { const html = await renderToString(app) console.log(html) })() SSR Context pass optional context object, used record additional data render, example accessing content Teleports: jsconst ctx = {} const html = await renderToString(app, ctx) console.log(ctx.teleports) // { '#teleported': 'teleported content' } SSR APIs page also optionally accept context object. context object accessed component code via useSSRContext helper. See also Guide - Server-Side Rendering renderToNodeStream() Renders input Node.js Readable stream. Exported vue/server-renderer Type tsfunction renderToNodeStream( input: App | VNode, context?: SSRContext ): Readable Example js// inside Node.js http handler renderToNodeStream(app).pipe(res) Note method supported ESM build vue/server-renderer , decoupled Node.js environments. UsepipeToNodeWritable instead. pipeToNodeWritable() Render pipe existing Node.js Writable stream instance. Exported vue/server-renderer Type tsfunction pipeToNodeWritable( input: App | VNode, context: SSRContext = {}, writable: Writable ): void Example js// inside Node.js http handler pipeToNodeWritable(app, {}, res) renderToWebStream() Renders input Web ReadableStream. Exported vue/server-renderer Type tsfunction renderToWebStream( input: App | VNode, context?: SSRContext ): ReadableStream Example js// inside environment ReadableStream support return new Response(renderToWebStream(app)) Note environments expose ReadableStream constructor global scope,pipeToWebWritable() used instead. pipeToWebWritable() Render pipe existing Web WritableStream instance. Exported vue/server-renderer Type tsfunction pipeToWebWritable( input: App | VNode, context: SSRContext = {}, writable: WritableStream ): void Example typically used combination TransformStream :js// TransformStream available environments CloudFlare workers. // Node.js, TransformStream needs explicitly imported 'stream/web' const { readable, writable } = new TransformStream() pipeToWebWritable(app, {}, writable) return new Response(readable) renderToSimpleStream() Renders input streaming mode using simple readable interface. Exported vue/server-renderer Type tsfunction renderToSimpleStream( input: App | VNode, context: SSRContext, options: SimpleReadable ): SimpleReadable interface SimpleReadable { push(content: string | null): void destroy(err: any): void } Example jslet res = '' renderToSimpleStream( app, {}, { push(chunk) { (chunk === null) { // done console(`render complete: ${res}`) } else { res += chunk } }, destroy(err) { // error encountered } } ) useSSRContext() runtime API used retrieve context object passed renderToString() server render APIs. Type tsfunction useSSRContext<T = Record<string, any>>(): | undefined Example retrieved context used attach information needed rendering final HTML (e.g. head metadata). vue<script setup> import { useSSRContext } 'vue' // make sure call SSR // https://vitejs.dev/guide/ssr.html#conditional-logic (import.meta.env.SSR) { const ctx = useSSRContext() // ...attach properties context } </script> data-allow-mismatch special attribute used suppress hydration mismatch warnings. Example html<div data-allow-mismatch=\"text\">{{ data.toLocaleString() }}</div> value limit allowed mismatch specific type. Allowed values are: text children (only allows mismatch direct children)class style attribute value provided, types mismatches allowed."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Utility Types INFO page lists commonly used utility types may need explanation usage. full list exported types, consult source code. PropType<T> Used annotate prop advanced types using runtime props declarations. Example tsimport type { PropType } 'vue' interface Book { title: string author: string year: number } export default { props: { book: { // provide specific type `Object` type: Object PropType<Book>, required: true } } } See also Guide - Typing Component Props MaybeRef<T> - supported 3.3+ Alias | Ref<T> . Useful annotating arguments Composables. MaybeRefOrGetter<T> - supported 3.3+ Alias | Ref<T> | (() => T) . Useful annotating arguments Composables. ExtractPropTypes<T> Extract prop types runtime props options object. extracted types internal facing - i.e. resolved props received component. means boolean props props default values always defined, even required. extract public facing props, i.e. props parent allowed pass, use ExtractPublicPropTypes . Example tsconst propsOptions = { foo: String, bar: Boolean, baz: { type: Number, required: true }, qux: { type: Number, default: 1 } } const type Props = ExtractPropTypes<typeof propsOptions> // { // foo?: string, // bar: boolean, // baz: number, // qux: number // } ExtractPublicPropTypes<T> - supported 3.3+ Extract prop types runtime props options object. extracted types public facing - i.e. props parent allowed pass. Example tsconst propsOptions = { foo: String, bar: Boolean, baz: { type: Number, required: true }, qux: { type: Number, default: 1 } } const type Props = ExtractPublicPropTypes<typeof propsOptions> // { // foo?: string, // bar?: boolean, // baz: number, // qux?: number // } ComponentCustomProperties Used augment component instance type support custom global properties. Example tsimport axios 'axios' declare module 'vue' { interface ComponentCustomProperties { $http: typeof axios $translate: (key: string) => string } } TIP Augmentations must placed module .ts or.d.ts file. See Type Augmentation Placement details.See also Guide - Augmenting Global Properties ComponentCustomOptions Used augment component options type support custom options. Example tsimport { Route } 'vue-router' declare module 'vue' { interface ComponentCustomOptions { beforeRouteEnter?(to: any, from: any, next: () => void): void } } TIP Augmentations must placed module .ts or.d.ts file. See Type Augmentation Placement details.See also Guide - Augmenting Custom Options ComponentCustomProps Used augment allowed TSX props order use non-declared props TSX elements. Example tsdeclare module 'vue' { interface ComponentCustomProps { hello?: string } } export {} tsx// works even hello declared prop <MyComponent hello=\"world\" /> TIP Augmentations must placed module .ts or.d.ts file. See Type Augmentation Placement details. CSSProperties Used augment allowed values style property bindings. Example Allow custom CSS property tsdeclare module 'vue' { interface CSSProperties { [key: `--${string}`]: string } } tsx<div style={ { '--bg-color': 'blue' } }> html<div :style=\"{ '--bg-color': 'blue' }\"></div> TIP Augmentations must placed module .ts .d.ts file. See Type Augmentation Placement details. See also SFC <style> tags support linking CSS values dynamic component state using v-bind CSS function. allows custom properties without type augmentation."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Introduction reading documentation Vue 3! - Vue 2 support ended Dec 31, 2023. Learn Vue 2 EOL. - Upgrading Vue 2? Check Migration Guide. Vue? Vue (pronounced /vju\u02d0/, like view) JavaScript framework building user interfaces. builds top standard HTML, CSS, JavaScript provides declarative, component-based programming model helps efficiently develop user interfaces complexity. minimal example: js import { createApp, ref } 'vue' createApp({ setup() { return { count: ref(0) } } }).mount('#app') template <div id=\"app\"> <button @click=\"count++\"> Count is: {{ count }} </button> </div> Result example demonstrates two core features Vue: Declarative Rendering: Vue extends standard HTML template syntax allows us declaratively describe HTML output based JavaScript state. Reactivity: Vue automatically tracks JavaScript state changes efficiently updates DOM changes happen. may already questions - worry. cover every little detail rest documentation. now, please read along high-level understanding Vue offers. Prerequisites rest documentation assumes basic familiarity HTML, CSS, JavaScript. totally new frontend development, might best idea jump right framework first step - grasp basics come back! check knowledge level overviews JavaScript, HTML CSS needed. Prior experience frameworks helps, required. Progressive Framework Vue framework ecosystem covers common features needed frontend development. web extremely diverse - things build web may vary drastically form scale. mind, Vue designed flexible incrementally adoptable. Depending use case, Vue used different ways: - Enhancing static HTML without build step - Embedding Web Components page - Single-Page Application (SPA) - Fullstack / Server-Side Rendering (SSR) - Jamstack / Static Site Generation (SSG) - Targeting desktop, mobile, WebGL, even terminal find concepts intimidating, worry! tutorial guide require basic HTML JavaScript knowledge, able follow along without expert these. experienced developer interested best integrate Vue stack, curious terms mean, discuss detail Ways Using Vue. Despite flexibility, core knowledge Vue works shared across use cases. Even beginner now, knowledge gained along way stay useful grow tackle ambitious goals future. veteran, pick optimal way leverage Vue based problems trying solve, retaining productivity. call Vue \"The Progressive Framework\": framework grow adapt needs. Single-File Components build-tool-enabled Vue projects, author Vue components using HTML-like file format called Single-File Component (also known *.vue files, abbreviated SFC). Vue SFC, name suggests, encapsulates component's logic (JavaScript), template (HTML), styles (CSS) single file. Here's previous example, written SFC format: vue <script setup> import { ref } 'vue' const count = ref(0) </script> <template> <button @click=\"count++\">Count is: {{ count }}</button> </template> <style scoped> button { font-weight: bold; } </style> SFC defining feature Vue recommended way author Vue components use case warrants build setup. learn SFC dedicated section - now, know Vue handle build tools setup you. API Styles Vue components authored two different API styles: Options API Composition API. Options API Options API, define component's logic using object options data , methods , mounted . Properties defined options exposed inside functions, points component instance: vue <script> export default { // Properties returned data() become reactive state // exposed `this`. data() { return { count: 0 } }, // Methods functions mutate state trigger updates. // bound event handlers templates. methods: { increment() { this.count++ } }, // Lifecycle hooks called different stages // component's lifecycle. // function called component mounted. mounted() { console.log(`The initial count ${this.count}.`) } } </script> <template> <button @click=\"increment\">Count is: {{ count }}</button> </template> Composition API Composition API, define component's logic using imported API functions. SFCs, Composition API typically used <script setup> . setup attribute hint makes Vue perform compile-time transforms allow us use Composition API less boilerplate. example, imports top-level variables / functions declared <script setup> directly usable template. component, exact template, using Composition API <script setup> instead: vue <script setup> import { ref, onMounted } 'vue' // reactive state const count = ref(0) // functions mutate state trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() => { console.log(`The initial count ${count.value}.`) }) </script> <template> <button @click=\"increment\">Count is: {{ count }}</button> </template> Choose? API styles fully capable covering common use cases. different interfaces powered exact underlying system. fact, Options API implemented top Composition API! fundamental concepts knowledge Vue shared across two styles. Options API centered around concept \"component instance\" (this seen example), typically aligns better class-based mental model users coming OOP language backgrounds. also beginner-friendly abstracting away reactivity details enforcing code organization via option groups. Composition API centered around declaring reactive state variables directly function scope composing state multiple functions together handle complexity. free-form requires understanding reactivity works Vue used effectively. return, flexibility enables powerful patterns organizing reusing logic. learn comparison two styles potential benefits Composition API Composition API FAQ. new Vue, here's general recommendation: learning purposes, go style looks easier understand you. Again, core concepts shared two styles. always pick style later. production use: Go Options API using build tools, plan use Vue primarily low-complexity scenarios, e.g. progressive enhancement. Go Composition API + Single-File Components plan build full applications Vue. commit one style learning phase. rest documentation provide code samples styles applicable, toggle time using API Preference switches top left sidebar. Still Got Questions? Check FAQ. Pick Learning Path Different developers different learning styles. Feel free pick learning path suits preference - although recommend going content, possible!"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Accessibility Web accessibility (also known a11y) refers practice creating websites used anyone \u2014 person disability, slow connection, outdated broken hardware simply someone unfavorable environment. example, adding subtitles video would help deaf hard-of-hearing users users loud environment can't hear phone. Similarly, making sure text low contrast help low-vision users users trying use phone bright sunlight. Ready start aren\u2019t sure where? Checkout Planning managing web accessibility guide provided World Wide Web Consortium (W3C) Skip link add link top page goes directly main content area users skip content repeated multiple Web pages. Typically done top App.vue first focusable element pages: template <ul class=\"skip-links\"> <li> <a href=\"#main\" ref=\"skipLink\" class=\"skip-link\">Skip main content</a> </li> </ul> hide link unless focused, add following style: css .skip-link { white-space: nowrap; margin: 1em auto; top: 0; position: fixed; left: 50%; margin-left: -72px; opacity: 0; } .skip-link:focus { opacity: 1; background-color: white; padding: 0.5em; border: 1px solid black; } user changes route, bring focus back skip link. achieved calling focus skip link's template ref (assuming usage vue-router ): vue <script setup> import { ref, watch } 'vue' import { useRoute } 'vue-router' const route = useRoute() const skipLink = ref() watch( () => route.path, () => { skipLink.value.focus() } ) </script> Read documentation skip link main content Content Structure One important pieces accessibility making sure design support accessible implementation. Design consider color contrast, font selection, text sizing, language, also content structured application. Headings Users navigate application headings. descriptive headings every section application makes easier users predict content section. comes headings, couple recommended accessibility practices: - Nest headings ranking order: <h1> -<h6> - Don\u2019t skip headings within section - Use actual heading tags instead styling text give visual appearance headings template <main role=\"main\" aria-labelledby=\"main-title\"> <h1 id=\"main-title\">Main title</h1> <section aria-labelledby=\"section-title-1\"> <h2 id=\"section-title-1\"> Section Title </h2> <h3>Section Subtitle</h3> <!-- Content --> </section> <section aria-labelledby=\"section-title-2\"> <h2 id=\"section-title-2\"> Section Title </h2> <h3>Section Subtitle</h3> <!-- Content --> <h3>Section Subtitle</h3> <!-- Content --> </section> </main> Landmarks Landmarks provide programmatic access sections within application. Users rely assistive technology navigate section application skip content. use ARIA roles help achieve this. | HTML | ARIA Role | Landmark Purpose | |---|---|---| | header | role=\"banner\" | Prime heading: title page | | nav | role=\"navigation\" | Collection links suitable use navigating document related documents | | main | role=\"main\" | main central content document. | | footer | role=\"contentinfo\" | Information parent document: footnotes/copyrights/links privacy statement | | aside | role=\"complementary\" | Supports main content, yet separated meaningful content | | search | role=\"search\" | section contains search functionality application | | form | role=\"form\" | Collection form-associated elements | | section | role=\"region\" | Content relevant users likely want navigate to. Label must provided element | Semantic Forms creating form, use following elements: <form> , <label> , <input> , <textarea> , <button> Labels typically placed top left form fields: template <form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\"> <div v-for=\"item formItems\" :key=\"item.id\" class=\"form-item\"> <label :for=\"item.id\">{{ item.label }}: </label> <input :type=\"item.type\" :id=\"item.id\" :name=\"item.id\" v-model=\"item.value\" /> </div> <button type=\"submit\">Submit</button> </form> Notice include autocomplete='on' form element apply inputs form. also set different values autocomplete attribute input. Labels Provide labels describe purpose form control; linking id : template <label for=\"name\">Name: </label> <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" /> inspect element Chrome DevTools open Accessibility tab inside Elements tab, see input gets name label: Warning: Though might seen labels wrapping input fields like this: template <label> Name: <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" /> </label> Explicitly setting labels matching id better supported assistive technology. aria-label also give input accessible name aria-label . template <label for=\"name\">Name: </label> <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" :aria-label=\"nameLabel\" /> Feel free inspect element Chrome DevTools see accessible name changed: aria-labelledby Using aria-labelledby similar aria-label except used label text visible screen. paired elements id link multiple id s: template <form class=\"demo\" action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\" > <h1 id=\"billing\">Billing</h1> <div class=\"form-item\"> <label for=\"name\">Name: </label> <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" aria-labelledby=\"billing name\" /> </div> <button type=\"submit\">Submit</button> </form> aria-describedby aria-describedby used way aria-labelledby except provides description additional information user might need. used describe criteria input: template <form class=\"demo\" action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\" > <h1 id=\"billing\">Billing</h1> <div class=\"form-item\"> <label for=\"name\">Full Name: </label> <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" aria-labelledby=\"billing name\" aria-describedby=\"nameDescription\" /> <p id=\"nameDescription\">Please provide first last name.</p> </div> <button type=\"submit\">Submit</button> </form> see description inspecting Chrome DevTools: Placeholder Avoid using placeholders confuse many users. One issues placeholders meet color contrast criteria default; fixing color contrast makes placeholder look like pre-populated data input fields. Looking following example, see Last Name placeholder meets color contrast criteria looks like pre-populated data: template <form class=\"demo\" action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\" > <div v-for=\"item formItems\" :key=\"item.id\" class=\"form-item\"> <label :for=\"item.id\">{{ item.label }}: </label> <input type=\"text\" :id=\"item.id\" :name=\"item.id\" v-model=\"item.value\" :placeholder=\"item.placeholder\" /> </div> <button type=\"submit\">Submit</button> </form> css /* https://www.w3schools.com/howto/howto_css_placeholder.asp */ #lastName::placeholder { /* Chrome, Firefox, Opera, Safari 10.1+ */ color: black; opacity: 1; /* Firefox */ } #lastName:-ms-input-placeholder { /* Internet Explorer 10-11 */ color: black; } #lastName::-ms-input-placeholder { /* Microsoft Edge */ color: black; } best provide information user needs fill forms outside inputs. Instructions adding instructions input fields, make sure link correctly input. provide additional instructions bind multiple ids inside aria-labelledby . allows flexible design. template <fieldset> <legend>Using aria-labelledby</legend> <label id=\"date-label\" for=\"date\">Current Date: </label> <input type=\"date\" name=\"date\" id=\"date\" aria-labelledby=\"date-label date-instructions\" /> <p id=\"date-instructions\">MM/DD/YYYY</p> </fieldset> Alternatively, attach instructions input aria-describedby : template <fieldset> <legend>Using aria-describedby</legend> <label id=\"dob\" for=\"dob\">Date Birth: </label> <input type=\"date\" name=\"dob\" id=\"dob\" aria-describedby=\"dob-instructions\" /> <p id=\"dob-instructions\">MM/DD/YYYY</p> </fieldset> Hiding Content Usually recommended visually hide labels, even input accessible name. However, functionality input understood surrounding content, hide visual label. Let's look search field: template <form role=\"search\"> <label for=\"search\" class=\"hidden-visually\">Search: </label> <input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" /> <button type=\"submit\">Search</button> </form> search button help visual users identify purpose input field. use CSS visually hide elements keep available assistive technology: css .hidden-visually { position: absolute; overflow: hidden; white-space: nowrap; margin: 0; padding: 0; height: 1px; width: 1px; clip: rect(0 0 0 0); clip-path: inset(100%); } aria-hidden=\"true\" Adding aria-hidden=\"true\" hide element assistive technology leave visually available users. use focusable elements, purely decorative, duplicated offscreen content. template <p>This hidden screen readers.</p> <p aria-hidden=\"true\">This hidden screen readers.</p> Buttons using buttons inside form, must set type prevent submitting form. also use input create buttons: template <form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\"> <!-- Buttons --> <button type=\"button\">Cancel</button> <button type=\"submit\">Submit</button> <!-- Input buttons --> <input type=\"button\" value=\"Cancel\" /> <input type=\"submit\" value=\"Submit\" /> </form> Functional Images use technique create functional images. Input fields - images act submit type button forms template<form role=\"search\"> <label for=\"search\" class=\"hidden-visually\">Search: </label> <input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" /> <input type=\"image\" class=\"btnImg\" src=\"https://img.icons8.com/search\" alt=\"Search\" /> </form> Icons template <form role=\"search\"> <label for=\"searchIcon\" class=\"hidden-visually\">Search: </label> <input type=\"text\" name=\"searchIcon\" id=\"searchIcon\" v-model=\"searchIcon\" /> <button type=\"submit\"> <i class=\"fas fa-search\" aria-hidden=\"true\"></i> <span class=\"hidden-visually\">Search</span> </button> </form> Standards World Wide Web Consortium (W3C) Web Accessibility Initiative (WAI) develops web accessibility standards different components: - User Agent Accessibility Guidelines (UAAG) - web browsers media players, including aspects assistive technologies - Authoring Tool Accessibility Guidelines (ATAG) - authoring tools - Web Content Accessibility Guidelines (WCAG) - web content - used developers, authoring tools, accessibility evaluation tools Web Content Accessibility Guidelines (WCAG) WCAG 2.1 extends WCAG 2.0 allows implementation new technologies addressing changes web. W3C encourages use current version WCAG developing updating Web accessibility policies. WCAG 2.1 Four Main Guiding Principles (abbreviated POUR): - Perceivable - Users must able perceive information presented - Operable - Interface forms, controls, navigation operable - Understandable - Information operation user interface must understandable users - Robust - Users must able access content technologies advance Web Accessibility Initiative \u2013 Accessible Rich Internet Applications (WAI-ARIA) W3C's WAI-ARIA provides guidance build dynamic content advanced user interface controls. Resources Documentation - WCAG 2.0 - WCAG 2.1 - Accessible Rich Internet Applications (WAI-ARIA) 1.2 - WAI-ARIA Authoring Practices 1.2 Assistive Technologies Testing - Automated Tools - Color Tools - Helpful Tools Users World Health Organization estimates 15% world's population form disability, 2-4% severely so. estimated 1 billion people worldwide; making people disabilities largest minority group world. huge range disabilities, divided roughly four categories: - Visual - users benefit use screen readers, screen magnification, controlling screen contrast, braille display. - Auditory - users benefit captioning, transcripts sign language video. - Motor - users benefit range assistive technologies motor impairments: voice recognition software, eye tracking, single-switch access, head wand, sip puff switch, oversized trackball mouse, adaptive keyboard assistive technologies. - Cognitive - users benefit supplemental media, structural organization content, clear simple writing. Check following links WebAim understand users:"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Performance Overview Vue designed performant common use cases without much need manual optimizations. However, always challenging scenarios extra fine-tuning needed. section, discuss pay attention comes performance Vue application. First, let's discuss two major aspects web performance: Page Load Performance: fast application shows content becomes interactive initial visit. usually measured using web vital metrics like Largest Contentful Paint (LCP) First Input Delay (FID). Update Performance: fast application updates response user input. example, fast list updates user types search box, fast page switches user clicks navigation link Single-Page Application (SPA). would ideal maximize both, different frontend architectures tend affect easy attain desired performance aspects. addition, type application building greatly influences prioritize terms performance. Therefore, first step ensuring optimal performance picking right architecture type application building: Consult Ways Using Vue see leverage Vue different ways. Jason Miller discusses types web applications respective ideal implementation / delivery Application Holotypes. Profiling Options improve performance, need first know measure it. number great tools help regard: profiling load performance production deployments: profiling performance local development: - Chrome DevTools Performance Panel app.config.performance enables Vue-specific performance markers Chrome DevTools' performance timeline. - Vue DevTools Extension also provides performance profiling feature. Page Load Optimizations many framework-agnostic aspects optimizing page load performance - check web.dev guide comprehensive round up. Here, primarily focus techniques specific Vue. Choosing Right Architecture use case sensitive page load performance, avoid shipping pure client-side SPA. want server directly sending HTML containing content users want see. Pure client-side rendering suffers slow time-to-content. mitigated Server-Side Rendering (SSR) Static Site Generation (SSG). Check SSR Guide learn performing SSR Vue. app rich interactivity requirements, also use traditional backend server render HTML enhance Vue client. main application SPA, marketing pages (landing, about, blog), ship separately! marketing pages ideally deployed static HTML minimal JS, using SSG. Bundle Size Tree-shaking One effective ways improve page load performance shipping smaller JavaScript bundles. ways reduce bundle size using Vue: Use build step possible. Many Vue's APIs \"tree-shakable\" bundled via modern build tool. example, use built-in <Transition> component, included final production bundle. Tree-shaking also remove unused modules source code.When using build step, templates pre-compiled need ship Vue compiler browser. saves 14kb min+gzipped JavaScript avoids runtime compilation cost. cautious size introducing new dependencies! real-world applications, bloated bundles often result introducing heavy dependencies without realizing it. using build step, prefer dependencies offer ES module formats tree-shaking friendly. example, prefer lodash-es overlodash .Check dependency's size evaluate whether worth functionality provides. Note dependency tree-shaking friendly, actual size increase depend APIs actually import it. Tools like bundlejs.com used quick checks, measuring actual build setup always accurate. using Vue primarily progressive enhancement prefer avoid build step, consider using petite-vue (only 6kb) instead. Code Splitting Code splitting build tool splits application bundle multiple smaller chunks, loaded demand parallel. proper code splitting, features required page load downloaded immediately, additional chunks lazy loaded needed, thus improving performance. Bundlers like Rollup (which Vite based upon) webpack automatically create split chunks detecting ESM dynamic import syntax: js // lazy.js dependencies split separate chunk // loaded `loadLazy()` called. function loadLazy() { return import('./lazy.js') } Lazy loading best used features immediately needed initial page load. Vue applications, used combination Vue's Async Component feature create split chunks component trees: js import { defineAsyncComponent } 'vue' // separate chunk created Foo.vue dependencies. // fetched demand async component // rendered page. const Foo = defineAsyncComponent(() => import('./Foo.vue')) applications using Vue Router, strongly recommended use lazy loading route components. Vue Router explicit support lazy loading, separate defineAsyncComponent . See Lazy Loading Routes details. Update Optimizations Props Stability Vue, child component updates least one received props changed. Consider following example: template <ListItem v-for=\"item list\" :id=\"item.id\" :active-id=\"activeId\" /> Inside <ListItem> component, uses id activeId props determine whether currently active item. works, problem whenever activeId changes, every <ListItem> list update! Ideally, items whose active status changed update. achieve moving active status computation parent, make <ListItem> directly accept active prop instead: template <ListItem v-for=\"item list\" :id=\"item.id\" :active=\"item.id === activeId\" /> Now, components active prop remain activeId changes, longer need update. general, idea keeping props passed child components stable possible. v-once v-once built-in directive used render content relies runtime data never needs update. entire sub-tree used skipped future updates. Consult API reference details. v-memo v-memo built-in directive used conditionally skip update large sub-trees v-for lists. Consult API reference details. Computed Stability Vue 3.4 above, computed property trigger effects computed value changed previous one. example, following isEven computed triggers effects returned value changed true false , vice-versa: js const count = ref(0) const isEven = computed(() => count.value % 2 === 0) watchEffect(() => console.log(isEven.value)) // true // trigger new logs computed value stays `true` count.value = 2 count.value = 4 reduces unnecessary effect triggers, unfortunately work computed creates new object compute: js const computedObj = computed(() => { return { isEven: count.value % 2 === 0 } }) new object created time, new value technically always different old value. Even isEven property remains same, Vue able know unless performs deep comparison old value new value. comparison could expensive likely worth it. Instead, optimize manually comparing new value old value, conditionally returning old value know nothing changed: js const computedObj = computed((oldValue) => { const newValue = { isEven: count.value % 2 === 0 } (oldValue && oldValue.isEven === newValue.isEven) { return oldValue } return newValue }) Note always perform full computation comparing returning old value, dependencies collected every run. General Optimizations following tips affect page load update performance. Virtualize Large Lists One common performance issues frontend applications rendering large lists. matter performant framework is, rendering list thousands items slow due sheer number DOM nodes browser needs handle. However, necessarily render nodes upfront. cases, user's screen size display small subset large list. greatly improve performance list virtualization, technique rendering items currently close viewport large list. Implementing list virtualization easy, luckily existing community libraries directly use: Reduce Reactivity Overhead Large Immutable Structures Vue's reactivity system deep default. makes state management intuitive, create certain level overhead data size large, every property access triggers proxy traps perform dependency tracking. typically becomes noticeable dealing large arrays deeply nested objects, single render needs access 100,000+ properties, affect specific use cases. Vue provide escape hatch opt-out deep reactivity using shallowRef() shallowReactive() . Shallow APIs create state reactive root level, exposes nested objects untouched. keeps nested property access fast, trade-off must treat nested objects immutable, updates triggered replacing root state: js const shallowArray = shallowRef([ /* big list deep objects */ ]) // trigger updates... shallowArray.value.push(newObject) // does: shallowArray.value = [...shallowArray.value, newObject] // trigger updates... shallowArray.value[0].foo = 1 // does: shallowArray.value = [ { ...shallowArray.value[0], foo: 1 }, ...shallowArray.value.slice(1) ] Avoid Unnecessary Component Abstractions Sometimes may create renderless components higher-order components (i.e. components render components extra props) better abstraction code organization. nothing wrong this, keep mind component instances much expensive plain DOM nodes, creating many due abstraction patterns incur performance costs. Note reducing instances noticeable effect, sweat component rendered times app. best scenario consider optimization large lists. Imagine list 100 items item component contains many child components. Removing one unnecessary component abstraction could result reduction hundreds component instances."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Production Deployment Development vs. Production development, Vue provides number features improve development experience: - Warning common errors pitfalls - Props / events validation - Reactivity debugging hooks - Devtools integration However, features become useless production. warning checks also incur small amount performance overhead. deploying production, drop unused, development-only code branches smaller payload size better performance. Without Build Tools using Vue without build tool loading CDN self-hosted script, make sure use production build (dist files end .prod.js ) deploying production. Production builds pre-minified development-only code branches removed. - using global build (accessing via Vue global): usevue.global.prod.js . - using ESM build (accessing via native ESM imports): use vue.esm-browser.prod.js . Consult dist file guide details. Build Tools Projects scaffolded via create-vue (based Vite) Vue CLI (based webpack) pre-configured production builds. using custom setup, make sure that: vue resolves tovue.runtime.esm-bundler.js .- compile time feature flags properly configured. process.env replaced with.NODE_ENV \"production\" build. Additional references: Tracking Runtime Errors app-level error handler used report errors tracking services: js import { createApp } 'vue' const app = createApp(...) app.config.errorHandler = (err, instance, info) => { // report error tracking services } Services Sentry Bugsnag also provide official integrations Vue."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Security Reporting Vulnerabilities vulnerability reported, immediately becomes top concern, full-time contributor dropping everything work it. report vulnerability, please email security@vuejs.org. discovery new vulnerabilities rare, also recommend always using latest versions Vue official companion libraries ensure application remains secure possible. Rule No.1: Never Use Non-trusted Templates fundamental security rule using Vue never use non-trusted content component template. equivalent allowing arbitrary JavaScript execution application - worse, could lead server breaches code executed server-side rendering. example usage: js Vue.createApp({ template: `<div>` + userProvidedString + `</div>` // NEVER }).mount('#app') Vue templates compiled JavaScript, expressions inside templates executed part rendering process. Although expressions evaluated specific rendering context, due complexity potential global execution environments, impractical framework like Vue completely shield potential malicious code execution without incurring unrealistic performance overhead. straightforward way avoid category problems altogether make sure contents Vue templates always trusted entirely controlled you. Vue Protect HTML content Whether using templates render functions, content automatically escaped. means template: template <h1>{{ userProvidedString }}</h1> userProvidedString contained: js '<script>alert(\"hi\")</script>' would escaped following HTML: template <script>alert(\"hi\")</script> thus preventing script injection. escaping done using native browser APIs, like textContent , vulnerability exist browser vulnerable. Attribute bindings Similarly, dynamic attribute bindings also automatically escaped. means template: template <h1 :title=\"userProvidedString\"> hello </h1> userProvidedString contained: js '\" onclick=\"alert(\\'hi\\')' would escaped following HTML: template \" onclick=\"alert('hi') thus preventing close title attribute inject new, arbitrary HTML. escaping done using native browser APIs, like setAttribute , vulnerability exist browser vulnerable. Potential Dangers web application, allowing unsanitized, user-provided content executed HTML, CSS, JavaScript potentially dangerous, avoided wherever possible. times risk may acceptable, though. example, services like CodePen JSFiddle allow user-provided content executed, context expected sandboxed extent inside iframes. cases important feature inherently requires level vulnerability, team weigh importance feature worst-case scenarios vulnerability enables. HTML Injection learned earlier, Vue automatically escapes HTML content, preventing accidentally injecting executable HTML application. However, cases know HTML safe, explicitly render HTML content: Using template: template<div v-html=\"userProvidedHtml\"></div> Using render function: jsh('div', { innerHTML: this.userProvidedHtml }) Using render function JSX: jsx<div innerHTML={this.userProvidedHtml}></div> WARNING User-provided HTML never considered 100% safe unless sandboxed iframe part app user wrote HTML ever exposed it. Additionally, allowing users write Vue templates brings similar dangers. URL Injection URL like this: template <a :href=\"userProvidedUrl\"> click </a> There's potential security issue URL \"sanitized\" prevent JavaScript execution using javascript: . libraries sanitize-url help this, note: ever URL sanitization frontend, already security issue. User-provided URLs always sanitized backend even saved database. problem avoided every client connecting API, including native mobile apps. Also note even sanitized URLs, Vue cannot help guarantee lead safe destinations. Style Injection Looking example: template <a :href=\"sanitizedUrl\" :style=\"userProvidedStyles\" > click </a> Let's assume sanitizedUrl sanitized, definitely real URL JavaScript. userProvidedStyles , malicious users could still provide CSS \"click jack\", e.g. styling link transparent box \"Log in\" button. https://user-controlled-website.com/ built resemble login page application, might captured user's real login information. may able imagine allowing user-provided content <style> element would create even greater vulnerability, giving user full control style entire page. That's Vue prevents rendering style tags inside templates, as: template <style>{{ userProvidedStyles }}</style> keep users fully safe clickjacking, recommend allowing full control CSS inside sandboxed iframe. Alternatively, providing user control style binding, recommend using object syntax allowing users provide values specific properties safe control, like this: template <a :href=\"sanitizedUrl\" :style=\"{ color: userProvidedColor, background: userProvidedBackground }\" > click </a> JavaScript Injection strongly discourage ever rendering <script> element Vue, since templates render functions never side effects. However, way include strings would evaluated JavaScript runtime. Every HTML element attributes values accepting strings JavaScript, onclick , onfocus , onmouseenter . Binding user-provided JavaScript event attributes potential security risk, avoided. WARNING User-provided JavaScript never considered 100% safe unless sandboxed iframe part app user wrote JavaScript ever exposed it. Sometimes receive vulnerability reports possible cross-site scripting (XSS) Vue templates. general, consider cases actual vulnerabilities there's practical way protect developers two scenarios would allow XSS: developer explicitly asking Vue render user-provided, unsanitized content Vue templates. inherently unsafe, there's way Vue know origin. developer mounting Vue entire HTML page happens contain server-rendered user-provided content. fundamentally problem #1, sometimes devs may without realizing it. lead possible vulnerabilities attacker provides HTML safe plain HTML unsafe Vue template. best practice never mount Vue nodes may contain server-rendered user-provided content. Best Practices general rule allow unsanitized, user-provided content executed (as either HTML, JavaScript, even CSS), might open attacks. advice actually holds true whether using Vue, another framework, even framework. Beyond recommendations made Potential Dangers, also recommend familiarizing resources: use learn also review source code dependencies potentially dangerous patterns, include 3rd-party components otherwise influence what's rendered DOM. Backend Coordination HTTP security vulnerabilities, cross-site request forgery (CSRF/XSRF) cross-site script inclusion (XSSI), primarily addressed backend, concern Vue's. However, still good idea communicate backend team learn best interact API, e.g., submitting CSRF tokens form submissions. Server-Side Rendering (SSR) additional security concerns using SSR, make sure follow best practices outlined throughout SSR documentation avoid vulnerabilities."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "KeepAlive <KeepAlive> built-in component allows us conditionally cache component instances dynamically switching multiple components. Basic Usage Component Basics chapter, introduced syntax Dynamic Components, using <component> special element: template <component :is=\"activeComponent\" /> default, active component instance unmounted switching away it. cause changed state holds lost. component displayed again, new instance created initial state. example below, two stateful components - contains counter, B contains message synced input via v-model . Try updating state one them, switch away, switch back it: Current component: Count: 0You'll notice switched back, previous changed state would reset. Creating fresh component instance switch normally useful behavior, case, we'd really like two component instances preserved even inactive. solve problem, wrap dynamic component <KeepAlive> built-in component: template <!-- Inactive components cached! --> <KeepAlive> <component :is=\"activeComponent\" /> </KeepAlive> Now, state persisted across component switches: Current component: Count: 0TIP used in-DOM templates, referenced <keep-alive> . Include / Exclude default, <KeepAlive> cache component instance inside. customize behavior via include exclude props. props comma-delimited string, RegExp , array containing either types: template <!-- comma-delimited string --> <KeepAlive include=\"a,b\"> <component :is=\"view\" /> </KeepAlive> <!-- regex (use `v-bind`) --> <KeepAlive :include=\"/a|b/\"> <component :is=\"view\" /> </KeepAlive> <!-- Array (use `v-bind`) --> <KeepAlive :include=\"['a', 'b']\"> <component :is=\"view\" /> </KeepAlive> match checked component's name option, components need conditionally cached KeepAlive must explicitly declare name option. TIP Since version 3.2.34, single-file component using <script setup> automatically infer name option based filename, removing need manually declare name. Max Cached Instances limit maximum number component instances cached via max prop. max specified, <KeepAlive> behaves like LRU cache: number cached instances exceed specified max count, least recently accessed cached instance destroyed make room new one. template <KeepAlive :max=\"10\"> <component :is=\"activeComponent\" /> </KeepAlive> Lifecycle Cached Instance component instance removed DOM part component tree cached <KeepAlive> , goes deactivated state instead unmounted. component instance inserted DOM part cached tree, activated. kept-alive component register lifecycle hooks two states using onActivated() onDeactivated() : vue <script setup> import { onActivated, onDeactivated } 'vue' onActivated(() => { // called initial mount // every time re-inserted cache }) onDeactivated(() => { // called removed DOM cache // also unmounted }) </script> Note that: onActivated also called mount, andonDeactivated unmount.Both hooks work root component cached <KeepAlive> , also descendant components cached tree. Related"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Suspense Experimental Feature <Suspense> experimental feature. guaranteed reach stable status API may change does. <Suspense> built-in component orchestrating async dependencies component tree. render loading state waiting multiple nested async dependencies component tree resolved. Async Dependencies explain problem <Suspense> trying solve interacts async dependencies, let's imagine component hierarchy like following: <Suspense> \u2514\u2500 <Dashboard> \u251c\u2500 <Profile> \u2502 \u2514\u2500 <FriendStatus> (component async setup()) \u2514\u2500 <Content> \u251c\u2500 <ActivityFeed> (async component) \u2514\u2500 <Stats> (async component) component tree multiple nested components whose rendering depends async resource resolved first. Without <Suspense> , need handle loading / error loaded states. worst case scenario, may see three loading spinners page, content displayed different times. <Suspense> component gives us ability display top-level loading / error states wait nested async dependencies resolved. two types async dependencies <Suspense> wait on: Components async setup() hook. includes components using<script setup> top-levelawait expressions. async setup() Composition API component's setup() hook async: js export default { async setup() { const res = await fetch(...) const posts = await res.json() return { posts } } } using <script setup> , presence top-level await expressions automatically makes component async dependency: vue <script setup> const res = await fetch(...) const posts = await res.json() </script> <template> {{ posts }} </template> Async Components Async components \"suspensible\" default. means <Suspense> parent chain, treated async dependency <Suspense> . case, loading state controlled <Suspense> , component's loading, error, delay timeout options ignored. async component opt-out Suspense control let component always control loading state specifying suspensible: false options. Loading State <Suspense> component two slots: #default #fallback . slots allow one immediate child node. node default slot shown possible. not, node fallback slot shown instead. template <Suspense> <!-- component nested async dependencies --> <Dashboard /> <!-- loading state via #fallback slot --> <template #fallback> Loading... </template> </Suspense> initial render, <Suspense> render default slot content memory. async dependencies encountered process, enter pending state. pending state, fallback content displayed. encountered async dependencies resolved, <Suspense> enters resolved state resolved default slot content displayed. async dependencies encountered initial render, <Suspense> directly go resolved state. resolved state, <Suspense> revert pending state root node #default slot replaced. New async dependencies nested deeper tree cause <Suspense> revert pending state. revert happens, fallback content immediately displayed. Instead, <Suspense> display previous #default content waiting new content async dependencies resolved. behavior configured timeout prop: <Suspense> switch fallback content takes longer timeout render new default content. timeout value 0 cause fallback content displayed immediately default content replaced. Events <Suspense> component emits 3 events: pending , resolve fallback . pending event occurs entering pending state. resolve event emitted new content finished resolving default slot. fallback event fired contents fallback slot shown. events could used, example, show loading indicator front old DOM new components loading. Error Handling <Suspense> currently provide error handling via component - however, use errorCaptured option onErrorCaptured() hook capture handle async errors parent component <Suspense> . Combining Components common want use <Suspense> combination <Transition> <KeepAlive> components. nesting order components important get working correctly. addition, components often used conjunction <RouterView> component Vue Router. following example shows nest components behave expected. simpler combinations remove components need: template <RouterView v-slot=\"{ Component }\"> <template v-if=\"Component\"> <Transition mode=\"out-in\"> <KeepAlive> <Suspense> <!-- main content --> <component :is=\"Component\"></component> <!-- loading state --> <template #fallback> Loading... </template> </Suspense> </KeepAlive> </Transition> </template> </RouterView> Vue Router built-in support lazily loading components using dynamic imports. distinct async components currently trigger <Suspense> . However, still async components descendants trigger <Suspense> usual way. Nested Suspense - supported 3.3+ multiple async components (common nested layout-based routes) like this: template <Suspense> <component :is=\"DynamicAsyncOuter\"> <component :is=\"DynamicAsyncInner\" /> </component> </Suspense> <Suspense> creates boundary resolve async components tree, expected. However, change DynamicAsyncOuter , <Suspense> awaits correctly, change DynamicAsyncInner , nested DynamicAsyncInner renders empty node resolved (instead previous one fallback slot). order solve that, could nested suspense handle patch nested component, like: template <Suspense> <component :is=\"DynamicAsyncOuter\"> <Suspense suspensible> <!-- --> <component :is=\"DynamicAsyncInner\" /> </Suspense> </component> </Suspense> set suspensible prop, inner <Suspense> treated like sync component parent <Suspense> . means fallback slot Dynamic components change time, might empty nodes multiple patching cycles child <Suspense> loading dependency tree, might desirable. set, async dependency handling given parent <Suspense> (including events emitted) inner <Suspense> serves solely another boundary dependency resolution patching. Related"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Teleport <Teleport> built-in component allows us \"teleport\" part component's template DOM node exists outside DOM hierarchy component. Basic Usage Sometimes part component's template belongs logically, visual standpoint, displayed somewhere else DOM, perhaps even outside Vue application. common example building full-screen modal. Ideally, want code modal's button modal written within single-file component, since related open / close state modal. means modal rendered alongside button, deeply nested application's DOM hierarchy. create tricky issues positioning modal via CSS. Consider following HTML structure. template <div class=\"outer\"> <h3>Vue Teleport Example</h3> <div> <MyModal /> </div> </div> implementation <MyModal> : vue <script setup> import { ref } 'vue' const open = ref(false) </script> <template> <button @click=\"open = true\">Open Modal</button> <div v-if=\"open\" class=\"modal\"> <p>Hello modal!</p> <button @click=\"open = false\">Close</button> </div> </template> <style scoped> .modal { position: fixed; z-index: 999; top: 20%; left: 50%; width: 300px; margin-left: -150px; } </style> component contains <button> trigger opening modal, <div> class .modal , contain modal's content button self-close. using component inside initial HTML structure, number potential issues: position: fixed places element relative viewport ancestor element hastransform ,perspective orfilter property set. If, example, intend animate ancestor<div class=\"outer\"> CSS transform, would break modal layout!The modal's z-index constrained containing elements. another element overlaps with<div class=\"outer\"> higherz-index , would cover modal. <Teleport> provides clean way work around these, allowing us break nested DOM structure. Let's modify <MyModal> use <Teleport> : template <button @click=\"open = true\">Open Modal</button> <Teleport to=\"body\"> <div v-if=\"open\" class=\"modal\"> <p>Hello modal!</p> <button @click=\"open = false\">Close</button> </div> </Teleport> target <Teleport> expects CSS selector string actual DOM node. Here, essentially telling Vue \"teleport template fragment body tag\". click button inspect <body> tag via browser's devtools: combine <Teleport> <Transition> create animated modals - see Example here. TIP teleport target must already DOM <Teleport> component mounted. Ideally, element outside entire Vue application. targeting another element rendered Vue, need make sure element mounted <Teleport> . Using Components <Teleport> alters rendered DOM structure - affect logical hierarchy components. say, <Teleport> contains component, component remain logical child parent component containing <Teleport> . Props passing event emitting continue work way. also means injections parent component work expected, child component nested parent component Vue Devtools, instead placed actual content moved to. Disabling Teleport cases, may want conditionally disable <Teleport> . example, may want render component overlay desktop, inline mobile. <Teleport> supports disabled prop dynamically toggled: template <Teleport :disabled=\"isMobile\"> ... </Teleport> could dynamically update isMobile . Multiple Teleports Target common use case would reusable <Modal> component, potential multiple instances active time. kind scenario, multiple <Teleport> components mount content target element. order simple append, later mounts located earlier ones, within target element. Given following usage: template <Teleport to=\"#modals\"> <div>A</div> </Teleport> <Teleport to=\"#modals\"> <div>B</div> </Teleport> rendered result would be: html <div id=\"modals\"> <div>A</div> <div>B</div> </div> Deferred Teleport Vue 3.5 above, use defer prop defer target resolving Teleport parts application mounted. allows Teleport target container element rendered Vue, later part component tree: template <Teleport defer to=\"#late-div\">...</Teleport> <!-- somewhere later template --> <div id=\"late-div\"></div> Note target element must rendered mount / update tick Teleport - i.e. <div> mounted second later, Teleport still report error. defer works similarly mounted lifecycle hook. Related"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Transition Vue offers two built-in components help work transitions animations response changing state: <Transition> applying animations element component entering leaving DOM. covered page.<TransitionGroup> applying animations element component inserted into, removed from, moved within av-for list. covered next chapter. Aside two components, also apply animations Vue using techniques toggling CSS classes state-driven animations via style bindings. additional techniques covered Animation Techniques chapter. <Transition> Component <Transition> built-in component: means available component's template without register it. used apply enter leave animations elements components passed via default slot. enter leave triggered one following: - Conditional rendering via v-if - Conditional display via v-show - Dynamic components toggling via <component> special element - Changing special key attribute example basic usage: template <button @click=\"show = !show\">Toggle</button> <Transition> <p v-if=\"show\">hello</p> </Transition> css /* explain classes next! */ .v-enter-active, .v-leave-active { transition: opacity 0.5s ease; } .v-enter-from, .v-leave-to { opacity: 0; } hello TIP <Transition> supports single element component slot content. content component, component must also one single root element. element <Transition> component inserted removed, happens: Vue automatically sniff whether target element CSS transitions animations applied. does, number CSS transition classes added / removed appropriate timings. listeners JavaScript hooks, hooks called appropriate timings. CSS transitions / animations detected JavaScript hooks provided, DOM operations insertion and/or removal executed browser's next animation frame. CSS-Based Transitions Transition Classes six classes applied enter / leave transitions. v-enter-from : Starting state enter. Added element inserted, removed one frame element inserted.v-enter-active : Active state enter. Applied entire entering phase. Added element inserted, removed transition/animation finishes. class used define duration, delay easing curve entering transition.v-enter-to : Ending state enter. Added one frame element inserted (at timev-enter-from removed), removed transition/animation finishes.v-leave-from : Starting state leave. Added immediately leaving transition triggered, removed one frame.v-leave-active : Active state leave. Applied entire leaving phase. Added immediately leaving transition triggered, removed transition/animation finishes. class used define duration, delay easing curve leaving transition.v-leave-to : Ending state leave. Added one frame leaving transition triggered (at timev-leave-from removed), removed transition/animation finishes. v-enter-active v-leave-active give us ability specify different easing curves enter / leave transitions, we'll see example following sections. Named Transitions transition named via name prop: template <Transition name=\"fade\"> ... </Transition> named transition, transition classes prefixed name instead v . example, applied class transition fade-enter-active instead v-enter-active . CSS fade transition look like this: css .fade-enter-active, .fade-leave-active { transition: opacity 0.5s ease; } .fade-enter-from, .fade-leave-to { opacity: 0; } CSS Transitions <Transition> commonly used combination native CSS transitions, seen basic example above. transition CSS property shorthand allows us specify multiple aspects transition, including properties animated, duration transition, easing curves. advanced example transitions multiple properties, different durations easing curves enter leave: template <Transition name=\"slide-fade\"> <p v-if=\"show\">hello</p> </Transition> css /* Enter leave animations use different durations timing functions. */ .slide-fade-enter-active { transition: 0.3s ease-out; } .slide-fade-leave-active { transition: 0.8s cubic-bezier(1, 0.5, 0.8, 1); } .slide-fade-enter-from, .slide-fade-leave-to { transform: translateX(20px); opacity: 0; } hello CSS Animations Native CSS animations applied way CSS transitions, difference *-enter-from removed immediately element inserted, animationend event. CSS animations, simply declare *-enter-active *-leave-active classes. Here's example: template <Transition name=\"bounce\"> <p v-if=\"show\" style=\"text-align: center;\"> Hello bouncy text! </p> </Transition> css .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.25); } 100% { transform: scale(1); } } Hello bouncy text! Custom Transition Classes also specify custom transition classes passing following props <Transition> : enter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class override conventional class names. especially useful want combine Vue's transition system existing CSS animation library, Animate.css: template <!-- assuming Animate.css included page --> <Transition name=\"custom-classes\" enter-active-class=\"animate__animated animate__tada\" leave-active-class=\"animate__animated animate__bounceOutRight\" > <p v-if=\"show\">hello</p> </Transition> Using Transitions Animations Together Vue needs attach event listeners order know transition ended. either transitionend animationend , depending type CSS rules applied. using one other, Vue automatically detect correct type. However, cases may want element, example CSS animation triggered Vue, along CSS transition effect hover. cases, explicitly declare type want Vue care passing type prop, value either animation transition : template <Transition type=\"animation\">...</Transition> Nested Transitions Explicit Transition Durations Although transition classes applied direct child element <Transition> , transition nested elements using nested CSS selectors: template <Transition name=\"nested\"> <div v-if=\"show\" class=\"outer\"> <div class=\"inner\"> Hello </div> </div> </Transition> css /* rules target nested elements */ .nested-enter-active .inner, .nested-leave-active .inner { transition: 0.3s ease-in-out; } .nested-enter-from .inner, .nested-leave-to .inner { transform: translateX(30px); opacity: 0; } /* ... necessary CSS omitted */ even add transition delay nested element enter, creates staggered enter animation sequence: css /* delay enter nested element staggered effect */ .nested-enter-active .inner { transition-delay: 0.25s; } However, creates small issue. default, <Transition> component attempts automatically figure transition finished listening first transitionend animationend event root transition element. nested transition, desired behavior waiting transitions inner elements finished. cases specify explicit transition duration (in milliseconds) using duration prop <transition> component. total duration match delay plus transition duration inner element: template <Transition :duration=\"550\">...</Transition> Hello necessary, also specify separate values enter leave durations using object: template <Transition :duration=\"{ enter: 500, leave: 800 }\">...</Transition> Performance Considerations may notice animations shown mostly using properties like transform opacity . properties efficient animate because: affect document layout animation, trigger expensive CSS layout calculation every animation frame. modern browsers leverage GPU hardware acceleration animating transform . comparison, properties like height margin trigger CSS layout, much expensive animate, used caution. JavaScript Hooks hook transition process JavaScript listening events <Transition> component: html <Transition @before-enter=\"onBeforeEnter\" @enter=\"onEnter\" @after-enter=\"onAfterEnter\" @enter-cancelled=\"onEnterCancelled\" @before-leave=\"onBeforeLeave\" @leave=\"onLeave\" @after-leave=\"onAfterLeave\" @leave-cancelled=\"onLeaveCancelled\" > <!-- ... --> </Transition> js // called element inserted DOM. // use set \"enter-from\" state element function onBeforeEnter(el) {} // called one frame element inserted. // use start entering animation. function onEnter(el, done) { // call done callback indicate transition end // optional used combination CSS done() } // called enter transition finished. function onAfterEnter(el) {} // called enter transition cancelled completion. function onEnterCancelled(el) {} // called leave hook. // time, use leave hook function onBeforeLeave(el) {} // called leave transition starts. // use start leaving animation. function onLeave(el, done) { // call done callback indicate transition end // optional used combination CSS done() } // called leave transition finished // element removed DOM. function onAfterLeave(el) {} // available v-show transitions function onLeaveCancelled(el) {} hooks used combination CSS transitions / animations own. using JavaScript-only transitions, usually good idea add :css=\"false\" prop. explicitly tells Vue skip auto CSS transition detection. Aside slightly performant, also prevents CSS rules accidentally interfering transition: template <Transition ... :css=\"false\" > ... </Transition> :css=\"false\" , also fully responsible controlling transition ends. case, done callbacks required @enter @leave hooks. Otherwise, hooks called synchronously transition finish immediately. Here's demo using GSAP library perform animations. can, course, use animation library want, example Anime.js Motion One: Reusable Transitions Transitions reused Vue's component system. create reusable transition, create component wraps <Transition> component passes slot content: vue <!-- MyTransition.vue --> <script> // JavaScript hooks logic... </script> <template> <!-- wrap built-in Transition component --> <Transition name=\"my-transition\" @enter=\"onEnter\" @leave=\"onLeave\"> <slot></slot> <!-- pass slot content --> </Transition> </template> <style> /* Necessary CSS... Note: avoid using <style scoped> since apply slot content. */ </style> MyTransition imported used like built-in version: template <MyTransition> <div v-if=\"show\">Hello</div> </MyTransition> Transition Appear also want apply transition initial render node, add appear prop: template <Transition appear> ... </Transition> Transition Elements addition toggling element v-if / v-show , also transition two elements using v-if / v-else / v-else-if , long make sure one element shown given moment: template <Transition> <button v-if=\"docState === 'saved'\">Edit</button> <button v-else-if=\"docState === 'edited'\">Save</button> <button v-else-if=\"docState === 'editing'\">Cancel</button> </Transition> Click cycle states: Transition Modes previous example, entering leaving elements animated time, make position: absolute avoid layout issue elements present DOM. However, cases option, simply desired behavior. may want leaving element animated first, entering element inserted leaving animation finished. Orchestrating animations manually would complicated - luckily, enable behavior passing <Transition> mode prop: template <Transition mode=\"out-in\"> ... </Transition> Here's previous demo mode=\"out-in\" : Click cycle states: <Transition> also supports mode=\"in-out\" , although much less frequently used. Transition Components <Transition> also used around dynamic components: template <Transition name=\"fade\" mode=\"out-in\"> <component :is=\"activeComponent\"></component> </Transition> Component Dynamic Transitions <Transition> props like name also dynamic! allows us dynamically apply different transitions based state change: template <Transition :name=\"transitionName\"> <!-- ... --> </Transition> useful defined CSS transitions / animations using Vue's transition class conventions want switch them. also apply different behavior JavaScript transition hooks based current state component. Finally, ultimate way creating dynamic transitions reusable transition components accept props change nature transition(s) used. may sound cheesy, limit really imagination. Transitions Key Attribute Sometimes need force re-render DOM element order transition occur. Take counter component example: vue <script setup> import { ref } 'vue'; const count = ref(0); setInterval(() => count.value++, 1000); </script> <template> <Transition> <span :key=\"count\">{{ count }}</span> </Transition> </template> excluded key attribute, text node would updated thus transition would occur. However, key attribute place, Vue knows create new span element whenever count changes thus Transition component 2 different elements transition between. Related"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "TransitionGroup <TransitionGroup> built-in component designed animating insertion, removal, order change elements components rendered list. Differences <Transition> <TransitionGroup> supports props, CSS transition classes, JavaScript hook listeners <Transition> , following differences: default, render wrapper element. specify element rendered tag prop.Transition modes available, longer alternating mutually exclusive elements. Elements inside always required unique key attribute.CSS transition classes applied individual elements list, group / container itself. TIP used in-DOM templates, referenced <transition-group> . Enter / Leave Transitions example applying enter / leave transitions v-for list using <TransitionGroup> : template <TransitionGroup name=\"list\" tag=\"ul\"> <li v-for=\"item items\" :key=\"item\"> {{ item }} </li> </TransitionGroup> css .list-enter-active, .list-leave-active { transition: 0.5s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); } - 1 - 2 - 3 - 4 - 5 Move Transitions demo obvious flaws: item inserted removed, surrounding items instantly \"jump\" place instead moving smoothly. fix adding additional CSS rules: css .list-move, /* apply transition moving elements */ .list-enter-active, .list-leave-active { transition: 0.5s ease; } .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); } /* ensure leaving items taken layout flow moving animations calculated correctly. */ .list-leave-active { position: absolute; } looks much better - even animating smoothly whole list shuffled: - 1 - 2 - 3 - 4 - 5 Custom TransitionGroup classes also specify custom transition classes moving element passing moveClass prop <TransitionGroup> , like custom transition classes <Transition> . Staggering List Transitions communicating JavaScript transitions data attributes, also possible stagger transitions list. First, render index item data attribute DOM element: template <TransitionGroup tag=\"ul\" :css=\"false\" @before-enter=\"onBeforeEnter\" @enter=\"onEnter\" @leave=\"onLeave\" > <li v-for=\"(item, index) computedList\" :key=\"item.msg\" :data-index=\"index\" > {{ item.msg }} </li> </TransitionGroup> Then, JavaScript hooks, animate element delay based data attribute. example using GSAP library perform animation: js function onEnter(el, done) { gsap.to(el, { opacity: 1, height: '1.6em', delay: el.dataset.index * 0.15, onComplete: done }) } - Bruce Lee - Jackie Chan - Chuck Norris - Jet Li - Kung Fury Related"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Async Components Basic Usage large applications, may need divide app smaller chunks load component server needed. make possible, Vue defineAsyncComponent function: js import { defineAsyncComponent } 'vue' const AsyncComp = defineAsyncComponent(() => { return new Promise((resolve, reject) => { // ...load component server resolve(/* loaded component */) }) }) // ... use `AsyncComp` like normal component see, defineAsyncComponent accepts loader function returns Promise. Promise's resolve callback called retrieved component definition server. also call reject(reason) indicate load failed. ES module dynamic import also returns Promise, time use combination defineAsyncComponent . Bundlers like Vite webpack also support syntax (and use bundle split points), use import Vue SFCs: js import { defineAsyncComponent } 'vue' const AsyncComp = defineAsyncComponent(() => import('./components/MyComponent.vue') ) resulting AsyncComp wrapper component calls loader function actually rendered page. addition, pass along props slots inner component, use async wrapper seamlessly replace original component achieving lazy loading. normal components, async components registered globally using app.component() : js app.component('MyComponent', defineAsyncComponent(() => import('./components/MyComponent.vue') )) also defined directly inside parent component: vue <script setup> import { defineAsyncComponent } 'vue' const AdminPage = defineAsyncComponent(() => import('./components/AdminPageComponent.vue') ) </script> <template> <AdminPage /> </template> Loading Error States Asynchronous operations inevitably involve loading error states - defineAsyncComponent() supports handling states via advanced options: js const AsyncComp = defineAsyncComponent({ // loader function loader: () => import('./Foo.vue'), // component use async component loading loadingComponent: LoadingComponent, // Delay showing loading component. Default: 200ms. delay: 200, // component use load fails errorComponent: ErrorComponent, // error component displayed timeout // provided exceeded. Default: Infinity. timeout: 3000 }) loading component provided, displayed first inner component loaded. default 200ms delay loading component shown - fast networks, instant loading state may get replaced fast end looking like flicker. error component provided, displayed Promise returned loader function rejected. also specify timeout show error component request taking long. Lazy Hydration section applies using Server-Side Rendering. Vue 3.5+, async components control hydrated providing hydration strategy. Vue provides number built-in hydration strategies. built-in strategies need individually imported tree-shaken used. design intentionally low-level flexibility. Compiler syntax sugar potentially built top future either core higher level solutions (e.g. Nuxt). Hydrate Idle Hydrates via requestIdleCallback : js import { defineAsyncComponent, hydrateOnIdle } 'vue' const AsyncComp = defineAsyncComponent({ loader: () => import('./Comp.vue'), hydrate: hydrateOnIdle(/* optionally pass max timeout */) }) Hydrate Visible Hydrate element(s) become visible via IntersectionObserver . js import { defineAsyncComponent, hydrateOnVisible } 'vue' const AsyncComp = defineAsyncComponent({ loader: () => import('./Comp.vue'), hydrate: hydrateOnVisible() }) optionally pass options object value observer: js hydrateOnVisible({ rootMargin: '100px' }) Hydrate Media Query Hydrates specified media query matches. js import { defineAsyncComponent, hydrateOnMediaQuery } 'vue' const AsyncComp = defineAsyncComponent({ loader: () => import('./Comp.vue'), hydrate: hydrateOnMediaQuery('(max-width:500px)') }) Hydrate Interaction Hydrates specified event(s) triggered component element(s). event triggered hydration also replayed hydration complete. js import { defineAsyncComponent, hydrateOnInteraction } 'vue' const AsyncComp = defineAsyncComponent({ loader: () => import('./Comp.vue'), hydrate: hydrateOnInteraction('click') }) also list multiple event types: js hydrateOnInteraction(['wheel', 'mouseover']) Custom Strategy ts import { defineAsyncComponent, type HydrationStrategy } 'vue' const myStrategy: HydrationStrategy = (hydrate, forEachElement) => { // forEachElement helper iterate root elements // component's non-hydrated DOM, since root fragment // instead single element forEachElement(el => { // ... }) // call `hydrate` ready hydrate() return () => { // return teardown function needed } } const AsyncComp = defineAsyncComponent({ loader: () => import('./Comp.vue'), hydrate: myStrategy }) Using Suspense Async components used <Suspense> built-in component. interaction <Suspense> async components documented dedicated chapter <Suspense> ."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Fallthrough Attributes page assumes already read Components Basics. Read first new components. Attribute Inheritance \"fallthrough attribute\" attribute v-on event listener passed component, explicitly declared receiving component's props emits. Common examples include class , style , id attributes. component renders single root element, fallthrough attributes automatically added root element's attributes. example, given <MyButton> component following template: template <!-- template <MyButton> --> <button>Click Me</button> parent using component with: template <MyButton class=\"large\" /> final rendered DOM would be: html <button class=\"large\">Click Me</button> Here, <MyButton> declare class accepted prop. Therefore, class treated fallthrough attribute automatically added <MyButton> 's root element. class style Merging child component's root element already existing class style attributes, merged class style values inherited parent. Suppose change template <MyButton> previous example to: template <!-- template <MyButton> --> <button class=\"btn\">Click Me</button> final rendered DOM would become: html <button class=\"btn large\">Click Me</button> v-on Listener Inheritance rule applies v-on event listeners: template <MyButton @click=\"onClick\" /> click listener added root element <MyButton> , i.e. native <button> element. native <button> clicked, trigger onClick method parent component. native <button> already click listener bound v-on , listeners trigger. Nested Component Inheritance component renders another component root node, example, refactored <MyButton> render <BaseButton> root: template <!-- template <MyButton/> simply renders another component --> <BaseButton /> fallthrough attributes received <MyButton> automatically forwarded <BaseButton> . Note that: Forwarded attributes include attributes declared props, v-on listeners declared events by<MyButton> - words, declared props listeners \"consumed\" by<MyButton> .Forwarded attributes may accepted props <BaseButton> , declared it. Disabling Attribute Inheritance want component automatically inherit attributes, set inheritAttrs: false component's options. Since 3.3 also use defineOptions directly <script setup> : vue <script setup> defineOptions({ inheritAttrs: false }) // ...setup logic </script> common scenario disabling attribute inheritance attributes need applied elements besides root node. setting inheritAttrs option false , take full control fallthrough attributes applied. fallthrough attributes accessed directly template expressions $attrs : template <span>Fallthrough attributes: {{ $attrs }}</span> $attrs object includes attributes declared component's props emits options (e.g., class , style , v-on listeners, etc.). notes: Unlike props, fallthrough attributes preserve original casing JavaScript, attribute like foo-bar needs accessed as$attrs['foo-bar'] .A v-on event listener like@click exposed object function under$attrs.onClick . Using <MyButton> component example previous section - sometimes may need wrap actual <button> element extra <div> styling purposes: template <div class=\"btn-wrapper\"> <button class=\"btn\">Click Me</button> </div> want fallthrough attributes like class v-on listeners applied inner <button> , outer <div> . achieve inheritAttrs: false v-bind=\"$attrs\" : template <div class=\"btn-wrapper\"> <button class=\"btn\" v-bind=\"$attrs\">Click Me</button> </div> Remember v-bind without argument binds properties object attributes target element. Attribute Inheritance Multiple Root Nodes Unlike components single root node, components multiple root nodes automatic attribute fallthrough behavior. $attrs bound explicitly, runtime warning issued. template <CustomLayout id=\"custom-layout\" @click=\"changeValue\" /> <CustomLayout> following multi-root template, warning Vue cannot sure apply fallthrough attributes: template <header>...</header> <main>...</main> <footer>...</footer> warning suppressed $attrs explicitly bound: template <header>...</header> <main v-bind=\"$attrs\">...</main> <footer>...</footer> Accessing Fallthrough Attributes JavaScript needed, access component's fallthrough attributes <script setup> using useAttrs() API: vue <script setup> import { useAttrs } 'vue' const attrs = useAttrs() </script> using <script setup> , attrs exposed property setup() context: js export default { setup(props, ctx) { // fallthrough attributes exposed ctx.attrs console.log(ctx.attrs) } } Note although attrs object always reflects latest fallthrough attributes, reactive (for performance reasons). cannot use watchers observe changes. need reactivity, use prop. Alternatively, use onUpdated() perform side effects latest attrs update."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Component Events page assumes already read Components Basics. Read first new components. Emitting Listening Events component emit custom events directly template expressions (e.g. v-on handler) using built-in $emit method: template <!-- MyComponent --> <button @click=\"$emit('someEvent')\">Click Me</button> parent listen using v-on : template <MyComponent @some-event=\"callback\" /> .once modifier also supported component event listeners: template <MyComponent @some-event.once=\"callback\" /> Like components props, event names provide automatic case transformation. Notice emitted camelCase event, listen using kebab-cased listener parent. props casing, recommend using kebab-cased event listeners templates. TIP Unlike native DOM events, component emitted events bubble. listen events emitted direct child component. need communicate sibling deeply nested components, use external event bus global state management solution. Event Arguments sometimes useful emit specific value event. example, may want <BlogPost> component charge much enlarge text by. cases, pass extra arguments $emit provide value: template <button @click=\"$emit('increaseBy', 1)\"> Increase 1 </button> Then, listen event parent, use inline arrow function listener, allows us access event argument: template <MyButton @increase-by=\"(n) => count += n\" /> Or, event handler method: template <MyButton @increase-by=\"increaseCount\" /> value passed first parameter method: js function increaseCount(n) { count.value += n } TIP extra arguments passed $emit() event name forwarded listener. example, $emit('foo', 1, 2, 3) listener function receive three arguments. Declaring Emitted Events component explicitly declare events emit using defineEmits() macro : vue <script setup> defineEmits(['inFocus', 'submit']) </script> $emit method used <template> accessible within <script setup> section component, defineEmits() returns equivalent function use instead: vue <script setup> const emit = defineEmits(['inFocus', 'submit']) function buttonClick() { emit('submit') } </script> defineEmits() macro cannot used inside function, must placed directly within <script setup> , example above. using explicit setup function instead <script setup> , events declared using emits option, emit function exposed setup() context: js export default { emits: ['inFocus', 'submit'], setup(props, ctx) { ctx.emit('submit') } } properties setup() context, emit safely destructured: js export default { emits: ['inFocus', 'submit'], setup(props, { emit }) { emit('submit') } } emits option defineEmits() macro also support object syntax. using TypeScript type arguments, allows us perform runtime validation payload emitted events: vue <script setup lang=\"ts\"> const emit = defineEmits({ submit(payload: { email: string, password: string }) { // return `true` `false` indicate // validation pass / fail } }) </script> using TypeScript <script setup> , also possible declare emitted events using pure type annotations: vue <script setup lang=\"ts\"> const emit = defineEmits<{ (e: 'change', id: number): void (e: 'update', value: string): void }>() </script> details: Typing Component Emits Although optional, recommended define emitted events order better document component work. also allows Vue exclude known listeners fallthrough attributes, avoiding edge cases caused DOM events manually dispatched 3rd party code. TIP native event (e.g., click ) defined emits option, listener listen component-emitted click events longer respond native click events. Events Validation Similar prop type validation, emitted event validated defined object syntax instead array syntax. add validation, event assigned function receives arguments passed emit call returns boolean indicate whether event valid not. vue <script setup> const emit = defineEmits({ // validation click: null, // Validate submit event submit: ({ email, password }) => { (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }) function submitForm(email, password) { emit('submit', { email, password }) } </script>"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Props page assumes already read Components Basics. Read first new components. Props Declaration Vue components require explicit props declaration Vue knows external props passed component treated fallthrough attributes (which discussed dedicated section). SFCs using <script setup> , props declared using defineProps() macro: vue <script setup> const props = defineProps(['foo']) console.log(props.foo) </script> non-<script setup> components, props declared using props option: js export default { props: ['foo'], setup(props) { // setup() receives props first argument. console.log(props.foo) } } Notice argument passed defineProps() value provided props options: props options API shared two declaration styles. addition declaring props using array strings, also use object syntax: js // <script setup> defineProps({ title: String, likes: Number }) js // non-<script setup> export default { props: { title: String, likes: Number } } property object declaration syntax, key name prop, value constructor function expected type. documents component, also warn developers using component browser console pass wrong type. discuss details prop validation page. using TypeScript <script setup> , also possible declare props using pure type annotations: vue <script setup lang=\"ts\"> defineProps<{ title?: string likes?: number }>() </script> details: Typing Component Props Reactive Props Destructure Vue's reactivity system tracks state usage based property access. E.g. access props.foo computed getter watcher, foo prop gets tracked dependency. So, given following code: js const { foo } = defineProps(['foo']) watchEffect(() => { // runs 3.5 // re-runs \"foo\" prop changes 3.5+ console.log(foo) }) version 3.4 below, foo actual constant never change. version 3.5 above, Vue's compiler automatically prepends props. code <script setup> block accesses variables destructured defineProps . Therefore code becomes equivalent following: js const props = defineProps(['foo']) watchEffect(() => { // `foo` transformed `props.foo` compiler console.log(props.foo) }) addition, use JavaScript's native default value syntax declare default values props. particularly useful using type-based props declaration: ts const { foo = 'hello' } = defineProps<{ foo?: string }>() prefer visual distinction destructured props normal variables IDE, Vue's VSCode extension provides setting enable inlay-hints destructured props. Passing Destructured Props Functions pass destructured prop function, e.g.: js const { foo } = defineProps(['foo']) watch(foo, /* ... */) work expected equivalent watch(props.foo, ...) - passing value instead reactive data source watch . fact, Vue's compiler catch cases throw warning. Similar watch normal prop watch(() => props.foo, ...) , watch destructured prop also wrapping getter: js watch(() => foo, /* ... */) addition, recommended approach need pass destructured prop external function retaining reactivity: js useComposable(() => foo) external function call getter (or normalize toValue) needs track changes provided prop, e.g. computed watcher getter. Prop Passing Details Prop Name Casing declare long prop names using camelCase avoids use quotes using property keys, allows us reference directly template expressions valid JavaScript identifiers: js defineProps({ greetingMessage: String }) template <span>{{ greetingMessage }}</span> Technically, also use camelCase passing props child component (except in-DOM templates). However, convention using kebab-case cases align HTML attributes: template <MyComponent greeting-message=\"hello\" /> use PascalCase component tags possible improves template readability differentiating Vue components native elements. However, much practical benefit using camelCase passing props, choose follow language's conventions. Static vs. Dynamic Props far, seen props passed static values, like in: template <BlogPost title=\"My journey Vue\" /> also seen props assigned dynamically v-bind : shortcut, in: template <!-- Dynamically assign value variable --> <BlogPost :title=\"post.title\" /> <!-- Dynamically assign value complex expression --> <BlogPost :title=\"post.title + ' ' + post.author.name\" /> Passing Different Value Types two examples above, happen pass string values, type value passed prop. Number template <!-- Even though `42` static, need v-bind tell Vue --> <!-- JavaScript expression rather string. --> <BlogPost :likes=\"42\" /> <!-- Dynamically assign value variable. --> <BlogPost :likes=\"post.likes\" /> Boolean template <!-- Including prop value imply `true`. --> <BlogPost is-published /> <!-- Even though `false` static, need v-bind tell Vue --> <!-- JavaScript expression rather string. --> <BlogPost :is-published=\"false\" /> <!-- Dynamically assign value variable. --> <BlogPost :is-published=\"post.isPublished\" /> Array template <!-- Even though array static, need v-bind tell Vue --> <!-- JavaScript expression rather string. --> <BlogPost :comment-ids=\"[234, 266, 273]\" /> <!-- Dynamically assign value variable. --> <BlogPost :comment-ids=\"post.commentIds\" /> Object template <!-- Even though object static, need v-bind tell Vue --> <!-- JavaScript expression rather string. --> <BlogPost :author=\"{ name: 'Veronica', company: 'Veridian Dynamics' }\" /> <!-- Dynamically assign value variable. --> <BlogPost :author=\"post.author\" /> Binding Multiple Properties Using Object want pass properties object props, use v-bind without argument (v-bind instead :prop-name ). example, given post object: js const post = { id: 1, title: 'My Journey Vue' } following template: template <BlogPost v-bind=\"post\" /> equivalent to: template <BlogPost :id=\"post.id\" :title=\"post.title\" /> One-Way Data Flow props form one-way-down binding child property parent one: parent property updates, flow child, way around. prevents child components accidentally mutating parent's state, make app's data flow harder understand. addition, every time parent component updated, props child component refreshed latest value. means attempt mutate prop inside child component. do, Vue warn console: js const props = defineProps(['foo']) // \u274c warning, props readonly! props.foo = 'bar' usually two cases tempting mutate prop: prop used pass initial value; child component wants use local data property afterwards. case, best define local data property uses prop initial value: jsconst props = defineProps(['initialCounter']) // counter uses props.initialCounter initial value; // disconnected future prop updates. const counter = ref(props.initialCounter) prop passed raw value needs transformed. case, best define computed property using prop's value: jsconst props = defineProps(['size']) // computed property auto-updates prop changes const normalizedSize = computed(() => props.size.trim().toLowerCase()) Mutating Object / Array Props objects arrays passed props, child component cannot mutate prop binding, able mutate object array's nested properties. JavaScript objects arrays passed reference, unreasonably expensive Vue prevent mutations. main drawback mutations allows child component affect parent state way obvious parent component, potentially making difficult reason data flow future. best practice, avoid mutations unless parent child tightly coupled design. cases, child emit event let parent perform mutation. Prop Validation Components specify requirements props, types already seen. requirement met, Vue warn browser's JavaScript console. especially useful developing component intended used others. specify prop validations, provide object validation requirements defineProps() macro , instead array strings. example: js defineProps({ // Basic type check // (`null` `undefined` values allow type) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: { type: String, required: true }, // Required nullable string propD: { type: [String, null], required: true }, // Number default value propE: { type: Number, default: 100 }, // Object default value propF: { type: Object, // Object array defaults must returned // factory function. function receives raw // props received component argument. default(rawProps) { return { message: 'hello' } } }, // Custom validator function // full props passed 2nd argument 3.4+ propG: { validator(value, props) { // value must match one strings return ['success', 'warning', 'danger'].includes(value) } }, // Function default value propH: { type: Function, // Unlike object array default, factory // function - function serve default value default() { return 'Default function' } } }) TIP Code inside defineProps() argument cannot access variables declared <script setup> , entire expression moved outer function scope compiled. Additional details: props optional default, unless required: true specified.An absent optional prop Boolean haveundefined value.The Boolean absent props cast tofalse . change setting adefault \u2014 i.e.:default: undefined behave non-Boolean prop.If default value specified, used resolved prop value isundefined - includes prop absent, explicitundefined value passed. prop validation fails, Vue produce console warning (if using development build). using Type-based props declarations , Vue try best compile type annotations equivalent runtime prop declarations. example, defineProps<{ msg: string }> compiled { msg: { type: String, required: true }} . Runtime Type Checks type one following native constructors: String Number Boolean Array Object Date Function Symbol Error addition, type also custom class constructor function assertion made instanceof check. example, given following class: js class Person { constructor(firstName, lastName) { this.firstName = firstName this.lastName = lastName } } could use prop's type: js defineProps({ author: Person }) Vue use instanceof Person validate whether value author prop indeed instance Person class. Nullable Type type required nullable, use array syntax includes null : js defineProps({ id: { type: [String, null], required: true } }) Note type null without using array syntax, allow type. Boolean Casting Props Boolean type special casting rules mimic behavior native boolean attributes. Given <MyComponent> following declaration: js defineProps({ disabled: Boolean }) component used like this: template <!-- equivalent passing :disabled=\"true\" --> <MyComponent disabled /> <!-- equivalent passing :disabled=\"false\" --> <MyComponent /> prop declared allow multiple types, casting rules Boolean also applied. However, edge String Boolean allowed - Boolean casting rule applies Boolean appears String: js // disabled casted true defineProps({ disabled: [Boolean, Number] }) // disabled casted true defineProps({ disabled: [Boolean, String] }) // disabled casted true defineProps({ disabled: [Number, Boolean] }) // disabled parsed empty string (disabled=\"\") defineProps({ disabled: [String, Boolean] })"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Provide / Inject page assumes already read Components Basics. Read first new components. Prop Drilling Usually, need pass data parent child component, use props. However, imagine case large component tree, deeply nested component needs something distant ancestor component. props, would pass prop across entire parent chain: Notice although <Footer> component may care props all, still needs declare pass along <DeepChild> access them. longer parent chain, components would affected along way. called \"props drilling\" definitely fun deal with. solve props drilling provide inject . parent component serve dependency provider descendants. component descendant tree, regardless deep is, inject dependencies provided components parent chain. Provide provide data component's descendants, use provide() function: vue <script setup> import { provide } 'vue' provide(/* key */ 'message', /* value */ 'hello!') </script> using <script setup> , make sure provide() called synchronously inside setup() : js import { provide } 'vue' export default { setup() { provide(/* key */ 'message', /* value */ 'hello!') } } provide() function accepts two arguments. first argument called injection key, string Symbol . injection key used descendant components lookup desired value inject. single component call provide() multiple times different injection keys provide different values. second argument provided value. value type, including reactive state refs: js import { ref, provide } 'vue' const count = ref(0) provide('key', count) Providing reactive values allows descendant components using provided value establish reactive connection provider component. App-level Provide addition providing data component, also provide app level: js import { createApp } 'vue' const app = createApp({}) app.provide(/* key */ 'message', /* value */ 'hello!') App-level provides available components rendered app. especially useful writing plugins, plugins typically able provide values using components. Inject inject data provided ancestor component, use inject() function: vue <script setup> import { inject } 'vue' const message = inject('message') </script> provided value ref, injected as-is automatically unwrapped. allows injector component retain reactivity connection provider component. Full provide + inject Example Reactivity Again, using <script setup> , inject() called synchronously inside setup() : js import { inject } 'vue' export default { setup() { const message = inject('message') return { message } } } Injection Default Values default, inject assumes injected key provided somewhere parent chain. case key provided, runtime warning. want make injected property work optional providers, need declare default value, similar props: js // `value` \"default value\" // data matching \"message\" provided const value = inject('message', 'default value') cases, default value may need created calling function instantiating new class. avoid unnecessary computation side effects case optional value used, use factory function creating default value: js const value = inject('key', () => new ExpensiveClass(), true) third parameter indicates default value treated factory function. Working Reactivity using reactive provide / inject values, recommended keep mutations reactive state inside provider whenever possible. ensures provided state possible mutations co-located component, making easier maintain future. may times need update data injector component. cases, recommend providing function responsible mutating state: vue <!-- inside provider component --> <script setup> import { provide, ref } 'vue' const location = ref('North Pole') function updateLocation() { location.value = 'South Pole' } provide('location', { location, updateLocation }) </script> vue <!-- injector component --> <script setup> import { inject } 'vue' const { location, updateLocation } = inject('location') </script> <template> <button @click=\"updateLocation\">{{ location }}</button> </template> Finally, wrap provided value readonly() want ensure data passed provide cannot mutated injector component. vue <script setup> import { ref, provide, readonly } 'vue' const count = ref(0) provide('read-only-count', readonly(count)) </script> Working Symbol Keys far, using string injection keys examples. working large application many dependency providers, authoring components going used developers, best use Symbol injection keys avoid potential collisions. recommended export Symbols dedicated file: js // keys.js export const myInjectionKey = Symbol() js // provider component import { provide } 'vue' import { myInjectionKey } './keys.js' provide(myInjectionKey, { /* data provide */ }) js // injector component import { inject } 'vue' import { myInjectionKey } './keys.js' const injected = inject(myInjectionKey) See also: Typing Provide / Inject"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Component Registration page assumes already read Components Basics. Read first new components. Vue component needs \"registered\" Vue knows locate implementation encountered template. two ways register components: global local. Global Registration make components available globally current Vue application using .component() method: js import { createApp } 'vue' const app = createApp({}) app.component( // registered name 'MyComponent', // implementation { /* ... */ } ) using SFCs, registering imported .vue files: js import MyComponent './App.vue' app.component('MyComponent', MyComponent) .component() method chained: js app .component('ComponentA', ComponentA) .component('ComponentB', ComponentB) .component('ComponentC', ComponentC) Globally registered components used template component within application: template <!-- work component inside app --> <ComponentA/> <ComponentB/> <ComponentC/> even applies subcomponents, meaning three components also available inside other. Local Registration convenient, global registration drawbacks: Global registration prevents build systems removing unused components (a.k.a \"tree-shaking\"). globally register component end using anywhere app, still included final bundle. Global registration makes dependency relationships less explicit large applications. makes difficult locate child component's implementation parent component using it. affect long-term maintainability similar using many global variables. Local registration scopes availability registered components current component only. makes dependency relationship explicit, tree-shaking friendly. using SFC <script setup> , imported components locally used without registration: vue <script setup> import ComponentA './ComponentA.vue' </script> <template> <ComponentA /> </template> non-<script setup> , need use components option: js import ComponentA './ComponentA.js' export default { components: { ComponentA }, setup() { // ... } } property components object, key registered name component, value contain implementation component. example using ES2015 property shorthand equivalent to: js export default { components: { ComponentA: ComponentA } // ... } Note locally registered components also available descendant components. case, ComponentA made available current component only, child descendant components. Component Name Casing Throughout guide, using PascalCase names registering components. because: PascalCase names valid JavaScript identifiers. makes easier import register components JavaScript. also helps IDEs auto-completion. <PascalCase /> makes obvious Vue component instead native HTML element templates. also differentiates Vue components custom elements (web components). recommended style working SFC string templates. However, discussed in-DOM Template Parsing Caveats, PascalCase tags usable in-DOM templates. Luckily, Vue supports resolving kebab-case tags components registered using PascalCase. means component registered MyComponent referenced inside Vue template (or inside HTML element rendered Vue) via <MyComponent> <my-component> . allows us use JavaScript component registration code regardless template source."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Slots page assumes already read Components Basics. Read first new components. Slot Content Outlet learned components accept props, JavaScript values type. template content? cases, may want pass template fragment child component, let child component render fragment within template. example, may <FancyButton> component supports usage like this: template <FancyButton> Click me! <!-- slot content --> </FancyButton> template <FancyButton> looks like this: template <button class=\"fancy-btn\"> <slot></slot> <!-- slot outlet --> </button> <slot> element slot outlet indicates parent-provided slot content rendered. final rendered DOM: html <button class=\"fancy-btn\">Click me!</button> slots, <FancyButton> responsible rendering outer <button> (and fancy styling), inner content provided parent component. Another way understand slots comparing JavaScript functions: js // parent component passing slot content FancyButton('Click me!') // FancyButton renders slot content template function FancyButton(slotContent) { return `<button class=\"fancy-btn\"> ${slotContent} </button>` } Slot content limited text. valid template content. example, pass multiple elements, even components: template <FancyButton> <span style=\"color:red\">Click me!</span> <AwesomeIcon name=\"plus\" /> </FancyButton> using slots, <FancyButton> flexible reusable. use different places different inner content, fancy styling. Vue components' slot mechanism inspired native Web Component <slot> element, additional capabilities see later. Render Scope Slot content access data scope parent component, defined parent. example: template <span>{{ message }}</span> <FancyButton>{{ message }}</FancyButton> {{ message }} interpolations render content. Slot content access child component's data. Expressions Vue templates access scope defined in, consistent JavaScript's lexical scoping. words: Expressions parent template access parent scope; expressions child template access child scope. Fallback Content cases useful specify fallback (i.e. default) content slot, rendered content provided. example, <SubmitButton> component: template <button type=\"submit\"> <slot></slot> </button> might want text \"Submit\" rendered inside <button> parent provide slot content. make \"Submit\" fallback content, place <slot> tags: template <button type=\"submit\"> <slot> Submit <!-- fallback content --> </slot> </button> use <SubmitButton> parent component, providing content slot: template <SubmitButton /> render fallback content, \"Submit\": html <button type=\"submit\">Submit</button> provide content: template <SubmitButton>Save</SubmitButton> provided content rendered instead: html <button type=\"submit\">Save</button> Named Slots times useful multiple slot outlets single component. example, <BaseLayout> component following template: template <div class=\"container\"> <header> <!-- want header content --> </header> <main> <!-- want main content --> </main> <footer> <!-- want footer content --> </footer> </div> cases, <slot> element special attribute, name , used assign unique ID different slots determine content rendered: template <div class=\"container\"> <header> <slot name=\"header\"></slot> </header> <main> <slot></slot> </main> <footer> <slot name=\"footer\"></slot> </footer> </div> <slot> outlet without name implicitly name \"default\". parent component using <BaseLayout> , need way pass multiple slot content fragments, targeting different slot outlet. named slots come in. pass named slot, need use <template> element v-slot directive, pass name slot argument v-slot : template <BaseLayout> <template v-slot:header> <!-- content header slot --> </template> </BaseLayout> v-slot dedicated shorthand # , <template v-slot:header> shortened <template #header> . Think \"render template fragment child component's 'header' slot\". Here's code passing content three slots <BaseLayout> using shorthand syntax: template <BaseLayout> <template #header> <h1>Here might page title</h1> </template> <template #default> <p>A paragraph main content.</p> <p>And another one.</p> </template> <template #footer> <p>Here's contact info</p> </template> </BaseLayout> component accepts default slot named slots, top-level non-<template> nodes implicitly treated content default slot. also written as: template <BaseLayout> <template #header> <h1>Here might page title</h1> </template> <!-- implicit default slot --> <p>A paragraph main content.</p> <p>And another one.</p> <template #footer> <p>Here's contact info</p> </template> </BaseLayout> everything inside <template> elements passed corresponding slots. final rendered HTML be: html <div class=\"container\"> <header> <h1>Here might page title</h1> </header> <main> <p>A paragraph main content.</p> <p>And another one.</p> </main> <footer> <p>Here's contact info</p> </footer> </div> Again, may help understand named slots better using JavaScript function analogy: js // passing multiple slot fragments different names BaseLayout({ header: `...`, default: `...`, footer: `...` }) // <BaseLayout> renders different places function BaseLayout(slots) { return `<div class=\"container\"> <header>${slots.header}</header> <main>${slots.default}</main> <footer>${slots.footer}</footer> </div>` } Conditional Slots Sometimes want render something based whether content passed slot. use $slots property combination v-if achieve this. example define Card component three conditional slots: header , footer default one. content header / footer / default present, want wrap provide additional styling: template <template> <div class=\"card\"> <div v-if=\"$slots.header\" class=\"card-header\"> <slot name=\"header\" /> </div> <div v-if=\"$slots.default\" class=\"card-content\"> <slot /> </div> <div v-if=\"$slots.footer\" class=\"card-footer\"> <slot name=\"footer\" /> </div> </div> </template> Dynamic Slot Names Dynamic directive arguments also work v-slot , allowing definition dynamic slot names: template <base-layout> <template v-slot:[dynamicSlotName]> ... </template> <!-- shorthand --> <template #[dynamicSlotName]> ... </template> </base-layout> note expression subject syntax constraints dynamic directive arguments. Scoped Slots discussed Render Scope, slot content access state child component. However, cases could useful slot's content make use data parent scope child scope. achieve that, need way child pass data slot rendering it. fact, exactly - pass attributes slot outlet like passing props component: template <!-- <MyComponent> template --> <div> <slot :text=\"greetingMessage\" :count=\"1\"></slot> </div> Receiving slot props bit different using single default slot vs. using named slots. going show receive props using single default slot first, using v-slot directly child component tag: template <MyComponent v-slot=\"slotProps\"> {{ slotProps.text }} {{ slotProps.count }} </MyComponent> props passed slot child available value corresponding v-slot directive, accessed expressions inside slot. think scoped slot function passed child component. child component calls it, passing props arguments: js MyComponent({ // passing default slot, function default: (slotProps) => { return `${slotProps.text} ${slotProps.count}` } }) function MyComponent(slots) { const greetingMessage = 'hello' return `<div>${ // call slot function props! slots.default({ text: greetingMessage, count: 1 }) }</div>` } fact, close scoped slots compiled, would use scoped slots manual render functions. Notice v-slot=\"slotProps\" matches slot function signature. like function arguments, use destructuring v-slot : template <MyComponent v-slot=\"{ text, count }\"> {{ text }} {{ count }} </MyComponent> Named Scoped Slots Named scoped slots work similarly - slot props accessible value v-slot directive: v-slot:name=\"slotProps\" . using shorthand, looks like this: template <MyComponent> <template #header=\"headerProps\"> {{ headerProps }} </template> <template #default=\"defaultProps\"> {{ defaultProps }} </template> <template #footer=\"footerProps\"> {{ footerProps }} </template> </MyComponent> Passing props named slot: template <slot name=\"header\" message=\"hello\"></slot> Note name slot included props reserved - resulting headerProps would { message: 'hello' } . mixing named slots default scoped slot, need use explicit <template> tag default slot. Attempting place v-slot directive directly component result compilation error. avoid ambiguity scope props default slot. example: template <!-- <MyComponent> template --> <div> <slot :message=\"hello\"></slot> <slot name=\"footer\" /> </div> template <!-- template compile --> <MyComponent v-slot=\"{ message }\"> <p>{{ message }}</p> <template #footer> <!-- message belongs default slot, available --> <p>{{ message }}</p> </template> </MyComponent> Using explicit <template> tag default slot helps make clear message prop available inside slot: template <MyComponent> <!-- Use explicit default slot --> <template #default=\"{ message }\"> <p>{{ message }}</p> </template> <template #footer> <p>Here's contact info</p> </template> </MyComponent> Fancy List Example may wondering would good use case scoped slots. Here's example: imagine <FancyList> component renders list items - may encapsulate logic loading remote data, using data display list, even advanced features like pagination infinite scrolling. However, want flexible item looks leave styling item parent component consuming it. desired usage may look like this: template <FancyList :api-url=\"url\" :per-page=\"10\"> <template #item=\"{ body, username, likes }\"> <div class=\"item\"> <p>{{ body }}</p> <p>by {{ username }} | {{ likes }} likes</p> </div> </template> </FancyList> Inside <FancyList> , render <slot> multiple times different item data (notice using v-bind pass object slot props): template <ul> <li v-for=\"item items\"> <slot name=\"item\" v-bind=\"item\"></slot> </li> </ul> Renderless Components <FancyList> use case discussed encapsulates reusable logic (data fetching, pagination etc.) visual output, delegating part visual output consumer component via scoped slots. push concept bit further, come components encapsulate logic render anything - visual output fully delegated consumer component scoped slots. call type component Renderless Component. example renderless component could one encapsulates logic tracking current mouse position: template <MouseTracker v-slot=\"{ x, }\"> Mouse at: {{ x }}, {{ }} </MouseTracker> interesting pattern, achieved Renderless Components achieved efficient fashion Composition API, without incurring overhead extra component nesting. Later, see implement mouse tracking functionality Composable. said, scoped slots still useful cases need encapsulate logic compose visual output, like <FancyList> example."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Component v-model Basic Usage v-model used component implement two-way binding. Starting Vue 3.4, recommended approach achieve using defineModel() macro: vue <!-- Child.vue --> <script setup> const model = defineModel() function update() { model.value++ } </script> <template> <div>Parent bound v-model is: {{ model }}</div> <button @click=\"update\">Increment</button> </template> parent bind value v-model : template <!-- Parent.vue --> <Child v-model=\"countModel\" /> value returned defineModel() ref. accessed mutated like ref, except acts two-way binding parent value local one: - .value synced value bound parentv-model ; - mutated child, causes parent bound value updated well. means also bind ref native input element v-model , making straightforward wrap native input elements providing v-model usage: vue <script setup> const model = defineModel() </script> <template> <input v-model=\"model\" /> </template> Hood defineModel convenience macro. compiler expands following: - prop named modelValue , local ref's value synced with; - event named update:modelValue , emitted local ref's value mutated. would implement child component shown prior 3.4: vue <!-- Child.vue --> <script setup> const props = defineProps(['modelValue']) const emit = defineEmits(['update:modelValue']) </script> <template> <input :value=\"props.modelValue\" @input=\"emit('update:modelValue', $event.target.value)\" /> </template> Then, v-model=\"foo\" parent component compiled to: template <!-- Parent.vue --> <Child :modelValue=\"foo\" @update:modelValue=\"$event => (foo = $event)\" /> see, quite bit verbose. However, helpful understand happening hood. defineModel declares prop, therefore declare underlying prop's options passing defineModel : js // making v-model required const model = defineModel({ required: true }) // providing default value const model = defineModel({ default: 0 }) WARNING default value defineModel prop provide value prop parent component, cause de-synchronization parent child components. example below, parent's myRef undefined, child's model 1: Child component: js const model = defineModel({ default: 1 }) Parent component: js const myRef = ref() html <Child v-model=\"myRef\"></Child> v-model arguments v-model component also accept argument: template <MyComponent v-model:title=\"bookTitle\" /> child component, support corresponding argument passing string defineModel() first argument: vue <!-- MyComponent.vue --> <script setup> const title = defineModel('title') </script> <template> <input type=\"text\" v-model=\"title\" /> </template> prop options also needed, passed model name: js const title = defineModel('title', { required: true }) Pre 3.4 Usage vue <!-- MyComponent.vue --> <script setup> defineProps({ title: { required: true } }) defineEmits(['update:title']) </script> <template> <input type=\"text\" :value=\"title\" @input=\"$emit('update:title', $event.target.value)\" /> </template> Multiple v-model bindings leveraging ability target particular prop event learned v-model arguments, create multiple v-model bindings single component instance. v-model sync different prop, without need extra options component: template <UserName v-model:first-name=\"first\" v-model:last-name=\"last\" /> vue <script setup> const firstName = defineModel('firstName') const lastName = defineModel('lastName') </script> <template> <input type=\"text\" v-model=\"firstName\" /> <input type=\"text\" v-model=\"lastName\" /> </template> Pre 3.4 Usage vue <script setup> defineProps({ firstName: String, lastName: String }) defineEmits(['update:firstName', 'update:lastName']) </script> <template> <input type=\"text\" :value=\"firstName\" @input=\"$emit('update:firstName', $event.target.value)\" /> <input type=\"text\" :value=\"lastName\" @input=\"$emit('update:lastName', $event.target.value)\" /> </template> Handling v-model modifiers learning form input bindings, saw v-model built-in modifiers - .trim , .number .lazy . cases, might also want v-model custom input component support custom modifiers. Let's create example custom modifier, capitalize , capitalizes first letter string provided v-model binding: template <MyComponent v-model.capitalize=\"myText\" /> Modifiers added component v-model accessed child component destructuring defineModel() return value like this: vue <script setup> const [model, modifiers] = defineModel() console.log(modifiers) // { capitalize: true } </script> <template> <input type=\"text\" v-model=\"model\" /> </template> conditionally adjust value read / written based modifiers, pass get set options defineModel() . two options receive value get / set model ref return transformed value. use set option implement capitalize modifier: vue <script setup> const [model, modifiers] = defineModel({ set(value) { (modifiers.capitalize) { return value.charAt(0).toUpperCase() + value.slice(1) } return value } }) </script> <template> <input type=\"text\" v-model=\"model\" /> </template> Pre 3.4 Usage vue <script setup> const props = defineProps({ modelValue: String, modelModifiers: { default: () => ({}) } }) const emit = defineEmits(['update:modelValue']) function emitValue(e) { let value = e.target.value (props.modelModifiers.capitalize) { value = value.charAt(0).toUpperCase() + value.slice(1) } emit('update:modelValue', value) } </script> <template> <input type=\"text\" :value=\"props.modelValue\" @input=\"emitValue\" /> </template> Modifiers v-model arguments Here's another example using modifiers multiple v-model different arguments: template <UserName v-model:first-name.capitalize=\"first\" v-model:last-name.uppercase=\"last\" /> vue <script setup> const [firstName, firstNameModifiers] = defineModel('firstName') const [lastName, lastNameModifiers] = defineModel('lastName') console.log(firstNameModifiers) // { capitalize: true } console.log(lastNameModifiers) // { uppercase: true } </script> Pre 3.4 Usage vue <script setup> const props = defineProps({ firstName: String, lastName: String, firstNameModifiers: { default: () => ({}) }, lastNameModifiers: { default: () => ({}) } }) defineEmits(['update:firstName', 'update:lastName']) console.log(props.firstNameModifiers) // { capitalize: true } console.log(props.lastNameModifiers) // { uppercase: true } </script>"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Creating Vue Application application instance Every Vue application starts creating new application instance createApp function: js import { createApp } 'vue' const app = createApp({ /* root component options */ }) Root Component object passing createApp fact component. Every app requires \"root component\" contain components children. using Single-File Components, typically import root component another file: js import { createApp } 'vue' // import root component App single-file component. import App './App.vue' const app = createApp(App) many examples guide need single component, real applications organized tree nested, reusable components. example, Todo application's component tree might look like this: App (root component) \u251c\u2500 TodoList \u2502 \u2514\u2500 TodoItem \u2502 \u251c\u2500 TodoDeleteButton \u2502 \u2514\u2500 TodoEditButton \u2514\u2500 TodoFooter \u251c\u2500 TodoClearButton \u2514\u2500 TodoStatistics later sections guide, discuss define compose multiple components together. that, focus happens inside single component. Mounting App application instance render anything .mount() method called. expects \"container\" argument, either actual DOM element selector string: html <div id=\"app\"></div> js app.mount('#app') content app's root component rendered inside container element. container element considered part app. .mount() method always called app configurations asset registrations done. Also note return value, unlike asset registration methods, root component instance instead application instance. In-DOM Root Component Template template root component usually part component itself, also possible provide template separately writing directly inside mount container: html <div id=\"app\"> <button @click=\"count++\">{{ count }}</button> </div> js import { createApp } 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') Vue automatically use container's innerHTML template root component already template option. In-DOM templates often used applications using Vue without build step. also used conjunction server-side frameworks, root template might generated dynamically server. App Configurations application instance exposes .config object allows us configure app-level options, example, defining app-level error handler captures errors descendant components: js app.config.errorHandler = (err) => { /* handle error */ } application instance also provides methods registering app-scoped assets. example, registering component: js app.component('TodoDeleteButton', TodoDeleteButton) makes TodoDeleteButton available use anywhere app. discuss registration components types assets later sections guide. also browse full list application instance APIs API reference. Make sure apply app configurations mounting app! Multiple application instances limited single application instance page. createApp API allows multiple Vue applications co-exist page, scope configuration global assets: js const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') using Vue enhance server-rendered HTML need Vue control specific parts large page, avoid mounting single Vue application instance entire page. Instead, create multiple small application instances mount elements responsible for."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Class Style Bindings common need data binding manipulating element's class list inline styles. Since class style attributes, use v-bind assign string value dynamically, much like attributes. However, trying generate values using string concatenation annoying error-prone. reason, Vue provides special enhancements v-bind used class style . addition strings, expressions also evaluate objects arrays. Binding HTML Classes Binding Objects pass object :class (short v-bind:class ) dynamically toggle classes: template <div :class=\"{ active: isActive }\"></div> syntax means presence active class determined truthiness data property isActive . multiple classes toggled fields object. addition, :class directive also co-exist plain class attribute. given following state: js const isActive = ref(true) const hasError = ref(false) following template: template <div class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\" ></div> render: template <div class=\"static active\"></div> isActive hasError changes, class list updated accordingly. example, hasError becomes true , class list become \"static active text-danger\" . bound object inline: js const classObject = reactive({ active: true, 'text-danger': false }) template <div :class=\"classObject\"></div> render: template <div class=\"active\"></div> also bind computed property returns object. common powerful pattern: js const isActive = ref(true) const error = ref(null) const classObject = computed(() => ({ active: isActive.value && !error.value, 'text-danger': error.value && error.value.type === 'fatal' })) template <div :class=\"classObject\"></div> Binding Arrays bind :class array apply list classes: js const activeClass = ref('active') const errorClass = ref('text-danger') template <div :class=\"[activeClass, errorClass]\"></div> render: template <div class=\"active text-danger\"></div> would like also toggle class list conditionally, ternary expression: template <div :class=\"[isActive ? activeClass : '', errorClass]\"></div> always apply errorClass , activeClass applied isActive truthy. However, bit verbose multiple conditional classes. That's also possible use object syntax inside array syntax: template <div :class=\"[{ [activeClass]: isActive }, errorClass]\"></div> Components section assumes knowledge Components. Feel free skip come back later. use class attribute component single root element, classes added component's root element merged existing class already it. example, component named MyComponent following template: template <!-- child component template --> <p class=\"foo bar\">Hi!</p> add classes using it: template <!-- using component --> <MyComponent class=\"baz boo\" /> rendered HTML be: template <p class=\"foo bar baz boo\">Hi!</p> true class bindings: template <MyComponent :class=\"{ active: isActive }\" /> isActive truthy, rendered HTML be: template <p class=\"foo bar active\">Hi!</p> component multiple root elements, would need define element receive class. using $attrs component property: template <!-- MyComponent template using $attrs --> <p :class=\"$attrs.class\">Hi!</p> <span>This child component</span> template <MyComponent class=\"baz\" /> render: html <p class=\"baz\">Hi!</p> <span>This child component</span> learn component attribute inheritance Fallthrough Attributes section. Binding Inline Styles Binding Objects :style supports binding JavaScript object values - corresponds HTML element's style property: js const activeColor = ref('red') const fontSize = ref(30) template <div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div> Although camelCase keys recommended, :style also supports kebab-cased CSS property keys (corresponds used actual CSS) - example: template <div :style=\"{ 'font-size': fontSize + 'px' }\"></div> often good idea bind style object directly template cleaner: js const styleObject = reactive({ color: 'red', fontSize: '30px' }) template <div :style=\"styleObject\"></div> Again, object style binding often used conjunction computed properties return objects. Binding Arrays bind :style array multiple style objects. objects merged applied element: template <div :style=\"[baseStyles, overridingStyles]\"></div> Auto-prefixing use CSS property requires vendor prefix :style , Vue automatically add appropriate prefix. Vue checking runtime see style properties supported current browser. browser support particular property various prefixed variants tested try find one supported. Multiple Values provide array multiple (prefixed) values style property, example: template <div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div> render last value array browser supports. example, render display: flex browsers support unprefixed version flexbox."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Components Basics Components allow us split UI independent reusable pieces, think piece isolation. common app organized tree nested components: similar nest native HTML elements, Vue implements component model allows us encapsulate custom content logic component. Vue also plays nicely native Web Components. curious relationship Vue Components native Web Components, read here. Defining Component using build step, typically define Vue component dedicated file using .vue extension - known Single-File Component (SFC short): vue <script setup> import { ref } 'vue' const count = ref(0) </script> <template> <button @click=\"count++\">You clicked {{ count }} times.</button> </template> using build step, Vue component defined plain JavaScript object containing Vue-specific options: js import { ref } 'vue' export default { setup() { const count = ref(0) return { count } }, template: ` <button @click=\"count++\"> clicked {{ count }} times. </button>` // also target in-DOM template: // template: '#my-template-element' } template inlined JavaScript string here, Vue compile fly. also use ID selector pointing element (usually native <template> elements) - Vue use content template source. example defines single component exports default export .js file, use named exports export multiple components file. Using Component TIP using SFC syntax rest guide - concepts around components regardless whether using build step not. Examples section shows component usage scenarios. use child component, need import parent component. Assuming placed counter component inside file called ButtonCounter.vue , component exposed file's default export: vue <script setup> import ButtonCounter './ButtonCounter.vue' </script> <template> <h1>Here child component!</h1> <ButtonCounter /> </template> <script setup> , imported components automatically made available template. also possible globally register component, making available components given app without import it. pros cons global vs. local registration discussed dedicated Component Registration section. Components reused many times want: template <h1>Here many child components!</h1> <ButtonCounter /> <ButtonCounter /> <ButtonCounter /> Notice clicking buttons, one maintains own, separate count . That's time use component, new instance created. SFCs, recommended use PascalCase tag names child components differentiate native HTML elements. Although native HTML tag names case-insensitive, Vue SFC compiled format able use case-sensitive tag names it. also able use /> close tag. authoring templates directly DOM (e.g. content native <template> element), template subject browser's native HTML parsing behavior. cases, need use kebab-case explicit closing tags components: template <!-- template written DOM --> <button-counter></button-counter> <button-counter></button-counter> <button-counter></button-counter> See in-DOM template parsing caveats details. Passing Props building blog, likely need component representing blog post. want blog posts share visual layout, different content. component useful unless pass data it, title content specific post want display. That's props come in. Props custom attributes register component. pass title blog post component, must declare list props component accepts, using defineProps macro: vue <!-- BlogPost.vue --> <script setup> defineProps(['title']) </script> <template> <h4>{{ title }}</h4> </template> defineProps compile-time macro available inside <script setup> need explicitly imported. Declared props automatically exposed template. defineProps also returns object contains props passed component, access JavaScript needed: js const props = defineProps(['title']) console.log(props.title) See also: Typing Component Props using <script setup> , props declared using props option, props object passed setup() first argument: js export default { props: ['title'], setup(props) { console.log(props.title) } } component many props like and, default, value passed prop. prop registered, pass data custom attribute, like this: template <BlogPost title=\"My journey Vue\" /> <BlogPost title=\"Blogging Vue\" /> <BlogPost title=\"Why Vue fun\" /> typical app, however, likely array posts parent component: js const posts = ref([ { id: 1, title: 'My journey Vue' }, { id: 2, title: 'Blogging Vue' }, { id: 3, title: 'Why Vue fun' } ]) want render component one, using v-for : template <BlogPost v-for=\"post posts\" :key=\"post.id\" :title=\"post.title\" /> Notice v-bind syntax (:title=\"post.title\" ) used pass dynamic prop values. especially useful know exact content going render ahead time. That's need know props now, finished reading page feel comfortable content, recommend coming back later read full guide Props. Listening Events develop <BlogPost> component, features may require communicating back parent. example, may decide include accessibility feature enlarge text blog posts, leaving rest page default size. parent, support feature adding postFontSize ref: js const posts = ref([ /* ... */ ]) const postFontSize = ref(1) used template control font size blog posts: template <div :style=\"{ fontSize: postFontSize + 'em' }\"> <BlogPost v-for=\"post posts\" :key=\"post.id\" :title=\"post.title\" /> </div> let's add button <BlogPost> component's template: vue <!-- BlogPost.vue, omitting <script> --> <template> <div class=\"blog-post\"> <h4>{{ title }}</h4> <button>Enlarge text</button> </div> </template> button anything yet - want clicking button communicate parent enlarge text posts. solve problem, components provide custom events system. parent choose listen event child component instance v-on @ , would native DOM event: template <BlogPost ... @enlarge-text=\"postFontSize += 0.1\" /> child component emit event calling built-in $emit method, passing name event: vue <!-- BlogPost.vue, omitting <script> --> <template> <div class=\"blog-post\"> <h4>{{ title }}</h4> <button @click=\"$emit('enlarge-text')\">Enlarge text</button> </div> </template> Thanks @enlarge-text=\"postFontSize += 0.1\" listener, parent receive event update value postFontSize . optionally declare emitted events using defineEmits macro: vue <!-- BlogPost.vue --> <script setup> defineProps(['title']) defineEmits(['enlarge-text']) </script> documents events component emits optionally validates them. also allows Vue avoid implicitly applying native listeners child component's root element. Similar defineProps , defineEmits usable <script setup> need imported. returns emit function equivalent $emit method. used emit events <script setup> section component, $emit directly accessible: vue <script setup> const emit = defineEmits(['enlarge-text']) emit('enlarge-text') </script> See also: Typing Component Emits using <script setup> , declare emitted events using emits option. access emit function property setup context (passed setup() second argument): js export default { emits: ['enlarge-text'], setup(props, ctx) { ctx.emit('enlarge-text') } } That's need know custom component events now, finished reading page feel comfortable content, recommend coming back later read full guide Custom Events. Content Distribution Slots like HTML elements, often useful able pass content component, like this: template <AlertBox> Something bad happened. </AlertBox> might render something like: Error Demo Purposes Something bad happened. achieved using Vue's custom <slot> element: vue <!-- AlertBox.vue --> <template> <div class=\"alert-box\"> <strong>This Error Demo Purposes</strong> <slot /> </div> </template> <style scoped> .alert-box { /* ... */ } </style> see above, use <slot> placeholder want content go \u2013 that's it. We're done! That's need know slots now, finished reading page feel comfortable content, recommend coming back later read full guide Slots. Dynamic Components Sometimes, useful dynamically switch components, like tabbed interface: made possible Vue's <component> element special attribute: template <!-- Component changes currentTab changes --> <component :is=\"tabs[currentTab]\"></component> example above, value passed :is contain either: - name string registered component, - actual imported component object also use attribute create regular HTML elements. switching multiple components <component :is=\"...\"> , component unmounted switched away from. force inactive components stay \"alive\" built-in <KeepAlive> component. in-DOM Template Parsing Caveats writing Vue templates directly DOM, Vue retrieve template string DOM. leads caveats due browsers' native HTML parsing behavior. TIP noted limitations discussed apply writing templates directly DOM. apply using string templates following sources: - Single-File Components - Inlined template strings (e.g. template: '...' ) <script type=\"text/x-template\"> Case Insensitivity HTML tags attribute names case-insensitive, browsers interpret uppercase characters lowercase. means you\u2019re using in-DOM templates, PascalCase component names camelCased prop names v-on event names need use kebab-cased (hyphen-delimited) equivalents: js // camelCase JavaScript const BlogPost = { props: ['postTitle'], emits: ['updatePost'], template: ` <h3>{{ postTitle }}</h3> ` } template <!-- kebab-case HTML --> <blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post> Self Closing Tags using self-closing tags components previous code samples: template <MyComponent /> Vue's template parser respects /> indication end tag, regardless type. in-DOM templates, however, must always include explicit closing tags: template <my-component></my-component> HTML spec allows specific elements omit closing tags, common <input> <img> . elements, omit closing tag, native HTML parser think never terminated opening tag. example, following snippet: template <my-component /> <!-- intend close tag here... --> <span>hello</span> parsed as: template <my-component> <span>hello</span> </my-component> <!-- browser close here. --> Element Placement Restrictions HTML elements, <ul> , <ol> , <table> <select> restrictions elements appear inside them, elements <li> , <tr> , <option> appear inside certain elements. lead issues using components elements restrictions. example: template <table> <blog-post-row></blog-post-row> </table> custom component <blog-post-row> hoisted invalid content, causing errors eventual rendered output. use special attribute workaround: template <table> <tr is=\"vue:blog-post-row\"></tr> </table> TIP used native HTML elements, value must prefixed vue: order interpreted Vue component. required avoid confusion native customized built-in elements. That's need know in-DOM template parsing caveats - actually, end Vue's Essentials. Congratulations! There's still learn, first, recommend taking break play Vue - build something fun, check Examples already. feel comfortable knowledge digested, move guide learn components depth."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Computed Properties Basic Example In-template expressions convenient, meant simple operations. Putting much logic templates make bloated hard maintain. example, object nested array: js const author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - Mystery' ] }) want display different messages depending author already books not: template <p>Has published books:</p> <span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span> point, template getting bit cluttered. look second realizing performs calculation depending author.books . importantly, probably want repeat need include calculation template once. That's complex logic includes reactive data, recommended use computed property. Here's example, refactored: vue <script setup> import { reactive, computed } 'vue' const author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - Mystery' ] }) // computed ref const publishedBooksMessage = computed(() => { return author.books.length > 0 ? 'Yes' : 'No' }) </script> <template> <p>Has published books:</p> <span>{{ publishedBooksMessage }}</span> </template> declared computed property publishedBooksMessage . computed() function expects passed getter function, returned value computed ref. Similar normal refs, access computed result publishedBooksMessage.value . Computed refs also auto-unwrapped templates reference without .value template expressions. computed property automatically tracks reactive dependencies. Vue aware computation publishedBooksMessage depends author.books , update bindings depend publishedBooksMessage author.books changes. See also: Typing Computed Computed Caching vs. Methods may noticed achieve result invoking method expression: template <p>{{ calculateBooksMessage() }}</p> js // component function calculateBooksMessage() { return author.books.length > 0 ? 'Yes' : 'No' } Instead computed property, define function method. end result, two approaches indeed exactly same. However, difference computed properties cached based reactive dependencies. computed property re-evaluate reactive dependencies changed. means long author.books changed, multiple access publishedBooksMessage immediately return previously computed result without run getter function again. also means following computed property never update, Date.now() reactive dependency: js const = computed(() => Date.now()) comparison, method invocation always run function whenever re-render happens. need caching? Imagine expensive computed property list , requires looping huge array lot computations. may computed properties turn depend list . Without caching, would executing list \u2019s getter many times necessary! cases want caching, use method call instead. Writable Computed Computed properties default getter-only. attempt assign new value computed property, receive runtime warning. rare cases need \"writable\" computed property, create one providing getter setter: vue <script setup> import { ref, computed } 'vue' const firstName = ref('John') const lastName = ref('Doe') const fullName = computed({ // getter get() { return firstName.value + ' ' + lastName.value }, // setter set(newValue) { // Note: using destructuring assignment syntax here. [firstName.value, lastName.value] = newValue.split(' ') } }) </script> run fullName.value = 'John Doe' , setter invoked firstName lastName updated accordingly. Getting Previous Value - supported 3.4+ case need it, get previous value returned computed property accessing first argument getter: vue <script setup> import { ref, computed } 'vue' const count = ref(2) // computed return value count less equal 3. // count >=4, last value fulfilled condition returned // instead count less equal 3 const alwaysSmall = computed((previous) => { (count.value <= 3) { return count.value } return previous }) </script> case using writable computed: vue <script setup> import { ref, computed } 'vue' const count = ref(2) const alwaysSmall = computed({ get(previous) { (count.value <= 3) { return count.value } return previous }, set(newValue) { count.value = newValue * 2 } }) </script> Best Practices Getters side-effect free important remember computed getter functions perform pure computation free side effects. example, mutate state, make async requests, mutate DOM inside computed getter! Think computed property declaratively describing derive value based values - responsibility computing returning value. Later guide discuss perform side effects reaction state changes watchers. Avoid mutating computed value returned value computed property derived state. Think temporary snapshot - every time source state changes, new snapshot created. make sense mutate snapshot, computed return value treated read-only never mutated - instead, update source state depends trigger new computations."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Conditional Rendering v-if directive v-if used conditionally render block. block rendered directive's expression returns truthy value. template <h1 v-if=\"awesome\">Vue awesome!</h1> v-else use v-else directive indicate \"else block\" v-if : template <button @click=\"awesome = !awesome\">Toggle</button> <h1 v-if=\"awesome\">Vue awesome!</h1> <h1 v-else>Oh \ud83d\ude22</h1> Vue awesome! v-else element must immediately follow v-if v-else-if element - otherwise recognized. v-else-if v-else-if , name suggests, serves \"else block\" v-if . also chained multiple times: template <div v-if=\"type === 'A'\"> </div> <div v-else-if=\"type === 'B'\"> B </div> <div v-else-if=\"type === 'C'\"> C </div> <div v-else> A/B/C </div> Similar v-else , v-else-if element must immediately follow v-if v-else-if element. v-if <template> v-if directive, attached single element. want toggle one element? case use v-if <template> element, serves invisible wrapper. final rendered result include <template> element. template <template v-if=\"ok\"> <h1>Title</h1> <p>Paragraph 1</p> <p>Paragraph 2</p> </template> v-else v-else-if also used <template> . v-show Another option conditionally displaying element v-show directive. usage largely same: template <h1 v-show=\"ok\">Hello!</h1> difference element v-show always rendered remain DOM; v-show toggles display CSS property element. v-show support <template> element, work v-else . v-if vs. v-show v-if \"real\" conditional rendering ensures event listeners child components inside conditional block properly destroyed re-created toggles. v-if also lazy: condition false initial render, anything - conditional block rendered condition becomes true first time. comparison, v-show much simpler - element always rendered regardless initial condition, CSS-based toggling. Generally speaking, v-if higher toggle costs v-show higher initial render costs. prefer v-show need toggle something often, prefer v-if condition unlikely change runtime. v-if v-for v-if v-for used element, v-if evaluated first. See list rendering guide details. Note recommended use v-if v-for element due implicit precedence. Refer list rendering guide details."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Event Handling Listening Events use v-on directive, typically shorten @ symbol, listen DOM events run JavaScript they're triggered. usage would v-on:click=\"handler\" shortcut, @click=\"handler\" . handler value one following: Inline handlers: Inline JavaScript executed event triggered (similar native onclick attribute).Method handlers: property name path points method defined component. Inline Handlers Inline handlers typically used simple cases, example: js const count = ref(0) template <button @click=\"count++\">Add 1</button> <p>Count is: {{ count }}</p> Method Handlers logic many event handlers complex though, likely feasible inline handlers. That's v-on also accept name path component method like call. example: js const name = ref('Vue.js') function greet(event) { alert(`Hello ${name.value}!`) // `event` native DOM event (event) { alert(event.target.tagName) } } template <!-- `greet` name method defined --> <button @click=\"greet\">Greet</button> method handler automatically receives native DOM Event object triggers - example above, able access element dispatching event via event.target . See also: Typing Event Handlers Method vs. Inline Detection template compiler detects method handlers checking whether v-on value string valid JavaScript identifier property access path. example, foo , foo.bar foo['bar'] treated method handlers, foo() count++ treated inline handlers. Calling Methods Inline Handlers Instead binding directly method name, also call methods inline handler. allows us pass method custom arguments instead native event: js function say(message) { alert(message) } template <button @click=\"say('hello')\">Say hello</button> <button @click=\"say('bye')\">Say bye</button> Accessing Event Argument Inline Handlers Sometimes also need access original DOM event inline handler. pass method using special $event variable, use inline arrow function: template <!-- using $event special variable --> <button @click=\"warn('Form cannot submitted yet.', $event)\"> Submit </button> <!-- using inline arrow function --> <button @click=\"(event) => warn('Form cannot submitted yet.', event)\"> Submit </button> js function warn(message, event) { // access native event (event) { event.preventDefault() } alert(message) } Event Modifiers common need call event.preventDefault() event.stopPropagation() inside event handlers. Although easily inside methods, would better methods purely data logic rather deal DOM event details. address problem, Vue provides event modifiers v-on . Recall modifiers directive postfixes denoted dot. .stop .prevent .self .capture .once .passive template <!-- click event's propagation stopped --> <a @click.stop=\"doThis\"></a> <!-- submit event longer reload page --> <form @submit.prevent=\"onSubmit\"></form> <!-- modifiers chained --> <a @click.stop.prevent=\"doThat\"></a> <!-- modifier --> <form @submit.prevent></form> <!-- trigger handler event.target element --> <!-- i.e. child element --> <div @click.self=\"doThat\">...</div> TIP Order matters using modifiers relevant code generated order. Therefore using @click.prevent.self prevent click's default action element children, @click.self.prevent prevent click's default action element itself. .capture , .once , .passive modifiers mirror options native addEventListener method: template <!-- use capture mode adding event listener --> <!-- i.e. event targeting inner element handled --> <!-- handled element --> <div @click.capture=\"doThis\">...</div> <!-- click event triggered --> <a @click.once=\"doThis\"></a> <!-- scroll event's default behavior (scrolling) happen --> <!-- immediately, instead waiting `onScroll` complete --> <!-- case contains `event.preventDefault()` --> <div @scroll.passive=\"onScroll\">...</div> .passive modifier typically used touch event listeners improving performance mobile devices. TIP use .passive .prevent together, .passive already indicates browser intend prevent event's default behavior, likely see warning browser so. Key Modifiers listening keyboard events, often need check specific keys. Vue allows adding key modifiers v-on @ listening key events: template <!-- call `submit` `key` `Enter` --> <input @keyup.enter=\"submit\" /> directly use valid key names exposed via KeyboardEvent.key modifiers converting kebab-case. template <input @keyup.page-down=\"onPageDown\" /> example, handler called $event.key equal 'PageDown' . Key Aliases Vue provides aliases commonly used keys: .enter .tab .delete (captures \"Delete\" \"Backspace\" keys).esc .space .up .down .left .right System Modifier Keys use following modifiers trigger mouse keyboard event listeners corresponding modifier key pressed: .ctrl .alt .shift .meta Note Macintosh keyboards, meta command key (\u2318). Windows keyboards, meta Windows key (\u229e). Sun Microsystems keyboards, meta marked solid diamond (\u25c6). certain keyboards, specifically MIT Lisp machine keyboards successors, Knight keyboard, space-cadet keyboard, meta labeled \u201cMETA\u201d. Symbolics keyboards, meta labeled \u201cMETA\u201d \u201cMeta\u201d. example: template <!-- Alt + Enter --> <input @keyup.alt.enter=\"clear\" /> <!-- Ctrl + Click --> <div @click.ctrl=\"doSomething\">Do something</div> TIP Note modifier keys different regular keys used keyup events, pressed event emitted. words, keyup.ctrl trigger release key holding ctrl . trigger release ctrl key alone. .exact Modifier .exact modifier allows control exact combination system modifiers needed trigger event. template <!-- fire even Alt Shift also pressed --> <button @click.ctrl=\"onClick\">A</button> <!-- fire Ctrl keys pressed --> <button @click.ctrl.exact=\"onCtrlClick\">A</button> <!-- fire system modifiers pressed --> <button @click.exact=\"onClick\">A</button> Mouse Button Modifiers .left .right .middle modifiers restrict handler events triggered specific mouse button. Note, however, .left , .right , .middle modifier names based typical right-handed mouse layout, fact represent \"main\", \"secondary\", \"auxiliary\" pointing device event triggers, respectively, actual physical buttons. left-handed mouse layout \"main\" button might physically right one would trigger .left modifier handler. trackpad might trigger .left handler one-finger tap, .right handler two-finger tap, .middle handler three-finger tap. Similarly, devices event sources generating \"mouse\" events might trigger modes related \"left\" \"right\" whatsoever."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Form Input Bindings dealing forms frontend, often need sync state form input elements corresponding state JavaScript. cumbersome manually wire value bindings change event listeners: template <input :value=\"text\" @input=\"event => text = event.target.value\"> v-model directive helps us simplify to: template <input v-model=\"text\"> addition, v-model used inputs different types, <textarea> , <select> elements. automatically expands different DOM property event pairs based element used on: <input> text types and<textarea> elements usevalue property andinput event;<input type=\"checkbox\"> and<input type=\"radio\"> usechecked property andchange event;<select> usesvalue prop andchange event. Note v-model ignore initial value , checked selected attributes found form elements. always treat current bound JavaScript state source truth. declare initial value JavaScript side, using reactivity APIs. Basic Usage Text template <p>Message is: {{ message }}</p> <input v-model=\"message\" placeholder=\"edit me\" /> Message is: Note languages require IME (Chinese, Japanese, Korean etc.), notice v-model get updated IME composition. want respond updates well, use input event listener value binding instead using v-model . Multiline Text template <span>Multiline message is:</span> <p style=\"white-space: pre-line;\">{{ message }}</p> <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea> Multiline message is: Note interpolation inside <textarea> work. Use v-model instead. template <!-- bad --> <textarea>{{ text }}</textarea> <!-- good --> <textarea v-model=\"text\"></textarea> Checkbox Single checkbox, boolean value: template <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" /> <label for=\"checkbox\">{{ checked }}</label> also bind multiple checkboxes array Set value: js const checkedNames = ref([]) template <div>Checked names: {{ checkedNames }}</div> <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" /> <label for=\"jack\">Jack</label> <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" /> <label for=\"john\">John</label> <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" /> <label for=\"mike\">Mike</label> Checked names: [] case, checkedNames array always contain values currently checked boxes. Radio template <div>Picked: {{ picked }}</div> <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" /> <label for=\"one\">One</label> <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" /> <label for=\"two\">Two</label> Picked: Select Single select: template <div>Selected: {{ selected }}</div> <select v-model=\"selected\"> <option disabled value=\"\">Please select one</option> <option>A</option> <option>B</option> <option>C</option> </select> Selected: Note initial value v-model expression match options, <select> element render \"unselected\" state. iOS cause user able select first item iOS fire change event case. therefore recommended provide disabled option empty value, demonstrated example above. Multiple select (bound array): template <div>Selected: {{ selected }}</div> <select v-model=\"selected\" multiple> <option>A</option> <option>B</option> <option>C</option> </select> Selected: [] Select options dynamically rendered v-for : js const selected = ref('A') const options = ref([ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ]) template <select v-model=\"selected\"> <option v-for=\"option options\" :value=\"option.value\"> {{ option.text }} </option> </select> <div>Selected: {{ selected }}</div> Value Bindings radio, checkbox select options, v-model binding values usually static strings (or booleans checkbox): template <!-- `picked` string \"a\" checked --> <input type=\"radio\" v-model=\"picked\" value=\"a\" /> <!-- `toggle` either true false --> <input type=\"checkbox\" v-model=\"toggle\" /> <!-- `selected` string \"abc\" first option selected --> <select v-model=\"selected\"> <option value=\"abc\">ABC</option> </select> sometimes may want bind value dynamic property current active instance. use v-bind achieve that. addition, using v-bind allows us bind input value non-string values. Checkbox template <input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\" /> true-value false-value Vue-specific attributes work v-model . toggle property's value set 'yes' box checked, set 'no' unchecked. also bind dynamic values using v-bind : template <input type=\"checkbox\" v-model=\"toggle\" :true-value=\"dynamicTrueValue\" :false-value=\"dynamicFalseValue\" /> Tip true-value false-value attributes affect input's value attribute, browsers include unchecked boxes form submissions. guarantee one two values submitted form (e.g. \"yes\" \"no\"), use radio inputs instead. Radio template <input type=\"radio\" v-model=\"pick\" :value=\"first\" /> <input type=\"radio\" v-model=\"pick\" :value=\"second\" /> pick set value first first radio input checked, set value second second one checked. Select Options template <select v-model=\"selected\"> <!-- inline object literal --> <option :value=\"{ number: 123 }\">123</option> </select> v-model supports value bindings non-string values well! example, option selected, selected set object literal value { number: 123 } . Modifiers .lazy default, v-model syncs input data input event (with exception IME composition stated above). add lazy modifier instead sync change events: template <!-- synced \"change\" instead \"input\" --> <input v-model.lazy=\"msg\" /> .number want user input automatically typecast number, add number modifier v-model managed inputs: template <input v-model.number=\"age\" /> value cannot parsed parseFloat() , original (string) value used instead. particular, input empty (for instance user clearing input field), empty string returned. behavior differs DOM property valueAsNumber . number modifier applied automatically input type=\"number\" . .trim want whitespace user input trimmed automatically, add trim modifier v-model -managed inputs: template <input v-model.trim=\"msg\" /> v-model Components yet familiar Vue's components, skip now. HTML's built-in input types always meet needs. Fortunately, Vue components allow build reusable inputs completely customized behavior. inputs even work v-model ! learn more, read Usage v-model Components guide."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Lifecycle Hooks Vue component instance goes series initialization steps created - example, needs set data observation, compile template, mount instance DOM, update DOM data changes. Along way, also runs functions called lifecycle hooks, giving users opportunity add code specific stages. Registering Lifecycle Hooks example, onMounted hook used run code component finished initial rendering created DOM nodes: vue <script setup> import { onMounted } 'vue' onMounted(() => { console.log(`the component mounted.`) }) </script> also hooks called different stages instance's lifecycle, commonly used onMounted , onUpdated , onUnmounted . calling onMounted , Vue automatically associates registered callback function current active component instance. requires hooks registered synchronously component setup. example, this: js setTimeout(() => { onMounted(() => { // work. }) }, 100) note mean call must placed lexically inside setup() <script setup> . onMounted() called external function long call stack synchronous originates within setup() . Lifecycle Diagram diagram instance lifecycle. need fully understand everything going right now, learn build more, useful reference. Consult Lifecycle Hooks API reference details lifecycle hooks respective use cases."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "List Rendering v-for use v-for directive render list items based array. v-for directive requires special syntax form item items , items source data array item alias array element iterated on: js const items = ref([{ message: 'Foo' }, { message: 'Bar' }]) template <li v-for=\"item items\"> {{ item.message }} </li> Inside v-for scope, template expressions access parent scope properties. addition, v-for also supports optional second alias index current item: js const parentMessage = ref('Parent') const items = ref([{ message: 'Foo' }, { message: 'Bar' }]) template <li v-for=\"(item, index) items\"> {{ parentMessage }} - {{ index }} - {{ item.message }} </li> variable scoping v-for similar following JavaScript: js const parentMessage = 'Parent' const items = [ /* ... */ ] items.forEach((item, index) => { // access outer scope `parentMessage` // `item` `index` available console.log(parentMessage, item.message, index) }) Notice v-for value matches function signature forEach callback. fact, use destructuring v-for item alias similar destructuring function arguments: template <li v-for=\"{ message } items\"> {{ message }} </li> <!-- index alias --> <li v-for=\"({ message }, index) items\"> {{ message }} {{ index }} </li> nested v-for , scoping also works similar nested functions. v-for scope access parent scopes: template <li v-for=\"item items\"> <span v-for=\"childItem item.children\"> {{ item.message }} {{ childItem }} </span> </li> also use delimiter instead , closer JavaScript's syntax iterators: template <div v-for=\"item items\"></div> v-for Object also use v-for iterate properties object. iteration order based result calling Object.values() object: js const myObject = reactive({ title: 'How lists Vue', author: 'Jane Doe', publishedAt: '2016-04-10' }) template <ul> <li v-for=\"value myObject\"> {{ value }} </li> </ul> also provide second alias property's name (a.k.a. key): template <li v-for=\"(value, key) myObject\"> {{ key }}: {{ value }} </li> another index: template <li v-for=\"(value, key, index) myObject\"> {{ index }}. {{ key }}: {{ value }} </li> v-for Range v-for also take integer. case repeat template many times, based range 1...n . template <span v-for=\"n 10\">{{ n }}</span> Note n starts initial value 1 instead 0 . v-for <template> Similar template v-if , also use <template> tag v-for render block multiple elements. example: template <ul> <template v-for=\"item items\"> <li>{{ item.msg }}</li> <li class=\"divider\" role=\"presentation\"></li> </template> </ul> v-for v-if exist node, v-if higher priority v-for . means v-if condition access variables scope v-for : template <!-- throw error property \"todo\" defined instance. --> <li v-for=\"todo todos\" v-if=\"!todo.isComplete\"> {{ todo.name }} </li> fixed moving v-for wrapping <template> tag (which also explicit): template <template v-for=\"todo todos\"> <li v-if=\"!todo.isComplete\"> {{ todo.name }} </li> </template> Note recommended use v-if v-for element due implicit precedence. two common cases tempting: filter items list (e.g. v-for=\"user users\" v-if=\"user.isActive\" ). cases, replaceusers new computed property returns filtered list (e.g.activeUsers ).To avoid rendering list hidden (e.g. v-for=\"user users\" v-if=\"shouldShowUsers\" ). cases, move thev-if container element (e.g.ul ,ol ). Maintaining State key Vue updating list elements rendered v-for , default uses \"in-place patch\" strategy. order data items changed, instead moving DOM elements match order items, Vue patch element in-place make sure reflects rendered particular index. default mode efficient, suitable list render output rely child component state temporary DOM state (e.g. form input values). give Vue hint track node's identity, thus reuse reorder existing elements, need provide unique key attribute item: template <div v-for=\"item items\" :key=\"item.id\"> <!-- content --> </div> using <template v-for> , key placed <template> container: template <template v-for=\"todo todos\" :key=\"todo.name\"> <li>{{ todo.name }}</li> </template> Note key special attribute bound v-bind . confused property key variable using v-for object. recommended provide key attribute v-for whenever possible, unless iterated DOM content simple (i.e. contains components stateful DOM elements), intentionally relying default behavior performance gains. key binding expects primitive values - i.e. strings numbers. use objects v-for keys. detailed usage key attribute, please see key API documentation. v-for Component section assumes knowledge Components. Feel free skip come back later. directly use v-for component, like normal element (don't forget provide key ): template <MyComponent v-for=\"item items\" :key=\"item.id\" /> However, automatically pass data component, components isolated scopes own. order pass iterated data component, also use props: template <MyComponent v-for=\"(item, index) items\" :item=\"item\" :index=\"index\" :key=\"item.id\" /> reason automatically injecting item component makes component tightly coupled v-for works. explicit data comes makes component reusable situations. Check example simple todo list see render list components using v-for , passing different data instance. Array Change Detection Mutation Methods Vue able detect reactive array's mutation methods called trigger necessary updates. mutation methods are: push() pop() shift() unshift() splice() sort() reverse() Replacing Array Mutation methods, name suggests, mutate original array called on. comparison, also non-mutating methods, e.g. filter() , concat() slice() , mutate original array always return new array. working non-mutating methods, replace old array new one: js // `items` ref array value items.value = items.value.filter((item) => item.message.match(/Foo/)) might think cause Vue throw away existing DOM re-render entire list - luckily, case. Vue implements smart heuristics maximize DOM element reuse, replacing array another array containing overlapping objects efficient operation. Displaying Filtered/Sorted Results Sometimes want display filtered sorted version array without actually mutating resetting original data. case, create computed property returns filtered sorted array. example: js const numbers = ref([1, 2, 3, 4, 5]) const evenNumbers = computed(() => { return numbers.value.filter((n) => n % 2 === 0) }) template <li v-for=\"n evenNumbers\">{{ n }}</li> situations computed properties feasible (e.g. inside nested v-for loops), use method: js const sets = ref([ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] ]) function even(numbers) { return numbers.filter((number) => number % 2 === 0) } template <ul v-for=\"numbers sets\"> <li v-for=\"n even(numbers)\">{{ n }}</li> </ul> careful reverse() sort() computed property! two methods mutate original array, avoided computed getters. Create copy original array calling methods: diff - return numbers.reverse() + return [...numbers].reverse()"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity Fundamentals API Preference page many chapters later guide contain different content Options API Composition API. current preference Composition API. toggle API styles using \"API Preference\" switches top left sidebar. Declaring Reactive State ref() Composition API, recommended way declare reactive state using ref() function: js import { ref } 'vue' const count = ref(0) ref() takes argument returns wrapped within ref object .value property: js const count = ref(0) console.log(count) // { value: 0 } console.log(count.value) // 0 count.value++ console.log(count.value) // 1 See also: Typing Refs access refs component's template, declare return component's setup() function: js import { ref } 'vue' export default { // `setup` special hook dedicated Composition API. setup() { const count = ref(0) // expose ref template return { count } } } template <div>{{ count }}</div> Notice need append .value using ref template. convenience, refs automatically unwrapped used inside templates (with caveats). also mutate ref directly event handlers: template <button @click=\"count++\"> {{ count }} </button> complex logic, declare functions mutate refs scope expose methods alongside state: js import { ref } 'vue' export default { setup() { const count = ref(0) function increment() { // .value needed JavaScript count.value++ } // forget expose function well. return { count, increment } } } Exposed methods used event handlers: template <button @click=\"increment\"> {{ count }} </button> Here's example live Codepen, without using build tools. <script setup> Manually exposing state methods via setup() verbose. Luckily, avoided using Single-File Components (SFCs). simplify usage <script setup> : vue <script setup> import { ref } 'vue' const count = ref(0) function increment() { count.value++ } </script> <template> <button @click=\"increment\"> {{ count }} </button> </template> Top-level imports, variables functions declared <script setup> automatically usable template component. Think template JavaScript function declared scope - naturally access everything declared alongside it. TIP rest guide, primarily using SFC + <script setup> syntax Composition API code examples, common usage Vue developers. using SFC, still use Composition API setup() option. Refs? might wondering need refs .value instead plain variables. explain that, need briefly discuss Vue's reactivity system works. use ref template, change ref's value later, Vue automatically detects change updates DOM accordingly. made possible dependency-tracking based reactivity system. component rendered first time, Vue tracks every ref used render. Later on, ref mutated, trigger re-render components tracking it. standard JavaScript, way detect access mutation plain variables. However, intercept get set operations object's properties using getter setter methods. .value property gives Vue opportunity detect ref accessed mutated. hood, Vue performs tracking getter, performs triggering setter. Conceptually, think ref object looks like this: js // pseudo code, actual implementation const myRef = { _value: 0, get value() { track() return this._value }, set value(newValue) { this._value = newValue trigger() } } Another nice trait refs unlike plain variables, pass refs functions retaining access latest value reactivity connection. particularly useful refactoring complex logic reusable code. reactivity system discussed details Reactivity Depth section. Deep Reactivity Refs hold value type, including deeply nested objects, arrays, JavaScript built-in data structures like Map . ref make value deeply reactive. means expect changes detected even mutate nested objects arrays: js import { ref } 'vue' const obj = ref({ nested: { count: 0 }, arr: ['foo', 'bar'] }) function mutateDeeply() { // work expected. obj.value.nested.count++ obj.value.arr.push('baz') } Non-primitive values turned reactive proxies via reactive() , discussed below. also possible opt-out deep reactivity shallow refs. shallow refs, .value access tracked reactivity. Shallow refs used optimizing performance avoiding observation cost large objects, cases inner state managed external library. reading: DOM Update Timing mutate reactive state, DOM updated automatically. However, noted DOM updates applied synchronously. Instead, Vue buffers \"next tick\" update cycle ensure component updates matter many state changes made. wait DOM update complete state change, use nextTick() global API: js import { nextTick } 'vue' async function increment() { count.value++ await nextTick() // DOM updated } reactive() another way declare reactive state, reactive() API. Unlike ref wraps inner value special object, reactive() makes object reactive: js import { reactive } 'vue' const state = reactive({ count: 0 }) See also: Typing Reactive Usage template: template <button @click=\"state.count++\"> {{ state.count }} </button> Reactive objects JavaScript Proxies behave like normal objects. difference Vue able intercept access mutation properties reactive object reactivity tracking triggering. reactive() converts object deeply: nested objects also wrapped reactive() accessed. also called ref() internally ref value object. Similar shallow refs, also shallowReactive() API opting-out deep reactivity. Reactive Proxy vs. Original important note returned value reactive() Proxy original object, equal original object: js const raw = {} const proxy = reactive(raw) // proxy equal original. console.log(proxy === raw) // false proxy reactive - mutating original object trigger updates. Therefore, best practice working Vue's reactivity system exclusively use proxied versions state. ensure consistent access proxy, calling reactive() object always returns proxy, calling reactive() existing proxy also returns proxy: js // calling reactive() object returns proxy console.log(reactive(raw) === proxy) // true // calling reactive() proxy returns console.log(reactive(proxy) === proxy) // true rule applies nested objects well. Due deep reactivity, nested objects inside reactive object also proxies: js const proxy = reactive({}) const raw = {} proxy.nested = raw console.log(proxy.nested === raw) // false Limitations reactive() reactive() API limitations: Limited value types: works object types (objects, arrays, collection types Map andSet ). cannot hold primitive types asstring ,number orboolean .Cannot replace entire object: since Vue's reactivity tracking works property access, must always keep reference reactive object. means can't easily \"replace\" reactive object reactivity connection first reference lost: jslet state = reactive({ count: 0 }) // reference ({ count: 0 }) longer tracked // (reactivity connection lost!) state = reactive({ count: 1 }) destructure-friendly: destructure reactive object's primitive type property local variables, pass property function, lose reactivity connection: jsconst state = reactive({ count: 0 }) // count disconnected state.count destructured. let { count } = state // affect original state count++ // function receives plain number // able track changes state.count // pass entire object retain reactivity callSomeFunction(state.count) Due limitations, recommend using ref() primary API declaring reactive state. Additional Ref Unwrapping Details Reactive Object Property ref automatically unwrapped accessed mutated property reactive object. words, behaves like normal property: js const count = ref(0) const state = reactive({ count }) console.log(state.count) // 0 state.count = 1 console.log(count.value) // 1 new ref assigned property linked existing ref, replace old ref: js const otherCount = ref(2) state.count = otherCount console.log(state.count) // 2 // original ref disconnected state.count console.log(count.value) // 1 Ref unwrapping happens nested inside deep reactive object. apply accessed property shallow reactive object. Caveat Arrays Collections Unlike reactive objects, unwrapping performed ref accessed element reactive array native collection type like Map : js const books = reactive([ref('Vue 3 Guide')]) // need .value console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value console.log(map.get('count').value) Caveat Unwrapping Templates Ref unwrapping templates applies ref top-level property template render context. example below, count object top-level properties, object.id not: js const count = ref(0) const object = { id: ref(1) } Therefore, expression works expected: template {{ count + 1 }} ...while one NOT: template {{ object.id + 1 }} rendered result [object Object]1 object.id unwrapped evaluating expression remains ref object. fix this, destructure id top-level property: js const { id } = object template {{ id + 1 }} render result 2 . Another thing note ref get unwrapped final evaluated value text interpolation (i.e. {{ }} tag), following render 1 : template {{ object.id }} convenience feature text interpolation equivalent {{ object.id.value }} ."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Template Refs Vue's declarative rendering model abstracts away direct DOM operations you, may still cases need direct access underlying DOM elements. achieve this, use special ref attribute: template <input ref=\"input\"> ref special attribute, similar key attribute discussed v-for chapter. allows us obtain direct reference specific DOM element child component instance mounted. may useful want to, example, programmatically focus input component mount, initialize 3rd party library element. Accessing Refs obtain reference Composition API, use useTemplateRef() helper: vue <script setup> import { useTemplateRef, onMounted } 'vue' // first argument must match ref value template const input = useTemplateRef('my-input') onMounted(() => { input.value.focus() }) </script> <template> <input ref=\"my-input\" /> </template> using TypeScript, Vue's IDE support vue-tsc automatically infer type input.value based element component matching ref attribute used on. Usage 3.5 versions 3.5 useTemplateRef() introduced, need declare ref name matches template ref attribute's value: vue <script setup> import { ref, onMounted } 'vue' // declare ref hold element reference // name must match template ref value const input = ref(null) onMounted(() => { input.value.focus() }) </script> <template> <input ref=\"input\" /> </template> using <script setup> , make sure also return ref setup() : js export default { setup() { const input = ref(null) // ... return { input } } } Note access ref component mounted. try access input template expression, null first render. element exist first render! trying watch changes template ref, make sure account case ref null value: js watchEffect(() => { (input.value) { input.value.focus() } else { // mounted yet, element unmounted (e.g. v-if) } }) See also: Typing Template Refs Refs inside v-for Requires v3.5 ref used inside v-for , corresponding ref contain Array value, populated elements mount: vue <script setup> import { ref, useTemplateRef, onMounted } 'vue' const list = ref([ /* ... */ ]) const itemRefs = useTemplateRef('items') onMounted(() => console.log(itemRefs.value)) </script> <template> <ul> <li v-for=\"item list\" ref=\"items\"> {{ item }} </li> </ul> </template> Usage 3.5 versions 3.5 useTemplateRef() introduced, need declare ref name matches template ref attribute's value. ref also contain array value: vue <script setup> import { ref, onMounted } 'vue' const list = ref([ /* ... */ ]) const itemRefs = ref([]) onMounted(() => console.log(itemRefs.value)) </script> <template> <ul> <li v-for=\"item list\" ref=\"itemRefs\"> {{ item }} </li> </ul> </template> noted ref array guarantee order source array. Function Refs Instead string key, ref attribute also bound function, called component update gives full flexibility store element reference. function receives element reference first argument: template <input :ref=\"(el) => { /* assign el property ref */ }\"> Note using dynamic :ref binding pass function instead ref name string. element unmounted, argument null . can, course, use method instead inline function. Ref Component section assumes knowledge Components. Feel free skip come back later. ref also used child component. case reference component instance: vue <script setup> import { useTemplateRef, onMounted } 'vue' import Child './Child.vue' const childRef = useTemplateRef('child') onMounted(() => { // childRef.value hold instance <Child /> }) </script> <template> <Child ref=\"child\" /> </template> Usage 3.5 vue <script setup> import { ref, onMounted } 'vue' import Child './Child.vue' const child = ref(null) onMounted(() => { // child.value hold instance <Child /> }) </script> <template> <Child ref=\"child\" /> </template> child component using Options API using <script setup> , referenced instance identical child component's , means parent component full access every property method child component. makes easy create tightly coupled implementation details parent child, component refs used absolutely needed - cases, try implement parent / child interactions using standard props emit interfaces first. exception components using <script setup> private default: parent component referencing child component using <script setup> able access anything unless child component chooses expose public interface using defineExpose macro: vue <script setup> import { ref } 'vue' const = 1 const b = ref(2) // Compiler macros, defineExpose, need imported defineExpose({ a, b }) </script> parent gets instance component via template refs, retrieved instance shape { a: number, b: number } (refs automatically unwrapped like normal instances). Note defineExpose must called await operation. Otherwise, properties methods exposed await operation accessible. See also: Typing Component Template Refs"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Template Syntax Vue uses HTML-based template syntax allows declaratively bind rendered DOM underlying component instance's data. Vue templates syntactically valid HTML parsed spec-compliant browsers HTML parsers. hood, Vue compiles templates highly-optimized JavaScript code. Combined reactivity system, Vue intelligently figure minimal number components re-render apply minimal amount DOM manipulations app state changes. familiar Virtual DOM concepts prefer raw power JavaScript, also directly write render functions instead templates, optional JSX support. However, note enjoy level compile-time optimizations templates. Text Interpolation basic form data binding text interpolation using \"Mustache\" syntax (double curly braces): template <span>Message: {{ msg }}</span> mustache tag replaced value msg property corresponding component instance. also updated whenever msg property changes. Raw HTML double mustaches interpret data plain text, HTML. order output real HTML, need use v-html directive: template <p>Using text interpolation: {{ rawHtml }}</p> <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p> Using text interpolation: <span style=\"color: red\">This red.</span> Using v-html directive: red. we're encountering something new. v-html attribute seeing called directive. Directives prefixed v- indicate special attributes provided Vue, may guessed, apply special reactive behavior rendered DOM. Here, we're basically saying \"keep element's inner HTML up-to-date rawHtml property current active instance.\" contents span replaced value rawHtml property, interpreted plain HTML - data bindings ignored. Note cannot use v-html compose template partials, Vue string-based templating engine. Instead, components preferred fundamental unit UI reuse composition. Security Warning Dynamically rendering arbitrary HTML website dangerous easily lead XSS vulnerabilities. use v-html trusted content never user-provided content. Attribute Bindings Mustaches cannot used inside HTML attributes. Instead, use v-bind directive: template <div v-bind:id=\"dynamicId\"></div> v-bind directive instructs Vue keep element's id attribute sync component's dynamicId property. bound value null undefined , attribute removed rendered element. Shorthand v-bind commonly used, dedicated shorthand syntax: template <div :id=\"dynamicId\"></div> Attributes start : may look bit different normal HTML, fact valid character attribute names Vue-supported browsers parse correctly. addition, appear final rendered markup. shorthand syntax optional, likely appreciate learn usage later. rest guide, using shorthand syntax code examples, that's common usage Vue developers. Same-name Shorthand - supported 3.4+ attribute name JavaScript value bound, syntax shortened omit attribute value: template <!-- :id=\"id\" --> <div :id></div> <!-- also works --> <div v-bind:id></div> similar property shorthand syntax declaring objects JavaScript. Note feature available Vue 3.4 above. Boolean Attributes Boolean attributes attributes indicate true / false values presence element. example, disabled one commonly used boolean attributes. v-bind works bit differently case: template <button :disabled=\"isButtonDisabled\">Button</button> disabled attribute included isButtonDisabled truthy value. also included value empty string, maintaining consistency <button disabled=\"\"> . falsy values attribute omitted. Dynamically Binding Multiple Attributes JavaScript object representing multiple attributes looks like this: js const objectOfAttrs = { id: 'container', class: 'wrapper', style: 'background-color:green' } bind single element using v-bind without argument: template <div v-bind=\"objectOfAttrs\"></div> Using JavaScript Expressions far we've binding simple property keys templates. Vue actually supports full power JavaScript expressions inside data bindings: template {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} <div :id=\"`list-${id}`\"></div> expressions evaluated JavaScript data scope current component instance. Vue templates, JavaScript expressions used following positions: - Inside text interpolations (mustaches) - attribute value Vue directives (special attributes start v- ) Expressions binding contain one single expression. expression piece code evaluated value. simple check whether used return . Therefore, following work: template <!-- statement, expression: --> {{ var = 1 }} <!-- flow control work either, use ternary expressions --> {{ (ok) { return message } }} Calling Functions possible call component-exposed method inside binding expression: template <time :title=\"toTitleDate(date)\" :datetime=\"date\"> {{ formatDate(date) }} </time> TIP Functions called inside binding expressions called every time component updates, side effects, changing data triggering asynchronous operations. Restricted Globals Access Template expressions sandboxed access restricted list globals. list exposes commonly used built-in globals Math Date . Globals explicitly included list, example user-attached properties window , accessible template expressions. can, however, explicitly define additional globals Vue expressions adding app.config.globalProperties . Directives Directives special attributes v- prefix. Vue provides number built-in directives, including v-html v-bind introduced above. Directive attribute values expected single JavaScript expressions (with exception v-for , v-on v-slot , discussed respective sections later). directive's job reactively apply updates DOM value expression changes. Take v-if example: template <p v-if=\"seen\">Now see me</p> Here, v-if directive would remove insert <p> element based truthiness value expression seen . Arguments directives take \"argument\", denoted colon directive name. example, v-bind directive used reactively update HTML attribute: template <a v-bind:href=\"url\"> ... </a> <!-- shorthand --> <a :href=\"url\"> ... </a> Here, href argument, tells v-bind directive bind element's href attribute value expression url . shorthand, everything argument (i.e., v-bind: ) condensed single character, : . Another example v-on directive, listens DOM events: template <a v-on:click=\"doSomething\"> ... </a> <!-- shorthand --> <a @click=\"doSomething\"> ... </a> Here, argument event name listen to: click . v-on corresponding shorthand, namely @ character. talk event handling detail too. Dynamic Arguments also possible use JavaScript expression directive argument wrapping square brackets: template <!-- Note constraints argument expression, explained \"Dynamic Argument Value Constraints\" \"Dynamic Argument Syntax Constraints\" sections below. --> <a v-bind:[attributeName]=\"url\"> ... </a> <!-- shorthand --> <a :[attributeName]=\"url\"> ... </a> Here, attributeName dynamically evaluated JavaScript expression, evaluated value used final value argument. example, component instance data property, attributeName , whose value \"href\" , binding equivalent v-bind:href . Similarly, use dynamic arguments bind handler dynamic event name: template <a v-on:[eventName]=\"doSomething\"> ... </a> <!-- shorthand --> <a @[eventName]=\"doSomething\"> ... </a> example, eventName 's value \"focus\" , v-on:[eventName] equivalent v-on:focus . Dynamic Argument Value Constraints Dynamic arguments expected evaluate string, exception null . special value null used explicitly remove binding. non-string value trigger warning. Dynamic Argument Syntax Constraints Dynamic argument expressions syntax constraints certain characters, spaces quotes, invalid inside HTML attribute names. example, following invalid: template <!-- trigger compiler warning. --> <a :['foo' + bar]=\"value\"> ... </a> need pass complex dynamic argument, probably better use computed property, cover shortly. using in-DOM templates (templates directly written HTML file), also avoid naming keys uppercase characters, browsers coerce attribute names lowercase: template <a :[someAttr]=\"value\"> ... </a> converted :[someattr] in-DOM templates. component someAttr property instead someattr , code work. Templates inside Single-File Components subject constraint. Modifiers Modifiers special postfixes denoted dot, indicate directive bound special way. example, .prevent modifier tells v-on directive call event.preventDefault() triggered event: template <form @submit.prevent=\"onSubmit\">...</form> see examples modifiers later, v-on v-model , explore features. finally, here's full directive syntax visualized:"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Watchers Basic Example Computed properties allow us declaratively compute derived values. However, cases need perform \"side effects\" reaction state changes - example, mutating DOM, changing another piece state based result async operation. Composition API, use watch function trigger callback whenever piece reactive state changes: vue <script setup> import { ref, watch } 'vue' const question = ref('') const answer = ref('Questions usually contain question mark. ;-)') const loading = ref(false) // watch works directly ref watch(question, async (newQuestion, oldQuestion) => { (newQuestion.includes('?')) { loading.value = true answer.value = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') answer.value = (await res.json()).answer } catch (error) { answer.value = 'Error! Could reach API. ' + error } finally { loading.value = false } } }) </script> <template> <p> Ask yes/no question: <input v-model=\"question\" :disabled=\"loading\" /> </p> <p>{{ answer }}</p> </template> Watch Source Types watch 's first argument different types reactive \"sources\": ref (including computed refs), reactive object, getter function, array multiple sources: js const x = ref(0) const = ref(0) // single ref watch(x, (newX) => { console.log(`x ${newX}`) }) // getter watch( () => x.value + y.value, (sum) => { console.log(`sum x + is: ${sum}`) } ) // array multiple sources watch([x, () => y.value], ([newX, newY]) => { console.log(`x ${newX} ${newY}`) }) note can't watch property reactive object like this: js const obj = reactive({ count: 0 }) // work passing number watch() watch(obj.count, (count) => { console.log(`Count is: ${count}`) }) Instead, use getter: js // instead, use getter: watch( () => obj.count, (count) => { console.log(`Count is: ${count}`) } ) Deep Watchers call watch() directly reactive object, implicitly create deep watcher - callback triggered nested mutations: js const obj = reactive({ count: 0 }) watch(obj, (newValue, oldValue) => { // fires nested property mutations // Note: `newValue` equal `oldValue` // point object! }) obj.count++ differentiated getter returns reactive object - latter case, callback fire getter returns different object: js watch( () => state.someObject, () => { // fires state.someObject replaced } ) can, however, force second case deep watcher explicitly using deep option: js watch( () => state.someObject, (newValue, oldValue) => { // Note: `newValue` equal `oldValue` // *unless* state.someObject replaced }, { deep: true } ) Vue 3.5+, deep option also number indicating max traversal depth - i.e. many levels Vue traverse object's nested properties. Use Caution Deep watch requires traversing nested properties watched object, expensive used large data structures. Use necessary beware performance implications. Eager Watchers watch lazy default: callback called watched source changed. cases may want callback logic run eagerly - example, may want fetch initial data, re-fetch data whenever relevant state changes. force watcher's callback executed immediately passing immediate: true option: js watch( source, (newValue, oldValue) => { // executed immediately, `source` changes }, { immediate: true } ) Watchers - supported 3.4+ Watcher's callback execute whenever watched source changes. want callback trigger source changes, use once: true option. js watch( source, (newValue, oldValue) => { // `source` changes, triggers }, { once: true } ) watchEffect() common watcher callback use exactly reactive state source. example, consider following code, uses watcher load remote resource whenever todoId ref changes: js const todoId = ref(1) const data = ref(null) watch( todoId, async () => { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ) data.value = await response.json() }, { immediate: true } ) particular, notice watcher uses todoId twice, source inside callback. simplified watchEffect() . watchEffect() allows us track callback's reactive dependencies automatically. watcher rewritten as: js watchEffect(async () => { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ) data.value = await response.json() }) Here, callback run immediately, there's need specify immediate: true . execution, automatically track todoId.value dependency (similar computed properties). Whenever todoId.value changes, callback run again. watchEffect() , longer need pass todoId explicitly source value. check example watchEffect() reactive data-fetching action. examples like these, one dependency, benefit watchEffect() relatively small. watchers multiple dependencies, using watchEffect() removes burden maintain list dependencies manually. addition, need watch several properties nested data structure, watchEffect() may prove efficient deep watcher, track properties used callback, rather recursively tracking them. TIP watchEffect tracks dependencies synchronous execution. using async callback, properties accessed first await tick tracked. watch vs. watchEffect watch watchEffect allow us reactively perform side effects. main difference way track reactive dependencies: watch tracks explicitly watched source. track anything accessed inside callback. addition, callback triggers source actually changed.watch separates dependency tracking side effect, giving us precise control callback fire.watchEffect , hand, combines dependency tracking side effect one phase. automatically tracks every reactive property accessed synchronous execution. convenient typically results terser code, makes reactive dependencies less explicit. Side Effect Cleanup Sometimes may perform side effects, e.g. asynchronous requests, watcher: js watch(id, (newId) => { fetch(`/api/${newId}`).then(() => { // callback logic }) }) id changes request completes? previous request completes, still fire callback ID value already stale. Ideally, want able cancel stale request id changes new value. use onWatcherCleanup() API register cleanup function called watcher invalidated re-run: js import { watch, onWatcherCleanup } 'vue' watch(id, (newId) => { const controller = new AbortController() fetch(`/api/${newId}`, { signal: controller.signal }).then(() => { // callback logic }) onWatcherCleanup(() => { // abort stale request controller.abort() }) }) Note onWatcherCleanup supported Vue 3.5+ must called synchronous execution watchEffect effect function watch callback function: cannot call await statement async function. Alternatively, onCleanup function also passed watcher callbacks 3rd argument, watchEffect effect function first argument: js watch(id, (newId, oldId, onCleanup) => { // ... onCleanup(() => { // cleanup logic }) }) watchEffect((onCleanup) => { // ... onCleanup(() => { // cleanup logic }) }) works versions 3.5. addition, onCleanup passed via function argument bound watcher instance subject synchronously constraint onWatcherCleanup . Callback Flush Timing mutate reactive state, may trigger Vue component updates watcher callbacks created you. Similar component updates, user-created watcher callbacks batched avoid duplicate invocations. example, probably want watcher fire thousand times synchronously push thousand items array watched. default, watcher's callback called parent component updates (if any), owner component's DOM updates. means attempt access owner component's DOM inside watcher callback, DOM pre-update state. Post Watchers want access owner component's DOM watcher callback Vue updated it, need specify flush: 'post' option: js watch(source, callback, { flush: 'post' }) watchEffect(callback, { flush: 'post' }) Post-flush watchEffect() also convenience alias, watchPostEffect() : js import { watchPostEffect } 'vue' watchPostEffect(() => { /* executed Vue updates */ }) Sync Watchers also possible create watcher fires synchronously, Vue-managed updates: js watch(source, callback, { flush: 'sync' }) watchEffect(callback, { flush: 'sync' }) Sync watchEffect() also convenience alias, watchSyncEffect() : js import { watchSyncEffect } 'vue' watchSyncEffect(() => { /* executed synchronously upon reactive data change */ }) Use Caution Sync watchers batching triggers every time reactive mutation detected. ok use watch simple boolean values, avoid using data sources might synchronously mutated many times, e.g. arrays. Stopping Watcher Watchers declared synchronously inside setup() <script setup> bound owner component instance, automatically stopped owner component unmounted. cases, need worry stopping watcher yourself. key watcher must created synchronously: watcher created async callback, bound owner component must stopped manually avoid memory leaks. Here's example: vue <script setup> import { watchEffect } 'vue' // one automatically stopped watchEffect(() => {}) // ...this one not! setTimeout(() => { watchEffect(() => {}) }, 100) </script> manually stop watcher, use returned handle function. works watch watchEffect : js const unwatch = watchEffect(() => {}) // ...later, longer needed unwatch() Note cases need create watchers asynchronously, synchronous creation preferred whenever possible. need wait async data, make watch logic conditional instead: js // data loaded asynchronously const data = ref(null) watchEffect(() => { (data.value) { // something data loaded } })"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Animation Techniques Vue provides <Transition> <TransitionGroup> components handling enter / leave list transitions. However, many ways using animations web, even Vue application. discuss additional techniques. Class-based Animations elements entering / leaving DOM, trigger animations dynamically adding CSS class: js const disabled = ref(false) function warnDisabled() { disabled.value = true setTimeout(() => { disabled.value = false }, 1500) } template <div :class=\"{ shake: disabled }\"> <button @click=\"warnDisabled\">Click me</button> <span v-if=\"disabled\">This feature disabled!</span> </div> css .shake { animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both; transform: translate3d(0, 0, 0); } @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } } State-driven Animations transition effects applied interpolating values, instance binding style element interaction occurs. Take example instance: js const x = ref(0) function onMousemove(e) { x.value = e.clientX } template <div @mousemove=\"onMousemove\" :style=\"{ backgroundColor: `hsl(${x}, 80%, 50%)` }\" class=\"movearea\" > <p>Move mouse across div...</p> <p>x: {{ x }}</p> </div> css .movearea { transition: 0.3s background-color ease; } Move mouse across div... x: 0 addition color, also use style bindings animate transform, width, height. even animate SVG paths using spring physics - all, attribute data bindings: Drag Animating Watchers creativity, use watchers animate anything based numerical state. example, animate number itself: js import { ref, reactive, watch } 'vue' import gsap 'gsap' const number = ref(0) const tweened = reactive({ number: 0 }) watch(number, (n) => { gsap.to(tweened, { duration: 0.5, number: Number(n) || 0 }) }) template Type number: <input v-model.number=\"number\" /> <p>{{ tweened.number.toFixed(0) }}</p> Type number: 0"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composition API FAQ TIP FAQ assumes prior experience Vue - particular, experience Vue 2 primarily using Options API. Composition API? Composition API set APIs allows us author Vue components using imported functions instead declaring options. umbrella term covers following APIs: Reactivity API, e.g. ref() andreactive() , allows us directly create reactive state, computed state, watchers.Lifecycle Hooks, e.g. onMounted() andonUnmounted() , allow us programmatically hook component lifecycle.Dependency Injection, i.e. provide() andinject() , allow us leverage Vue's dependency injection system using Reactivity APIs. Composition API built-in feature Vue 3 Vue 2.7. older Vue 2 versions, use officially maintained @vue/composition-api plugin. Vue 3, also primarily used together <script setup> syntax Single-File Components. Here's basic example component using Composition API: vue <script setup> import { ref, onMounted } 'vue' // reactive state const count = ref(0) // functions mutate state trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() => { console.log(`The initial count ${count.value}.`) }) </script> <template> <button @click=\"increment\">Count is: {{ count }}</button> </template> Despite API style based function composition, Composition API functional programming. Composition API based Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability. interested learning use Vue Composition API, set site-wide API preference Composition API using toggle top left sidebar, go guide beginning. Composition API? Better Logic Reuse primary advantage Composition API enables clean, efficient logic reuse form Composable functions. solves drawbacks mixins, primary logic reuse mechanism Options API. Composition API's logic reuse capability given rise impressive community projects VueUse, ever-growing collection composable utilities. also serves clean mechanism easily integrating stateful third-party services libraries Vue's reactivity system, example immutable data, state machines, RxJS. Flexible Code Organization Many users love write organized code default Options API: everything place based option falls under. However, Options API poses serious limitations single component's logic grows beyond certain complexity threshold. limitation particularly prominent components need deal multiple logical concerns, witnessed first hand many production Vue 2 apps. Take folder explorer component Vue CLI's GUI example: component responsible following logical concerns: - Tracking current folder state displaying content - Handling folder navigation (opening, closing, refreshing...) - Handling new folder creation - Toggling show favorite folders - Toggling show hidden folders - Handling current working directory changes original version component written Options API. give line code color based logical concern dealing with, looks: Notice code dealing logical concern forced split different options, located different parts file. component several hundred lines long, understanding navigating single logical concern requires constantly scrolling file, making much difficult be. addition, ever intend extract logical concern reusable utility, takes quite bit work find extract right pieces code different parts file. Here's component, refactor Composition API: Notice code related logical concern grouped together: longer need jump different options blocks working specific logical concern. Moreover, move group code external file minimal effort, since longer need shuffle code around order extract them. reduced friction refactoring key long-term maintainability large codebases. Better Type Inference recent years, frontend developers adopting TypeScript helps us write robust code, make changes confidence, provides great development experience IDE support. However, Options API, originally conceived 2013, designed without type inference mind. implement absurdly complex type gymnastics make type inference work Options API. Even effort, type inference Options API still break mixins dependency injection. led many developers wanted use Vue TS lean towards Class API powered vue-class-component . However, class-based API heavily relies ES decorators, language feature stage 2 proposal Vue 3 developed 2019. felt risky base official API unstable proposal. Since then, decorators proposal gone yet another complete overhaul, finally reached stage 3 2022. addition, class-based API suffers logic reuse organization limitations similar Options API. comparison, Composition API utilizes mostly plain variables functions, naturally type friendly. Code written Composition API enjoy full type inference little need manual type hints. time, Composition API code look largely identical TypeScript plain JavaScript. also makes possible plain JavaScript users benefit partial type inference. Smaller Production Bundle Less Overhead Code written Composition API <script setup> also efficient minification-friendly Options API equivalent. template <script setup> component compiled function inlined scope <script setup> code. Unlike property access , compiled template code directly access variables declared inside <script setup> , without instance proxy between. also leads better minification variable names safely shortened. Relationship Options API Trade-offs users moving Options API found Composition API code less organized, concluded Composition API \"worse\" terms code organization. recommend users opinions look problem different perspective. true Composition API longer provides \"guard rails\" guide put code respective buckets. return, get author component code like would write normal JavaScript. means apply code organization best practices Composition API code would writing normal JavaScript. write well-organized JavaScript, also able write well-organized Composition API code. Options API allow \"think less\" writing component code, many users love it. However, reducing mental overhead, also locks prescribed code organization pattern escape hatch, make difficult refactor improve code quality larger scale projects. regard, Composition API provides better long term scalability. Composition API cover use cases? Yes terms stateful logic. using Composition API, options may still needed: props , emits , name , inheritAttrs . TIP Since 3.3 directly use defineOptions <script setup> set component name inheritAttrs property intend exclusively use Composition API (along options listed above), shave kbs production bundle via compile-time flag drops Options API related code Vue. Note also affects Vue components dependencies. use APIs component? Yes. use Composition API via setup() option Options API component. However, recommend existing Options API codebase needs integrate new features / external libraries written Composition API. Options API deprecated? No, plan so. Options API integral part Vue reason many developers love it. also realize many benefits Composition API manifest larger-scale projects, Options API remains solid choice many low-to-medium-complexity scenarios. Relationship Class API longer recommend using Class API Vue 3, given Composition API provides great TypeScript integration additional logic reuse code organization benefits. Comparison React Hooks Composition API provides level logic composition capabilities React Hooks, important differences. React Hooks invoked repeatedly every time component updates. creates number caveats confuse even seasoned React developers. also leads performance optimization issues severely affect development experience. examples: Hooks call-order sensitive cannot conditional. Variables declared React component captured hook closure become \"stale\" developer fails pass correct dependencies array. leads React developers relying ESLint rules ensure correct dependencies passed. However, rule often smart enough over-compensates correctness, leads unnecessary invalidation headaches edge cases encountered. Expensive computations require use useMemo , requires manually passing correct dependencies array.Event handlers passed child components cause unnecessary child updates default, require explicit useCallback optimization. almost always needed, requires correct dependencies array. Neglecting leads over-rendering apps default cause performance issues without realizing it.The stale closure problem, combined Concurrent features, makes difficult reason piece hooks code run, makes working mutable state persist across renders (via useRef ) cumbersome. Note: issues related memoization resolved upcoming React Compiler. comparison, Vue Composition API: Invokes setup() or<script setup> code once. makes code align better intuitions idiomatic JavaScript usage stale closures worry about. Composition API calls also sensitive call order conditional.Vue's runtime reactivity system automatically collects reactive dependencies used computed properties watchers, there's need manually declare dependencies. need manually cache callback functions avoid unnecessary child updates. general, Vue's fine-grained reactivity system ensures child components update need to. Manual child-update optimizations rarely concern Vue developers. acknowledge creativity React Hooks, major source inspiration Composition API. However, issues mentioned exist design noticed Vue's reactivity model happens provide way around them."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity Depth One Vue\u2019s distinctive features unobtrusive reactivity system. Component state consists reactive JavaScript objects. modify them, view updates. makes state management simple intuitive, it\u2019s also important understand works avoid common gotchas. section, going dig lower-level details Vue\u2019s reactivity system. Reactivity? term comes programming quite bit days, people mean say it? Reactivity programming paradigm allows us adjust changes declarative manner. canonical example people usually show, it\u2019s great one, Excel spreadsheet: | | B | C | | |---|---|---|---| | 0 | 1 | || | 1 | 2 | || | 2 | 3 | cell A2 defined via formula = A0 + A1 (you click A2 view edit formula), spreadsheet gives us 3. surprises there. update A0 A1, notice A2 automagically updates too. JavaScript doesn\u2019t usually work like this. write something comparable JavaScript: js let A0 = 1 let A1 = 2 let A2 = A0 + A1 console.log(A2) // 3 A0 = 2 console.log(A2) // Still 3 mutate A0 , A2 change automatically. would JavaScript? First, order re-run code updates A2 , let's wrap function: js let A2 function update() { A2 = A0 + A1 } Then, need define terms: update() function produces side effect, effect short, modifies state program.A0 andA1 considered dependencies effect, values used perform effect. effect said subscriber dependencies. need magic function invoke update() (the effect) whenever A0 A1 (the dependencies) change: js whenDepsChange(update) whenDepsChange() function following tasks: Track variable read. E.g. evaluating expression A0 + A1 , bothA0 andA1 read.If variable read currently running effect, make effect subscriber variable. E.g. A0 andA1 read whenupdate() executed,update() becomes subscriber bothA0 andA1 first call.Detect variable mutated. E.g. A0 assigned new value, notify subscriber effects re-run. Reactivity Works Vue can't really track reading writing local variables like example. There's mechanism vanilla JavaScript. though, intercept reading writing object properties. two ways intercepting property access JavaScript: getter / setters Proxies. Vue 2 used getter / setters exclusively due browser support limitations. Vue 3, Proxies used reactive objects getter / setters used refs. Here's pseudo-code illustrates work: js function reactive(obj) { return new Proxy(obj, { get(target, key) { track(target, key) return target[key] }, set(target, key, value) { target[key] = value trigger(target, key) } }) } function ref(value) { const refObject = { get value() { track(refObject, 'value') return value }, set value(newValue) { value = newValue trigger(refObject, 'value') } } return refObject } TIP Code snippets meant explain core concepts simplest form possible, many details omitted, edge cases ignored. explains limitations reactive objects discussed fundamentals section: assign destructure reactive object's property local variable, accessing assigning variable non-reactive longer triggers get / set proxy traps source object. Note \"disconnect\" affects variable binding - variable points non-primitive value object, mutating object would still reactive. returned proxy reactive() , although behaving like original, different identity compare original using the=== operator. Inside track() , check whether currently running effect. one, lookup subscriber effects (stored Set) property tracked, add effect Set: js // set right effect // run. We'll deal later. let activeEffect function track(target, key) { (activeEffect) { const effects = getSubscribersForProperty(target, key) effects.add(activeEffect) } } Effect subscriptions stored global WeakMap<target, Map<key, Set<effect>>> data structure. subscribing effects Set found property (tracked first time), created. getSubscribersForProperty() function does, short. simplicity, skip details. Inside trigger() , lookup subscriber effects property. time invoke instead: js function trigger(target, key) { const effects = getSubscribersForProperty(target, key) effects.forEach((effect) => effect()) } let's circle back whenDepsChange() function: js function whenDepsChange(update) { const effect = () => { activeEffect = effect update() activeEffect = null } effect() } wraps raw update function effect sets current active effect running actual update. enables track() calls update locate current active effect. point, created effect automatically tracks dependencies, re-runs whenever dependency changes. call Reactive Effect. Vue provides API allows create reactive effects: watchEffect() . fact, may noticed works pretty similarly magical whenDepsChange() example. rework original example using actual Vue APIs: js import { ref, watchEffect } 'vue' const A0 = ref(0) const A1 = ref(1) const A2 = ref() watchEffect(() => { // tracks A0 A1 A2.value = A0.value + A1.value }) // triggers effect A0.value = 2 Using reactive effect mutate ref interesting use case - fact, using computed property makes declarative: js import { ref, computed } 'vue' const A0 = ref(0) const A1 = ref(1) const A2 = computed(() => A0.value + A1.value) A0.value = 2 Internally, computed manages invalidation re-computation using reactive effect. what's example common useful reactive effect? Well, updating DOM! implement simple \"reactive rendering\" like this: js import { ref, watchEffect } 'vue' const count = ref(0) watchEffect(() => { document.body.innerHTML = `Count is: ${count.value}` }) // updates DOM count.value++ fact, pretty close Vue component keeps state DOM sync - component instance creates reactive effect render update DOM. course, Vue components use much efficient ways update DOM innerHTML . discussed Rendering Mechanism. Runtime vs. Compile-time Reactivity Vue's reactivity system primarily runtime-based: tracking triggering performed code running directly browser. pros runtime reactivity work without build step, fewer edge cases. hand, makes constrained syntax limitations JavaScript, leading need value containers like Vue refs. frameworks, Svelte, choose overcome limitations implementing reactivity compilation. analyzes transforms code order simulate reactivity. compilation step allows framework alter semantics JavaScript - example, implicitly injecting code performs dependency analysis effect triggering around access locally defined variables. downside transforms require build step, altering JavaScript semantics essentially creating language looks like JavaScript compiles something else. Vue team explore direction via experimental feature called Reactivity Transform, end decided would good fit project due reasoning here. Reactivity Debugging great Vue's reactivity system automatically tracks dependencies, cases may want figure exactly tracked, causing component re-render. Component Debugging Hooks debug dependencies used component's render dependency triggering update using onRenderTracked onRenderTriggered lifecycle hooks. hooks receive debugger event contains information dependency question. recommended place debugger statement callbacks interactively inspect dependency: vue <script setup> import { onRenderTracked, onRenderTriggered } 'vue' onRenderTracked((event) => { debugger }) onRenderTriggered((event) => { debugger }) </script> TIP Component debug hooks work development mode. debug event objects following type: ts type DebuggerEvent = { effect: ReactiveEffect target: object type: | TrackOpTypes /* 'get' | 'has' | 'iterate' */ | TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */ key: newValue?: oldValue?: oldTarget?: Map<any, any> | Set<any> } Computed Debugging debug computed properties passing computed() second options object onTrack onTrigger callbacks: onTrack called reactive property ref tracked dependency.onTrigger called watcher callback triggered mutation dependency. callbacks receive debugger events format component debug hooks: js const plusOne = computed(() => count.value + 1, { onTrack(e) { // triggered count.value tracked dependency debugger }, onTrigger(e) { // triggered count.value mutated debugger } }) // access plusOne, trigger onTrack console.log(plusOne.value) // mutate count.value, trigger onTrigger count.value++ TIP onTrack onTrigger computed options work development mode. Watcher Debugging Similar computed() , watchers also support onTrack onTrigger options: js watch(source, callback, { onTrack(e) { debugger }, onTrigger(e) { debugger } }) watchEffect(callback, { onTrack(e) { debugger }, onTrigger(e) { debugger } }) TIP onTrack onTrigger watcher options work development mode. Integration External State Systems Vue's reactivity system works deeply converting plain JavaScript objects reactive proxies. deep conversion unnecessary sometimes unwanted integrating external state management systems (e.g. external solution also uses Proxies). general idea integrating Vue's reactivity system external state management solution hold external state shallowRef . shallow ref reactive .value property accessed - inner value left intact. external state changes, replace ref value trigger updates. Immutable Data implementing undo / redo feature, likely want take snapshot application's state every user edit. However, Vue's mutable reactivity system best suited state tree large, serializing entire state object every update expensive terms CPU memory costs. Immutable data structures solve never mutating state objects - instead, creates new objects share same, unchanged parts old ones. different ways using immutable data JavaScript, recommend using Immer Vue allows use immutable data keeping ergonomic, mutable syntax. integrate Immer Vue via simple composable: js import { produce } 'immer' import { shallowRef } 'vue' export function useImmer(baseState) { const state = shallowRef(baseState) const update = (updater) => { state.value = produce(state.value, updater) } return [state, update] } State Machines State Machine model describing possible states application in, possible ways transition one state another. may overkill simple components, help make complex state flows robust manageable. One popular state machine implementations JavaScript XState. Here's composable integrates it: js import { createMachine, interpret } 'xstate' import { shallowRef } 'vue' export function useMachine(options) { const machine = createMachine(options) const state = shallowRef(machine.initialState) const service = interpret(machine) .onTransition((newState) => (state.value = newState)) .start() const send = (event) => service.send(event) return [state, send] } RxJS RxJS library working asynchronous event streams. VueUse library provides @vueuse/rxjs add-on connecting RxJS streams Vue's reactivity system. Connection Signals Quite frameworks introduced reactivity primitives similar refs Vue's Composition API, term \"signals\": Fundamentally, signals kind reactivity primitive Vue refs. value container provides dependency tracking access, side-effect triggering mutation. reactivity-primitive-based paradigm particularly new concept frontend world: dates back implementations like Knockout observables Meteor Tracker decade ago. Vue Options API React state management library MobX also based principles, hide primitives behind object properties. Although necessary trait something qualify signals, today concept often discussed alongside rendering model updates performed fine-grained subscriptions. Due use Virtual DOM, Vue currently relies compilers achieve similar optimizations. However, also exploring new Solid-inspired compilation strategy, called Vapor Mode, rely Virtual DOM takes advantage Vue's built-in reactivity system. API Design Trade-Offs design Preact Qwik's signals similar Vue's shallowRef: three provide mutable interface via .value property. focus discussion Solid Angular signals. Solid Signals Solid's createSignal() API design emphasizes read / write segregation. Signals exposed read-only getter separate setter: js const [count, setCount] = createSignal(0) count() // access value setCount(1) // update value Notice count signal passed without setter. ensures state never mutated unless setter also explicitly exposed. Whether safety guarantee justifies verbose syntax could subject requirement project personal taste - case prefer API style, easily replicate Vue: js import { shallowRef, triggerRef } 'vue' export function createSignal(value, options) { const r = shallowRef(value) const get = () => r.value const set = (v) => { r.value = typeof v === 'function' ? v(r.value) : v (options?.equals === false) triggerRef(r) } return [get, set] } Angular Signals Angular undergoing fundamental changes foregoing dirty-checking introducing implementation reactivity primitive. Angular Signal API looks like this: js const count = signal(0) count() // access value count.set(1) // set new value count.update((v) => v + 1) // update based previous value Again, easily replicate API Vue: js import { shallowRef } 'vue' export function signal(initialValue) { const r = shallowRef(initialValue) const = () => r.value s.set = (value) => { r.value = value } s.update = (updater) => { r.value = updater(r.value) } return } Compared Vue refs, Solid Angular's getter-based API style provide interesting trade-offs used Vue components: () slightly less verbose than.value , updating value verbose.- ref-unwrapping: accessing values always require () . makes value access consistent everywhere. also means pass raw signals component props. Whether API styles suit extent subjective. goal demonstrate underlying similarity trade-offs different API designs. also want show Vue flexible: really locked existing APIs. necessary, create reactivity primitive API suit specific needs."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Reactivity Transform Removed Experimental Feature Reactivity Transform experimental feature, removed latest 3.4 release. Please read reasoning here. still intend use it, available via Vue Macros plugin. Composition-API-specific Reactivity Transform Composition-API-specific feature requires build step. Refs vs. Reactive Variables Ever since introduction Composition API, one primary unresolved questions use refs vs. reactive objects. easy lose reactivity destructuring reactive objects, cumbersome use .value everywhere using refs. Also, .value easy miss using type system. Vue Reactivity Transform compile-time transform allows us write code like this: vue <script setup> let count = $ref(0) console.log(count) function increment() { count++ } </script> <template> <button @click=\"increment\">{{ count }}</button> </template> $ref() method compile-time macro: actual method called runtime. Instead, Vue compiler uses hint treat resulting count variable reactive variable. Reactive variables accessed re-assigned like normal variables, operations compiled refs .value . example, <script> part component compiled into: js import { ref } 'vue' let count = ref(0) console.log(count.value) function increment() { count.value++ } Every reactivity API returns refs $ -prefixed macro equivalent. APIs include: ref ->$ref computed ->$computed shallowRef ->$shallowRef customRef ->$customRef toRef ->$toRef macros globally available need imported Reactivity Transform enabled, optionally import vue/macros want explicit: js import { $ref } 'vue/macros' let count = $ref(0) Destructuring $() common composition function return object refs, use destructuring retrieve refs. purpose, reactivity transform provides $() macro: js import { useMouse } '@vueuse/core' const { x, } = $(useMouse()) console.log(x, y) Compiled output: js import { toRef } 'vue' import { useMouse } '@vueuse/core' const __temp = useMouse(), x = toRef(__temp, 'x'), = toRef(__temp, 'y') console.log(x.value, y.value) Note x already ref, toRef(__temp, 'x') simply return as-is additional ref created. destructured value ref (e.g. function), still work - value wrapped ref rest code works expected. $() destructure works reactive objects plain objects containing refs. Convert Existing Refs Reactive Variables $() cases may wrapped functions also return refs. However, Vue compiler able know ahead time function going return ref. cases, $() macro also used convert existing refs reactive variables: js function myCreateRef() { return ref(0) } let count = $(myCreateRef()) Reactive Props Destructure two pain points current defineProps() usage <script setup> : Similar .value , need always access props asprops.x order retain reactivity. means cannot destructuredefineProps resulting destructured variables reactive update.When using type-only props declaration, easy way declare default values props. introduced withDefaults() API exact purpose, still clunky use. address issues applying compile-time transform defineProps used destructuring, similar saw earlier $() : html <script setup lang=\"ts\"> interface Props { msg: string count?: number foo?: string } const { msg, // default value works count = 1, // local aliasing also works // aliasing `props.foo` `bar` foo: bar } = defineProps<Props>() watchEffect(() => { // log whenever props change console.log(msg, count, bar) }) </script> compiled following runtime declaration equivalent: js export default { props: { msg: { type: String, required: true }, count: { type: Number, default: 1 }, foo: String }, setup(props) { watchEffect(() => { console.log(props.msg, props.count, props.foo) }) } } Retaining Reactivity Across Function Boundaries reactive variables relieve us use .value everywhere, creates issue \"reactivity loss\" pass reactive variables across function boundaries. happen two cases: Passing function argument Given function expects ref argument, e.g.: ts function trackChange(x: Ref<number>) { watch(x, (x) => { console.log('x changed!') }) } let count = $ref(0) trackChange(count) // work! case work expected compiles to: ts let count = ref(0) trackChange(count.value) count.value passed number, whereas trackChange expects actual ref. fixed wrapping count $$() passing it: diff let count = $ref(0) - trackChange(count) + trackChange($$(count)) compiles to: js import { ref } 'vue' let count = ref(0) trackChange(count) see, $$() macro serves escape hint: reactive variables inside $$() get .value appended. Returning inside function scope Reactivity also lost reactive variables used directly returned expression: ts function useMouse() { let x = $ref(0) let = $ref(0) // listen mousemove... // work! return { x, } } return statement compiles to: ts return { x: x.value, y: y.value } order retain reactivity, returning actual refs, current value return time. Again, use $$() fix this. case, $$() used directly returned object - reference reactive variables inside $$() call retain reference underlying refs: ts function useMouse() { let x = $ref(0) let = $ref(0) // listen mousemove... // fixed return $$({ x, }) } Using $$() destructured props $$() works destructured props since reactive variables well. compiler convert toRef efficiency: ts const { count } = defineProps<{ count: number }>() passAsRef($$(count)) compiles to: js setup(props) { const __props_count = toRef(props, 'count') passAsRef(__props_count) } TypeScript Integration Vue provides typings macros (available globally) types work expected. incompatibilities standard TypeScript semantics, syntax work existing tooling. also means macros work files valid JS / TS allowed - inside Vue SFCs. Since macros available globally, types need explicitly referenced (e.g. env.d.ts file): ts /// <reference types=\"vue/macros-global\" /> explicitly importing macros vue/macros , type work without declaring globals. Explicit Opt-in longer supported core following applies Vue version 3.3 below. Support removed Vue core 3.4 above, @vitejs/plugin-vue 5.0 above. intend continue using transform, please migrate Vue Macros instead. Vite - Requires @vitejs/plugin-vue@>=2.0.0 - Applies SFCs js(x)/ts(x) files. fast usage check performed files applying transform performance cost files using macros. - Note reactivityTransform plugin root-level option instead nested asscript.refSugar , since affects SFCs. js // vite.config.js export default { plugins: [ vue({ reactivityTransform: true }) ] } vue-cli - Currently affects SFCs - Requires vue-loader@>=17.0.0 js // vue.config.js module.exports = { chainWebpack: (config) => { config.module .rule('vue') .use('vue-loader') .tap((options) => { return { ...options, reactivityTransform: true } }) } } Plain webpack + vue-loader - Currently affects SFCs - Requires vue-loader@>=17.0.0 js // webpack.config.js module.exports = { module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: { reactivityTransform: true } } ] } }"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Render Functions & JSX Vue recommends using templates build applications vast majority cases. However, situations need full programmatic power JavaScript. That's use render function. new concept virtual DOM render functions, make sure read Rendering Mechanism chapter first. Basic Usage Creating Vnodes Vue provides h() function creating vnodes: js import { h } 'vue' const vnode = h( 'div', // type { id: 'foo', class: 'bar' }, // props [ /* children */ ] ) h() short hyperscript - means \"JavaScript produces HTML (hypertext markup language)\". name inherited conventions shared many virtual DOM implementations. descriptive name could createVNode() , shorter name helps call function many times render function. h() function designed flexible: js // arguments except type optional h('div') h('div', { id: 'foo' }) // attributes properties used props // Vue automatically picks right way assign h('div', { class: 'bar', innerHTML: 'hello' }) // props modifiers `.prop` `.attr` added // `.` `^` prefixes respectively h('div', { '.name': 'some-name', '^width': '100' }) // class style object / array // value support templates h('div', { class: [foo, { bar }], style: { color: 'red' } }) // event listeners passed onXxx h('div', { onClick: () => {} }) // children string h('div', { id: 'foo' }, 'hello') // props omitted props h('div', 'hello') h('div', [h('span', 'hello')]) // children array contain mixed vnodes strings h('div', ['hello', h('span', 'hello')]) resulting vnode following shape: js const vnode = h('div', { id: 'foo' }, []) vnode.type // 'div' vnode.props // { id: 'foo' } vnode.children // [] vnode.key // null Note full VNode interface contains many internal properties, strongly recommended avoid relying properties ones listed here. avoids unintended breakage case internal properties changed. Declaring Render Functions using templates Composition API, return value setup() hook used expose data template. using render functions, however, directly return render function instead: js import { ref, h } 'vue' export default { props: { /* ... */ }, setup(props) { const count = ref(1) // return render function return () => h('div', props.msg + count.value) } } render function declared inside setup() naturally access props reactive state declared scope. addition returning single vnode, also return strings arrays: js export default { setup() { return () => 'hello world!' } } js import { h } 'vue' export default { setup() { // use array return multiple root nodes return () => [ h('div'), h('div'), h('div') ] } } TIP Make sure return function instead directly returning values! setup() function called per component, returned render function called multiple times. render function component need instance state, also declared directly function brevity: js function Hello() { return 'hello world!' } That's right, valid Vue component! See Functional Components details syntax. Vnodes Must Unique vnodes component tree must unique. means following render function invalid: js function render() { const p = h('p', 'hi') return h('div', [ // Yikes - duplicate vnodes! p, p ]) } really want duplicate element/component many times, factory function. example, following render function perfectly valid way rendering 20 identical paragraphs: js function render() { return h( 'div', Array.from({ length: 20 }).map(() => { return h('p', 'hi') }) ) } JSX / TSX JSX XML-like extension JavaScript allows us write code like this: jsx const vnode = <div>hello</div> Inside JSX expressions, use curly braces embed dynamic values: jsx const vnode = <div id={dynamicId}>hello, {userName}</div> create-vue Vue CLI options scaffolding projects pre-configured JSX support. configuring JSX manually, please refer documentation @vue/babel-plugin-jsx details. Although first introduced React, JSX actually defined runtime semantics compiled various different outputs. worked JSX before, note Vue JSX transform different React's JSX transform, can't use React's JSX transform Vue applications. notable differences React JSX include: - use HTML attributes class andfor props - need useclassName orhtmlFor . - Passing children components (i.e. slots) works differently. Vue's type definition also provides type inference TSX usage. using TSX, make sure specify \"jsx\": \"preserve\" tsconfig.json TypeScript leaves JSX syntax intact Vue JSX transform process. JSX Type Inference Similar transform, Vue's JSX also needs different type definitions. Starting Vue 3.4, Vue longer implicitly registers global JSX namespace. instruct TypeScript use Vue's JSX type definitions, make sure include following tsconfig.json : json { \"compilerOptions\": { \"jsx\": \"preserve\", \"jsxImportSource\": \"vue\" // ... } } also opt-in per file adding /* @jsxImportSource vue */ comment top file. code depends presence global JSX namespace, retain exact pre-3.4 global behavior explicitly importing referencing vue/jsx project, registers global JSX namespace. Render Function Recipes provide common recipes implementing template features equivalent render functions / JSX. v-if Template: template <div> <div v-if=\"ok\">yes</div> <span v-else>no</span> </div> Equivalent render function / JSX: js h('div', [ok.value ? h('div', 'yes') : h('span', 'no')]) jsx <div>{ok.value ? <div>yes</div> : <span>no</span>}</div> v-for Template: template <ul> <li v-for=\"{ id, text } items\" :key=\"id\"> {{ text }} </li> </ul> Equivalent render function / JSX: js h( 'ul', // assuming `items` ref array value items.value.map(({ id, text }) => { return h('li', { key: id }, text) }) ) jsx <ul> {items.value.map(({ id, text }) => { return <li key={id}>{text}</li> })} </ul> v-on Props names start followed uppercase letter treated event listeners. example, onClick equivalent @click templates. js h( 'button', { onClick(event) { /* ... */ } }, 'Click Me' ) jsx <button onClick={(event) => { /* ... */ }} > Click </button> Event Modifiers .passive , .capture , .once event modifiers, concatenated event name using camelCase. example: js h('input', { onClickCapture() { /* listener capture mode */ }, onKeyupOnce() { /* triggers */ }, onMouseoverOnceCapture() { /* + capture */ } }) jsx <input onClickCapture={() => {}} onKeyupOnce={() => {}} onMouseoverOnceCapture={() => {}} /> event key modifiers, withModifiers helper used: js import { withModifiers } 'vue' h('div', { onClick: withModifiers(() => {}, ['self']) }) jsx <div onClick={withModifiers(() => {}, ['self'])} /> Components create vnode component, first argument passed h() component definition. means using render functions, unnecessary register components - use imported components directly: js import Foo './Foo.vue' import Bar './Bar.jsx' function render() { return h('div', [h(Foo), h(Bar)]) } jsx function render() { return ( <div> <Foo /> <Bar /> </div> ) } see, h work components imported file format long valid Vue component. Dynamic components straightforward render functions: js import Foo './Foo.vue' import Bar './Bar.jsx' function render() { return ok.value ? h(Foo) : h(Bar) } jsx function render() { return ok.value ? <Foo /> : <Bar /> } component registered name cannot imported directly (for example, globally registered library), programmatically resolved using resolveComponent() helper. Rendering Slots render functions, slots accessed setup() context. slot slots object function returns array vnodes: js export default { props: ['message'], setup(props, { slots }) { return () => [ // default slot: // <div><slot /></div> h('div', slots.default()), // named slot: // <div><slot name=\"footer\" :text=\"message\" /></div> h( 'div', slots.footer({ text: props.message }) ) ] } } JSX equivalent: jsx // default <div>{slots.default()}</div> // named <div>{slots.footer({ text: props.message })}</div> Passing Slots Passing children components works bit differently passing children elements. Instead array, need pass either slot function, object slot functions. Slot functions return anything normal render function return - always normalized arrays vnodes accessed child component. js // single default slot h(MyComponent, () => 'hello') // named slots // notice `null` required avoid // slots object treated props h(MyComponent, null, { default: () => 'default slot', foo: () => h('div', 'foo'), bar: () => [h('span', 'one'), h('span', 'two')] }) JSX equivalent: jsx // default <MyComponent>{() => 'hello'}</MyComponent> // named <MyComponent>{{ default: () => 'default slot', foo: () => <div>foo</div>, bar: () => [<span>one</span>, <span>two</span>] }}</MyComponent> Passing slots functions allows invoked lazily child component. leads slot's dependencies tracked child instead parent, results accurate efficient updates. Scoped Slots render scoped slot parent component, slot passed child. Notice slot parameter text . slot called child component data child component passed parent component. js // parent component export default { setup() { return () => h(MyComp, null, { default: ({ text }) => h('p', text) }) } } Remember pass null slots treated props. js // child component export default { setup(props, { slots }) { const text = ref('hi') return () => h('div', null, slots.default({ text: text.value })) } } JSX equivalent: jsx <MyComponent>{{ default: ({ text }) => <p>{ text }</p> }}</MyComponent> Built-in Components Built-in components <KeepAlive> , <Transition> , <TransitionGroup> , <Teleport> <Suspense> must imported use render functions: js import { h, KeepAlive, Teleport, Transition, TransitionGroup } 'vue' export default { setup () { return () => h(Transition, { mode: 'out-in' }, /* ... */) } } v-model v-model directive expanded modelValue onUpdate:modelValue props template compilation\u2014we provide props ourselves: js export default { props: ['modelValue'], emits: ['update:modelValue'], setup(props, { emit }) { return () => h(SomeComponent, { modelValue: props.modelValue, 'onUpdate:modelValue': (value) => emit('update:modelValue', value) }) } } Custom Directives Custom directives applied vnode using withDirectives : js import { h, withDirectives } 'vue' // custom directive const pin = { mounted() { /* ... */ }, updated() { /* ... */ } } // <div v-pin:top.animate=\"200\"></div> const vnode = withDirectives(h('div'), [ [pin, 200, 'top', { animate: true }] ]) directive registered name cannot imported directly, resolved using resolveDirective helper. Template Refs Composition API, template refs created passing ref() prop vnode: js import { h, ref } 'vue' export default { setup() { const divEl = ref() // <div ref=\"divEl\"> return () => h('div', { ref: divEl }) } } Functional Components Functional components alternative form component state own. act like pure functions: props in, vnodes out. rendered without creating component instance (i.e. ), without usual component lifecycle hooks. create functional component use plain function, rather options object. function effectively render function component. signature functional component setup() hook: js function MyComponent(props, { slots, emit, attrs }) { // ... } usual configuration options components available functional components. However, possible define props emits adding properties: js MyComponent.props = ['value'] MyComponent.emits = ['click'] props option specified, props object passed function contain attributes, attrs . prop names normalized camelCase unless props option specified. functional components explicit props , attribute fallthrough works much normal components. However, functional components explicitly specify props , class , style , onXxx event listeners inherited attrs default. either case, inheritAttrs set false disable attribute inheritance: js MyComponent.inheritAttrs = false Functional components registered consumed like normal components. pass function first argument h() , treated functional component. Typing Functional Components Functional Components typed based whether named anonymous. Vue - Official extension also supports type checking properly typed functional components consuming SFC templates. Named Functional Component tsx import type { SetupContext } 'vue' type FComponentProps = { message: string } type Events = { sendMessage(message: string): void } function FComponent( props: FComponentProps, context: SetupContext<Events> ) { return ( <button onClick={() => context.emit('sendMessage', props.message)}> {props.message} {' '} </button> ) } FComponent.props = { message: { type: String, required: true } } FComponent.emits = { sendMessage: (value: unknown) => typeof value === 'string' } Anonymous Functional Component tsx import type { FunctionalComponent } 'vue' type FComponentProps = { message: string } type Events = { sendMessage(message: string): void } const FComponent: FunctionalComponent<FComponentProps, Events> = ( props, context ) => { return ( <button onClick={() => context.emit('sendMessage', props.message)}> {props.message} {' '} </button> ) } FComponent.props = { message: { type: String, required: true } } FComponent.emits = { sendMessage: (value) => typeof value === 'string' }"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Rendering Mechanism Vue take template turn actual DOM nodes? Vue update DOM nodes efficiently? attempt shed light questions diving Vue's internal rendering mechanism. Virtual DOM probably heard term \"virtual DOM\", Vue's rendering system based upon. virtual DOM (VDOM) programming concept ideal, \u201cvirtual\u201d, representation UI kept memory synced \u201creal\u201d DOM. concept pioneered React, adopted many frameworks different implementations, including Vue. Virtual DOM pattern specific technology, one canonical implementation. illustrate idea using simple example: js const vnode = { type: 'div', props: { id: 'hello' }, children: [ /* vnodes */ ] } Here, vnode plain JavaScript object (a \"virtual node\") representing <div> element. contains information need create actual element. also contains children vnodes, makes root virtual DOM tree. runtime renderer walk virtual DOM tree construct real DOM tree it. process called mount. two copies virtual DOM trees, renderer also walk compare two trees, figuring differences, apply changes actual DOM. process called patch, also known \"diffing\" \"reconciliation\". main benefit virtual DOM gives developer ability programmatically create, inspect compose desired UI structures declarative way, leaving direct DOM manipulation renderer. Render Pipeline high level, happens Vue component mounted: Compile: Vue templates compiled render functions: functions return virtual DOM trees. step done either ahead-of-time via build step, on-the-fly using runtime compiler. Mount: runtime renderer invokes render functions, walks returned virtual DOM tree, creates actual DOM nodes based it. step performed reactive effect, keeps track reactive dependencies used. Patch: dependency used mount changes, effect re-runs. time, new, updated Virtual DOM tree created. runtime renderer walks new tree, compares old one, applies necessary updates actual DOM. Templates vs. Render Functions Vue templates compiled virtual DOM render functions. Vue also provides APIs allow us skip template compilation step directly author render functions. Render functions flexible templates dealing highly dynamic logic, work vnodes using full power JavaScript. Vue recommend templates default? number reasons: Templates closer actual HTML. makes easier reuse existing HTML snippets, apply accessibility best practices, style CSS, designers understand modify. Templates easier statically analyze due deterministic syntax. allows Vue's template compiler apply many compile-time optimizations improve performance virtual DOM (which discuss below). practice, templates sufficient use cases applications. Render functions typically used reusable components need deal highly dynamic rendering logic. Render function usage discussed detail Render Functions & JSX. Compiler-Informed Virtual DOM virtual DOM implementation React virtual-DOM implementations purely runtime: reconciliation algorithm cannot make assumptions incoming virtual DOM tree, fully traverse tree diff props every vnode order ensure correctness. addition, even part tree never changes, new vnodes always created re-render, resulting unnecessary memory pressure. one criticized aspect virtual DOM: somewhat brute-force reconciliation process sacrifices efficiency return declarativeness correctness. way. Vue, framework controls compiler runtime. allows us implement many compile-time optimizations tightly-coupled renderer take advantage of. compiler statically analyze template leave hints generated code runtime take shortcuts whenever possible. time, still preserve capability user drop render function layer direct control edge cases. call hybrid approach Compiler-Informed Virtual DOM. Below, discuss major optimizations done Vue template compiler improve virtual DOM's runtime performance. Static Hoisting Quite often parts template contain dynamic bindings: template <div> <div>foo</div> <!-- hoisted --> <div>bar</div> <!-- hoisted --> <div>{{ dynamic }}</div> </div> foo bar divs static - re-creating vnodes diffing re-render unnecessary. Vue compiler automatically hoists vnode creation calls render function, reuses vnodes every render. renderer also able completely skip diffing notices old vnode new vnode one. addition, enough consecutive static elements, condensed single \"static vnode\" contains plain HTML string nodes (Example). static vnodes mounted directly setting innerHTML . also cache corresponding DOM nodes initial mount - piece content reused elsewhere app, new DOM nodes created using native cloneNode() , extremely efficient. Patch Flags single element dynamic bindings, also infer lot information compile time: template <!-- class binding --> <div :class=\"{ active }\"></div> <!-- id value bindings --> <input :id=\"id\" :value=\"value\"> <!-- text children --> <div>{{ dynamic }}</div> generating render function code elements, Vue encodes type update needs directly vnode creation call: js createElementVNode(\"div\", { class: _normalizeClass({ active: _ctx.active }) }, null, 2 /* CLASS */) last argument, 2 , patch flag. element multiple patch flags, merged single number. runtime renderer check flags using bitwise operations determine whether needs certain work: js (vnode.patchFlag & PatchFlags.CLASS /* 2 */) { // update element's class } Bitwise checks extremely fast. patch flags, Vue able least amount work necessary updating elements dynamic bindings. Vue also encodes type children vnode has. example, template multiple root nodes represented fragment. cases, know sure order root nodes never change, information also provided runtime patch flag: js export function render() { return (_openBlock(), _createElementBlock(_Fragment, null, [ /* children */ ], 64 /* STABLE_FRAGMENT */)) } runtime thus completely skip child-order reconciliation root fragment. Tree Flattening Taking another look generated code previous example, notice root returned virtual DOM tree created using special createElementBlock() call: js export function render() { return (_openBlock(), _createElementBlock(_Fragment, null, [ /* children */ ], 64 /* STABLE_FRAGMENT */)) } Conceptually, \"block\" part template stable inner structure. case, entire template single block contain structural directives like v-if v-for . block tracks descendant nodes (not direct children) patch flags. example: template <div> <!-- root block --> <div>...</div> <!-- tracked --> <div :id=\"id\"></div> <!-- tracked --> <div> <!-- tracked --> <div>{{ bar }}</div> <!-- tracked --> </div> </div> result flattened array contains dynamic descendant nodes: div (block root) - div :id binding - div {{ bar }} binding component needs re-render, needs traverse flattened tree instead full tree. called Tree Flattening, greatly reduces number nodes need traversed virtual DOM reconciliation. static parts template effectively skipped. v-if v-for directives create new block nodes: template <div> <!-- root block --> <div> <div v-if> <!-- block --> ... </div> </div> </div> child block tracked inside parent block's array dynamic descendants. retains stable structure parent block. Impact SSR Hydration patch flags tree flattening also greatly improve Vue's SSR Hydration performance: Single element hydration take fast paths based corresponding vnode's patch flag. block nodes dynamic descendants need traversed hydration, effectively achieving partial hydration template level."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Ways Using Vue believe \"one size fits all\" story web. Vue designed flexible incrementally adoptable. Depending use case, Vue used different ways strike optimal balance stack complexity, developer experience end performance. Standalone Script Vue used standalone script file - build step required! backend framework already rendering HTML, frontend logic complex enough justify build step, easiest way integrate Vue stack. think Vue declarative replacement jQuery cases. Vue also provides alternative distribution called petite-vue specifically optimized progressively enhancing existing HTML. smaller feature set, extremely lightweight uses implementation efficient no-build-step scenarios. Embedded Web Components use Vue build standard Web Components embedded HTML page, regardless rendered. option allows leverage Vue completely consumer-agnostic fashion: resulting web components embedded legacy applications, static HTML, even applications built frameworks. Single-Page Application (SPA) applications require rich interactivity, deep session depth, non-trivial stateful logic frontend. best way build applications use architecture Vue controls entire page, also handles data updates navigation without reload page. type application typically referred Single-Page Application (SPA). Vue provides core libraries comprehensive tooling support amazing developer experience building modern SPAs, including: - Client-side router - Blazing fast build tool chain - IDE support - Browser devtools - TypeScript integrations - Testing utilities SPAs typically require backend expose API endpoints - also pair Vue solutions like Inertia.js get SPA benefits retaining server-centric development model. Fullstack / SSR Pure client-side SPAs problematic app sensitive SEO time-to-content. browser receive largely empty HTML page, wait JavaScript loaded rendering anything. Vue provides first-class APIs \"render\" Vue app HTML strings server. allows server send back already-rendered HTML, allowing end users see content immediately JavaScript downloaded. Vue \"hydrate\" application client side make interactive. called Server-Side Rendering (SSR) greatly improves Core Web Vital metrics Largest Contentful Paint (LCP). higher-level Vue-based frameworks built top paradigm, Nuxt, allow develop fullstack application using Vue JavaScript. JAMStack / SSG Server-side rendering done ahead time required data static. means pre-render entire application HTML serve static files. improves site performance makes deployment lot simpler since longer need dynamically render pages request. Vue still hydrate applications provide rich interactivity client. technique commonly referred Static-Site Generation (SSG), also known JAMStack. two flavors SSG: single-page multi-page. flavors pre-render site static HTML, difference that: initial page load, single-page SSG \"hydrates\" page SPA. requires upfront JS payload hydration cost, subsequent navigations faster, since needs partially update page content instead reloading entire page. multi-page SSG loads new page every navigation. upside ship minimal JS - JS page requires interaction! multi-page SSG frameworks Astro also support \"partial hydration\" - allows use Vue components create interactive \"islands\" inside static HTML. Single-page SSGs better suited expect non-trivial interactivity, deep session lengths, persisted elements / state across navigations. Otherwise, multi-page SSG would better choice. Vue team also maintains static-site generator called VitePress, powers website reading right now! VitePress supports flavors SSG. Nuxt also supports SSG. even mix SSR SSG different routes Nuxt app. Beyond Web Although Vue primarily designed building web applications, means limited browser. can: - Build desktop apps Electron - Build mobile apps Ionic Vue - Build desktop mobile apps codebase Quasar Tauri - Build 3D WebGL experiences TresJS - Use Vue's Custom Renderer API build custom renderers, like terminal!"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Vue Web Components Web Components umbrella term set web native APIs allows developers create reusable custom elements. consider Vue Web Components primarily complementary technologies. Vue excellent support consuming creating custom elements. Whether integrating custom elements existing Vue application, using Vue build distribute custom elements, good company. Using Custom Elements Vue Vue scores perfect 100% Custom Elements Everywhere tests. Consuming custom elements inside Vue application largely works using native HTML elements, things keep mind: Skipping Component Resolution default, Vue attempt resolve non-native HTML tag registered Vue component falling back rendering custom element. cause Vue emit \"failed resolve component\" warning development. let Vue know certain elements treated custom elements skip component resolution, specify compilerOptions.isCustomElement option. using Vue build setup, option passed via build configs since compile-time option. Example In-Browser Config js // works using in-browser compilation. // using build tools, see config examples below. app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-') Example Vite Config js // vite.config.js import vue '@vitejs/plugin-vue' export default { plugins: [ vue({ template: { compilerOptions: { // treat tags dash custom elements isCustomElement: (tag) => tag.includes('-') } } }) ] } Example Vue CLI Config js // vue.config.js module.exports = { chainWebpack: (config) => { config.module .rule('vue') .use('vue-loader') .tap((options) => ({ ...options, compilerOptions: { // treat tag starts ion- custom elements isCustomElement: (tag) => tag.startsWith('ion-') } })) } } Passing DOM Properties Since DOM attributes strings, need pass complex data custom elements DOM properties. setting props custom element, Vue 3 automatically checks DOM-property presence using operator prefer setting value DOM property key present. means that, cases, need think custom element follows recommended best practices. However, could rare cases data must passed DOM property, custom element properly define/reflect property (causing check fail). case, force v-bind binding set DOM property using .prop modifier: template <my-element :user.prop=\"{ name: 'jack' }\"></my-element> <!-- shorthand equivalent --> <my-element .user=\"{ name: 'jack' }\"></my-element> Building Custom Elements Vue primary benefit custom elements used framework, even without framework. makes ideal distributing components end consumer may using frontend stack, want insulate end application implementation details components uses. defineCustomElement Vue supports creating custom elements using exactly Vue component APIs via defineCustomElement method. method accepts argument defineComponent , instead returns custom element constructor extends HTMLElement : template <my-vue-element></my-vue-element> js import { defineCustomElement } 'vue' const MyVueElement = defineCustomElement({ // normal Vue component options props: {}, emits: {}, template: `...`, // defineCustomElement only: CSS injected shadow root styles: [`/* inlined css */`] }) // Register custom element. // registration, `<my-vue-element>` tags // page upgraded. customElements.define('my-vue-element', MyVueElement) // also programmatically instantiate element: // (can done registration) document.body.appendChild( new MyVueElement({ // initial props (optional) }) ) Lifecycle Vue custom element mount internal Vue component instance inside shadow root element's connectedCallback called first time.When element's disconnectedCallback invoked, Vue check whether element detached document microtask tick.If element still document, move component instance preserved; element detached document, removal component instance unmounted. Props props declared using props option defined custom element properties. Vue automatically handle reflection attributes / properties appropriate.Attributes always reflected corresponding properties. Properties primitive values ( string ,boolean ornumber ) reflected attributes. Vue also automatically casts props declared Boolean orNumber types desired type set attributes (which always strings). example, given following props declaration:jsprops: { selected: Boolean, index: Number } custom element usage: template<my-element selected index=\"1\"></my-element> component, selected cast totrue (boolean) andindex cast to1 (number). Events Events emitted via this.$emit setup emit dispatched native CustomEvents custom element. Additional event arguments (payload) exposed array CustomEvent object detail property. Slots Inside component, slots rendered using <slot/> element usual. However, consuming resulting element, accepts native slots syntax: Scoped slots supported. passing named slots, use slot attribute instead thev-slot directive:template<my-element> <div slot=\"named\">hello</div> </my-element> Provide / Inject Provide / Inject API Composition API equivalent also work Vue-defined custom elements. However, note works custom elements. i.e. Vue-defined custom element able inject properties provided non-custom-element Vue component. App Level Config configure app instance Vue custom element using configureApp option: js defineCustomElement(MyComponent, { configureApp(app) { app.config.errorHandler = (err) => { /* ... */ } } }) SFC Custom Element defineCustomElement also works Vue Single-File Components (SFCs). However, default tooling setup, <style> inside SFCs still extracted merged single CSS file production build. using SFC custom element, often desirable inject <style> tags custom element's shadow root instead. official SFC toolings support importing SFCs \"custom element mode\" (requires @vitejs/plugin-vue@^1.4.0 vue-loader@^16.5.0 ). SFC loaded custom element mode inlines <style> tags strings CSS exposes component's styles option. picked defineCustomElement injected element's shadow root instantiated. opt-in mode, simply end component file name .ce.vue : js import { defineCustomElement } 'vue' import Example './Example.ce.vue' console.log(Example.styles) // [\"/* inlined css */\"] // convert custom element constructor const ExampleElement = defineCustomElement(Example) // register customElements.define('my-example', ExampleElement) wish customize files imported custom element mode (for example, treating SFCs custom elements), pass customElement option respective build plugins: Tips Vue Custom Elements Library building custom elements Vue, elements rely Vue's runtime. ~16kb baseline size cost depending many features used. means ideal use Vue shipping single custom element - may want use vanilla JavaScript, petite-vue, frameworks specialize small runtime size. However, base size justifiable shipping collection custom elements complex logic, Vue allow component authored much less code. elements shipping together, better trade-off. custom elements used application also using Vue, choose externalize Vue built bundle elements using copy Vue host application. recommended export individual element constructors give users flexibility import on-demand register desired tag names. also export convenience function automatically register elements. Here's example entry point Vue custom element library: js // elements.js import { defineCustomElement } 'vue' import Foo './MyFoo.ce.vue' import Bar './MyBar.ce.vue' const MyFoo = defineCustomElement(Foo) const MyBar = defineCustomElement(Bar) // export individual elements export { MyFoo, MyBar } export function register() { customElements.define('my-foo', MyFoo) customElements.define('my-bar', MyBar) } consumer use elements Vue file: vue <script setup> import { register } 'path/to/elements.js' register() </script> <template> <my-foo ...> <my-bar ...></my-bar> </my-foo> </template> framework one JSX, custom names: jsx import { MyFoo, MyBar } 'path/to/elements.js' customElements.define('some-foo', MyFoo) customElements.define('some-bar', MyBar) export function MyComponent() { return <> <some-foo ... > <some-bar ... ></some-bar> </some-foo> </> } Vue-based Web Components TypeScript writing Vue SFC templates, may want type check Vue components, including defined custom elements. Custom elements registered globally browsers using built-in APIs, default type inference used Vue templates. provide type support Vue components registered custom elements, register global component typings augmenting GlobalComponents interface type checking Vue templates (JSX users augment JSX.IntrinsicElements type instead, shown here). define type custom element made Vue: typescript import { defineCustomElement } 'vue' // Import Vue component. import SomeComponent './src/components/SomeComponent.ce.vue' // Turn Vue component Custom Element class. export const SomeElement = defineCustomElement(SomeComponent) // Remember register element class browser. customElements.define('some-element', SomeElement) // Add new element type Vue's GlobalComponents type. declare module 'vue' { interface GlobalComponents { // sure pass Vue component type // (SomeComponent, *not* SomeElement). // Custom Elements require hyphen name, // use hyphenated element name here. 'some-element': typeof SomeComponent } } Non-Vue Web Components TypeScript recommended way enable type checking SFC templates Custom Elements built Vue. NOTE approach one possible way it, may vary depending framework used create custom elements. Suppose custom element JS properties events defined, shipped library called some-lib : ts // file: some-lib/src/SomeElement.ts // Define class typed JS properties. export class SomeElement extends HTMLElement { foo: number = 123 bar: string = 'blah' lorem: boolean = false // method exposed template types. someMethod() { /* ... */ } // ... implementation details omitted ... // ... assume element dispatches events named \"apple-fell\" ... } customElements.define('some-element', SomeElement) // list properties SomeElement selected type // checking framework templates (f.e. Vue SFC templates). // properties exposed. export type SomeElementAttributes = 'foo' | 'bar' // Define event types SomeElement dispatches. export type SomeElementEvents = { 'apple-fell': AppleFellEvent } export class AppleFellEvent extends Event { /* ... details omitted ... */ } implementation details omitted, important part type definitions two things: prop types event types. Let's create type helper easily registering custom element type definitions Vue: ts // file: some-lib/src/DefineCustomElement.ts // re-use type helper per element need define. type DefineCustomElement< ElementType extends HTMLElement, Events extends EventMap = {}, SelectedAttributes extends keyof ElementType = keyof ElementType > = new () => ElementType & { // Use $props define properties exposed template type checking. Vue // specifically reads prop definitions `$props` type. Note // combine element's props global HTML props Vue's special // props. /** @deprecated use $props property Custom Element ref, template prop types only. */ $props: HTMLAttributes & Partial<Pick<ElementType, SelectedAttributes>> & PublicProps // Use $emit specifically define event types. Vue specifically reads event // types `$emit` type. Note `$emit` expects particular format // map `Events` to. /** @deprecated use $emit property Custom Element ref, template prop types only. */ $emit: VueEmit<Events> } type EventMap = { [event: string]: Event } // maps EventMap format Vue's $emit type expects. type VueEmit<T extends EventMap> = EmitFn<{ [K keyof T]: (event: T[K]) => void }> NOTE marked $props $emit deprecated get ref custom element tempted use properties, properties type checking purposes comes custom elements. properties actually exist custom element instances. Using type helper select JS properties exposed type checking Vue templates: ts // file: some-lib/src/SomeElement.vue.ts import { SomeElement, SomeElementAttributes, SomeElementEvents } './SomeElement.js' import type { Component } 'vue' import type { DefineCustomElement } './DefineCustomElement' // Add new element type Vue's GlobalComponents type. declare module 'vue' { interface GlobalComponents { 'some-element': DefineCustomElement< SomeElement, SomeElementAttributes, SomeElementEvents > } } Suppose some-lib builds source TypeScript files dist/ folder. user some-lib import SomeElement use Vue SFC like so: vue <script setup lang=\"ts\"> // create register element browser. import 'some-lib/dist/SomeElement.js' // user using TypeScript Vue additionally import // Vue-specific type definition (users frameworks may import // framework-specific type definitions). import type {} 'some-lib/dist/SomeElement.vue.js' import { useTemplateRef, onMounted } 'vue' const el = useTemplateRef('el') onMounted(() => { console.log( el.value!.foo, el.value!.bar, el.value!.lorem, el.value!.someMethod() ) // use props, `undefined` // IDE show crossed el.$props el.$emit }) </script> <template> <!-- use element, type checking: --> <some-element ref=\"el\" :foo=\"456\" :blah=\"'hello'\" @apple-fell=\" (event) => { // type `event` inferred `AppleFellEvent` } \" ></some-element> </template> element type definitions, types properties events defined manual fashion: vue <script setup lang=\"ts\"> // Suppose `some-lib` plain JS without type definitions, TypeScript // cannot infer types: import { SomeElement } 'some-lib' // We'll use type helper before. import { DefineCustomElement } './DefineCustomElement' type SomeElementProps = { foo?: number; bar?: string } type SomeElementEvents = { 'apple-fell': AppleFellEvent } interface AppleFellEvent extends Event { /* ... */ } // Add new element type Vue's GlobalComponents type. declare module 'vue' { interface GlobalComponents { 'some-element': DefineCustomElement< SomeElementProps, SomeElementEvents > } } // ... before, use reference element ... </script> <template> <!-- ... before, use element template ... --> </template> Custom Element authors automatically export framework-specific custom element type definitions libraries, example export index.ts file also exports rest library, otherwise users unexpected module augmentation errors. Users import framework-specific type definition file need. Web Components vs. Vue Components developers believe framework-proprietary component models avoided, exclusively using Custom Elements makes application \"future-proof\". try explain believe overly simplistic take problem. indeed certain level feature overlap Custom Elements Vue Components: allow us define reusable components data passing, event emitting, lifecycle management. However, Web Components APIs relatively low-level bare-bones. build actual application, need quite additional capabilities platform cover: declarative efficient templating system; reactive state management system facilitates cross-component logic extraction reuse; performant way render components server hydrate client (SSR), important SEO Web Vitals metrics LCP. Native custom elements SSR typically involves simulating DOM Node.js serializing mutated DOM, Vue SSR compiles string concatenation whenever possible, much efficient. Vue's component model designed needs mind coherent system. competent engineering team, could probably build equivalent top native Custom Elements - also means taking long-term maintenance burden in-house framework, losing ecosystem community benefits mature framework like Vue. also frameworks built using Custom Elements basis component model, inevitably introduce proprietary solutions problems listed above. Using frameworks entails buying technical decisions solve problems - which, despite may advertised, automatically insulate potential future churns. also areas find custom elements limiting: Eager slot evaluation hinders component composition. Vue's scoped slots powerful mechanism component composition, can't supported custom elements due native slots' eager nature. Eager slots also mean receiving component cannot control whether render piece slot content. Shipping custom elements shadow DOM scoped CSS today requires embedding CSS inside JavaScript injected shadow roots runtime. also result duplicated styles markup SSR scenarios. platform features worked area - yet universally supported, still production performance / SSR concerns addressed. meanwhile, Vue SFCs provide CSS scoping mechanisms support extracting styles plain CSS files. Vue always stay date latest standards web platform, happily leverage whatever platform provides makes job easier. However, goal provide solutions work well work today. means incorporate new platform features critical mindset - involves filling gaps standards fall short still case."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Introduction reading documentation Vue 3! - Vue 2 support ended Dec 31, 2023. Learn Vue 2 EOL. - Upgrading Vue 2? Check Migration Guide. Vue? Vue (pronounced /vju\u02d0/, like view) JavaScript framework building user interfaces. builds top standard HTML, CSS, JavaScript provides declarative, component-based programming model helps efficiently develop user interfaces complexity. minimal example: js import { createApp, ref } 'vue' createApp({ setup() { return { count: ref(0) } } }).mount('#app') template <div id=\"app\"> <button @click=\"count++\"> Count is: {{ count }} </button> </div> Result example demonstrates two core features Vue: Declarative Rendering: Vue extends standard HTML template syntax allows us declaratively describe HTML output based JavaScript state. Reactivity: Vue automatically tracks JavaScript state changes efficiently updates DOM changes happen. may already questions - worry. cover every little detail rest documentation. now, please read along high-level understanding Vue offers. Prerequisites rest documentation assumes basic familiarity HTML, CSS, JavaScript. totally new frontend development, might best idea jump right framework first step - grasp basics come back! check knowledge level overviews JavaScript, HTML CSS needed. Prior experience frameworks helps, required. Progressive Framework Vue framework ecosystem covers common features needed frontend development. web extremely diverse - things build web may vary drastically form scale. mind, Vue designed flexible incrementally adoptable. Depending use case, Vue used different ways: - Enhancing static HTML without build step - Embedding Web Components page - Single-Page Application (SPA) - Fullstack / Server-Side Rendering (SSR) - Jamstack / Static Site Generation (SSG) - Targeting desktop, mobile, WebGL, even terminal find concepts intimidating, worry! tutorial guide require basic HTML JavaScript knowledge, able follow along without expert these. experienced developer interested best integrate Vue stack, curious terms mean, discuss detail Ways Using Vue. Despite flexibility, core knowledge Vue works shared across use cases. Even beginner now, knowledge gained along way stay useful grow tackle ambitious goals future. veteran, pick optimal way leverage Vue based problems trying solve, retaining productivity. call Vue \"The Progressive Framework\": framework grow adapt needs. Single-File Components build-tool-enabled Vue projects, author Vue components using HTML-like file format called Single-File Component (also known *.vue files, abbreviated SFC). Vue SFC, name suggests, encapsulates component's logic (JavaScript), template (HTML), styles (CSS) single file. Here's previous example, written SFC format: vue <script setup> import { ref } 'vue' const count = ref(0) </script> <template> <button @click=\"count++\">Count is: {{ count }}</button> </template> <style scoped> button { font-weight: bold; } </style> SFC defining feature Vue recommended way author Vue components use case warrants build setup. learn SFC dedicated section - now, know Vue handle build tools setup you. API Styles Vue components authored two different API styles: Options API Composition API. Options API Options API, define component's logic using object options data , methods , mounted . Properties defined options exposed inside functions, points component instance: vue <script> export default { // Properties returned data() become reactive state // exposed `this`. data() { return { count: 0 } }, // Methods functions mutate state trigger updates. // bound event handlers templates. methods: { increment() { this.count++ } }, // Lifecycle hooks called different stages // component's lifecycle. // function called component mounted. mounted() { console.log(`The initial count ${this.count}.`) } } </script> <template> <button @click=\"increment\">Count is: {{ count }}</button> </template> Composition API Composition API, define component's logic using imported API functions. SFCs, Composition API typically used <script setup> . setup attribute hint makes Vue perform compile-time transforms allow us use Composition API less boilerplate. example, imports top-level variables / functions declared <script setup> directly usable template. component, exact template, using Composition API <script setup> instead: vue <script setup> import { ref, onMounted } 'vue' // reactive state const count = ref(0) // functions mutate state trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() => { console.log(`The initial count ${count.value}.`) }) </script> <template> <button @click=\"increment\">Count is: {{ count }}</button> </template> Choose? API styles fully capable covering common use cases. different interfaces powered exact underlying system. fact, Options API implemented top Composition API! fundamental concepts knowledge Vue shared across two styles. Options API centered around concept \"component instance\" (this seen example), typically aligns better class-based mental model users coming OOP language backgrounds. also beginner-friendly abstracting away reactivity details enforcing code organization via option groups. Composition API centered around declaring reactive state variables directly function scope composing state multiple functions together handle complexity. free-form requires understanding reactivity works Vue used effectively. return, flexibility enables powerful patterns organizing reusing logic. learn comparison two styles potential benefits Composition API Composition API FAQ. new Vue, here's general recommendation: learning purposes, go style looks easier understand you. Again, core concepts shared two styles. always pick style later. production use: Go Options API using build tools, plan use Vue primarily low-complexity scenarios, e.g. progressive enhancement. Go Composition API + Single-File Components plan build full applications Vue. commit one style learning phase. rest documentation provide code samples styles applicable, toggle time using API Preference switches top left sidebar. Still Got Questions? Check FAQ. Pick Learning Path Different developers different learning styles. Feel free pick learning path suits preference - although recommend going content, possible!"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Quick Start Try Vue Online quickly get taste Vue, try directly Playground. prefer plain HTML setup without build steps, use JSFiddle starting point. already familiar Node.js concept build tools, also try complete build setup right within browser StackBlitz. Creating Vue Application Prerequisites - Familiarity command line - Install Node.js version 18.3 higher section introduce scaffold Vue Single Page Application local machine. created project using build setup based Vite allow us use Vue Single-File Components (SFCs). Make sure up-to-date version Node.js installed current working directory one intend create project. Run following command command line (without $ sign): npm pnpm yarn bun sh $ npm create vue@latest command install execute create-vue, official Vue project scaffolding tool. presented prompts several optional features TypeScript testing support: \u2714 Project name: \u2026 <your-project-name> \u2714 Add TypeScript? \u2026 / Yes \u2714 Add JSX Support? \u2026 / Yes \u2714 Add Vue Router Single Page Application development? \u2026 / Yes \u2714 Add Pinia state management? \u2026 / Yes \u2714 Add Vitest Unit testing? \u2026 / Yes \u2714 Add End-to-End Testing Solution? \u2026 / Cypress / Nightwatch / Playwright \u2714 Add ESLint code quality? \u2026 / Yes \u2714 Add Prettier code formatting? \u2026 / Yes \u2714 Add Vue DevTools 7 extension debugging? (experimental) \u2026 / Yes Scaffolding project ./<your-project-name>... Done. unsure option, simply choose hitting enter now. project created, follow instructions install dependencies start dev server: npm pnpm yarn bun sh $ cd <your-project-name> $ npm install $ npm run dev first Vue project running! Note example components generated project written using Composition API <script setup> , rather Options API. additional tips: - recommended IDE setup Visual Studio Code + Vue - Official extension. use editors, check IDE support section. - tooling details, including integration backend frameworks, discussed Tooling Guide. - learn underlying build tool Vite, check Vite docs. - choose use TypeScript, check TypeScript Usage Guide. ready ship app production, run following: npm pnpm yarn bun sh $ npm run build create production-ready build app project's ./dist directory. Check Production Deployment Guide learn shipping app production. Using Vue CDN use Vue directly CDN via script tag: html <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> using unpkg, also use CDN serves npm packages, example jsdelivr cdnjs. course, also download file serve yourself. using Vue CDN, \"build step\" involved. makes setup lot simpler, suitable enhancing static HTML integrating backend framework. However, able use Single-File Component (SFC) syntax. Using Global Build link loads global build Vue, top-level APIs exposed properties global Vue object. full example using global build: html <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <div id=\"app\">{{ message }}</div> <script> const { createApp, ref } = Vue createApp({ setup() { const message = ref('Hello vue!') return { message } } }).mount('#app') </script> TIP Many examples Composition API throughout guide using <script setup> syntax, requires build tools. intend use Composition API without build step, consult usage setup() option. Using ES Module Build Throughout rest documentation, primarily using ES modules syntax. modern browsers support ES modules natively, use Vue CDN via native ES modules like this: html <div id=\"app\">{{ message }}</div> <script type=\"module\"> import { createApp, ref } 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' createApp({ setup() { const message = ref('Hello Vue!') return { message } } }).mount('#app') </script> Notice using <script type=\"module\"> , imported CDN URL pointing ES modules build Vue instead. Enabling Import maps example, importing full CDN URL, rest documentation see code like this: js import { createApp } 'vue' teach browser locate vue import using Import Maps: html <script type=\"importmap\"> { \"imports\": { \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\" } } </script> <div id=\"app\">{{ message }}</div> <script type=\"module\"> import { createApp, ref } 'vue' createApp({ setup() { const message = ref('Hello Vue!') return { message } } }).mount('#app') </script> also add entries dependencies import map - make sure point ES modules version library intend use. Import Maps Browser Support Import Maps relatively new browser feature. Make sure use browser within support range. particular, supported Safari 16.4+. Notes Production Use examples far using development build Vue - intend use Vue CDN production, make sure check Production Deployment Guide. possible use Vue without build system, alternative approach consider using vuejs/petite-vue could better suit context jquery/jquery (in past) alpinejs/alpine (in present) might used instead. Splitting Modules dive deeper guide, may need split code separate JavaScript files easier manage. example: html <!-- index.html --> <div id=\"app\"></div> <script type=\"module\"> import { createApp } 'vue' import MyComponent './my-component.js' createApp(MyComponent).mount('#app') </script> js // my-component.js import { ref } 'vue' export default { setup() { const count = ref(0) return { count } }, template: `<div>Count is: {{ count }}</div>` } directly open index.html browser, find throws error ES modules cannot work file:// protocol, protocol browser uses open local file. Due security reasons, ES modules work http:// protocol, browsers use opening pages web. order ES modules work local machine, need serve index.html http:// protocol, local HTTP server. start local HTTP server, first make sure Node.js installed, run npx serve command line directory HTML file is. also use HTTP server serve static files correct MIME types. may noticed imported component's template inlined JavaScript string. using VS Code, install es6-string-html extension prefix strings /*html*/ comment get syntax highlighting them. Next Steps skipped Introduction, strongly recommend reading moving rest documentation."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Composables TIP section assumes basic knowledge Composition API. learning Vue Options API only, set API Preference Composition API (using toggle top left sidebar) re-read Reactivity Fundamentals Lifecycle Hooks chapters. \"Composable\"? context Vue applications, \"composable\" function leverages Vue's Composition API encapsulate reuse stateful logic. building frontend applications, often need reuse logic common tasks. example, may need format dates many places, extract reusable function that. formatter function encapsulates stateless logic: takes input immediately returns expected output. many libraries reusing stateless logic - example lodash date-fns, may heard of. contrast, stateful logic involves managing state changes time. simple example would tracking current position mouse page. real-world scenarios, could also complex logic touch gestures connection status database. Mouse Tracker Example implement mouse tracking functionality using Composition API directly inside component, would look like this: vue <script setup> import { ref, onMounted, onUnmounted } 'vue' const x = ref(0) const = ref(0) function update(event) { x.value = event.pageX y.value = event.pageY } onMounted(() => window.addEventListener('mousemove', update)) onUnmounted(() => window.removeEventListener('mousemove', update)) </script> <template>Mouse position at: {{ x }}, {{ }}</template> want reuse logic multiple components? extract logic external file, composable function: js // mouse.js import { ref, onMounted, onUnmounted } 'vue' // convention, composable function names start \"use\" export function useMouse() { // state encapsulated managed composable const x = ref(0) const = ref(0) // composable update managed state time. function update(event) { x.value = event.pageX y.value = event.pageY } // composable also hook owner component's // lifecycle setup teardown side effects. onMounted(() => window.addEventListener('mousemove', update)) onUnmounted(() => window.removeEventListener('mousemove', update)) // expose managed state return value return { x, } } used components: vue <script setup> import { useMouse } './mouse.js' const { x, } = useMouse() </script> <template>Mouse position at: {{ x }}, {{ }}</template> Mouse position at: 0, 0 see, core logic remains identical - move external function return state exposed. like inside component, use full range Composition API functions composables. useMouse() functionality used component. cooler part composables though, also nest them: one composable function call one composable functions. enables us compose complex logic using small, isolated units, similar compose entire application using components. fact, decided call collection APIs make pattern possible Composition API. example, extract logic adding removing DOM event listener composable: js // event.js import { onMounted, onUnmounted } 'vue' export function useEventListener(target, event, callback) { // want, also make // support selector strings target onMounted(() => target.addEventListener(event, callback)) onUnmounted(() => target.removeEventListener(event, callback)) } useMouse() composable simplified to: js // mouse.js import { ref } 'vue' import { useEventListener } './event' export function useMouse() { const x = ref(0) const = ref(0) useEventListener(window, 'mousemove', (event) => { x.value = event.pageX y.value = event.pageY }) return { x, } } TIP component instance calling useMouse() create copies x state interfere one another. want manage shared state components, read State Management chapter. Async State Example useMouse() composable take arguments, let's take look another example makes use one. async data fetching, often need handle different states: loading, success, error: vue <script setup> import { ref } 'vue' const data = ref(null) const error = ref(null) fetch('...') .then((res) => res.json()) .then((json) => (data.value = json)) .catch((err) => (error.value = err)) </script> <template> <div v-if=\"error\">Oops! Error encountered: {{ error.message }}</div> <div v-else-if=\"data\"> Data loaded: <pre>{{ data }}</pre> </div> <div v-else>Loading...</div> </template> would tedious repeat pattern every component needs fetch data. Let's extract composable: js // fetch.js import { ref } 'vue' export function useFetch(url) { const data = ref(null) const error = ref(null) fetch(url) .then((res) => res.json()) .then((json) => (data.value = json)) .catch((err) => (error.value = err)) return { data, error } } component do: vue <script setup> import { useFetch } './fetch.js' const { data, error } = useFetch('...') </script> Accepting Reactive State useFetch() takes static URL string input - performs fetch done. want re-fetch whenever URL changes? order achieve this, need pass reactive state composable function, let composable create watchers perform actions using passed state. example, useFetch() able accept ref: js const url = ref('/initial-url') const { data, error } = useFetch(url) // trigger re-fetch url.value = '/new-url' Or, accept getter function: js // re-fetch props.id changes const { data, error } = useFetch(() => `/posts/${props.id}`) refactor existing implementation watchEffect() toValue() APIs: js // fetch.js import { ref, watchEffect, toValue } 'vue' export function useFetch(url) { const data = ref(null) const error = ref(null) const fetchData = () => { // reset state fetching.. data.value = null error.value = null fetch(toValue(url)) .then((res) => res.json()) .then((json) => (data.value = json)) .catch((err) => (error.value = err)) } watchEffect(() => { fetchData() }) return { data, error } } toValue() API added 3.3. designed normalize refs getters values. argument ref, returns ref's value; argument function, call function return return value. Otherwise, returns argument as-is. works similarly unref() , special treatment functions. Notice toValue(url) called inside watchEffect callback. ensures reactive dependencies accessed toValue() normalization tracked watcher. version useFetch() accepts static URL strings, refs, getters, making much flexible. watch effect run immediately, track dependencies accessed toValue(url) . dependencies tracked (e.g. url already string), effect runs once; otherwise, re-run whenever tracked dependency changes. Here's updated version useFetch() , artificial delay randomized error demo purposes. Conventions Best Practices Naming convention name composable functions camelCase names start \"use\". Input Arguments composable accept ref getter arguments even rely reactivity. writing composable may used developers, good idea handle case input arguments refs getters instead raw values. toValue() utility function come handy purpose: js import { toValue } 'vue' function useFeature(maybeRefOrGetter) { // maybeRefOrGetter ref getter, // normalized value returned. // Otherwise, returned as-is. const value = toValue(maybeRefOrGetter) } composable creates reactive effects input ref getter, make sure either explicitly watch ref / getter watch() , call toValue() inside watchEffect() properly tracked. useFetch() implementation discussed earlier provides concrete example composable accepts refs, getters plain values input argument. Return Values probably noticed exclusively using ref() instead reactive() composables. recommended convention composables always return plain, non-reactive object containing multiple refs. allows destructured components retaining reactivity: js // x refs const { x, } = useMouse() Returning reactive object composable cause destructures lose reactivity connection state inside composable, refs retain connection. prefer use returned state composables object properties, wrap returned object reactive() refs unwrapped. example: js const mouse = reactive(useMouse()) // mouse.x linked original ref console.log(mouse.x) template Mouse position at: {{ mouse.x }}, {{ mouse.y }} Side Effects OK perform side effects (e.g. adding DOM event listeners fetching data) composables, pay attention following rules: working application uses Server-Side Rendering (SSR), make sure perform DOM-specific side effects post-mount lifecycle hooks, e.g. onMounted() . hooks called browser, sure code inside access DOM.Remember clean side effects onUnmounted() . example, composable sets DOM event listener, remove listener inonUnmounted() seen theuseMouse() example. good idea use composable automatically you, like theuseEventListener() example. Usage Restrictions Composables called <script setup> setup() hook. also called synchronously contexts. cases, also call lifecycle hooks like onMounted() . restrictions important contexts Vue able determine current active component instance. Access active component instance necessary that: Lifecycle hooks registered it. Computed properties watchers linked it, disposed instance unmounted prevent memory leaks. TIP <script setup> place call composables using await . compiler automatically restores active instance context async operation. Extracting Composables Code Organization Composables extracted reuse, also code organization. complexity components grow, may end components large navigate reason about. Composition API gives full flexibility organize component code smaller functions based logical concerns: vue <script setup> import { useFeatureA } './featureA.js' import { useFeatureB } './featureB.js' import { useFeatureC } './featureC.js' const { foo, bar } = useFeatureA() const { baz } = useFeatureB(foo) const { qux } = useFeatureC(baz) </script> extent, think extracted composables component-scoped services talk one another. Using Composables Options API using Options API, composables must called inside setup() , returned bindings must returned setup() exposed template: js import { useMouse } './mouse.js' import { useFetch } './fetch.js' export default { setup() { const { x, } = useMouse() const { data, error } = useFetch('...') return { x, y, data, error } }, mounted() { // setup() exposed properties accessed `this` console.log(this.x) } // ...other options } Comparisons Techniques vs. Mixins Users coming Vue 2 may familiar mixins option, also allows us extract component logic reusable units. three primary drawbacks mixins: Unclear source properties: using many mixins, becomes unclear instance property injected mixin, making difficult trace implementation understand component's behavior. also recommend using refs + destructure pattern composables: makes property source clear consuming components. Namespace collisions: multiple mixins different authors potentially register property keys, causing namespace collisions. composables, rename destructured variables conflicting keys different composables. Implicit cross-mixin communication: multiple mixins need interact one another rely shared property keys, making implicitly coupled. composables, values returned one composable passed another arguments, like normal functions. reasons, longer recommend using mixins Vue 3. feature kept migration familiarity reasons. vs. Renderless Components component slots chapter, discussed Renderless Component pattern based scoped slots. even implemented mouse tracking demo using renderless components. main advantage composables renderless components composables incur extra component instance overhead. used across entire application, amount extra component instances created renderless component pattern become noticeable performance overhead. recommendation use composables reusing pure logic, use components reusing logic visual layout. vs. React Hooks experience React, may notice looks similar custom React hooks. Composition API part inspired React hooks, Vue composables indeed similar React hooks terms logic composition capabilities. However, Vue composables based Vue's fine-grained reactivity system, fundamentally different React hooks' execution model. discussed detail Composition API FAQ. Reading - Reactivity Depth: low-level understanding Vue's reactivity system works. - State Management: patterns managing state shared multiple components. - Testing Composables: tips unit testing composables. - VueUse: ever-growing collection Vue composables. source code also great learning resource."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Custom Directives Introduction addition default set directives shipped core (like v-model v-show ), Vue also allows register custom directives. introduced two forms code reuse Vue: components composables. Components main building blocks, composables focused reusing stateful logic. Custom directives, hand, mainly intended reusing logic involves low-level DOM access plain elements. custom directive defined object containing lifecycle hooks similar component. hooks receive element directive bound to. example directive adds class element inserted DOM Vue: vue <script setup> // enables v-highlight templates const vHighlight = { mounted: (el) => { el.classList.add('is-highlight') } } </script> <template> <p v-highlight>This sentence important!</p> </template> sentence important! <script setup> , camelCase variable starts v prefix used custom directive. example above, vHighlight used template v-highlight . using <script setup> , custom directives registered using directives option: js export default { setup() { /*...*/ }, directives: { // enables v-highlight template highlight: { /* ... */ } } } also common globally register custom directives app level: js const app = createApp({}) // make v-highlight usable components app.directive('highlight', { /* ... */ }) use custom directives Custom directives used desired functionality achieved via direct DOM manipulation. common example v-focus custom directive brings element focus. vue <script setup> // enables v-focus templates const vFocus = { mounted: (el) => el.focus() } </script> <template> <input v-focus /> </template> directive useful autofocus attribute works page load - also works element dynamically inserted Vue! Declarative templating built-in directives v-bind recommended possible efficient server-rendering friendly. Directive Hooks directive definition object provide several hook functions (all optional): js const myDirective = { // called bound element's attributes // event listeners applied created(el, binding, vnode) { // see details arguments }, // called right element inserted DOM. beforeMount(el, binding, vnode) {}, // called bound element's parent component // children mounted. mounted(el, binding, vnode) {}, // called parent component updated beforeUpdate(el, binding, vnode, prevVnode) {}, // called parent component // children updated updated(el, binding, vnode, prevVnode) {}, // called parent component unmounted beforeUnmount(el, binding, vnode) {}, // called parent component unmounted unmounted(el, binding, vnode) {} } Hook Arguments Directive hooks passed arguments: el : element directive bound to. used directly manipulate DOM.binding : object containing following properties.value : value passed directive. example inv-my-directive=\"1 + 1\" , value would be2 .oldValue : previous value, available inbeforeUpdate andupdated . available whether value changed.arg : argument passed directive, any. example inv-my-directive:foo , arg would be\"foo\" .modifiers : object containing modifiers, any. example inv-my-directive.foo.bar , modifiers object would be{ foo: true, bar: true } .instance : instance component directive used.dir : directive definition object. vnode : underlying VNode representing bound element.prevVnode : VNode representing bound element previous render. available thebeforeUpdate andupdated hooks. example, consider following directive usage: template <div v-example:foo.bar=\"baz\"> binding argument would object shape of: js { arg: 'foo', modifiers: { bar: true }, value: /* value `baz` */, oldValue: /* value `baz` previous update */ } Similar built-in directives, custom directive arguments dynamic. example: template <div v-example:[arg]=\"value\"></div> directive argument reactively updated based arg property component state. Note Apart el , treat arguments read-only never modify them. need share information across hooks, recommended element's dataset. Function Shorthand common custom directive behavior mounted updated , need hooks. cases define directive function: template <div v-color=\"color\"></div> js app.directive('color', (el, binding) => { // called `mounted` `updated` el.style.color = binding.value }) Object Literals directive needs multiple values, also pass JavaScript object literal. Remember, directives take valid JavaScript expression. template <div v-demo=\"{ color: 'white', text: 'hello!' }\"></div> js app.directive('demo', (el, binding) => { console.log(binding.value.color) // => \"white\" console.log(binding.value.text) // => \"hello!\" }) Usage Components recommended Using custom directives components recommended. Unexpected behaviour may occur component multiple root nodes. used components, custom directives always apply component's root node, similar Fallthrough Attributes. template <MyComponent v-demo=\"test\" /> template <!-- template MyComponent --> <div> <!-- v-demo directive applied --> <span>My component content</span> </div> Note components potentially one root node. applied multi-root component, directive ignored warning thrown. Unlike attributes, directives can't passed different element v-bind=\"$attrs\" ."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Plugins Introduction Plugins self-contained code usually add app-level functionality Vue. install plugin: js import { createApp } 'vue' const app = createApp({}) app.use(myPlugin, { /* optional options */ }) plugin defined either object exposes install() method, simply function acts install function itself. install function receives app instance along additional options passed app.use() , any: js const myPlugin = { install(app, options) { // configure app } } strictly defined scope plugin, common scenarios plugins useful include: Register one global components custom directives app.component() andapp.directive() .Make resource injectable throughout app calling app.provide() .Add global instance properties methods attaching app.config.globalProperties .A library needs perform combination (e.g. vue-router). Writing Plugin order better understand create Vue.js plugins, create simplified version plugin displays i18n (short Internationalization) strings. Let's begin setting plugin object. recommended create separate file export it, shown keep logic contained separate. js // plugins/i18n.js export default { install: (app, options) => { // Plugin code goes } } want create translation function. function receive dot-delimited key string, use look translated string user-provided options. intended usage templates: template <h1>{{ $translate('greetings.hello') }}</h1> Since function globally available templates, make attaching app.config.globalProperties plugin: js // plugins/i18n.js export default { install: (app, options) => { // inject globally available $translate() method app.config.globalProperties.$translate = (key) => { // retrieve nested property `options` // using `key` path return key.split('.').reduce((o, i) => { (o) return o[i] }, options) } } } $translate function take string greetings.hello , look inside user provided configuration return translated value. object containing translated keys passed plugin installation via additional parameters app.use() : js import i18nPlugin './plugins/i18n' app.use(i18nPlugin, { greetings: { hello: 'Bonjour!' } }) Now, initial expression $translate('greetings.hello') replaced Bonjour! runtime. See also: Augmenting Global Properties TIP Use global properties scarcely, since quickly become confusing many global properties injected different plugins used throughout app. Provide / Inject Plugins Plugins also allow us use inject provide function attribute plugin's users. example, allow application access options parameter able use translations object. js // plugins/i18n.js export default { install: (app, options) => { app.provide('i18n', options) } } Plugin users able inject plugin options components using i18n key: vue <script setup> import { inject } 'vue' const i18n = inject('i18n') console.log(i18n.greetings.hello) </script> Bundle NPM want build publish plugin others use, see Vite's section Library Mode."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Routing Client-Side vs. Server-Side Routing Routing server side means server sending response based URL path user visiting. click link traditional server-rendered web app, browser receives HTML response server reloads entire page new HTML. Single-Page Application (SPA), however, client-side JavaScript intercept navigation, dynamically fetch new data, update current page without full page reloads. typically results snappy user experience, especially use cases like actual \"applications\", user expected perform many interactions long period time. SPAs, \"routing\" done client side, browser. client-side router responsible managing application's rendered view using browser APIs History API hashchange event. Official Router Vue well-suited building SPAs. SPAs, recommended use officially-supported Vue Router library. details, see Vue Router's documentation. Simple Routing Scratch need simple routing wish involve full-featured router library, Dynamic Components update current component state listening browser hashchange events using History API. Here's bare-bone example: vue <script setup> import { ref, computed } 'vue' import Home './Home.vue' import './About.vue' import NotFound './NotFound.vue' const routes = { '/': Home, '/about': } const currentPath = ref(window.location.hash) window.addEventListener('hashchange', () => { currentPath.value = window.location.hash }) const currentView = computed(() => { return routes[currentPath.value.slice(1) || '/'] || NotFound }) </script> <template> <a href=\"#/\">Home</a> | <a href=\"#/about\">About</a> | <a href=\"#/non-existent-path\">Broken Link</a> <component :is=\"currentView\" /> </template>"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Single-File Components Introduction Vue Single-File Components (a.k.a. *.vue files, abbreviated SFC) special file format allows us encapsulate template, logic, styling Vue component single file. Here's example SFC: vue <script setup> import { ref } 'vue' const greeting = ref('Hello World!') </script> <template> <p class=\"greeting\">{{ greeting }}</p> </template> <style> .greeting { color: red; font-weight: bold; } </style> see, Vue SFC natural extension classic trio HTML, CSS JavaScript. <template> , <script> , <style> blocks encapsulate colocate view, logic styling component file. full syntax defined SFC Syntax Specification. SFC SFCs require build step, numerous benefits return: - Author modularized components using familiar HTML, CSS JavaScript syntax - Colocation inherently coupled concerns - Pre-compiled templates without runtime compilation cost - Component-scoped CSS - ergonomic syntax working Composition API - compile-time optimizations cross-analyzing template script - IDE support auto-completion type-checking template expressions - Out-of-the-box Hot-Module Replacement (HMR) support SFC defining feature Vue framework, recommended approach using Vue following scenarios: - Single-Page Applications (SPA) - Static Site Generation (SSG) - non-trivial frontend build step justified better development experience (DX). said, realize scenarios SFCs feel like overkill. Vue still used via plain JavaScript without build step. looking enhancing largely static HTML light interactions, also check petite-vue, 6 kB subset Vue optimized progressive enhancement. Works Vue SFC framework-specific file format must pre-compiled @vue/compiler-sfc standard JavaScript CSS. compiled SFC standard JavaScript (ES) module - means proper build setup import SFC like module: js import MyComponent './MyComponent.vue' export default { components: { MyComponent } } <style> tags inside SFCs typically injected native <style> tags development support hot updates. production extracted merged single CSS file. play SFCs explore compiled Vue SFC Playground. actual projects, typically integrate SFC compiler build tool Vite Vue CLI (which based webpack), Vue provides official scaffolding tools get started SFCs fast possible. Check details SFC Tooling section. Separation Concerns? users coming traditional web development background may concern SFCs mixing different concerns place - HTML/CSS/JS supposed separate! answer question, important us agree separation concerns equal separation file types. ultimate goal engineering principles improve maintainability codebases. Separation concerns, applied dogmatically separation file types, help us reach goal context increasingly complex frontend applications. modern UI development, found instead dividing codebase three huge layers interweave one another, makes much sense divide loosely-coupled components compose them. Inside component, template, logic, styles inherently coupled, colocating actually makes component cohesive maintainable. Note even like idea Single-File Components, still leverage hot-reloading pre-compilation features separating JavaScript CSS separate files using Src Imports."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Server-Side Rendering (SSR) Overview SSR? Vue.js framework building client-side applications. default, Vue components produce manipulate DOM browser output. However, also possible render components HTML strings server, send directly browser, finally \"hydrate\" static markup fully interactive app client. server-rendered Vue.js app also considered \"isomorphic\" \"universal\", sense majority app's code runs server client. SSR? Compared client-side Single-Page Application (SPA), advantage SSR primarily lies in: Faster time-to-content: prominent slow internet slow devices. Server-rendered markup need wait JavaScript downloaded executed displayed, user see fully-rendered page sooner. addition, data fetching done server-side initial visit, likely faster connection database client. generally results improved Core Web Vitals metrics, better user experience, critical applications time-to-content directly associated conversion rate. Unified mental model: get use language declarative, component-oriented mental model developing entire app, instead jumping back forth backend templating system frontend framework. Better SEO: search engine crawlers directly see fully rendered page. TIP now, Google Bing index synchronous JavaScript applications fine. Synchronous key word there. app starts loading spinner, fetches content via Ajax, crawler wait finish. means content fetched asynchronously pages SEO important, SSR might necessary. also trade-offs consider using SSR: Development constraints. Browser-specific code used inside certain lifecycle hooks; external libraries may need special treatment able run server-rendered app. involved build setup deployment requirements. Unlike fully static SPA deployed static file server, server-rendered app requires environment Node.js server run. server-side load. Rendering full app Node.js going CPU-intensive serving static files, expect high traffic, prepared corresponding server load wisely employ caching strategies. using SSR app, first question ask whether actually need it. mostly depends important time-to-content app. example, building internal dashboard extra hundred milliseconds initial load matter much, SSR would overkill. However, cases time-to-content absolutely critical, SSR help achieve best possible initial load performance. SSR vs. SSG Static Site Generation (SSG), also referred pre-rendering, another popular technique building fast websites. data needed server-render page every user, instead rendering page every time request comes in, render once, ahead time, build process. Pre-rendered pages generated served static HTML files. SSG retains performance characteristics SSR apps: provides great time-to-content performance. time, cheaper easier deploy SSR apps output static HTML assets. keyword static: SSG applied pages providing static data, i.e. data known build time change requests. Every time data changes, new deployment needed. investigating SSR improve SEO handful marketing pages (e.g. / , /about , /contact , etc.), probably want SSG instead SSR. SSG also great content-based websites documentation sites blogs. fact, website reading right statically generated using VitePress, Vue-powered static site generator. Basic Tutorial Rendering App Let's take look bare-bones example Vue SSR action. - Create new directory cd - Run npm init -y - Add \"type\": \"module\" inpackage.json Node.js runs ES modules mode. - Run npm install vue - Create example.js file: js // runs Node.js server. import { createSSRApp } 'vue' // Vue's server-rendering API exposed `vue/server-renderer`. import { renderToString } 'vue/server-renderer' const app = createSSRApp({ data: () => ({ count: 1 }), template: `<button @click=\"count++\">{{ count }}</button>` }) renderToString(app).then((html) => { console.log(html) }) run: sh > node example.js print following command line: <button>1</button> renderToString() takes Vue app instance returns Promise resolves rendered HTML app. also possible stream rendering using Node.js Stream API Web Streams API. Check SSR API Reference full details. move Vue SSR code server request handler, wraps application markup full page HTML. using express next steps: - Run npm install express - Create following server.js file: js import express 'express' import { createSSRApp } 'vue' import { renderToString } 'vue/server-renderer' const server = express() server.get('/', (req, res) => { const app = createSSRApp({ data: () => ({ count: 1 }), template: `<button @click=\"count++\">{{ count }}</button>` }) renderToString(app).then((html) => { res.send(` <!DOCTYPE html> <html> <head> <title>Vue SSR Example</title> </head> <body> <div id=\"app\">${html}</div> </body> </html> `) }) }) server.listen(3000, () => { console.log('ready') }) Finally, run node server.js visit http://localhost:3000 . see page working button. Client Hydration click button, notice number change. HTML completely static client since loading Vue browser. make client-side app interactive, Vue needs perform hydration step. hydration, creates Vue application run server, matches component DOM nodes control, attaches DOM event listeners. mount app hydration mode, need use createSSRApp() instead createApp() : js // runs browser. import { createSSRApp } 'vue' const app = createSSRApp({ // ...same app server }) // mounting SSR app client assumes // HTML pre-rendered perform // hydration instead mounting new DOM nodes. app.mount('#app') Code Structure Notice need reuse app implementation server. need start thinking code structure SSR app - share application code server client? demonstrate bare-bones setup. First, let's split app creation logic dedicated file, app.js : js // app.js (shared server client) import { createSSRApp } 'vue' export function createApp() { return createSSRApp({ data: () => ({ count: 1 }), template: `<button @click=\"count++\">{{ count }}</button>` }) } file dependencies shared server client - call universal code. number things need pay attention writing universal code, discuss below. client entry imports universal code, creates app, performs mount: js // client.js import { createApp } './app.js' createApp().mount('#app') server uses app creation logic request handler: js // server.js (irrelevant code omitted) import { createApp } './app.js' server.get('/', (req, res) => { const app = createApp() renderToString(app).then(html => { // ... }) }) addition, order load client files browser, also need to: - Serve client files adding server.use(express.static('.')) inserver.js . - Load client entry adding <script type=\"module\" src=\"/client.js\"></script> HTML shell. - Support usage like import * 'vue' browser adding Import Map HTML shell. Try completed example StackBlitz. button interactive! Higher Level Solutions Moving example production-ready SSR app involves lot more. need to: Support Vue SFCs build step requirements. fact, need coordinate two builds app: one client, one server. TIP Vue components compiled differently used SSR - templates compiled string concatenations instead Virtual DOM render functions efficient rendering performance. server request handler, render HTML correct client-side asset links optimal resource hints. may also need switch SSR SSG mode, even mix app. Manage routing, data fetching, state management stores universal manner. complete implementation would quite complex depends build toolchain chosen work with. Therefore, highly recommend going higher-level, opinionated solution abstracts away complexity you. introduce recommended SSR solutions Vue ecosystem. Nuxt Nuxt higher-level framework built top Vue ecosystem provides streamlined development experience writing universal Vue applications. Better yet, also use static site generator! highly recommend giving try. Quasar Quasar complete Vue-based solution allows target SPA, SSR, PWA, mobile app, desktop app, browser extension using one codebase. handles build setup, also provides full collection Material Design compliant UI components. Vite SSR Vite provides built-in support Vue server-side rendering, intentionally low-level. wish go directly Vite, check vite-plugin-ssr, community plugin abstracts away many challenging details you. also find example Vue + Vite SSR project using manual setup here, serve base build upon. Note recommended experienced SSR / build tools really want complete control higher-level architecture. Writing SSR-friendly Code Regardless build setup higher-level framework choice, principles apply Vue SSR applications. Reactivity Server SSR, request URL maps desired state application. user interaction DOM updates, reactivity unnecessary server. default, reactivity disabled SSR better performance. Component Lifecycle Hooks Since dynamic updates, lifecycle hooks onMounted onUpdated called SSR executed client. avoid code produces side effects need cleanup setup() root scope <script setup> . example side effects setting timers setInterval . client-side code may setup timer tear onBeforeUnmount onUnmounted . However, unmount hooks never called SSR, timers stay around forever. avoid this, move side-effect code onMounted instead. Access Platform-Specific APIs Universal code cannot assume access platform-specific APIs, code directly uses browser-only globals like window document , throw errors executed Node.js, vice-versa. tasks shared server client different platform APIs, recommended wrap platform-specific implementations inside universal API, use libraries you. example, use node-fetch use fetch API server client. browser-only APIs, common approach lazily access inside client-only lifecycle hooks onMounted . Note third-party library written universal usage mind, could tricky integrate server-rendered app. might able get working mocking globals, would hacky may interfere environment detection code libraries. Cross-Request State Pollution State Management chapter, introduced simple state management pattern using Reactivity APIs. SSR context, pattern requires additional adjustments. pattern declares shared state JavaScript module's root scope. makes singletons - i.e. one instance reactive object throughout entire lifecycle application. works expected pure client-side Vue application, since modules application initialized fresh browser page visit. However, SSR context, application modules typically initialized server, server boots up. module instances reused across multiple server requests, singleton state objects. mutate shared singleton state data specific one user, accidentally leaked request another user. call cross-request state pollution. technically re-initialize JavaScript modules request, like browsers. However, initializing JavaScript modules costly, would significantly affect server performance. recommended solution create new instance entire application - including router global stores - request. Then, instead directly importing components, provide shared state using app-level provide inject components need it: js // app.js (shared server client) import { createSSRApp } 'vue' import { createStore } './store.js' // called request export function createApp() { const app = createSSRApp(/* ... */) // create new instance store per request const store = createStore(/* ... */) // provide store app level app.provide('store', store) // also expose store hydration purposes return { app, store } } State Management libraries like Pinia designed mind. Consult Pinia's SSR guide details. Hydration Mismatch DOM structure pre-rendered HTML match expected output client-side app, hydration mismatch error. Hydration mismatch commonly introduced following causes: template contains invalid HTML nesting structure, rendered HTML got \"corrected\" browser's native HTML parsing behavior. example, common gotcha <div> cannot placed inside<p> :html<p><div>hi</div></p> produce server-rendered HTML, browser terminate first <p> when<div> encountered parse following DOM structure:html<p></p> <div>hi</div> <p></p> data used render contains randomly generated values. Since application run twice - server, client - random values guaranteed two runs. two ways avoid random-value-induced mismatches: Use v-if +onMounted render part depends random values client. framework may also built-in features make easier, example the<ClientOnly> component VitePress.Use random number generator library supports generating seeds, guarantee server run client run using seed (e.g. including seed serialized state retrieving client). server client different time zones. Sometimes, may want convert timestamp user's local time. However, timezone server run timezone client run always same, may reliably know user's timezone server run. cases, local time conversion also performed client-only operation. Vue encounters hydration mismatch, attempt automatically recover adjust pre-rendered DOM match client-side state. lead rendering performance loss due incorrect nodes discarded new nodes mounted, cases, app continue work expected. said, still best eliminate hydration mismatches development. Suppressing Hydration Mismatches Vue 3.5+, possible selectively suppress inevitable hydration mismatches using data-allow-mismatch attribute. Custom Directives Since custom directives involve direct DOM manipulation, ignored SSR. However, want specify custom directive rendered (i.e. attributes add rendered element), use getSSRProps directive hook: js const myDirective = { mounted(el, binding) { // client-side implementation: // directly update DOM el.id = binding.value }, getSSRProps(binding) { // server-side implementation: // return props rendered. // getSSRProps receives directive binding. return { id: binding.value } } } Teleports Teleports require special handling SSR. rendered app contains Teleports, teleported content part rendered string. easier solution conditionally render Teleport mount. need hydrate teleported content, exposed teleports property ssr context object: js const ctx = {} const html = await renderToString(app, ctx) console.log(ctx.teleports) // { '#teleported': 'teleported content' } need inject teleport markup correct location final page HTML similar need inject main app markup. TIP Avoid targeting body using Teleports SSR together - usually, <body> contain server-rendered content makes impossible Teleports determine correct starting location hydration. Instead, prefer dedicated container, e.g. <div id=\"teleported\"></div> contains teleported content."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "State Management State Management? Technically, every Vue component instance already \"manages\" reactive state. Take simple counter component example: vue <script setup> import { ref } 'vue' // state const count = ref(0) // actions function increment() { count.value++ } </script> <!-- view --> <template>{{ count }}</template> self-contained unit following parts: - state, source truth drives app; - view, declarative mapping state; - actions, possible ways state could change reaction user inputs view. simple representation concept \"one-way data flow\": However, simplicity starts break multiple components share common state: - Multiple views may depend piece state. - Actions different views may need mutate piece state. case one, possible workaround \"lifting\" shared state common ancestor component, pass props. However, quickly gets tedious component trees deep hierarchies, leading another problem known Prop Drilling. case two, often find resorting solutions reaching direct parent / child instances via template refs, trying mutate synchronize multiple copies state via emitted events. patterns brittle quickly lead unmaintainable code. simpler straightforward solution extract shared state components, manage global singleton. this, component tree becomes big \"view\", component access state trigger actions, matter tree! Simple State Management Reactivity API piece state shared multiple instances, use reactive() create reactive object, import multiple components: js // store.js import { reactive } 'vue' export const store = reactive({ count: 0 }) vue <!-- ComponentA.vue --> <script setup> import { store } './store.js' </script> <template>From A: {{ store.count }}</template> vue <!-- ComponentB.vue --> <script setup> import { store } './store.js' </script> <template>From B: {{ store.count }}</template> whenever store object mutated, <ComponentA> <ComponentB> update views automatically - single source truth now. However, also means component importing store mutate however want: template <template> <button @click=\"store.count++\"> B: {{ store.count }} </button> </template> works simple cases, global state arbitrarily mutated component going maintainable long run. ensure state-mutating logic centralized like state itself, recommended define methods store names express intention actions: js // store.js import { reactive } 'vue' export const store = reactive({ count: 0, increment() { this.count++ } }) template <template> <button @click=\"store.increment()\"> B: {{ store.count }} </button> </template> TIP Note click handler uses store.increment() parentheses - necessary call method proper context since component method. Although using single reactive object store, also share reactive state created using Reactivity APIs ref() computed() , even return global state Composable: js import { ref } 'vue' // global state, created module scope const globalCount = ref(1) export function useCount() { // local state, created per-component const localCount = ref(1) return { globalCount, localCount } } fact Vue's reactivity system decoupled component model makes extremely flexible. SSR Considerations building application leverages Server-Side Rendering (SSR), pattern lead issues due store singleton shared across multiple requests. discussed details SSR guide. Pinia hand-rolled state management solution suffice simple scenarios, many things consider large-scale production applications: - Stronger conventions team collaboration - Integrating Vue DevTools, including timeline, in-component inspection, time-travel debugging - Hot Module Replacement - Server-Side Rendering support Pinia state management library implements above. maintained Vue core team, works Vue 2 Vue 3. Existing users may familiar Vuex, previous official state management library Vue. Pinia serving role ecosystem, Vuex maintenance mode. still works, longer receive new features. recommended use Pinia new applications. Pinia started exploration next iteration Vuex could look like, incorporating many ideas core team discussions Vuex 5. Eventually, realized Pinia already implements wanted Vuex 5, decided make new recommendation instead. Compared Vuex, Pinia provides simpler API less ceremony, offers Composition-API-style APIs, importantly, solid type inference support used TypeScript."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Testing Test? Automated tests help team build complex Vue applications quickly confidently preventing regressions encouraging break apart application testable functions, modules, classes, components. application, new Vue app break many ways, important catch issues fix releasing. guide, we'll cover basic terminology provide recommendations tools choose Vue 3 application. one Vue-specific section covering composables. See Testing Composables details. Test Start testing early! recommend begin writing tests soon can. longer wait add tests application, dependencies application have, harder start. Testing Types designing Vue application's testing strategy, leverage following testing types: - Unit: Checks inputs given function, class, composable producing expected output side effects. - Component: Checks component mounts, renders, interacted with, behaves expected. tests import code unit tests, complex, require time execute. - End-to-end: Checks features span multiple pages makes real network requests production-built Vue application. tests often involve standing database backend. testing type plays role application's testing strategy, protect different types issues. Overview briefly discuss are, implemented Vue applications, provide general recommendations. Unit Testing Unit tests written verify small, isolated units code working expected. unit test usually covers single function, class, composable, module. Unit tests focus logical correctness concern small portion application's overall functionality. may mock large parts application's environment (e.g. initial state, complex classes, 3rd party modules, network requests). general, unit tests catch issues function's business logic logical correctness. Take example increment function: js // helpers.js export function increment(current, max = 10) { (current < max) { return current + 1 } return current } self-contained, it'll easy invoke increment function assert returns supposed to, we'll write Unit Test. assertions fail, clear issue contained within increment function. js // helpers.spec.js import { increment } './helpers' describe('increment', () => { test('increments current number 1', () => { expect(increment(0, 10)).toBe(1) }) test('does increment current number max', () => { expect(increment(10, 10)).toBe(10) }) test('has default max 10', () => { expect(increment(10)).toBe(10) }) }) mentioned previously, unit testing typically applied self-contained business logic, components, classes, modules, functions involve UI rendering, network requests, environmental concerns. typically plain JavaScript / TypeScript modules unrelated Vue. general, writing unit tests business logic Vue applications differ significantly applications using frameworks. two instances unit test Vue-specific features: - Composables - Components Composables One category functions specific Vue applications Composables, may require special handling tests. See Testing Composables details. Unit Testing Components component tested two ways: Whitebox: Unit Testing Tests \"Whitebox tests\" aware implementation details dependencies component. focused isolating component test. tests usually involve mocking some, component's children, well setting plugin state dependencies (e.g. Pinia). Blackbox: Component Testing Tests \"Blackbox tests\" unaware implementation details component. tests mock little possible test integration component entire system. usually render child components considered \"integration test\". See Component Testing recommendations below. Recommendation Since official setup created create-vue based Vite, recommend using unit testing framework leverage configuration transform pipeline directly Vite. Vitest unit testing framework designed specifically purpose, created maintained Vue / Vite team members. integrates Vite-based projects minimal effort, blazing fast. Options - Jest popular unit testing framework. However, recommend Jest existing Jest test suite needs migrated Vite-based project, Vitest offers seamless integration better performance. Component Testing Vue applications, components main building blocks UI. Components therefore natural unit isolation comes validating application's behavior. granularity perspective, component testing sits somewhere unit testing considered form integration testing. Much Vue Application covered component test recommend Vue component spec file. Component tests catch issues relating component's props, events, slots provides, styles, classes, lifecycle hooks, more. Component tests mock child components, instead test interactions component children interacting components user would. example, component test click element like user would instead programmatically interacting component. Component tests focus component's public interfaces rather internal implementation details. components, public interface limited to: events emitted, props, slots. testing, remember test component does, it. Visual logic: assert correct render output based inputted props slots. Behavioral logic: assert correct render updates emitted events response user input events. example, demonstrate Stepper component DOM element labeled \"increment\" clicked. pass prop called max prevents Stepper incremented past2 , click button 3 times, UI still say2 .We know nothing implementation Stepper, \"input\" max prop \"output\" state DOM user see it. Vue Test Utils Cypress Testing Library js const valueSelector = '[data-testid=stepper-value]' const buttonSelector = '[data-testid=increment]' const wrapper = mount(Stepper, { props: { max: 1 } }) expect(wrapper.find(valueSelector).text()).toContain('0') await wrapper.find(buttonSelector).trigger('click') expect(wrapper.find(valueSelector).text()).toContain('1') assert private state component instance test private methods component. Testing implementation details makes tests brittle, likely break require updates implementation changes. component's ultimate job rendering correct DOM output, tests focusing DOM output provide level correctness assurance (if more) robust resilient change. rely exclusively snapshot tests. Asserting HTML strings describe correctness. Write tests intentionality. method needs tested thoroughly, consider extracting standalone utility function write dedicated unit test it. cannot extracted cleanly, may tested part component, integration, end-to-end test covers it. Recommendation Vitest components composables render headlessly (e.g. useFavicon function VueUse). Components DOM tested using@vue/test-utils .Cypress Component Testing components whose expected behavior depends properly rendering styles triggering native DOM events. used Testing Library via @testing-library/cypress. main differences Vitest browser-based runners speed execution context. short, browser-based runners, like Cypress, catch issues node-based runners, like Vitest, cannot (e.g. style issues, real native DOM events, cookies, local storage, network failures), browser-based runners orders magnitude slower Vitest open browser, compile stylesheets, more. Cypress browser-based runner supports component testing. Please read Vitest's comparison page latest information comparing Vitest Cypress. Mounting Libraries Component testing often involves mounting component tested isolation, triggering simulated user input events, asserting rendered DOM output. dedicated utility libraries make tasks simpler. @vue/test-utils official low-level component testing library written provide users access Vue specific APIs. also lower-level library@testing-library/vue built top of.@testing-library/vue Vue testing library focused testing components without relying implementation details. guiding principle tests resemble way software used, confidence provide. recommend using @vue/test-utils testing components applications. @testing-library/vue issues testing asynchronous component Suspense, used caution. Options Nightwatch E2E test runner Vue Component Testing support. (Example Project) WebdriverIO cross-browser component testing relies native user interaction based standardized automation. also used Testing Library. E2E Testing unit tests provide developers degree confidence, unit component tests limited abilities provide holistic coverage application deployed production. result, end-to-end (E2E) tests provide coverage arguably important aspect application: happens users actually use applications. End-to-end tests focus multi-page application behavior makes network requests production-built Vue application. often involve standing database backend may even run live staging environment. End-to-end tests often catch issues router, state management library, top-level components (e.g. App Layout), public assets, request handling. stated above, catch critical issues may impossible catch unit tests component tests. End-to-end tests import Vue application's code instead rely completely testing application navigating entire pages real browser. End-to-end tests validate many layers application. either target locally built application even live Staging environment. Testing Staging environment includes frontend code static server associated backend services infrastructure. tests resemble software used, confidence give you. - Kent C. Dodds - Author Testing Library testing user actions impact application, E2E tests often key higher confidence whether application functioning properly not. Choosing E2E Testing Solution end-to-end (E2E) testing web gained negative reputation unreliable (flaky) tests slowing development processes, modern E2E tools made strides forward create reliable, interactive, useful tests. choosing E2E testing framework, following sections provide guidance things keep mind choosing testing framework application. Cross-browser testing One primary benefits end-to-end (E2E) testing known ability test application across multiple browsers. may seem desirable 100% cross-browser coverage, important note cross browser testing diminishing returns team's resources due additional time machine power required run consistently. result, important mindful trade-off choosing amount cross-browser testing application needs. Faster feedback loops One primary problems end-to-end (E2E) tests development running entire suite takes long time. Typically, done continuous integration deployment (CI/CD) pipelines. Modern E2E testing frameworks helped solve adding features like parallelization, allows CI/CD pipelines often run magnitudes faster before. addition, developing locally, ability selectively run single test page working also providing hot reloading tests help boost developer's workflow productivity. First-class debugging experience developers traditionally relied scanning logs terminal window help determine went wrong test, modern end-to-end (E2E) test frameworks allow developers leverage tools already familiar with, e.g. browser developer tools. Visibility headless mode end-to-end (E2E) tests run continuous integration/deployment pipelines, often run headless browsers (i.e., visible browser opened user watch). critical feature modern E2E testing frameworks ability see snapshots and/or videos application testing, providing insight errors happening. Historically, tedious maintain integrations. Recommendation Playwright great E2E testing solution supports Chromium, WebKit, Firefox. Test Windows, Linux, macOS, locally CI, headless headed native mobile emulation Google Chrome Android Mobile Safari. informative UI, excellent debuggability, built-in assertions, parallelization, traces designed eliminate flaky tests. Support Component Testing available, marked experimental. Playwright open source maintained Microsoft. Cypress informative graphical interface, excellent debuggability, built-in assertions, stubs, flake-resistance, snapshots. mentioned above, provides stable support Component Testing. Cypress supports Chromium-based browsers, Firefox, Electron. WebKit support available, marked experimental. Cypress MIT-licensed, features like parallelization require subscription Cypress Cloud. Options Nightwatch E2E testing solution based Selenium WebDriver. gives widest browser support range, including native mobile testing. Selenium-based solutions slower Playwright Cypress. WebdriverIO test automation framework web mobile testing based WebDriver protocol. Recipes Adding Vitest Project Vite-based Vue project, run: sh > npm install -D vitest happy-dom @testing-library/vue Next, update Vite configuration add test option block: js // vite.config.js import { defineConfig } 'vite' export default defineConfig({ // ... test: { // enable jest-like global test APIs globals: true, // simulate DOM happy-dom // (requires installing happy-dom peer dependency) environment: 'happy-dom' } }) TIP use TypeScript, add vitest/globals types field tsconfig.json . json // tsconfig.json { \"compilerOptions\": { \"types\": [\"vitest/globals\"] } } Then, create file ending *.test.js project. place test files test directory project root test directories next source files. Vitest automatically search using naming convention. js // MyComponent.test.js import { render } '@testing-library/vue' import MyComponent './MyComponent.vue' test('it work', () => { const { getByText } = render(MyComponent, { props: { /* ... */ } }) // assert output getByText('...') }) Finally, update package.json add test script run it: json { // ... \"scripts\": { \"test\": \"vitest\" } } sh > npm test Testing Composables section assumes read Composables section. comes testing composables, divide two categories: composables rely host component instance, composables do. composable depends host component instance uses following APIs: - Lifecycle hooks - Provide / Inject composable uses Reactivity APIs, tested directly invoking asserting returned state/methods: js // counter.js import { ref } 'vue' export function useCounter() { const count = ref(0) const increment = () => count.value++ return { count, increment } } js // counter.test.js import { useCounter } './counter.js' test('useCounter', () => { const { count, increment } = useCounter() expect(count.value).toBe(0) increment() expect(count.value).toBe(1) }) composable relies lifecycle hooks Provide / Inject needs wrapped host component tested. create helper like following: js // test-utils.js import { createApp } 'vue' export function withSetup(composable) { let result const app = createApp({ setup() { result = composable() // suppress missing template warning return () => {} } }) app.mount(document.createElement('div')) // return result app instance // testing provide/unmount return [result, app] } js import { withSetup } './test-utils' import { useFoo } './foo' test('useFoo', () => { const [result, app] = withSetup(() => useFoo(123)) // mock provide testing injections app.provide(...) // run assertions expect(result.foo.value).toBe(1) // trigger onUnmounted hook needed app.unmount() }) complex composables, could also easier test writing tests wrapper component using Component Testing techniques."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Tooling Try Online need install anything machine try Vue SFCs - online playgrounds allow right browser: - Vue SFC Playground - Always deployed latest commit - Designed inspecting component compilation results - Vue + Vite StackBlitz - IDE-like environment running actual Vite dev server browser - Closest local setup also recommended use online playgrounds provide reproductions reporting bugs. Project Scaffolding Vite Vite lightweight fast build tool first-class Vue SFC support. created Evan You, also author Vue! get started Vite + Vue, simply run: npm pnpm yarn bun sh $ npm create vue@latest command install execute create-vue, official Vue project scaffolding tool. - learn Vite, check Vite docs. - configure Vue-specific behavior Vite project, example passing options Vue compiler, check docs @vitejs/plugin-vue. online playgrounds mentioned also support downloading files Vite project. Vue CLI Vue CLI official webpack-based toolchain Vue. maintenance mode recommend starting new projects Vite unless rely specific webpack-only features. Vite provide superior developer experience cases. information migrating Vue CLI Vite: Note In-Browser Template Compilation using Vue without build step, component templates written either directly page's HTML inlined JavaScript strings. cases, Vue needs ship template compiler browser order perform on-the-fly template compilation. hand, compiler would unnecessary pre-compile templates build step. reduce client bundle size, Vue provides different \"builds\" optimized different use cases. Build files start vue.runtime.* runtime-only builds: include compiler. using builds, templates must pre-compiled via build step.Build files include .runtime full builds: include compiler support compiling templates directly browser. However, increase payload ~14kb. default tooling setups use runtime-only build since templates SFCs pre-compiled. If, reason, need in-browser template compilation even build step, configuring build tool alias vue vue/dist/vue.esm-bundler.js instead. looking lighter-weight alternative no-build-step usage, check petite-vue. IDE Support recommended IDE setup VS Code + Vue - Official extension (previously Volar). extension provides syntax highlighting, TypeScript support, intellisense template expressions component props. TIP Vue - Official replaces Vetur, previous official VS Code extension Vue 2. Vetur currently installed, make sure disable Vue 3 projects. WebStorm also provides great built-in support Vue SFCs. IDEs support Language Service Protocol (LSP) also leverage Volar's core functionalities via LSP: Browser Devtools Vue browser devtools extension allows explore Vue app's component tree, inspect state individual components, track state management events, profile performance. TypeScript Main article: Using Vue TypeScript. Vue - Official extension provides type checking SFCs using <script lang=\"ts\"> blocks, including template expressions cross-component props validation.Use vue-tsc performing type checking command line, generatingd.ts files SFCs. Testing Main article: Testing Guide. Cypress recommended E2E tests. also used component testing Vue SFCs via Cypress Component Test Runner. Vitest test runner created Vue / Vite team members focuses speed. specifically designed Vite-based applications provide instant feedback loop unit / component testing. Jest made work Vite via vite-jest. However, recommended existing Jest-based test suites need migrate Vite-based setup, Vitest provides similar functionalities much efficient integration. Linting Vue team maintains eslint-plugin-vue, ESLint plugin supports SFC-specific linting rules. Users previously using Vue CLI may used linters configured via webpack loaders. However using Vite-based build setup, general recommendation is: npm install -D eslint eslint-plugin-vue , followeslint-plugin-vue 's configuration guide.Setup ESLint IDE extensions, example ESLint VS Code, get linter feedback right editor development. also avoids unnecessary linting cost starting dev server. Run ESLint part production build command, get full linter feedback shipping production. (Optional) Setup tools like lint-staged automatically lint modified files git commit. Formatting Vue - Official VS Code extension provides formatting Vue SFCs box. Alternatively, Prettier provides built-in Vue SFC formatting support. SFC Custom Block Integrations Custom blocks compiled imports Vue file different request queries. underlying build tool handle import requests. using Vite, custom Vite plugin used transform matched custom blocks executable JavaScript. Example using Vue CLI plain webpack, webpack loader configured transform matched blocks. Example Lower-Level Packages @vue/compiler-sfc package part Vue core monorepo always published version main vue package. included dependency main vue package proxied vue/compiler-sfc need install individually. package provides lower-level utilities processing Vue SFCs meant tooling authors need support Vue SFCs custom tools. TIP Always prefer using package via vue/compiler-sfc deep import since ensures version sync Vue runtime. @vitejs/plugin-vue Official plugin provides Vue SFC support Vite. vue-loader official loader provides Vue SFC support webpack. using Vue CLI, also see docs modifying vue-loader options Vue CLI."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "TypeScript Composition API page assumes already read overview Using Vue TypeScript. Typing Component Props Using <script setup> using <script setup> , defineProps() macro supports inferring props types based argument: vue <script setup lang=\"ts\"> const props = defineProps({ foo: { type: String, required: true }, bar: Number }) props.foo // string props.bar // number | undefined </script> called \"runtime declaration\", argument passed defineProps() used runtime props option. However, usually straightforward define props pure types via generic type argument: vue <script setup lang=\"ts\"> const props = defineProps<{ foo: string bar?: number }>() </script> called \"type-based declaration\". compiler try best infer equivalent runtime options based type argument. case, second example compiles exact runtime options first example. use either type-based declaration runtime declaration, cannot use time. also move props types separate interface: vue <script setup lang=\"ts\"> interface Props { foo: string bar?: number } const props = defineProps<Props>() </script> also works Props imported external source. feature requires TypeScript peer dependency Vue. vue <script setup lang=\"ts\"> import type { Props } './foo' const props = defineProps<Props>() </script> Syntax Limitations version 3.2 below, generic type parameter defineProps() limited type literal reference local interface. limitation resolved 3.3. latest version Vue supports referencing imported limited set complex types type parameter position. However, type runtime conversion still AST-based, complex types require actual type analysis, e.g. conditional types, supported. use conditional types type single prop, entire props object. Props Default Values using type-based declaration, lose ability declare default values props. resolved using Reactive Props Destructure : ts interface Props { msg?: string labels?: string[] } const { msg = 'hello', labels = ['one', 'two'] } = defineProps<Props>() 3.4 below, Reactive Props Destructure enabled default. alternative use withDefaults compiler macro: ts interface Props { msg?: string labels?: string[] } const props = withDefaults(defineProps<Props>(), { msg: 'hello', labels: () => ['one', 'two'] }) compiled equivalent runtime props default options. addition, withDefaults helper provides type checks default values, ensures returned props type optional flags removed properties default values declared. INFO Note default values mutable reference types (like arrays objects) wrapped functions using withDefaults avoid accidental modification external side effects. ensures component instance gets copy default value. necessary using default values destructure. Without <script setup> using <script setup> , necessary use defineComponent() enable props type inference. type props object passed setup() inferred props option. ts import { defineComponent } 'vue' export default defineComponent({ props: { message: String }, setup(props) { props.message // <-- type: string } }) Complex prop types type-based declaration, prop use complex type much like type: vue <script setup lang=\"ts\"> interface Book { title: string author: string year: number } const props = defineProps<{ book: Book }>() </script> runtime declaration, use PropType utility type: ts import type { PropType } 'vue' const props = defineProps({ book: Object PropType<Book> }) works much way we're specifying props option directly: ts import { defineComponent } 'vue' import type { PropType } 'vue' export default defineComponent({ props: { book: Object PropType<Book> } }) props option commonly used Options API, find detailed examples guide TypeScript Options API. techniques shown examples also apply runtime declarations using defineProps() . Typing Component Emits <script setup> , emit function also typed using either runtime declaration type declaration: vue <script setup lang=\"ts\"> // runtime const emit = defineEmits(['change', 'update']) // options based const emit = defineEmits({ change: (id: number) => { // return `true` `false` indicate // validation pass / fail }, update: (value: string) => { // return `true` `false` indicate // validation pass / fail } }) // type-based const emit = defineEmits<{ (e: 'change', id: number): void (e: 'update', value: string): void }>() // 3.3+: alternative, succinct syntax const emit = defineEmits<{ change: [id: number] update: [value: string] }>() </script> type argument one following: - callable function type, written type literal Call Signatures. used type returned emit function. - type literal keys event names, values array / tuple types representing additional accepted parameters event. example using named tuples argument explicit name. see, type declaration gives us much finer-grained control type constraints emitted events. using <script setup> , defineComponent() able infer allowed events emit function exposed setup context: ts import { defineComponent } 'vue' export default defineComponent({ emits: ['change'], setup(props, { emit }) { emit('change') // <-- type check / auto-completion } }) Typing ref() Refs infer type initial value: ts import { ref } 'vue' // inferred type: Ref<number> const year = ref(2020) // => TS Error: Type 'string' assignable type 'number'. year.value = '2020' Sometimes may need specify complex types ref's inner value. using Ref type: ts import { ref } 'vue' import type { Ref } 'vue' const year: Ref<string | number> = ref('2020') year.value = 2020 // ok! Or, passing generic argument calling ref() override default inference: ts // resulting type: Ref<string | number> const year = ref<string | number>('2020') year.value = 2020 // ok! specify generic type argument omit initial value, resulting type union type includes undefined : ts // inferred type: Ref<number | undefined> const n = ref<number>() Typing reactive() reactive() also implicitly infers type argument: ts import { reactive } 'vue' // inferred type: { title: string } const book = reactive({ title: 'Vue 3 Guide' }) explicitly type reactive property, use interfaces: ts import { reactive } 'vue' interface Book { title: string year?: number } const book: Book = reactive({ title: 'Vue 3 Guide' }) TIP recommended use generic argument reactive() returned type, handles nested ref unwrapping, different generic argument type. Typing computed() computed() infers type based getter's return value: ts import { ref, computed } 'vue' const count = ref(0) // inferred type: ComputedRef<number> const double = computed(() => count.value * 2) // => TS Error: Property 'split' exist type 'number' const result = double.value.split('') also specify explicit type via generic argument: ts const double = computed<number>(() => { // type error return number }) Typing Event Handlers dealing native DOM events, might useful type argument pass handler correctly. Let's take look example: vue <script setup lang=\"ts\"> function handleChange(event) { // `event` implicitly `any` type console.log(event.target.value) } </script> <template> <input type=\"text\" @change=\"handleChange\" /> </template> Without type annotation, event argument implicitly type . also result TS error \"strict\": true \"noImplicitAny\": true used tsconfig.json . therefore recommended explicitly annotate argument event handlers. addition, may need use type assertions accessing properties event : ts function handleChange(event: Event) { console.log((event.target HTMLInputElement).value) } Typing Provide / Inject Provide inject usually performed separate components. properly type injected values, Vue provides InjectionKey interface, generic type extends Symbol . used sync type injected value provider consumer: ts import { provide, inject } 'vue' import type { InjectionKey } 'vue' const key = Symbol() InjectionKey<string> provide(key, 'foo') // providing non-string value result error const foo = inject(key) // type foo: string | undefined recommended place injection key separate file imported multiple components. using string injection keys, type injected value unknown , needs explicitly declared via generic type argument: ts const foo = inject<string>('foo') // type: string | undefined Notice injected value still undefined , guarantee provider provide value runtime. undefined type removed providing default value: ts const foo = inject<string>('foo', 'bar') // type: string sure value always provided, also force cast value: ts const foo = inject('foo') string Typing Template Refs Vue 3.5 @vue/language-tools 2.1 (powering IDE language service vue-tsc ), type refs created useTemplateRef() SFCs automatically inferred static refs based element matching ref attribute used on. cases auto-inference possible, still cast template ref explicit type via generic argument: ts const el = useTemplateRef<HTMLInputElement>('el') Usage 3.5 Template refs created explicit generic type argument initial value null : vue <script setup lang=\"ts\"> import { ref, onMounted } 'vue' const el = ref<HTMLInputElement | null>(null) onMounted(() => { el.value?.focus() }) </script> <template> <input ref=\"el\" /> </template> get right DOM interface check pages like MDN. Note strict type safety, necessary use optional chaining type guards accessing el.value . initial ref value null component mounted, also set null referenced element unmounted v-if . Typing Component Template Refs Vue 3.5 @vue/language-tools 2.1 (powering IDE language service vue-tsc ), type refs created useTemplateRef() SFCs automatically inferred static refs based element component matching ref attribute used on. cases auto-inference possible (e.g. non-SFC usage dynamic components), still cast template ref explicit type via generic argument. order get instance type imported component, need first get type via typeof , use TypeScript's built-in InstanceType utility extract instance type: vue <!-- App.vue --> <script setup lang=\"ts\"> import { useTemplateRef } 'vue' import Foo './Foo.vue' import Bar './Bar.vue' type FooType = InstanceType<typeof Foo> type BarType = InstanceType<typeof Bar> const compRef = useTemplateRef<FooType | BarType>('comp') </script> <template> <component :is=\"Math.random() > 0.5 ? Foo : Bar\" ref=\"comp\" /> </template> cases exact type component available important, ComponentPublicInstance used instead. include properties shared components, $el : ts import { useTemplateRef } 'vue' import type { ComponentPublicInstance } 'vue' const child = useTemplateRef<ComponentPublicInstance>('child') cases component referenced generic component, instance MyGenericModal : vue <!-- MyGenericModal.vue --> <script setup lang=\"ts\" generic=\"ContentType extends string | number\"> import { ref } 'vue' const content = ref<ContentType | null>(null) const open = (newContent: ContentType) => (content.value = newContent) defineExpose({ open }) </script> needs referenced using ComponentExposed vue-component-type-helpers library InstanceType work. vue <!-- App.vue --> <script setup lang=\"ts\"> import { useTemplateRef } 'vue' import MyGenericModal './MyGenericModal.vue' import type { ComponentExposed } 'vue-component-type-helpers' const modal = useTemplateRef<ComponentExposed<typeof MyGenericModal>>('modal') const openModal = () => { modal.value?.open('newValue') } </script> Note @vue/language-tools 2.1+, static template refs' types automatically inferred needed edge cases."},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "TypeScript Options API page assumes already read overview Using Vue TypeScript. TIP Vue support TypeScript usage Options API, recommended use Vue TypeScript via Composition API offers simpler, efficient robust type inference. Typing Component Props Type inference props Options API requires wrapping component defineComponent() . it, Vue able infer types props based props option, taking additional options required: true default account: ts import { defineComponent } 'vue' export default defineComponent({ // type inference enabled props: { name: String, id: [Number, String], msg: { type: String, required: true }, metadata: null }, mounted() { this.name // type: string | undefined this.id // type: number | string | undefined this.msg // type: string this.metadata // type: } }) However, runtime props options support using constructor functions prop's type - way specify complex types objects nested properties function call signatures. annotate complex props types, use PropType utility type: ts import { defineComponent } 'vue' import type { PropType } 'vue' interface Book { title: string author: string year: number } export default defineComponent({ props: { book: { // provide specific type `Object` type: Object PropType<Book>, required: true }, // also annotate functions callback: Function PropType<(id: number) => void> }, mounted() { this.book.title // string this.book.year // number // TS Error: argument type 'string' // assignable parameter type 'number' this.callback?.('123') } }) Caveats TypeScript version less 4.7 , careful using function values validator default prop options - make sure use arrow functions: ts import { defineComponent } 'vue' import type { PropType } 'vue' interface Book { title: string year?: number } export default defineComponent({ props: { bookA: { type: Object PropType<Book>, // Make sure use arrow functions TypeScript version less 4.7 default: () => ({ title: 'Arrow Function Expression' }), validator: (book: Book) => !!book.title } } }) prevents TypeScript infer type inside functions, which, unfortunately, cause type inference fail. previous design limitation, improved TypeScript 4.7. Typing Component Emits declare expected payload type emitted event using object syntax emits option. Also, non-declared emitted events throw type error called: ts import { defineComponent } 'vue' export default defineComponent({ emits: { addBook(payload: { bookName: string }) { // perform runtime validation return payload.bookName.length > 0 } }, methods: { onSubmit() { this.$emit('addBook', { bookName: 123 // Type error! }) this.$emit('non-declared-event') // Type error! } } }) Typing Computed Properties computed property infers type based return value: ts import { defineComponent } 'vue' export default defineComponent({ data() { return { message: 'Hello!' } }, computed: { greeting() { return this.message + '!' } }, mounted() { this.greeting // type: string } }) cases, may want explicitly annotate type computed property ensure implementation correct: ts import { defineComponent } 'vue' export default defineComponent({ data() { return { message: 'Hello!' } }, computed: { // explicitly annotate return type greeting(): string { return this.message + '!' }, // annotating writable computed property greetingUppercased: { get(): string { return this.greeting.toUpperCase() }, set(newValue: string) { this.message = newValue.toUpperCase() } } } }) Explicit annotations may also required edge cases TypeScript fails infer type computed property due circular inference loops. Typing Event Handlers dealing native DOM events, might useful type argument pass handler correctly. Let's take look example: vue <script lang=\"ts\"> import { defineComponent } 'vue' export default defineComponent({ methods: { handleChange(event) { // `event` implicitly `any` type console.log(event.target.value) } } }) </script> <template> <input type=\"text\" @change=\"handleChange\" /> </template> Without type annotation, event argument implicitly type . also result TS error \"strict\": true \"noImplicitAny\": true used tsconfig.json . therefore recommended explicitly annotate argument event handlers. addition, may need use type assertions accessing properties event : ts import { defineComponent } 'vue' export default defineComponent({ methods: { handleChange(event: Event) { console.log((event.target HTMLInputElement).value) } } }) Augmenting Global Properties plugins install globally available properties component instances via app.config.globalProperties . example, may install this.$http data-fetching this.$translate internationalization. make play well TypeScript, Vue exposes ComponentCustomProperties interface designed augmented via TypeScript module augmentation: ts import axios 'axios' declare module 'vue' { interface ComponentCustomProperties { $http: typeof axios $translate: (key: string) => string } } See also: Type Augmentation Placement put type augmentation .ts file, project-wide *.d.ts file. Either way, make sure included tsconfig.json . library / plugin authors, file specified types property package.json . order take advantage module augmentation, need ensure augmentation placed TypeScript module. say, file needs contain least one top-level import export , even export {} . augmentation placed outside module, overwrite original types rather augmenting them! ts // work, overwrites original types. declare module 'vue' { interface ComponentCustomProperties { $translate: (key: string) => string } } ts // Works correctly export {} declare module 'vue' { interface ComponentCustomProperties { $translate: (key: string) => string } } Augmenting Custom Options plugins, example vue-router , provide support custom component options beforeRouteEnter : ts import { defineComponent } 'vue' export default defineComponent({ beforeRouteEnter(to, from, next) { // ... } }) Without proper type augmentation, arguments hook implicitly type. augment ComponentCustomOptions interface support custom options: ts import { Route } 'vue-router' declare module 'vue' { interface ComponentCustomOptions { beforeRouteEnter?(to: Route, from: Route, next: () => void): void } } beforeRouteEnter option properly typed. Note example - well-typed libraries like vue-router automatically perform augmentations type definitions. placement augmentation subject restrictions global property augmentations. See also:"},
{"source": "https://vuejs.org/", "title": "Vue.js", "text": "Using Vue TypeScript type system like TypeScript detect many common errors via static analysis build time. reduces chance runtime errors production, also allows us confidently refactor code large-scale applications. TypeScript also improves developer ergonomics via type-based auto-completion IDEs. Vue written TypeScript provides first-class TypeScript support. official Vue packages come bundled type declarations work out-of-the-box. Project Setup create-vue , official project scaffolding tool, offers options scaffold Vite-powered, TypeScript-ready Vue project. Overview Vite-based setup, dev server bundler transpilation-only perform type-checking. ensures Vite dev server stays blazing fast even using TypeScript. development, recommend relying good IDE setup instant feedback type errors. using SFCs, use vue-tsc utility command line type checking type declaration generation.vue-tsc wrapper aroundtsc , TypeScript's command line interface. works largely astsc except supports Vue SFCs addition TypeScript files. runvue-tsc watch mode parallel Vite dev server, use Vite plugin like vite-plugin-checker runs checks separate worker thread.Vue CLI also provides TypeScript support, longer recommended. See notes below. IDE Support Visual Studio Code (VS Code) strongly recommended great out-of-the-box support TypeScript. Vue - Official (previously Volar) official VS Code extension provides TypeScript support inside Vue SFCs, along many great features. TIP Vue - Official extension replaces Vetur, previous official VS Code extension Vue 2. Vetur currently installed, make sure disable Vue 3 projects. WebStorm also provides out-of-the-box support TypeScript Vue. JetBrains IDEs support too, either box via free plugin. version 2023.2, WebStorm Vue Plugin come built-in support Vue Language Server. set Vue service use Volar integration TypeScript versions, Settings > Languages & Frameworks > TypeScript > Vue. default, Volar used TypeScript versions 5.0 higher. Configuring tsconfig.json Projects scaffolded via create-vue include pre-configured tsconfig.json . base config abstracted @vue/tsconfig package. Inside project, use Project References ensure correct types code running different environments (e.g. app code test code different global variables). configuring tsconfig.json manually, notable options include: compilerOptions.isolatedModules set totrue Vite uses esbuild transpiling TypeScript subject single-file transpile limitations.compilerOptions.verbatimModuleSyntax superset ofisolatedModules good choice, - what@vue/tsconfig uses.If using Options API, need set compilerOptions.strict totrue (or least enablecompilerOptions.noImplicitThis , part thestrict flag) leverage type checking ofthis component options. Otherwisethis treated asany .If configured resolver aliases build tool, example @/* alias configured default acreate-vue project, need also configure TypeScript viacompilerOptions.paths .If intend use TSX Vue, set compilerOptions.jsx to\"preserve\" , setcompilerOptions.jsxImportSource to\"vue\" . See also: Note Vue CLI ts-loader webpack-based setups Vue CLI, common perform type checking part module transform pipeline, example ts-loader . This, however, clean solution type system needs knowledge entire module graph perform type checks. Individual module's transform step simply right place task. leads following problems: ts-loader type check post-transform code. align errors see IDEs fromvue-tsc , map directly back source code.Type checking slow. performed thread / process code transformations, significantly affects build speed entire application. already type checking running right IDE separate process, cost dev experience slow simply good trade-off. currently using Vue 3 + TypeScript via Vue CLI, strongly recommend migrating Vite. also working CLI options enable transpile-only TS support, switch vue-tsc type checking. General Usage Notes defineComponent() let TypeScript properly infer types inside component options, need define components defineComponent() : ts import { defineComponent } 'vue' export default defineComponent({ // type inference enabled props: { name: String, msg: { type: String, required: true } }, data() { return { count: 1 } }, mounted() { this.name // type: string | undefined this.msg // type: string this.count // type: number } }) defineComponent() also supports inferring props passed setup() using Composition API without <script setup> : ts import { defineComponent } 'vue' export default defineComponent({ // type inference enabled props: { message: String }, setup(props) { props.message // type: string | undefined } }) See also: TIP defineComponent() also enables type inference components defined plain JavaScript. Usage Single-File Components use TypeScript SFCs, add lang=\"ts\" attribute <script> tags. lang=\"ts\" present, template expressions also enjoy stricter type checking. vue <script lang=\"ts\"> import { defineComponent } 'vue' export default defineComponent({ data() { return { count: 1 } } }) </script> <template> <!-- type checking auto-completion enabled --> {{ count.toFixed(2) }} </template> lang=\"ts\" also used <script setup> : vue <script setup lang=\"ts\"> // TypeScript enabled import { ref } 'vue' const count = ref(1) </script> <template> <!-- type checking auto-completion enabled --> {{ count.toFixed(2) }} </template> TypeScript Templates <template> also supports TypeScript binding expressions <script lang=\"ts\"> <script setup lang=\"ts\"> used. useful cases need perform type casting template expressions. Here's contrived example: vue <script setup lang=\"ts\"> let x: string | number = 1 </script> <template> <!-- error x could string --> {{ x.toFixed(2) }} </template> worked around inline type cast: vue <script setup lang=\"ts\"> let x: string | number = 1 </script> <template> {{ (x number).toFixed(2) }} </template> TIP using Vue CLI webpack-based setup, TypeScript template expressions requires vue-loader@^16.8.0 . Usage TSX Vue also supports authoring components JSX / TSX. Details covered Render Function & JSX guide. Generic Components Generic components supported two cases: - SFCs: <script setup> thegeneric attribute - Render function / JSX components: defineComponent() 's function signature"}]