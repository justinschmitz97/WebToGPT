Domain: https://www.typescriptlang.org
Timestamp: 2024-09-21T15:01:32.658852

# TypeScript is **JavaScript with syntax for types.**

TypeScript is a strongly typed programming language that builds on JavaScript,
giving you better tooling at any scale.

[Try TypeScript NowOnline or via npm](/download)

  * Editor Checks
  * Auto-complete
  * Interfaces
  * JSX

    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†
    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†

[TypeScript 5.6](https://devblogs.microsoft.com/typescript/announcing-
typescript-5-6/) is now available

## What is TypeScript?

### JavaScript and More

TypeScript adds additional syntax to JavaScript to support a **tighter
integration with your editor**. Catch errors early in your editor.

### A Result You Can Trust

TypeScript code converts to JavaScript, which **runs anywhere JavaScript
runs** : In a browser, on Node.js or Deno and in your apps.

### Safety at Scale

TypeScript understands JavaScript and uses **type inference to give you great
tooling** without additional code.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

## Adopt TypeScript Gradually

Apply types to your JavaScript project incrementally, **each step improves
editor support** and improves your codebase.

Let's take this incorrect JavaScript code, and see how **TypeScript can catch
mistakes in your editor**.

    
    
    js
    
    function compact(arr) {
    
        if (orr.length > 10)
    
            return arr.trim(0, 10)
    
        return arr
    
    }

No editor warnings in JavaScript files  
  
This code crashes at runtime!

JavaScript file

    
    
    js
    
    // @ts-check
    
    ¬†
    
    function compact(arr) {
    
      if (orr.length > 10)
    
    Cannot find name 'orr'.2304Cannot find name 'orr'.
    
        return arr.trim(0, 10)
    
      return arr
    
    }

Adding this to a JS file shows errors in your editor

the param is arr, not orr!

JavaScript with TS Check

    
    
    js
    
    // @ts-check
    
    ¬†
    
    /** @param {any[]} arr */
    
    function compact(arr) {
    
        if (arr.length > 10)
    
          return arr.trim(0, 10)
    
    Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.
    
        return arr
    
      }

Using JSDoc to give type information

Now TS has found a bad call. Arrays have slice, not trim.

JavaScript with JSDoc

    
    
    ts
    
    function compact(arr: string[]) {
    
      if (arr.length > 10)
    
        return arr.slice(0, 10)
    
      return arr
    
    }

TypeScript adds natural syntax for providing types

TypeScript file

### Describe Your Data

**Describe the shape of objects and functions** in your code.

Making it possible to see **documentation and issues in your editor**.

    
    
    ts
    
    interface Account {
    
      id: number
    
      displayName: string
    
      version: 1
    
    }
    
    ¬†
    
    function welcome(user: Account) {
    
      console.log(user.id)
    
    }
    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }

## TypeScript becomes JavaScript via the delete key.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**TypeScript file**.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**Types are removed**.

    
    
    js
    
    ¬†
    
    ¬†
    
    function verify(result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**JavaScript file**.

## TypeScript Testimonials

**First** , we were surprised by the number of small bugs we found when
converting our code.

**Second** , we underestimated how powerful the editor integration is.

TypeScript was such a boon to our stability and sanity that we started using
it for all new code within days of starting the conversion.

Felix Rieseberg at Slack covered the transition of their desktop app from
JavaScript to TypeScript in their blog

[Read](https://slack.engineering/typescript-at-slack-a81307fa288d)

### Open Source with TypeScript

[Angular](https://angular.io/)[Vue](https://vuejs.org/)[Jest](https://jestjs.io/)[Redux](https://redux.js.org/)[Ionic](https://ionicframework.com/)[Probot](https://probot.github.io/)[Deno](https://deno.land/)[Vercel](https://github.com/vercel/vercel)[Yarn](https://yarnpkg.com/)[GitHub  
Desktop](https://github.com/desktop/desktop/)

## Loved by Developers

![Image of the stack overflow logo, and a graph showing TypeScript as the 2nd
most popular language](/images/index/stack-overflow.svg)

Voted **2nd most loved programming language** in the [Stack Overflow 2020
Developer survey](https://insights.stackoverflow.com/survey/2020#most-loved-
dreaded-and-wanted)

![Logo of the State of JS survey](/images/index/state-of-js.svg)

TypeScript was **used by 78%** of the [2020 State of
JS](https://2020.stateofjs.com/en-US/technologies/javascript-flavors/)
respondents, with **93% saying they would use it again**.

TypeScript was given the award for **‚ÄúMost Adopted Technology‚Äù** based on
year-on-year growth.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

 # TypeScript is **JavaScript with syntax for types.**

TypeScript is a strongly typed programming language that builds on JavaScript,
giving you better tooling at any scale.

[Try TypeScript NowOnline or via npm](/download)

  * Editor Checks
  * Auto-complete
  * Interfaces
  * JSX

    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†
    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†

[TypeScript 5.6](https://devblogs.microsoft.com/typescript/announcing-
typescript-5-6/) is now available

## What is TypeScript?

### JavaScript and More

TypeScript adds additional syntax to JavaScript to support a **tighter
integration with your editor**. Catch errors early in your editor.

### A Result You Can Trust

TypeScript code converts to JavaScript, which **runs anywhere JavaScript
runs** : In a browser, on Node.js or Deno and in your apps.

### Safety at Scale

TypeScript understands JavaScript and uses **type inference to give you great
tooling** without additional code.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

## Adopt TypeScript Gradually

Apply types to your JavaScript project incrementally, **each step improves
editor support** and improves your codebase.

Let's take this incorrect JavaScript code, and see how **TypeScript can catch
mistakes in your editor**.

    
    
    js
    
    function compact(arr) {
    
        if (orr.length > 10)
    
            return arr.trim(0, 10)
    
        return arr
    
    }

No editor warnings in JavaScript files  
  
This code crashes at runtime!

JavaScript file

    
    
    js
    
    // @ts-check
    
    ¬†
    
    function compact(arr) {
    
      if (orr.length > 10)
    
    Cannot find name 'orr'.2304Cannot find name 'orr'.
    
        return arr.trim(0, 10)
    
      return arr
    
    }

Adding this to a JS file shows errors in your editor

the param is arr, not orr!

JavaScript with TS Check

    
    
    js
    
    // @ts-check
    
    ¬†
    
    /** @param {any[]} arr */
    
    function compact(arr) {
    
        if (arr.length > 10)
    
          return arr.trim(0, 10)
    
    Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.
    
        return arr
    
      }

Using JSDoc to give type information

Now TS has found a bad call. Arrays have slice, not trim.

JavaScript with JSDoc

    
    
    ts
    
    function compact(arr: string[]) {
    
      if (arr.length > 10)
    
        return arr.slice(0, 10)
    
      return arr
    
    }

TypeScript adds natural syntax for providing types

TypeScript file

### Describe Your Data

**Describe the shape of objects and functions** in your code.

Making it possible to see **documentation and issues in your editor**.

    
    
    ts
    
    interface Account {
    
      id: number
    
      displayName: string
    
      version: 1
    
    }
    
    ¬†
    
    function welcome(user: Account) {
    
      console.log(user.id)
    
    }
    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }

## TypeScript becomes JavaScript via the delete key.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**TypeScript file**.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**Types are removed**.

    
    
    js
    
    ¬†
    
    ¬†
    
    function verify(result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**JavaScript file**.

## TypeScript Testimonials

**First** , we were surprised by the number of small bugs we found when
converting our code.

**Second** , we underestimated how powerful the editor integration is.

TypeScript was such a boon to our stability and sanity that we started using
it for all new code within days of starting the conversion.

Felix Rieseberg at Slack covered the transition of their desktop app from
JavaScript to TypeScript in their blog

[Read](https://slack.engineering/typescript-at-slack-a81307fa288d)

### Open Source with TypeScript

[Angular](https://angular.io/)[Vue](https://vuejs.org/)[Jest](https://jestjs.io/)[Redux](https://redux.js.org/)[Ionic](https://ionicframework.com/)[Probot](https://probot.github.io/)[Deno](https://deno.land/)[Vercel](https://github.com/vercel/vercel)[Yarn](https://yarnpkg.com/)[GitHub  
Desktop](https://github.com/desktop/desktop/)

## Loved by Developers

![Image of the stack overflow logo, and a graph showing TypeScript as the 2nd
most popular language](/images/index/stack-overflow.svg)

Voted **2nd most loved programming language** in the [Stack Overflow 2020
Developer survey](https://insights.stackoverflow.com/survey/2020#most-loved-
dreaded-and-wanted)

![Logo of the State of JS survey](/images/index/state-of-js.svg)

TypeScript was **used by 78%** of the [2020 State of
JS](https://2020.stateofjs.com/en-US/technologies/javascript-flavors/)
respondents, with **93% saying they would use it again**.

TypeScript was given the award for **‚ÄúMost Adopted Technology‚Äù** based on
year-on-year growth.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

  # Branding

## Logos and design assets for TypeScript

[![Examples of the logos](/images/branding/logo-grouping.svg)Click to download
the asset pack](/branding/typescript-design-assets.zip)

## Recommendations

Please use the blue TypeScript mark above as the primary logo for TypeScript.

This is the right logo for blog posts, news articles, giveaway stickers and
general marketing for yourself.

The ‚ÄúTS‚Äù in the logo is white, not transparent by default.

There is a capital ‚ÄúS‚Äù in TypeScript, just like in JavaScript.

## Alternatives

[![Examples of the logos as single colors](/images/branding/two-
colors.svg)](/branding/typescript-design-assets.zip "Download the design
assets")

Single color variant which has the ‚ÄúTS‚Äù cut out, useful for when you need a
single color design.

[![Examples of the logos as long-form. e.g. saying 'TypeScript' and not
'TS'](/images/branding/two-longform.svg)](/branding/typescript-design-
assets.zip "Download the design assets")

Full lettermark version of the TypeScript logo.

## Palette

[![Examples of the palette, you can get this in ASCII inside the design
assets](/images/branding/palette.svg)](/branding/typescript-design-assets.zip
"Download the design assets")

[![Examples of the palette, you can get this in ASCII inside the design
assets](/images/branding/palette-bg.svg)](/branding/typescript-design-
assets.zip "Download the design assets")

## Please Don't

Use the TypeScript logos for your application/product.

Modify the shape of the logos when used.

Integrate the TypeScript logo into your application's logo.

Name a product which implies TypeScript's endorsement of the product.

 ## TypeScript Cheat Sheets

Downloadable syntax reference pages for different parts of everyday TypeScript
code

Learn more about Classes, Interfaces, Types and Control Flow Analysis

[![Control Flow Analysis Cheat Sheet](/static/TypeScript Control Flow
Analysis-8a549253ad8470850b77c4c5c351d457.png)Control Flow
Analysis](/static/TypeScript Control Flow
Analysis-8a549253ad8470850b77c4c5c351d457.png "Control Flow Analysis Cheat
Sheets")[![Interfaces Cheat Sheet](/static/TypeScript
Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png)Interfaces](/static/TypeScript
Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png "Interfaces Cheat
Sheets")[![Types Cheat Sheet](/static/TypeScript Types-
ae199d69aeecf7d4a2704a528d0fd3f9.png)Types](/static/TypeScript Types-
ae199d69aeecf7d4a2704a528d0fd3f9.png "Types Cheat Sheets")[![Classes Cheat
Sheet](/static/TypeScript
Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png)Classes](/static/TypeScript
Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png "Classes Cheat Sheets")

[Download PDFs and PNGsTo read later or print](/assets/typescript-cheat-
sheets.zip)

 ## TypeScript Cheat Sheets

Downloadable syntax reference pages for different parts of everyday TypeScript
code

Learn more about Classes, Interfaces, Types and Control Flow Analysis

[![Control Flow Analysis Cheat Sheet](/static/TypeScript Control Flow
Analysis-8a549253ad8470850b77c4c5c351d457.png)Control Flow
Analysis](/static/TypeScript Control Flow
Analysis-8a549253ad8470850b77c4c5c351d457.png "Control Flow Analysis Cheat
Sheets")[![Interfaces Cheat Sheet](/static/TypeScript
Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png)Interfaces](/static/TypeScript
Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png "Interfaces Cheat
Sheets")[![Types Cheat Sheet](/static/TypeScript Types-
ae199d69aeecf7d4a2704a528d0fd3f9.png)Types](/static/TypeScript Types-
ae199d69aeecf7d4a2704a528d0fd3f9.png "Types Cheat Sheets")[![Classes Cheat
Sheet](/static/TypeScript
Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png)Classes](/static/TypeScript
Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png "Classes Cheat Sheets")

[Download PDFs and PNGsTo read later or print](/assets/typescript-cheat-
sheets.zip)

 # Connect with us

## Online

Tell us what‚Äôs working well, what you want to see added or improved, and find
out about new updates.

### [Stack Overflow](https://stackoverflow.com/questions/tagged/typescript
"TypeScript tag on Stack Overflow")Engage with your peers and ask questions
about TypeScript using the tag 'typescript'

### [Chat](https://discord.gg/typescript "TypeScript Community on
Discord")Chat with other TypeScript users in the TypeScript Community Chat.

### [GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create
a new GitHub Issue on the TypeScript repo")Found a bug, or want to give us
constructive feedback? [Tell us on
GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create a
new GitHub Issue on the TypeScript repo")

### [Twitter](https://twitter.com/typescript "The TypeScript team on
Twitter")Stay up to date. Follow us on Twitter
[@typescript](https://twitter.com/typescript "The TypeScript team on
Twitter")!

### [Blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")Learn about the latest TypeScript developments via our
[blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")!

### [Definitely
Typed](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type
definitions")TypeScript definition files. [Browse the thousands
of](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type definitions")
available for common libraries and frameworks.

## Connect in person

ConferencesUpcoming EventsMeetups

### Conferences

[![logo of  TSConf:EU](\[object Module\])](https://tsconf.eu "Link to
TSConf:EU")#### [TSConf:EU](https://tsconf.eu)

Linz Austria  
March 31st, 2020

## Conferences

Hello

### Meetups

![logo of Boston TypeScript Club](/static/boston-ts-
club-8ed5db84c1ef76a9b7629d936da92973.png)

#### Boston TypeScript Club

üá∫üá∏  
[Website](https://bostonts.club "Website for Boston TypeScript Club")

![logo of Hamburg
TypeScript](data:image/png;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QCiRXhpZgAATU0AKgAAAAgABgESAAMAAAABAAEAAAEaAAUAAAABAAAAVgEbAAUAAAABAAAAXgEoAAMAAAABAAIAAAExAAIAAAAVAAAAZodpAAQAAAABAAAAfAAAAAAAAABIAAAAAQAAAEgAAAABUGl4ZWxtYXRvciBQcm8gMS41LjIAAAACoAIABAAAAAEAAADIoAMABAAAAAEAAADIAAAAAP/hCZlodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IlBpeGVsbWF0b3IgUHJvIDEuNS4yIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTExLTMwVDAyOjI3OjE2WiIvPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz4A/+0AOFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAAOEJJTQQlAAAAAAAQ1B2M2Y8AsgTpgAmY7PhC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)

#### Hamburg TypeScript

üá©üá™  
[Website](https://www.meetup.com/Hamburg-TypeScript-Meetup-Group "Website for
Hamburg TypeScript")

![logo of Krakow TypeScript User
Group](/static/ktug-d861e06684ad664e628d59cba8a96e5c.jpg)

#### Krakow TypeScript User Group

üáµüá±  
[Website](https://www.meetup.com/typescript-krakow "Website for Krakow
TypeScript User Group")

![logo of Melbourne
TypeScript](/static/melbourne-5eb843a1b0ccd09bb6cfcb339b9b8a5d.jpg)

#### Melbourne TypeScript

üá¶üá∫  
[Website](https://www.meetup.com/Melbourne-TypeScript-Meetup "Website for
Melbourne TypeScript")

![logo of Milano
TS](data:image/jpeg;base64,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)

#### Milano TS

üáÆüáπ  
[Website](https://www.meetup.com/MilanoTS/ "Website for Milano TS")
[Twitter](https://twitter.com/Milano_TS "Twitter page for Milano TS")

![logo of Seattle
TypeScript](data:image/jpeg;base64,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)

#### Seattle TypeScript

üá∫üá∏  
[Website](https://www.meetup.com/seattle-ts "Website for Seattle TypeScript")

![logo of Sevilla
TypeScript](data:image/jpeg;base64,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)

#### Sevilla TypeScript

üá™üá∏  
[Website](https://www.meetup.com/Sevilla-TypeScript "Website for Sevilla
TypeScript") [Twitter](https://twitter.com/SVQTypeScript "Twitter page for
Sevilla TypeScript")

![logo of San Francisco TypeScript Meetup](/static/san-fran-
ts-6a81c173960965f62590310db2b4b93c.jpg)

#### San Francisco TypeScript Meetup

üá∫üá∏  
[Website](https://www.meetup.com/San-Francisco-TypeScript-Meetup "Website for
San Francisco TypeScript Meetup")

![logo of Sydney
TypeScript](data:image/jpeg;base64,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)

#### Sydney TypeScript

üá¶üá∫  
[Website](https://www.meetup.com/Sydney-TypeScript "Website for Sydney
TypeScript") [Twitter](https://twitter.com/SydTypeScript "Twitter page for
Sydney TypeScript")

![logo of TypeScript
NYC](data:image/jpeg;base64,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)

#### TypeScript NYC

üá∫üá∏  
[Website](https://www.meetup.com/NYC-Typescript "Website for TypeScript NYC")

![logo of TypeScript Brazil
Meetup](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/2wCEAAICAgICAgMCAgMFAwMDBQYFBQUFBggGBgYGBggKCAgICAgICgoKCgoKCgoMDAwMDAwODg4ODg8PDw8PDw8PDw8BAgICBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/CABEIAMgAyAMBIgACEQEDEQH/xAAeAAEAAQQDAQEAAAAAAAAAAAAACAIFBwkBBAYDCv/aAAgBAQAAAACeACmoAAR5xbTT6qWWDIlyTkoBZra4KeUZ4/8AH29pPOMMbpIys8/e7h1ejdIo9RyDrx9q+nq8545xJJCRPl/S3TzvjsgR3zdzR0rl8ujcsBR4fX2MxI9YTknJHyEer7as3+9jFmuqjoXP5W+6YEj1X9fXyuwhgqRkqrrijK2N/Z0xkzBVR0Ll8uhc8Ax5PYzPwVHmRUt7hiTLfhu5dIzY57c2waxOmfa89C3924Vdbs/JV0vh872CwAAAAAAAAAAAAAJVScAQYxB2JmyW7GCoL2kBtA2ROOVFbSdE/cvMrhzHrR1ZwJUyYZQme10dFB71m9znXf5PYtHbT740ASq3dUfm8sJNfcZ5n85HxyriykAJVbuqPzeWEkhvTQx1lYfAAlVu6o/N5YSrdLLrnqwz1r4bACVW7qj83lhFx2J7DvYc2TSnGMASq3dUfm8sIL/OzZB7fBmhAASq3dUfm8sJzKqMPSTt27fD813UAJVbuqPzeWF9t1csYga2uns1l5jP89PABKrd1R+bywk9NsvZOWomCQAkNtap0c2cSc2KyE7uJtfUGwAADnjngAAAAP/EABwBAQACAwEBAQAAAAAAAAAAAAAFBgQHCAMBAv/aAAgBAhAAAADo72j8zAxj0/X0u0hXpSs4Pl6TfifLBm16VrH59Y2Vw/18+3PIjcqJ8fz8mMXCfLOAAYNWFvxanZ5cVXR8B7zW9uZ56L6q9g5+l91QHK3TtjyAc/S+6mjtVXfoLNDn6X3Uj8XnHZW3g5+l91UTn/YOvt87CCl5FsU2pWG/AAH/xAAcAQEAAQUBAQAAAAAAAAAAAAAABAMFBgcIAgH/2gAIAQMQAAAA5f8AEihJqnn4Meh3eFeJPpbavx8tcS7w7x68Sodf75Y5Rnx5tX35gV5fz7YgACflIxCVleM2cZVvG+UrPojpWw3TleiHQVp0nf8AqfmTHI4OgrTpNvDamEaAgh0FadJrjJ6M1tqIOgrTpPO9/a/2DobXwZrFxRmWW47gQAB//8QAOhAAAAUCAwQJAwIEBwAAAAAAAQIDBAUABgcREhMUFVQQFxggITAxNVUkNmMiNAgWIyUyM0BBQlBg/9oACAEBAAEMAe/6eI0AgYMw8Q/0F3XRIwbxNBnoEOsCa2WvNHUGIU3oEw7LUGIU4ICI7IBgb1lpKVbsnOzBOr3nH0O3QKwNszyT6Vcjm8cKrEw8k3DhBWOWNqJ33MjHsjAR25TRNx2E59CuOwnPoVx6E59CuPQnPoVx6E59CuPwnPoVx+D59CuPwfPoVf8AsOOtt5z2S26FdDsNR27sWpnSgswMVB8LIzgRjymKjFO4tpNR7lPUmkzkWMgXWyXIsGJOoF2g5+C+ZzCuGoxcNhDeHYBS66DZMVnChUicdhM8t/Qpu7avCio0VKsWlV0UchWUKnXEGGeneUsyHIoUDpmAxb+ZrvZdi3bEE5+rR3zpK6tHnOkrq0d86SurR3zpK6tHfOkrq0d86SurR3zpK6tHfOkq/iIqTzQjg+zSFNDexSBTNF4m3SdKJtFNqi+RaoOBTaLbdOMBghMshLqdJOYRR+qCkbECyG62LpkLQkk725nCJkQAhinKOGoZLu8/UEEXyjkXBAUKqzt5usDd2VqkozXiWiOzRWQSDiUbzaVSK0E+Q2btZusVCOtV0sKDNBuucjZGOUbJtSAkniGoqjJMFETiQzxEhFVwJqADok2uX6qSRIIlzE1bMNjnmbMyJNX/ACpJIgnKA6q0Bsc8zZnRIBw/xVfrcXU+1bgcqdKIARyZsChTA6Q3Zyo32hVaeNgaLiiVUq1RDAeMsUUXQauDTQeBZpXK92rloo1K9dneC4SMmmGopyVhvrBV0A6so4PpCKVcCSamy1x6j6olmZUznaxjlyHCVt82gQrgW800M2YGcIxK7SrbQMjq1xhmZn4f0NrWJIfWMRp9vW2cZgSj71tfQlI71qJ4Er6nYj4Fo29a/QlI71rL4Er6nYehaU3rWHgSr/QVczrVuiGpQ6CqbgWqhdKjpsszcKNXAaVHrJzHri2dk2akZEOOMsmbrUhX8ml/2knIVeEOaOVZpbdd2C2nPLIwHw3ObeHwZ+DEMmTcOi0v1NXyvRdxdVuPQpifasW6lSPt7qsSP3LAaev2JlnGlwmNHfMtrnvCdJPmICTNwnW+stiIbwnRn7HV+5TpF+xA5c3Cdb8y2GW8J5qSDDWH1KdYimEswgYo5CJhEdQjmImEwiYw5iIiYczDmMA3I+mWrZcTaQs2HD1MsNXtDR8TuYoAfSYU9P6QHVh1/nSNNQ+lR6LL/VDCp0XKXVAPgqBPtIRgapH291WJYfrZDVqKKoJSjlBQU1Iq5590/TQWenEm7fmUrdvzKVu35lK3b8ylbt+ZSt2/MpSzhdwbW4UMqPSmookcFEjCQ3FZTnFqWdunOW8LHV6EXLhvnu6pk6CUkwDIHa1cVlOcWpJ++QJs0XCiZeKynOLUeSkVCiQ7pUxSSMgmUE03SpSjJyRgEpnaogs6dOct4WOrRFVUwMCZxKBDnTNqIIlHispzi1cVlOcWrispzi1cVlOcWrispzi1cVlOcW/8jhzh0hfKTxRV2ZtXZ6Z/Lnrs9M/lz12emfy567PTP5c9dnpn8ueuz0z+XPXZ6Z/Lnrs9M/lz1fFsp2jPqQqa4uApJJVdQqKJBUUt3BC5ZUhXEqcsck1wBt1Mv1b5dUVsArZOH9B24TGewFl2iZloN2V7T5g8jHSjKQRM3X8j+Hr9rL+TjV9+Oa9fSsLsOW1tMUpeTSzlQ7l/WDH3rHiAlBKQfsHUW9Wj3yYpL9/DnEZGxUniarQXVdoVp8Qeu0K0+IPVn4wIXbOpQpI8zcc6Hwp1j8k2cqt+EiNdoVH4g1doVH4g1XtcwXdPKzRUd3rC2FJN3oxQWLqS6LrxzQjXyjC3mxXYRH8QC23KSbjyglFSrCbYJSUaqCze98VYW09bJsO+yM/OvrklFpeREoreVgx9+tOgfSpX3N53MCPvFXomEXDmKeN2g5LqEOkoZJQolPUVelxQkS4hox0ZBAREw5iOY+Xgx9+tOgfSpX3N53MJ5hOGvZkosbSn0Xtg/E3M4VlI5TcX1y2LclqHHirUdj5uDH3606B9Klfc3ncARKOYeA4W4hI3VHljZBTKVoaVSTXTMksUDkunBS3pjW4hv7a5uqxLitBT+6IZoeXgx9+tOgfSpX3N53Wjt0wcpvGSpkVrRx1USAjK7EtoEROxE+23uIdEdJdD1i0kWqjN8kVdDEywj2bJgq1zPHeVgx9+tOgfSpX3N5346VkYhyV5GOTtVrYx3kG2htcyG8pwU9F3HHlkohYFkaxGgCXDaL9pp1K+Vgx9+tOgfSpX3N53bdwhuqdZnfqJgyTcN12i6jZyQU1ejAaWdIXG4iAERb0cAEogPouUpF1CF9PJwY+/WnQPpUr7m86UwKY5SnHSWxcNbVg2zeVb5SLisQcKWN2nNJMDg0kZPDC+ItQSKRaq5WGG17yKgJpRC6dYZYbfyamo/kDlVkKu+bJb1uP5Yw5G8rBj79adA+lSvubzuYT4mpwem3Z5TJiRQqhSqJmAxe7jLfiU27LbsWpraeVhfLx0Hd7eRlVgbt+tKwPmE6HFOwcvd06kFCKv3KqY5l7lmYpT9ogVoI74xhMZLMliFByuMes1n4N8XUzkEFwWlotsXU4dpJhKYmWTFEEy0oksa+cZn86kpGwBDMWn/a//xABAEAABAgMCCAwFAwMFAQAAAAABAAIDERIhMRATQVFhcXOxBCAiMDJCUnKBkaGyU2LB0eEjQ5IUM9JAUGCCwvD/2gAIAQEADT8B5g/6F7Zyc2ZU+jQbs96FwoNvqhdyDb6qKZGTbd+CMTN0p2DWiZcqYE8oloUABzM4mbuYdcHuDd62jfuto37raNW0ato1bRq2jVtGrF8qm+U0DZOxxCJ5IdfJWSrMzpUINxpdby5WkSyL5TM+SkbJ/ROPSdlOW1Bjd6F7nGQW0b90DKbDMT8MDrqjJd8I3EWhPYbBblXdK7pXdK7pXdK7pXdK7pRYKnXyE7Sq5Vy6s75akDyXESmFIcqUlIF7Q22oi1oGVT/uOfij4BqOTpOa3XefFTNjhLUqG+U0HYtocJiQA+qcJ0ukD63q8hjmymu+1NM5OiNA3oCfItn43BP/AEy1tgnKYPoqHWtMjehCcRyjfTrWMl0j2wM6Lh1jmdpWJn0jfQFXLpH4gCq7R+bSsRPpG+iedYyXSPxAM6fDlU80tFuUoOprHRvv1KGZVMM2nUgAamGYtCjSNUI2smN60w2H6IzvY1shrARcaQ7MqGkTuvNyizifzNX1Vv8AbfTT6hMiFlkaVEshtVMqMdbVnnNQyJxHR5gDzRY2cRzw8v8AUqE5r/AG30mqXb1iX5+ysZp7YVQz5nrEHP2AsZp+IFVp+dYg5+wsZp+IFEYGtGklNdQQchuUIycNKABlrXCKXgtNtLhMLQ8/dRT13VeDdKBM6vRCG2zxWLZuwP4ZGPrgpB8nBOhsPmFin7lJ29GC4dMdlYztjthVDrDM9YiXSF9AVfbHxAqu2PnWIl0xfQsZ2x8QIQ/rgKKiOkSDI3Z1tCnuNU3E2DWp+ixQ+qobuwPjRHeZwYp3osRD9GrFP3KTlB4OXNIzhOqyNyNJzLX+Fr/C1/ha/wALX+Fr/CGVxJ38QXEGRW0chdU4u34HX0kifkto5bRyzNeQFtHJ1hBe4gptwDyAj87kLqnE708SMjKY0rOFtHLaOW0cto5bRy2jv+I8FLRY2qdS2YWzC2YWzC2YWzC2YWzChta6siXSwPMmtaJkk5AE7qu5UTyFy0Sb91pk5N/beKHnVkUIycx4kRzNcPceZxULdgjtq5X7IPVGnPxYQ/Sjf+XaFwdxY9pyEcxwotNjqZUraD7LaD7KKHGsvn0RPDCe5s8ZmMsy2n4W0/CiNa2ic+iFwcmO8Z8XaPWWGCS10Z55JI7MrxpRvfBNo8Cowm1w/wDr0LMW08lh+c/RRr6RISF3N0RPbhx0T3Hif0r94wRIMRsM/MWkD1TDIg3gjBwl1TqekM9JyT0I85RE9uHHRPceJwmfBydpd6ywxLXWThvdnIzqchGZyoZ8cnjz1ET24cdE9x4gXBm8qf7rR1xpz4XCRa4TBGkI5GicInu5PBOMmxmWwz45Dr5yiJ7cOOie48WEZtewyIOtXf1EMW/9m/ZZ2G7WLx44Yopcx4mCFwokwieqcrDzdET24cdE9x47etDdIq7HQ+S/xFxT/Ag5iMhwQmGLC78MTHndzdET24cdE9x4tBdDEax0QyssyA5yoTi17XWEEXg4eEwS8jIHMlb64WuIHnzVET24cdE9xwk2m+QURrXs4Q+0W2gsGTfgla6XIiS7WnSh1oAxoP8AG30RyxW4sD+UlHFJp6LG5hggwzRpebGjz5uiJ7cOOie48Rx/Sim6ETkPy7k4TBFxHG4G6cVzbnxB9G82xjwXmZvGhd1/+K7r/wDFPivIOgnij9l56PcOTUj1Yws/kLEexFa7cVnc9o3lDqwTjSf4zCfY5/7rx4XD/dv/xAAqEAEAAgEDAwMEAgMBAAAAAAABABEhMUFRYXHwgZHBECAwobHhQNHxYP/aAAgBAQABPxD71o4A1WGHAWJkR3P8Fj7rQDdXdhB3QJNQ03YekRWUDRDq3wlRsFLNXsg0ZyYsLQ6PoN8HSQGgBN40WQLowQeBTTiXyPDosPbufgMUloicgj60KHnHzPOPmecfM84+Z5R8zyj5nO4aFbMl4sgCRGxNxurBjjwrLPBSVmfQFtZKdYvbxzwEF5OCYK1bSHfUepCwy1Zc3l4994esFtpG2hb9Y5pW0O2ek0WRgV8riczva94uI2FIbXY+gZQqQ3eC6tl7DDbL/MAotpEOiYYWZsG1GTXQzHz7+Z5d8zx/5nj/AMzx/wCZ4/8AM8f+Z4/8xihUizug3ohWQs6ji/mVEoVd45E2ZUDkL7qZKc4cS9NL1aegnHWEntignOifSPEvWktuYBxygImbSUVh1pz6RN3ICU5cjxdytdoRqNDeqz2lg3O2LYJjq3cwuyKFWetvdiGo+XMKAwb40u9EpVKipSrwGjvmJ4hEttoaXlnWGk4DCx3KYxQvGMJHquBQQUpt4XoUljgBnT/0j2ja1zfnF663mBINHtOBrw1HUQkeGsfYe0b+uL8ZbqvMKBB6HhehqLqiochlMBEYDuW6pR918QSALph3W5D6+SzQ0PS6Zk8osuRpUKG5AtANLL3bMutgvOmQFa8Okq2tCwoOjm6S2sywVpA3kqnUj96B6AIaFqF3e5yXKkhxmHTiWm7Fd9EJn9DW0t2IsIapBuVqLIkEVNrs67So7n3gd5YFxfrF1QqdFo770O+qaxO4QLtnm0QdX7HjuLDsrvwhb9Hm0VizPUaos/CjdYHvF0KJAi2F01lpVbg0NcmIvdYaNAs0lzkNGFKCaNepKf1ai1DpnysKFUUrRAZV0GBzZowi3eFsDbNToYH6w1iuP919PS73wn/M9WeR5wZmlH6RiGCpbVAGdYtCijezfevGY5CpH/edT3jrQtTjFa63iV7hz6N968Z7RLGBejXV1PePKhTLgK11vFRCCmXRtvXjPaNoNRGkRZGJ3K2q5Xm41BVq5Vd2PGZCrayp6rIQVVs0n7Q52Lsp1owZU1E1FY2uOBXPWXENn/cVGbfxIFxsaimPVaJ7L+I2o4PYPiDwd8TyOSLCyk1MXY3DwI0A0DTkEv8A1Iv/AFIv/Ui/9SL/ANSL/wBSCwaoWhxafsRCdrA9EyTwD5hYI4ovizX0TaYrDXDYuCggKAoD3ngHzBg7aE19BqeAfME8CBB1EWkh+moeHADRDoUiLCOoly9dIpvizUrzYWHFTU6MAHN0iJeHJ0ngHzPAPmeAfM8A+Z4B8zwD5/8AIs3TQ8Jc2lVU8X+Z4v8AM8X+Z4v8zxf5ni/zPF/meL/MrOF22l1Ren0E1Bg8oBaq6BB+YIOF5xLot8hBJudJ30Kiq8qX6qIWfClCGyy3op3llGgHdnZ2dEyfiwWSyU7sx9EXp6fXcQgoBa8Q05GC0d5NK69dpolMr9S6iAs4siZEMrfbUmtMKBdPc3HRMn4EOxqWEmbG7v60KFU+qCaCgNY09I6N7ZiXXgQu63dU/wCQj/kISiLZaYLvGsDwghYMRONY3JV5qABxFKIBGqa6B7HbEUlMEa3fTa4ufzz8CJqBwjkYcUFXpE6PRntGtEYZhQA1oxbb1/KNrdn7UDKkzq8TqUmKxpHG9qRHlIOpCkR0Rw/Qv5kweq3NWrljWPHItXKruv5htbs/agFVdhoGhf0j1l5qYmUM6+RCyLdNXKXK6eJ+ix1PFH/AG1uz9qAw6gRMIm5A8FBQOB1OE3zowzLVEq6EKaiYR4ZdrNc4Of8ASOkEi5x27H8CnS/zDa3Z+5AIBrg7cGSMYCqb1jQ9WnaG2yrsrdmpegGZqY9oy0YhbZH9Oo5JqqyEllG6bO5+UbW7P4EGlCpjHDWE5GxlaZUhAOcPoVG2simH1dkOH+JsxMBXVkYR2D6vyja3Z+1ACtGVgv2KJqSa0Voc0w2/lW+gOiP1spi+06U6iFnaFqKER0RmcXtIIPyDa3Z+xBTTgpyHLW9G0oL+gEJoHVh9xDiJkoGtQoqZKYptrGOIh3iC3uEOEqmtuVu9hldb0u2bWaVXVolwO9Xuz90z0uLav5Btbs/ag3EfuTyuyW73Z0uFwEhaMiJqJoxBKZWNJRWkw5iYhN2UrxVCYchfN1+MzIKgNZgLl6Qki4q9JKnGNulH1PttKbCrO+6PUStOFuL9CadWoAzqH+aJTD9m+4QPNtHUbGI90gYBXtJwl6o1pva/8a36W/53/8QAOxEAAQIEAAkICQQDAAAAAAAAAQIDAAQFEQYHEiExQVFxkRUgUmGBobHREBMUFzM1U3LBFkDh8CMkMv/aAAgBAgEBPwBmkPOICk2sY5Df6om5NbCglcSVIU8kLKrAxNyxacLZ1cwNLIuBHs6uieEezudE8I9nc6J4R7O50Twim/ATuhFs2n+7Yq0uhak5RIzac35zxTgEspSDeKukGYVfRmhxpFroBhDRJsQbQ6ygZhe/XAm3W2WwlVrg6uuOVJjTl90cpv8AS7hHKj97ZfcIFVf6XcIph/wpz6oCtGf+Yq7icpN16tgMU5QLSbG/d3RWRZ1XZ4RKzZQ0qw0W1mJepKU4kEawNJ84ccKnLn+8YJJZbsNvjFjbRCgdkAG+iEJNtESjHq20oOr0Tsk66oFCskRLMqQgJWbmJ6kF5wrCrXhNBUEKRlabatl4awfUlQVlaOqFUAleVl69kMyRSyGSf7e8T1IDigWyE9kcgr6fdHIK+n3R+n19Lu/YVOpsybJffNkjt0x7w6X9U8D5R7w6X9U8D5R7w6X9U8D5R7w6X9U8D5RKTSH2kvNm6VC43RUqzKyacuZWE+J3DTBxlUy9rngYpVflJ0f67gV1a+Bz83DSnvTVPW0wm6jbN2iP0LVPoniIqVKfk3PVTCclVr9kUmhzM8VCWTlZOnOBp3x+gqr9LvHnEgsyNLQp8WKE5xuGiKnUnpt9T7xuT3dQ6oZwGqS2Q8lrMc9ri/CKMxOe1JTKA+sB4b+rbeJYuFtJdACrZ7aL67c7Gf8AMB9o8TGKf4kxuH59GFTCnac8lGnJMJVYg7IoGGMnPpASrJX0TmN+rbDMo02pS0JAKs5O3fz8Z/zAfaPExin+JMbh+fThXi9dQ4p+RF0nPk6xu2iFoUgkKFiOMUHD6clCEOHLRsOnsPnFNqLU2ymYZN0q52M/5gPtHiYxT/EmNw/Ppk6tLPrW2ysKKdNtUVfB6TnU2fQCduvjGFFE5PnFS4NxpG4xiom1KbeYOgEEdt7+HOxn/MB9o8TGKf4kxuH59GH1Pm35W8qo5v8ApI1jxzbNcU6pPyjoeYVkqEDGnPZNshN9ufzio1F2aeU++bqMYuaGuVlC64LKcz26ho8b87CDAmXqL4fdWoEC2a3XtHXGDeCLNMUtTSicq2m2q+wdfprWAsjOqLhTkqOtOa+8aIOKdF8z5t9v8xR8XUlKqDi7rUNujh53/Yf/xAA5EQABAgQACQkIAwEBAAAAAAABAgMABAURBgcSITFBUXGhEBMgM1JTgZHBFBUXNWFysdEWIkAj4f/aAAgBAwEBPwByfbSopOqPeTUMzCXBdMTE8lslNrmGHQtIUOgVpGYmOcTtjnk7Y55O2OeTtid61W+CDniRdUlJsNcTlytRIiQJ5oQhZv8A2IhSxbMYQsnTaOZQtxRUL6IEk12eMextdnjHsbXZ4x7G12eJidH/AFVm1wRpzRIIOSf669tom8y1XEU83bHjDzOU4DeHZQBCiD+P1CUWRaB1i/CARfTGbbFxthQz6YmHctZVt5JWZQgWUm8POhaiUiwiVqAbSEkQqppKgrJ0QuqpKSMmBVU5NsmHJkF3nAIlp/IBCxePeyOzxj3sjsx72R2eP+Cm052bdDLIuox8Pap3fER8Pap3fER8Pap3fER8Pap3fERNyq2HVMuCykmxim0eZnFZEugq/A3nRAxbVK18keYiq0GakjaYQU/XV5jN0cDqg1Kz6HXlWSL5/Ax/OaX3vA/qKbVZebb52XVlJvaKpW5aTCTMryb6PCP51TO94GJ9InqmpLBuFqzHedMUymNSjKWWRYDj9TDmHNNQ6Wi5nGa9jbzisvyfsqlTShzZHnu+sTIbDig0SU3zX021X6WLH5efuPpGNfq2N59OTBd9LdQZWrRlCFpygQYr2B83IqJUm6O0NFvrs8YdmnXEpQtRITmA2bunix+Xn7j6RjX6tjefTlwUxhNKQlidNlDMFajv2GG1oWkKSbgxXsApSbBW2Mhe0aPERUae7KvKZeFlDpYsfl5+4+kY1+rY3n05ZqlTDDaXXUFIVovrik4QTckq7CyBs1eUYL1sz8ol9QsdB3iMasolLjL40kEHwtb89LFj8vP3H0jGv1bG8+nJgHUJRiatNJGfQo6j+M8VGmszbRZfTdJg4rZPLvlqtszfqKbTWpRlLDIskRjDriJubDTZulGbxOn9dLB/DZ+nslltCSCb57+hjCTCx6pBAdSBk30X122n6ctGw5npNIbSrKSNSs/kdMDGuu2dgX3/APkVfGFOzaC2myEnZp8/8H//2Q==)

#### TypeScript Brazil Meetup

üáßüá∑  
[Website](https://www.meetup.com/typescriptbr "Website for TypeScript Brazil
Meetup") [Twitter](https://twitter.com/tsbrmeetup "Twitter page for TypeScript
Brazil Meetup")

![logo of TypeScript JP](/static/typescript-jp-
bed04107658e1301111868439cd400a5.jpg)

#### TypeScript JP

üáØüáµ  
[Website](https://typescript-jp.dev "Website for TypeScript JP")
[Twitter](https://twitter.com/typescriptjp "Twitter page for TypeScript JP")

![logo of Paris
TypeScript](data:image/jpeg;base64,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)

#### Paris TypeScript

üá´üá∑  
[Website](https://www.meetup.com/Paris-Typescript "Website for Paris
TypeScript") [Twitter](https://twitter.com/ParisTypeScript "Twitter page for
Paris TypeScript")

![logo of Phoenix TypeScript](/static/phx-
ts-65691ca201f8f26bfbc291bdbf6767dd.jpg)

#### Phoenix TypeScript

üá∫üá∏  
[Website](https://www.meetup.com/Phoenix-TypeScript "Website for Phoenix
TypeScript")

![logo of Wroclaw
TypeScript](data:image/jpeg;base64,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)

#### Wroclaw TypeScript

üáµüá±  
[Website](https://typescript.community/ "Website for Wroclaw TypeScript")
[Twitter](https://twitter.com/WrocTypeScript "Twitter page for Wroclaw
TypeScript")

 # Connect with us

## Online

Tell us what‚Äôs working well, what you want to see added or improved, and find
out about new updates.

### [Stack Overflow](https://stackoverflow.com/questions/tagged/typescript
"TypeScript tag on Stack Overflow")Engage with your peers and ask questions
about TypeScript using the tag 'typescript'

### [Chat](https://discord.gg/typescript "TypeScript Community on
Discord")Chat with other TypeScript users in the TypeScript Community Chat.

### [GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create
a new GitHub Issue on the TypeScript repo")Found a bug, or want to give us
constructive feedback? [Tell us on
GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create a
new GitHub Issue on the TypeScript repo")

### [Twitter](https://twitter.com/typescript "The TypeScript team on
Twitter")Stay up to date. Follow us on Twitter
[@typescript](https://twitter.com/typescript "The TypeScript team on
Twitter")!

### [Blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")Learn about the latest TypeScript developments via our
[blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")!

### [Definitely
Typed](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type
definitions")TypeScript definition files. [Browse the thousands
of](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type definitions")
available for common libraries and frameworks.

## Connect in person

ConferencesUpcoming EventsMeetups

### Conferences

[![logo of  TSConf:EU](\[object Module\])](https://tsconf.eu "Link to
TSConf:EU")#### [TSConf:EU](https://tsconf.eu)

Linz Austria  
March 31st, 2020

## Conferences

Hello

### Meetups

![logo of Boston TypeScript Club](/static/boston-ts-
club-8ed5db84c1ef76a9b7629d936da92973.png)

#### Boston TypeScript Club

üá∫üá∏  
[Website](https://bostonts.club "Website for Boston TypeScript Club")

![logo of Hamburg
TypeScript](data:image/png;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QCiRXhpZgAATU0AKgAAAAgABgESAAMAAAABAAEAAAEaAAUAAAABAAAAVgEbAAUAAAABAAAAXgEoAAMAAAABAAIAAAExAAIAAAAVAAAAZodpAAQAAAABAAAAfAAAAAAAAABIAAAAAQAAAEgAAAABUGl4ZWxtYXRvciBQcm8gMS41LjIAAAACoAIABAAAAAEAAADIoAMABAAAAAEAAADIAAAAAP/hCZlodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IlBpeGVsbWF0b3IgUHJvIDEuNS4yIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTExLTMwVDAyOjI3OjE2WiIvPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz4A/+0AOFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAAOEJJTQQlAAAAAAAQ1B2M2Y8AsgTpgAmY7PhC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)

#### Hamburg TypeScript

üá©üá™  
[Website](https://www.meetup.com/Hamburg-TypeScript-Meetup-Group "Website for
Hamburg TypeScript")

![logo of Krakow TypeScript User
Group](/static/ktug-d861e06684ad664e628d59cba8a96e5c.jpg)

#### Krakow TypeScript User Group

üáµüá±  
[Website](https://www.meetup.com/typescript-krakow "Website for Krakow
TypeScript User Group")

![logo of Melbourne
TypeScript](/static/melbourne-5eb843a1b0ccd09bb6cfcb339b9b8a5d.jpg)

#### Melbourne TypeScript

üá¶üá∫  
[Website](https://www.meetup.com/Melbourne-TypeScript-Meetup "Website for
Melbourne TypeScript")

![logo of Milano
TS](data:image/jpeg;base64,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)

#### Milano TS

üáÆüáπ  
[Website](https://www.meetup.com/MilanoTS/ "Website for Milano TS")
[Twitter](https://twitter.com/Milano_TS "Twitter page for Milano TS")

![logo of Seattle
TypeScript](data:image/jpeg;base64,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)

#### Seattle TypeScript

üá∫üá∏  
[Website](https://www.meetup.com/seattle-ts "Website for Seattle TypeScript")

![logo of Sevilla
TypeScript](data:image/jpeg;base64,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)

#### Sevilla TypeScript

üá™üá∏  
[Website](https://www.meetup.com/Sevilla-TypeScript "Website for Sevilla
TypeScript") [Twitter](https://twitter.com/SVQTypeScript "Twitter page for
Sevilla TypeScript")

![logo of San Francisco TypeScript Meetup](/static/san-fran-
ts-6a81c173960965f62590310db2b4b93c.jpg)

#### San Francisco TypeScript Meetup

üá∫üá∏  
[Website](https://www.meetup.com/San-Francisco-TypeScript-Meetup "Website for
San Francisco TypeScript Meetup")

![logo of Sydney
TypeScript](data:image/jpeg;base64,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)

#### Sydney TypeScript

üá¶üá∫  
[Website](https://www.meetup.com/Sydney-TypeScript "Website for Sydney
TypeScript") [Twitter](https://twitter.com/SydTypeScript "Twitter page for
Sydney TypeScript")

![logo of TypeScript
NYC](data:image/jpeg;base64,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)

#### TypeScript NYC

üá∫üá∏  
[Website](https://www.meetup.com/NYC-Typescript "Website for TypeScript NYC")

![logo of TypeScript Brazil
Meetup](data:image/jpeg;base64,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)

#### TypeScript Brazil Meetup

üáßüá∑  
[Website](https://www.meetup.com/typescriptbr "Website for TypeScript Brazil
Meetup") [Twitter](https://twitter.com/tsbrmeetup "Twitter page for TypeScript
Brazil Meetup")

![logo of TypeScript JP](/static/typescript-jp-
bed04107658e1301111868439cd400a5.jpg)

#### TypeScript JP

üáØüáµ  
[Website](https://typescript-jp.dev "Website for TypeScript JP")
[Twitter](https://twitter.com/typescriptjp "Twitter page for TypeScript JP")

![logo of Paris
TypeScript](data:image/jpeg;base64,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)

#### Paris TypeScript

üá´üá∑  
[Website](https://www.meetup.com/Paris-Typescript "Website for Paris
TypeScript") [Twitter](https://twitter.com/ParisTypeScript "Twitter page for
Paris TypeScript")

![logo of Phoenix TypeScript](/static/phx-
ts-65691ca201f8f26bfbc291bdbf6767dd.jpg)

#### Phoenix TypeScript

üá∫üá∏  
[Website](https://www.meetup.com/Phoenix-TypeScript "Website for Phoenix
TypeScript")

![logo of Wroclaw
TypeScript](data:image/jpeg;base64,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)

#### Wroclaw TypeScript

üáµüá±  
[Website](https://typescript.community/ "Website for Wroclaw TypeScript")
[Twitter](https://twitter.com/WrocTypeScript "Twitter page for Wroclaw
TypeScript")

 Downloading TypeScript...

  * Version...... 

  * ‚á•

  # Your toys, our sandbox

The new TypeScript Playground allows people to hook into the Playground and
extend it in ways in which the TypeScript team don't expect.

The sidebar of the Playground uses the same plugin infrastructure as external
plugins, so you have the same level of access as the playground to build
interesting projects.

Playground plugins are built via the DOM API and an expansive Design System,
however, you're free to use a framework like React or Svelte at runtime.

Getting started is easy, we have a plugin template, and the Playground has a
dev-mode for hooking directly to your local server, so you don't need to run a
copy of the TypeScript website to have a working development environment.

There is a repo of sample plugins at [microsoft/TypeScript-Playground-
Samples](https://github.com/microsoft/TypeScript-Playground-Samples/) and
there are many existing open source plugins to look at too: [Presentation
Mode](https://github.com/orta/playground-slides),
[Clippy](https://github.com/orta/playground-clippy#playground-plugin-clippy)
[TSQuery](https://github.com/orta/playground-plugin-tsquery),
[Collaborate](https://github.com/orta/playground-collaborate#typescript-
playground-collaborate) and [Transformer](https://github.com/orta/playground-
transformer-timeline) which are available by default for you to investigate
and understand.

If you have questions as you are working on your plugin, ask in the
[TypeScript Community Discord](https://discord.gg/typescript). When it is
polished, ship it to the npm registry and it will make its way into the
plugins sidebar.

![Screenshot of the playground showing the plugins tab](/static/playground-
plugin-preview-3fa319f7efff676f839a57ad3d8be916.png)

## Quick Tutorial

You need about 5 minutes, Node.js, yarn and Firefox/Edge or Chrome.

**Step 1** : Use the template to bootstrap: `yarn create typescript-
playground-plugin playground-my-plugin`

**Step 2** : Run `yarn start` in the new repo, to start up the local dev
server

**Step 3** : Open the [playground](/play/) in your browser, click "Options"
and enable `"Connect to localhost:5000/index.js"`

**Step 4** : Refresh, and see the new tab. That's your plugin up and running

That's all the pieces working in tandem, now you can make changes to the
template and build out your plugin. The plugin in dev mode will always become
forefront when connected, so you can re-load without a lot of clicks. To
understand the template's technology, read the
[CONTRIBUTING.md](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/create-typescript-playground-
plugin/template/CONTRIBUTING.md)

## Alternatives

There are community-run templates for Playground plugins which bootstrap your
plugin with well-known view libraries:

  * [gojutin/typescript-playground-plugin-react](https://github.com/gojutin/typescript-playground-plugin-react#typescript-playground-plugin-react)
  * [gojutin/typescript-playground-plugin-svelte](https://github.com/gojutin/typescript-playground-plugin-svelte#typescript-playground-plugin-svelte)

They have their own up-to-date documentation in their READMEs.

 # TypeScript Sandbox

A DOM library for interacting with TypeScript and JavaScript code, which
powers the heart of the [TypeScript playground](/play/)

You can use the TypeScript sandbox for:

  * Building IDE-like experiences for people to explore your library's API
  * Building interactive web tools which use TypeScript, with a lot of the Playgrounds developer experience for free

For example, the sandbox to the side has grabbed the Types for
[DangerJS](https://danger.systems/js/) with no modifications for this code
sample. This is because the Playground's Automatic Type Acquisition is enabled
by default. It will also look for the same parameters for code, and selection
indexes inside the URL.

Try clicking [this
URL](?q=1#code/PTAEBUAsFMGdtAYwPYFtXQHYBdagO7QBOCiJAhttACagCWmo2MEAngA7QDKZd72oAAoAbcqwDmRZAFdM1AFAhQ5OUxiNmCAKoAlADKhI5WJALGkydnRqhkAN2JNkahJmj5QuvfMVgodPAwVPBVWUHYpACtoRAFpWAZxNk4eIj4BWBVqACNkAA84JBVfUGhjOmEw+FUUagRyKVlabGcyxFNkTSJQHxRMWAEYYWFnAF5QACIACWhh5wB1ZCJhagn5PthkYWgAOhHxAAohkYBKIA)
to see that in action.

This library builds on top of the [Monaco
Editor](https://microsoft.github.io/monaco-editor/index.html), providing a
higher level API but offering access to all the lower-level APIs via a single
`sandbox` object.

You can find the code for the TypeScript Sandbox inside the
[microsoft/TypeScript-Website](https://github.com/microsoft/TypeScript-
Website/tree/v2/packages/sandbox#@typescript/sandbox) mono-repo.

Downloading Sandbox...

## Usage

A sandbox uses the same tools as monaco-editor, meaning this library is
shipped as an AMD bundle which you can use the [VSCode
Loader](https://github.com/microsoft/vscode-loader/) to `require`.

Because we need it for the TypeScript website, you can use our hosted copy
[here.](https://typescriptlang.org/js/vs.loader.js "Link to the JS for the
visual studio require loader")

### Get Started

Create a new file: `index.html` and paste this code into that file.

    
    
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
      </head>
      <div id="loader">Loading...</div>
      <div id="monaco-editor-embed" style="height: 800px;" />
      <script>
        // First set up the VSCode loader in a script tag
        const getLoaderScript = document.createElement('script')
        getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'
        getLoaderScript.async = true
        getLoaderScript.onload = () => {
          // Now the loader is ready, tell require where it can get the version of monaco, and the sandbox
          // This version uses the latest version of the sandbox, which is used on the TypeScript website
    
          // For the monaco version you can use unpkg or the TypeSCript web infra CDN
          // You can see the available releases for TypeScript here:
          // https://playgroundcdn.typescriptlang.org/indexes/releases.json
          //
          require.config({
            paths: {
              vs: 'https://playgroundcdn.typescriptlang.org/cdn/4.0.5/monaco/min/vs',
              // vs: 'https://unpkg.com/@typescript-deploys/monaco-editor@4.0.5/min/vs',
              sandbox: 'https://www.typescriptlang.org/js/sandbox',
            },
            // This is something you need for monaco to work
            ignoreDuplicateModules: ['vs/editor/editor.main'],
          })
    
          // Grab a copy of monaco, TypeScript and the sandbox
          require(['vs/editor/editor.main', 'vs/language/typescript/tsWorker', 'sandbox/index'], (
            main,
            _tsWorker,
            sandboxFactory
          ) => {
            const initialCode = `import {markdown, danger} from "danger"
    
    export default async function () {
        // Check for new @types in devDependencies
        const packageJSONDiff = await danger.git.JSONDiffForFile("package.json")
        const newDeps = packageJSONDiff.devDependencies.added
        const newTypesDeps = newDeps?.filter(d => d.includes("@types")) ?? []
        if (newTypesDeps.length){
            markdown("Added new types packages " + newTypesDeps.join(", "))
        }
    }
    `
    
            const isOK = main && window.ts && sandboxFactory
            if (isOK) {
              document.getElementById('loader').parentNode.removeChild(document.getElementById('loader'))
            } else {
              console.error('Could not get all the dependencies of sandbox set up!')
              console.error('main', !!main, 'ts', !!window.ts, 'sandbox', !!sandbox)
              return
            }
    
            // Create a sandbox and embed it into the div #monaco-editor-embed
            const sandboxConfig = {
              text: initialCode,
              compilerOptions: {},
              domID: 'monaco-editor-embed',
            }
    
            const sandbox = sandboxFactory.createTypeScriptSandbox(sandboxConfig, main, window.ts)
            sandbox.editor.focus()
          })
        }
    
        document.body.appendChild(getLoaderScript)
      </script>
    </html>

Opening the file `index.html` in a web browser will load up the same sandbox
up at the top of the page.

### Some examples of the API

Converting the user's TypeScript into JavaScript

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    // Async because it needs to go  
    const js = await sandbox.getRunnableJS()
    console.log(js)

Get the DTS for the user's editor

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    const dts = await sandbox.getDTSForCode()
    console.log(dts)

Make a request for an LSP response

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    // A worker here is a web-worker, set up by monaco-typescript
    // which does the computation in the background 
    const worker = await sandbox.getWorkerProcess()
    const definitions =  await client.getDefinitionAtPosition(model.uri.toString(), 6)

Change compiler flags using a few different APIs

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    // Hook in to all changes to the compiler
    sandbox.setDidUpdateCompilerSettings((newOptions) => {
      console.log("Compiler settings changed: ", newOptions)
    })
    
    // Update via key value
    sandbox.updateCompilerSetting("allowJs", true)
    // Update via an object
    sandbox.updateCompilerSettings({ jsx: 0 })
    // Replace the compiler settings
    sandbox.setCompilerSettings({})

Highlight some code in the editor

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    const start = {
      lineNumber: 0,
      column: 0
    }
    
    const end = {
      lineNumber: 0,
      column: 4
    }
    
    const decorations = sandbox.editor.deltaDecorations([], [
      {
        range: new sandbox.monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column),
        options: { inlineClassName: 'error-highlight' },
      },
    ])

Create your own playground.

    
    
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    
    // Use a script to make a JSON file like:
    // { 
    //   "file:///node_modules/types/keyboard/index.d.ts": "export const enterKey: string"
    // }
    //
    // Where the keys are the paths, and the values are the source-code. The sandbox
    // will use the node resolution lookup strategy by default.
    
    const dtsFiles = {} 
    
    Object.keys(dtsFiles).forEach(path => {
      sandbox.languageServiceDefaults.addExtraLib(dts[path], path);
    });

The API is mainly a light shim over the [monaco-editor
API](https://microsoft.github.io/monaco-editor/api/index.html) with the
[monaco-typescript API](https://github.com/microsoft/monaco-typescript).

 # TypeScript Twoslash

A markup format for TypeScript code, ideal for creating self-contained code
samples which let the TypeScript compiler do the extra leg-work.

If you know TypeScript, you basically know twoslash.

Twoslash adds the ability to declare tsconfig options inline, split a sample
into multiple files and a few other useful commands. You can see the full API
[inside the README](https://github.com/microsoft/TypeScript-
Website/tree/v2/packages/ts-twoslasher)

The Twoslash markup language helps with:

  * Enforcing accurate errors from a TypeScript code sample, and leaving the messaging to the compiler
  * Splitting a code sample to hide distracting code
  * Declaratively highlighting symbols in your code sample
  * Replacing code with the results of transpilation to different files, or ancillary files like .d.ts or .map files
  * Handle multi-file imports in a single code sample
  * Creating a playground link for the code

### Markup

See how TS Twoslash will grab the highlight information for identifiers in
your code

Downloading Sandbox...

Highlights runtime types

Show Errors

Set Compiler Flags

Trims code

Show the JS

Show the DTS

Highlights

### Results

## Usage

Twoslash's usage guide is available on the npm README at
[`@typescript/twoslash`](https://www.npmjs.com/package/@typescript/twoslash).

 # TypeScript Twoslash

A markup format for TypeScript code, ideal for creating self-contained code
samples which let the TypeScript compiler do the extra leg-work.

If you know TypeScript, you basically know twoslash.

Twoslash adds the ability to declare tsconfig options inline, split a sample
into multiple files and a few other useful commands. You can see the full API
[inside the README](https://github.com/microsoft/TypeScript-
Website/tree/v2/packages/ts-twoslasher)

The Twoslash markup language helps with:

  * Enforcing accurate errors from a TypeScript code sample, and leaving the messaging to the compiler
  * Splitting a code sample to hide distracting code
  * Declaratively highlighting symbols in your code sample
  * Replacing code with the results of transpilation to different files, or ancillary files like .d.ts or .map files
  * Handle multi-file imports in a single code sample
  * Creating a playground link for the code

### Markup

See how TS Twoslash will grab the highlight information for identifiers in
your code

Downloading Sandbox...

Highlights runtime types

Show Errors

Set Compiler Flags

Trims code

Show the JS

Show the DTS

Highlights

### Results

## Usage

Twoslash's usage guide is available on the npm README at
[`@typescript/twoslash`](https://www.npmjs.com/package/@typescript/twoslash).

 # Easy access to the compiler API

TypeScript VFS lets you create a self-contained TypeScript environment
entirely under your control. This library is used to power the Playground, and
provides the underlying tooling for [twoslash](/dev/twoslash/) code samples.

There are 3 main uses for TypeScript VFS:

  * Creating a TypeScript Program as an entry-point to the compiler API
  * Running TypeScript to emit files like `*.js`, `*.d.ts` or `*.map`
  * Using TypeScript's language service to make the same calls an editor would make

You can learn more in the [TypeScript VFS
README](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/typescript-vfs/)

### Setup with TypeScript from node_modules

    
    
    import ts from 'typescript'
    import tsvfs from '@typescript/vfs'
    
    const fsMap = tsvfs.createDefaultMapFromNodeModules({ target: ts.ScriptTarget.ES2015 })
    fsMap.set('index.ts', 'console.log("Hello World")')
    
    // ....
                  

### Use the TypeScript CDN to get your lib.d.ts files

    
    
    import ts from 'typescript'
    import tsvfs from '@typescript/vfs'
    
    const fsMap = await tsvfs.createDefaultMapFromCDN(compilerOptions, ts.version, true, ts)
    fsMap.set('index.ts', 'console.log("Hello World")')
    
    const system = tsvfs.createSystem(fsMap)
    const host = tsvfs.createVirtualCompilerHost(system, compilerOptions, ts)
    
    const program = ts.createProgram({
      rootNames: [...fsMap.keys()],
      options: compilerOptions,
      host: host.compilerHost,
    })
    
    // This will update the fsMap with new files
    // for the .d.ts and .js files
    program.emit()
    
    // Now I can look at the AST for the .ts file too
    const index = program.getSourceFile('index.ts')
                  

 # TypeScript Documentation

#### Get Started

Quick introductions based on your background or preference.

  * [TS for the New Programmer](/docs/handbook/typescript-from-scratch.html)
  * [TypeScript for JS Programmers](/docs/handbook/typescript-in-5-minutes.html)
  * [TS for Java/C# Programmers](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [TS for Functional Programmers](/docs/handbook/typescript-in-5-minutes-func.html)
  * [TypeScript Tooling in 5 minutes](/docs/handbook/typescript-tooling-in-5-minutes.html)

#### Handbook

A great first read for your daily TS work.

  * [The TypeScript Handbook](/docs/handbook/intro.html)
  * [The Basics](/docs/handbook/2/basic-types.html)
  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Narrowing](/docs/handbook/2/narrowing.html)
  * [More on Functions](/docs/handbook/2/functions.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * Type Manipulation
  *     * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
    * [Generics](/docs/handbook/2/generics.html)
    * [Keyof Type Operator](/docs/handbook/2/keyof-types.html)
    * [Typeof Type Operator](/docs/handbook/2/typeof-types.html)
    * [Indexed Access Types](/docs/handbook/2/indexed-access-types.html)
    * [Conditional Types](/docs/handbook/2/conditional-types.html)
    * [Mapped Types](/docs/handbook/2/mapped-types.html)
    * [Template Literal Types](/docs/handbook/2/template-literal-types.html)
  * [Classes](/docs/handbook/2/classes.html)
  * [Modules](/docs/handbook/2/modules.html)

#### Reference

Deep dive reference materials.

  * [Utility Types](/docs/handbook/utility-types.html)
  * [Cheat Sheets](/cheatsheets/)
  * [Decorators](/docs/handbook/decorators.html)
  * [Declaration Merging](/docs/handbook/declaration-merging.html)
  * [Enums](/docs/handbook/enums.html)
  * [Iterators and Generators](/docs/handbook/iterators-and-generators.html)
  * [JSX](/docs/handbook/jsx.html)
  * [Mixins](/docs/handbook/mixins.html)
  * [Namespaces](/docs/handbook/namespaces.html)
  * [Namespaces and Modules](/docs/handbook/namespaces-and-modules.html)
  * [Symbols](/docs/handbook/symbols.html)
  * [Triple-Slash Directives](/docs/handbook/triple-slash-directives.html)
  * [Type Compatibility](/docs/handbook/type-compatibility.html)
  * [Type Inference](/docs/handbook/type-inference.html)
  * [Variable Declaration](/docs/handbook/variable-declarations.html)

#### Modules Reference

How TypeScript models JavaScript modules.

  * [Introduction](/docs/handbook/modules/introduction.html)
  * [Theory](/docs/handbook/modules/theory.html)
  * Guides
  *     * [Choosing Compiler Options](/docs/handbook/modules/guides/choosing-compiler-options.html)
  * [Reference](/docs/handbook/modules/reference.html)
  * Appendices
  *     * [ESM/CJS Interoperability](/docs/handbook/modules/appendices/esm-cjs-interop.html)

#### Tutorials

Using TypeScript in several environments.

  * [ASP.NET Core](/docs/handbook/asp-net-core.html)
  * [Gulp](/docs/handbook/gulp.html)
  * [DOM Manipulation](/docs/handbook/dom-manipulation.html)
  * [Migrating from JavaScript](/docs/handbook/migrating-from-javascript.html)
  * [Using Babel with TypeScript](/docs/handbook/babel-with-typescript.html)

#### Declaration Files

Learn how to write declaration files to describe existing JavaScript.
Important for DefinitelyTyped contributions.

  * [Introduction](/docs/handbook/declaration-files/introduction.html)
  * [Declaration Reference](/docs/handbook/declaration-files/by-example.html)
  * [Library Structures](/docs/handbook/declaration-files/library-structures.html)
  * .d.ts Templates
  *     * [Modules .d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html)
    * [Module: Plugin](/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)
    * [Module: Class](/docs/handbook/declaration-files/templates/module-class-d-ts.html)
    * [Module: Function](/docs/handbook/declaration-files/templates/module-function-d-ts.html)
    * [Global .d.ts](/docs/handbook/declaration-files/templates/global-d-ts.html)
    * [Global: Modifying Module](/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)
  * [Do's and Don'ts](/docs/handbook/declaration-files/do-s-and-don-ts.html)
  * [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
  * [Publishing](/docs/handbook/declaration-files/publishing.html)
  * [Consumption](/docs/handbook/declaration-files/consumption.html)

#### JavaScript

How to use TypeScript-powered JavaScript tooling.

  * [JS Projects Utilizing TypeScript](/docs/handbook/intro-to-js-ts.html)
  * [Type Checking JavaScript Files](/docs/handbook/type-checking-javascript-files.html)
  * [JSDoc Reference](/docs/handbook/jsdoc-supported-types.html)
  * [Creating .d.ts Files from .js files](/docs/handbook/declaration-files/dts-from-js.html)

#### Project Configuration

Compiler configuration reference.

  * [What is a tsconfig.json](/docs/handbook/tsconfig-json.html)
  * [Compiler Options in MSBuild](/docs/handbook/compiler-options-in-msbuild.html)
  * [TSConfig Reference](/tsconfig/)
  * [tsc CLI Options](/docs/handbook/compiler-options.html)
  * [Project References](/docs/handbook/project-references.html)
  * [Integrating with Build Tools](/docs/handbook/integrating-with-build-tools.html)
  * [Configuring Watch](/docs/handbook/configuring-watch.html)
  * [Nightly Builds](/docs/handbook/nightly-builds.html)

#### Cheat Sheets

Downloadable syntax reference pages for different parts of everyday TypeScript
code.

  * [Control Flow Analysis](/static/TypeScript Control Flow Analysis-8a549253ad8470850b77c4c5c351d457.png)
  * [Classes](/static/TypeScript Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png)
  * [Interfaces](/static/TypeScript Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png)
  * [Types](/static/TypeScript Types-ae199d69aeecf7d4a2704a528d0fd3f9.png)
  * [Download PDFs and PNGs](/assets/typescript-cheat-sheets.zip)

## Learning Resources

#### Get Started

  * [JS to TS](/docs/handbook/typescript-in-5-minutes.html)
  * [New to Programming](/docs/handbook/typescript-from-scratch.html)
  * [OOP to JS](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [Functional to JS](/docs/handbook/typescript-in-5-minutes-func.html)
  * [Installation](/download/)

#### Handbook

  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * [Variable Declarations](/docs/handbook/variable-declarations.html)
  * [More on Functions](/docs/handbook/2/functions.html)

#### Tools

  * [Playground](/play/)
  * [TSConfig Reference](/tsconfig/)

#### Release Notes

  * [What's new in 5.6](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/)

#### Tutorials

  * [ASP.NET](/docs/handbook/asp-net-core.html)
  * [Migrating from JS](/docs/handbook/migrating-from-javascript.html)
  * [Working with the DOM](/docs/handbook/dom-manipulation.html)
  * [React & Webpack](/docs/handbook/react-&-webpack.html)

 Was this page helpful?

# The Basics

Welcome to the first page of the handbook. If this is your first experience
with TypeScript - you may want to start at one of the '[Getting
Started](https://www.typescriptlang.org/docs/handbook/intro.html#get-started)'
guides

Each and every value in JavaScript has a set of behaviors you can observe from
running different operations. That sounds abstract, but as a quick example,
consider some operations we might run on a variable named `message`.

    
    
    js
    
    // Accessing the property 'toLowerCase'
    
    // on 'message' and then calling it
    
    message.toLowerCase();
    
    // Calling 'message'
    
    message();

If we break this down, the first runnable line of code accesses a property
called `toLowerCase` and then calls it. The second one tries to call `message`
directly.

But assuming we don‚Äôt know the value of `message` \- and that‚Äôs pretty common
- we can‚Äôt reliably say what results we‚Äôll get from trying to run any of this
code. The behavior of each operation depends entirely on what value we had in
the first place.

  * Is `message` callable?
  * Does it have a property called `toLowerCase` on it?
  * If it does, is `toLowerCase` even callable?
  * If both of these values are callable, what do they return?

The answers to these questions are usually things we keep in our heads when we
write JavaScript, and we have to hope we got all the details right.

Let‚Äôs say `message` was defined in the following way.

    
    
    js
    
    const message = "Hello World!";

As you can probably guess, if we try to run `message.toLowerCase()`, we‚Äôll get
the same string only in lower-case.

What about that second line of code? If you‚Äôre familiar with JavaScript,
you‚Äôll know this fails with an exception:

    
    
    txt
    
    TypeError: message is not a function

It‚Äôd be great if we could avoid mistakes like this.

When we run our code, the way that our JavaScript runtime chooses what to do
is by figuring out the _type_ of the value - what sorts of behaviors and
capabilities it has. That‚Äôs part of what that `TypeError` is alluding to -
it‚Äôs saying that the string `"Hello World!"` cannot be called as a function.

For some values, such as the primitives `string` and `number`, we can identify
their type at runtime using the `typeof` operator. But for other things like
functions, there‚Äôs no corresponding runtime mechanism to identify their types.
For example, consider this function:

    
    
    js
    
    function fn(x) {
    
      return x.flip();
    
    }

We can _observe_ by reading the code that this function will only work if
given an object with a callable `flip` property, but JavaScript doesn‚Äôt
surface this information in a way that we can check while the code is running.
The only way in pure JavaScript to tell what `fn` does with a particular value
is to call it and see what happens. This kind of behavior makes it hard to
predict what the code will do before it runs, which means it‚Äôs harder to know
what your code is going to do while you‚Äôre writing it.

Seen in this way, a _type_ is the concept of describing which values can be
passed to `fn` and which will crash. JavaScript only truly provides _dynamic_
typing - running the code to see what happens.

The alternative is to use a _static_ type system to make predictions about
what the code is expected to do _before_ it runs.

## Static type-checking

Think back to that `TypeError` we got earlier from trying to call a `string`
as a function. _Most people_ don‚Äôt like to get any sorts of errors when
running their code - those are considered bugs! And when we write new code, we
try our best to avoid introducing new bugs.

If we add just a bit of code, save our file, re-run the code, and immediately
see the error, we might be able to isolate the problem quickly; but that‚Äôs not
always the case. We might not have tested the feature thoroughly enough, so we
might never actually run into a potential error that would be thrown! Or if we
were lucky enough to witness the error, we might have ended up doing large
refactorings and adding a lot of different code that we‚Äôre forced to dig
through.

Ideally, we could have a tool that helps us find these bugs _before_ our code
runs. That‚Äôs what a static type-checker like TypeScript does. _Static types
systems_ describe the shapes and behaviors of what our values will be when we
run our programs. A type-checker like TypeScript uses that information and
tells us when things might be going off the rails.

    
    
    ts
    
    const message = "hello!";
    
    ¬†
    
    message();
    
    This expression is not callable.
      Type 'String' has no call signatures.2349This expression is not callable.
      Type 'String' has no call signatures.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA)

Running that last sample with TypeScript will give us an error message before
we run the code in the first place.

## Non-exception Failures

So far we‚Äôve been discussing certain things like runtime errors - cases where
the JavaScript runtime tells us that it thinks something is nonsensical. Those
cases come up because [the ECMAScript
specification](https://tc39.github.io/ecma262/) has explicit instructions on
how the language should behave when it runs into something unexpected.

For example, the specification says that trying to call something that isn‚Äôt
callable should throw an error. Maybe that sounds like ‚Äúobvious behavior‚Äù, but
you could imagine that accessing a property that doesn‚Äôt exist on an object
should throw an error too. Instead, JavaScript gives us different behavior and
returns the value `undefined`:

    
    
    js
    
    const user = {
    
      name: "Daniel",
    
      age: 26,
    
    };
    
    user.location; // returns undefined

Ultimately, a static type system has to make the call over what code should be
flagged as an error in its system, even if it‚Äôs ‚Äúvalid‚Äù JavaScript that won‚Äôt
immediately throw an error. In TypeScript, the following code produces an
error about `location` not being defined:

    
    
    ts
    
    const user = {
    
      name: "Daniel",
    
      age: 26,
    
    };
    
    ¬†
    
    user.location;
    
    Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA)

While sometimes that implies a trade-off in what you can express, the intent
is to catch legitimate bugs in our programs. And TypeScript catches _a lot_ of
legitimate bugs.

For example: typos,

    
    
    ts
    
    const announcement = "Hello World!";
    
    ¬†
    
    // How quickly can you spot the typos?
    
    announcement.toLocaleLowercase();
    
    announcement.toLocalLowerCase();
    
    ¬†
    
    // We probably meant to write this...
    
    announcement.toLocaleLowerCase();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA)

uncalled functions,

    
    
    ts
    
    function flipCoin() {
    
      // Meant to be Math.random()
    
      return Math.random < 0.5;
    
    Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA)

or basic logic errors.

    
    
    ts
    
    const value = Math.random() < 0.5 ? "a" : "b";
    
    if (value !== "a") {
    
      // ...
    
    } else if (value === "b") {
    
    This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap.2367This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap.
    
      // Oops, unreachable
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA)

## Types for Tooling

TypeScript can catch bugs when we make mistakes in our code. That‚Äôs great, but
TypeScript can _also_ prevent us from making those mistakes in the first
place.

The type-checker has information to check things like whether we‚Äôre accessing
the right properties on variables and other properties. Once it has that
information, it can also start _suggesting_ which properties you might want to
use.

That means TypeScript can be leveraged for editing code too, and the core
type-checker can provide error messages and code completion as you type in the
editor. That‚Äôs part of what people often refer to when they talk about tooling
in TypeScript.

    
    
    ts
    
    import express from "express";
    
    const app = express();
    
    ¬†
    
    app.get("/", function (req, res) {
    
      res.sen
    
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†
    
      * send
      * sendDate
      * sendfile
      * sendFile
      * sendStatus
    
    
    
    });
    
    ¬†
    
    app.listen(3000);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA)

TypeScript takes tooling seriously, and that goes beyond completions and
errors as you type. An editor that supports TypeScript can deliver ‚Äúquick
fixes‚Äù to automatically fix errors, refactorings to easily re-organize code,
and useful navigation features for jumping to definitions of a variable, or
finding all references to a given variable. All of this is built on top of the
type-checker and is fully cross-platform, so it‚Äôs likely that [your favorite
editor has TypeScript support
available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-
Support).

## `tsc`, the TypeScript compiler

We‚Äôve been talking about type-checking, but we haven‚Äôt yet used our type-
_checker_. Let‚Äôs get acquainted with our new friend `tsc`, the TypeScript
compiler. First we‚Äôll need to grab it via npm.

    
    
    sh
    
    npm install -g typescript

> This installs the TypeScript Compiler `tsc` globally. You can use `npx` or
> similar tools if you‚Äôd prefer to run `tsc` from a local `node_modules`
> package instead.

Now let‚Äôs move to an empty folder and try writing our first TypeScript
program: `hello.ts`:

    
    
    ts
    
    // Greets the world.
    
    console.log("Hello world!");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA)

Notice there are no frills here; this ‚Äúhello world‚Äù program looks identical to
what you‚Äôd write for a ‚Äúhello world‚Äù program in JavaScript. And now let‚Äôs
type-check it by running the command `tsc` which was installed for us by the
`typescript` package.

    
    
    sh
    
    tsc hello.ts

Tada!

Wait, ‚Äútada‚Äù _what_ exactly? We ran `tsc` and nothing happened! Well, there
were no type errors, so we didn‚Äôt get any output in our console since there
was nothing to report.

But check again - we got some _file_ output instead. If we look in our current
directory, we‚Äôll see a `hello.js` file next to `hello.ts`. That‚Äôs the output
from our `hello.ts` file after `tsc` _compiles_ or _transforms_ it into a
plain JavaScript file. And if we check the contents, we‚Äôll see what TypeScript
spits out after it processes a `.ts` file:

    
    
    js
    
    // Greets the world.
    
    console.log("Hello world!");

In this case, there was very little for TypeScript to transform, so it looks
identical to what we wrote. The compiler tries to emit clean readable code
that looks like something a person would write. While that‚Äôs not always so
easy, TypeScript indents consistently, is mindful of when our code spans
across different lines of code, and tries to keep comments around.

What about if we _did_ introduce a type-checking error? Let‚Äôs rewrite
`hello.ts`:

    
    
    ts
    
    // This is an industrial-grade general-purpose greeter function:
    
    function greet(person, date) {
    
      console.log(`Hello ${person}, today is ${date}!`);
    
    }
    
    ¬†
    
    greet("Brendan");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA)

If we run `tsc hello.ts` again, notice that we get an error on the command
line!

    
    
    txt
    
    Expected 2 arguments, but got 1.

TypeScript is telling us we forgot to pass an argument to the `greet`
function, and rightfully so. So far we‚Äôve only written standard JavaScript,
and yet type-checking was still able to find problems with our code. Thanks
TypeScript!

## Emitting with Errors

One thing you might not have noticed from the last example was that our
`hello.js` file changed again. If we open that file up then we‚Äôll see that the
contents still basically look the same as our input file. That might be a bit
surprising given the fact that `tsc` reported an error about our code, but
this is based on one of TypeScript‚Äôs core values: much of the time, _you_ will
know better than TypeScript.

To reiterate from earlier, type-checking code limits the sorts of programs you
can run, and so there‚Äôs a tradeoff on what sorts of things a type-checker
finds acceptable. Most of the time that‚Äôs okay, but there are scenarios where
those checks get in the way. For example, imagine yourself migrating
JavaScript code over to TypeScript and introducing type-checking errors.
Eventually you‚Äôll get around to cleaning things up for the type-checker, but
that original JavaScript code was already working! Why should converting it
over to TypeScript stop you from running it?

So TypeScript doesn‚Äôt get in your way. Of course, over time, you may want to
be a bit more defensive against mistakes, and make TypeScript act a bit more
strictly. In that case, you can use the
[`noEmitOnError`](/tsconfig#noEmitOnError) compiler option. Try changing your
`hello.ts` file and running `tsc` with that flag:

    
    
    sh
    
    tsc --noEmitOnError hello.ts

You‚Äôll notice that `hello.js` never gets updated.

## Explicit Types

Up until now, we haven‚Äôt told TypeScript what `person` or `date` are. Let‚Äôs
edit the code to tell TypeScript that `person` is a `string`, and that `date`
should be a `Date` object. We‚Äôll also use the `toDateString()` method on
`date`.

    
    
    ts
    
    function greet(person: string, date: Date) {
    
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA)

What we did was add _type annotations_ on `person` and `date` to describe what
types of values `greet` can be called with. You can read that signature as
‚Äù`greet` takes a `person` of type `string`, and a `date` of type `Date`‚Äú.

With this, TypeScript can tell us about other cases where `greet` might have
been called incorrectly. For example‚Ä¶

    
    
    ts
    
    function greet(person: string, date: Date) {
    
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    
    }
    
    ¬†
    
    greet("Maddison", Date());
    
    Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA)

Huh? TypeScript reported an error on our second argument, but why?

Perhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On
the other hand, constructing a `Date` with `new Date()` actually gives us what
we were expecting.

Anyway, we can quickly fix up the error:

    
    
    ts
    
    function greet(person: string, date: Date) {
    
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    
    }
    
    ¬†
    
    greet("Maddison", new Date());
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA)

Keep in mind, we don‚Äôt always have to write explicit type annotations. In many
cases, TypeScript can even just _infer_ (or ‚Äúfigure out‚Äù) the types for us
even if we omit them.

    
    
    ts
    
    let msg = "hello there!";
    
        
    
    let msg: string
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA)

Even though we didn‚Äôt tell TypeScript that `msg` had the type `string` it was
able to figure that out. That‚Äôs a feature, and it‚Äôs best not to add
annotations when the type system would end up inferring the same type anyway.

> Note: The message bubble inside the previous code sample is what your editor
> would show if you had hovered over the word.

## Erased Types

Let‚Äôs take a look at what happens when we compile the above function `greet`
with `tsc` to output JavaScript:

    
    
    ts
    
    "use strict";
    
    function greet(person, date) {
    
        console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
    
    }
    
    greet("Maddison", new Date());
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA)

Notice two things here:

  1. Our `person` and `date` parameters no longer have type annotations.
  2. Our ‚Äútemplate string‚Äù - that string that used backticks (the ``` character) - was converted to plain strings with concatenations.

More on that second point later, but let‚Äôs now focus on that first point. Type
annotations aren‚Äôt part of JavaScript (or ECMAScript to be pedantic), so there
really aren‚Äôt any browsers or other runtimes that can just run TypeScript
unmodified. That‚Äôs why TypeScript needs a compiler in the first place - it
needs some way to strip out or transform any TypeScript-specific code so that
you can run it. Most TypeScript-specific code gets erased away, and likewise,
here our type annotations were completely erased.

> **Remember** : Type annotations never change the runtime behavior of your
> program.

## Downleveling

One other difference from the above was that our template string was rewritten
from

    
    
    js
    
    `Hello ${person}, today is ${date.toDateString()}!`;

to

    
    
    js
    
    "Hello ".concat(person, ", today is ").concat(date.toDateString(), "!");

Why did this happen?

Template strings are a feature from a version of ECMAScript called ECMAScript
2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - _don‚Äôt ask_). TypeScript has
the ability to rewrite code from newer versions of ECMAScript to older ones
such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5). This process of moving from
a newer or ‚Äúhigher‚Äù version of ECMAScript down to an older or ‚Äúlower‚Äù one is
sometimes called _downleveling_.

By default TypeScript targets ES5, an extremely old version of ECMAScript. We
could have chosen something a little bit more recent by using the
[`target`](/tsconfig#target) option. Running with `--target es2015` changes
TypeScript to target ECMAScript 2015, meaning code should be able to run
wherever ECMAScript 2015 is supported. So running `tsc --target es2015
hello.ts` gives us the following output:

    
    
    js
    
    function greet(person, date) {
    
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    
    }
    
    greet("Maddison", new Date());

> While the default target is ES5, the great majority of current browsers
> support ES2015. Most developers can therefore safely specify ES2015 or above
> as a target, unless compatibility with certain ancient browsers is
> important.

## Strictness

Different users come to TypeScript looking for different things in a type-
checker. Some people are looking for a more loose opt-in experience which can
help validate only some parts of their program, and still have decent tooling.
This is the default experience with TypeScript, where types are optional,
inference takes the most lenient types, and there‚Äôs no checking for
potentially `null`/`undefined` values. Much like how `tsc` emits in the face
of errors, these defaults are put in place to stay out of your way. If you‚Äôre
migrating existing JavaScript, that might be a desirable first step.

In contrast, a lot of users prefer to have TypeScript validate as much as it
can straight away, and that‚Äôs why the language provides strictness settings as
well. These strictness settings turn static type-checking from a switch
(either your code is checked or not) into something closer to a dial. The
further you turn this dial up, the more TypeScript will check for you. This
can require a little extra work, but generally speaking it pays for itself in
the long run, and enables more thorough checks and more accurate tooling. When
possible, a new codebase should always turn these strictness checks on.

TypeScript has several type-checking strictness flags that can be turned on or
off, and all of our examples will be written with all of them enabled unless
otherwise stated. The [`strict`](/tsconfig#strict) flag in the CLI, or
`"strict": true` in a
[`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-
json.html) toggles them all on simultaneously, but we can opt out of them
individually. The two biggest ones you should know about are
[`noImplicitAny`](/tsconfig#noImplicitAny) and
[`strictNullChecks`](/tsconfig#strictNullChecks).

## `noImplicitAny`

Recall that in some places, TypeScript doesn‚Äôt try to infer types for us and
instead falls back to the most lenient type: `any`. This isn‚Äôt the worst thing
that can happen - after all, falling back to `any` is just the plain
JavaScript experience anyway.

However, using `any` often defeats the purpose of using TypeScript in the
first place. The more typed your program is, the more validation and tooling
you‚Äôll get, meaning you‚Äôll run into fewer bugs as you code. Turning on the
[`noImplicitAny`](/tsconfig#noImplicitAny) flag will issue an error on any
variables whose type is implicitly inferred as `any`.

## `strictNullChecks`

By default, values like `null` and `undefined` are assignable to any other
type. This can make writing some code easier, but forgetting to handle `null`
and `undefined` is the cause of countless bugs in the world - some consider it
a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)! The
[`strictNullChecks`](/tsconfig#strictNullChecks) flag makes handling `null`
and `undefined` more explicit, and _spares_ us from worrying about whether we
_forgot_ to handle `null` and `undefined`.

### [The TypeScript HandbookYour first step to learn
TypeScript](/docs/handbook/intro.html)

### [Everyday TypesThe language primitives.](/docs/handbook/2/everyday-
types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Basics.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(55\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RT![Rich Trott
\(4\)](https://gravatar.com/avatar/d9bebc8f32aaad1275a931e2045196e0?s=32&&d=blank)

DR![Daniel Rosenwasser
\(4\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

EB![Eli Barzilay
\(2\)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)

18+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Classes

> Background Reading:  
> [Classes (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes)

TypeScript offers full support for the `class` keyword introduced in ES2015.

As with other JavaScript language features, TypeScript adds type annotations
and other syntax to allow you to express relationships between classes and
other types.

## Class Members

Here‚Äôs the most basic class - an empty one:

    
    
    ts
    
    class Point {}
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A)

This class isn‚Äôt very useful yet, so let‚Äôs start adding some members.

### Fields

A field declaration creates a public writeable property on a class:

    
    
    ts
    
    class Point {
    
      x: number;
    
      y: number;
    
    }
    
    ¬†
    
    const pt = new Point();
    
    pt.x = 0;
    
    pt.y = 0;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA)

As with other locations, the type annotation is optional, but will be an
implicit `any` if not specified.

Fields can also have _initializers_ ; these will run automatically when the
class is instantiated:

    
    
    ts
    
    class Point {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    const pt = new Point();
    
    // Prints 0, 0
    
    console.log(`${pt.x}, ${pt.y}`);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA)

Just like with `const`, `let`, and `var`, the initializer of a class property
will be used to infer its type:

    
    
    ts
    
    const pt = new Point();
    
    pt.x = "0";
    
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA)

#### `--strictPropertyInitialization`

The [`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization)
setting controls whether class fields need to be initialized in the
constructor.

    
    
    ts
    
    class BadGreeter {
    
      name: string;
    
    Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA)
    
    
    ts
    
    class GoodGreeter {
    
      name: string;
    
    ¬†
    
      constructor() {
    
        this.name = "hello";
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA)

Note that the field needs to be initialized _in the constructor itself_.
TypeScript does not analyze methods you invoke from the constructor to detect
initializations, because a derived class might override those methods and fail
to initialize the members.

If you intend to definitely initialize a field through means other than the
constructor (for example, maybe an external library is filling in part of your
class for you), you can use the _definite assignment assertion operator_ ,
`!`:

    
    
    ts
    
    class OKGreeter {
    
      // Not initialized, but no error
    
      name!: string;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A)

### `readonly`

Fields may be prefixed with the `readonly` modifier. This prevents assignments
to the field outside of the constructor.

    
    
    ts
    
    class Greeter {
    
      readonly name: string = "world";
    
    ¬†
    
      constructor(otherName?: string) {
    
        if (otherName !== undefined) {
    
          this.name = otherName;
    
        }
    
      }
    
    ¬†
    
      err() {
    
        this.name = "not ok";
    
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.
    
      }
    
    }
    
    const g = new Greeter();
    
    g.name = "also not ok";
    
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA)

### Constructors

> Background Reading:  
>  [Constructor (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/constructor)  
>

Class constructors are very similar to functions. You can add parameters with
type annotations, default values, and overloads:

    
    
    ts
    
    class Point {
    
      x: number;
    
      y: number;
    
    ¬†
    
      // Normal signature with defaults
    
      constructor(x = 0, y = 0) {
    
        this.x = x;
    
        this.y = y;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA)
    
    
    ts
    
    class Point {
    
      x: number = 0;
    
      y: number = 0;
    
    ¬†
    
      // Constructor overloads
    
      constructor(x: number, y: number);
    
      constructor(xy: string);
    
      constructor(x: string | number, y: number = 0) {
    
        // Code logic here
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA)

There are just a few differences between class constructor signatures and
function signatures:

  * Constructors can‚Äôt have type parameters - these belong on the outer class declaration, which we‚Äôll learn about later
  * Constructors can‚Äôt have return type annotations - the class instance type is always what‚Äôs returned

#### Super Calls

Just as in JavaScript, if you have a base class, you‚Äôll need to call
`super();` in your constructor body before using any `this.` members:

    
    
    ts
    
    class Base {
    
      k = 4;
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      constructor() {
    
        // Prints a wrong value in ES5; throws exception in ES6
    
        console.log(this.k);
    
    'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.
    
        super();
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA)

Forgetting to call `super` is an easy mistake to make in JavaScript, but
TypeScript will tell you when it‚Äôs necessary.

### Methods

> Background Reading:  
>  [Method definitions](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/Method_definitions)  
>

A function property on a class is called a _method_. Methods can use all the
same type annotations as functions and constructors:

    
    
    ts
    
    class Point {
    
      x = 10;
    
      y = 10;
    
    ¬†
    
      scale(n: number): void {
    
        this.x *= n;
    
        this.y *= n;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA)

Other than the standard type annotations, TypeScript doesn‚Äôt add anything else
new to methods.

Note that inside a method body, it is still mandatory to access fields and
other methods via `this.`. An unqualified name in a method body will always
refer to something in the enclosing scope:

    
    
    ts
    
    let x: number = 0;
    
    ¬†
    
    class C {
    
      x: string = "hello";
    
    ¬†
    
      m() {
    
        // This is trying to modify 'x' from line 1, not the class property
    
        x = "world";
    
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA)

### Getters / Setters

Classes can also have _accessors_ :

    
    
    ts
    
    class C {
    
      _length = 0;
    
      get length() {
    
        return this._length;
    
      }
    
      set length(value) {
    
        this._length = value;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA)

> Note that a field-backed get/set pair with no extra logic is very rarely
> useful in JavaScript. It‚Äôs fine to expose public fields if you don‚Äôt need to
> add additional logic during the get/set operations.

TypeScript has some special inference rules for accessors:

  * If `get` exists but no `set`, the property is automatically `readonly`
  * If the type of the setter parameter is not specified, it is inferred from the return type of the getter

Since [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-3/), it is possible to have accessors with different types for
getting and setting.

    
    
    ts
    
    class Thing {
    
      _size = 0;
    
    ¬†
    
      get size(): number {
    
        return this._size;
    
      }
    
    ¬†
    
      set size(value: string | number | boolean) {
    
        let num = Number(value);
    
    ¬†
    
        // Don't allow NaN, Infinity, etc
    
    ¬†
    
        if (!Number.isFinite(num)) {
    
          this._size = 0;
    
          return;
    
        }
    
    ¬†
    
        this._size = num;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA)

### Index Signatures

Classes can declare index signatures; these work the same as [Index Signatures
for other object types](/docs/handbook/2/objects.html#index-signatures):

    
    
    ts
    
    class MyClass {
    
      [s: string]: boolean | ((s: string) => boolean);
    
    ¬†
    
      check(s: string) {
    
        return this[s] as boolean;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA)

Because the index signature type needs to also capture the types of methods,
it‚Äôs not easy to usefully use these types. Generally it‚Äôs better to store
indexed data in another place instead of on the class instance itself.

## Class Heritage

Like other languages with object-oriented features, classes in JavaScript can
inherit from base classes.

### `implements` Clauses

You can use an `implements` clause to check that a class satisfies a
particular `interface`. An error will be issued if a class fails to correctly
implement it:

    
    
    ts
    
    interface Pingable {
    
      ping(): void;
    
    }
    
    ¬†
    
    class Sonar implements Pingable {
    
      ping() {
    
        console.log("ping!");
    
      }
    
    }
    
    ¬†
    
    class Ball implements Pingable {
    
    Class 'Ball' incorrectly implements interface 'Pingable'.
      Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.
      Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
    
      pong() {
    
        console.log("pong!");
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA)

Classes may also implement multiple interfaces, e.g. `class C implements A, B
{`.

#### Cautions

It‚Äôs important to understand that an `implements` clause is only a check that
the class can be treated as the interface type. It doesn‚Äôt change the type of
the class or its methods _at all_. A common source of error is to assume that
an `implements` clause will change the class type - it doesn‚Äôt!

    
    
    ts
    
    interface Checkable {
    
      check(name: string): boolean;
    
    }
    
    ¬†
    
    class NameChecker implements Checkable {
    
      check(s) {
    
    Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.
    
        // Notice no error here
    
        return s.toLowerCase() === "ok";
    
                     
    
    any
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA)

In this example, we perhaps expected that `s`‚Äôs type would be influenced by
the `name: string` parameter of `check`. It is not - `implements` clauses
don‚Äôt change how the class body is checked or its type inferred.

Similarly, implementing an interface with an optional property doesn‚Äôt create
that property:

    
    
    ts
    
    interface A {
    
      x: number;
    
      y?: number;
    
    }
    
    class C implements A {
    
      x = 0;
    
    }
    
    const c = new C();
    
    c.y = 10;
    
    Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA)

### `extends` Clauses

> Background Reading:  
>  [extends keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/extends)  
>

Classes may `extend` from a base class. A derived class has all the properties
and methods of its base class, and can also define additional members.

    
    
    ts
    
    class Animal {
    
      move() {
    
        console.log("Moving along!");
    
      }
    
    }
    
    ¬†
    
    class Dog extends Animal {
    
      woof(times: number) {
    
        for (let i = 0; i < times; i++) {
    
          console.log("woof!");
    
        }
    
      }
    
    }
    
    ¬†
    
    const d = new Dog();
    
    // Base class method
    
    d.move();
    
    // Derived class method
    
    d.woof(3);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA)

#### Overriding Methods

> Background Reading:  
>  [super keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/super)  
>

A derived class can also override a base class field or property. You can use
the `super.` syntax to access base class methods. Note that because JavaScript
classes are a simple lookup object, there is no notion of a ‚Äúsuper field‚Äù.

TypeScript enforces that a derived class is always a subtype of its base
class.

For example, here‚Äôs a legal way to override a method:

    
    
    ts
    
    class Base {
    
      greet() {
    
        console.log("Hello, world!");
    
      }
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      greet(name?: string) {
    
        if (name === undefined) {
    
          super.greet();
    
        } else {
    
          console.log(`Hello, ${name.toUpperCase()}`);
    
        }
    
      }
    
    }
    
    ¬†
    
    const d = new Derived();
    
    d.greet();
    
    d.greet("reader");
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA)

It‚Äôs important that a derived class follow its base class contract. Remember
that it‚Äôs very common (and always legal!) to refer to a derived class instance
through a base class reference:

    
    
    ts
    
    // Alias the derived instance through a base class reference
    
    const b: Base = d;
    
    // No problem
    
    b.greet();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA)

What if `Derived` didn‚Äôt follow `Base`‚Äôs contract?

    
    
    ts
    
    class Base {
    
      greet() {
    
        console.log("Hello, world!");
    
      }
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      // Make this parameter required
    
      greet(name: string) {
    
    Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
      Type '(name: string) => void' is not assignable to type '() => void'.
        Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
      Type '(name: string) => void' is not assignable to type '() => void'.
        Target signature provides too few arguments. Expected 1 or more, but got 0.
    
        console.log(`Hello, ${name.toUpperCase()}`);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA)

If we compiled this code despite the error, this sample would then crash:

    
    
    ts
    
    const b: Base = new Derived();
    
    // Crashes because "name" will be undefined
    
    b.greet();
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA)

#### Type-only Field Declarations

When `target >= ES2022` or
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields) is `true`,
class fields are initialized after the parent class constructor completes,
overwriting any value set by the parent class. This can be a problem when you
only want to re-declare a more accurate type for an inherited field. To handle
these cases, you can write `declare` to indicate to TypeScript that there
should be no runtime effect for this field declaration.

    
    
    ts
    
    interface Animal {
    
      dateOfBirth: any;
    
    }
    
    ¬†
    
    interface Dog extends Animal {
    
      breed: any;
    
    }
    
    ¬†
    
    class AnimalHouse {
    
      resident: Animal;
    
      constructor(animal: Animal) {
    
        this.resident = animal;
    
      }
    
    }
    
    ¬†
    
    class DogHouse extends AnimalHouse {
    
      // Does not emit JavaScript code,
    
      // only ensures the types are correct
    
      declare resident: Dog;
    
      constructor(dog: Dog) {
    
        super(dog);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA)

#### Initialization Order

The order that JavaScript classes initialize can be surprising in some cases.
Let‚Äôs consider this code:

    
    
    ts
    
    class Base {
    
      name = "base";
    
      constructor() {
    
        console.log("My name is " + this.name);
    
      }
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      name = "derived";
    
    }
    
    ¬†
    
    // Prints "base", not "derived"
    
    const d = new Derived();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA)

What happened here?

The order of class initialization, as defined by JavaScript, is:

  * The base class fields are initialized
  * The base class constructor runs
  * The derived class fields are initialized
  * The derived class constructor runs

This means that the base class constructor saw its own value for `name` during
its own constructor, because the derived class field initializations hadn‚Äôt
run yet.

#### Inheriting Built-in Types

> Note: If you don‚Äôt plan to inherit from built-in types like `Array`,
> `Error`, `Map`, etc. or your compilation target is explicitly set to
> `ES6`/`ES2015` or above, you may skip this section

In ES2015, constructors which return an object implicitly substitute the value
of `this` for any callers of `super(...)`. It is necessary for generated
constructor code to capture any potential return value of `super(...)` and
replace it with `this`.

As a result, subclassing `Error`, `Array`, and others may no longer work as
expected. This is due to the fact that constructor functions for `Error`,
`Array`, and the like use ECMAScript 6‚Äôs `new.target` to adjust the prototype
chain; however, there is no way to ensure a value for `new.target` when
invoking a constructor in ECMAScript 5. Other downlevel compilers generally
have the same limitation by default.

For a subclass like the following:

    
    
    ts
    
    class MsgError extends Error {
    
      constructor(m: string) {
    
        super(m);
    
      }
    
      sayHello() {
    
        return "hello " + this.message;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA)

you may find that:

  * methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.
  * `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.

As a recommendation, you can manually adjust the prototype immediately after
any `super(...)` calls.

    
    
    ts
    
    class MsgError extends Error {
    
      constructor(m: string) {
    
        super(m);
    
    ¬†
    
        // Set the prototype explicitly.
    
        Object.setPrototypeOf(this, MsgError.prototype);
    
      }
    
    ¬†
    
      sayHello() {
    
        return "hello " + this.message;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA)

However, any subclass of `MsgError` will have to manually set the prototype as
well. For runtimes that don‚Äôt support
[`Object.setPrototypeOf`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf), you
may instead be able to use [`__proto__`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).

Unfortunately, [these workarounds will not work on Internet Explorer 10 and
prior](https://msdn.microsoft.com/en-us/library/s4esdbwz\(v=vs.94\).aspx). One
can manually copy methods from the prototype onto the instance itself (i.e.
`MsgError.prototype` onto `this`), but the prototype chain itself cannot be
fixed.

## Member Visibility

You can use TypeScript to control whether certain methods or properties are
visible to code outside the class.

### `public`

The default visibility of class members is `public`. A `public` member can be
accessed anywhere:

    
    
    ts
    
    class Greeter {
    
      public greet() {
    
        console.log("hi!");
    
      }
    
    }
    
    const g = new Greeter();
    
    g.greet();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA)

Because `public` is already the default visibility modifier, you don‚Äôt ever
_need_ to write it on a class member, but might choose to do so for
style/readability reasons.

### `protected`

`protected` members are only visible to subclasses of the class they‚Äôre
declared in.

    
    
    ts
    
    class Greeter {
    
      public greet() {
    
        console.log("Hello, " + this.getName());
    
      }
    
      protected getName() {
    
        return "hi";
    
      }
    
    }
    
    ¬†
    
    class SpecialGreeter extends Greeter {
    
      public howdy() {
    
        // OK to access protected member here
    
        console.log("Howdy, " + this.getName());
    
      }
    
    }
    
    const g = new SpecialGreeter();
    
    g.greet(); // OK
    
    g.getName();
    
    Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA)

#### Exposure of `protected` members

Derived classes need to follow their base class contracts, but may choose to
expose a subtype of base class with more capabilities. This includes making
`protected` members `public`:

    
    
    ts
    
    class Base {
    
      protected m = 10;
    
    }
    
    class Derived extends Base {
    
      // No modifier, so default is 'public'
    
      m = 15;
    
    }
    
    const d = new Derived();
    
    console.log(d.m); // OK
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA)

Note that `Derived` was already able to freely read and write `m`, so this
doesn‚Äôt meaningfully alter the ‚Äúsecurity‚Äù of this situation. The main thing to
note here is that in the derived class, we need to be careful to repeat the
`protected` modifier if this exposure isn‚Äôt intentional.

#### Cross-hierarchy `protected` access

Different OOP languages disagree about whether it‚Äôs legal to access a
`protected` member through a base class reference:

    
    
    ts
    
    class Base {
    
      protected x: number = 1;
    
    }
    
    class Derived1 extends Base {
    
      protected x: number = 5;
    
    }
    
    class Derived2 extends Base {
    
      f1(other: Derived2) {
    
        other.x = 10;
    
      }
    
      f2(other: Derived1) {
    
        other.x = 10;
    
    Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA)

Java, for example, considers this to be legal. On the other hand, C# and C++
chose that this code should be illegal.

TypeScript sides with C# and C++ here, because accessing `x` in `Derived2`
should only be legal from `Derived2`‚Äôs subclasses, and `Derived1` isn‚Äôt one of
them. Moreover, if accessing `x` through a `Derived1` reference is illegal
(which it certainly should be!), then accessing it through a base class
reference should never improve the situation.

See also [Why Can‚Äôt I Access A Protected Member From A Derived
Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-
access-a-protected-member-from-a-derived-class/) which explains more of C#‚Äòs
reasoning.

### `private`

`private` is like `protected`, but doesn‚Äôt allow access to the member even
from subclasses:

    
    
    ts
    
    class Base {
    
      private x = 0;
    
    }
    
    const b = new Base();
    
    // Can't access from outside the class
    
    console.log(b.x);
    
    Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA)
    
    
    ts
    
    class Derived extends Base {
    
      showX() {
    
        // Can't access in subclasses
    
        console.log(this.x);
    
    Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA)

Because `private` members aren‚Äôt visible to derived classes, a derived class
can‚Äôt increase their visibility:

    
    
    ts
    
    class Base {
    
      private x = 0;
    
    }
    
    class Derived extends Base {
    
    Class 'Derived' incorrectly extends base class 'Base'.
      Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.
      Property 'x' is private in type 'Base' but not in type 'Derived'.
    
      x = 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA)

#### Cross-instance `private` access

Different OOP languages disagree about whether different instances of the same
class may access each others‚Äô `private` members. While languages like Java,
C#, C++, Swift, and PHP allow this, Ruby does not.

TypeScript does allow cross-instance `private` access:

    
    
    ts
    
    class A {
    
      private x = 10;
    
    ¬†
    
      public sameAs(other: A) {
    
        // No error
    
        return other.x === this.x;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA)

#### Caveats

Like other aspects of TypeScript‚Äôs type system, `private` and `protected` [are
only enforced during type
checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-
HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-
KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA).

This means that JavaScript runtime constructs like `in` or simple property
lookup can still access a `private` or `protected` member:

    
    
    ts
    
    class MySafe {
    
      private secretKey = 12345;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA)
    
    
    js
    
    // In a JavaScript file...
    
    const s = new MySafe();
    
    // Will print 12345
    
    console.log(s.secretKey);

`private` also allows access using bracket notation during type checking. This
makes `private`-declared fields potentially easier to access for things like
unit tests, with the drawback that these fields are _soft private_ and don‚Äôt
strictly enforce privacy.

    
    
    ts
    
    class MySafe {
    
      private secretKey = 12345;
    
    }
    
    ¬†
    
    const s = new MySafe();
    
    ¬†
    
    // Not allowed during type checking
    
    console.log(s.secretKey);
    
    Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'.
    
    ¬†
    
    // OK
    
    console.log(s["secretKey"]);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA)

Unlike TypeScripts‚Äôs `private`, JavaScript‚Äôs [private
fields](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) (`#`) remain
private after compilation and do not provide the previously mentioned escape
hatches like bracket notation access, making them _hard private_.

    
    
    ts
    
    class Dog {
    
      #barkAmount = 0;
    
      personality = "happy";
    
    ¬†
    
      constructor() {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA)
    
    
    ts
    
    "use strict";
    
    class Dog {
    
        #barkAmount = 0;
    
        personality = "happy";
    
        constructor() { }
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA)

When compiling to ES2021 or less, TypeScript will use WeakMaps in place of
`#`.

    
    
    ts
    
    "use strict";
    
    var _Dog_barkAmount;
    
    class Dog {
    
        constructor() {
    
            _Dog_barkAmount.set(this, 0);
    
            this.personality = "happy";
    
        }
    
    }
    
    _Dog_barkAmount = new WeakMap();
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA)

If you need to protect values in your class from malicious actors, you should
use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or
private fields. Note that these added privacy checks during runtime could
affect performance.

## Static Members

> Background Reading:  
>  [Static Members (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/static)  
>

Classes may have `static` members. These members aren‚Äôt associated with a
particular instance of the class. They can be accessed through the class
constructor object itself:

    
    
    ts
    
    class MyClass {
    
      static x = 0;
    
      static printX() {
    
        console.log(MyClass.x);
    
      }
    
    }
    
    console.log(MyClass.x);
    
    MyClass.printX();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA)

Static members can also use the same `public`, `protected`, and `private`
visibility modifiers:

    
    
    ts
    
    class MyClass {
    
      private static x = 0;
    
    }
    
    console.log(MyClass.x);
    
    Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA)

Static members are also inherited:

    
    
    ts
    
    class Base {
    
      static getGreeting() {
    
        return "Hello world";
    
      }
    
    }
    
    class Derived extends Base {
    
      myGreeting = Derived.getGreeting();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA)

### Special Static Names

It‚Äôs generally not safe/possible to overwrite properties from the `Function`
prototype. Because classes are themselves functions that can be invoked with
`new`, certain `static` names can‚Äôt be used. Function properties like `name`,
`length`, and `call` aren‚Äôt valid to define as `static` members:

    
    
    ts
    
    class S {
    
      static name = "S!";
    
    Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A)

### Why No Static Classes?

TypeScript (and JavaScript) don‚Äôt have a construct called `static class` the
same way as, for example, C# does.

Those constructs _only_ exist because those languages force all data and
functions to be inside a class; because that restriction doesn‚Äôt exist in
TypeScript, there‚Äôs no need for them. A class with only a single instance is
typically just represented as a normal _object_ in JavaScript/TypeScript.

For example, we don‚Äôt need a ‚Äústatic class‚Äù syntax in TypeScript because a
regular object (or even top-level function) will do the job just as well:

    
    
    ts
    
    // Unnecessary "static" class
    
    class MyStaticClass {
    
      static doSomething() {}
    
    }
    
    ¬†
    
    // Preferred (alternative 1)
    
    function doSomething() {}
    
    ¬†
    
    // Preferred (alternative 2)
    
    const MyHelperObject = {
    
      dosomething() {},
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA)

## `static` Blocks in Classes

Static blocks allow you to write a sequence of statements with their own scope
that can access private fields within the containing class. This means that we
can write initialization code with all the capabilities of writing statements,
no leakage of variables, and full access to our class‚Äôs internals.

    
    
    ts
    
    class Foo {
    
        static #count = 0;
    
    ¬†
    
        get count() {
    
            return Foo.#count;
    
        }
    
    ¬†
    
        static {
    
            try {
    
                const lastInstances = loadLastInstances();
    
                Foo.#count += lastInstances.length;
    
            }
    
            catch {}
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA)

## Generic Classes

Classes, much like interfaces, can be generic. When a generic class is
instantiated with `new`, its type parameters are inferred the same way as in a
function call:

    
    
    ts
    
    class Box<Type> {
    
      contents: Type;
    
      constructor(value: Type) {
    
        this.contents = value;
    
      }
    
    }
    
    ¬†
    
    const b = new Box("hello!");
    
         
    
    const b: Box<string>
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA)

Classes can use generic constraints and defaults the same way as interfaces.

### Type Parameters in Static Members

This code isn‚Äôt legal, and it may not be obvious why:

    
    
    ts
    
    class Box<Type> {
    
      static defaultValue: Type;
    
    Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A)

Remember that types are always fully erased! At runtime, there‚Äôs only _one_
`Box.defaultValue` property slot. This means that setting
`Box<string>.defaultValue` (if that were possible) would _also_ change
`Box<number>.defaultValue` \- not good. The `static` members of a generic
class can never refer to the class‚Äôs type parameters.

## `this` at Runtime in Classes

> Background Reading:  
>  [this keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/this)  
>

It‚Äôs important to remember that TypeScript doesn‚Äôt change the runtime behavior
of JavaScript, and that JavaScript is somewhat famous for having some peculiar
runtime behaviors.

JavaScript‚Äôs handling of `this` is indeed unusual:

    
    
    ts
    
    class MyClass {
    
      name = "MyClass";
    
      getName() {
    
        return this.name;
    
      }
    
    }
    
    const c = new MyClass();
    
    const obj = {
    
      name: "obj",
    
      getName: c.getName,
    
    };
    
    ¬†
    
    // Prints "obj", not "MyClass"
    
    console.log(obj.getName());
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA)

Long story short, by default, the value of `this` inside a function depends on
_how the function was called_. In this example, because the function was
called through the `obj` reference, its value of `this` was `obj` rather than
the class instance.

This is rarely what you want to happen! TypeScript provides some ways to
mitigate or prevent this kind of error.

### Arrow Functions

> Background Reading:  
>  [Arrow functions (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)  
>

If you have a function that will often be called in a way that loses its
`this` context, it can make sense to use an arrow function property instead of
a method definition:

    
    
    ts
    
    class MyClass {
    
      name = "MyClass";
    
      getName = () => {
    
        return this.name;
    
      };
    
    }
    
    const c = new MyClass();
    
    const g = c.getName;
    
    // Prints "MyClass" instead of crashing
    
    console.log(g());
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA)

This has some trade-offs:

  * The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript
  * This will use more memory, because each class instance will have its own copy of each function defined this way
  * You can‚Äôt use `super.getName` in a derived class, because there‚Äôs no entry in the prototype chain to fetch the base class method from

### `this` parameters

In a method or function definition, an initial parameter named `this` has
special meaning in TypeScript. These parameters are erased during compilation:

    
    
    ts
    
    // TypeScript input with 'this' parameter
    
    function fn(this: SomeType, x: number) {
    
      /* ... */
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA)
    
    
    js
    
    // JavaScript output
    
    function fn(x) {
    
      /* ... */
    
    }

TypeScript checks that calling a function with a `this` parameter is done so
with a correct context. Instead of using an arrow function, we can add a
`this` parameter to method definitions to statically enforce that the method
is called correctly:

    
    
    ts
    
    class MyClass {
    
      name = "MyClass";
    
      getName(this: MyClass) {
    
        return this.name;
    
      }
    
    }
    
    const c = new MyClass();
    
    // OK
    
    c.getName();
    
    ¬†
    
    // Error, would crash
    
    const g = c.getName;
    
    console.log(g());
    
    The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA)

This method makes the opposite trade-offs of the arrow function approach:

  * JavaScript callers might still use the class method incorrectly without realizing it
  * Only one function per class definition gets allocated, rather than one per class instance
  * Base method definitions can still be called via `super`.

## `this` Types

In classes, a special type called `this` refers _dynamically_ to the type of
the current class. Let‚Äôs see how this is useful:

    
    
    ts
    
    class Box {
    
      contents: string = "";
    
      set(value: string) {
    
      
    
    (method) Box.set(value: string): this
    
        this.contents = value;
    
        return this;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA)

Here, TypeScript inferred the return type of `set` to be `this`, rather than
`Box`. Now let‚Äôs make a subclass of `Box`:

    
    
    ts
    
    class ClearableBox extends Box {
    
      clear() {
    
        this.contents = "";
    
      }
    
    }
    
    ¬†
    
    const a = new ClearableBox();
    
    const b = a.set("hello");
    
         
    
    const b: ClearableBox
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA)

You can also use `this` in a parameter type annotation:

    
    
    ts
    
    class Box {
    
      content: string = "";
    
      sameAs(other: this) {
    
        return other.content === this.content;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA)

This is different from writing `other: Box` ‚Äî if you have a derived class, its
`sameAs` method will now only accept other instances of that same derived
class:

    
    
    ts
    
    class Box {
    
      content: string = "";
    
      sameAs(other: this) {
    
        return other.content === this.content;
    
      }
    
    }
    
    ¬†
    
    class DerivedBox extends Box {
    
      otherContent: string = "?";
    
    }
    
    ¬†
    
    const base = new Box();
    
    const derived = new DerivedBox();
    
    derived.sameAs(base);
    
    Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
      Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
      Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA)

### `this`-based type guards

You can use `this is Type` in the return position for methods in classes and
interfaces. When mixed with a type narrowing (e.g. `if` statements) the type
of the target object would be narrowed to the specified `Type`.

    
    
    ts
    
    class FileSystemObject {
    
      isFile(): this is FileRep {
    
        return this instanceof FileRep;
    
      }
    
      isDirectory(): this is Directory {
    
        return this instanceof Directory;
    
      }
    
      isNetworked(): this is Networked & this {
    
        return this.networked;
    
      }
    
      constructor(public path: string, private networked: boolean) {}
    
    }
    
    ¬†
    
    class FileRep extends FileSystemObject {
    
      constructor(path: string, public content: string) {
    
        super(path, false);
    
      }
    
    }
    
    ¬†
    
    class Directory extends FileSystemObject {
    
      children: FileSystemObject[];
    
    }
    
    ¬†
    
    interface Networked {
    
      host: string;
    
    }
    
    ¬†
    
    const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");
    
    ¬†
    
    if (fso.isFile()) {
    
      fso.content;
    
      
    
    const fso: FileRep
    
    } else if (fso.isDirectory()) {
    
      fso.children;
    
      
    
    const fso: Directory
    
    } else if (fso.isNetworked()) {
    
      fso.host;
    
      
    
    const fso: Networked & FileSystemObject
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA)

A common use-case for a this-based type guard is to allow for lazy validation
of a particular field. For example, this case removes an `undefined` from the
value held inside box when `hasValue` has been verified to be true:

    
    
    ts
    
    class Box<T> {
    
      value?: T;
    
    ¬†
    
      hasValue(): this is { value: T } {
    
        return this.value !== undefined;
    
      }
    
    }
    
    ¬†
    
    const box = new Box<string>();
    
    box.value = "Gameboy";
    
    ¬†
    
    box.value;
    
         
    
    (property) Box<string>.value?: string
    
    ¬†
    
    if (box.hasValue()) {
    
      box.value;
    
           
    
    (property) value: string
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA)

## Parameter Properties

TypeScript offers special syntax for turning a constructor parameter into a
class property with the same name and value. These are called _parameter
properties_ and are created by prefixing a constructor argument with one of
the visibility modifiers `public`, `private`, `protected`, or `readonly`. The
resulting field gets those modifier(s):

    
    
    ts
    
    class Params {
    
      constructor(
    
        public readonly x: number,
    
        protected y: number,
    
        private z: number
    
      ) {
    
        // No body necessary
    
      }
    
    }
    
    const a = new Params(1, 2, 3);
    
    console.log(a.x);
    
                 
    
    (property) Params.x: number
    
    console.log(a.z);
    
    Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA)

## Class Expressions

> Background Reading:  
>  [Class expressions (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/class)  
>

Class expressions are very similar to class declarations. The only real
difference is that class expressions don‚Äôt need a name, though we can refer to
them via whatever identifier they ended up bound to:

    
    
    ts
    
    const someClass = class<Type> {
    
      content: Type;
    
      constructor(value: Type) {
    
        this.content = value;
    
      }
    
    };
    
    ¬†
    
    const m = new someClass("Hello, world");
    
         
    
    const m: someClass<string>
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA)

## Constructor Signatures

JavaScript classes are instantiated with the `new` operator. Given the type of
a class itself, the [InstanceType](/docs/handbook/utility-
types.html#instancetypetype) utility type models this operation.

    
    
    ts
    
    class Point {
    
      createdAt: number;
    
      x: number;
    
      y: number
    
      constructor(x: number, y: number) {
    
        this.createdAt = Date.now()
    
        this.x = x;
    
        this.y = y;
    
      }
    
    }
    
    type PointInstance = InstanceType<typeof Point>
    
    ¬†
    
    function moveRight(point: PointInstance) {
    
      point.x += 5;
    
    }
    
    ¬†
    
    const point = new Point(3, 4);
    
    moveRight(point);
    
    point.x; // => 8
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA)

## `abstract` Classes and Members

Classes, methods, and fields in TypeScript may be _abstract_.

An _abstract method_ or _abstract field_ is one that hasn‚Äôt had an
implementation provided. These members must exist inside an _abstract class_ ,
which cannot be directly instantiated.

The role of abstract classes is to serve as a base class for subclasses which
do implement all the abstract members. When a class doesn‚Äôt have any abstract
members, it is said to be _concrete_.

Let‚Äôs look at an example:

    
    
    ts
    
    abstract class Base {
    
      abstract getName(): string;
    
    ¬†
    
      printName() {
    
        console.log("Hello, " + this.getName());
    
      }
    
    }
    
    ¬†
    
    const b = new Base();
    
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA)

We can‚Äôt instantiate `Base` with `new` because it‚Äôs abstract. Instead, we need
to make a derived class and implement the abstract members:

    
    
    ts
    
    class Derived extends Base {
    
      getName() {
    
        return "world";
    
      }
    
    }
    
    ¬†
    
    const d = new Derived();
    
    d.printName();
    
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA)

Notice that if we forget to implement the base class‚Äôs abstract members, we‚Äôll
get an error:

    
    
    ts
    
    class Derived extends Base {
    
    Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
    
      // forgot to do anything
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA)

### Abstract Construct Signatures

Sometimes you want to accept some class constructor function that produces an
instance of a class which derives from some abstract class.

For example, you might want to write this code:

    
    
    ts
    
    function greet(ctor: typeof Base) {
    
      const instance = new ctor();
    
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.
    
      instance.printName();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA)

TypeScript is correctly telling you that you‚Äôre trying to instantiate an
abstract class. After all, given the definition of `greet`, it‚Äôs perfectly
legal to write this code, which would end up constructing an abstract class:

    
    
    ts
    
    // Bad!
    
    greet(Base);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA)

Instead, you want to write a function that accepts something with a construct
signature:

    
    
    ts
    
    function greet(ctor: new () => Base) {
    
      const instance = new ctor();
    
      instance.printName();
    
    }
    
    greet(Derived);
    
    greet(Base);
    
    Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA)

Now TypeScript correctly tells you about which class constructor functions can
be invoked - `Derived` can because it‚Äôs concrete, but `Base` cannot.

## Relationships Between Classes

In most cases, classes in TypeScript are compared structurally, the same as
other types.

For example, these two classes can be used in place of each other because
they‚Äôre identical:

    
    
    ts
    
    class Point1 {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    class Point2 {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    // OK
    
    const p: Point1 = new Point2();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA)

Similarly, subtype relationships between classes exist even if there‚Äôs no
explicit inheritance:

    
    
    ts
    
    class Person {
    
      name: string;
    
      age: number;
    
    }
    
    ¬†
    
    class Employee {
    
      name: string;
    
      age: number;
    
      salary: number;
    
    }
    
    ¬†
    
    // OK
    
    const p: Person = new Employee();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA)

This sounds straightforward, but there are a few cases that seem stranger than
others.

Empty classes have no members. In a structural type system, a type with no
members is generally a supertype of anything else. So if you write an empty
class (don‚Äôt!), anything can be used in place of it:

    
    
    ts
    
    class Empty {}
    
    ¬†
    
    function fn(x: Empty) {
    
      // can't do anything with 'x', so I won't
    
    }
    
    ¬†
    
    // All OK!
    
    fn(window);
    
    fn({});
    
    fn(fn);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [ModulesHow JavaScript handles communicating across file
boundaries.](/docs/handbook/2/modules.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Classes.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(60\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

HA![Hossein Ahmadian-Yazdi
\(6\)](https://gravatar.com/avatar/e486af78745bd81069f00ebb26364938?s=32&&d=blank)

MR![Maxim R
\(3\)](https://gravatar.com/avatar/bd0e320612c6c7670833ba6db050c1e8?s=32&&d=blank)

U![uid11
\(2\)](https://gravatar.com/avatar/40f81f9167eaa8aca3142219ec2cc6da?s=32&&d=blank)

22+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Conditional Types

At the heart of most useful programs, we have to make decisions based on
input. JavaScript programs are no different, but given the fact that values
can be easily introspected, those decisions are also based on the types of the
inputs. _Conditional types_ help describe the relation between the types of
inputs and outputs.

    
    
    ts
    
    interface Animal {
    
      live(): void;
    
    }
    
    interface Dog extends Animal {
    
      woof(): void;
    
    }
    
    ¬†
    
    type Example1 = Dog extends Animal ? number : string;
    
            
    
    type Example1 = number
    
    ¬†
    
    type Example2 = RegExp extends Animal ? number : string;
    
            
    
    type Example2 = string
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChlkdgA3CACgEoAuZcge2ABMBuQgX0NElkQoAIkwDmyCAA9IIVgGc0GbHiIkA7kyYxaDZm049CYAJ4AHFAFFJcTKZwQAjMgC8yEeKkz5irLmQB+ZBAAV0wAI2hkBjkwKFBRTgB6RJJkAD1-QiMzS2tbewAmF2QAJQhRK1MJaQhZBXRfPECQ8Mjo2PiklJIMoA)

Conditional types take a form that looks a little like conditional expressions
(`condition ? trueExpression : falseExpression`) in JavaScript:

    
    
    ts
    
      SomeType extends OtherType ? TrueType : FalseType;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgChRIoB5YACwgCdVTNcDi0pkaBXFVxvIk6ADEsAGwDO3Btj4tSMYBwBmiqOkJQoAek1QAtPoDGHYPt3rYiSdAgAPYBBwATMeSq160APxtOVqAC4oYXErfCA)

When the type on the left of the `extends` is assignable to the one on the
right, then you‚Äôll get the type in the first branch (the ‚Äútrue‚Äù branch);
otherwise you‚Äôll get the type in the latter branch (the ‚Äúfalse‚Äù branch).

From the examples above, conditional types might not immediately seem useful -
we can tell ourselves whether or not `Dog extends Animal` and pick `number` or
`string`! But the power of conditional types comes from using them with
generics.

For example, let‚Äôs take the following `createLabel` function:

    
    
    ts
    
    interface IdLabel {
    
      id: number /* some fields */;
    
    }
    
    interface NameLabel {
    
      name: string /* other fields */;
    
    }
    
    ¬†
    
    function createLabel(id: number): IdLabel;
    
    function createLabel(name: string): NameLabel;
    
    function createLabel(nameOrId: string | number): IdLabel | NameLabel;
    
    function createLabel(nameOrId: string | number): IdLabel | NameLabel {
    
      throw "unimplemented";
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbJIw6IBGGA8QyBFAg4SA0CAApKGnomaABKGgwQ-Ck3Dy8fPwCgiETQ3X4DI1M45FV1XAJk909vX39A4PL8XL0AeSgMAuMQMwAfWkZmYoTG5D7S7MbK1JqM+onNZv42ju5C7tH+6KghrBGxvUTiMmRrKB4Ad2QAIndgBgAHfAh+cAh0K+cgA)

These overloads for createLabel describe a single JavaScript function that
makes a choice based on the types of its inputs. Note a few things:

  1. If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.
  2. We have to create three overloads: one for each case when we‚Äôre _sure_ of the type (one for `string` and one for `number`), and one for the most general case (taking a `string | number`). For every new type `createLabel` can handle, the number of overloads grows exponentially.

Instead, we can encode that logic in a conditional type:

    
    
    ts
    
    type NameOrId<T extends number | string> = T extends number
    
      ? IdLabel
    
      : NameLabel;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbNatkAWk8I6YT+5JgAJ4ADip6APJQGAA8ACrIEAAekCAitIzMyAA+3EamAHzIALzI8UkpafRM0GTIAPxoWLgEtTSq6s34EkA)

We can then use that conditional type to simplify our overloads down to a
single function with no overloads.

    
    
    ts
    
    function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
    
      throw "unimplemented";
    
    }
    
    ¬†
    
    let a = createLabel("typescript");
    
       
    
    let a: NameLabel
    
    ¬†
    
    let b = createLabel(2.8);
    
       
    
    let b: IdLabel
    
    ¬†
    
    let c = createLabel(Math.random() ? "hello" : 42);
    
    let c: NameLabel | IdLabel
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbLABPAA4q9AeSgYAPAAqyBAAHpAgIrSMzMgAPtxGpgB8yAC8yMFhEVH0TNBkyAD8aFi4BIU0qurl+FKsrMgAtC0IdGAtTSQwdCAIYMA8IMgIUBBwkBoEQSHhEJGiebEJhsYgJskAFJS+1fqZAJRVPn7oQanayNZQPADuyABEvcAM7vgQ-OAQ6A-OJCTvMDIODpEZjCYQKb4TYPNyeLijYDuMAPA71RrIAB6RX+gOQOFBo3Gk1qmwATAA6AAcaJIDXI2NxECBCEJ4JJmk2AFkJlYKVA4JE+JsDsVHjZ8PgeA9kDQACxk2n0rFFIA)

### Conditional Type Constraints

Often, the checks in a conditional type will provide us with some new
information. Just like narrowing with type guards can give us a more specific
type, the true branch of a conditional type will further constrain generics by
the type we check against.

For example, let‚Äôs take the following:

    
    
    ts
    
    type MessageOf<T> = T["message"];
    
    Type '"message"' cannot be used to index type 'T'.2536Type '"message"' cannot be used to index type 'T'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMA2AUAC4CeADpKALKSKICGA5pAPIBmAPACoB8oAvKBwDaAIgC21Oo2EBdANxA)

In this example, TypeScript errors because `T` isn‚Äôt known to have a property
called `message`. We could constrain `T`, and TypeScript would no longer
complain:

    
    
    ts
    
    type MessageOf<T extends { message: unknown }> = T["message"];
    
    ¬†
    
    interface Email {
    
      message: string;
    
    }
    
    ¬†
    
    type EmailMessageContents = MessageOf<Email>;
    
                  
    
    type EmailMessageContents = string
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCpQgA9gIA7AE3igG8oBbBZNALigFdSBrUgewHdSUAL4A+KAF4ouANoAiBolQRZAXQDcAKA0BLUiQBOmJAGNoAUTpJtAGxoao9Rktbxg+3Sk1CtoSFAtW1nCKaADCPHpkwFSSwUwYOAE2IpoA9KkOUAB6APxAA)

However, what if we wanted `MessageOf` to take any type, and default to
something like `never` if a `message` property isn‚Äôt available? We can do this
by moving the constraint out and introducing a conditional type:

    
    
    ts
    
    type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;
    
    ¬†
    
    interface Email {
    
      message: string;
    
    }
    
    ¬†
    
    interface Dog {
    
      bark(): void;
    
    }
    
    ¬†
    
    type EmailMessageContents = MessageOf<Email>;
    
                  
    
    type EmailMessageContents = string
    
    ¬†
    
    type DogMessageContents = MessageOf<Dog>;
    
                 
    
    type DogMessageContents = never
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCoD4oBeKXKCAD2AgDsATeKAbygFsFk0AuKAVxoDWNAPYB3GlAC+UAPykA2gCJ2iVBEUBdKDxoQAbhABOAbgBQpgJY1qhzEgDG0AKKskFgDbNTUNhzU94YEMrFDNJcysbO0coABFhFC8fACMkQwEACgBKHj1hCzow81BIKBc3dzhVNABhYWtaYEYSKs4MHHKPfDMAeh6fKAA9GWLwaHiUVrU6hutm2D80LGwJ7tM+geGgA)

Within the true branch, TypeScript knows that `T` _will_ have a `message`
property.

As another example, we could also write a type called `Flatten` that flattens
array types to their element types, but leaves them alone otherwise:

    
    
    ts
    
    type Flatten<T> = T extends any[] ? T[number] : T;
    
    ¬†
    
    // Extracts out the element type.
    
    type Str = Flatten<string[]>;
    
         
    
    type Str = string
    
    ¬†
    
    // Leaves the type alone.
    
    type Num = Flatten<number>;
    
         
    
    type Num = number
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFQHxQLxSZQQAeKqAJgM5QKogDaAulAPyEOoCuAtgEYQATiwBchANwAoSQHoZUAKJlBCAMbAaAey7AowABbQIcCDzS7QkAHSTL0AMrBB+WImRp0VJwEtUAc2ZsKTkoUIA9VmkQgBkIBAA3CBoDaDtaOE1UCBs0gDleF3gkcnRufiEg2Xlw1iA)

When `Flatten` is given an array type, it uses an indexed access with `number`
to fetch out `string[]`‚Äôs element type. Otherwise, it just returns the type it
was given.

### Inferring Within Conditional Types

We just found ourselves using conditional types to apply constraints and then
extract out types. This ends up being such a common operation that conditional
types make it easier.

Conditional types provide us with a way to infer from types we compare against
in the true branch using the `infer` keyword. For example, we could have
inferred the element type in `Flatten` instead of fetching it out ‚Äúmanually‚Äù
with an indexed access type:

    
    
    ts
    
    type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFXBAfFAXim0iggA8VUATAZygEEAnJhEdAS1QDMImoAkigC2+APyCRUAFzEcAbiA)

Here, we used the `infer` keyword to declaratively introduce a new generic
type variable named `Item` instead of specifying how to retrieve the element
type of `Type` within the true branch. This frees us from having to think
about how to dig through and probing apart the structure of the types we‚Äôre
interested in.

We can write some useful helper type aliases using the `infer` keyword. For
example, for simple cases, we can extract the return type out from function
types:

    
    
    ts
    
    type GetReturnType<Type> = Type extends (...args: never[]) => infer Return
    
      ? Return
    
      : never;
    
    ¬†
    
    type Num = GetReturnType<() => number>;
    
         
    
    type Num = number
    
    ¬†
    
    type Str = GetReturnType<(x: string) => string>;
    
         
    
    type Str = string
    
    ¬†
    
    type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;
    
          
    
    type Bools = boolean[]
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAebkAfFALxQHQQAewE6AJgM5QAUAdBwIaoDmjAXFHQQAbhFQBtALoBKUsQCW6AGbioSYGnQAoKFAD86lBl1RBwsagDc27aEhQAcsgC2pWPA1aKuFnJLE6K4ARuKENgD0EXpQAHr6tvbQAMrAqO5wiMZYOL5UgoxpSjz+xIWoxeHaUTHxiThQAEIA9s0ANsxkmV4YPiycgsGtbRCc6AA0UMGDw6PopVOzY9JVNXrxQA)

When inferring from a type with multiple call signatures (such as the type of
an overloaded function), inferences are made from the _last_ signature (which,
presumably, is the most permissive catch-all case). It is not possible to
perform overload resolution based on a list of argument types.

    
    
    ts
    
    declare function stringOrNum(x: string): number;
    
    declare function stringOrNum(x: number): string;
    
    declare function stringOrNum(x: string | number): string | number;
    
    ¬†
    
    type T1 = ReturnType<typeof stringOrNum>;
    
         
    
    type T1 = string | number
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGcMYtUBzAeRgDlkBbACgA8AuQ40sgSjdXoCMQMANwAoUJFgIU6bHnYlyVWo1bw+dQTB4LOYidDhI0mXPiKLKNeszYXO8AD7qBQnffJOXmoWNEYATwAHBAAVAEZ4AF54ACUQDGQYVFDgkAAeQJCcRF0lazoAPjEAehL4CoA9AH4gA)

## Distributive Conditional Types

When conditional types act on a generic type, they become _distributive_ when
given a union type. For example, take the following:

    
    
    ts
    
    type ToArray<Type> = Type extends any ? Type[] : never;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcQA)

If we plug a union type into `ToArray`, then the conditional type will be
applied to each member of that union.

    
    
    ts
    
    type ToArray<Type> = Type extends any ? Type[] : never;
    
    ¬†
    
    type StrArrOrNumArr = ToArray<string | number>;
    
               
    
    type StrArrOrNumArr = string[] | number[]
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKEmhIUAMrAkyJAHkkAOQCuAWxWFYiFOgx0lASyoBzKAB9BugEZjcUgPRuoXgHqsgA)

What happens here is that `ToArray` distributes on:

    
    
    ts
    
      string | number;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmUAHyjdcAIwjwA3EA)

and maps over each member type of the union, to what is effectively:

    
    
    ts
    
      ToArray<string> | ToArray<number>;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKFCQoAZWBJkSAPJIAcgFcAtssKSoUAPRGoAWgsBjTcAtmDsRCnQY6igJZUA5vgA+j5RcqHQAjMVxxIA)

which leaves us with:

    
    
    ts
    
      string[] | number[];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmA2gF0oAHyjdcAIwjwhAbiA)

Typically, distributivity is the desired behavior. To avoid that behavior, you
can surround each side of the `extends` keyword with square brackets.

    
    
    ts
    
    type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
    
    ¬†
    
    // 'ArrOfStrOrNum' is no longer a union.
    
    type ArrOfStrOrNum = ToArrayNonDist<string | number>;
    
              
    
    type ArrOfStrOrNum = (string | number)[]
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgHJwHYBECWAzsADwzgQB8UAvFANrmQC6UEAHsBNgCaEOpsIVgH5YFeqwBcUbBABuEJAG4AUKoD0GqAHJkSAPIAzAMrBDSDAFcAtjqhFZcKABscAcyVRUUK9nw4AHSqoJBQ+sZmFtY2tLCIKOhYeESkxEj42O5QAD6ytgBGSpRqWlDlAHoiQA)

### [Indexed Access TypesUsing Type['a'] syntax to access a subset of a
type.](/docs/handbook/2/indexed-access-types.html)

### [Mapped TypesGenerating types by re-using an existing
type.](/docs/handbook/2/mapped-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Conditional Types.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(10\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

BK![Benedikt K√∂nig
\(1\)](https://gravatar.com/avatar/67a495c379471d65003c17c34cbf0a04?s=32&&d=blank)

GF![George Flinn
\(1\)](https://gravatar.com/avatar/364a571118695dfc26b1a069a81801ad?s=32&&d=blank)

SF![Shinya Fujino
\(1\)](https://gravatar.com/avatar/5467412635d8b794d2f3ea5f428222e1?s=32&&d=blank)

NM![Nicol√°s Montone
\(1\)](https://gravatar.com/avatar/808a426610e875611d0e1f5e2e23c7f8?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Everyday Types

In this chapter, we‚Äôll cover some of the most common types of values you‚Äôll
find in JavaScript code, and explain the corresponding ways to describe those
types in TypeScript. This isn‚Äôt an exhaustive list, and future chapters will
describe more ways to name and use other types.

Types can also appear in many more _places_ than just type annotations. As we
learn about the types themselves, we‚Äôll also learn about the places where we
can refer to these types to form new constructs.

We‚Äôll start by reviewing the most basic and common types you might encounter
when writing JavaScript or TypeScript code. These will later form the core
building blocks of more complex types.

## The primitives: `string`, `number`, and `boolean`

JavaScript has three very commonly used
[primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive):
`string`, `number`, and `boolean`. Each has a corresponding type in
TypeScript. As you might expect, these are the same names you‚Äôd see if you
used the JavaScript `typeof` operator on a value of those types:

  * `string` represents string values like `"Hello, world"`
  * `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there‚Äôs no equivalent to `int` or `float` \- everything is simply `number`
  * `boolean` is for the two values `true` and `false`

> The type names `String`, `Number`, and `Boolean` (starting with capital
> letters) are legal, but refer to some special built-in types that will very
> rarely appear in your code. _Always_ use `string`, `number`, or `boolean`
> for types.

## Arrays

To specify the type of an array like `[1, 2, 3]`, you can use the syntax
`number[]`; this syntax works for any type (e.g. `string[]` is an array of
strings, and so on). You may also see this written as `Array<number>`, which
means the same thing. We‚Äôll learn more about the syntax `T<U>` when we cover
_generics_.

> Note that `[number]` is a different thing; refer to the section on
> [Tuples](/docs/handbook/2/objects.html#tuple-types).

## `any`

TypeScript also has a special type, `any`, that you can use whenever you don‚Äôt
want a particular value to cause typechecking errors.

When a value is of type `any`, you can access any properties of it (which will
in turn be of type `any`), call it like a function, assign it to (or from) a
value of any type, or pretty much anything else that‚Äôs syntactically legal:

    
    
    ts
    
    let obj: any = { x: 0 };
    
    // None of the following lines of code will throw compiler errors.
    
    // Using `any` disables all further type checking, and it is assumed
    
    // you know the environment better than TypeScript.
    
    obj.foo();
    
    obj();
    
    obj.bar = 100;
    
    obj = "hello";
    
    const n: number = obj;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gRgVgLggQwHYE8IF4IG8IAeSADBAL4DcAsAFAD0dEAclKiNAGYRgAW7HUYMCgB3AJaoA5hGASQAZ04QAxlAAm7cUO48ATqJVQAtgAcxoXRBC79u+QDpaDCAFV5E6QAM06TxDVi8sgwoIrI2hwArrq81tzoJuzKfMoA1h4ANCioahBikIEo8vKRRiBqTozoUJEQqagGsVaoAG5i+qhlqJAw4GBxvGgQACoJIADKyrpiJmCONLBw9gJQABQAlNQL8Btbi-YwyJY4AIzExHvw2BAARHxCUDdbqqjykKhIqKW9x9DwFEA)

The `any` type is useful when you don‚Äôt want to write out a long type just to
convince TypeScript that a particular line of code is okay.

### `noImplicitAny`

When you don‚Äôt specify a type, and TypeScript can‚Äôt infer it from context, the
compiler will typically default to `any`.

You usually want to avoid this, though, because `any` isn‚Äôt type-checked. Use
the compiler flag [`noImplicitAny`](/tsconfig#noImplicitAny) to flag any
implicit `any` as an error.

## Type Annotations on Variables

When you declare a variable using `const`, `var`, or `let`, you can optionally
add a type annotation to explicitly specify the type of the variable:

    
    
    ts
    
    let myName: string = "Alice";
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngcgQyiAXBAzmATgSwHYDmEAvBAEQCCwOAxiGQNwCwAUAPRsRfdcB6-A-hAAqMAA4gICPHgD2YBGByy8QA)

> TypeScript doesn‚Äôt use ‚Äútypes on the left‚Äù-style declarations like `int x =
> 0;` Type annotations will always go _after_ the thing being typed.

In most cases, though, this isn‚Äôt needed. Wherever possible, TypeScript tries
to automatically _infer_ the types in your code. For example, the type of a
variable is inferred based on the type of its initializer:

    
    
    ts
    
    // No type annotation needed -- 'myName' inferred as type 'string'
    
    let myName = "Alice";
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEDkHtQFwTwA4FNQEMB27I1TAlpOqOkkgCbmgC0VoA5ALZzioNJ2h7oBmSATn0qoAzrEQo6wmHy4BzOgFgAUABskMUExZtQAXlAAiAIIq8AYyQGA3EA)

For the most part you don‚Äôt need to explicitly learn the rules of inference.
If you‚Äôre starting out, try using fewer type annotations than you think - you
might be surprised how few you need for TypeScript to fully understand what‚Äôs
going on.

## Functions

Functions are the primary means of passing data around in JavaScript.
TypeScript allows you to specify the types of both the input and output values
of functions.

### Parameter Type Annotations

When you declare a function, you can add type annotations after each parameter
to declare what types of parameters the function accepts. Parameter type
annotations go after the parameter name:

    
    
    ts
    
    // Parameter type annotation
    
    function greet(name: string) {
    
      console.log("Hello, " + name.toUpperCase() + "!!");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHVEgngBwaSA7fAeyUiQEsj8BYAKADMBXfAYwqtAHNoFkAKfPAQAuUAGck0cvk4BKUAG86oUCBXqNm9QD1de3ctAsqYogBsEAOjNFOfAEQAJBGZsAaUPdABqUIMSWSEQAqlg40ADCkGIIfPK+9gCEifayANx0AL5AA)

When a parameter has a type annotation, arguments to that function will be
checked:

    
    
    ts
    
    // Would be a runtime error if executed!
    
    greet(42);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgDmNkrABRNKAW0ipEraOyY8AlKgBucdkQDchEKAC0e0g1Z6dWsAHU4DckVAAjWpVDRmHcaBjxoodnXcAPMkNIIgBCQj5IAUEsNHl1IA)

> Even if you don‚Äôt have type annotations on your parameters, TypeScript will
> still check that you passed the right number of arguments.

### Return Type Annotations

You can also add return type annotations. Return type annotations appear after
the parameter list:

    
    
    ts
    
    function getFavoriteNumber(): number {
    
      return 26;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQGIEMBucBOMUqAciALYBGq+AFAJQBciYF1+iA3gLABQiiAPSCBoseIliAejNky+A-OhD4kAJgBsAbj4BfIA)

Much like variable type annotations, you usually don‚Äôt need a return type
annotation because TypeScript will infer the function‚Äôs return type based on
its `return` statements. The type annotation in the above example doesn‚Äôt
change anything. Some codebases will explicitly specify a return type for
documentation purposes, to prevent accidental changes, or just for personal
preference.

#### Functions Which Return Promises

If you want to annotate the return type of a function which returns a promise,
you should use the `Promise` type:

    
    
    ts
    
    async function getFavoriteNumber(): Promise<number> {
    
      return 26;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkBiwAbugE6rK4ByCAtgEa5kAUAlAFwwAKZ6dqELgA8EekzIA+GAG8AsACgYMMvgRksAJgBsAbkUBfIA)

### Anonymous Functions

Anonymous functions are a little bit different from function declarations.
When a function appears in a place where TypeScript can determine how it‚Äôs
going to be called, the parameters of that function are automatically given
types.

Here‚Äôs an example:

    
    
    ts
    
    const names = ["Alice", "Bob", "Eve"];
    
    ¬†
    
    // Contextual typing for function - parameter s inferred to have type string
    
    names.forEach(function (s) {
    
      console.log(s.toUpperCase());
    
    });
    
    ¬†
    
    // Contextual typing also applies to arrow functions
    
    names.forEach((s) => {
    
      console.log(s.toUpperCase());
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYCwAoAYzgDtEAXUEgQwFtJFQBeUAbQCIBBAGwEtDI7ADSh2AITgAjYaICiAN0EBdANwECIUAGFS5SAA9yAV2rdQ5AJ4AHXiQDmoAGYInRkoXK9SoALSgr1NB0kHrQoIy2jjDQkAAm5nCgABbUiubWkOHk0LZ2BDT0iAB0ztCy1IRJABSObh5eJKBViACUoADeBKCgxGRw3JBF3HB2zUXkcACqVlYwWtSIkFUtLWr4AL6r6viaOiR6hiZmljb2oKaIidQzfAwJ57BwAO6u7p6kiPnBxaXllVXNNpMAB8HS6PQ+-UGw1GxQm01m0Hmi2WWw2qyAA)

Even though the parameter `s` didn‚Äôt have a type annotation, TypeScript used
the types of the `forEach` function, along with the inferred type of the
array, to determine the type `s` will have.

This process is called _contextual typing_ because the _context_ that the
function occurred within informs what type it should have.

Similar to the inference rules, you don‚Äôt need to explicitly learn how this
happens, but understanding that it _does_ happen can help you notice when type
annotations aren‚Äôt needed. Later, we‚Äôll see more examples of how the context
that a value occurs in can affect its type.

## Object Types

Apart from primitives, the most common sort of type you‚Äôll encounter is an
_object type_. This refers to any JavaScript value with properties, which is
almost all of them! To define an object type, we simply list its properties
and their types.

For example, here‚Äôs a function that takes a point-like object:

    
    
    ts
    
    // The parameter's type annotation is an object type
    
    function printCoord(pt: { x: number; y: number }) {
    
      console.log("The coordinate's x value is " + pt.x);
    
      console.log("The coordinate's y value is " + pt.y);
    
    }
    
    printCoord({ x: 3, y: 7 });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIOQGdQMBPOWBAO3IHsMEMBLK80egi0KgIwCtoBjDIRLQAsACgAZgFdyAxszhJ65DAGEqVJABMAFHAwAuUAG9QADyPkpqTtgDcoIpeu2koAL4BKE+NCgQfoFBwSF+AHoRkVHRMZG+oHxMeFQANtAAdClUAOY6AERQsImaWsp00PjmoABuCClSsKygeaAA1PAY6WaedvGJ5MlpmTn5hQka2mVYlUQ1dQ0sBC3t+ulEPeLu4orKahO6phagAMwANI5GAOwePUA)

Here, we annotated the parameter with a type with two properties - `x` and `y`
\- which are both of type `number`. You can use `,` or `;` to separate the
properties, and the last separator is optional either way.

The type part of each property is also optional. If you don‚Äôt specify a type,
it will be assumed to be `any`.

### Optional Properties

Object types can also specify that some or all of their properties are
_optional_. To do this, add a `?` after the property name:

    
    
    ts
    
    function printName(obj: { first: string; last?: string }) {
    
      // ...
    
    }
    
    // Both OK
    
    printName({ first: "Bob" });
    
    printName({ first: "Alice", last: "Alisson" });
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAcgQwLYCmAFHAEYBWAXIgN6LAyoDOU1L6YA5gNyIA2OFgH42UDp0QBfAJS0AsAChEiAPQrEAOi2LJitYgBCcKAAtEAeQDSitBmz5idBs1aIAREdJup07jY72hEROjCzUbgCCfDAQBG4ANPyCrpHRTEwI3jLcQA)

In JavaScript, if you access a property that doesn‚Äôt exist, you‚Äôll get the
value `undefined` rather than a runtime error. Because of this, when you
_read_ from an optional property, you‚Äôll have to check for `undefined` before
using it.

    
    
    ts
    
    function printName(obj: { first: string; last?: string }) {
    
      // Error - might crash if 'obj.last' wasn't provided!
    
      console.log(obj.last.toUpperCase());
    
    'obj.last' is possibly 'undefined'.18048'obj.last' is possibly 'undefined'.
    
      if (obj.last !== undefined) {
    
        // OK
    
        console.log(obj.last.toUpperCase());
    
      }
    
    ¬†
    
      // A safe alternative using modern JavaScript syntax:
    
      console.log(obj.last?.toUpperCase());
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMAWDBYAKADMBXAOwGMAXASznNAAdpbzqA5AQwFtIAKOACMAVqgDeoYrSTVUiaq3IBzANygANlwUB+eYrbLQAXwCUocUVCgQoAKKwEoALSgetZQAtqoStG2eoLTEoADkwiIAdFoKoaAA7trkoT4scAButAAmkFkAhFa+DIhwGpDRcMqCotHa1JHUcACqTEwwAMLaAqamqoXBoNVRMT55ALxjoBQ50uS55paE1ta2APIA0oXWlMWl5RqVQ7UKDc2tHV38PX1LJkSFtgCCoIhcxJCgXBrUMORcdOkPqREIY3HActBGAApLjpLgAZT8tCYPkQAE92FwAB7IQo7cglMoVKoRY7UHSnFptaCdRDdXpEYxAA)

## Union Types

TypeScript‚Äôs type system allows you to build new types out of existing ones
using a large variety of operators. Now that we know how to write a few types,
it‚Äôs time to start _combining_ them in interesting ways.

### Defining a Union Type

The first way to combine types you might see is a _union_ type. A union type
is a type formed from two or more other types, representing values that may be
_any one_ of those types. We refer to each of these types as the union‚Äôs
_members_.

Let‚Äôs write a function that can operate on strings or numbers:

    
    
    ts
    
    function printId(id: number | string) {
    
      console.log("Your ID is: " + id);
    
    }
    
    // OK
    
    printId(101);
    
    // OK
    
    printId("202");
    
    // Error
    
    printId({ myID: 22342 });
    
    Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.2345Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAkgCYAUNnqZEgFsARjFAAfUIiosyAcwCUoAN6FQoCvURwANpAB0uuPO4AiAJpwS0UOwAioGilBnQAaiedFAbkIBfQhBQAHkAaUJmVg4eAEYABljfILBwyLkY8zR4tDNkgmCAUVgEdOiubhVQIQBPB1Q0TCw0UH9fIA)

### Working with Union Types

It‚Äôs easy to _provide_ a value matching a union type - simply provide a type
matching any of the union‚Äôs members. If you _have_ a value of a union type,
how do you work with it?

TypeScript will only allow an operation if it is valid for _every_ member of the union. For example, if you have the union `string | number`, you can‚Äôt use methods that are only available on `string`:
    
    
    ts
    
    function printId(id: number | string) {
    
      console.log(id.toUpperCase());
    
    Property 'toUpperCase' does not exist on type 'string | number'.
      Property 'toUpperCase' does not exist on type 'number'.2339Property 'toUpperCase' does not exist on type 'string | number'.
      Property 'toUpperCase' does not exist on type 'number'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoAMwFcA7AYwBcBLOU0AB2mtMoEkATACmo9VOIBbAEYxQAH1CJKzUgHMAlKADeBUKHJ1EcADaQAdDrhyeHfZTgBVBgxgBhAIaJIXBQoDcBAL5A)

The solution is to _narrow_ the union with code, the same as you would in
JavaScript without type annotations. _Narrowing_ occurs when TypeScript can
deduce a more specific type for a value based on the structure of the code.

For example, TypeScript knows that only a `string` value will have a `typeof`
value `"string"`:

    
    
    ts
    
    function printId(id: number | string) {
    
      if (typeof id === "string") {
    
        // In this branch, id is of type 'string'
    
        console.log(id.toUpperCase());
    
      } else {
    
        // Here, id is of type 'number'
    
        console.log(id);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAkgEwBQw4BciYIAtgEYCmqiAPogM5TpgDmAlIgN4CwAKESIYwRHigBPZNThjCiALzLEAIhZt2q7vyHDEAegOIsSKAAsYTRJVQBDSOYA0InCOtzEUmYgDkGjHZfQX1ECAQmOAAbagA6KLh2AhxYqDgAVWQZVABhOyZqPE5OAG4QxABfRGoogt5y4SNEAAlaahcFK0RPb2o-MipaYL1hcLBImPjE5NLyisEKoA)

Another example is to use a function like `Array.isArray`:

    
    
    ts
    
    function welcomePeople(x: string[] | string) {
    
      if (Array.isArray(x)) {
    
        // Here: 'x' is 'string[]'
    
        console.log("Hello, " + x.join(" and "));
    
      } else {
    
        // Here: 'x' is 'string'
    
        console.log("Welcome lone traveler " + x);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwKYBsJwLaoAqpwAO6qAFAB4BciAzlAE4xgDmA2gLqIA+djzLAJSIA3gFgAUIkQxgiMgEEGDAIYBPAHQxaS1WsqDh4qdMQB6M4gASqBqhoByCg5m1ED+k1acHk04iwwWjhSDXQ4FjIAIht0cIAaRCjEAGpECg0AKzhmaMQVMAATJMMAbj9EAF9EDFpUUQrpC2tbe3dnV3dPAV8TaUDg0PDIqIB1DCxcRHCwesYVADcMWyTU9MFyk0rJSqA)

Notice that in the `else` branch, we don‚Äôt need to do anything special - if
`x` wasn‚Äôt a `string[]`, then it must have been a `string`.

Sometimes you‚Äôll have a union where all the members have something in common.
For example, both arrays and strings have a `slice` method. If every member in
a union has a property in common, you can use that property without narrowing:

    
    
    ts
    
    // Return type is inferred as number[] | string
    
    function getFirstThree(x: number[] | string) {
    
      return x.slice(0, 3);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMBcFcCcB2poE8AOlQEsDOPEAzSeeSAE1AEN9FYBbAIxIG0BdUAH1F2nm0QBzALAAoQrEQBjaNgD2yQTABi2eLwAqACzKQAFAA8AXKDpNWHbr35CAlKADeY0KDJwkoAwDpcAG2xS+gAMADSgAMy2ANxiAL5AA)

> It might be confusing that a _union_ of types appears to have the _intersection_ of those types‚Äô properties. This is not an accident - the name _union_ comes from type theory. The _union_ `number | string` is composed by taking the union _of the values_ from each type. Notice that given two sets with corresponding facts about each set, only the _intersection_ of those facts applies to the _union_ of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about _every_ person is that they must be wearing a hat.

## Type Aliases

We‚Äôve been using object types and union types by writing them directly in type
annotations. This is convenient, but it‚Äôs common to want to use the same type
more than once and refer to it by a single name.

A _type alias_ is exactly that - a _name_ for any _type_. The syntax for a
type alias is:

    
    
    ts
    
    type Point = {
    
      x: number;
    
      y: number;
    
    };
    
    ¬†
    
    // Exactly the same as the earlier example
    
    function printCoord(pt: Point) {
    
      console.log("The coordinate's x value is " + pt.x);
    
      console.log("The coordinate's y value is " + pt.y);
    
    }
    
    ¬†
    
    printCoord({ x: 100, y: 100 });
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbwLACgpQAeAXFEgK4C2ARhAE4DceBIpFN9TuAvl3gPT8oAUUIBDAMbAANiCjAAFtADOYytDHL5SqBDF1pCervGUw0iHgBm5JFIRwkUMHWTAAwnDh0AJgAowYFJ4NwBKLGYoCUdlOAsAOmk4AHM-ACIAFR1o7x9kMWAIAHItQigANzFpcmgELTSoAGpnYHjCUK4CaKRYhKTUzOyvX3zCkqg5Sura+qaW+JAOvG48PBc3T1y-TCJSAEYABgOAGgn9o6huDqA)

You can actually use a type alias to give a name to any type at all, not just
an object type. For example, a type alias can name a union type:

    
    
    ts
    
    type ID = number | string;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAkgIlAvFAdgVwLYCMICcoA+UAzsLgJYoDmA3EA)

Note that aliases are _only_ aliases - you cannot use type aliases to create
different/distinct ‚Äúversions‚Äù of the same type. When you use the alias, it‚Äôs
exactly as if you had written the aliased type. In other words, this code
might _look_ illegal, but is OK according to TypeScript because both types are
aliases for the same type:

    
    
    ts
    
    type UserInputSanitizedString = string;
    
    ¬†
    
    function sanitizeInput(str: string): UserInputSanitizedString {
    
      return sanitize(str);
    
    }
    
    ¬†
    
    // Create a sanitized input
    
    let userInput = sanitizeInput(getInput());
    
    ¬†
    
    // Can still be re-assigned with a string though
    
    userInput = "new input";
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBJVAB2QwAoBKALngGcMYtUCBuAWAChRIsBCnTY8zKKizYAXiGosYjRewINmrVT14B6HfAC0RsFSMG+GAJ7kEAVSYgYZShgDKk6VjnBXmjvABeDTYObT4RTFx8Jg9ZEGcqBVZlPzVGe0cEt1ivEB9U+ABvPnh4OAxkGGicuSSYWm0AXz4+PXgAYTgoDAQoCSk44Hh2Fz4IYnhkBycKKkD+zzks6iJSWZpaBpbdfXbJDSwICHgAIwQ4AygmJiwCVDz4AHdpAAt4PpV-DBecZAIXvhTTLreYAInuj2G61BnCAA)

## Interfaces

An _interface declaration_ is another way to name an object type:

    
    
    ts
    
    interface Point {
    
      x: number;
    
      y: number;
    
    }
    
    ¬†
    
    function printCoord(pt: Point) {
    
      console.log("The coordinate's x value is " + pt.x);
    
      console.log("The coordinate's y value is " + pt.y);
    
    }
    
    ¬†
    
    printCoord({ x: 100, y: 100 });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwLABQyyAHgFzIgCuAtgEbQDchxAnhdfU4QL6GEwqIBGGDoQyAA5QsAYXTooAEwAUksBQxYAlLhbIE4gM7oANhAB0p9AHMVAIgAqACxSHFS0HEgByI6WQANzhTKhRgf3tkAGopMAsSbWYiA2MzS2s7J1dUjy9ff1YgkLDkCOQo2PULViTefgJpOQVlFRxSCgBGAAZugBpkdmQe7uQeJKA)

Just like when we used a type alias above, the example works just as if we had
used an anonymous object type. TypeScript is only concerned with the
_structure_ of the value we passed to `printCoord` \- it only cares that it
has the expected properties. Being concerned only with the structure and
capabilities of types is why we call TypeScript a _structurally typed_ type
system.

### Differences Between Type Aliases and Interfaces

Type aliases and interfaces are very similar, and in many cases you can choose
between them freely. Almost all features of an `interface` are available in
`type`, the key distinction is that a type cannot be re-opened to add new
properties vs an interface which is always extendable.

`Interface` | `Type`  
---|---  
Extending an interface `

    
    
    interface Animal {
      name: string;
    }  
    
    interface Bear extends Animal {
      honey: boolean;
    }  
    
    const bear = getBear();
    bear.name;
    bear.honey;
            

` |  Extending a type via intersections `
    
    
    type Animal = {
      name: string;
    }  
    
    type Bear = Animal & { 
      honey: boolean;
    }  
    
    const bear = getBear();
    bear.name;
    bear.honey;
            

`  
Adding new fields to an existing interface `

    
    
    interface Window {
      title: string;
    }  
    
    interface Window {
      ts: TypeScriptAPI;
    }  
    
    const src = 'const a = "Hello World"';
    window.ts.transpileModule(src, {});
            

` |  A type cannot be changed after being created `
    
    
    type Window = {
      title: string;
    }  
    
    type Window = {
      ts: TypeScriptAPI;
    }  
    
     // Error: Duplicate identifier 'Window'.  
    
            

`  
  
You‚Äôll learn more about these concepts in later chapters, so don‚Äôt worry if
you don‚Äôt understand all of these right away.

  * Prior to TypeScript version 4.2, type alias names [_may_ appear in error messages](/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA), sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.
  * Type aliases may not participate [in declaration merging, but interfaces can](/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA).
  * Interfaces may only be used to [declare the shapes of objects, not rename primitives](/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA).
  * Interface names will [_always_ appear in their original form](/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA) in error messages, but _only_ when they are used by name.
  * Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections) than type aliases with intersections

For the most part, you can choose based on personal preference, and TypeScript
will tell you if it needs something to be the other kind of declaration. If
you would like a heuristic, use `interface` until you need to use features
from `type`.

## Type Assertions

Sometimes you will have information about the type of a value that TypeScript
can‚Äôt know about.

For example, if you‚Äôre using `document.getElementById`, TypeScript only knows
that this will return _some_ kind of `HTMLElement`, but you might know that
your page will always have an `HTMLCanvasElement` with a given ID.

In this situation, you can use a _type assertion_ to specify a more specific
type:

    
    
    ts
    
    const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgExGAFc4BTMKAOgHMyoBRAGzPMoCEEBJfACgCI4KAJZgA+sDSYI-AJQwsMABIAVALIAZVBizNWFKAG4gA)

Like a type annotation, type assertions are removed by the compiler and won‚Äôt
affect the runtime behavior of your code.

You can also use the angle-bracket syntax (except if the code is in a `.tsx`
file), which is equivalent:

    
    
    ts
    
    const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgHgAkAVAWQBlUMsBRAGwFM4GwoA+AExGAFdnWAdAHMGUekxZQAQggCSHABQAiOCgCWYAPrA0mCEoCUAbiA)

> Reminder: Because type assertions are removed at compile-time, there is no
> runtime checking associated with a type assertion. There won‚Äôt be an
> exception or `null` generated if the type assertion is wrong.

TypeScript only allows type assertions which convert to a _more specific_ or
_less specific_ version of a type. This rule prevents ‚Äúimpossible‚Äù coercions
like:

    
    
    ts
    
    const x = "hello" as number;
    
    Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.2352Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCsaCwAoAYzgDtEAXUAD1AF5QAiAC0gBtW4HQBDRUEgK4BbAEYwA3EA)

Sometimes this rule can be too conservative and will disallow more complex
coercions that might be valid. If this happens, you can use two assertions,
first to `any` (or `unknown`, which we‚Äôll introduce later), then to the
desired type:

    
    
    ts
    
    const a = expr as any as T;
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iAHgBxgC54oUBPAbgFgAoDMvBAFXgF54BvE4gRgvgBGxAEz8wxAMzwAvtRoB6efAC0qsAFcMq5bWTosUNtnwwSaEuTPwmFIA)

## Literal Types

In addition to the general types `string` and `number`, we can refer to
_specific_ strings and numbers in type positions.

One way to think about this is to consider how JavaScript comes with different
ways to declare a variable. Both `var` and `let` allow for changing what is
held inside the variable, and `const` does not. This is reflected in how
TypeScript creates types for literals.

    
    
    ts
    
    let changingString = "Hello World";
    
    changingString = "Ol√° Mundo";
    
    // Because `changingString` can represent any possible string, that
    
    // is how TypeScript describes it in the type system
    
    changingString;
    
          
    
    let changingString: string
    
    ¬†
    
    const constantString = "Hello World";
    
    // Because `constantString` can only represent 1 possible string, it
    
    // has a literal type representation
    
    constantString;
    
          
    
    const constantString: "Hello World"
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxgFghgOwOYEtkGUwCc1IgXggCIAJEYYAewgHVKtgATIgbgFgAoWRVDbXAsQDywAIcQAsgFcEjSq04B6RRABCIKHCkBnEBAAG3ZLkw5k+6IghYQABxu6EkRAE8Itytu0oARqAja-MgANBBg8GBKKijaEDCUAO4QACoutiDoUDi2kIwg2lm++RAokGhhMHpgaXraLoEgALacRrxIprjsHMoQAHoA-JwtlAiB0COBiGAdyIKk5FS09EwK3Srqmjp6hhNgUzNIFpoIECPAbjb2+SBOEACM7p7efrVBSKGlUXFwsXAQwKUQFg4MAwjVrHYHDc9mAUCNhqM9k4Dl0egMgA)

By themselves, literal types aren‚Äôt very valuable:

    
    
    ts
    
    let x: "hello" = "hello";
    
    // OK
    
    x = "hello";
    
    // ...
    
    x = "howdy";
    
    Type '"howdy"' is not assignable to type '"hello"'.2322Type '"howdy"' is not assignable to type '"hello"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UAiAC0gILktAF5Qa6HKBufEUAeQDS+Miza16jHnj4A6eSLE04AdwAmAT25A)

It‚Äôs not much use to have a variable that can only have one value!

But by _combining_ literals into unions, you can express a much more useful
concept - for example, functions that only accept a certain set of known
values:

    
    
    ts
    
    function printText(s: string, alignment: "left" | "right" | "center") {
    
      // ...
    
    }
    
    printText("Hello, world", "left");
    
    printText("G'day, mate", "centre");
    
    Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.2345Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAKpAB5UAUKoRFRZkA5gBpQAQwA2NUWQC2kNqgBEMyESprQAH1BqWogBY79hiiqow1ASlABvQqFAhQAOi+EAvoWasHNx8agASkDIycJIA7ggyACZqkhpaOnYA3P4iQTy8agDiAOQJUgCekopSNsmW1tCQ9hlAA)

Numeric literal types work the same way:

    
    
    ts
    
    function compare(a: string, b: string): -1 | 0 | 1 {
    
      return a === b ? 0 : a > b ? 1 : -1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbADgQwE4FMAUmAXIgM5TYxgDmANIgEYnmU0CUJAtAIyIA+iAAz9EvAN4BYAFCJEeKCGxJMiALzrGiAPxDEJFQD5NO3l24BuaQF8gA)

Of course, you can combine these with non-literal types:

    
    
    ts
    
    interface Options {
    
      width: number;
    
    }
    
    function configure(x: Options | "auto") {
    
      // ...
    
    }
    
    configure({ width: 100 });
    
    configure("auto");
    
    configure("automatic");
    
    Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.2345Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACWAdgC4wBmAhgMaSgDyADmUXCYqAN6GigB3IgBMyAC1QkArgFsARjADchAL6FKUkrTYdQtDpSIBzKdEgAKAB6oWOzqAA+oAETUpZOM4CUPPqBCgAHTBqoT6JIYmZubcgiLiqACMAAzJoCpeygThkaYWru6emWEGxnnmBR4y1Gy03opAA)

There‚Äôs one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.

### Literal Inference

When you initialize a variable with an object, TypeScript assumes that the
properties of that object might change values later. For example, if you wrote
code like this:

    
    
    ts
    
    const obj = { counter: 0 };
    
    if (someCondition) {
    
      obj.counter = 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEAwqsAJYYmoBc8ARkkhCFCgNwCwAUAPRfwC0AsAFcMAvp2TosSGgCt4AXngBvREiEoMIGNQAM8AL7sOJAGbwAFDnxEUpcqgCUKzvHgzZAOmQatMRfAAjMYGQA)

TypeScript doesn‚Äôt assume the assignment of `1` to a field which previously
had `0` is an error. Another way of saying this is that `obj.counter` must
have the type `number`, not `0`, because types are used to determine both
_reading_ and _writing_ behavior.

The same applies to strings:

    
    
    ts
    
    declare function handleRequest(url: string, method: "GET" | "POST"): void;
    
    ¬†
    
    const req = { url: "https://example.com", method: "GET" };
    
    handleRequest(req.url, req.method);
    
    Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.2345Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgAWlTRcpABKkAI4NIiVgAoG0cqmnR2TAOYAaUAFtIrHnCKoARAHEAogBVjoAD6hjABQDyAZWsBKVADc47IgDchISkXNKgNGKgALygAN6g8ooOPKysAA4oIJAAHpTa6UIAdKHaxlq6+oYmFtagAL5BBHwCQqISUrKRRUla3ZUGRB4BQA)

In the above example `req.method` is inferred to be `string`, not `"GET"`.
Because code can be evaluated between the creation of `req` and the call of
`handleRequest` which could assign a new string like `"GUESS"` to
`req.method`, TypeScript considers this code to have an error.

There are two ways to work around this.

  1. You can change the inference by adding a type assertion in either location:
    
        ts
    
    // Change 1:
    
    const req = { url: "https://example.com", method: "GET" as "GET" };
    
    // Change 2
    
    handleRequest(req.url, req.method as "GET");
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm-fgBhInwQARjYbMDwGeDgqeABeeABveBZ2dQIMDAAHOjZ7EAAPKCEMsgA6MKEpQRExCWl5JXgoOnV65QBfKzsHP2JeBAAmG39SCmpaBkYokuTBKerxYEbm2UUpfXMgA)

Change 1 means ‚ÄúI intend for `req.method` to always have the _literal type_
`"GET"`‚Äù, preventing the possible assignment of `"GUESS"` to that field after.
Change 2 means ‚ÄúI know for other reasons that `req.method` has the value
`"GET"`‚Äú.

  2. You can use `as const` to convert the entire object to be type literals:
    
        ts
    
    const req = { url: "https://example.com", method: "GET" } as const;
    
    handleRequest(req.url, req.method);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm2DwN4cKvAAvPAA3vAs7OoEGBgADnRs9iAAHlBCsWQAdN5CUoIiYhLS8krwAL7wUHTw3qgMVtZEJGSUNPRM-pkRgp0F4sD65kA)

The `as const` suffix acts like `const` but for the type system, ensuring that
all properties are assigned the literal type instead of a more general version
like `string` or `number`.

## `null` and `undefined`

JavaScript has two primitive values used to signal absent or uninitialized
value: `null` and `undefined`.

TypeScript has two corresponding _types_ by the same names. How these types
behave depends on whether you have the
[`strictNullChecks`](/tsconfig#strictNullChecks) option on.

### `strictNullChecks` off

With [`strictNullChecks`](/tsconfig#strictNullChecks) _off_ , values that
might be `null` or `undefined` can still be accessed normally, and the values
`null` and `undefined` can be assigned to a property of any type. This is
similar to how languages without null checks (e.g. C#, Java) behave. The lack
of checking for these values tends to be a major source of bugs; we always
recommend people turn [`strictNullChecks`](/tsconfig#strictNullChecks) on if
it‚Äôs practical to do so in their codebase.

### `strictNullChecks` on

With [`strictNullChecks`](/tsconfig#strictNullChecks) _on_ , when a value is
`null` or `undefined`, you will need to test for those values before using
methods or properties on that value. Just like checking for `undefined` before
using an optional property, we can use _narrowing_ to check for values that
might be `null`:

    
    
    ts
    
    function doSomething(x: string | null) {
    
      if (x === null) {
    
        // do nothing
    
      } else {
    
        console.log("Hello, " + x.toUpperCase());
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAB4BciAzlAE6FGIA+iYIANhwJSIDeAWABQiRDGCJyiALyy2nHv2GjRAelUo4bOPkbLEAX0TYO1bEpEqICanA7YAdBzikARAAkTzgDSJXiAGpEMgcoOABVAAdI7DoAYQBDMxJubgBufQNhAyA)

### Non-null Assertion Operator (Postfix `!`)

TypeScript also has a special syntax for removing `null` and `undefined` from
a type without doing any explicit checking. Writing `!` after any expression
is effectively a type assertion that the value isn‚Äôt `null` or `undefined`:

    
    
    ts
    
    function liveDangerously(x?: number | null) {
    
      // No error
    
      console.log(x!.toFixed());
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGxgNwKYBECGYDmGATnCAM7ICeAFAB4D8AXImCALYBGxiAPiyMmQBKRAG8AsAChEiAPSzEAOTiJiJIlJkQEZOMgwA6ZHHx0AhAahwAYjFoYAJtSFCA3FIC+QA)

Just like other type assertions, this doesn‚Äôt change the runtime behavior of
your code, so it‚Äôs important to only use `!` when you know that the value
_can‚Äôt_ be `null` or `undefined`.

## Enums

Enums are a feature added to JavaScript by TypeScript which allows for
describing a value which could be one of a set of possible named constants.
Unlike most TypeScript features, this is _not_ a type-level addition to
JavaScript but something added to the language and runtime. Because of this,
it‚Äôs a feature which you should know exists, but maybe hold off on using
unless you are sure. You can read more about enums in the [Enum reference
page](/docs/handbook/enums.html).

## Less Common Primitives

It‚Äôs worth mentioning the rest of the primitives in JavaScript which are
represented in the type system. Though we will not go into depth here.

#### `bigint`

From ES2020 onwards, there is a primitive in JavaScript used for very large
integers, `BigInt`:

    
    
    ts
    
    // Creating a bigint via the BigInt function
    
    const oneHundred: bigint = BigInt(100);
    
    ¬†
    
    // Creating a BigInt via the literal syntax
    
    const anotherHundred: bigint = 100n;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGXBYAKCJFAGFZFpIBLAO3lGlACMb57JQA3G5yABaJQAIXYBJOlwBmAVzoBjWgHs6RBaoxdViABLyAJpQNo2HKaAC8oiVIAUARhw4AlAG4iJMBSq0GTG3hJLl5+IVAAGxpIRFhoCNAMAE8paAAPdU0uaDplQVj9OiNEE1Z2TitQJxw6NyA)

You can learn more about BigInt in [the TypeScript 3.2 release
notes](/docs/handbook/release-notes/typescript-3-2.html#bigint).

#### `symbol`

There is a primitive in JavaScript used to create a globally unique reference
via the function `Symbol()`:

    
    
    ts
    
    const firstName = Symbol("name");
    
    const secondName = Symbol("name");
    
    ¬†
    
    if (firstName === secondName) {
    
    This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.2367This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.
    
      // Can't ever happen
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AsAFADGcAdogC6gBmAlkhQHICGAtpKALygDKAnqwBGcADYAKAESk2kCQEoA3IRLkqiSCoAmLdl14Dh4qTPlKChWtVBi6DHR06PQ6rfbmgA3oVCgQoAMLMpADkVJAAbjCgABbMAA5xkKSEAL5AA)

You can learn more about them in [Symbols reference
page](/docs/handbook/symbols.html).

### [The BasicsStep one in learning TypeScript: The basic
types.](/docs/handbook/2/basic-types.html)

### [NarrowingUnderstand how TypeScript uses JavaScript knowledge to reduce
the amount of type syntax in your projects.](/docs/handbook/2/narrowing.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Everyday Types.md)
‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(56\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(22\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

UG![Utku Gultopu
\(3\)](https://gravatar.com/avatar/c232fb5cf00305df477f035a89b9f1a4?s=32&&d=blank)

AB![Andrew Branch
\(2\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

DR![Daniel Rosenwasser
\(2\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

30+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# More on Functions

Functions are the basic building block of any application, whether they‚Äôre
local functions, imported from another module, or methods on a class. They‚Äôre
also values, and just like other values, TypeScript has many ways to describe
how functions can be called. Let‚Äôs learn about how to write types that
describe functions.

## Function Type Expressions

The simplest way to describe a function is with a _function type expression_.
These types are syntactically similar to arrow functions:

    
    
    ts
    
    function greeter(fn: (a: string) => void) {
    
      fn("Hello, World");
    
    }
    
    ¬†
    
    function printToConsole(s: string) {
    
      console.log(s);
    
    }
    
    ¬†
    
    greeter(printToConsole);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA)

The syntax `(a: string) => void` means ‚Äúa function with one parameter, named
`a`, of type `string`, that doesn‚Äôt have a return value‚Äù. Just like with
function declarations, if a parameter type isn‚Äôt specified, it‚Äôs implicitly
`any`.

> Note that the parameter name is **required**. The function type `(string) =>
> void` means ‚Äúa function with a parameter named `string` of type `any`‚Äú!

Of course, we can use a type alias to name a function type:

    
    
    ts
    
    type GreetFunction = (a: string) => void;
    
    function greeter(fn: GreetFunction) {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA)

## Call Signatures

In JavaScript, functions can have properties in addition to being callable.
However, the function type expression syntax doesn‚Äôt allow for declaring
properties. If we want to describe something callable with properties, we can
write a _call signature_ in an object type:

    
    
    ts
    
    type DescribableFunction = {
    
      description: string;
    
      (someArg: number): boolean;
    
    };
    
    function doSomething(fn: DescribableFunction) {
    
      console.log(fn.description + " returned " + fn(6));
    
    }
    
    ¬†
    
    function myFunc(someArg: number) {
    
      return someArg > 3;
    
    }
    
    myFunc.description = "default description";
    
    ¬†
    
    doSomething(myFunc);
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA)

Note that the syntax is slightly different compared to a function type
expression - use `:` between the parameter list and the return type rather
than `=>`.

## Construct Signatures

JavaScript functions can also be invoked with the `new` operator. TypeScript
refers to these as _constructors_ because they usually create a new object.
You can write a _construct signature_ by adding the `new` keyword in front of
a call signature:

    
    
    ts
    
    type SomeConstructor = {
    
      new (s: string): SomeObject;
    
    };
    
    function fn(ctor: SomeConstructor) {
    
      return new ctor("hello");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA)

Some objects, like JavaScript‚Äôs `Date` object, can be called with or without
`new`. You can combine call and construct signatures in the same type
arbitrarily:

    
    
    ts
    
    interface CallOrConstruct {
    
      (n?: number): string;
    
      new (s: string): Date;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfIA)

## Generic Functions

It‚Äôs common to write a function where the types of the input relate to the
type of the output, or where the types of two inputs are related in some way.
Let‚Äôs consider for a moment a function that returns the first element of an
array:

    
    
    ts
    
    function firstElement(arr: any[]) {
    
      return arr[0];
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA)

This function does its job, but unfortunately has the return type `any`. It‚Äôd
be better if the function returned the type of the array element.

In TypeScript, _generics_ are used when we want to describe a correspondence
between two values. We do this by declaring a _type parameter_ in the function
signature:

    
    
    ts
    
    function firstElement<Type>(arr: Type[]): Type | undefined {
    
      return arr[0];
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA)

By adding a type parameter `Type` to this function and using it in two places,
we‚Äôve created a link between the input of the function (the array) and the
output (the return value). Now when we call it, a more specific type comes
out:

    
    
    ts
    
    // s is of type 'string'
    
    const s = firstElement(["a", "b", "c"]);
    
    // n is of type 'number'
    
    const n = firstElement([1, 2, 3]);
    
    // u is of type undefined
    
    const u = firstElement([]);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA)

### Inference

Note that we didn‚Äôt have to specify `Type` in this sample. The type was
_inferred_ \- chosen automatically - by TypeScript.

We can use multiple type parameters as well. For example, a standalone version
of `map` would look like this:

    
    
    ts
    
    function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
    
      return arr.map(func);
    
    }
    
    ¬†
    
    // Parameter 'n' is of type 'string'
    
    // 'parsed' is of type 'number[]'
    
    const parsed = map(["1", "2", "3"], (n) => parseInt(n));
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA)

Note that in this example, TypeScript could infer both the type of the `Input`
type parameter (from the given `string` array), as well as the `Output` type
parameter based on the return value of the function expression (`number`).

### Constraints

We‚Äôve written some generic functions that can work on _any_ kind of value.
Sometimes we want to relate two values, but can only operate on a certain
subset of values. In this case, we can use a _constraint_ to limit the kinds
of types that a type parameter can accept.

Let‚Äôs write a function that returns the longer of two values. To do this, we
need a `length` property that‚Äôs a number. We _constrain_ the type parameter to
that type by writing an `extends` clause:

    
    
    ts
    
    function longest<Type extends { length: number }>(a: Type, b: Type) {
    
      if (a.length >= b.length) {
    
        return a;
    
      } else {
    
        return b;
    
      }
    
    }
    
    ¬†
    
    // longerArray is of type 'number[]'
    
    const longerArray = longest([1, 2], [1, 2, 3]);
    
    // longerString is of type 'alice' | 'bob'
    
    const longerString = longest("alice", "bob");
    
    // Error! Numbers don't have a 'length' property
    
    const notOK = longest(10, 100);
    
    Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA)

There are a few interesting things to note in this example. We allowed
TypeScript to _infer_ the return type of `longest`. Return type inference also
works on generic functions.

Because we constrained `Type` to `{ length: number }`, we were allowed to
access the `.length` property of the `a` and `b` parameters. Without the type
constraint, we wouldn‚Äôt be able to access those properties because the values
might have been some other type without a length property.

The types of `longerArray` and `longerString` were inferred based on the
arguments. Remember, generics are all about relating two or more values with
the same type!

Finally, just as we‚Äôd like, the call to `longest(10, 100)` is rejected because
the `number` type doesn‚Äôt have a `.length` property.

### Working with Constrained Values

Here‚Äôs a common error when working with generic constraints:

    
    
    ts
    
    function minimumLength<Type extends { length: number }>(
    
      obj: Type,
    
      minimum: number
    
    ): Type {
    
      if (obj.length >= minimum) {
    
        return obj;
    
      } else {
    
        return { length: minimum };
    
    Type '{ length: number; }' is not assignable to type 'Type'.
      '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.
      '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA)

It might look like this function is OK - `Type` is constrained to `{ length:
number }`, and the function either returns `Type` or a value matching that
constraint. The problem is that the function promises to return the _same_
kind of object as was passed in, not just _some_ object matching the
constraint. If this code were legal, you could write code that definitely
wouldn‚Äôt work:

    
    
    ts
    
    // 'arr' gets value { length: 6 }
    
    const arr = minimumLength([1, 2, 3], 6);
    
    // and crashes here because arrays have
    
    // a 'slice' method, but not the returned object!
    
    console.log(arr.slice(0));
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA)

### Specifying Type Arguments

TypeScript can usually infer the intended type arguments in a generic call,
but not always. For example, let‚Äôs say you wrote a function to combine two
arrays:

    
    
    ts
    
    function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
    
      return arr1.concat(arr2);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A)

Normally it would be an error to call this function with mismatched arrays:

    
    
    ts
    
    const arr = combine([1, 2, 3], ["hello"]);
    
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA)

If you intended to do this, however, you could manually specify `Type`:

    
    
    ts
    
    const arr = combine<string | number>([1, 2, 3], ["hello"]);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA)

### Guidelines for Writing Good Generic Functions

Writing generic functions is fun, and it can be easy to get carried away with
type parameters. Having too many type parameters or using constraints where
they aren‚Äôt needed can make inference less successful, frustrating callers of
your function.

#### Push Type Parameters Down

Here are two ways of writing a function that appear similar:

    
    
    ts
    
    function firstElement1<Type>(arr: Type[]) {
    
      return arr[0];
    
    }
    
    ¬†
    
    function firstElement2<Type extends any[]>(arr: Type) {
    
      return arr[0];
    
    }
    
    ¬†
    
    // a: number (good)
    
    const a = firstElement1([1, 2, 3]);
    
    // b: any (bad)
    
    const b = firstElement2([1, 2, 3]);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA)

These might seem identical at first glance, but `firstElement1` is a much
better way to write this function. Its inferred return type is `Type`, but
`firstElement2`‚Äôs inferred return type is `any` because TypeScript has to
resolve the `arr[0]` expression using the constraint type, rather than
‚Äúwaiting‚Äù to resolve the element during a call.

> **Rule** : When possible, use the type parameter itself rather than
> constraining it

#### Use Fewer Type Parameters

Here‚Äôs another pair of similar functions:

    
    
    ts
    
    function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
    
      return arr.filter(func);
    
    }
    
    ¬†
    
    function filter2<Type, Func extends (arg: Type) => boolean>(
    
      arr: Type[],
    
      func: Func
    
    ): Type[] {
    
      return arr.filter(func);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA)

We‚Äôve created a type parameter `Func` that _doesn‚Äôt relate two values_. That‚Äôs
always a red flag, because it means callers wanting to specify type arguments
have to manually specify an extra type argument for no reason. `Func` doesn‚Äôt
do anything but make the function harder to read and reason about!

> **Rule** : Always use as few type parameters as possible

#### Type Parameters Should Appear Twice

Sometimes we forget that a function might not need to be generic:

    
    
    ts
    
    function greet<Str extends string>(s: Str) {
    
      console.log("Hello, " + s);
    
    }
    
    ¬†
    
    greet("world");
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA)

We could just as easily have written a simpler version:

    
    
    ts
    
    function greet(s: string) {
    
      console.log("Hello, " + s);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA)

Remember, type parameters are for _relating the types of multiple values_. If
a type parameter is only used once in the function signature, it‚Äôs not
relating anything. This includes the inferred return type; for example, if
`Str` was part of the inferred return type of `greet`, it would be relating
the argument and return types, so would be used _twice_ despite appearing only
once in the written code.

> **Rule** : If a type parameter only appears in one location, strongly
> reconsider if you actually need it

## Optional Parameters

Functions in JavaScript often take a variable number of arguments. For
example, the `toFixed` method of `number` takes an optional digit count:

    
    
    ts
    
    function f(n: number) {
    
      console.log(n.toFixed()); // 0 arguments
    
      console.log(n.toFixed(3)); // 1 argument
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA)

We can model this in TypeScript by marking the parameter as _optional_ with
`?`:

    
    
    ts
    
    function f(x?: number) {
    
      // ...
    
    }
    
    f(); // OK
    
    f(10); // OK
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA)

Although the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.

You can also provide a parameter _default_ :

    
    
    ts
    
    function f(x = 10) {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA)

Now in the body of `f`, `x` will have type `number` because any `undefined`
argument will be replaced with `10`. Note that when a parameter is optional,
callers can always pass `undefined`, as this simply simulates a ‚Äúmissing‚Äù
argument:

    
    
    ts
    
    // All OK
    
    f();
    
    f(10);
    
    f(undefined);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA)

### Optional Parameters in Callbacks

Once you‚Äôve learned about optional parameters and function type expressions,
it‚Äôs very easy to make the following mistakes when writing functions that
invoke callbacks:

    
    
    ts
    
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
    
      for (let i = 0; i < arr.length; i++) {
    
        callback(arr[i], i);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA)

What people usually intend when writing `index?` as an optional parameter is
that they want both of these calls to be legal:

    
    
    ts
    
    myForEach([1, 2, 3], (a) => console.log(a));
    
    myForEach([1, 2, 3], (a, i) => console.log(a, i));
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA)

What this _actually_ means is that _`callback` might get invoked with one
argument_. In other words, the function definition says that the
implementation might look like this:

    
    
    ts
    
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
    
      for (let i = 0; i < arr.length; i++) {
    
        // I don't feel like providing the index today
    
        callback(arr[i]);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA)

In turn, TypeScript will enforce this meaning and issue errors that aren‚Äôt
really possible:

    
    
    ts
    
    myForEach([1, 2, 3], (a, i) => {
    
      console.log(i.toFixed());
    
    'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA)

In JavaScript, if you call a function with more arguments than there are
parameters, the extra arguments are simply ignored. TypeScript behaves the
same way. Functions with fewer parameters (of the same types) can always take
the place of functions with more parameters.

> **Rule** : When writing a function type for a callback, _never_ write an
> optional parameter unless you intend to _call_ the function without passing
> that argument

## Function Overloads

Some JavaScript functions can be called in a variety of argument counts and
types. For example, you might write a function to produce a `Date` that takes
either a timestamp (one argument) or a month/day/year specification (three
arguments).

In TypeScript, we can specify a function that can be called in different ways
by writing _overload signatures_. To do this, write some number of function
signatures (usually two or more), followed by the body of the function:

    
    
    ts
    
    function makeDate(timestamp: number): Date;
    
    function makeDate(m: number, d: number, y: number): Date;
    
    function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
    
      if (d !== undefined && y !== undefined) {
    
        return new Date(y, mOrTimestamp, d);
    
      } else {
    
        return new Date(mOrTimestamp);
    
      }
    
    }
    
    const d1 = makeDate(12345678);
    
    const d2 = makeDate(5, 5, 5);
    
    const d3 = makeDate(1, 3);
    
    No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA)

In this example, we wrote two overloads: one accepting one argument, and
another accepting three arguments. These first two signatures are called the
_overload signatures_.

Then, we wrote a function implementation with a compatible signature.
Functions have an _implementation_ signature, but this signature can‚Äôt be
called directly. Even though we wrote a function with two optional parameters
after the required one, it can‚Äôt be called with two parameters!

### Overload Signatures and the Implementation Signature

This is a common source of confusion. Often people will write code like this
and not understand why there is an error:

    
    
    ts
    
    function fn(x: string): void;
    
    function fn() {
    
      // ...
    
    }
    
    // Expected to be able to call with zero arguments
    
    fn();
    
    Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA)

Again, the signature used to write the function body can‚Äôt be ‚Äúseen‚Äù from the
outside.

> The signature of the _implementation_ is not visible from the outside. When
> writing an overloaded function, you should always have _two_ or more
> signatures above the implementation of the function.

The implementation signature must also be _compatible_ with the overload
signatures. For example, these functions have errors because the
implementation signature doesn‚Äôt match the overloads in a correct way:

    
    
    ts
    
    function fn(x: boolean): void;
    
    // Argument type isn't right
    
    function fn(x: string): void;
    
    This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.
    
    function fn(x: boolean) {}
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA)
    
    
    ts
    
    function fn(x: string): string;
    
    // Return type isn't right
    
    function fn(x: number): boolean;
    
    This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.
    
    function fn(x: string | number) {
    
      return "oops";
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA)

### Writing Good Overloads

Like generics, there are a few guidelines you should follow when using
function overloads. Following these principles will make your function easier
to call, easier to understand, and easier to implement.

Let‚Äôs consider a function that returns the length of a string or an array:

    
    
    ts
    
    function len(s: string): number;
    
    function len(arr: any[]): number;
    
    function len(x: any) {
    
      return x.length;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A)

This function is fine; we can invoke it with strings or arrays. However, we
can‚Äôt invoke it with a value that might be a string _or_ an array, because
TypeScript can only resolve a function call to a single overload:

    
    
    ts
    
    len(""); // OK
    
    len([0]); // OK
    
    len(Math.random() > 0.5 ? "hello" : [0]);
    
    No overload matches this call.
      Overload 1 of 2, '(s: string): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
          Type 'number[]' is not assignable to type 'string'.
      Overload 2 of 2, '(arr: any[]): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
          Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.
      Overload 1 of 2, '(s: string): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
          Type 'number[]' is not assignable to type 'string'.
      Overload 2 of 2, '(arr: any[]): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
          Type 'string' is not assignable to type 'any[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA)

Because both overloads have the same argument count and same return type, we
can instead write a non-overloaded version of the function:

    
    
    ts
    
    function len(x: any[] | string) {
    
      return x.length;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA)

This is much better! Callers can invoke this with either sort of value, and as
an added bonus, we don‚Äôt have to figure out a correct implementation
signature.

> Always prefer parameters with union types instead of overloads when possible

## Declaring `this` in a Function

TypeScript will infer what the `this` should be in a function via code flow
analysis, for example in the following:

    
    
    ts
    
    const user = {
    
      id: 123,
    
    ¬†
    
      admin: false,
    
      becomeAdmin: function () {
    
        this.admin = true;
    
      },
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA)

TypeScript understands that the function `user.becomeAdmin` has a
corresponding `this` which is the outer object `user`. `this`, _heh_ , can be
enough for a lot of cases, but there are a lot of cases where you need more
control over what object `this` represents. The JavaScript specification
states that you cannot have a parameter called `this`, and so TypeScript uses
that syntax space to let you declare the type for `this` in the function body.

    
    
    ts
    
    interface DB {
    
      filterUsers(filter: (this: User) => boolean): User[];
    
    }
    
    ¬†
    
    const db = getDB();
    
    const admins = db.filterUsers(function (this: User) {
    
      return this.admin;
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA)

This pattern is common with callback-style APIs, where another object
typically controls when your function is called. Note that you need to use
`function` and not arrow functions to get this behavior:

    
    
    ts
    
    interface DB {
    
      filterUsers(filter: (this: User) => boolean): User[];
    
    }
    
    ¬†
    
    const db = getDB();
    
    const admins = db.filterUsers(() => this.admin);
    
    The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.7041  
    7017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXv0QBBAWMqoJcOABtI9CrJIBfUgMiNN9aC0ZwKiKqADmkKgBEAQqgAUASlABeAD5Qd30QUABaSMYRKkjw0koaaAZmYLduOVoyTST2GERPLJyYLyoACzIUNg5oX0DQdS0dCm9UPOgAbQBdfSMSUmtbewEJf0dndx99QbtQemVKRDGRgDoi3JqCn38g8sqV+ZUW6SA)

## Other Types to Know About

There are some additional types you‚Äôll want to recognize that appear often
when working with function types. Like all types, you can use them everywhere,
but these are especially relevant in the context of functions.

### `void`

`void` represents the return value of functions which don‚Äôt return a value.
It‚Äôs the inferred type any time a function doesn‚Äôt have any `return`
statements, or doesn‚Äôt return any explicit value from those return statements:

    
    
    ts
    
    // The inferred return type is void
    
    function noop() {
    
      return;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA)

In JavaScript, a function that doesn‚Äôt return any value will implicitly return
the value `undefined`. However, `void` and `undefined` are not the same thing
in TypeScript. There are further details at the end of this chapter.

> `void` is not the same as `undefined`.

### `object`

The special type `object` refers to any value that isn‚Äôt a primitive
(`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`).
This is different from the _empty object type_ `{ }`, and also different from
the global type `Object`. It‚Äôs very likely you will never use `Object`.

> `object` is not `Object`. **Always** use `object`!

Note that in JavaScript, function values are objects: They have properties,
have `Object.prototype` in their prototype chain, are `instanceof Object`, you
can call `Object.keys` on them, and so on. For this reason, function types are
considered to be `object`s in TypeScript.

### `unknown`

The `unknown` type represents _any_ value. This is similar to the `any` type,
but is safer because it‚Äôs not legal to do anything with an `unknown` value:

    
    
    ts
    
    function f1(a: any) {
    
      a.b(); // OK
    
    }
    
    function f2(a: unknown) {
    
      a.b();
    
    'a' is of type 'unknown'.18046'a' is of type 'unknown'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA)

This is useful when describing function types because you can describe
functions that accept any value without having `any` values in your function
body.

Conversely, you can describe a function that returns a value of unknown type:

    
    
    ts
    
    function safeParse(s: string): unknown {
    
      return JSON.parse(s);
    
    }
    
    ¬†
    
    // Need to be careful with 'obj'!
    
    const obj = safeParse(someRandomString);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA)

### `never`

Some functions _never_ return a value:

    
    
    ts
    
    function fail(msg: string): never {
    
      throw new Error(msg);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA)

The `never` type represents values which are _never_ observed. In a return
type, this means that the function throws an exception or terminates execution
of the program.

`never` also appears when TypeScript determines there‚Äôs nothing left in a
union.

    
    
    ts
    
    function fn(x: string | number) {
    
      if (typeof x === "string") {
    
        // do something
    
      } else if (typeof x === "number") {
    
        // do something else
    
      } else {
    
        x; // has type 'never'!
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA)

### `Function`

The global type `Function` describes properties like `bind`, `call`, `apply`,
and others present on all function values in JavaScript. It also has the
special property that values of type `Function` can always be called; these
calls return `any`:

    
    
    ts
    
    function doSomething(f: Function) {
    
      return f(1, 2, 3);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA)

This is an _untyped function call_ and is generally best avoided because of
the unsafe `any` return type.

If you need to accept an arbitrary function but don‚Äôt intend to call it, the
type `() => void` is generally safer.

## Rest Parameters and Arguments

> Background Reading:  
>  [Rest Parameters](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  
>  [Spread Syntax](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  
>

### Rest Parameters

In addition to using optional parameters or overloads to make functions that
can accept a variety of fixed argument counts, we can also define functions
that take an _unbounded_ number of arguments using _rest parameters_.

A rest parameter appears after all other parameters, and uses the `...`
syntax:

    
    
    ts
    
    function multiply(n: number, ...m: number[]) {
    
      return m.map((x) => n * x);
    
    }
    
    // 'a' gets value [10, 20, 30, 40]
    
    const a = multiply(10, 1, 2, 3, 4);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA)

In TypeScript, the type annotation on these parameters is implicitly `any[]`
instead of `any`, and any type annotation given must be of the form `Array<T>`
or `T[]`, or a tuple type (which we‚Äôll learn about later).

### Rest Arguments

Conversely, we can _provide_ a variable number of arguments from an iterable
object (for example, an array) using the spread syntax. For example, the
`push` method of arrays takes any number of arguments:

    
    
    ts
    
    const arr1 = [1, 2, 3];
    
    const arr2 = [4, 5, 6];
    
    arr1.push(...arr2);
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA)

Note that in general, TypeScript does not assume that arrays are immutable.
This can lead to some surprising behavior:

    
    
    ts
    
    // Inferred type is number[] -- "an array with zero or more numbers",
    
    // not specifically two numbers
    
    const args = [8, 5];
    
    const angle = Math.atan2(...args);
    
    A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA)

The best fix for this situation depends a bit on your code, but in general a
`const` context is the most straightforward solution:

    
    
    ts
    
    // Inferred as 2-length tuple
    
    const args = [8, 5] as const;
    
    // OK
    
    const angle = Math.atan2(...args);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA)

Using rest arguments may require turning on
[`downlevelIteration`](/tsconfig#downlevelIteration) when targeting older
runtimes.

## Parameter Destructuring

> Background Reading:  
>  [Destructuring Assignment](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  
>

You can use parameter destructuring to conveniently unpack objects provided as
an argument into one or more local variables in the function body. In
JavaScript, it looks like this:

    
    
    js
    
    function sum({ a, b, c }) {
    
      console.log(a + b + c);
    
    }
    
    sum({ a: 10, b: 3, c: 9 });

The type annotation for the object goes after the destructuring syntax:

    
    
    ts
    
    function sum({ a, b, c }: { a: number; b: number; c: number }) {
    
      console.log(a + b + c);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA)

This can look a bit verbose, but you can use a named type here as well:

    
    
    ts
    
    // Same as prior example
    
    type ABC = { a: number; b: number; c: number };
    
    function sum({ a, b, c }: ABC) {
    
      console.log(a + b + c);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA)

## Assignability of Functions

### Return type `void`

The `void` return type for functions can produce some unusual, but expected
behavior.

Contextual typing with a return type of `void` does **not** force functions to
**not** return something. Another way to say this is a contextual function
type with a `void` return type (`type voidFunc = () => void`), when
implemented, can return _any_ other value, but it will be ignored.

Thus, the following implementations of the type `() => void` are valid:

    
    
    ts
    
    type voidFunc = () => void;
    
    ¬†
    
    const f1: voidFunc = () => {
    
      return true;
    
    };
    
    ¬†
    
    const f2: voidFunc = () => true;
    
    ¬†
    
    const f3: voidFunc = function () {
    
      return true;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA)

And when the return value of one of these functions is assigned to another
variable, it will retain the type of `void`:

    
    
    ts
    
    const v1 = f1();
    
    ¬†
    
    const v2 = f2();
    
    ¬†
    
    const v3 = f3();
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA)

This behavior exists so that the following code is valid even though
`Array.prototype.push` returns a number and the `Array.prototype.forEach`
method expects a function with a return type of `void`.

    
    
    ts
    
    const src = [1, 2, 3];
    
    const dst = [0];
    
    ¬†
    
    src.forEach((el) => dst.push(el));
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA)

There is one other special case to be aware of, when a literal function
definition has a `void` return type, that function must **not** return
anything.

    
    
    ts
    
    function f2(): void {
    
      // @ts-expect-error
    
      return true;
    
    }
    
    ¬†
    
    const f3 = function (): void {
    
      // @ts-expect-error
    
      return true;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA)

For more on `void` please refer to these other documentation entries:

  * [v2 handbook](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
  * [FAQ - ‚ÄúWhy are functions returning non-void assignable to function returning void?‚Äù](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)

### [NarrowingUnderstand how TypeScript uses JavaScript knowledge to reduce
the amount of type syntax in your projects.](/docs/handbook/2/narrowing.html)

### [Object TypesHow TypeScript describes the shapes of JavaScript
objects.](/docs/handbook/2/objects.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/More on
Functions.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(56\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

HA![Hossein Ahmadian-Yazdi
\(4\)](https://gravatar.com/avatar/e486af78745bd81069f00ebb26364938?s=32&&d=blank)

JW![Joseph Wynn
\(3\)](https://gravatar.com/avatar/18aa570fcb7a4928bcc2e564690b34aa?s=32&&d=blank)

SB![Siarhei Bobryk
\(2\)](https://gravatar.com/avatar/104098b350a8f60748daa830466d024b?s=32&&d=blank)

35+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Generics

A major part of software engineering is building components that not only have
well-defined and consistent APIs, but are also reusable. Components that are
capable of working on the data of today as well as the data of tomorrow will
give you the most flexible capabilities for building up large software
systems.

In languages like C# and Java, one of the main tools in the toolbox for
creating reusable components is _generics_ , that is, being able to create a
component that can work over a variety of types rather than a single one. This
allows users to consume these components and use their own types.

## Hello World of Generics

To start off, let‚Äôs do the ‚Äúhello world‚Äù of generics: the identity function.
The identity function is a function that will return back whatever is passed
in. You can think of this in a similar way to the `echo` command.

Without generics, we would either have to give the identity function a
specific type:

    
    
    ts
    
    function identity(arg: number): number {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)

Or, we could describe the identity function using the `any` type:

    
    
    ts
    
    function identity(arg: any): any {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)

While using `any` is certainly generic in that it will cause the function to
accept any and all types for the type of `arg`, we actually are losing the
information about what that type was when the function returns. If we passed
in a number, the only information we have is that any type could be returned.

Instead, we need a way of capturing the type of the argument in such a way
that we can also use it to denote what is being returned. Here, we will use a
_type variable_ , a special kind of variable that works on types rather than
values.

    
    
    ts
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)

We‚Äôve now added a type variable `Type` to the identity function. This `Type`
allows us to capture the type the user provides (e.g. `number`), so that we
can use that information later. Here, we use `Type` again as the return type.
On inspection, we can now see the same type is used for the argument and the
return type. This allows us to traffic that type information in one side of
the function and out the other.

We say that this version of the `identity` function is generic, as it works
over a range of types. Unlike using `any`, it‚Äôs also just as precise (i.e., it
doesn‚Äôt lose any information) as the first `identity` function that used
numbers for the argument and return type.

Once we‚Äôve written the generic identity function, we can call it in one of two
ways. The first way is to pass all of the arguments, including the type
argument, to the function:

    
    
    ts
    
    let output = identity<string>("myString");
    
          
    
    let output: string
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA)

Here we explicitly set `Type` to be `string` as one of the arguments to the
function call, denoted using the `<>` around the arguments rather than `()`.

The second way is also perhaps the most common. Here we use _type argument
inference_ ‚Äî that is, we want the compiler to set the value of `Type` for us
automatically based on the type of the argument we pass in:

    
    
    ts
    
    let output = identity("myString");
    
          
    
    let output: string
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA)

Notice that we didn‚Äôt have to explicitly pass the type in the angle brackets
(`<>`); the compiler just looked at the value `"myString"`, and set `Type` to
its type. While type argument inference can be a helpful tool to keep code
shorter and more readable, you may need to explicitly pass in the type
arguments as we did in the previous example when the compiler fails to infer
the type, as may happen in more complex examples.

## Working with Generic Type Variables

When you begin to use generics, you‚Äôll notice that when you create generic
functions like `identity`, the compiler will enforce that you use any
generically typed parameters in the body of the function correctly. That is,
that you actually treat these parameters as if they could be any and all
types.

Let‚Äôs take our `identity` function from earlier:

    
    
    ts
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)

What if we want to also log the length of the argument `arg` to the console
with each call? We might be tempted to write this:

    
    
    ts
    
    function loggingIdentity<Type>(arg: Type): Type {
    
      console.log(arg.length);
    
    Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)

When we do, the compiler will give us an error that we‚Äôre using the `.length`
member of `arg`, but nowhere have we said that `arg` has this member.
Remember, we said earlier that these type variables stand in for any and all
types, so someone using this function could have passed in a `number` instead,
which does not have a `.length` member.

Let‚Äôs say that we‚Äôve actually intended this function to work on arrays of
`Type` rather than `Type` directly. Since we‚Äôre working with arrays, the
`.length` member should be available. We can describe this just like we would
create arrays of other types:

    
    
    ts
    
    function loggingIdentity<Type>(arg: Type[]): Type[] {
    
      console.log(arg.length);
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA)

You can read the type of `loggingIdentity` as ‚Äúthe generic function
`loggingIdentity` takes a type parameter `Type`, and an argument `arg` which
is an array of `Type`s, and returns an array of `Type`s.‚Äù If we passed in an
array of numbers, we‚Äôd get an array of numbers back out, as `Type` would bind
to `number`. This allows us to use our generic type variable `Type` as part of
the types we‚Äôre working with, rather than the whole type, giving us greater
flexibility.

We can alternatively write the sample example this way:

    
    
    ts
    
    function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
    
      console.log(arg.length); // Array has a .length, so no more error
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA)

You may already be familiar with this style of type from other languages. In
the next section, we‚Äôll cover how you can create your own generic types like
`Array<Type>`.

## Generic Types

In previous sections, we created generic identity functions that worked over a
range of types. In this section, we‚Äôll explore the type of the functions
themselves and how to create generic interfaces.

The type of generic functions is just like those of non-generic functions,
with the type parameters listed first, similarly to function declarations:

    
    
    ts
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: <Type>(arg: Type) => Type = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA)

We could also have used a different name for the generic type parameter in the
type, so long as the number of type variables and how the type variables are
used line up.

    
    
    ts
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: <Input>(arg: Input) => Input = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA)

We can also write the generic type as a call signature of an object literal
type:

    
    
    ts
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: { <Type>(arg: Type): Type } = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA)

Which leads us to writing our first generic interface. Let‚Äôs take the object
literal from the previous example and move it to an interface:

    
    
    ts
    
    interface GenericIdentityFn {
    
      <Type>(arg: Type): Type;
    
    }
    
    ¬†
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: GenericIdentityFn = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA)

In a similar example, we may want to move the generic parameter to be a
parameter of the whole interface. This lets us see what type(s) we‚Äôre generic
over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the
type parameter visible to all the other members of the interface.

    
    
    ts
    
    interface GenericIdentityFn<Type> {
    
      (arg: Type): Type;
    
    }
    
    ¬†
    
    function identity<Type>(arg: Type): Type {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: GenericIdentityFn<number> = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA)

Notice that our example has changed to be something slightly different.
Instead of describing a generic function, we now have a non-generic function
signature that is a part of a generic type. When we use `GenericIdentityFn`,
we now will also need to specify the corresponding type argument (here:
`number`), effectively locking in what the underlying call signature will use.
Understanding when to put the type parameter directly on the call signature
and when to put it on the interface itself will be helpful in describing what
aspects of a type are generic.

In addition to generic interfaces, we can also create generic classes. Note
that it is not possible to create generic enums and namespaces.

## Generic Classes

A generic class has a similar shape to a generic interface. Generic classes
have a generic type parameter list in angle brackets (`<>`) following the name
of the class.

    
    
    ts
    
    class GenericNumber<NumType> {
    
      zeroValue: NumType;
    
      add: (x: NumType, y: NumType) => NumType;
    
    }
    
    ¬†
    
    let myGenericNumber = new GenericNumber<number>();
    
    myGenericNumber.zeroValue = 0;
    
    myGenericNumber.add = function (x, y) {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA)

This is a pretty literal use of the `GenericNumber` class, but you may have
noticed that nothing is restricting it to only use the `number` type. We could
have instead used `string` or even more complex objects.

    
    
    ts
    
    let stringNumeric = new GenericNumber<string>();
    
    stringNumeric.zeroValue = "";
    
    stringNumeric.add = function (x, y) {
    
      return x + y;
    
    };
    
    ¬†
    
    console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA)

Just as with interface, putting the type parameter on the class itself lets us
make sure all of the properties of the class are working with the same type.

As we cover in [our section on classes](/docs/handbook/2/classes.html), a
class has two sides to its type: the static side and the instance side.
Generic classes are only generic over their instance side rather than their
static side, so when working with classes, static members can not use the
class‚Äôs type parameter.

## Generic Constraints

If you remember from an earlier example, you may sometimes want to write a
generic function that works on a set of types where you have _some_ knowledge
about what capabilities that set of types will have. In our `loggingIdentity`
example, we wanted to be able to access the `.length` property of `arg`, but
the compiler could not prove that every type had a `.length` property, so it
warns us that we can‚Äôt make this assumption.

    
    
    ts
    
    function loggingIdentity<Type>(arg: Type): Type {
    
      console.log(arg.length);
    
    Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)

Instead of working with any and all types, we‚Äôd like to constrain this
function to work with any and all types that _also_ have the `.length`
property. As long as the type has this member, we‚Äôll allow it, but it‚Äôs
required to have at least this member. To do so, we must list our requirement
as a constraint on what `Type` can be.

To do so, we‚Äôll create an interface that describes our constraint. Here, we‚Äôll
create an interface that has a single `.length` property and then we‚Äôll use
this interface and the `extends` keyword to denote our constraint:

    
    
    ts
    
    interface Lengthwise {
    
      length: number;
    
    }
    
    ¬†
    
    function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
    
      console.log(arg.length); // Now we know it has a .length property, so no more error
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA)

Because the generic function is now constrained, it will no longer work over
any and all types:

    
    
    ts
    
    loggingIdentity(3);
    
    Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA)

Instead, we need to pass in values whose type has all the required properties:

    
    
    ts
    
    loggingIdentity({ length: 10, value: 3 });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA)

## Using Type Parameters in Generic Constraints

You can declare a type parameter that is constrained by another type
parameter. For example, here we‚Äôd like to get a property from an object given
its name. We‚Äôd like to ensure that we‚Äôre not accidentally grabbing a property
that does not exist on the `obj`, so we‚Äôll place a constraint between the two
types:

    
    
    ts
    
    function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
    
      return obj[key];
    
    }
    
    ¬†
    
    let x = { a: 1, b: 2, c: 3, d: 4 };
    
    ¬†
    
    getProperty(x, "a");
    
    getProperty(x, "m");
    
    Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.2345Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA)

## Using Class Types in Generics

When creating factories in TypeScript using generics, it is necessary to refer
to class types by their constructor functions. For example,

    
    
    ts
    
    function create<Type>(c: { new (): Type }): Type {
    
      return new c();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA)

A more advanced example uses the prototype property to infer and constrain
relationships between the constructor function and the instance side of class
types.

    
    
    ts
    
    class BeeKeeper {
    
      hasMask: boolean = true;
    
    }
    
    ¬†
    
    class ZooKeeper {
    
      nametag: string = "Mikle";
    
    }
    
    ¬†
    
    class Animal {
    
      numLegs: number = 4;
    
    }
    
    ¬†
    
    class Bee extends Animal {
    
      numLegs = 6;
    
      keeper: BeeKeeper = new BeeKeeper();
    
    }
    
    ¬†
    
    class Lion extends Animal {
    
      keeper: ZooKeeper = new ZooKeeper();
    
    }
    
    ¬†
    
    function createInstance<A extends Animal>(c: new () => A): A {
    
      return new c();
    
    }
    
    ¬†
    
    createInstance(Lion).keeper.nametag;
    
    createInstance(Bee).keeper.hasMask;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA)

This pattern is used to power the [mixins](/docs/handbook/mixins.html) design
pattern.

## Generic Parameter Defaults

By declaring a default for a generic type parameter, you make it optional to
specify the corresponding type argument. For example, a function which creates
a new `HTMLElement`. Calling the function with no arguments generates a
`HTMLDivElement`; calling the function with an element as the first argument
generates an element of the argument‚Äôs type. You can optionally pass a list of
children as well. Previously you would have to define the function as:

    
    
    ts
    
    declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;
    
    declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;
    
    declare function create<T extends HTMLElement, U extends HTMLElement>(
    
      element: T,
    
      children: U[]
    
    ): Container<T, U[]>;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA)

With generic parameter defaults we can reduce it to:

    
    
    ts
    
    declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(
    
      element?: T,
    
      children?: U
    
    ): Container<T, U>;
    
    ¬†
    
    const div = create();
    
          
    
    const div: Container<HTMLDivElement, HTMLDivElement[]>
    
    ¬†
    
    const p = create(new HTMLParagraphElement());
    
         
    
    const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA)

A generic parameter default follows the following rules:

  * A type parameter is deemed optional if it has a default.
  * Required type parameters must not follow optional type parameters.
  * Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.
  * When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.
  * If a default type is specified and inference cannot choose a candidate, the default type is inferred.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.

## Variance Annotations

> This is an advanced feature for solving a very specific problem, and should
> only be used in situations where you‚Äôve identified a reason to use it

[Covariance and
contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\))
are type theory terms that describe what the relationship between two generic
types is. Here‚Äôs a brief primer on the concept.

For example, if you have an interface representing an object that can `make` a
certain type:

    
    
    ts
    
    interface Producer<T> {
    
      make(): T;
    
    }

We can use a `Producer<Cat>` where a `Producer<Animal>` is expected, because a
`Cat` is an `Animal`. This relationship is called _covariance_ : the
relationship from `Producer<T>` to `Producer<U>` is the same as the
relationship from `T` to `U`.

Conversely, if you have an interface that can `consume` a certain type:

    
    
    ts
    
    interface Consumer<T> {
    
      consume: (arg: T) => void;
    
    }

Then we can use a `Consumer<Animal>` where a `Consumer<Cat>` is expected,
because any function that is capable of accepting a `Cat` must also be capable
of accepting an `Animal`. This relationship is called _contravariance_ : the
relationship from `Consumer<T>` to `Consumer<U>` is the same as the
relationship from `U` to `T`. Note the reveral of direction as compared to
covariance! This is why contravariance ‚Äúcancels itself out‚Äù but covariance
doesn‚Äôt.

In a structural type system like TypeScript‚Äôs, covariance and contravariance
are naturally emergent behaviors that follow from the definition of types.
Even in the absence of generics, we would see covariant (and contravariant)
relationships:

    
    
    ts
    
    interface AnimalProducer {
    
      make(): Animal;
    
    }
    
    // A CatProducer can be used anywhere an
    
    // Animal producer is expected
    
    interface CatProducer {
    
      make(): Cat;
    
    }

TypeScript has a structural type system, so when comparing two types, e.g. to
see if a `Producer<Cat>` can be used where a `Producer<Animal>` is expected,
the usual algorithm would be structurally expand both of those definitions,
and compare their structures. However, variance allows for an extremely useful
optimization: if `Producer<T>` is covariant on `T`, then we can simply check
`Cat` and `Animal` instead, as we know they‚Äôll have the same relationship as
`Producer<Cat>` and `Producer<Animal>`.

Note that this logic can only be used when we‚Äôre examining two instantiations
of the same type. If we have a `Producer<T>` and a `FastProducer<U>`, there‚Äôs
no guarantee that `T` and `U` necessarily refer to the same positions in these
types, so this check will always be performed structurally.

Because variance is a naturally emergent property of structural types,
TypeScript automatically _infers_ the variance of every generic type. **In
extremely rare cases** involving certain kinds of circular types, this
measurement can be inaccurate. If this happens, you can add a variance
annotation to a type parameter to force a particular variance:

    
    
    ts
    
    // Contravariant annotation
    
    interface Consumer<in T> {
    
      consume: (arg: T) => void;
    
    }
    
    // Covariant annotation
    
    interface Producer<out T> {
    
      make(): T;
    
    }
    
    // Invariant annotation
    
    interface ProducerConsumer<in out T> {
    
      consume: (arg: T) => void;
    
      make(): T;
    
    }

Only do this if you are writing the same variance that _should_ occur
structurally.

> Never write a variance annotation that doesn‚Äôt match the structural
> variance!

It‚Äôs critical to reinforce that variance annotations are only in effect during
an instantiation-based comparison. They have no effect during a structural
comparison. For example, you can‚Äôt use variance annotations to ‚Äúforce‚Äù a type
to be actually invariant:

    
    
    ts
    
    // DON'T DO THIS - variance annotation
    
    // does not match structural behavior
    
    interface Producer<in out T> {
    
      make(): T;
    
    }
    
    // Not a type error -- this is a structural
    
    // comparison, so variance annotations are
    
    // not in effect
    
    const p: Producer<string | number> = {
    
        make(): number {
    
            return 42;
    
        }
    
    }

Here, the object literal‚Äôs `make` function returns `number`, which we might expect to cause an error because `number` isn‚Äôt `string | number`. However, this isn‚Äôt an instantiation-based comparison, because the object literal is an anonymous type, not a `Producer<string | number>`.

> Variance annotations don‚Äôt change structural behavior and are only consulted
> in specific situations

It‚Äôs very important to only write variance annotations if you absolutely know
why you‚Äôre doing it, what their limitations are, and when they aren‚Äôt in
effect. Whether TypeScript uses an instantiation-based comparison or
structural comparison is not a specified behavior and may change from version
to version for correctness or performance reasons, so you should only ever
write variance annotations when they match the structural behavior of a type.
Don‚Äôt use variance annotations to try to ‚Äúforce‚Äù a particular variance; this
will cause unpredictable behavior in your code.

> Do NOT write variance annotations unless they match the structural behavior
> of a type

Rmember, TypeScript can automatically infer variance from your generic types.
It‚Äôs almost never necessary to write a variance annotation, and you should
only do so when you‚Äôve identified a specific need. Variance annotations _do
not_ change the structural behavior of a type, and depending on the situation,
you might see a structural comparison made when you expected an instantiation-
based comparison. Variance annotations can‚Äôt be used to modify how types
behave in these structural contexts, and shouldn‚Äôt be written unless the
annotation is the same as the structural definition. Because this is difficult
to get right, and TypeScript can correctly infer variance in the vast majority
of cases, you should not find yourself writing variance annotations in normal
code.

> Don‚Äôt try to use variance annotations to change typechecking behavior; this
> is not what they are for

You _may_ find temporary variance annotations useful in a ‚Äútype debugging‚Äù
situation, because variance annotations are checked. TypeScript will issue an
error if the annotated variance is identifiably wrong:

    
    
    ts
    
    // Error, this interface is definitely contravariant on T
    
    interface Foo<out T> {
    
      consume: (arg: T) => void;
    
    }

However, variance annotations are allowed to be stricter (e.g. `in out` is
valid if the actual variance is covariant). Be sure to remove your variance
annotations once you‚Äôre done debugging.

Lastly, if you‚Äôre trying to maximize your typechecking performance, _and_ have
run a profiler, _and_ have identified a specific type that‚Äôs slow, _and_ have
identified variance inference specifically is slow, _and_ have carefully
validated the variance annotation you want to write, you _may_ see a small
performance benefit in extraordinarily complex types by adding variance
annotations.

> Don‚Äôt try to use variance annotations to change typechecking behavior; this
> is not what they are for

### [Creating Types from TypesAn overview of the ways in which you can create
more types from existing types.](/docs/handbook/2/types-from-types.html)

### [Keyof Type OperatorUsing the keyof operator in type
contexts.](/docs/handbook/2/keyof-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Generics.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(26\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NK![Navneet Karnani
\(2\)](https://gravatar.com/avatar/76b0250b679ee5a24597da80ffaaaeeb?s=32&&d=blank)

RC![Ryan Cavanaugh
\(1\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

G![grebenyuksv
\(1\)](https://gravatar.com/avatar/fdbdb43a1bbae99c16f6eb5c060c21bc?s=32&&d=blank)

PS![Pawe≈Ç Smolak
\(1\)](https://gravatar.com/avatar/b9630916b900a7fa61888bfd2f8f41f6?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Indexed Access Types

We can use an _indexed access type_ to look up a specific property on another
type:

    
    
    ts
    
    type Person = { age: number; name: string; alive: boolean };
    
    type Age = Person["age"];
    
         
    
    type Age = number
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6AfiA)

The indexing type is itself a type, so we can use unions, `keyof`, or other
types entirely:

    
    
    ts
    
    type I1 = Person["age" | "name"];
    
         
    
    type I1 = string | number
    
    ¬†
    
    type I2 = Person[keyof Person];
    
         
    
    type I2 = string | number | boolean
    
    ¬†
    
    type AliveOrName = "alive" | "name";
    
    type I3 = Person[AliveOrName];
    
         
    
    type I3 = string | boolean
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBJAIyZYCFKgDaAIkIQbUAD5QbqJg4C68pVD8A9AH45PXBoQwAmMzgkNCsAawgQZAAzc1jUb0VlAODQgwBBAWEAeXgAOQ8zO2KHZ1d3Zht5fXCAZmiLOKKhCDLK5izfXKA)

You‚Äôll even see an error if you try to index a property that doesn‚Äôt exist:

    
    
    ts
    
    type I1 = Person["alve"];
    
    Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQAFGROAO1AF5QBvUAQwHNJUaBXAWwBGMANygarPl1CJ80AJY12o1gBs5ANykC4cFZFZ0AvsNwhQAWksBjHvkvmCJMgEkAjAwpVaAbQBEqzV8AXWEgA)

Another example of indexing with an arbitrary type is using `number` to get
the type of an array‚Äôs elements. We can combine this with `typeof` to
conveniently capture the element type of an array literal:

    
    
    ts
    
    const MyArray = [
    
      { name: "Alice", age: 15 },
    
      { name: "Bob", age: 23 },
    
      { name: "Eve", age: 38 },
    
    ];
    
    ¬†
    
    type Person = typeof MyArray[number];
    
           
    
    type Person = {
        name: string;
        age: number;
    }
    
    type Age = typeof MyArray[number]["age"];
    
         
    
    type Age = number
    
    // Or
    
    type Age2 = Person["age"];
    
          
    
    type Age2 = number
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAsgTwIICcUEMEwLwwNoBQMMA3jGOgLYCmAXDAERIA2AlsNQwDQzoDmdGAEYArDAC+XIqXJVBDAEIgARt14D6AJgDMEqcTIUa9BgFEAbpx79B2gBx6CAXQDcBAlAQAHajAAK1CgQ4Dgwnj4gAGbwyGiYeGAArpTKga4EAPQZxDAAegD8Ht6+SAKh4dRRMagYCAnJqShOeAw2DOlZOQWZ2QDyKEU+MKXUmqEBQeAtbR3ZxAVAA)

You can only use types when indexing, meaning you can‚Äôt use a `const` to make
a variable reference:

    
    
    ts
    
    const key = "age";
    
    type Age = Person[key];
    
    Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?2538  
    2749Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMAOdB2AFgE4AoAFwE8AHSUABRkTgDtQBeUAb1AEMBzSKhYBXALYAjGAG5QLXmKGhE5aAEsW-WbwA2agG5KJcODsi82AX2mkQoALSOAxiPKP7pJ6xWgA1pEoOUAAiAUhgmypaUABBQSDGJFYAbX9KAF1pIA)

However, you can use a type alias for a similar style of refactor:

    
    
    ts
    
    type key = "age";
    
    type Age = Person[key];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBrCCExQARIQjn5+6AEEiZuEjQBtYyAC6dIA)

### [Typeof Type OperatorUsing the typeof operator in type
contexts.](/docs/handbook/2/typeof-types.html)

### [Conditional TypesCreate types which act like if statements in the type
system.](/docs/handbook/2/conditional-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Indexed Access Types.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(5\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Keyof Type Operator

## The `keyof` type operator

The `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = "x" | "y"`:
    
    
    ts
    
    type Point = { x: number; y: number };
    
    type P = keyof Point;
    
        
    
    type P = keyof Point
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbygDwFxRICuAtgEYQBOA3FCAceVVAL7UBQoks6UA1hBBwAZrEQoOAeklRZAPQD8QA)

If the type has a `string` or `number` index signature, `keyof` will return
those types instead:

    
    
    ts
    
    type Arrayish = { [n: number]: unknown };
    
    type A = keyof Arrayish;
    
        
    
    type A = number
    
    ¬†
    
    type Mapish = { [k: string]: boolean };
    
    type M = keyof Mapish;
    
        
    
    type M = string | number
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnAhiAlgZwBZQLxQN5QDaAdgFxTECuAtgEYRwC65lxA1sQPYDuxUAvgG4AUKEiwcUNhBCcAZrATJ0GEQHo1ULQD0A-MNHhoAWURgVkgoTbk0wOCmIBzZlFqdOAGwiI+Qw+LGktKyCqbmmOqaOrpAA)

Note that in this example, `M` is `string | number` ‚Äî this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj["0"]`.

`keyof` types become especially useful when combined with mapped types, which
we‚Äôll learn more about later.

### [GenericsTypes which take parameters](/docs/handbook/2/generics.html)

### [Typeof Type OperatorUsing the typeof operator in type
contexts.](/docs/handbook/2/typeof-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Keyof Type Operator.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(3\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RM![Roman Mahotskyi
\(1\)](https://gravatar.com/avatar/fb55d1e3b056ea9ef4fd3d4acf20395a?s=32&&d=blank)

MM![Masashi Miyazaki
\(1\)](https://gravatar.com/avatar/0f0347b8f1f29cfd1c1be831f1cd80a7?s=32&&d=blank)

S![suica
\(1\)](https://gravatar.com/avatar/9c415978e6572ee748cb34e995e6c1d7?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Mapped Types

When you don‚Äôt want to repeat yourself, sometimes a type needs to be based on
another type.

Mapped types build on the syntax for index signatures, which are used to
declare the types of properties which have not been declared ahead of time:

    
    
    ts
    
    type OnlyBoolsAndHorses = {
    
      [key: string]: boolean | Horse;
    
    };
    
    ¬†
    
    const conforms: OnlyBoolsAndHorses = {
    
      del: true,
    
      rodney: false,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAEg9gJwM7QLxQN4F8DcAoAegKgFoyBjAV2DJL1EigHkA7AGxACE442kBBFgBN4yCEijoMeKFADaAawggAXFCTAEASxYBzALpqARjzYQAhiygAfWIhT5cePOTgsNUVywBmiALZIaqwc3LwCwqIoElIyUEIQbGqalBAANLEIcEIsymre5nxpeLhAA)

A mapped type is a generic type which uses a union of `PropertyKey`s
(frequently created [via a `keyof`](/docs/handbook/2/indexed-access-
types.html)) to iterate through keys to create a type:

    
    
    ts
    
    type OptionsFlags<Type> = {
    
      [Property in keyof Type]: boolean;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+GoA)

In this example, `OptionsFlags` will take all the properties from the type
`Type` and change their values to be a boolean.

    
    
    ts
    
    type Features = {
    
      darkMode: () => void;
    
      newUserProfile: () => void;
    
    };
    
    ¬†
    
    type FeatureOptions = OptionsFlags<Features>;
    
               
    
    type FeatureOptions = {
        darkMode: boolean;
        newUserProfile: boolean;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+WgPR6oAWhMBjAK7ATR+qEhQMa4OfYQ01OoygATHO0EAskjeEPIAFACU1JQAbkgI3lpMKBAA7gCqaBDsHOIIquFRVLHxiTpatmQOTi4QcIio7jT1yOjY+ESOOM6uaOT6hkwAegD8QA)

### Mapping Modifiers

There are two additional modifiers which can be applied during mapping:
`readonly` and `?` which affect mutability and optionality respectively.

You can remove or add these modifiers by prefixing with `-` or `+`. If you
don‚Äôt add a prefix, then `+` is assumed.

    
    
    ts
    
    // Removes 'readonly' attributes from a type's properties
    
    type CreateMutable<Type> = {
    
      -readonly [Property in keyof Type]: Type[Property];
    
    };
    
    ¬†
    
    type LockedAccount = {
    
      readonly id: string;
    
      readonly name: string;
    
    };
    
    ¬†
    
    type UnlockedAccount = CreateMutable<LockedAccount>;
    
               
    
    type UnlockedAccount = {
        id: string;
        name: string;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHIBOkCGATWA7AGwE9VQsAXC9ASwCMBXC5UAM3VmnNAuIAdIqFHw4D0FGsgBQvAaADCmSpACyTLHUKQAPABV+kAHygAvKADeU0KAC0SvEWKgA2gAVRkcU5r5QAa0hiWFZQfQEAXQAuUIM3Dy9wgG4pAF9kmQNQABlYAGMAnABBXNzYBnwKUwsrUHsCElAaHGikah8Ac2TrOsdQfCxoSBa2-E7U9NlIUABVIjyC4tLyyrNFbGY1Cg0tbRz8yCKSsorDZJBrUAA9AH4gA)
    
    
    ts
    
    // Removes 'optional' attributes from a type's properties
    
    type Concrete<Type> = {
    
      [Property in keyof Type]-?: Type[Property];
    
    };
    
    ¬†
    
    type MaybeUser = {
    
      id: string;
    
      name?: string;
    
      age?: number;
    
    };
    
    ¬†
    
    type User = Concrete<MaybeUser>;
    
          
    
    type User = {
        id: string;
        name: string;
        age: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHJYAcAuBLWA7AQwBtVRCssAnHAIwFctlQAzK2ac0LATw0lQoM7flVzIAUL36gAwgQDGVSEwA8AFT6QAfKAC8oAN4TQoANoAFEZDE9QOfKADWkHrBahN-ALoBaAPwAXJ5alta23gDcEgC+0VJaoACyhDy0kACqSDb6Rib2ACbBSNQOAObRpkTQkEGgJTT4FfmEZbXB+PTQ6VTRcRIJMlk5BvL4SiqQqilpmdlU2tEgpqAAev5AA)

## Key Remapping via `as`

In TypeScript 4.1 and onwards, you can re-map keys in mapped types with an
`as` clause in a mapped type:

    
    
    ts
    
    type MappedTypeWithNewProperties<Type> = {
    
        [Properties in keyof Type as NewKeyType]: Type[Properties]
    
    }

You can leverage features like [template literal
types](/docs/handbook/2/template-literal-types.html) to create new property
names from prior ones:

    
    
    ts
    
    type Getters<Type> = {
    
        [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
    
    };
    
    ¬†
    
    interface Person {
    
        name: string;
    
        age: number;
    
        location: string;
    
    }
    
    ¬†
    
    type LazyPerson = Getters<Person>;
    
             
    
    type LazyPerson = {
        getName: () => string;
        getAge: () => number;
        getLocation: () => string;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4Aq4ID4oF4oBvAKCnKgG0AFJAe0iVCgEsA7KAawhDoDMoWSFACGKKAAMA5vAAkRAMIiwLYCIA2LAF4Q0KYEnZSoAMii0GyUDgC+EgLoAuKAAoAlATxCINeo1D2JDYA3CQk7IhIfCIAxtDUyCh0HKQUUGwiALYQzvqGbFKhaSIyzmwArpkARshFFOp0MSLALMm5BkahNmGgwgAyIlogCajJBLDwkegjSWw4oQD0CxQAegD8QA)

You can filter out keys by producing `never` via a conditional type:

    
    
    ts
    
    // Remove the 'kind' property
    
    type RemoveKindField<Type> = {
    
        [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]
    
    };
    
    ¬†
    
    interface Circle {
    
        kind: "circle";
    
        radius: number;
    
    }
    
    ¬†
    
    type KindlessCircle = RemoveKindField<Circle>;
    
               
    
    type KindlessCircle = {
        radius: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVWlQB8oALygA3vVBLQAbQAKFKjVqh8oLJFqwAZqDHMAhgGdQAUQAeAY34BXApCEbK1OgBpQAES4hAESALoAXGbikOqaPrRh9AC+ANz09PjI1MYWjkgAwjhkzkgKyvpcUQGOxaUB6RVkFgQ4LlZReC7QAEbU6ckZTEichPyQVlZFJeMyLHCIozx8gkLTpRLpIMoAegD8QA)

You can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:
    
    
    ts
    
    type EventConfig<Events extends { kind: string }> = {
    
        [E in Events as E["kind"]]: (event: E) => void;
    
    }
    
    ¬†
    
    type SquareEvent = { kind: "square", x: number, y: number };
    
    type CircleEvent = { kind: "circle", radius: number };
    
    ¬†
    
    type Config = EventConfig<SquareEvent | CircleEvent>
    
           
    
    type Config = {
        square: (event: SquareEvent) => void;
        circle: (event: CircleEvent) => void;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogbhAdsAwge0QMwJYHMA88SwAzlBAB7BIAmZA3lANbaI0BcUJwATq7lAC+APigBeKPQBQUWVADaMKK1gJkZAIZkY8gEQs2ugLpHOACghrgnGAEpxouGmw0A3FMFSpoSFADKAI4Arho8EETI4pLMrBxQuiTBoRC6ADRQFJyIQQC2AEYQPOkgWbkFPELuPtAo2DwAxgA24VZRjAZxuvV1TSnpPBo02EEkpfmFlV7VUOhYeFERqBg4BIEhYYtQAD4zPc2LwlIA9EdyAHoA-EA)

### Further Exploration

Mapped types work well with other features in this type manipulation section,
for example here is [a mapped type using a conditional
type](/docs/handbook/2/conditional-types.html) which returns either a `true`
or `false` depending on whether an object has the property `pii` set to the
literal `true`:

    
    
    ts
    
    type ExtractPII<Type> = {
    
      [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;
    
    };
    
    ¬†
    
    type DBFields = {
    
      id: { format: "incrementing" };
    
      name: { type: string; pii: true };
    
    };
    
    ¬†
    
    type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;
    
                     
    
    type ObjectsNeedingGDPRDeletion = {
        id: false;
        name: true;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogHsATgQwMbAAoEksB4Aq4EAfFALxQDeAUFFANoaID2kioUAlgHZQDWEEMwBmUQpAC6ALjFFGLNqAlQICCNwAmAZypQwnTjKQBXaAF8oAfignoM4cgA2WiAG5qZ99VCQoAEQAhADFOCEdtcipaLg0ZSihhZkQAW2RgGQAiHlRECGT1YB4AcwyoT2juZHy4myIZLSRi1z0DI0RTMvdy7yIoAHkAIwArCHQtADkICA1igHE-DAAlPzCIQuZeCngkNEwcXECQsO1idwB6M7ooAD1LIA)

### [Conditional TypesCreate types which act like if statements in the type
system.](/docs/handbook/2/conditional-types.html)

### [Template Literal TypesGenerating mapping types which change properties
via template literal strings.](/docs/handbook/2/template-literal-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Mapped Types.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(7\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SF![Sergey Falinsky
\(2\)](https://gravatar.com/avatar/ed9cdede625d84beb153051efefa0bfc?s=32&&d=blank)

L![Luke
\(1\)](https://gravatar.com/avatar/90fc2c8799b9209360d208feb31c0830?s=32&&d=blank)

W![webstrand
\(1\)](https://gravatar.com/avatar/dfe4babb4e414382d359fa8a6f36461e?s=32&&d=blank)

SGH![Steven G. Harms
\(1\)](https://gravatar.com/avatar/6a070b2c7e547cc942b8b8b094fd221a?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules

JavaScript has a long history of different ways to handle modularizing code.
Having been around since 2012, TypeScript has implemented support for a lot of
these formats, but over time the community and the JavaScript specification
has converged on a format called ES Modules (or ES6 modules). You might know
it as the `import`/`export` syntax.

ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad
support in most web browsers and JavaScript runtimes.

For focus, the handbook will cover both ES Modules and its popular pre-cursor
CommonJS `module.exports =` syntax, and you can find information about the
other module patterns in the reference section under
[Modules](/docs/handbook/modules.html).

## How JavaScript Modules are Defined

In TypeScript, just as in ECMAScript 2015, any file containing a top-level
`import` or `export` is considered a module.

Conversely, a file without any top-level import or export declarations is
treated as a script whose contents are available in the global scope (and
therefore to modules as well).

Modules are executed within their own scope, not in the global scope. This
means that variables, functions, classes, etc. declared in a module are not
visible outside the module unless they are explicitly exported using one of
the export forms. Conversely, to consume a variable, function, class,
interface, etc. exported from a different module, it has to be imported using
one of the import forms.

## Non-modules

Before we start, it‚Äôs important to understand what TypeScript considers a
module. The JavaScript specification declares that any JavaScript files
without an `import` declaration, `export`, or top-level `await` should be
considered a script and not a module.

Inside a script file variables and types are declared to be in the shared
global scope, and it‚Äôs assumed that you‚Äôll either use the
[`outFile`](/tsconfig#outFile) compiler option to join multiple input files
into one output file, or use multiple `<script>` tags in your HTML to load
these files (in the correct order!).

If you have a file that doesn‚Äôt currently have any `import`s or `export`s, but
you want to be treated as a module, add the line:

    
    
    ts
    
    export {};
    
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g)

which will change the file to be a module exporting nothing. This syntax works
regardless of your module target.

## Modules in TypeScript

> Additional Reading:  
>  [Impatient JS (Modules)](https://exploringjs.com/impatient-
> js/ch_modules.html#overview-syntax-of-ecmascript-modules)  
>  [MDN: JavaScript Modules](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Guide/Modules)  
>

There are three main things to consider when writing module-based code in
TypeScript:

  * **Syntax** : What syntax do I want to use to import and export things?
  * **Module Resolution** : What is the relationship between module names (or paths) and files on disk?
  * **Module Output Target** : What should my emitted JavaScript module look like?

### ES Module Syntax

A file can declare a main export via `export default`:

    
    
    ts
    
    // @filename: hello.ts
    
    export default function helloWorld() {
    
      console.log("Hello, world!");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA)

This is then imported via:

    
    
    ts
    
    import helloWorld from "./hello.js";
    
    helloWorld();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA)

In addition to the default export, you can have more than one export of
variables and functions via the `export` by omitting `default`:

    
    
    ts
    
    // @filename: maths.ts
    
    export var pi = 3.14;
    
    export let squareTwo = 1.41;
    
    export const phi = 1.61;
    
    ¬†
    
    export class RandomNumberGenerator {}
    
    ¬†
    
    export function absolute(num: number) {
    
      if (num < 0) return num * -1;
    
      return num;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA)

These can be used in another file via the `import` syntax:

    
    
    ts
    
    import { pi, phi, absolute } from "./maths.js";
    
    ¬†
    
    console.log(pi);
    
    const absPhi = absolute(phi);
    
            
    
    const absPhi: number
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA)

### Additional Import Syntax

An import can be renamed using a format like `import {old as new}`:

    
    
    ts
    
    import { pi as œÄ } from "./maths.js";
    
    ¬†
    
    console.log(œÄ);
    
               
    
    (alias) var œÄ: number
    import œÄ
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA)

You can mix and match the above syntax into a single `import`:

    
    
    ts
    
    // @filename: maths.ts
    
    export const pi = 3.14;
    
    export default class RandomNumberGenerator {}
    
    ¬†
    
    // @filename: app.ts
    
    import RandomNumberGenerator, { pi as œÄ } from "./maths.js";
    
    ¬†
    
    RandomNumberGenerator;
    
             
    
    (alias) class RandomNumberGenerator
    import RandomNumberGenerator
    
    ¬†
    
    console.log(œÄ);
    
               
    
    (alias) const œÄ: 3.14
    import œÄ
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A)

You can take all of the exported objects and put them into a single namespace
using `* as name`:

    
    
    ts
    
    // @filename: app.ts
    
    import * as math from "./maths.js";
    
    ¬†
    
    console.log(math.pi);
    
    const positivePhi = math.absolute(math.phi);
    
              
    
    const positivePhi: number
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA)

You can import a file and _not_ include any variables into your current module
via `import "./file"`:

    
    
    ts
    
    // @filename: app.ts
    
    import "./maths.js";
    
    ¬†
    
    console.log("3.14");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA)

In this case, the `import` does nothing. However, all of the code in
`maths.ts` was evaluated, which could trigger side-effects which affect other
objects.

#### TypeScript Specific ES Module Syntax

Types can be exported and imported using the same syntax as JavaScript values:

    
    
    ts
    
    // @filename: animal.ts
    
    export type Cat = { breed: string; yearOfBirth: number };
    
    ¬†
    
    export interface Dog {
    
      breeds: string[];
    
      yearOfBirth: number;
    
    }
    
    ¬†
    
    // @filename: app.ts
    
    import { Cat, Dog } from "./animal.js";
    
    type Animals = Cat | Dog;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA)

TypeScript has extended the `import` syntax with two concepts for declaring an
import of a type:

###### `import type`

Which is an import statement which can _only_ import types:

    
    
    ts
    
    // @filename: animal.ts
    
    export type Cat = { breed: string; yearOfBirth: number };
    
    export type Dog = { breeds: string[]; yearOfBirth: number };
    
    export const createCatName = () => "fluffy";
    
    ¬†
    
    // @filename: valid.ts
    
    import type { Cat, Dog } from "./animal.js";
    
    export type Animals = Cat | Dog;
    
    ¬†
    
    // @filename: app.ts
    
    import type { createCatName } from "./animal.js";
    
    const name = createCatName();
    
    'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA)

###### Inline `type` imports

TypeScript 4.5 also allows for individual imports to be prefixed with `type`
to indicate that the imported reference is a type:

    
    
    ts
    
    // @filename: app.ts
    
    import { createCatName, type Cat, type Dog } from "./animal.js";
    
    ¬†
    
    export type Animals = Cat | Dog;
    
    const name = createCatName();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA)

Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to
know what imports can be safely removed.

#### ES Module Syntax with CommonJS Behavior

TypeScript has ES Module syntax which _directly_ correlates to a CommonJS and
AMD `require`. Imports using ES Module are _for most cases_ the same as the
`require` from those environments, but this syntax ensures you have a 1 to 1
match in your TypeScript file with the CommonJS output:

    
    
    ts
    
    import fs = require("fs");
    
    const code = fs.readFileSync("hello.ts", "utf8");
    
    [Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA)

You can learn more about this syntax in the [modules reference
page](/docs/handbook/modules.html#export--and-import--require).

## CommonJS Syntax

CommonJS is the format which most modules on npm are delivered in. Even if you
are writing using the ES Modules syntax above, having a brief understanding of
how CommonJS syntax works will help you debug easier.

#### Exporting

Identifiers are exported via setting the `exports` property on a global called
`module`.

    
    
    ts
    
    function absolute(num: number) {
    
      if (num < 0) return num * -1;
    
      return num;
    
    }
    
    ¬†
    
    module.exports = {
    
      pi: 3.14,
    
      squareTwo: 1.41,
    
      phi: 1.61,
    
      absolute,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA)

Then these files can be imported via a `require` statement:

    
    
    ts
    
    const maths = require("./maths");
    
    maths.pi;
    
          
    
    any
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA)

Or you can simplify a bit using the destructuring feature in JavaScript:

    
    
    ts
    
    const { squareTwo } = require("./maths");
    
    squareTwo;
    
       
    
    const squareTwo: any
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA)

### CommonJS and ES Modules interop

There is a mis-match in features between CommonJS and ES Modules regarding the
distinction between a default import and a module namespace object import.
TypeScript has a compiler flag to reduce the friction between the two
different sets of constraints with
[`esModuleInterop`](/tsconfig#esModuleInterop).

## TypeScript‚Äôs Module Resolution Options

Module resolution is the process of taking a string from the `import` or
`require` statement, and determining what file that string refers to.

TypeScript includes two resolution strategies: Classic and Node. Classic, the
default when the compiler option [`module`](/tsconfig#module) is not
`commonjs`, is included for backwards compatibility. The Node strategy
replicates how Node.js works in CommonJS mode, with additional checks for
`.ts` and `.d.ts`.

There are many TSConfig flags which influence the module strategy within
TypeScript: [`moduleResolution`](/tsconfig#moduleResolution),
[`baseUrl`](/tsconfig#baseUrl), [`paths`](/tsconfig#paths),
[`rootDirs`](/tsconfig#rootDirs).

For the full details on how these strategies work, you can consult the [Module
Resolution](/docs/handbook/modules/reference.html#the-moduleresolution-
compiler-option) reference page.

## TypeScript‚Äôs Module Output Options

There are two options which affect the emitted JavaScript output:

  * [`target`](/tsconfig#target) which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact
  * [`module`](/tsconfig#module) which determines what code is used for modules to interact with each other

Which [`target`](/tsconfig#target) you use is determined by the features
available in the JavaScript runtime you expect to run the TypeScript code in.
That could be: the oldest web browser you support, the lowest version of
Node.js you expect to run on or could come from unique constraints from your
runtime - like Electron for example.

All communication between modules happens via a module loader, the compiler
option [`module`](/tsconfig#module) determines which one is used. At runtime
the module loader is responsible for locating and executing all dependencies
of a module before executing it.

For example, here is a TypeScript file using ES Modules syntax, showcasing a
few different options for [`module`](/tsconfig#module):

    
    
    ts
    
    import { valueOfPi } from "./constants.js";
    
    ¬†
    
    export const twoPi = valueOfPi * 2;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA)

#### `ES2020`

    
    
    ts
    
    import { valueOfPi } from "./constants.js";
    
    export const twoPi = valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA)

#### `CommonJS`

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.twoPi = void 0;
    
    const constants_js_1 = require("./constants.js");
    
    exports.twoPi = constants_js_1.valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA)

#### `UMD`

    
    
    ts
    
    (function (factory) {
    
        if (typeof module === "object" && typeof module.exports === "object") {
    
            var v = factory(require, exports);
    
            if (v !== undefined) module.exports = v;
    
        }
    
        else if (typeof define === "function" && define.amd) {
    
            define(["require", "exports", "./constants.js"], factory);
    
        }
    
    })(function (require, exports) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.twoPi = void 0;
    
        const constants_js_1 = require("./constants.js");
    
        exports.twoPi = constants_js_1.valueOfPi * 2;
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA)

> Note that ES2020 is effectively the same as the original `index.ts`.

You can see all of the available options and what their emitted JavaScript
code looks like in the [TSConfig Reference for `module`](/tsconfig#module).

## TypeScript namespaces

TypeScript has its own module format called `namespaces` which pre-dates the
ES Modules standard. This syntax has a lot of useful features for creating
complex definition files, and still sees active use [in
DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). While
not deprecated, the majority of the features in namespaces exist in ES Modules
and we recommend you use that to align with JavaScript‚Äôs direction. You can
learn more about namespaces in [the namespaces reference
page](/docs/handbook/namespaces.html).

### [ClassesHow classes work in TypeScript](/docs/handbook/2/classes.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Modules.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(52\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(7\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

M![Myo
\(3\)](https://gravatar.com/avatar/1889321e114dd7ecd318de69c1021a6b?s=32&&d=blank)

AB![Andrew Branch
\(2\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

HA![Hossein Ahmadian-Yazdi
\(2\)](https://gravatar.com/avatar/e486af78745bd81069f00ebb26364938?s=32&&d=blank)

18+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Narrowing

Imagine we have a function called `padLeft`.

    
    
    ts
    
    function padLeft(padding: number | string, input: string): string {
    
      throw new Error("Not implemented yet!");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkRQAFkzgB3ath0BRJpqb4ARADk4UQbWQAbbLWxgo2dIgCe2KAEJTkgG5FAF8gA)

If `padding` is a `number`, it will treat that as the number of spaces we want
to prepend to `input`. If `padding` is a `string`, it should just prepend
`padding` to `input`. Let‚Äôs try to implement the logic for when `padLeft` is
passed a `number` for `padding`.

    
    
    ts
    
    function padLeft(padding: number | string, input: string): string {
    
      return " ".repeat(padding) + input;
    
    Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.2345Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAA4CGAJgDKQEUAUTzzVJAOaoSRALYAjGKAA+oRBWgDBAGlAD6RCqgVKhASh2LloAN55QoaJApFodAESgHAOmv1Ijbr34HQAanUSTQoAbjwAXyA)

Uh-oh, we‚Äôre getting an error on `padding`. TypeScript is warning us that we‚Äôre passing a value with type `number | string` to the `repeat` function, which only accepts a `number`, and it‚Äôs right. In other words, we haven‚Äôt explicitly checked if `padding` is a `number` first, nor are we handling the case where it‚Äôs a `string`, so let‚Äôs do exactly that.
    
    
    ts
    
    function padLeft(padding: number | string, input: string): string {
    
      if (typeof padding === "number") {
    
        return " ".repeat(padding) + input;
    
      }
    
      return padding + input;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBwBfB2dXdxQMQzJEUKERaJigA)

If this mostly looks like uninteresting JavaScript code, that‚Äôs sort of the
point. Apart from the annotations we put in place, this TypeScript code looks
like JavaScript. The idea is that TypeScript‚Äôs type system aims to make it as
easy as possible to write typical JavaScript code without bending over
backwards to get type safety.

While it might not look like much, there‚Äôs actually a lot going on under the
covers here. Much like how TypeScript analyzes runtime values using static
types, it overlays type analysis on JavaScript‚Äôs runtime control flow
constructs like `if/else`, conditional ternaries, loops, truthiness checks,
etc., which can all affect those types.

Within our `if` check, TypeScript sees `typeof padding === "number"` and
understands that as a special form of code called a _type guard_. TypeScript
follows possible paths of execution that our programs can take to analyze the
most specific possible type of a value at a given position. It looks at these
special checks (called _type guards_) and assignments, and the process of
refining types to more specific types than declared is called _narrowing_. In
many editors we can observe these types as they change, and we‚Äôll even do so
in our examples.

    
    
    ts
    
    function padLeft(padding: number | string, input: string): string {
    
      if (typeof padding === "number") {
    
        return " ".repeat(padding) + input;
    
                            
    
    (parameter) padding: number
    
      }
    
      return padding + input;
    
               
    
    (parameter) padding: string
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBxUAeljHRKTEgD0AfgcAXwdnV3cUDEMyRFChEWi4hNSMzKA)

There are a couple of different constructs TypeScript understands for
narrowing.

## `typeof` type guards

As we‚Äôve seen, JavaScript supports a `typeof` operator which can give very
basic information about the type of values we have at runtime. TypeScript
expects this to return a certain set of strings:

  * `"string"`
  * `"number"`
  * `"bigint"`
  * `"boolean"`
  * `"symbol"`
  * `"undefined"`
  * `"object"`
  * `"function"`

Like we saw with `padLeft`, this operator comes up pretty often in a number of
JavaScript libraries, and TypeScript can understand it to narrow types in
different branches.

In TypeScript, checking against the value returned by `typeof` is a type
guard. Because TypeScript encodes how `typeof` operates on different values,
it knows about some of its quirks in JavaScript. For example, notice that in
the list above, `typeof` doesn‚Äôt return the string `null`. Check out the
following example:

    
    
    ts
    
    function printAll(strs: string | string[] | null) {
    
      if (typeof strs === "object") {
    
        for (const s of strs) {
    
    'strs' is possibly 'null'.18047'strs' is possibly 'null'.
    
          console.log(s);
    
        }
    
      } else if (typeof strs === "string") {
    
        console.log(strs);
    
      } else {
    
        // do nothing
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMBGUOAOABgBYB2AKADMBXAOwGMAXASzjtAAdoW6mBBADaCAFIiZJU4nnQDmoAD6hpvWQG0AuotB0awgJSgA3hVCgWVUCKYBPTpDiXpiUAF53oAERwARgCtIZk9DEzMzKgQrBnZxZVBHZQlEENMws2i6RDhBSAA6QThZMX0AblSzAF9UitBIQURIc0trOwcnJLcPTxU5YONy0AysnPzCsSTS6tr6xtCwkFAAEzgdOCYAC1VqigqgA)

In the `printAll` function, we try to check if `strs` is an object to see if
it‚Äôs an array type (now might be a good time to reinforce that arrays are
object types in JavaScript). But it turns out that in JavaScript, `typeof
null` is actually `"object"`! This is one of those unfortunate accidents of
history.

Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.

This might be a good segue into what we‚Äôll call ‚Äútruthiness‚Äù checking.

# Truthiness narrowing

Truthiness might not be a word you‚Äôll find in the dictionary, but it‚Äôs very
much something you‚Äôll hear about in JavaScript.

In JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if`
statements, Boolean negations (`!`), and more. As an example, `if` statements
don‚Äôt expect their condition to always have the type `boolean`.

    
    
    ts
    
    function getUsersOnlineMessage(numUsersOnline: number) {
    
      if (numUsersOnline) {
    
        return `There are ${numUsersOnline} online now!`;
    
      }
    
      return "Nobody's here. :(";
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQKoGdUCcsDyYANjGKgLKpZYCGaAFGCALbZ6ElmoBcizLAEZ4AlIgDeAKESIYwRE1bt8RUuTFSZM3OhC4kAAwAqACzypEtHYgAk4gcs5rUAX0QJn-OAHcAhAYBuaUQXYJ0oPSQAIgA5OEE4ABMATwByLEQzHQA6RB4GKKCXIA)

In JavaScript, constructs like `if` first ‚Äúcoerce‚Äù their conditions to
`boolean`s to make sense of them, and then choose their branches depending on
whether the result is `true` or `false`. Values like

  * `0`
  * `NaN`
  * `""` (the empty string)
  * `0n` (the `bigint` version of zero)
  * `null`
  * `undefined`

all coerce to `false`, and other values get coerced to `true`. You can always
coerce values to `boolean`s by running them through the `Boolean` function, or
by using the shorter double-Boolean negation. (The latter has the advantage
that TypeScript infers a narrow literal boolean type `true`, while inferring
the first as type `boolean`.)

    
    
    ts
    
    // both of these result in 'true'
    
    Boolean("hello"); // type: boolean, value: true
    
    !!"world"; // type: true,    value: true
    
    This kind of expression is always truthy.2872This kind of expression is always truthy.[Try](https://www.typescriptlang.org/play/#code/PTAECMHsBcAtUgM1HApgZ1aAThgrgDbSgCWAdqAOTTZ6qUBQAQpJAagIZkAUARLKgIFIvAJQBuUCBQBPAA6oAXBFbsuAGlAA3DgTrKadBgEJjvAO6RsBACa9J06PKUpaqTaE869Lw6iA)

It‚Äôs fairly popular to leverage this behavior, especially for guarding against
values like `null` or `undefined`. As an example, let‚Äôs try using it for our
`printAll` function.

    
    
    ts
    
    function printAll(strs: string | string[] | null) {
    
      if (strs && typeof strs === "object") {
    
        for (const s of strs) {
    
          console.log(s);
    
        }
    
      } else if (typeof strs === "string") {
    
        console.log(strs);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogBkcxFACeyAKZxJVWQF49iAERwARgCs10AwJFixwOKikQExSok1NS10bbHOwhHA4agB0OHA0RHwA3D5iAL4+8YhqOIRq4pL4Kuoe2oh6OoZULFZCcYj+gcFhEdJesQnC8UA)

You‚Äôll notice that we‚Äôve gotten rid of the error above by checking if `strs`
is truthy. This at least prevents us from dreaded errors when we run our code
like:

    
    
    txt
    
    TypeError: null is not iterable

Keep in mind though that truthiness checking on primitives can often be error
prone. As an example, consider a different attempt at writing `printAll`

    
    
    ts
    
    function printAll(strs: string | string[] | null) {
    
      // !!!!!!!!!!!!!!!!
    
      //  DON'T DO THIS!
    
      //   KEEP READING
    
      // !!!!!!!!!!!!!!!!
    
      if (strs) {
    
        if (typeof strs === "object") {
    
          for (const s of strs) {
    
            console.log(s);
    
          }
    
        } else if (typeof strs === "string") {
    
          console.log(strs);
    
        }
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRAHpxiAISy58hdNESpiACIB5AHIByACrqNiPQAkAkgGUlYyWMQBpAKKOACogBKjrGrNaA4sq2isFyyjDAiEQkhAIidojhkVAAnsgApnARVISIALz5iABEcABGAFZp0IWxyvHAcKiREAjElIiZTKQ18fHNYIRwOGkAdDhwNER8ANy1dgC+s3OIaTiEaQkR+CnpHdl5BYVULNVCs2J9A0Oj41FdM-ELYgtzQA)

We wrapped the entire body of the function in a truthy check, but this has a
subtle downside: we may no longer be handling the empty string case correctly.

TypeScript doesn‚Äôt hurt us here at all, but this behavior is worth noting if
you‚Äôre less familiar with JavaScript. TypeScript can often help you catch bugs
early on, but if you choose to do _nothing_ with a value, there‚Äôs only so much
that it can do without being overly prescriptive. If you want, you can make
sure you handle situations like these with a linter.

One last word on narrowing by truthiness is that Boolean negations with `!`
filter out from negated branches.

    
    
    ts
    
    function multiplyAll(
    
      values: number[] | undefined,
    
      factor: number
    
    ): number[] | undefined {
    
      if (!values) {
    
        return values;
    
      } else {
    
        return values.map((x) => x * factor);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwIJpoAUAUIogG4CGaIApgM4BciYIyARnQE4DaAuogA+icABM6wGGDpiANGUTAq0ONxZtOPEgEoN7Ln0Ejxk6bMQBvRTGCIiAQmq1GOq4vLc6UENyTP6BgBuRQBfRDo0Bjp3ck9vX38aQIA6ZCpMIiIADzcAXgA+RGzEAColFSg1HRDyUJJQoA)

## Equality narrowing

TypeScript also uses `switch` statements and equality checks like `===`,
`!==`, `==`, and `!=` to narrow types. For example:

    
    
    ts
    
    function example(x: string | number, y: string | boolean) {
    
      if (x === y) {
    
        // We can now call any 'string' method on 'x' or 'y'.
    
        x.toUpperCase();
    
              
    
    (method) String.toUpperCase(): string
    
        y.toLowerCase();
    
              
    
    (method) String.toLowerCase(): string
    
      } else {
    
        console.log(x);
    
                   
    
    (parameter) x: string | number
    
        console.log(y);
    
                   
    
    (parameter) y: string | boolean
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgClQC5EBnKAJxjAHNEAfRMETAI2UoBpEBPUitTqNEbOHHzowASkQBvAFCJEMYIiKIAvNr6zFy5QHpDiAOrJEEKczgB3S+ly5EU3ogDkgmrXeJMyKAALOAATRAQPVF84Sg9edwA6JQNUBKg4AFVsbE4AYXQyQmkAbmSjEwA9AH4yvjS4ABk7PIKi0oNEY0Rq5IBfFFxC+VqIBDIJZATcOFoiEtqujqWejtGwcfwpmYJeeY7FpYMVxF6FXqA)

When we checked that `x` and `y` are both equal in the above example,
TypeScript knew their types also had to be equal. Since `string` is the only
common type that both `x` and `y` could take on, TypeScript knows that `x` and
`y` must be `string`s in the first branch.

Checking against specific literal values (as opposed to variables) works also.
In our section about truthiness narrowing, we wrote a `printAll` function
which was error-prone because it accidentally didn‚Äôt handle empty strings
properly. Instead we could have done a specific check to block out `null`s,
and TypeScript still correctly removes `null` from the type of `strs`.

    
    
    ts
    
    function printAll(strs: string | string[] | null) {
    
      if (strs !== null) {
    
        if (typeof strs === "object") {
    
          for (const s of strs) {
    
                           
    
    (parameter) strs: string[]
    
            console.log(s);
    
          }
    
        } else if (typeof strs === "string") {
    
          console.log(strs);
    
                       
    
    (parameter) strs: string
    
        }
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogCEAXgXdeOASLFiJUqAE9kAUziSqspcoBEcAEYArA9AvrRmscDiopEBMUqJjTKTOrq4A9KEhkYgAegD8LpHeYIRwOAYAdDhwNER8ANwJmgC+hUWIBjiEBuKS+HqGAaaI5ogWVCxOQoViSSlpmdnSQQWR4VGacaUuJUVAA)

JavaScript‚Äôs looser equality checks with `==` and `!=` also get narrowed
correctly. If you‚Äôre unfamiliar, checking whether something `== null` actually
not only checks whether it is specifically the value `null` \- it also checks
whether it‚Äôs potentially `undefined`. The same applies to `== undefined`: it
checks whether a value is either `null` or `undefined`.

    
    
    ts
    
    interface Container {
    
      value: number | null | undefined;
    
    }
    
    ¬†
    
    function multiplyValue(container: Container, factor: number) {
    
      // Remove both 'null' and 'undefined' from the type.
    
      if (container.value != null) {
    
        console.log(container.value);
    
                               
    
    (property) Container.value: number
    
    ¬†
    
        // Now we can safely multiply 'container.value'.
    
        container.value *= factor;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NZBvAKGWQDc4AbAVwgC5kRKBbAI1wB97LzzkPKQAJhBg4BAbgIBfAgRj8EYYJmSMuigA7kAngDUK1ABQJMYbCGh0MWHFAA0yeAvRQ6DFtACU+IsgD0v5AAlCEZ0EhRmdDAAC2QAcgZuOOQ4QXj+IRFzAWSYKHRGZBiUMC11CAA6H2AYZCMTM2gKsioUAEIAXk5uL0JiYmMQAGd0ckrydABzeutzKGb9CA8Jfr8A1Y3N1YA9AH4ZVf9kADl0AHdkM5QEVOQhuBgIbRU1YE0teMHTGwXWuKrVl9GvMWtRkAAqLqOMDOFbIaSSIA)

## The `in` operator narrowing

JavaScript has an operator for determining if an object or its prototype chain
has a property with a name: the `in` operator. TypeScript takes this into
account as a way to narrow down potential types.

For example, with the code: `"value" in x`. where `"value"` is a string
literal and `x` is a union type. The ‚Äútrue‚Äù branch narrows `x`‚Äôs types which
have either an optional or required property `value`, and the ‚Äúfalse‚Äù branch
narrows to types which have an optional or missing property `value`.

    
    
    ts
    
    type Fish = { swim: () => void };
    
    type Bird = { fly: () => void };
    
    ¬†
    
    function move(animal: Fish | Bird) {
    
      if ("swim" in animal) {
    
        return animal.swim();
    
      }
    
    ¬†
    
      return animal.fly();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw4dRAVwB2AY2Bw6aqPjo0IJAIZqCJ8cXjIoAHz6DGFDByhQ4o0gCJcBbx56ZhbiLm7uUAIQwCoCQeb4lgB0fvjknO4sSu5RMXFQwYniSRIg6RwsQA)

To reiterate, optional properties will exist in both sides for narrowing. For
example, a human could both swim and fly (with the right equipment) and thus
should show up in both sides of the `in` check:

    
    
    ts
    
    type Fish = { swim: () => void };
    
    type Bird = { fly: () => void };
    
    type Human = { swim?: () => void; fly?: () => void };
    
    ¬†
    
    function move(animal: Fish | Bird | Human) {
    
      if ("swim" in animal) {
    
        animal;
    
          
    
    (parameter) animal: Fish | Human
    
      } else {
    
        animal;
    
          
    
    (parameter) animal: Bird | Human
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuy7hoACQCu+AIYA7NJmx58AfmkVU1ekzZQJIE6TMX5rTh1FrtAY2Bw6u-HQ0ECQ6BJrixPDIUAA+fILMcepa2hQYHFBQcKKkAES4BLlZuqFa4mkZmVCl4ZwA9HWZAHpGlSxQEOII0OlV1dph4vWNUC1tHCxAA)

## `instanceof` narrowing

JavaScript has an operator for checking whether or not a value is an
‚Äúinstance‚Äù of another value. More specifically, in JavaScript `x instanceof
Foo` checks whether the _prototype chain_ of `x` contains `Foo.prototype`.
While we won‚Äôt dive deep here, and you‚Äôll see more of this when we get into
classes, they can still be useful for most values that can be constructed with
`new`. As you might have guessed, `instanceof` is also a type guard, and
TypeScript narrows in branches guarded by `instanceof`s.

    
    
    ts
    
    function logValue(x: Date | string) {
    
      if (x instanceof Date) {
    
        console.log(x.toUTCString());
    
                   
    
    (parameter) x: Date
    
      } else {
    
        console.log(x.toUpperCase());
    
                   
    
    (parameter) x: string
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgcwGoENkgKYAUAHgFyIAiWUeiAPogM5QBOMYaAlIgN4BQiiGMETFBYJlkh44wytS58BAiAgZxkeAHSo0xTVDgBVACoBhAMos2ujhwDc-JQHonSt0oB6AfkcBfRHjIDDSKSiri6lo6egaGAA5xeMymWMEEtg5uLu7u3n68vkA)

## Assignments

As we mentioned earlier, when we assign to any variable, TypeScript looks at
the right side of the assignment and narrows the left side appropriately.

    
    
    ts
    
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    
       
    
    let x: string | number
    
    x = 1;
    
    ¬†
    
    console.log(x);
    
               
    
    let x: number
    
    x = "goodbye!";
    
    ¬†
    
    console.log(x);
    
               
    
    let x: string
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EFkCGYAWA6ATkgdgEwHsBbACgEoIAeCABnQFYIB+CARhogC4IAiVEYMAIQA7gUzA8AQh4BuAFAB6RRAgA9JvJjxWC+QGMCOAM4FQ6IQHMSUMguWrHT9Zu29LBAngBGATxAyeoYmZiAWBNa29irOThpAA)

Notice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the _declared type_ of `x` \- the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.

If we‚Äôd assigned a `boolean` to `x`, we‚Äôd have seen an error since that wasn‚Äôt
part of the declared type.

    
    
    ts
    
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    
       
    
    let x: string | number
    
    x = 1;
    
    ¬†
    
    console.log(x);
    
               
    
    let x: number
    
    x = true;
    
    Type 'boolean' is not assignable to type 'string | number'.2322Type 'boolean' is not assignable to type 'string | number'.
    
    ¬†
    
    console.log(x);
    
               
    
    let x: string | number
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABtIAXUAD1AF5QBZAQ0IAsA6aGgOwBM4BbACgEpQAHlAAGRgFZQAflABGEaFQAiepDx44oAO4I87AIRKA3DhChQAPSk4ylWSZwBjOK0RwCjDQHMeJPibNzIOCrGwpQQmgAV0gHZ1d3SE84Hz8AsGDMqyA)

## Control flow analysis

Up until this point, we‚Äôve gone through some basic examples of how TypeScript
narrows within specific branches. But there‚Äôs a bit more going on than just
walking up from every variable and looking for type guards in `if`s, `while`s,
conditionals, etc. For example

    
    
    ts
    
    function padLeft(padding: number | string, input: string) {
    
      if (typeof padding === "number") {
    
        return " ".repeat(padding) + input;
    
      }
    
      return padding + input;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJSIA3gChEg4InxQAnsmxxlREuUQBeI4gBENBsxPT5ixU2xQQTJCdMA6e5tQFdvaQGpBMGEoAG4FRABfCPtHZxQMPTJEQKERcMigA)

`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is _unreachable_ in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.

This analysis of code based on reachability is called _control flow analysis_
, and TypeScript uses this flow analysis to narrow types as it encounters type
guards and assignments. When a variable is analyzed, control flow can split
off and re-merge over and over again, and that variable can be observed to
have a different type at each point.

    
    
    ts
    
    function example() {
    
      let x: string | number | boolean;
    
    ¬†
    
      x = Math.random() < 0.5;
    
    ¬†
    
      console.log(x);
    
                 
    
    let x: boolean
    
    ¬†
    
      if (Math.random() < 0.5) {
    
        x = "hello";
    
        console.log(x);
    
                   
    
    let x: string
    
      } else {
    
        x = 100;
    
        console.log(x);
    
                   
    
    let x: number
    
      }
    
    ¬†
    
      return x;
    
            
    
    let x: string | number
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgCgEpEBvAKEUXykVQC5EBnKAJxjAHNEAfRMEJgBGyVr0RC4cfOjABucpTqIAvIgCy6KAAsAdK1kATOJmKIAPIgAMugKwKlEBE2nJduOJwKoiCqgHp-KmCQxAA9AH5FKhhgRAJNHX0jEzNLG1sSChDUVUQAIm1kXA98v2CnMBd8d09vXyUAoNCQyKUAXxRcJmQyRuU1AEYrK3KqSuq3Dy8fMcRAltaoqnboxFZkKBBWJFRyhaXydqA)

## Using type predicates

We‚Äôve worked with existing JavaScript constructs to handle narrowing so far,
however sometimes you want more direct control over how types change
throughout your code.

To define a user-defined type guard, we simply need to define a function whose
return type is a _type predicate_ :

    
    
    ts
    
    function isFish(pet: Fish | Bird): pet is Fish {
    
      return (pet as Fish).swim !== undefined;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTgHo-KABaEJUdYBCgjl0DIxMoRDckEkhgV0QUL34hMmJUhIRYDMwOKCgtYB0BUxTLKHVCpLIAOlwCKABCVHR9ZVE4PQhfDhYgA)

`pet is Fish` is our type predicate in this example. A predicate takes the
form `parameterName is Type`, where `parameterName` must be the name of a
parameter from the current function signature.

Any time `isFish` is called with some variable, TypeScript will _narrow_ that
variable to that specific type if the original type is compatible.

    
    
    ts
    
    // Both calls to 'swim' and 'fly' are now okay.
    
    let pet = getSmallPet();
    
    ¬†
    
    if (isFish(pet)) {
    
      pet.swim();
    
    } else {
    
      pet.fly();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTroNGJlCIbkgkkMCuiChe-EJkxBHBCLDRmBxQUFrAOgKm4ZZQ6imhZAB0uARQAISo6PrKonB6EL4cLBwA9J1QALT9KjrA-b1dPbx0wCgqduIpwHRQAOSV+EtFesxLEiDrmtB6dDhQdADW6iBlHOKFSegW1rb2TsDknBxwoqQh0QXAZBQMBkoBEKnh8G92lAIHNoEDMqCdpCWEA)

Notice that TypeScript not only knows that `pet` is a `Fish` in the `if`
branch; it also knows that in the `else` branch, you _don‚Äôt_ have a `Fish`, so
you must have a `Bird`.

You may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:
    
    
    ts
    
    const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
    
    const underWater1: Fish[] = zoo.filter(isFish);
    
    // or, equivalently
    
    const underWater2: Fish[] = zoo.filter(isFish) as Fish[];
    
    ¬†
    
    // The predicate may need repeating for more complex examples
    
    const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
    
      if (pet.name === "sharkey") return false;
    
      return isFish(pet);
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMBuKAOwEN8JiFgAnOGwDmUAL7MAUKEhQAQnH6M0mKADMANiGLkqtBi3Zce2AUNETJjCAGMNHftDUBXNjeBw6bKMIjAAyvgcGhoACn7kxPDIUAA+8ooski5uHl5QiNFIJJDAUYgo8QpKZMS5GQiwBZiSUFCOwM783jl+UByVWWQAdLgEUACEqOiu1mpCEElikgD0M1AAtEs2zsBLC5I2XnxQAF50dDpZcQklANoAuipnvgFBIeHA5AA0Pn6BwWERZK+3Hw-fC5SLZsHajCD8ADqHGAEIAjPlkJcVPs6N1xhpYfwSJkCmQpHMoHR+K8IABHZxwGjBCBsYBaTbbYBQcFQmEQgBMiKQyPQqPRcExEJxCC67U6BUuUlm8wAKkhoGBHIw4DZ2VAgiB2BBJvUIJAYeZ1MSNcToFt8GANBAAB5QW1cK0QBCM0HM1nQrEAZm5vL2BwFQuxrWApSg5UQVRiqGoGFqGTUpFy3U43DQwygACJkA4ANYQECZigNJreNTBBAQKR1EvNCpZEP4yRifFAA)

In addition, classes can [use `this is
Type`](/docs/handbook/2/classes.html#this-based-type-guards) to narrow their
type.

## Assertion functions

Types can also be narrowed using [Assertion functions](/docs/handbook/release-
notes/typescript-3-7.html#assertion-functions).

# Discriminated unions

Most of the examples we‚Äôve looked at so far have focused around narrowing
single variables with simple types like `string`, `boolean`, and `number`.
While this is common, most of the time in JavaScript we‚Äôll be dealing with
slightly more complex structures.

For some motivation, let‚Äôs imagine we‚Äôre trying to encode shapes like circles
and squares. Circles keep track of their radiuses and squares keep track of
their side lengths. We‚Äôll use a field called `kind` to tell which shape we‚Äôre
dealing with. Here‚Äôs a first attempt at defining `Shape`.

    
    
    ts
    
    interface Shape {
    
      kind: "circle" | "square";
    
      radius?: number;
    
      sideLength?: number;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AXyA)

Notice we‚Äôre using a union of string literal types: `"circle"` and `"square"` to tell us whether we should treat the shape as a circle or square respectively. By using `"circle" | "square"` instead of `string`, we can avoid misspelling issues.
    
    
    ts
    
    function handleShape(shape: Shape) {
    
      // oops!
    
      if (shape.kind === "rect") {
    
    This comparison appears to be unintentional because the types '"circle" | "square"' and '"rect"' have no overlap.2367This comparison appears to be unintentional because the types '"circle" | "square"' and '"rect"' have no overlap.
    
        // ...
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAJYB2ALjAGYCGAxpKAMoAWlADnQN56igDWxAJqgBE1AtGoAbSENAAfUEMQBHAK6Vo0gNxdQ0SvwIrEAflREVAWwBGMbd0QF+kADKQiAcxKNToc9dt4AL54eCCgALSR1CokkeF45CpE1CQEcESgzET8UkyskAAUiMxsqHlsAJSgnNxhcHAsiACEOgTkoEUlkAB0fNmgALxDChopQlU13KBh3bM6wYFAA)

We can write a `getArea` function that applies the right logic based on if
it‚Äôs dealing with a circle or square. We‚Äôll first try dealing with circles.

    
    
    ts
    
    function getArea(shape: Shape) {
    
      return Math.PI * shape.radius ** 2;
    
    'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIoa0utCFALJMwQB0AAoAkqAAVKA1jQPmltYTk2gmUUA)

Under [`strictNullChecks`](/tsconfig#strictNullChecks) that gives us an error
- which is appropriate since `radius` might not be defined. But what if we
perform the appropriate checks on the `kind` property?

    
    
    ts
    
    function getArea(shape: Shape) {
    
      if (shape.kind === "circle") {
    
        return Math.PI * shape.radius ** 2;
    
    'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIpQMoNW1kAB04tQSoAC8o5pyCsrSLW0iZiW60IUAskzBvQAKAJKgAFSgNY295pbWe-to7qAxUUA)

Hmm, TypeScript still doesn‚Äôt know what to do here. We‚Äôve hit a point where we
know more about our values than the type checker does. We could try to use a
non-null assertion (a `!` after `shape.radius`) to say that `radius` is
definitely present.

    
    
    ts
    
    function getArea(shape: Shape) {
    
      if (shape.kind === "circle") {
    
        return Math.PI * shape.radius! ** 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AX3z4A9HeQBaFwl5gXT-DF4gEYYAB7EGQDCDAAQUE4AApOTBwqDGwIAEpkAiJgGGQ4hIgAOlIQMmQAXgqaOgZmanTMojFw3igQgFk4YwKABQBJZAAqZHiUgvFJaQBCQaGAJnVkGysgA)

But this doesn‚Äôt feel ideal. We had to shout a bit at the type-checker with
those non-null assertions (`!`) to convince it that `shape.radius` was
defined, but those assertions are error-prone if we start to move code around.
Additionally, outside of [`strictNullChecks`](/tsconfig#strictNullChecks)
we‚Äôre able to accidentally access any of those fields anyway (since optional
properties are just assumed to always be present when reading them). We can
definitely do better.

The problem with this encoding of `Shape` is that the type-checker doesn‚Äôt
have any way to know whether or not `radius` or `sideLength` are present based
on the `kind` property. We need to communicate what _we_ know to the type
checker. With that in mind, let‚Äôs take another swing at defining `Shape`.

    
    
    ts
    
    interface Circle {
    
      kind: "circle";
    
      radius: number;
    
    }
    
    ¬†
    
    interface Square {
    
      kind: "square";
    
      sideLength: number;
    
    }
    
    ¬†
    
    type Shape = Circle | Square;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1JiA)

Here, we‚Äôve properly separated `Shape` out into two types with different
values for the `kind` property, but `radius` and `sideLength` are declared as
required properties in their respective types.

Let‚Äôs see what happens here when we try to access the `radius` of a `Shape`.

    
    
    ts
    
    function getArea(shape: Shape) {
    
      return Math.PI * shape.radius ** 2;
    
    Property 'radius' does not exist on type 'Shape'.
      Property 'radius' does not exist on type 'Square'.2339Property 'radius' does not exist on type 'Shape'.
      Property 'radius' does not exist on type 'Square'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBLAOwBcYAzAQwGNJQBhfaKgG1oG9dRQBrIgE1QAiKoxaRBAbk6hoFPvgCuKUIQUBbAEYwpAX1wES5arQDKARwUVo7ab0IDQgxBavipXRPj6QAMpEIA5sQAFqiqmtq4erjEAJ4ADqbBFImgALz0oqygAD6g5pbWUrggoAC0FVQKxBVluGQKhFTE+HCEoAGQxACC1hQAFIjJiagmw5AAlKAcXNbECtDtALIUIQB0AAoAkqAAVKBDKZBrsvJKe-toukA)

Like with our first definition of `Shape`, this is still an error. When
`radius` was optional, we got an error (with
[`strictNullChecks`](/tsconfig#strictNullChecks) enabled) because TypeScript
couldn‚Äôt tell whether the property was present. Now that `Shape` is a union,
TypeScript is telling us that `shape` might be a `Square`, and `Square`s don‚Äôt
have `radius` defined on them! Both interpretations are correct, but only the
union encoding of `Shape` will cause an error regardless of how
[`strictNullChecks`](/tsconfig#strictNullChecks) is configured.

But what if we tried checking the `kind` property again?

    
    
    ts
    
    function getArea(shape: Shape) {
    
      if (shape.kind === "circle") {
    
        return Math.PI * shape.radius ** 2;
    
                          
    
    (parameter) shape: Circle
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCImAYZDqWgDotMkCAoNoQxnbOojZyrigSgFk4e36ABQBJZAAqZHq-CH72Tl4d3YAmIxmEmdu7mYA9AH5WSXEgA)

That got rid of the error! When every type in a union contains a common
property with literal types, TypeScript considers that to be a _discriminated
union_ , and can narrow out the members of the union.

In this case, `kind` was that common property (which is what‚Äôs considered a
_discriminant_ property of `Shape`). Checking whether the `kind` property was
`"circle"` got rid of every type in `Shape` that didn‚Äôt have a `kind` property
with the type `"circle"`. That narrowed `shape` down to the type `Circle`.

The same checking works with `switch` statements as well. Now we can try to
write our complete `getArea` without any pesky `!` non-null assertions.

    
    
    ts
    
    function getArea(shape: Shape) {
    
      switch (shape.kind) {
    
        case "circle":
    
          return Math.PI * shape.radius ** 2;
    
                            
    
    (parameter) shape: Circle
    
        case "square":
    
          return shape.sideLength ** 2;
    
                  
    
    (parameter) shape: Square
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFoQxgpWKbZyrigSgFk4e2GABQBJZAAqZHq-CGH2Tl5Ts4AmIymE1bf3ogA9AH4V6dn5npoks-kR1GANiULt5hiYzJYbPZ7sgnn9Xu8fqxJOIgA)

The important thing here was the encoding of `Shape`. Communicating the right
information to TypeScript - that `Circle` and `Square` were really two
separate types with specific `kind` fields - was crucial. Doing that lets us
write type-safe TypeScript code that looks no different than the JavaScript we
would‚Äôve written otherwise. From there, the type system was able to do the
‚Äúright‚Äù thing and figure out the types in each branch of our `switch`
statement.

> As an aside, try playing around with the above example and remove some of
> the return keywords. You‚Äôll see that type-checking can help avoid bugs when
> accidentally falling through different clauses in a `switch` statement.

Discriminated unions are useful for more than just talking about circles and
squares. They‚Äôre good for representing any sort of messaging scheme in
JavaScript, like when sending messages over the network (client/server
communication), or encoding mutations in a state management framework.

# The `never` type

When narrowing, you can reduce the options of a union to a point where you
have removed all possibilities and have nothing left. In those cases,
TypeScript will use a `never` type to represent a state which shouldn‚Äôt exist.

# Exhaustiveness checking

The `never` type is assignable to every type; however, no type is assignable
to `never` (except `never` itself). This means you can use narrowing and rely
on `never` turning up to do exhaustive checking in a `switch` statement.

For example, adding a `default` to our `getArea` function which tries to
assign the shape to `never` will not raise an error when every possible case
has been handled.

    
    
    ts
    
    type Shape = Circle | Square;
    
    ¬†
    
    function getArea(shape: Shape) {
    
      switch (shape.kind) {
    
        case "circle":
    
          return Math.PI * shape.radius ** 2;
    
        case "square":
    
          return shape.sideLength ** 2;
    
        default:
    
          const _exhaustiveCheck: never = shape;
    
          return _exhaustiveCheck;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJ+APRvkAWh8IuYHy98MABPAAdFOzgI5ABeNHocZAAfZGVVdRZ8GC4QBDBgAHsQZGsIMABBdTgACh4oiKoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFpExgpWKbZyrigSgFk4e2GABQBJZAAqZHroiGH2Tl5Ts4AmIymZud19dWpl1aJ1MA2ShcIsMTGZLDZ7PdkE8VsgzPAuFgwN8fghijwwMgAPoQAAeUV4BQAbhBUHYIAhiPwICSoHFzi1nqs-gDsXiCRjgCSyRTiM9JOIgA)

Adding a new member to the `Shape` union, will cause a TypeScript error:

    
    
    ts
    
    interface Triangle {
    
      kind: "triangle";
    
      sideLength: number;
    
    }
    
    ¬†
    
    type Shape = Circle | Square | Triangle;
    
    ¬†
    
    function getArea(shape: Shape) {
    
      switch (shape.kind) {
    
        case "circle":
    
          return Math.PI * shape.radius ** 2;
    
        case "square":
    
          return shape.sideLength ** 2;
    
        default:
    
          const _exhaustiveCheck: never = shape;
    
    Type 'Triangle' is not assignable to type 'never'.2322Type 'Triangle' is not assignable to type 'never'.
    
          return _exhaustiveCheck;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGE9pKAbGgbx1FAGtCATVAESUGzSAIDcHUNHK88AVxSgC8gLYAjGJIC+OfMTJUaAZQCO88tDZSeBfqAGJzlsZM6I8vSABlIBAOZEABaoKhpaOLogoAC0cZTyRHEx+iTQFNSgACrQeOQBLKDsnLb2AkS5+f4sElIeXr4BwaFqmtA6ekQAngAOJkHkfaAAvHQihQA+oGYWVqBTOXkFkJI4pPIElER4cASg-pBEAIJW5AAUiAN9qMZXkACURXUA7nhElEGgF3cAdKWPxU4oEo5EQNCE4zEyCkQOkh3k0D2AFlyMEfgAFACSoAAVKBLoNID8ZHJFLi8Wg3ECQWCHE5ZlCYUCrEQEXsCX0fvUfH5Ap8cRSqZwvBR5EwiNDYZxKLtEERQAB9SAADwGim2ADdILQgpBKFxQpAtdARvi7kLmfDEYqVWq5XgtTq9VwqbptEA)

### [Everyday TypesThe language primitives.](/docs/handbook/2/everyday-
types.html)

### [More on FunctionsLearn about how Functions work in
TypeScript.](/docs/handbook/2/functions.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Narrowing.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(52\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SB![Siarhei Bobryk
\(2\)](https://gravatar.com/avatar/104098b350a8f60748daa830466d024b?s=32&&d=blank)

AB![Andrew Branch
\(2\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

DR![Daniel Rosenwasser
\(2\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

27+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Object Types

In JavaScript, the fundamental way that we group and pass around data is
through objects. In TypeScript, we represent those through _object types_.

As we‚Äôve seen, they can be anonymous:

    
    
    ts
    
    function greet(person: { name: string; age: number }) {
    
      return "Hello " + person.name;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA)

or they can be named by using either an interface:

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
    }
    
    ¬†
    
    function greet(person: Person) {
    
      return "Hello " + person.name;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA)

or a type alias:

    
    
    ts
    
    type Person = {
    
      name: string;
    
      age: number;
    
    };
    
    ¬†
    
    function greet(person: Person) {
    
      return "Hello " + person.name;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA)

In all three examples above, we‚Äôve written functions that take objects that
contain the property `name` (which must be a `string`) and `age` (which must
be a `number`).

## Quick Reference

We have cheat-sheets available for both [`type` and
`interface`](https://www.typescriptlang.org/cheatsheets), if you want a quick
look at the important every-day syntax at a glance.

## Property Modifiers

Each property in an object type can specify a couple of things: the type,
whether the property is optional, and whether the property can be written to.

### Optional Properties

Much of the time, we‚Äôll find ourselves dealing with objects that _might_ have
a property set. In those cases, we can mark those properties as _optional_ by
adding a question mark (`?`) to the end of their names.

    
    
    ts
    
    interface PaintOptions {
    
      shape: Shape;
    
      xPos?: number;
    
      yPos?: number;
    
    }
    
    ¬†
    
    function paintShape(opts: PaintOptions) {
    
      // ...
    
    }
    
    ¬†
    
    const shape = getShape();
    
    paintShape({ shape });
    
    paintShape({ shape, xPos: 100 });
    
    paintShape({ shape, yPos: 100 });
    
    paintShape({ shape, xPos: 100, yPos: 100 });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA)

In this example, both `xPos` and `yPos` are considered optional. We can choose
to provide either of them, so every call above to `paintShape` is valid. All
optionality really says is that if the property _is_ set, it better have a
specific type.

We can also read from those properties - but when we do under
[`strictNullChecks`](/tsconfig#strictNullChecks), TypeScript will tell us
they‚Äôre potentially `undefined`.

    
    
    ts
    
    function paintShape(opts: PaintOptions) {
    
      let xPos = opts.xPos;
    
                       
    
    (property) PaintOptions.xPos?: number | undefined
    
      let yPos = opts.yPos;
    
                       
    
    (property) PaintOptions.yPos?: number | undefined
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA)

In JavaScript, even if the property has never been set, we can still access it
- it‚Äôs just going to give us the value `undefined`. We can just handle
`undefined` specially by checking for it.

    
    
    ts
    
    function paintShape(opts: PaintOptions) {
    
      let xPos = opts.xPos === undefined ? 0 : opts.xPos;
    
           
    
    let xPos: number
    
      let yPos = opts.yPos === undefined ? 0 : opts.yPos;
    
           
    
    let yPos: number
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA)

Note that this pattern of setting defaults for unspecified values is so common
that JavaScript has syntax to support it.

    
    
    ts
    
    function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
    
      console.log("x coordinate at", xPos);
    
                                      
    
    (parameter) xPos: number
    
      console.log("y coordinate at", yPos);
    
                                      
    
    (parameter) yPos: number
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA)

Here we used [a destructuring pattern](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for
`paintShape`‚Äôs parameter, and provided [default
values](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values)
for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present
within the body of `paintShape`, but optional for any callers to `paintShape`.

> Note that there is currently no way to place type annotations within
> destructuring patterns. This is because the following syntax already means
> something different in JavaScript.
>  
>  
>     ts
>  
>     function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {
>  
>       render(shape);
>  
>     Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name
> 'shape'. Did you mean 'Shape'?
>  
>       render(xPos);
>  
>     Cannot find name 'xPos'.2304Cannot find name 'xPos'.
>  
>     }
>  
>
> [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA)
>
> In an object destructuring pattern, `shape: Shape` means ‚Äúgrab the property
> `shape` and redefine it locally as a variable named `Shape`.‚Äù Likewise
> `xPos: number` creates a variable named `number` whose value is based on the
> parameter‚Äôs `xPos`.

### `readonly` Properties

Properties can also be marked as `readonly` for TypeScript. While it won‚Äôt
change any behavior at runtime, a property marked as `readonly` can‚Äôt be
written to during type-checking.

    
    
    ts
    
    interface SomeType {
    
      readonly prop: string;
    
    }
    
    ¬†
    
    function doSomething(obj: SomeType) {
    
      // We can read from 'obj.prop'.
    
      console.log(`prop has the value '${obj.prop}'.`);
    
    ¬†
    
      // But we can't re-assign it.
    
      obj.prop = "hello";
    
    Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA)

Using the `readonly` modifier doesn‚Äôt necessarily imply that a value is
totally immutable - or in other words, that its internal contents can‚Äôt be
changed. It just means the property itself can‚Äôt be re-written to.

    
    
    ts
    
    interface Home {
    
      readonly resident: { name: string; age: number };
    
    }
    
    ¬†
    
    function visitForBirthday(home: Home) {
    
      // We can read and update properties from 'home.resident'.
    
      console.log(`Happy birthday ${home.resident.name}!`);
    
      home.resident.age++;
    
    }
    
    ¬†
    
    function evict(home: Home) {
    
      // But we can't write to the 'resident' property itself on a 'Home'.
    
      home.resident = {
    
    Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.
    
        name: "Victor the Evictor",
    
        age: 42,
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA)

It‚Äôs important to manage expectations of what `readonly` implies. It‚Äôs useful
to signal intent during development time for TypeScript on how an object
should be used. TypeScript doesn‚Äôt factor in whether properties on two types
are `readonly` when checking whether those types are compatible, so `readonly`
properties can also change via aliasing.

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
    }
    
    ¬†
    
    interface ReadonlyPerson {
    
      readonly name: string;
    
      readonly age: number;
    
    }
    
    ¬†
    
    let writablePerson: Person = {
    
      name: "Person McPersonface",
    
      age: 42,
    
    };
    
    ¬†
    
    // works
    
    let readonlyPerson: ReadonlyPerson = writablePerson;
    
    ¬†
    
    console.log(readonlyPerson.age); // prints '42'
    
    writablePerson.age++;
    
    console.log(readonlyPerson.age); // prints '43'
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA)

Using [mapping modifiers](/docs/handbook/2/mapped-types.html#mapping-
modifiers), you can remove `readonly` attributes.

### Index Signatures

Sometimes you don‚Äôt know all the names of a type‚Äôs properties ahead of time,
but you do know the shape of the values.

In those cases you can use an index signature to describe the types of
possible values, for example:

    
    
    ts
    
    interface StringArray {
    
      [index: number]: string;
    
    }
    
    ¬†
    
    const myArray: StringArray = getStringArray();
    
    const secondItem = myArray[1];
    
              
    
    const secondItem: string
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA)

Above, we have a `StringArray` interface which has an index signature. This
index signature states that when a `StringArray` is indexed with a `number`,
it will return a `string`.

Only some types are allowed for index signature properties: `string`,
`number`, `symbol`, template string patterns, and union types consisting only
of these.

It is possible to support multiple types of indexers...

It is possible to support multiple types of indexers. Note that when using
both `number` and `string` indexers, the type returned from a numeric indexer
must be a subtype of the type returned from the string indexer. This is
because when indexing with a `number`, JavaScript will actually convert that
to a `string` before indexing into an object. That means that indexing with
`100` (a `number`) is the same thing as indexing with `"100"` (a `string`), so
the two need to be consistent.

    
    
    ts
    
    interface Animal {
    
      name: string;
    
    }
    
    ¬†
    
    interface Dog extends Animal {
    
      breed: string;
    
    }
    
    ¬†
    
    // Error: indexing with a numeric string might get you a completely separate type of Animal!
    
    interface NotOkay {
    
      [x: number]: Animal;
    
    'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
    
      [x: string]: Dog;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)

While string index signatures are a powerful way to describe the ‚Äúdictionary‚Äù
pattern, they also enforce that all properties match their return type. This
is because a string index declares that `obj.property` is also available as
`obj["property"]`. In the following example, `name`‚Äôs type does not match the
string index‚Äôs type, and the type checker gives an error:

    
    
    ts
    
    interface NumberDictionary {
    
      [index: string]: number;
    
    ¬†
    
      length: number; // ok
    
      name: string;
    
    Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA)

However, properties of different types are acceptable if the index signature
is a union of the property types:

    
    
    ts
    
    interface NumberOrStringDictionary {
    
      [index: string]: number | string;
    
      length: number; // ok, length is a number
    
      name: string; // ok, name is a string
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA)

Finally, you can make index signatures `readonly` in order to prevent
assignment to their indices:

    
    
    ts
    
    interface ReadonlyStringArray {
    
      readonly [index: number]: string;
    
    }
    
    ¬†
    
    let myArray: ReadonlyStringArray = getReadOnlyStringArray();
    
    myArray[2] = "Mallory";
    
    Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA)

You can‚Äôt set `myArray[2]` because the index signature is `readonly`.

## Excess Property Checks

Where and how an object is assigned a type can make a difference in the type
system. One of the key examples of this is in excess property checking, which
validates the object more thoroughly when it is created and assigned to an
object type during creation.

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
    }
    
    ¬†
    
    function createSquare(config: SquareConfig): { color: string; area: number } {
    
      return {
    
        color: config.color || "red",
    
        area: config.width ? config.width * config.width : 20,
    
      };
    
    }
    
    ¬†
    
    let mySquare = createSquare({ colour: "red", width: 100 });
    
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)

Notice the given argument to `createSquare` is spelled _`colour`_ instead of
`color`. In plain JavaScript, this sort of thing fails silently.

You could argue that this program is correctly typed, since the `width`
properties are compatible, there‚Äôs no `color` property present, and the extra
`colour` property is insignificant.

However, TypeScript takes the stance that there‚Äôs probably a bug in this code.
Object literals get special treatment and undergo _excess property checking_
when assigning them to other variables, or passing them as arguments. If an
object literal has any properties that the ‚Äútarget type‚Äù doesn‚Äôt have, you‚Äôll
get an error:

    
    
    ts
    
    let mySquare = createSquare({ colour: "red", width: 100 });
    
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)

Getting around these checks is actually really simple. The easiest method is
to just use a type assertion:

    
    
    ts
    
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)

However, a better approach might be to add a string index signature if you‚Äôre
sure that the object can have some extra properties that are used in some
special way. If `SquareConfig` can have `color` and `width` properties with
the above types, but could _also_ have any number of other properties, then we
could define it like so:

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
      [propName: string]: any;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXyA)

Here we‚Äôre saying that `SquareConfig` can have any number of properties, and
as long as they aren‚Äôt `color` or `width`, their types don‚Äôt matter.

One final way to get around these checks, which might be a bit surprising, is
to assign the object to another variable: Since assigning `squareOptions`
won‚Äôt undergo excess property checks, the compiler won‚Äôt give you an error:

    
    
    ts
    
    let squareOptions = { colour: "red", width: 100 };
    
    let mySquare = createSquare(squareOptions);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXypUYmEAjDAidXHEgZsuAAU9MRkHP44+EQkpACUHBR0jMzGPHz8yJFwHHJK0Mj2lEK4YJhQIEW0tPRMUBwhMQB0NczIAD5tyABEuGJdADRCtFn10WSNohKSyCxJoaQT4lLIAFRzTZPLHABMAAyDtPYOVAD0J8gAtFcImGBXF1QMEGBcWJEA8hoeRJzIALyUJJMMocHoQPr9ERLSQcACMu12BUETxe8hsEVw-28EF8EAxEECnDeuE+3xAnFi-CAA)

The above workaround will work as long as you have a common property between
`squareOptions` and `SquareConfig`. In this example, it was the property
`width`. It will however, fail if the variable does not have any common object
property. For example:

    
    
    ts
    
    let squareOptions = { colour: "red" };
    
    let mySquare = createSquare(squareOptions);
    
    Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)

Keep in mind that for simple code like above, you probably shouldn‚Äôt be trying
to ‚Äúget around‚Äù these checks. For more complex object literals that have
methods and hold state, you might need to keep these techniques in mind, but a
majority of excess property errors are actually bugs.

That means if you‚Äôre running into excess property checking problems for
something like option bags, you might need to revise some of your type
declarations. In this instance, if it‚Äôs okay to pass an object with both a
`color` or `colour` property to `createSquare`, you should fix up the
definition of `SquareConfig` to reflect that.

## Extending Types

It‚Äôs pretty common to have types that might be more specific versions of other
types. For example, we might have a `BasicAddress` type that describes the
fields necessary for sending letters and packages in the U.S.

    
    
    ts
    
    interface BasicAddress {
    
      name?: string;
    
      street: string;
    
      city: string;
    
      country: string;
    
      postalCode: string;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA)

In some situations that‚Äôs enough, but addresses often have a unit number
associated with them if the building at an address has multiple units. We can
then describe an `AddressWithUnit`.

    
    
    ts
    
    interface AddressWithUnit {
    
      name?: string;
    
      unit: string;
    
      street: string;
    
      city: string;
    
      country: string;
    
      postalCode: string;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA)

This does the job, but the downside here is that we had to repeat all the
other fields from `BasicAddress` when our changes were purely additive.
Instead, we can extend the original `BasicAddress` type and just add the new
fields that are unique to `AddressWithUnit`.

    
    
    ts
    
    interface BasicAddress {
    
      name?: string;
    
      street: string;
    
      city: string;
    
      country: string;
    
      postalCode: string;
    
    }
    
    ¬†
    
    interface AddressWithUnit extends BasicAddress {
    
      unit: string;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA)

The `extends` keyword on an `interface` allows us to effectively copy members
from other named types, and add whatever new members we want. This can be
useful for cutting down the amount of type declaration boilerplate we have to
write, and for signaling intent that several different declarations of the
same property might be related. For example, `AddressWithUnit` didn‚Äôt need to
repeat the `street` property, and because `street` originates from
`BasicAddress`, a reader will know that those two types are related in some
way.

`interface`s can also extend from multiple types.

    
    
    ts
    
    interface Colorful {
    
      color: string;
    
    }
    
    ¬†
    
    interface Circle {
    
      radius: number;
    
    }
    
    ¬†
    
    interface ColorfulCircle extends Colorful, Circle {}
    
    ¬†
    
    const cc: ColorfulCircle = {
    
      color: "red",
    
      radius: 42,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA)

## Intersection Types

`interface`s allowed us to build up new types from other types by extending
them. TypeScript provides another construct called _intersection types_ that
is mainly used to combine existing object types.

An intersection type is defined using the `&` operator.

    
    
    ts
    
    interface Colorful {
    
      color: string;
    
    }
    
    interface Circle {
    
      radius: number;
    
    }
    
    ¬†
    
    type ColorfulCircle = Colorful & Circle;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA)

Here, we‚Äôve intersected `Colorful` and `Circle` to produce a new type that has
all the members of `Colorful` _and_ `Circle`.

    
    
    ts
    
    function draw(circle: Colorful & Circle) {
    
      console.log(`Color was ${circle.color}`);
    
      console.log(`Radius was ${circle.radius}`);
    
    }
    
    ¬†
    
    // okay
    
    draw({ color: "blue", radius: 42 });
    
    ¬†
    
    // oops
    
    draw({ color: "red", raidus: 42 });
    
    Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA)

## Interfaces vs. Intersections

We just looked at two ways to combine types which are similar, but are
actually subtly different. With interfaces, we could use an `extends` clause
to extend from other types, and we were able to do something similar with
intersections and name the result with a type alias. The principal difference
between the two is how conflicts are handled, and that difference is typically
one of the main reasons why you‚Äôd pick one over the other between an interface
and a type alias of an intersection type.

If interfaces are defined with the same name, TypeScript will attempt to merge
them if the properties are compatible. If the properties are not compatible
(i.e., they have the same property name but different types), TypeScript will
raise an error.

In the case of intersection types, properties with different types will be
merged automatically. When the type is used later, TypeScript will expect the
property to satisfy both types simultaneously, which may produce unexpected
results.

For example, the following code will throw an error because the properties are
incompatible:

    
    
    ts
    
    interface Person {
    
      name: string;
    
    }
    
    interface Person {
    
      name: number;
    
    }

In contrast, the following code will compile, but it results in a `never`
type:

    
    
    ts
    
    interface Person1 {
    
      name: string;
    
    }
    
    ¬†
    
    interface Person2 {
    
      name: number;
    
    }
    
    ¬†
    
    type Staff = Person1 & Person2
    
    ¬†
    
    declare const staffer: Staff;
    
    staffer.name;
    
             
    
    (property) name: never
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsQEZkDeAUMsiHALYQBcyGYUoA5gNxEC+RRoksiK6KNhAAmQiTKUaZAK4UARtDaciYAJ4AHFAGUwcGDGQBeNJhz4AZKaE4RXACYQEAGzhQUCHPTp6D0Wrr6MGz0QdAAdORUbAD0MaQJpAB6APxAA)

In this case, Staff would require the name property to be both a string and a
number, which results in property being of type `never`.

## Generic Object Types

Let‚Äôs imagine a `Box` type that can contain any value - `string`s, `number`s,
`Giraffe`s, whatever.

    
    
    ts
    
    interface Box {
    
      contents: any;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g)

Right now, the `contents` property is typed as `any`, which works, but can
lead to accidents down the line.

We could instead use `unknown`, but that would mean that in cases where we
already know the type of `contents`, we‚Äôd need to do precautionary checks, or
use error-prone type assertions.

    
    
    ts
    
    interface Box {
    
      contents: unknown;
    
    }
    
    ¬†
    
    let x: Box = {
    
      contents: "hello world",
    
    };
    
    ¬†
    
    // we could check 'x.contents'
    
    if (typeof x.contents === "string") {
    
      console.log(x.contents.toLowerCase());
    
    }
    
    ¬†
    
    // or we could use a type assertion
    
    console.log((x.contents as string).toLowerCase());
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA)

One type safe approach would be to instead scaffold out different `Box` types
for every type of `contents`.

    
    
    ts
    
    interface NumberBox {
    
      contents: number;
    
    }
    
    ¬†
    
    interface StringBox {
    
      contents: string;
    
    }
    
    ¬†
    
    interface BooleanBox {
    
      contents: boolean;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA)

But that means we‚Äôll have to create different functions, or overloads of
functions, to operate on these types.

    
    
    ts
    
    function setContents(box: StringBox, newContents: string): void;
    
    function setContents(box: NumberBox, newContents: number): void;
    
    function setContents(box: BooleanBox, newContents: boolean): void;
    
    function setContents(box: { contents: any }, newContents: any) {
    
      box.contents = newContents;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA)

That‚Äôs a lot of boilerplate. Moreover, we might later need to introduce new
types and overloads. This is frustrating, since our box types and overloads
are all effectively the same.

Instead, we can make a _generic_ `Box` type which declares a _type parameter_.

    
    
    ts
    
    interface Box<Type> {
    
      contents: Type;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)

You might read this as ‚ÄúA `Box` of `Type` is something whose `contents` have
type `Type`‚Äù. Later on, when we refer to `Box`, we have to give a _type
argument_ in place of `Type`.

    
    
    ts
    
    let box: Box<string>;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA)

Think of `Box` as a template for a real type, where `Type` is a placeholder
that will get replaced with some other type. When TypeScript sees
`Box<string>`, it will replace every instance of `Type` in `Box<Type>` with
`string`, and end up working with something like `{ contents: string }`. In
other words, `Box<string>` and our earlier `StringBox` work identically.

    
    
    ts
    
    interface Box<Type> {
    
      contents: Type;
    
    }
    
    interface StringBox {
    
      contents: string;
    
    }
    
    ¬†
    
    let boxA: Box<string> = { contents: "hello" };
    
    boxA.contents;
    
            
    
    (property) Box<string>.contents: string
    
    ¬†
    
    let boxB: StringBox = { contents: "world" };
    
    boxB.contents;
    
            
    
    (property) StringBox.contents: string
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA)

`Box` is reusable in that `Type` can be substituted with anything. That means
that when we need a box for a new type, we don‚Äôt need to declare a new `Box`
type at all (though we certainly could if we wanted to).

    
    
    ts
    
    interface Box<Type> {
    
      contents: Type;
    
    }
    
    ¬†
    
    interface Apple {
    
      // ....
    
    }
    
    ¬†
    
    // Same as '{ contents: Apple }'.
    
    type AppleBox = Box<Apple>;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA)

This also means that we can avoid overloads entirely by instead using [generic
functions](/docs/handbook/2/functions.html#generic-functions).

    
    
    ts
    
    function setContents<Type>(box: Box<Type>, newContents: Type) {
    
      box.contents = newContents;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA)

It is worth noting that type aliases can also be generic. We could have
defined our new `Box<Type>` interface, which was:

    
    
    ts
    
    interface Box<Type> {
    
      contents: Type;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)

by using a type alias instead:

    
    
    ts
    
    type Box<Type> = {
    
      contents: Type;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA)

Since type aliases, unlike interfaces, can describe more than just object
types, we can also use them to write other kinds of generic helper types.

    
    
    ts
    
    type OrNull<Type> = Type | null;
    
    ¬†
    
    type OneOrMany<Type> = Type | Type[];
    
    ¬†
    
    type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;
    
               
    
    type OneOrManyOrNull<Type> = OneOrMany<Type> | null
    
    ¬†
    
    type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
    
                   
    
    type OneOrManyOrNullStrings = OneOrMany<string> | null
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA)

We‚Äôll circle back to type aliases in just a little bit.

### The `Array` Type

Generic object types are often some sort of container type that work
independently of the type of elements they contain. It‚Äôs ideal for data
structures to work this way so that they‚Äôre re-usable across different data
types.

It turns out we‚Äôve been working with a type just like that throughout this
handbook: the `Array` type. Whenever we write out types like `number[]` or
`string[]`, that‚Äôs really just a shorthand for `Array<number>` and
`Array<string>`.

    
    
    ts
    
    function doSomething(value: Array<string>) {
    
      // ...
    
    }
    
    ¬†
    
    let myArray: string[] = ["hello", "world"];
    
    ¬†
    
    // either of these work!
    
    doSomething(myArray);
    
    doSomething(new Array("hello", "world"));
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA)

Much like the `Box` type above, `Array` itself is a generic type.

    
    
    ts
    
    interface Array<Type> {
    
    Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters.2317  
    2428Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters.
    
      /**
    
       * Gets or sets the length of the array.
    
       */
    
      length: number;
    
    ¬†
    
      /**
    
       * Removes the last element from an array and returns it.
    
       */
    
      pop(): Type | undefined;
    
    ¬†
    
      /**
    
       * Appends new elements to an array, and returns the new length of the array.
    
       */
    
      push(...items: Type[]): number;
    
    A rest parameter must be of an array type.2370A rest parameter must be of an array type.
    
    ¬†
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA)

Modern JavaScript also provides other data structures which are generic, like
`Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because
of how `Map`, `Set`, and `Promise` behave, they can work with any sets of
types.

### The `ReadonlyArray` Type

The `ReadonlyArray` is a special type that describes arrays that shouldn‚Äôt be
changed.

    
    
    ts
    
    function doStuff(values: ReadonlyArray<string>) {
    
      // We can read from 'values'...
    
      const copy = values.slice();
    
      console.log(`The first value is ${values[0]}`);
    
    ¬†
    
      // ...but we can't mutate 'values'.
    
      values.push("hello!");
    
    Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA)

Much like the `readonly` modifier for properties, it‚Äôs mainly a tool we can
use for intent. When we see a function that returns `ReadonlyArray`s, it tells
us we‚Äôre not meant to change the contents at all, and when we see a function
that consumes `ReadonlyArray`s, it tells us that we can pass any array into
that function without worrying that it will change its contents.

Unlike `Array`, there isn‚Äôt a `ReadonlyArray` constructor that we can use.

    
    
    ts
    
    new ReadonlyArray("red", "green", "blue");
    
    'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA)

Instead, we can assign regular `Array`s to `ReadonlyArray`s.

    
    
    ts
    
    const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA)

Just as TypeScript provides a shorthand syntax for `Array<Type>` with
`Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with
`readonly Type[]`.

    
    
    ts
    
    function doStuff(values: readonly string[]) {
    
      // We can read from 'values'...
    
      const copy = values.slice();
    
      console.log(`The first value is ${values[0]}`);
    
    ¬†
    
      // ...but we can't mutate 'values'.
    
      values.push("hello!");
    
    Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA)

One last thing to note is that unlike the `readonly` property modifier,
assignability isn‚Äôt bidirectional between regular `Array`s and
`ReadonlyArray`s.

    
    
    ts
    
    let x: readonly string[] = [];
    
    let y: string[] = [];
    
    ¬†
    
    x = y;
    
    y = x;
    
    The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA)

### Tuple Types

A _tuple type_ is another sort of `Array` type that knows exactly how many
elements it contains, and exactly which types it contains at specific
positions.

    
    
    ts
    
    type StringNumberPair = [string, number];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA)

Here, `StringNumberPair` is a tuple type of `string` and `number`. Like
`ReadonlyArray`, it has no representation at runtime, but is significant to
TypeScript. To the type system, `StringNumberPair` describes arrays whose `0`
index contains a `string` and whose `1` index contains a `number`.

    
    
    ts
    
    function doSomething(pair: [string, number]) {
    
      const a = pair[0];
    
           
    
    const a: string
    
      const b = pair[1];
    
           
    
    const b: number
    
      // ...
    
    }
    
    ¬†
    
    doSomething(["hello", 42]);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA)

If we try to index past the number of elements, we‚Äôll get an error.

    
    
    ts
    
    function doSomething(pair: [string, number]) {
    
      // ...
    
    ¬†
    
      const c = pair[2];
    
    Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA)

We can also [destructure tuples](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)
using JavaScript‚Äôs array destructuring.

    
    
    ts
    
    function doSomething(stringHash: [string, number]) {
    
      const [inputString, hash] = stringHash;
    
    ¬†
    
      console.log(inputString);
    
                      
    
    const inputString: string
    
    ¬†
    
      console.log(hash);
    
                   
    
    const hash: number
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA)

> Tuple types are useful in heavily convention-based APIs, where each
> element‚Äôs meaning is ‚Äúobvious‚Äù. This gives us flexibility in whatever we
> want to name our variables when we destructure them. In the above example,
> we were able to name elements `0` and `1` to whatever we wanted.
>
> However, since not every user holds the same view of what‚Äôs obvious, it may
> be worth reconsidering whether using objects with descriptive property names
> may be better for your API.

Other than those length checks, simple tuple types like these are equivalent
to types which are versions of `Array`s that declare properties for specific
indexes, and that declare `length` with a numeric literal type.

    
    
    ts
    
    interface StringNumberPair {
    
      // specialized properties
    
      length: 2;
    
      0: string;
    
      1: number;
    
    ¬†
    
      // Other 'Array<string | number>' members...
    
      slice(start?: number, end?: number): Array<string | number>;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA)

Another thing you may be interested in is that tuples can have optional
properties by writing out a question mark (`?` after an element‚Äôs type).
Optional tuple elements can only come at the end, and also affect the type of
`length`.

    
    
    ts
    
    type Either2dOr3d = [number, number, number?];
    
    ¬†
    
    function setCoordinate(coord: Either2dOr3d) {
    
      const [x, y, z] = coord;
    
                  
    
    const z: number | undefined
    
    ¬†
    
      console.log(`Provided coordinates had ${coord.length} dimensions`);
    
                                                      
    
    (property) length: 2 | 3
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA)

Tuples can also have rest elements, which have to be an array/tuple type.

    
    
    ts
    
    type StringNumberBooleans = [string, number, ...boolean[]];
    
    type StringBooleansNumber = [string, ...boolean[], number];
    
    type BooleansStringNumber = [...boolean[], string, number];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA)

  * `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.
  * `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.
  * `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.

A tuple with a rest element has no set ‚Äúlength‚Äù - it only has a set of well-
known elements in different positions.

    
    
    ts
    
    const a: StringNumberBooleans = ["hello", 1];
    
    const b: StringNumberBooleans = ["beautiful", 2, true];
    
    const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA)

Why might optional and rest elements be useful? Well, it allows TypeScript to
correspond tuples with parameter lists. Tuples types can be used in [rest
parameters and arguments](/docs/handbook/2/functions.html#rest-parameters-and-
arguments), so that the following:

    
    
    ts
    
    function readButtonInput(...args: [string, number, ...boolean[]]) {
    
      const [name, version, ...input] = args;
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA)

is basically equivalent to:

    
    
    ts
    
    function readButtonInput(name: string, version: number, ...input: boolean[]) {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA)

This is handy when you want to take a variable number of arguments with a rest
parameter, and you need a minimum number of elements, but you don‚Äôt want to
introduce intermediate variables.

### `readonly` Tuple Types

One final note about tuple types - tuple types have `readonly` variants, and
can be specified by sticking a `readonly` modifier in front of them - just
like with array shorthand syntax.

    
    
    ts
    
    function doSomething(pair: readonly [string, number]) {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA)

As you might expect, writing to any property of a `readonly` tuple isn‚Äôt
allowed in TypeScript.

    
    
    ts
    
    function doSomething(pair: readonly [string, number]) {
    
      pair[0] = "hello!";
    
    Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA)

Tuples tend to be created and left un-modified in most code, so annotating
types as `readonly` tuples when possible is a good default. This is also
important given that array literals with `const` assertions will be inferred
with `readonly` tuple types.

    
    
    ts
    
    let point = [3, 4] as const;
    
    ¬†
    
    function distanceFromOrigin([x, y]: [number, number]) {
    
      return Math.sqrt(x ** 2 + y ** 2);
    
    }
    
    ¬†
    
    distanceFromOrigin(point);
    
    Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
      The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
      The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA)

Here, `distanceFromOrigin` never modifies its elements, but expects a mutable
tuple. Since `point`‚Äôs type was inferred as `readonly [3, 4]`, it won‚Äôt be
compatible with `[number, number]` since that type can‚Äôt guarantee `point`‚Äôs
elements won‚Äôt be mutated.

### [More on FunctionsLearn about how Functions work in
TypeScript.](/docs/handbook/2/functions.html)

### [Creating Types from TypesAn overview of the ways in which you can create
more types from existing types.](/docs/handbook/2/types-from-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Object Types.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(52\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

3![38elements
\(2\)](https://gravatar.com/avatar/373add4e82c35904739437d2a8b2ddf2?s=32&&d=blank)

BR![Bruce Robertson
\(2\)](https://gravatar.com/avatar/a7ed9d86c35f631214c8d6854264bcba?s=32&&d=blank)

AR![Alan Rempel
\(2\)](https://gravatar.com/avatar/0588c3dbf0385c98145224b88a6fe49b?s=32&&d=blank)

21+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Template Literal Types

Template literal types build on [string literal
types](/docs/handbook/2/everyday-types.html#literal-types), and have the
ability to expand into many strings via unions.

They have the same syntax as [template literal strings in
JavaScript](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Template_literals), but are used in type
positions. When used with concrete literal types, a template literal produces
a new string literal type by concatenating the contents.

    
    
    ts
    
    type World = "world";
    
    ¬†
    
    type Greeting = `hello ${World}`;
    
            
    
    type Greeting = "hello world"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)

When a union is used in the interpolated position, the type is the set of
every possible string literal that could be represented by each union member:

    
    
    ts
    
    type EmailLocaleIDs = "welcome_email" | "email_heading";
    
    type FooterLocaleIDs = "footer_title" | "footer_sendoff";
    
    ¬†
    
    type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
    
              
    
    type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnzF4aAEEUdGxcAhJyKAADABIAb3h+XVCDblVHHRD9EgBfZiRRSIUAeiKoMoA9AH4gA)

For each interpolated position in the template literal, the unions are cross
multiplied:

    
    
    ts
    
    type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
    
    type Lang = "en" | "ja" | "pt";
    
    ¬†
    
    type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
    
                
    
    type LocaleMessageIDs = "en_welcome_email_id" | "en_email_heading_id" | "en_footer_title_id" | "en_footer_sendoff_id" | "ja_welcome_email_id" | "ja_email_heading_id" | "ja_footer_title_id" | "ja_footer_sendoff_id" | "pt_welcome_email_id" | "pt_email_heading_id" | "pt_footer_title_id" | "pt_footer_sendoff_id"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnyA9D6gAtEFYAK7AQQGK4NAAgijo2LgEJORQAAYAJADe8Py6SQbcqo46ifokAL7MSKJpCkrQaAjSqZSudlQAVggdlGDA3lHK+XgAshDExAhSyYbp2U3SVdlxCXqzFXW+-lBQAHoA-EA)

We generally recommend that people use ahead-of-time generation for large
string unions, but this is useful in smaller cases.

### String Unions in Types

The power in template literals comes when defining a new string based on
information inside a type.

Consider the case where a function (`makeWatchedObject`) adds a new function
called `on()` to a passed object. In JavaScript, its call might look like:
`makeWatchedObject(baseObject)`. We can imagine the base object as looking
like:

    
    
    ts
    
    const passedObject = {
    
      firstName: "Saoirse",
    
      lastName: "Ronan",
    
      age: 26,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AA4CGKKApgCYDyARgFZkb4C8oA3mqKAGYCWquAHJEAtmQBcoAEQBlItH7kpAGk6gANiSGiJ0gErYikFWqIBzXQCYAbKoC+AbiA)

The `on` function that will be added to the base object expects two arguments,
an `eventName` (a `string`) and a `callback` (a `function`).

The `eventName` should be of the form `attributeInThePassedObject +
"Changed"`; thus, `firstNameChanged` as derived from the attribute `firstName`
in the base object.

The `callback` function, when called:

  * Should be passed a value of the type associated with the name `attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument
  * Should have `void` return type (for simplicity of demonstration)

The naive function signature of `on()` might thus be: `on(eventName: string,
callback: (newValue: any) => void)`. However, in the preceding description, we
identified important type constraints that we‚Äôd like to document in our code.
Template Literal types let us bring these constraints into our code.

    
    
    ts
    
    const person = makeWatchedObject({
    
      firstName: "Saoirse",
    
      lastName: "Ronan",
    
      age: 26,
    
    });
    
    ¬†
    
    // makeWatchedObject has added `on` to the anonymous Object
    
    ¬†
    
    person.on("firstNameChanged", (newValue) => {
    
      console.log(`firstName was changed to ${newValue}!`);
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagBmArpDgC4CW0koAtgQNZYDqB1OAFlhgDyAIwBWuagApoYgFygCkAJ4BKeYqUBuNCFABaAznLUDetDgYpqoAA5ZUDUAF5mbTtz4CR4mpIDeaKBktKjUAHIETFjyAEQAygTQIShYMQA0gaCEVhFRsQBKDIrpmQQA5tGgAEwAbBkAviraOmAs7Fw8-EJiEqC8BCgKGNgYoAAGDGOg1NDT-AowykzQ5IPeEmhodg6QAHQMkjGkyeGRWADC-ZAVGOmgkpBYAO4AagR45FgqzgB8oAFBCyQFDQPBYXZ4aBlSRjY6hXIkJ4DUB8RQ3aazAAkfker3en3qAEIxk00I1NEA)

Notice that `on` listens on the event `"firstNameChanged"`, not just
`"firstName"`. Our naive specification of `on()` could be made more robust if
we were to ensure that the set of eligible event names was constrained by the
union of attribute names in the watched object with ‚ÄúChanged‚Äù added at the
end. While we are comfortable with doing such a calculation in JavaScript i.e.
`Object.keys(passedObject).map(x => `${x}Changed`)`, template literals _inside
the type system_ provide a similar approach to string manipulation:

    
    
    ts
    
    type PropEventSource<Type> = {
    
        on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;
    
    };
    
    ¬†
    
    /// Create a "watched object" with an `on` method
    
    /// so that you can watch for changes to properties.
    
    declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGAFBOlgHIBDALYQAXFAAGAEgYBnYHACWGAOZQAZFADWEEAgBmUCpAC+AYQAWA1RAAmEgDRRCAgDauARgMJbxnDBAA7gBqbnhiUNYgAJR0NKgIirbR4glJANxMJplMAPT5UGZwEALA0AJQAESBpYQWduweAFYQhMCVUIGKwBaRGJIcElAiPQi2eQWyCFA9pVB6eM7WnbW9+ghwzlY2sjPTYIiQcMCKELIAdEy2ra4CxVD6eBhtihzDAjoA6qt2APLNrWA5EoVE4CGa4mMEBSRkoGlghzQmBw+CIpChVHSQA)

With this, we can build something that errors when given the wrong property:

    
    
    ts
    
    const person = makeWatchedObject({
    
      firstName: "Saoirse",
    
      lastName: "Ronan",
    
      age: 26
    
    });
    
    ¬†
    
    person.on("firstNameChanged", () => {});
    
    ¬†
    
    // Prevent easy human error (using the key instead of the event name)
    
    person.on("firstName", () => {});
    
    Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.
    
    ¬†
    
    // It's typo-resistant
    
    person.on("frstNameChanged", () => {});
    
    Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKqUgA+UAF5QAbzyhZoOIwAUkBswByAQwC2kVAAMAJJMQFoAS0YBzUADJQAa0hE4AM1CCyAXwDCACw1WkAAmegA0oFwaADZRAEYaXPaoioyQAO4AatHsuqABRACU4qJ0cGZBBail5QDceJ51eEGQXFEa0OQu7IxcBGYKoFoajgDqGgRcvsEA8rEAVi0EAsKKcPOo-JXutpTU9EysHNx8-MJ1IKAAtNdc7ATXl3hcCiagZEgDEkOj45Mz84tFNJZC4zEgCJodKgAEQsDRlJCQaGhGSgNomSG5aEAJQUAWRqI0llyaAAbPUCo13ogFAA6BSKaGg8GYvwBYlBZGgRRFMSiSSeSl4PAXKgqA6gSAaRBEUC+dhDRiS2AIbnsRAWawEKYOJygCwmKVBeRubXkcXMUCMbSQAp4al0hlMsEYm1cnnFKSCxoXACSBAA5IhQMQSHBLh0NSYAgR7TAaYx6UomSybWzApzwh6+V7KUA)

### Inference with Template Literals

Notice that we did not benefit from all the information provided in the
original passed object. Given change of a `firstName` (i.e. a
`firstNameChanged` event), we should expect that the callback will receive an
argument of type `string`. Similarly, the callback for a change to `age`
should receive a `number` argument. We‚Äôre naively using `any` to type the
`callback`‚Äôs argument. Again, template literal types make it possible to
ensure an attribute‚Äôs data type will be the same type as that attribute‚Äôs
callback‚Äôs first argument.

The key insight that makes this possible is this: we can use a function with a
generic such that:

  1. The literal used in the first argument is captured as a literal type
  2. That literal type can be validated as being in the union of valid attributes in the generic
  3. The type of the validated attribute can be looked up in the generic‚Äôs structure using Indexed Access
  4. This typing information can _then_ be applied to ensure the argument to the callback function is of the same type

    
    
    ts
    
    type PropEventSource<Type> = {
    
        on<Key extends string & keyof Type>
    
            (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;
    
    };
    
    ¬†
    
    declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;
    
    ¬†
    
    const person = makeWatchedObject({
    
      firstName: "Saoirse",
    
      lastName: "Ronan",
    
      age: 26
    
    });
    
    ¬†
    
    person.on("firstNameChanged", newName => {
    
                                    
    
    (parameter) newName: string
    
        console.log(`new name is ${newName.toUpperCase()}`);
    
    });
    
    ¬†
    
    person.on("ageChanged", newAge => {
    
                              
    
    (parameter) newAge: number
    
        if (newAge < 0) {
    
            console.warn("warning! negative age");
    
        }
    
    })
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGJA0hCFBAA9gmACYBnKGOBwAlhgDmUAGRQA1rwQAzKBUhUWbQwAoI6LADkAhgFsIALigADACQMeIAL4BhABaWFECKOADRQhJYANhEARpaEqg5GGBAA7gBqkXj2OpQA2u4AugCUdDSoCDIiRQ7llQDcTB4NTCIQhBGWcNCaeBiEwDIcUNaW6gDqlsCEPoEA8tEAVm3A5JRURgiLDroQ1TmQyrCIKGY4+ESkO1TNhBxSUJBwYkP0I+OT03OLy0bMrJoyJ7AKy2BwAImwlgqTwgYOCBg6UhB2TBACUOP44QZLPJsgAmABsjSKzUezwwADoOEYwQCgcjfP5cSI4VBkilkaVGAZWAB6XmGQVC4WsAB6AH4eWE7ggIhAKREEPIjI52WybNAZBJXOzkRTgAgAKpgR5eSxiCBGIoeRwk4mkiBPDhUjA0nEQRkBFmhdkAQVxXL+bH5ItDUAlUpk2iSqX90BIUAADCUg0LbhhnnKKSlOq6wTm4Bg5PIAIRsiDySYydBQd1gu2GDzEoA)

Here we made `on` into a generic method.

When a user calls with the string `"firstNameChanged"`, TypeScript will try to
infer the right type for `Key`. To do that, it will match `Key` against the
content before `"Changed"` and infer the string `"firstName"`. Once TypeScript
figures that out, the `on` method can fetch the type of `firstName` on the
original object, which is `string` in this case. Similarly, when called with
`"ageChanged"`, TypeScript finds the type for the property `age` which is
`number`.

Inference can be combined in different ways, often to deconstruct strings, and
reconstruct them in different ways.

## Intrinsic String Manipulation Types

To help with string manipulation, TypeScript includes a set of types which can
be used in string manipulation. These types come built-in to the compiler for
performance and can‚Äôt be found in the `.d.ts` files included with TypeScript.

### `Uppercase<StringType>`

Converts each character in the string to the uppercase version.

##### Example

    
    
    ts
    
    type Greeting = "Hello, world"
    
    type ShoutyGreeting = Uppercase<Greeting>
    
               
    
    type ShoutyGreeting = "HELLO, WORLD"
    
    ¬†
    
    type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`
    
    type MainID = ASCIICacheKey<"my_app">
    
           
    
    type MainID = "ID-MY_APP"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigGUALUgV1HkQoM2KAFUwkOAGMAhgGcIAHgFI06AHxMA9Fqh6AegH4mLcNACC7AMIBJG1ZlTOEANIQQi9sDhQIAD2AIVHo5KDlvNXURAAMbABEAWgASAG9xSVkFT291AF9o0zYAWRk0eJFLW3tHZzcPXABbEAB9GQlcTR09KCMgA)

### `Lowercase<StringType>`

Converts each character in the string to the lowercase equivalent.

##### Example

    
    
    ts
    
    type Greeting = "Hello, world"
    
    type QuietGreeting = Lowercase<Greeting>
    
              
    
    type QuietGreeting = "hello, world"
    
    ¬†
    
    type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`
    
    type MainID = ASCIICacheKey<"MY_APP">
    
           
    
    type MainID = "id-my_app"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigEUBXZJeRFDNigAZUlQhwAxgEMAzhAA8fJGnQA+JgHpNUXQD0A-ExbhoAQQDKAYQCSNq9MkALCAGkIIBReBwoEAB7AEKj0slCyPqpqQgAGyPQAtAAkAN6i4lJyit5wagC+MSZsALLSaDYAIkKWtvaOLu6euMUAmgD6ZgAKnbga2rpQhkA)

### `Capitalize<StringType>`

Converts the first character in the string to an uppercase equivalent.

##### Example

    
    
    ts
    
    type LowercaseGreeting = "hello, world";
    
    type Greeting = Capitalize<LowercaseGreeting>;
    
            
    
    type Greeting = "Hello, world"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAMg9gdwgJwMYEMDOEDiyITACWAdgOZQC8UARABYQA2jcANFAnMowCY0DcAKFCQoeAsXJUoAYXRgiwdIyIAvCAB54SNFlz5CpMgD4hAejNQrAPQD8QA)

### `Uncapitalize<StringType>`

Converts the first character in the string to a lowercase equivalent.

##### Example

    
    
    ts
    
    type UppercaseGreeting = "HELLO WORLD";
    
    type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;
    
                  
    
    type UncomfortableGreeting = "hELLO WORLD"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAqmkCcDGBDAzhA4giFgEsA7AcygF4oAiACQFEAZegeSgHUmAlegEUoG4AUKEixCSAPYBbAGbiEwFACMANlhx4ipCjDEow+BcvwAvCAB44iVBmy4CJAHyCA9M6juAegH4gA)

Technical details on the intrinsic string manipulation types

The code, as of TypeScript 4.1, for these intrinsic functions uses the
JavaScript string runtime functions directly for manipulation and are not
locale aware.

`

    
    
    function applyStringMapping(symbol: Symbol, str: string) {
        switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
            case IntrinsicTypeKind.Uppercase: return str.toUpperCase();
            case IntrinsicTypeKind.Lowercase: return str.toLowerCase();
            case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);
            case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);
        }
        return str;
    }

`

### [Mapped TypesGenerating types by re-using an existing
type.](/docs/handbook/2/mapped-types.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Template Literal Types.md) ‚ù§

Contributors to this page:  

SH![Steven Harms
\(6\)](https://gravatar.com/avatar/7825651fa53738f194d4e3267c32c959?s=32&&d=blank)

OT![Orta Therox
\(4\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SGH![Steven G. Harms
\(3\)](https://gravatar.com/avatar/6a070b2c7e547cc942b8b8b094fd221a?s=32&&d=blank)

SP![Seol Park
\(1\)](https://gravatar.com/avatar/289457fe688256dafe499e0a38e065d0?s=32&&d=blank)

P![Penchy
\(1\)](https://gravatar.com/avatar/da88fb30ba7d91f374abacc8ca7716dd?s=32&&d=blank)

6+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Typeof Type Operator

## The `typeof` type operator

JavaScript already has a `typeof` operator you can use in an _expression_
context:

    
    
    ts
    
    // Prints "string"
    
    console.log(typeof "Hello world");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOoBEj41gcxQKAMYD2sihANgKYB0ZhWAFPAJ4AOFhAZqgBIVm2gA7oUhkAJigCUAbiA)

TypeScript adds a `typeof` operator you can use in a _type_ context to refer
to the _type_ of a variable or property:

    
    
    ts
    
    let s = "hello";
    
    let n: typeof s;
    
       
    
    let n: string
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECIAWJjAPYINwChSQDsAuCMATwAcR0AzaXAegYggD0B+IA)

This isn‚Äôt very useful for basic types, but combined with other type
operators, you can use `typeof` to conveniently express many patterns. For an
example, let‚Äôs start by looking at the predefined type `ReturnType<T>`. It
takes a _function type_ and produces its return type:

    
    
    ts
    
    type Predicate = (x: unknown) => boolean;
    
    type K = ReturnType<Predicate>;
    
        
    
    type K = boolean
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgThAJgSwMYENjQLxQBQAeAXFAK4B2A1uQPYDu5AlFNgHxQBGNNANhOuQDcAKFCQoAaRZQAShGCk45ACrgIAHnhI0mCKxEB6A1BMA9APxA)

If we try to use `ReturnType` on a function name, we see an instructive error:

    
    
    ts
    
    function f() {
    
      return { x: 10, y: 3 };
    
    }
    
    type P = ReturnType<f>;
    
    'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?2749'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBOAUAGYCuAdgMYAuAlnCaAQBQCUoA3nqKNJBUdHa1AAPVAEYADABpQAT1QBmUAF8A3HiV4KMgA6RQABVABeUACUefEgBUdkADwEAfCqA)

Remember that _values_ and _types_ aren‚Äôt the same thing. To refer to the
_type_ that the _value`f`_ has, we use `typeof`:

    
    
    ts
    
    function f() {
    
      return { x: 10, y: 3 };
    
    }
    
    type P = ReturnType<typeof f>;
    
        
    
    type P = {
        x: number;
        y: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFASkQbwFCMQJwFMoR8lNEAPALkQEYAGAGkQE9aBmRAXwG5tu2KKwAOhRAAVEAXkQAlYqTAAVUYQA8wsXGDIAfPwD0hvIgB6AfiA)

### Limitations

TypeScript intentionally limits the sorts of expressions you can use `typeof`
on.

Specifically, it‚Äôs only legal to use `typeof` on identifiers (i.e. variable
names) or their properties. This helps avoid the confusing trap of writing
code you think is executing, but isn‚Äôt:

    
    
    ts
    
    // Meant to use = ReturnType<typeof msgbox>
    
    let shouldContinue: typeof msgbox("Are you sure you want to continue?");
    
    ',' expected.1005',' expected.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQATSAYwBsBDaSUIuAO0QBdQBbRAcwCM4APVACgAO8ZgIapG0AJa02ASlABeAHygucEpDK0A3LhCgGATwFVWnHotBbDu-QFoHRAK4MHdvWACym2kwZxQJ0QqBVAAJUgGJ2haABVjSAAeIxM4ADMWdi5uJVwNJkQACzgnEnwAYToGaSdIVBTIdMzzbj4AIgBBSlBDEtBEaKpep1AAdy0-AJpfGsgAfjbZbSA)

### [Keyof Type OperatorUsing the keyof operator in type
contexts.](/docs/handbook/2/keyof-types.html)

### [Indexed Access TypesUsing Type['a'] syntax to access a subset of a
type.](/docs/handbook/2/indexed-access-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Typeof Type Operator.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(4\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JL![Jimmy Liao
\(1\)](https://gravatar.com/avatar/1437294b03e75e326f470117f2ad85f3?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Creating Types from Types

TypeScript‚Äôs type system is very powerful because it allows expressing types
_in terms of other types_.

The simplest form of this idea is generics. Additionally, we have a wide
variety of _type operators_ available to use. It‚Äôs also possible to express
types in terms of _values_ that we already have.

By combining various type operators, we can express complex operations and
values in a succinct, maintainable way. In this section we‚Äôll cover ways to
express a new type in terms of an existing type or value.

  * [Generics](/docs/handbook/2/generics.html) \- Types which take parameters
  * [Keyof Type Operator](/docs/handbook/2/keyof-types.html) \- Using the `keyof` operator to create new types
  * [Typeof Type Operator](/docs/handbook/2/typeof-types.html) \- Using the `typeof` operator to create new types
  * [Indexed Access Types](/docs/handbook/2/indexed-access-types.html) \- Using `Type['a']` syntax to access a subset of a type
  * [Conditional Types](/docs/handbook/2/conditional-types.html) \- Types which act like if statements in the type system
  * [Mapped Types](/docs/handbook/2/mapped-types.html) \- Creating types by mapping each property in an existing type
  * [Template Literal Types](/docs/handbook/2/template-literal-types.html) \- Mapped types which change properties via template literal strings

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [GenericsTypes which take parameters](/docs/handbook/2/generics.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/_Creating Types from Types.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(6\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

GF![Graham Fisher
\(1\)](https://gravatar.com/avatar/61aa376dd43357c37995cdfae5a58840?s=32&&d=blank)

AP![Alexander Pepper
\(1\)](https://gravatar.com/avatar/45b31509c11165be5fac1dd17b76accf?s=32&&d=blank)

PC![Pradeep Chauhan
\(1\)](https://gravatar.com/avatar/250e588eadd076bcd7f2af5970581ed2?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# ASP.NET Core

## Install ASP.NET Core and TypeScript

First, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet) if you
need it. This quick-start guide requires Visual Studio 2015 or 2017.

Next, if your version of Visual Studio does not already have the latest
TypeScript, you can [install
it](https://www.typescriptlang.org/index.html#download-links).

## Create a new project

  1. Choose **File**
  2. Choose **New Project** (Ctrl + Shift + N)
  3. Search for **.NET Core** in the project search bar
  4. Select **ASP.NET Core Web Application** and press the _Next_ button

![Visual Studio Project Window
Screenshot](/images/tutorials/aspnet/createwebapp.png)

  5. Name your project and solution. After select the _Create_ button

![Visual Studio New Project Window
Screenshot](/images/tutorials/aspnet/namewebapp.png)

  6. In the last window, select the **Empty** template and press the _Create_ button

![Visual Studio Web Application
Screenshot](/images/tutorials/aspnet/emptytemplate.png)

Run the application and make sure that it works.

![A screenshot of Edge showing "Hello World" as
success](/images/tutorials/aspnet/workingsite.png)

### Set up the server

Open **Dependencies > Manage NuGet Packages > Browse.** Search and install
`Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:

![The Visual Studio search for
Nuget](/images/tutorials/aspnet/downloaddependency.png)

Open up your `Startup.cs` file and edit your `Configure` function to look like
this:

    
    
    public void Configure(IApplicationBuilder app, IHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
    
        app.UseDefaultFiles();
        app.UseStaticFiles();
    }

You may need to restart VS for the red squiggly lines below `UseDefaultFiles`
and `UseStaticFiles` to disappear.

## Add TypeScript

Next we will add a new folder and call it `scripts`.

![The Path of "Add" then "New Folder" in Visual Studio from a Web
Project](/images/tutorials/aspnet/newfolder.png)

![](/images/tutorials/aspnet/scripts.png)

## Add TypeScript code

Right click on `scripts` and click **New Item**. Then choose **TypeScript
File** and name the file `app.ts`

![A highlight of the new folder](/images/tutorials/aspnet/tsfile.png)

### Add example code

Add the following code to the `app.ts` file.

    
    
    ts
    
    function sayHello() {
    
      const compiler = (document.getElementById("compiler") as HTMLInputElement)
    
        .value;
    
      const framework = (document.getElementById("framework") as HTMLInputElement)
    
        .value;
    
      return `Hello from ${compiler} and ${framework}!`;
    
    }

## Set up the build

_Configure the TypeScript compiler_

First we need to tell TypeScript how to build. Right click on `scripts` and
click **New Item**. Then choose **TypeScript Configuration File** and use the
default name of `tsconfig.json`

![A screenshot showing the new file dialogue with TypeScript JSON Config
selected](/images/tutorials/aspnet/tsconfig.png)

Replace the contents of the `tsconfig.json` file with:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noEmitOnError](https://www.typescriptlang.org/tsconfig#noEmitOnError)": true,
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es6"
    
      },
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["./app.ts"],
    
      "compileOnSave": true
    
    }

  * [`noEmitOnError`](/tsconfig#noEmitOnError) : Do not emit outputs if any errors were reported.
  * [`noImplicitAny`](/tsconfig#noImplicitAny) : Raise error on expressions and declarations with an implied `any` type.
  * [`sourceMap`](/tsconfig#sourceMap) : Generates corresponding `.map` file.
  * [`target`](/tsconfig#target) : Specify ECMAScript target version.

Note: `"ESNext"` targets latest supported

[`noImplicitAny`](/tsconfig#noImplicitAny) is good idea whenever you‚Äôre
writing new code ‚Äî you can make sure that you don‚Äôt write any untyped code by
mistake. `"compileOnSave"` makes it easy to update your code in a running web
app.

#### _Set up NPM_

We need to setup NPM so that JavaScript packages can be downloaded. Right
click on the project and select **New Item**. Then choose **NPM Configuration
File** and use the default name of `package.json`.

![Screenshot of VS showing new file dialog with 'npm configuration file'
selected](/images/tutorials/aspnet/packagejson.png)

Inside the `"devDependencies"` section of the `package.json` file, add _gulp_
and _del_

    
    
    "devDependencies": {
    
        "gulp": "4.0.2",
    
        "del": "5.1.0"
    
    }

Visual Studio should start installing gulp and del as soon as you save the
file. If not, right-click package.json and then Restore Packages.

After you should see an `npm` folder in your solution explorer

![Screenshot of VS showing npm folder](/images/tutorials/aspnet/npm.png)

#### _Set up gulp_

Right click on the project and click **New Item**. Then choose **JavaScript
File** and use the name of `gulpfile.js`

    
    
    js
    
    /// <binding AfterBuild='default' Clean='clean' />
    
    /*
    
    This file is the main entry point for defining Gulp tasks and using Gulp plugins.
    
    Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007
    
    */
    
    var gulp = require("gulp");
    
    var del = require("del");
    
    var paths = {
    
      scripts: ["scripts/**/*.js", "scripts/**/*.ts", "scripts/**/*.map"],
    
    };
    
    gulp.task("clean", function () {
    
      return del(["wwwroot/scripts/**/*"]);
    
    });
    
    gulp.task("default", function (done) {
    
        gulp.src(paths.scripts).pipe(gulp.dest("wwwroot/scripts"));
    
        done();
    
    });

The first line tells Visual Studio to run the task ‚Äòdefault‚Äô after the build
finishes. It will also run the ‚Äòclean‚Äô task when you ask Visual Studio to
clean the build.

Now right-click on `gulpfile.js` and click Task Runner Explorer.

![Screenshot of right clicking on the "Gulpfile.js" with 'Task Runner
Explorer' selected](/images/tutorials/aspnet/taskrunner.png)

If ‚Äòdefault‚Äô and ‚Äòclean‚Äô tasks don‚Äôt show up, refresh the explorer:

![Screenshot of task explorer with "Gulpfile.js" in
it](/images/tutorials/aspnet/taskrunnerrefresh.png)

## Write a HTML page

Right click on the `wwwroot` folder (if you don‚Äôt see the folder try building
the project) and add a New Item named `index.html` inside. Use the following
code for `index.html`

    
    
    <!DOCTYPE html>
    
    <html>
    
    <head>
    
        <meta charset="utf-8" />
    
        <script src="scripts/app.js"></script>
    
        <title></title>
    
    </head>
    
    <body>
    
        <div id="message"></div>
    
        <div>
    
            Compiler: <input id="compiler" value="TypeScript" onkeyup="document.getElementById('message').innerText = sayHello()" /><br />
    
            Framework: <input id="framework" value="ASP.NET" onkeyup="document.getElementById('message').innerText = sayHello()" />
    
        </div>
    
    </body>
    
    </html>

## Test

  1. Run the project
  2. As you type on the boxes you should see the message appear/change!

![A GIF of Edge showing the code you have just
wrote](https://media.giphy.com/media/U3mTibRAx34DG3zhAN/giphy.gif)

## Debug

  1. In Edge, press F12 and click the Debugger tab.
  2. Look in the first localhost folder, then scripts/app.ts
  3. Put a breakpoint on the line with return.
  4. Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.

![An image showing the debugger running the code you have just
wrote](/images/tutorials/aspnet/debugger.png)

Congrats you‚Äôve built your own .NET Core project with a TypeScript frontend.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/ASP.NET Core.md) ‚ù§

Contributors to this page:  

BK![Bowden Kelly
\(56\)](https://gravatar.com/avatar/e87ecf3e2da8b667dd3a8005ac610d4a?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

GC![Gabrielle Crevecoeur
\(11\)](https://gravatar.com/avatar/1d1c3d0dff776fedc6a4f10cd7824314?s=32&&d=blank)

DR![Daniel Rosenwasser
\(3\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

LZ![Limin Zhu
\(2\)](https://gravatar.com/avatar/6ff09ff871238f23c607356e5eee9dd1?s=32&&d=blank)

14+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Using Babel with TypeScript

## Babel vs `tsc` for TypeScript

When making a modern JavaScript project, you might ask yourself what is the
right way to convert files from TypeScript to JavaScript?

A lot of the time the answer is _‚Äúit depends‚Äù_ , or _‚Äúsomeone may have decided
for you‚Äù_ depending on the project. If you are building your project with an
existing framework like [tsdx](https://tsdx.io),
[Angular](https://angular.io/), [NestJS](https://nestjs.com/) or any framework
mentioned in the [Getting Started](/docs/home) then this decision is handled
for you.

However, a useful heuristic could be:

  * Is your build output mostly the same as your source input files? Use `tsc`
  * Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking

## Babel for transpiling, `tsc` for types

This is a common pattern for projects with existing build infrastructure which
may have been ported from a JavaScript codebase to TypeScript.

This technique is a hybrid approach, using Babel‚Äôs [preset-
typescript](https://babeljs.io/docs/en/babel-preset-typescript) to generate
your JS files, and then using TypeScript to do type checking and `.d.ts` file
generation.

By using babel‚Äôs support for TypeScript, you get the ability to work with
existing build pipelines and are more likely to have a faster JS emit time
because Babel does not type check your code.

#### Type Checking and d.ts file generation

The downside to using babel is that you don‚Äôt get type checking during the
transition from TS to JS. This can mean that type errors which you miss in
your editor could sneak through into production code.

In addition to that, Babel cannot create `.d.ts` files for your TypeScript
which can make it harder to work with your project if it is a library.

To fix these issues, you would probably want to set up a command to type check
your project using TSC. This likely means duplicating some of your babel
config into a corresponding [`tsconfig.json`](/tsconfig) and ensuring these
flags are enabled:

    
    
    "compilerOptions": {
    
      // Ensure that .d.ts files are created by tsc, but not .js files
    
      "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
      "[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)": true,
    
      // Ensure that Babel can safely transpile files in the TypeScript project
    
      "[isolatedModules](https://www.typescriptlang.org/tsconfig#isolatedModules)": true
    
    }

For more information on these flags:

  * [`isolatedModules`](/tsconfig#isolatedModules)
  * [`declaration`](/tsconfig#declaration), [`emitDeclarationOnly`](/tsconfig#emitDeclarationOnly)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Babel with
TypeScript.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

R![Rob
\(1\)](https://gravatar.com/avatar/adbe33073feaad7230c312d57863491f?s=32&&d=blank)

US![Udayan Shevade
\(1\)](https://gravatar.com/avatar/77a1c7d709b837898ddd3092fdca4767?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

### This page has been deprecated

This handbook page has been replaced, [go to the new
page](/docs/handbook/2/everyday-types.html)

[Go to new page](/docs/handbook/2/everyday-types.html)

# Basic Types

For programs to be useful, we need to be able to work with some of the
simplest units of data: numbers, strings, structures, boolean values, and the
like. In TypeScript, we support the same types as you would expect in
JavaScript, with an extra enumeration type thrown in to help things along.

## Boolean

The most basic datatype is the simple true/false value, which JavaScript and
TypeScript call a `boolean` value.

    
    
    ts
    
    let isDone: boolean = false;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAlgzgIgewHYgFwQEYIaAhkiAXggDNdgYQBuIA)

## Number

As in JavaScript, all numbers in TypeScript are either floating point values
or BigIntegers. These floating point numbers get the type `number`, while
BigIntegers get the type `bigint`. In addition to hexadecimal and decimal
literals, TypeScript also supports binary and octal literals introduced in
ECMAScript 2015.

    
    
    ts
    
    let decimal: number = 6;
    
    let hex: number = 0xf00d;
    
    let binary: number = 0b1010;
    
    let octal: number = 0o744;
    
    let big: bigint = 100n;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlATABjwFAA2yoAJogMYCWAttEWgHYCutARorKALygBsAbmKkAFogAezNp259cEgGa5cZYSUih21JnACe0jl16hc7AIy5L60gHtKMRqFZG5p2wHYALF5ubt8GgBOpp8lrhMgkA)

## String

Another fundamental part of creating programs in JavaScript for webpages and
servers alike is working with textual data. As in other languages, we use the
type `string` to refer to these textual datatypes. Just like JavaScript,
TypeScript also uses double quotes (`"`) or single quotes (`'`) to surround
string data.

    
    
    ts
    
    let color: string = "blue";
    
    color = 'red';
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxg9sMCcBcEDOYEEsB2BzCAvBAEQBGwAriMQNwBQA9AxAA4LhiYgIC0mu2RCDqx4CQhADk7ACaSaQA)

You can also use _template strings_ , which can span multiple lines and have
embedded expressions. These strings are surrounded by the backtick/backquote
(```) character, and embedded expressions are of the form `${ expr }`.

    
    
    ts
    
    let fullName: string = `Bob Bobbington`;
    
    let age: number = 37;
    
    let sentence: string = `Hello, my name is ${fullName}.
    
    ¬†
    
    I'll be ${age + 1} years old next month.`;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZgrswDkCGBbEAuCBnMAnAlgHYDmEAvBAAYBCA9gEYR331HFi2GUDcAUKJCTEMEQjBT0QuchADMAdj4DsIQmFUBjETgIkZlABIh4tADQQUAT1GoQEfFggASAN6x4yNAF8AdL14AkgDk8BCSzi5CdgDUEACMXhCWIEi4jrTAACaiIAAekCicYAAWPjxAA)

This is equivalent to declaring `sentence` like so:

    
    
    ts
    
    let sentence: string =
    
      "Hello, my name is " +
    
      fullName +
    
      ".\n\n" +
    
      "I'll be " +
    
      (age + 1) +
    
      " years old next month.";
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZgrswDkCGBbEAuCBnMAnAlgHYDmEAvBAAYBCA9gEYR331HFi2GUDcAUKJCTEMEQjBT0QuchADMAdj4B6JRAC0GgMYwwGtf3DYQhMMc0icBEuV4QIAIgASIeLQA0EFAE9RqEBHwsBwgAaltoOEQ-UPD7ADoAHUIk+xi7ewBJAHJ4CElgsLsACiF-EIgARgBKNOCvECRcINpgABNREAAPSBROMAALOPtuIA)

## Array

TypeScript, like JavaScript, allows you to work with arrays of values. Array
types can be written in one of two ways. In the first, you use the type of the
elements followed by `[]` to denote an array of that element type:

    
    
    ts
    
    let list: number[] = [1, 2, 3];
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMCWDOYC4IDsCuBbARiATgbQF0IBeCPARgBoIAmagZgIG4g)

The second way uses a generic array type, `Array<elemType>`:

    
    
    ts
    
    let list: Array<number> = [1, 2, 3];
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMCWDOYC4IEEBOqCGBPAPAOwFcBbAIxFQD4IBeCAbQEYAaCAJhYGYBdAbiA)

## Tuple

Tuple types allow you to express an array with a fixed number of elements
whose types are known, but need not be the same. For example, you may want to
represent a value as a pair of a `string` and a `number`:

    
    
    ts
    
    // Declare a tuple type
    
    let x: [string, number];
    
    // Initialize it
    
    x = ["hello", 10]; // OK
    
    // Initialize it incorrectly
    
    x = [10, "hello"]; // Error
    
    Type 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.2322  
    2322Type 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAlACKQDGANgIbSSjmgAuArgA6nV0CeTkOrdoAHqgDaiOtACWAOwDmAGlCSGAWwBGMALoBuPGACSk8XXHlS4gF7VDOfqAC8oIQCIAFpFKk4j+QEYADFtB8AHkAaR1QfUNjUwtQQzjJYgQqYjpSdms7Bz95FzcPRwD8AFFYBCA)

When accessing an element with a known index, the correct type is retrieved:

    
    
    ts
    
    // OK
    
    console.log(x[0].substring(1));
    
    ¬†
    
    console.log(x[1].substring(1));
    
    Property 'substring' does not exist on type 'number'.2339Property 'substring' does not exist on type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAbSAF1AA9UBtRI6ASwDsBzAGlHoFcBbAIxgF0A3LlKgAvKAoAiABaR8+OJNYBGAAyDQIUAHkA0rhBgAtCYDG7IiaMGwe3Kbj1EcQgDoFjABSkK614nZuajomT2UASnChe0dnNw9vCmU+f0Dghi8IqKA)

Accessing an element outside the set of known indices fails with an error:

    
    
    ts
    
    x[3] = "world";
    
    Tuple type '[string, number]' of length '2' has no element at index '3'.2493Tuple type '[string, number]' of length '2' has no element at index '3'.
    
    ¬†
    
    console.log(x[5].toString());
    
    Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.2532  
    2493Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmdBWHNdItAKABtIAXUAD1QG1FroBLAOwHMAaUDgK4BbAEYwAugG4ydUAF5QjAEQALSBQpwlfAIwAGKaBCgA8gGkyIMAFpbAYwHVb1mYxzj5oJQHcEFACZK0mR2cByIcFQAdJpcABR0jPjiUdRwAMqsnPEAlDmSQA)

## Enum

A helpful addition to the standard set of datatypes from JavaScript is the
`enum`. As in languages like C#, an enum is a way of giving more friendly
names to sets of numeric values.

    
    
    ts
    
    enum Color {
    
      Red,
    
      Green,
    
      Blue,
    
    }
    
    let c: Color = Color.Green;
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEwBosoBxZYUY7AIQTGGIF8MFgAXKAYwC5ZEUUALz8kyAHTlKIANxA)

By default, enums begin numbering their members starting at `0`. You can
change this by manually setting the value of one of its members. For example,
we can start the previous example at `1` instead of `0`:

    
    
    ts
    
    enum Color {
    
      Red = 1,
    
      Green,
    
      Blue,
    
    }
    
    let c: Color = Color.Green;
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRLsAhBMYSgXwwWABcoAxgC5YiFMVFJkAOlr0QAbiA)

Or, even manually set all the values in the enum:

    
    
    ts
    
    enum Color {
    
      Red = 1,
    
      Green = 2,
    
      Blue = 4,
    
    }
    
    let c: Color = Color.Green;
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRioAmS7AIQTGEYBZKBfDAmAAXKAGMAXLEQpG8JMgB0teiADcQA)

A handy feature of enums is that you can also go from a numeric value to the
name of that value in the enum. For example, if we had the value `2` but
weren‚Äôt sure what that mapped to in the `Color` enum above, we could look up
the corresponding name:

    
    
    ts
    
    enum Color {
    
      Red = 1,
    
      Green,
    
      Blue,
    
    }
    
    let colorName: string = Color[2];
    
    ¬†
    
    // Displays 'Green'
    
    console.log(colorName);
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRLsAhBMYSgXwwWABcoAxohQA5AIYRgALigBnXsgCWIAObFYw5AG0ATAF0A3BgwB6E1AAii2QAcEYgJ6yoAclr0QLjEJCzEwADokFQAKISRkcUkASgMgA)

## Unknown

We may need to describe the type of variables that we do not know when we are
writing an application. These values may come from dynamic content ‚Äì e.g. from
the user ‚Äì or we may want to intentionally accept all values in our API. In
these cases, we want to provide a type that tells the compiler and future
readers that this variable could be anything, so we give it the `unknown`
type.

    
    
    ts
    
    let notSure: unknown = 4;
    
    notSure = "maybe a string instead";
    
    ¬†
    
    // OK, definitely a boolean
    
    notSure = false;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAdg9mDKBXATiAXBRUDWsDuUEAvBACwDcAULAiiMRAEQC2AhgJ4BG9rEAzmGQBLKAHMIIgSFYATRlUoB6RRADyAaQA0EGSABmIoWBDB2EXpxgxQrKNThJUDPa2B8Q5IA)

If you have a variable with an unknown type, you can narrow it to something
more specific by doing `typeof` checks, comparison checks, or more advanced
type guards that will be discussed in a later chapter:

    
    
    ts
    
    declare const maybe: unknown;
    
    // 'maybe' could be a string, object, boolean, undefined, or other types
    
    const aNumber: number = maybe;
    
    Type 'unknown' is not assignable to type 'number'.2322Type 'unknown' is not assignable to type 'number'.
    
    ¬†
    
    if (maybe === true) {
    
      // TypeScript knows that maybe is a boolean now
    
      const aBoolean: boolean = maybe;
    
      // So, it cannot be a string
    
      const aString: string = maybe;
    
    Type 'boolean' is not assignable to type 'string'.2322Type 'boolean' is not assignable to type 'string'.
    
    }
    
    ¬†
    
    if (typeof maybe === "string") {
    
      // TypeScript knows that maybe is a string
    
      const aString: string = maybe;
    
      // So, it cannot be a boolean
    
      const aBoolean: boolean = maybe;
    
    Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vVnnsAoAE0gGMAbAQ2klDLgDtEAXUAWyoE8AjSVAK6MA1ozgB3RgG5CIUAHJOvSPPpwBFYqD6gqoVtACWjAOYAaUHB4Arciws84cCpCqMLQ0gDNjkYhYRLFgALGFAWLgAHSERCBmY2KgA5AXY+aFRGVPTQAF4Obj4ZQkMvUAAKJR1cmvDoAUgASlAAb0JQUDkAFSjIAGUyI0i2UQlEcOCqNiq6Q3G9R2dXRlAxcXa1BN0AIScXN1RF-ZX8mZkOuT64C0M2MjcxNh09A2MTDfjWXT6WI1NUV6mPIFZQyAC+hBKZXKEWicDKMzytQARICTMjmm0LmAetEBkMRmtxiEpiCdHNdPpfm8PkwvlQfn8TADqUDToVIOdOmArjc7g84E86As9staVsqLslgdtKK3MCzoQwUA)

## Any

In some situations, not all type information is available or its declaration
would take an inappropriate amount of effort. These may occur for values from
code that has been written without TypeScript or a 3rd party library. In these
cases, we might want to opt-out of type checking. To do so, we label these
values with the `any` type:

    
    
    ts
    
    declare function getValue(key: string): any;
    
    // OK, return value of 'getValue' is not checked
    
    const str: string = getValue("myString");
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMA1KCZEACgGsQBPALngGcMYtUCBKZqVegG4AUAHpR8APIBpADTw4GZDHwA3cpXg5E8AORFSGkLvhYW8VDgzwwAC3B1gwsHjat2zNhy7wAvIWIyCmoAIgBbegBldk4CEO5BIA)

The `any` type is a powerful way to work with existing JavaScript, allowing
you to gradually opt-in and opt-out of type checking during compilation.

Unlike `unknown`, variables of type `any` allow you to access arbitrary
properties, even ones that don‚Äôt exist. These properties include functions and
TypeScript will not check their existence or type:

    
    
    ts
    
    let looselyTyped: any = 4;
    
    // OK, ifItExists might exist at runtime
    
    looselyTyped.ifItExists();
    
    // OK, toFixed exists (but the compiler doesn't check)
    
    looselyTyped.toFixed();
    
    ¬†
    
    let strictlyTyped: unknown = 4;
    
    strictlyTyped.toFixed();
    
    'strictlyTyped' is of type 'unknown'.18046'strictlyTyped' is of type 'unknown'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABtIAXUKuORSKgTwBU2AHSAE1QBDAHZtQAXlAkA3BRCgA8gGkANKACWAMwCStAKIAPdYlqJQAW3UBzABb1IRk6EH1oAV2G115yNSYt2Ll4+ADotXUNjUwAKAEpZeWU1WjgAMXUDflAHKLNogCM3elobSFAAYzhzbnUaaFA+OEhEYQByenLS8oBrWL9mVk4efhCU9My+ONlqOlATaHVy2kDhgVAPbuE4AHdhCSlZecXloeDRtIz+KaA)

The `any` will continue to propagate through your objects:

    
    
    ts
    
    let looselyTyped: any = {};
    
    let d = looselyTyped.a.b.c.d;
    
       
    
    let d: any
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMD20M4mATwCpIA4gCYC4IEMA7JCAXggG8BfAbgChRIsypYFk1MsA6fbgI24BjblnoB6cRAgA9APxA)

After all, remember that all the convenience of `any` comes at the cost of
losing type safety. Type safety is one of the main motivations for using
TypeScript and you should try to avoid using `any` when not necessary.

## Void

`void` is a little like the opposite of `any`: the absence of having any type
at all. You may commonly see this as the return type of functions that do not
return a value:

    
    
    ts
    
    function warnUser(): void {
    
      console.log("This is my warning message");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwIYCcwFUDOBTdACgEoAuRANzhgBNEBvAKEUQgRzgBs8A6TuAOaEARABUAFjByIpiALYBPFBjAwwA+Xhw5UAvMOIBuRgF8gA)

Declaring variables of type `void` is not useful because you can only assign
`null` (only if [`strictNullChecks`](/tsconfig#strictNullChecks) is not
specified, see next section) or `undefined` to them:

    
    
    ts
    
    let unusable: void = undefined;
    
    // OK if `--strictNullChecks` is not given
    
    unusable = null;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgCuAdmZJgEbFoBuA9vACagC85Fbe68CnjYBuAiFAB5ANKh46UAAMAtMpgJkAOTLZsAYQAWeRAGtIiuZFAVmpAObxGeCgUrU6xLtZ3YRQA)

## Null and Undefined

In TypeScript, both `undefined` and `null` actually have their types named
`undefined` and `null` respectively. Much like `void`, they‚Äôre not extremely
useful on their own:

    
    
    ts
    
    // Not much else we can assign to these variables!
    
    let u: undefined = undefined;
    
    let n: null = null;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEDkHsBdQWwK4GMAWoCmAbAzu0B3PJAQwDtRjtsBLAc3OklGhXV1ADdiAna4gI0xsAhACghsBAC5QCUgBN0AM2ql080AF5ZC5avUBucelikZpBJkxbQFqwaA)

By default `null` and `undefined` are subtypes of all other types. That means
you can assign `null` and `undefined` to something like `number`.

However, when using the [`strictNullChecks`](/tsconfig#strictNullChecks) flag, `null` and `undefined` are only assignable to `unknown`, `any` and their respective types (the one exception being that `undefined` is also assignable to `void`). This helps avoid _many_ common errors. In cases where you want to pass in either a `string` or `null` or `undefined`, you can use the union type `string | null | undefined`.

Union types are an advanced topic that we‚Äôll cover in a later chapter.

> As a note: we encourage the use of
> [`strictNullChecks`](/tsconfig#strictNullChecks) when possible, but for the
> purposes of this handbook, we will assume it is turned off.

## Never

The `never` type represents the type of values that never occur. For instance,
`never` is the return type for a function expression or an arrow function
expression that always throws an exception or one that never returns.
Variables also acquire the type `never` when narrowed by any type guards that
can never be true.

The `never` type is a subtype of, and assignable to, every type; however, _no_
type is a subtype of, or assignable to, `never` (except `never` itself). Even
`any` isn‚Äôt assignable to `never`.

Some examples of functions returning `never`:

    
    
    ts
    
    // Function returning never must not have a reachable end point
    
    function error(message: string): never {
    
      throw new Error(message);
    
    }
    
    ¬†
    
    // Inferred return type is never
    
    function fail() {
    
      return error("Something failed");
    
    }
    
    ¬†
    
    // Function returning never must not have a reachable end point
    
    function infiniteLoop(): never {
    
      while (true) {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEDEFcDsGMBcCWB7aoBOBTel3UdAOajSYBum6oAtpAM7wnKMAWAhhaGxpm7OwCMANplCZoAE1AAHZAXgAoAGYwEKNJXTJ0ACmqY6dNoUwAuUA3QFCASnOkKVAN4LQoeCy0B3Eph8BRdC1dfUNjTBsAbgUAXwUFEFAASWglTUwpLBw8dwBPaVFEOl9HZVUkVFAlNkQhHRtQFzcs3A0g7R0AIgBlZH0PayqakQlOqNj4xKg4CrQWvEGHShp6RmhmUHZObiw+QRExSRk5aEUVGfVQAiUCRHhMABlkZGl6+3JlptAvFlrRHXg6EgEUacRiQA)

## Object

`object` is a type that represents the non-primitive type, i.e. anything that
is not `number`, `string`, `boolean`, `bigint`, `symbol`, `null`, or
`undefined`.

With `object` type, APIs like `Object.create` can be better represented. For
example:

    
    
    ts
    
    declare function create(o: object | null): void;
    
    ¬†
    
    // OK
    
    create({ prop: 0 });
    
    create(null);
    
    create(undefined); // with `--strictNullChecks` flag enabled, undefined is not a subtype of null
    
    Argument of type 'undefined' is not assignable to parameter of type 'object | null'.2345Argument of type 'undefined' is not assignable to parameter of type 'object | null'.
    
    ¬†
    
    create(42);
    
    Argument of type 'number' is not assignable to parameter of type 'object'.2345Argument of type 'number' is not assignable to parameter of type 'object'.
    
    create("string");
    
    Argument of type 'string' is not assignable to parameter of type 'object'.2345Argument of type 'string' is not assignable to parameter of type 'object'.
    
    create(false);
    
    Argument of type 'boolean' is not assignable to parameter of type 'object'.2345Argument of type 'boolean' is not assignable to parameter of type 'object'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6MVec5ABRxUcAEYArEs1AAfUAzqlSASlQA3OKwIBuPHhCgA8gGk83SLwEBvUAAd4N1AAZQAXyU6zF-vMXvTPPn5GIhpWBkgCd1B9AHdWZgALUAADAFpUxGZoVhYAOQVSAGEEkgBrRGTaCgBzUEgGchFSCIAaUGDIUPCCUFZEOTgpclBEOhFmAE8bajgaOQLdT0CsND8lgQAiTOyGao21gIEaclJESHcgA)

Generally, you won‚Äôt need to use this.

## Type assertions

Sometimes you‚Äôll end up in a situation where you‚Äôll know more about a value
than TypeScript does. Usually, this will happen when you know the type of some
entity could be more specific than its current type.

_Type assertions_ are a way to tell the compiler ‚Äútrust me, I know what I‚Äôm
doing.‚Äù A type assertion is like a type cast in other languages, but it
performs no special checking or restructuring of data. It has no runtime
impact and is used purely by the compiler. TypeScript assumes that you, the
programmer, have performed any special checks that you need.

Type assertions have two forms.

One is the `as`-syntax:

    
    
    ts
    
    let someValue: unknown = "this is a string";
    
    ¬†
    
    let strLength: number = (someValue as string).length;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzg9gtiAagQ2AVxALgmgdga1xgHdcIBeCAIjAAsBLKCRiZaMAJ3twHMqBuAFCDQkKJwAyIXnWy40cAEYgOFCAApYCFOhCsm4rrwCUAOlAza-IA)

The other version is the ‚Äúangle-bracket‚Äù syntax:

    
    
    ts
    
    let someValue: unknown = "this is a string";
    
    ¬†
    
    let strLength: number = (<string>someValue).length;
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzg9gtiAagQ2AVxALgmgdga1xgHdcIBeCAIjAAsBLKCRiZaMAJ3twHMqBuAFCDQkKJwAyIXnWy40cAEYgOFCAAoAPOK68AfLAQp0IAJQA6UDNr8gA)

The two samples are equivalent. Using one over the other is mostly a choice of
preference; however, when using TypeScript with JSX, only `as`-style
assertions are allowed.

## A note about `let`

You may have noticed that so far, we‚Äôve been using the `let` keyword instead
of JavaScript‚Äôs `var` keyword which you might be more familiar with. The `let`
keyword is actually a newer JavaScript construct that TypeScript makes
available. You can read in the Handbook Reference on [Variable
Declarations](/docs/handbook/variable-declarations.html) more about how `let`
and `const` fix a lot of the problems with `var`.

## About `Number`, `String`, `Boolean`, `Symbol` and `Object`

It can be tempting to think that the types `Number`, `String`, `Boolean`,
`Symbol`, or `Object` are the same as the lowercase versions recommended
above. These types do not refer to the language primitives however, and almost
never should be used as a type.

    
    
    ts
    
    function reverse(s: String): String {
    
      return s.split("").reverse().join("");
    
    }
    
    ¬†
    
    reverse("hello world");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jRpIA3GRSAChVAGVzpLiBzAJSpuvAaADeuUHUjlC0WogB0iAA4AbSuVYAiXYOX0mSNoYBWcPnoMBuXAF9cuY8za6AFpA0a4oAO4IGgAmdkA)

Instead, use the types `number`, `string`, `boolean`, `object` and `symbol`.

    
    
    ts
    
    function reverse(s: string): string {
    
      return s.split("").reverse().join("");
    
    }
    
    ¬†
    
    reverse("hello world");
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYDdXIM6oBTYBci2UyMYA5gJTGnlWIDeAUIiqlCMktgHTYADgBsYUPACIJ1Pmkw58MgFZwKk6QG4WAXxYs5WXJIAWqYcLiIA7nGTCAJpqA)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Basic Types.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(53\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

OT![Orta Therox
\(33\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(25\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

NS![Nathan Shively-Sanders
\(4\)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)

MZ![Micah Zoltu
\(3\)](https://gravatar.com/avatar/c0b2bfa28a2c809735b4209cbfcd357d?s=32&&d=blank)

47+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

### This page has been deprecated

This handbook page has been replaced, [go to the new
page](/docs/handbook/2/classes.html)

[Go to new page](/docs/handbook/2/classes.html)

# Classes

Traditional JavaScript uses functions and prototype-based inheritance to build
up reusable components, but this may feel a bit awkward to programmers more
comfortable with an object-oriented approach, where classes inherit
functionality and objects are built from these classes. Starting with
ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build
their applications using this object-oriented class-based approach. In
TypeScript, we allow developers to use these techniques now, and compile them
down to JavaScript that works across all major browsers and platforms, without
having to wait for the next version of JavaScript.

## Classes

Let‚Äôs take a look at a simple class-based example:

    
    
    ts
    
    class Greeter {
    
      greeting: string;
    
    ¬†
    
      constructor(message: string) {
    
        this.greeting = message;
    
      }
    
    ¬†
    
      greet() {
    
        return "Hello, " + this.greeting;
    
      }
    
    }
    
    ¬†
    
    let greeter = new Greeter("world");
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8BQ1oHMlUBLAO3wC5oIV4z8BubXaYAe1JvgFdgU34ACgC2iKGHyIqXegEosLPCgAWxCADpCyFPWgBeaKPGSmeAL7M8W1IPk48eJCm7xS0AEQAJRCBBsANB7QANTQKmqaRDrkptAWFtggqARR6PrQpIgA7nCpQu5ZAiAAJu6yDEA)

The syntax should look familiar if you‚Äôve used C# or Java before. We declare a
new class `Greeter`. This class has three members: a property called
`greeting`, a constructor, and a method `greet`.

You‚Äôll notice that in the class when we refer to one of the members of the
class we prepend `this.`. This denotes that it‚Äôs a member access.

In the last line we construct an instance of the `Greeter` class using `new`.
This calls into the constructor we defined earlier, creating a new object with
the `Greeter` shape, and running the constructor to initialize it.

## Inheritance

In TypeScript, we can use common object-oriented patterns. One of the most
fundamental patterns in class-based programming is being able to extend
existing classes to create new ones using inheritance.

Let‚Äôs take a look at an example:

    
    
    ts
    
    class Animal {
    
      move(distanceInMeters: number = 0) {
    
        console.log(`Animal moved ${distanceInMeters}m.`);
    
      }
    
    }
    
    ¬†
    
    class Dog extends Animal {
    
      bark() {
    
        console.log("Woof! Woof!");
    
      }
    
    }
    
    ¬†
    
    const dog = new Dog();
    
    dog.bark();
    
    dog.move(10);
    
    dog.bark();
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa1kHsA3AUwAoATRCAFzHmGIEl4BZY64gJwgC5p4ArsgBGXaAF5oABgCUmHLmjB88CPhDEAdCHwBzUgAMEKNHiLFy0ACQZKNOg2ZsO3AL7JNBmQG4FrrP5YoJAwACJ60MQAHhzw5DDGqOjYuMJgnADWpHIpisqq6lo6+gBEAOr4+ABmAITQFdU1JT5+AVhBKjTQ5BGS8MQA7tDh+i09upppmdm+45oEJKQAjLKzepPpWT5AA)

This example shows the most basic inheritance feature: classes inherit
properties and methods from base classes. Here, `Dog` is a _derived_ class
that derives from the `Animal` _base_ class using the `extends` keyword.
Derived classes are often called _subclasses_ , and base classes are often
called _superclasses_.

Because `Dog` extends the functionality from `Animal`, we were able to create
an instance of `Dog` that could both `bark()` and `move()`.

Let‚Äôs now look at a more complex example.

    
    
    ts
    
    class Animal {
    
      name: string;
    
      constructor(theName: string) {
    
        this.name = theName;
    
      }
    
      move(distanceInMeters: number = 0) {
    
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    
      }
    
    }
    
    ¬†
    
    class Snake extends Animal {
    
      constructor(name: string) {
    
        super(name);
    
      }
    
      move(distanceInMeters = 5) {
    
        console.log("Slithering...");
    
        super.move(distanceInMeters);
    
      }
    
    }
    
    ¬†
    
    class Horse extends Animal {
    
      constructor(name: string) {
    
        super(name);
    
      }
    
      move(distanceInMeters = 45) {
    
        console.log("Galloping...");
    
        super.move(distanceInMeters);
    
      }
    
    }
    
    ¬†
    
    let sam = new Snake("Sammy the Python");
    
    let tom: Animal = new Horse("Tommy the Palomino");
    
    ¬†
    
    sam.move();
    
    tom.move(34);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa15mQFMAuaCAFwCdF4BzAbh2mAHt4LKBXYclygCnIALQgDkCJMlRq0AlJia5hiCADp8RaAF5owsRMa4Avk2QsAboX4ATFeTDxghAJLwAsoXKFKEUvE7IAEbe2tAADPLYuLis7CwghKogLLT8AAYAJBjKahqERtBmltbQWbYUDk6uHl4+RsiqabKG0CYmWKCQMADK+ADWhNCEAB5e8NYwCChoCjFsHNy8AnmkHDKRimScAA7e-HnNTCa4RVbl9o4u7p7eMDoArBvRzPPxicmpAETdIIh61HRVEDPodnhAdt5VKcbHZKlcardQa0sO1OlBoAAJPgQQYjMYTOBIVDoKIvdhURZ8fYSVbSOhPaLg3bLCRI46FCxnWGXao3HyhAAsj1m0ViEDeSRS-E+AHE0MltjIgaoQS1cEzIdDznDebUIGyUVgsAlyGQCKF4IQAO7QXpgAbS7oEZAAT10ImgAAUXcI2KrjZ5dCxkKQpsSLdbMdirJ8ACrB13uwaetDBmgsf1YCAEKGc-iHXgNaEAZgFzSAA)

This example covers a few other features we didn‚Äôt previously mention. Again,
we see the `extends` keywords used to create two new subclasses of `Animal`:
`Horse` and `Snake`.

One difference from the prior example is that each derived class that contains
a constructor function _must_ call `super()` which will execute the
constructor of the base class. What‚Äôs more, before we _ever_ access a property
on `this` in a constructor body, we _have_ to call `super()`. This is an
important rule that TypeScript will enforce.

The example also shows how to override methods in the base class with methods
that are specialized for the subclass. Here both `Snake` and `Horse` create a
`move` method that overrides the `move` from `Animal`, giving it functionality
specific to each class. Note that even though `tom` is declared as an
`Animal`, since its value is a `Horse`, calling `tom.move(34)` will call the
overriding method in `Horse`:

    
    
    Slithering...
    
    Sammy the Python moved 5m.
    
    Galloping...
    
    Tommy the Palomino moved 34m.

## Public, private, and protected modifiers

### Public by default

In our examples, we‚Äôve been able to freely access the members that we declared
throughout our programs. If you‚Äôre familiar with classes in other languages,
you may have noticed in the above examples we haven‚Äôt had to use the word
`public` to accomplish this; for instance, C# requires that each member be
explicitly labeled `public` to be visible. In TypeScript, each member is
`public` by default.

You may still mark a member `public` explicitly. We could have written the
`Animal` class from the previous section in the following way:

    
    
    ts
    
    class Animal {
    
      public name: string;
    
    ¬†
    
      public constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    ¬†
    
      public move(distanceInMeters: number) {
    
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa0AOArgEYiLDTxjICmAXNBAC4BOi8A5gNxY77GnlgAe3hNmBYIyHMAFIwAW1AHJU6DFm3YBKTL1wLEEAHSUa0ALzQFy1d1wBfHrkIky0ZEIBu1GQBNDjGDwwNQAkvAAstSM1MwQ9PAEyESxOti4uMKiQiDURiBC7DIABgAkGAbGptT27l7UvtDl-kxBIeFRMXH2yEbFWnbQjvZAA)

### ECMAScript Private Fields

With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private
fields:

    
    
    ts
    
    class Animal {
    
      #name: string;
    
      constructor(theName: string) {
    
        this.#name = theName;
    
      }
    
    }
    
    ¬†
    
    new Animal("Cat").#name;
    
    Property '#name' is not accessible outside class 'Animal' because it has a private identifier.18013Property '#name' is not accessible outside class 'Animal' because it has a private identifier.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMaDMAoAYwBsBDRRUAQQDsBLAW1ONAG99RQBiG0hyVIgAu0OjQDmAbg6hCcGsOgBXQkIQAKIQAtIAOT4DQiseICUbGZ211EAOh4HQAXlDa9B6ZwC++H-hqQAO7U9EzE6gBEAMKkQhGm9rz8kkA)

This syntax is built into the JavaScript runtime and can have better
guarantees about the isolation of each private field. Right now, the best
documentation for these private fields is in the TypeScript 3.8 [release
notes](https://devblogs.microsoft.com/typescript/announcing-
typescript-3-8-beta/#ecmascript-private-fields).

### Understanding TypeScript‚Äôs `private`

TypeScript also has its own way to declare a member as being marked `private`,
it cannot be accessed from outside of its containing class. For example:

    
    
    ts
    
    class Animal {
    
      private name: string;
    
    ¬†
    
      constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    }
    
    ¬†
    
    new Animal("Cat").name;
    
    Property 'name' is private and only accessible within class 'Animal'.2341Property 'name' is private and only accessible within class 'Animal'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUAMYA2AhooqAIIB2AlgLYlGgDeeooADtLQG4kAXSKGol6kVIgE9qAcwDcedqAJxqU6AFcCAhAAoBAC0gA5MRNAbacgJStlHI7UQA6UeNABeUEdPnFHAC+eMF41JAA7lR0jER6AEQAwoLxNm7+QA)

TypeScript is a structural type system. When we compare two different types,
regardless of where they came from, if the types of all members are
compatible, then we say the types themselves are compatible.

However, when comparing types that have `private` and `protected` members, we
treat these types differently. For two types to be considered compatible, if
one of them has a `private` member, then the other must have a `private`
member that originated in the same declaration. The same applies to
`protected` members.

Let‚Äôs look at an example to better see how this plays out in practice:

    
    
    ts
    
    class Animal {
    
      private name: string;
    
      constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    }
    
    ¬†
    
    class Rhino extends Animal {
    
      constructor() {
    
        super("Rhino");
    
      }
    
    }
    
    ¬†
    
    class Employee {
    
      private name: string;
    
      constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    }
    
    ¬†
    
    let animal = new Animal("Goat");
    
    let rhino = new Rhino();
    
    let employee = new Employee("Bob");
    
    ¬†
    
    animal = rhino;
    
    animal = employee;
    
    Type 'Employee' is not assignable to type 'Animal'.
      Types have separate declarations of a private property 'name'.2322Type 'Employee' is not assignable to type 'Animal'.
      Types have separate declarations of a private property 'name'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAGMAbAQ0UVAEEA7ASwFsiDQBvHUUAB2moDciAXSKEpFakVIj5dKAcwDcrUHjiUJ0AK54+CABR8AFpAByIsaFXUZASmYK2+6ogB0w0aAC8ofUZPy2AXxwA-GJSUAAlPQs4UEgADwFKABMyKjoGGzYlFUkNLWhtaxY2NkQ1dhhtACIIqMrLX1AAoMISMgBRWnYCOABPSEEiji5eASETcUkLOQUs1VydL2NRCalpQttPSKcXQQ9FnwUmnBwCSD5QIhp6Rg9KSAB3CiuGKoBxOH46+VPz6EjKaK3B7hf5wArfM4xTrdPq7ITAjpdXr9KoAITgACMvsdLmkbqA-lF5Ljru4oUjYbIgA)

In this example, we have an `Animal` and a `Rhino`, with `Rhino` being a
subclass of `Animal`. We also have a new class `Employee` that looks identical
to `Animal` in terms of shape. We create some instances of these classes and
then try to assign them to each other to see what will happen. Because
`Animal` and `Rhino` share the `private` side of their shape from the same
declaration of `private name: string` in `Animal`, they are compatible.
However, this is not the case for `Employee`. When we try to assign from an
`Employee` to `Animal` we get an error that these types are not compatible.
Even though `Employee` also has a `private` member called `name`, it‚Äôs not the
one we declared in `Animal`.

### Understanding `protected`

The `protected` modifier acts much like the `private` modifier with the
exception that members declared `protected` can also be accessed within
deriving classes. For example,

    
    
    ts
    
    class Person {
    
      protected name: string;
    
      constructor(name: string) {
    
        this.name = name;
    
      }
    
    }
    
    ¬†
    
    class Employee extends Person {
    
      private department: string;
    
    ¬†
    
      constructor(name: string, department: string) {
    
        super(name);
    
        this.department = department;
    
      }
    
    ¬†
    
      public getElevatorPitch() {
    
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    
      }
    
    }
    
    ¬†
    
    let howard = new Employee("Howard", "Sales");
    
    console.log(howard.getElevatorPitch());
    
    console.log(howard.name);
    
    Property 'name' is protected and only accessible within class 'Person' and its subclasses.2445Property 'name' is protected and only accessible within class 'Person' and its subclasses.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYBQBjAGwENFFQAFGROAO1AG9dRQAHeAF0ny4BNRaxALaRUiDtACWtAOYBuZqHx1x0AK48EACkEixE6TICUjRSw4ALSYgB0uyKAC8A4ZAUsAvri8ESZUACiQqyEcACekA6QAB5ctLzkVEh0pizskgBuxFygvJCsxNAcIrQc+lKyCorKtKoaHNr25YYANLn5hcWQpc2yJkwsLIhqrDA6rkbug5bWNnkFRSUcTu0LXaVTPmlqAEaEkvigMpAcAYSQWQ3QFJIc+BZa-Wag0Cdq0PQABgASkIShbSEYRcIlA1lAABIGDNbPYPKBiPFQABJUAAdwQAGswfQoTC5h1Ft0OB4bJ9Nt5cLhzssLHA0YV+M5aJA0YFgqEIpAtAAib70xk8to8gDKxHOiB5kwIKjg5xsoRkWjpDOgvBsx1O50uCBudweRmlNRo8sVyoFarsEzkQA)

Notice that while we can‚Äôt use `name` from outside of `Person`, we can still
use it from within an instance method of `Employee` because `Employee` derives
from `Person`.

A constructor may also be marked `protected`. This means that the class cannot
be instantiated outside of its containing class, but can be extended. For
example,

    
    
    ts
    
    class Person {
    
      protected name: string;
    
      protected constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    }
    
    ¬†
    
    // Employee can extend Person
    
    class Employee extends Person {
    
      private department: string;
    
    ¬†
    
      constructor(name: string, department: string) {
    
        super(name);
    
        this.department = department;
    
      }
    
    ¬†
    
      public getElevatorPitch() {
    
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    
      }
    
    }
    
    ¬†
    
    let howard = new Employee("Howard", "Sales");
    
    let john = new Person("John");
    
    Constructor of class 'Person' is protected and only accessible within the class declaration.2674Constructor of class 'Person' is protected and only accessible within the class declaration.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYDsAWAUAMYA2AhooqAAoyJwB2oA3nqKAA7wAukB3AJqDokAtpFSJO0AJZ0A5gG4W7Lj36gC9CdACuvBAApOAC0gA5EWNBaZsgJRMlrY1MQA6IaNABeUMbMXFVgBfPBC8EFAAUWE2IjgAT0hIdRIGSAAPbjoBaiR6QlJyKJi4xOSMrL4KXNoGZlYOKQA3Em5QPkg2EmhOUTpOcUkbRSUNOi1dTgMPS2s5ABp2zu7eyH7B6Tl7etYrbTYYfRnbQN3nNw6unr7ObyWr1f7TsIbtACMiKQJQWUhOSKIkBaU2glCknAIRn020coGgf200AYAAMABKQIhxRbCeKCCygFygAAkjHO7gsQVAqQEAElQAB3BAAawJDBJZMuKxuQVcyOeoTweEBtyMcHp3QEPjokHpxViCSS+gARKixRKlYslQBlEiAxBKk5Cv6gABWcCMDClMqoNHoyoAUua6Ab5EA)

## Readonly modifier

You can make properties readonly by using the `readonly` keyword. Readonly
properties must be initialized at their declaration or in the constructor.

    
    
    ts
    
    class Octopus {
    
      readonly name: string;
    
      readonly numberOfLegs: number = 8;
    
    ¬†
    
      constructor(theName: string) {
    
        this.name = theName;
    
      }
    
    }
    
    ¬†
    
    let dad = new Octopus("Man with the 8 strong legs");
    
    dad.name = "Man with the 3-piece suit";
    
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAMYA2AhooqAPIEAucADgK4UDeeoo0kJAJnAHZEAnqH4kAtpFSIa0AJb8A5gG52nbn0Ej+jcQCMYlAGYAZSIpSjdB6KAC8oAByq1BATOiNaCABQ0AFpAAchJSoB4KigCUoGwcHAFyiAB0YpL2oAHBoaocAL54BXhEkDSgPLwZ-JAA7lTeTIg+AEQAsiT8oDVyAZmBTuGyAoqgJRbNUaoVPKmhGW0dXT3+fZCgAMwAtPRykARriIw9zcpAA)

## Parameter properties

In our last example, we had to declare a readonly member `name` and a
constructor parameter `theName` in the `Octopus` class. This is needed in
order to have the value of `theName` accessible after the `Octopus`
constructor is executed. _Parameter properties_ let you create and initialize
a member in one place. Here‚Äôs a further revision of the previous `Octopus`
class using a parameter property:

    
    
    ts
    
    class Octopus {
    
      readonly numberOfLegs: number = 8;
    
      constructor(readonly name: string) {}
    
    }
    
    ¬†
    
    let dad = new Octopus("Man with the 8 strong legs");
    
    dad.name;
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDywBcD2AHArjA3gKGtATgKZgAmSAdiAJ7TloC2ARofrAGYAyhA5hAFy0GzfNAC80ABwBuXNGAUICfGkRJ8ACiKkK1WmHqEBi-AEty3AJTRMAX2x3sIQgmglSY2oQDucVegjqAEQAsmDk0F4mCAAW0DGEktDGFNzQTryBFjJuJAB05PqEUkA)

Notice how we dropped `theName` altogether and just use the shortened
`readonly name: string` parameter on the constructor to create and initialize
the `name` member. We‚Äôve consolidated the declarations and assignment into one
location.

Parameter properties are declared by prefixing a constructor parameter with an
accessibility modifier or `readonly`, or both. Using `private` for a parameter
property declares and initializes a private member; likewise, the same is done
for `public`, `protected`, and `readonly`.

## Accessors

TypeScript supports getters/setters as a way of intercepting accesses to a
member of an object. This gives you a way of having finer-grained control over
how a member is accessed on each object.

Let‚Äôs convert a simple class to use `get` and `set`. First, let‚Äôs start with
an example without getters and setters.

    
    
    ts
    
    class Employee {
    
      fullName: string;
    
    }
    
    ¬†
    
    let employee = new Employee();
    
    employee.fullName = "Bob Smith";
    
    ¬†
    
    if (employee.fullName) {
    
      console.log(employee.fullName);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCiAtgA7YD2AnnnqAN4GgYCu22Acpip40MBADsA5gG4CAXwIFseaKDy0GzVgF5Q4vAHdKGpiwAUASlnq6pvADp0vAUJ2gARACF6AI1ABlKnhoAAt3WQJ4dFAzG00WR2dBYQt2TlBEenFIemV7BklYky1EvmS8K3kgA)

While allowing people to randomly set `fullName` directly is pretty handy, we
may also want enforce some constraints when `fullName` is set.

In this version, we add a setter that checks the length of the `newName` to
make sure it‚Äôs compatible with the max-length of our backing database field.
If it isn‚Äôt we throw an error notifying client code that something went wrong.

To preserve existing functionality, we also add a simple getter that retrieves
`fullName` unmodified.

    
    
    ts
    
    const fullNameMaxLength = 10;
    
    ¬†
    
    class Employee {
    
      private _fullName: string = "";
    
    ¬†
    
      get fullName(): string {
    
        return this._fullName;
    
      }
    
    ¬†
    
      set fullName(newName: string) {
    
        if (newName && newName.length > fullNameMaxLength) {
    
          throw new Error("fullName has a max length of " + fullNameMaxLength);
    
        }
    
    ¬†
    
        this._fullName = newName;
    
      }
    
    }
    
    ¬†
    
    let employee = new Employee();
    
    employee.fullName = "Bob Smith";
    
    ¬†
    
    if (employee.fullName) {
    
      console.log(employee.fullName);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCID2AdjBgK7bYBymAtngLKYAeAMnqQObQAWoALygAjAAYA3ASLZMkSKACiDAA7ZiATzx5QAbwKhQqhADdM0XQH101OozxoYCXsNAAid9MOgeeaFQ09EwAFACUTnDwrgZGRrD+lLCkoALwkAB0NnbBeNJGAL4yRvgBtkEOIaR4AO65kS48Yfo+RvDooFW1uaAAZL2g1XUOGdjcfIIAfIH2TKyc4wLNsXFGArDENYO1yrAbsCHu5bO6-PKgmKAM7KBjvAKgxB3uoADUM7nzXPf8YflxRVaqX46Syxx6IiGuX+RUBYwCeDUGm0ukhOxU6i0OnC0kRmJRGXBDjc7gAQsQAEagADKDHgAi8MnanTxyJ0hJyDmWPhI5GIY1GxB4IVZWLwHIqTD+BAKQA)

To prove to ourselves that our accessor is now checking the length of values,
we can attempt to assign a name longer than 10 characters and verify that we
get an error.

A couple of things to note about accessors:

First, accessors require you to set the compiler to output ECMAScript 5 or
higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with
a `get` and no `set` are automatically inferred to be `readonly`. This is
helpful when generating a `.d.ts` file from your code, because users of your
property can see that they can‚Äôt change it.

## Static Properties

Up to this point, we‚Äôve only talked about the _instance_ members of the class,
those that show up on the object when it‚Äôs instantiated. We can also create
_static_ members of a class, those that are visible on the class itself rather
than on the instances. In this example, we use `static` on the origin, as it‚Äôs
a general value for all grids. Each instance accesses this value through
prepending the name of the class. Similarly to prepending `this.` in front of
instance accesses, here we prepend `Grid.` in front of static accesses.

    
    
    ts
    
    class Grid {
    
      static origin = { x: 0, y: 0 };
    
    ¬†
    
      calculateDistanceFromOrigin(point: { x: number; y: number }) {
    
        let xDist = point.x - Grid.origin.x;
    
        let yDist = point.y - Grid.origin.y;
    
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    
      }
    
    ¬†
    
      constructor(public scale: number) {}
    
    }
    
    ¬†
    
    let grid1 = new Grid(1.0); // 1x scale
    
    let grid2 = new Grid(5.0); // 5x scale
    
    ¬†
    
    console.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));
    
    console.log(grid2.calculateDistanceFromOrigin({ x: 10, y: 10 }));
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBLAJtA3gKGtCAXMuiw0A9kgOaIB20AvOtAB4Bc0ADADTQCerb0AXwDcGLNGBgQwAK7hcAUwAiiPGCrB5AMXgkAtgHkK1ABQAHEtVys0TVlWm6ARvPhCedh8-iCAlOjHYIPK4TMp4dNDmlgB0jNAAtHBIyNFkiJRUsSLYgcE8YSH0UVS40dwJSSipRpnc2TnwwdLwNACyBAAW0RAAjvC4xowF0ABUoSohANT5E6MzeH4A9NC4HSrdEkH1AqLYwCRUePDSwLhkZtKOIEQ4m-IeTi5+aDs7GEEh5MkAjBFU8gB3SrIYzfaJsHxuRbLb5xCB3d55L4oABMf0BwOMAFZwZDoNDoFi4QiMPtDiQgtEQCRyMZkcgwZsZHIlBM1BptHpDOkTDYWNBvpx3AL+AIfJDSQcIBT5FSaXTkijokzZARWap1FodAYasY+axBVxeCLfJCgA)

## Abstract Classes

Abstract classes are base classes from which other classes may be derived.
They may not be instantiated directly. Unlike an interface, an abstract class
may contain implementation details for its members. The `abstract` keyword is
used to define abstract classes as well as abstract methods within an abstract
class.

    
    
    ts
    
    abstract class Animal {
    
      abstract makeSound(): void;
    
    ¬†
    
      move(): void {
    
        console.log("roaming the earth...");
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgggOwJYFthkEBvAKAQVEhngUIGsBTAZQHsBXbAEwAoBKAFwIAbm1zcA3GQr02IpgOFiJpWZVhtsYNsiYA6ZGwDmvAERQ2wfLmzGEEABZMETYFCf6vZ-tMoBfMn8gA)

Methods within an abstract class that are marked as abstract do not contain an
implementation and must be implemented in derived classes. Abstract methods
share a similar syntax to interface methods. Both define the signature of a
method without including a method body. However, abstract methods must include
the `abstract` keyword and may optionally include access modifiers.

    
    
    ts
    
    abstract class Department {
    
      constructor(public name: string) {}
    
    ¬†
    
      printName(): void {
    
        console.log("Department name: " + this.name);
    
      }
    
    ¬†
    
      abstract printMeeting(): void; // must be implemented in derived classes
    
    }
    
    ¬†
    
    class AccountingDepartment extends Department {
    
      constructor() {
    
        super("Accounting and Auditing"); // constructors in derived classes must call super()
    
      }
    
    ¬†
    
      printMeeting(): void {
    
        console.log("The Accounting Department meets each Monday at 10am.");
    
      }
    
    ¬†
    
      generateReports(): void {
    
        console.log("Generating accounting reports...");
    
      }
    
    }
    
    ¬†
    
    let department: Department; // ok to create a reference to an abstract type
    
    department = new Department(); // error: cannot create an instance of an abstract class
    
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.
    
    department = new AccountingDepartment(); // ok to create and assign a non-abstract subclass
    
    department.printName();
    
    department.printMeeting();
    
    department.generateReports(); // error: department is not of type AccountingDepartment, cannot access generateReports
    
    Property 'generateReports' does not exist on type 'Department'.2339Property 'generateReports' does not exist on type 'Department'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMX0GY8BOAKAEMAjRAF2lIGMrQ6AbUxRUAEUgAdToqAW0gA7RgG9ioJnBHVoAVwYIAFDwXlmASzqgRpYanlaRAcwCUocQF9iU0D2gmqAOQOQV51ADc4WgCZW9tJ0sohwzJAAdMxwpioARNx8AsJieu6oCaAA1KBUABZaiFH6wuYA3Pa29hTy9IyOzgCykJBUJvFeoL4BFaAgoIIK1KDkkKBagjyRaVSQgSag-jBa3gtMrOyQiMQ1LGwcAIJ0oQpincn8QqKMkAAe8yL+HFept0EhYTRKVKqWkmk0kQCh4MESJzOFzMoFIz1ARwU-i0HTMCUqAzAoTkP2USEmImWq3WgQO2w4w1GdFIzGYoBBYOgnmqdmkTTErXanU8Pj8gUBQOx4UiMTiiQAKgUJpC4OdUaYuLxrnMhm0qBxIPQCqBmrJ-KQAJ6wxhYAAMBii6Kq0hq0lMohgpHmACVeAh1TyenzPoKwhForF4gkAOIO2jy2GnWXQhXQN0CEpRS2VFk1SKMFYpG5iVBvbNUfqDOAAa3ycCYcadE1IoDjADMYKI6BM-rDCXUaA18gawcRM8qPgBePSQADuiqzc08hbAMHg0FQ1JEIjgjDolfmbYJ1DhzdAcDrW47tAYm0OfaV73Sw5EY4RUbll0v+enmP3pdb681m7hgUOWlMds9FkABaY8uxBcgyV2fsryoKJ2VcdxpwvSdbgQpwOTVbkU1g-MontW9w0gV0eHdRBX0GOcEFQPCVWKYDGAPbswXvKF5TzOYABomDhFdGHoZt2FAQjHRdeN1SAA)

## Advanced Techniques

## Constructor functions

When you declare a class in TypeScript, you are actually creating multiple
declarations at the same time. The first is the type of the _instance_ of the
class.

    
    
    ts
    
    class Greeter {
    
      greeting: string;
    
    ¬†
    
      constructor(message: string) {
    
        this.greeting = message;
    
      }
    
    ¬†
    
      greet() {
    
        return "Hello, " + this.greeting;
    
      }
    
    }
    
    ¬†
    
    let greeter: Greeter;
    
    greeter = new Greeter("world");
    
    console.log(greeter.greet()); // "Hello, world"
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8BQ1oHMlUBLAO3wC5oIV4z8BubXaYAe1JvgFdgU34ACgC2iKGHyIqXegEosLPCgAWxCADpCyFPWgBeaKPGSmeAL7M8W1IPk48eJCm7xS0AEQAJRCBBsANB7QANTQKmqaRDrkptAWFtggqARR6FQI2uhM1mgYBqSIAO5wqULuhQIgACbuskzsnGxJ6n74gjnokdq2ddAA9H0e3r4B0BXw1e5AA)

Here, when we say `let greeter: Greeter`, we‚Äôre using `Greeter` as the type of
instances of the class `Greeter`. This is almost second nature to programmers
from other object-oriented languages.

We‚Äôre also creating another value that we call the _constructor function_.
This is the function that is called when we `new` up instances of the class.
To see what this looks like in practice, let‚Äôs take a look at the JavaScript
created by the above example:

    
    
    ts
    
    let Greeter = (function () {
    
      function Greeter(message) {
    
        this.greeting = message;
    
      }
    
    ¬†
    
      Greeter.prototype.greet = function () {
    
        return "Hello, " + this.greeting;
    
      };
    
    ¬†
    
      return Greeter;
    
    })();
    
    ¬†
    
    let greeter;
    
    greeter = new Greeter("world");
    
    console.log(greeter.greet()); // "Hello, world"
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgDiseJesoAvKABToCuAdsvAPZtMCUoAN4FQGdpx7lK1WIwC2eSJEwBzPAOGjR0ABbxIAOhXTo8NivqgFS1XgDcI0AF8CjilWg0DAB1hdo-gCe3nhGJpasHKaSjBqOopTQLLC8AEQAEnjY2FwANKCpoADUoLr6YR5mKg6iTg6Oicm87jIOTnyx9cSkxh40Dr0ylmx4AO5SfbKpo1yw2AAmqXwOiDyQXMQGOSqMg56wFSSxy6AgBZnZeaAzc4tAA)

Here, `let Greeter` is going to be assigned the constructor function. When we
call `new` and run this function, we get an instance of the class. The
constructor function also contains all of the static members of the class.
Another way to think of each class is that there is an _instance_ side and a
_static_ side.

Let‚Äôs modify the example a bit to show this difference:

    
    
    ts
    
    class Greeter {
    
      static standardGreeting = "Hello, there";
    
      greeting: string;
    
      greet() {
    
        if (this.greeting) {
    
          return "Hello, " + this.greeting;
    
        } else {
    
          return Greeter.standardGreeting;
    
        }
    
      }
    
    }
    
    ¬†
    
    let greeter1: Greeter;
    
    greeter1 = new Greeter();
    
    console.log(greeter1.greet()); // "Hello, there"
    
    ¬†
    
    let greeterMaker: typeof Greeter = Greeter;
    
    greeterMaker.standardGreeting = "Hey there!";
    
    ¬†
    
    let greeter2: Greeter = new greeterMaker();
    
    console.log(greeter2.greet()); // "Hey there!"
    
    ¬†
    
    let greeter3: Greeter;
    
    greeter3 = new Greeter();
    
    console.log(greeter3.greet()); // "Hey there!"
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDisee0esoA3gaKDJtEm9JgHYAmmWPyo1OvAOagAvKABEACTzZsAewA0oaAAt6eOQG4WoCdVrxJaGAklHWpsQAoAlE2Ot46UI53xIAOgdzSVdmVnDQamgAV1heeSUVDXlQAGotbT9As3EJO3CAX1BlfDcI1ijY+NFaen92ASERHIs891AC407OgmxaExz6AEY0GrpYIyDxoZlQXjwAd0pB2BcjRFVeSFU+-zUJRynh7KdnZwNQEATlNU0dPTkCXv6j2ABZTABrejRoAE8AA54VReMb0WZgiYEV4fb6weo8RrCMatWaKPB-DJ6ACEhiefWgAzE9AATKMVrN5ksYV96GsiJttrt9ocViSTrQXOdLmB0Zj7tRcfiXisAMzk4lQ16iymLZaS+kbLY7PB7VQHaUc6Bci5XPlYwVyIA)

In this example, `greeter1` works similarly to before. We instantiate the
`Greeter` class, and use this object. This we have seen before.

Next, we then use the class directly. Here we create a new variable called
`greeterMaker`. This variable will hold the class itself, or said another way
its constructor function. Here we use `typeof Greeter`, that is ‚Äúgive me the
type of the `Greeter` class itself‚Äù rather than the instance type. Or, more
precisely, ‚Äúgive me the type of the symbol called `Greeter`,‚Äù which is the
type of the constructor function. This type will contain all of the static
members of Greeter along with the constructor that creates instances of the
`Greeter` class. We show this by using `new` on `greeterMaker`, creating new
instances of `Greeter` and invoking them as before. It is also good to mention
that changing static property is frowned upon, here `greeter3` has `"Hey
there!"` instead of `"Hello, there"` on `standardGreeting`.

## Using a class as an interface

As we said in the previous section, a class declaration creates two things: a
type representing instances of the class and a constructor function. Because
classes create types, you can use them in the same places you would be able to
use interfaces.

    
    
    ts
    
    class Point {
    
      x: number;
    
      y: number;
    
    }
    
    ¬†
    
    interface Point3d extends Point {
    
      z: number;
    
    }
    
    ¬†
    
    let point3d: Point3d = { x: 1, y: 2, z: 3 };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgAKA9vAHbSgDeBooAHmrQK4C2ARnlgBuFqACenXgOEEAvgQJ1ogrIjyUa9AMwATUHjbLaO8tSVNRAL0n9BI+QWx4GAB03RdaM9r0BeJuxoAIwANOJoAExh1qBaoLJCQA)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Classes.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(53\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DR![Daniel Rosenwasser
\(27\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

OT![Orta Therox
\(21\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nathan Shively-Sanders
\(8\)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)

BW![Brice Wilson
\(5\)](https://gravatar.com/avatar/e1dfaa389348fc04d0807cc3d6252491?s=32&&d=blank)

25+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Compiler Options in MSBuild

## Overview

When you have an MSBuild based project which utilizes TypeScript such as an
ASP.NET Core project, you can configure TypeScript in two ways. Either via a
`tsconfig.json` or via the project settings.

## Using a `tsconfig.json`

We recommend using a `tsconfig.json` for your project when possible. To add
one to an existing project, add a new item to your project which is called a
‚ÄúTypeScript JSON Configuration File‚Äù in modern versions of Visual Studio.

The new `tsconfig.json` will then be used as the source of truth for
TypeScript-specific build information like files and configuration. You can
learn [about how TSConfigs works here](/docs/handbook/tsconfig-json.html) and
there is a [comprehensive reference here](/tsconfig).

## Using Project Settings

You can also define the configuration for TypeScript inside you project‚Äôs
settings. This is done by editing the XML in your `.csproj` to define
`PropertyGroups` which describe how the build can work:

    
    
    xml
    
    <PropertyGroup>
    
      <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>
    
      <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>
    
    </PropertyGroup>

There is a series of mappings for common TypeScript settings, these are
settings which map directly to [TypeScript cli
options](/docs/handbook/compiler-options.html) and are used to help you write
a more understandable project file. You can use the [TSConfig
reference](/tsconfig) to get more information on what values and defaults are
for each mapping.

### CLI Mappings

MSBuild Config Name | TSC Flag  
---|---  
`<TypeScriptAllowJS>` | `[--allowJs](/tsconfig/#allowJs)`  
Allow JavaScript files to be a part of your program. Use the `checkJS` option
to get errors from these files.  
`<TypeScriptRemoveComments>` | `[--removeComments](/tsconfig/#removeComments)`  
Disable emitting comments.  
`<TypeScriptNoImplicitAny>` | `[--noImplicitAny](/tsconfig/#noImplicitAny)`  
Enable error reporting for expressions and declarations with an implied `any`
type..  
`<TypeScriptGeneratesDeclarations>` | `[--declaration](/tsconfig/#declaration)`  
Generate .d.ts files from TypeScript and JavaScript files in your project.  
`<TypeScriptModuleKind>` | `[--module](/tsconfig/#module)`  
Specify what module code is generated.  
`<TypeScriptJSXEmit>` | `[--jsx](/tsconfig/#jsx)`  
Specify what JSX code is generated.  
`<TypeScriptOutDir>` | `[--outDir](/tsconfig/#outDir)`  
Specify an output folder for all emitted files.  
`<TypeScriptSourceMap>` | `[--sourcemap](/tsconfig/#sourcemap)`  
Create source map files for emitted JavaScript files.  
`<TypeScriptTarget>` | `[--target](/tsconfig/#target)`  
Set the JavaScript language version for emitted JavaScript and include
compatible library declarations.  
`<TypeScriptNoResolve>` | `[--noResolve](/tsconfig/#noResolve)`  
Disallow `import`s, `require`s or `<reference>`s from expanding the number of
files TypeScript should add to a project.  
`<TypeScriptMapRoot>` | `[--mapRoot](/tsconfig/#mapRoot)`  
Specify the location where debugger should locate map files instead of
generated locations.  
`<TypeScriptSourceRoot>` | `[--sourceRoot](/tsconfig/#sourceRoot)`  
Specify the root path for debuggers to find the reference source code.  
`<TypeScriptCharset>` | `[--charset](/tsconfig/#charset)`  
No longer supported. In early versions, manually set the text encoding for
reading files.  
`<TypeScriptEmitBOM>` | `[--emitBOM](/tsconfig/#emitBOM)`  
Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.  
`<TypeScriptNoLib>` | `[--noLib](/tsconfig/#noLib)`  
Disable including any library files, including the default lib.d.ts.  
`<TypeScriptPreserveConstEnums>` | `[--preserveConstEnums](/tsconfig/#preserveConstEnums)`  
Disable erasing `const enum` declarations in generated code.  
`<TypeScriptSuppressImplicitAnyIndexErrors>` | `[--suppressImplicitAnyIndexErrors](/tsconfig/#suppressImplicitAnyIndexErrors)`  
Suppress `noImplicitAny` errors when indexing objects that lack index
signatures.  
`<TypeScriptNoEmitHelpers>` | `[--noEmitHelpers](/tsconfig/#noEmitHelpers)`  
Disable generating custom helper functions like `__extends` in compiled
output.  
`<TypeScriptInlineSourceMap>` | `[--inlineSourceMap](/tsconfig/#inlineSourceMap)`  
Include sourcemap files inside the emitted JavaScript.  
`<TypeScriptInlineSources>` | `[--inlineSources](/tsconfig/#inlineSources)`  
Include source code in the sourcemaps inside the emitted JavaScript.  
`<TypeScriptNewLine>` | `[--newLine](/tsconfig/#newLine)`  
Set the newline character for emitting files.  
`<TypeScriptIsolatedModules>` | `[--isolatedModules](/tsconfig/#isolatedModules)`  
Ensure that each file can be safely transpiled without relying on other
imports.  
`<TypeScriptEmitDecoratorMetadata>` | `[--emitDecoratorMetadata](/tsconfig/#emitDecoratorMetadata)`  
Emit design-type metadata for decorated declarations in source files.  
`<TypeScriptRootDir>` | `[--rootDir](/tsconfig/#rootDir)`  
Specify the root folder within your source files.  
`<TypeScriptExperimentalDecorators>` | `[--experimentalDecorators](/tsconfig/#experimentalDecorators)`  
Enable experimental support for TC39 stage 2 draft decorators.  
`<TypeScriptModuleResolution>` | `[--moduleResolution](/tsconfig/#moduleResolution)`  
Specify how TypeScript looks up a file from a given module specifier.  
`<TypeScriptSuppressExcessPropertyErrors>` | `[--suppressExcessPropertyErrors](/tsconfig/#suppressExcessPropertyErrors)`  
Disable reporting of excess property errors during the creation of object
literals.  
`<TypeScriptReactNamespace>` | `[--reactNamespace](/tsconfig/#reactNamespace)`  
Specify the object invoked for `createElement`. This only applies when
targeting `react` JSX emit.  
`<TypeScriptSkipDefaultLibCheck>` | `[--skipDefaultLibCheck](/tsconfig/#skipDefaultLibCheck)`  
Skip type checking .d.ts files that are included with TypeScript.  
`<TypeScriptAllowUnusedLabels>` | `[--allowUnusedLabels](/tsconfig/#allowUnusedLabels)`  
Disable error reporting for unused labels.  
`<TypeScriptNoImplicitReturns>` | `[--noImplicitReturns](/tsconfig/#noImplicitReturns)`  
Enable error reporting for codepaths that do not explicitly return in a
function.  
`<TypeScriptNoFallthroughCasesInSwitch>` | `[--noFallthroughCasesInSwitch](/tsconfig/#noFallthroughCasesInSwitch)`  
Enable error reporting for fallthrough cases in switch statements.  
`<TypeScriptAllowUnreachableCode>` | `[--allowUnreachableCode](/tsconfig/#allowUnreachableCode)`  
Disable error reporting for unreachable code.  
`<TypeScriptForceConsistentCasingInFileNames>` | `[--forceConsistentCasingInFileNames](/tsconfig/#forceConsistentCasingInFileNames)`  
Ensure that casing is correct in imports.  
`<TypeScriptAllowSyntheticDefaultImports>` | `[--allowSyntheticDefaultImports](/tsconfig/#allowSyntheticDefaultImports)`  
Allow 'import x from y' when a module doesn't have a default export.  
`<TypeScriptNoImplicitUseStrict>` | `[--noImplicitUseStrict](/tsconfig/#noImplicitUseStrict)`  
Disable adding 'use strict' directives in emitted JavaScript files.  
`<TypeScriptLib>` | `[--lib](/tsconfig/#lib)`  
Specify a set of bundled library declaration files that describe the target
runtime environment.  
`<TypeScriptBaseUrl>` | `[--baseUrl](/tsconfig/#baseUrl)`  
Specify the base directory to resolve bare specifier module names.  
`<TypeScriptDeclarationDir>` | `[--declarationDir](/tsconfig/#declarationDir)`  
Specify the output directory for generated declaration files.  
`<TypeScriptNoImplicitThis>` | `[--noImplicitThis](/tsconfig/#noImplicitThis)`  
Enable error reporting when `this` is given the type `any`.  
`<TypeScriptSkipLibCheck>` | `[--skipLibCheck](/tsconfig/#skipLibCheck)`  
Skip type checking all .d.ts files.  
`<TypeScriptStrictNullChecks>` | `[--strictNullChecks](/tsconfig/#strictNullChecks)`  
When type checking, take into account `null` and `undefined`.  
`<TypeScriptNoUnusedLocals>` | `[--noUnusedLocals](/tsconfig/#noUnusedLocals)`  
Enable error reporting when a local variables aren't read.  
`<TypeScriptNoUnusedParameters>` | `[--noUnusedParameters](/tsconfig/#noUnusedParameters)`  
Raise an error when a function parameter isn't read  
`<TypeScriptAlwaysStrict>` | `[--alwaysStrict](/tsconfig/#alwaysStrict)`  
Ensure 'use strict' is always emitted.  
`<TypeScriptImportHelpers>` | `[--importHelpers](/tsconfig/#importHelpers)`  
Allow importing helper functions from tslib once per project, instead of
including them per-file.  
`<TypeScriptJSXFactory>` | `[--jsxFactory](/tsconfig/#jsxFactory)`  
Specify the JSX factory function used when targeting React JSX emit, e.g.
'React.createElement' or 'h'  
`<TypeScriptStripInternal>` | `[--stripInternal](/tsconfig/#stripInternal)`  
Disable emitting declarations that have `@internal` in their JSDoc comments.  
`<TypeScriptCheckJs>` | `[--checkJs](/tsconfig/#checkJs)`  
Enable error reporting in type-checked JavaScript files.  
`<TypeScriptDownlevelIteration>` | `[--downlevelIteration](/tsconfig/#downlevelIteration)`  
Emit more compliant, but verbose and less performant JavaScript for iteration.  
`<TypeScriptStrict>` | `[--strict](/tsconfig/#strict)`  
Enable all strict type checking options.  
`<TypeScriptNoStrictGenericChecks>` | `[--noStrictGenericChecks](/tsconfig/#noStrictGenericChecks)`  
Disable strict checking of generic signatures in function types.  
`<TypeScriptPreserveSymlinks>` | `[--preserveSymlinks](/tsconfig/#preserveSymlinks)`  
Disable resolving symlinks to their realpath. This correlates to the same flag
in node.  
`<TypeScriptStrictFunctionTypes>` | `[--strictFunctionTypes](/tsconfig/#strictFunctionTypes)`  
When assigning functions, check to ensure parameters and the return values are
subtype-compatible.  
`<TypeScriptStrictPropertyInitialization>` | `[--strictPropertyInitialization](/tsconfig/#strictPropertyInitialization)`  
Check for class properties that are declared but not set in the constructor.  
`<TypeScriptESModuleInterop>` | `[--esModuleInterop](/tsconfig/#esModuleInterop)`  
Emit additional JavaScript to ease support for importing CommonJS modules.
This enables `allowSyntheticDefaultImports` for type compatibility.  
`<TypeScriptEmitDeclarationOnly>` | `[--emitDeclarationOnly](/tsconfig/#emitDeclarationOnly)`  
Only output d.ts files and not JavaScript files.  
`<TypeScriptKeyofStringsOnly>` | `[--keyofStringsOnly](/tsconfig/#keyofStringsOnly)`  
Make keyof only return strings instead of string, numbers or symbols. Legacy
option.  
`<TypeScriptUseDefineForClassFields>` | `[--useDefineForClassFields](/tsconfig/#useDefineForClassFields)`  
Emit ECMAScript-standard-compliant class fields.  
`<TypeScriptDeclarationMap>` | `[--declarationMap](/tsconfig/#declarationMap)`  
Create sourcemaps for d.ts files.  
`<TypeScriptResolveJsonModule>` | `[--resolveJsonModule](/tsconfig/#resolveJsonModule)`  
Enable importing .json files  
`<TypeScriptStrictBindCallApply>` | `[--strictBindCallApply](/tsconfig/#strictBindCallApply)`  
Check that the arguments for `bind`, `call`, and `apply` methods match the
original function.  
`<TypeScriptNoEmitOnError>` | `[--noEmitOnError](/tsconfig/#noEmitOnError)`  
Disable emitting files if any type checking errors are reported.  
  
### Additional Flags

Because the MSBuild system passes arguments directly to the TypeScript CLI,
you can use the option `TypeScriptAdditionalFlags` to provide specific flags
which don‚Äôt have a mapping above.

For example, this would turn on
[`noPropertyAccessFromIndexSignature`](/tsconfig#noPropertyAccessFromIndexSignature):

    
    
    xml
    
    <TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>

### Debug and Release Builds

You can use PropertyGroup conditions to define different sets of
configurations. For example, a common task is stripping comments and
sourcemaps in production. In this example, we define a debug and release
property group which have different TypeScript configurations:

    
    
    xml
    
    <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
    
      <TypeScriptRemoveComments>false</TypeScriptRemoveComments>
    
      <TypeScriptSourceMap>true</TypeScriptSourceMap>
    
    </PropertyGroup>
    
    <PropertyGroup Condition="'$(Configuration)' == 'Release'">
    
      <TypeScriptRemoveComments>true</TypeScriptRemoveComments>
    
      <TypeScriptSourceMap>false</TypeScriptSourceMap>
    
    </PropertyGroup>
    
    <Import
    
        Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
    
        Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" />

### ToolsVersion

The value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property
in the project file identifies the compiler version to use to build (1.7 in
this example). This allows a project to build against the same versions of the
compiler on different machines.

If `TypeScriptToolsVersion` is not specified, the latest compiler version
installed on the machine will be used to build.

Users using newer versions of TS, will see a prompt to upgrade their project
on first load.

### TypeScriptCompileBlocked

If you are using a different build tool to build your project (e.g. gulp,
grunt , etc.) and VS for the development and debugging experience, set
`<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project.
This should give you all the editing support, but not the build when you hit
F5.

### TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)

By default, MSBuild will attempt to only run the TypeScript compiler when the
project‚Äôs source files have been updated since the last compilation. However,
if this behavior is causing issues, such as when TypeScript‚Äôs
[`incremental`](/tsconfig#incremental) option is enabled, set
`<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>`
to ensure the TypeScript compiler is invoked with every run of MSBuild.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Compiler Options
in MSBuild.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(62\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(18\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

Y![Yui
\(4\)](https://gravatar.com/avatar/c43ddeea6c2575b4f28e8e8107222501?s=32&&d=blank)

DR![Daniel Rosenwasser
\(4\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

BL![Ben Lichtman
\(2\)](https://gravatar.com/avatar/2b51f2f83270041e14fa2b3c241778f6?s=32&&d=blank)

13+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# tsc CLI Options

## Using the CLI

Running `tsc` locally will compile the closest project defined by a
`tsconfig.json`, or you can compile a set of TypeScript files by passing in a
glob of files you want. When input files are specified on the command line,
`tsconfig.json` files are ignored.

    
    
    sh
    
    # Run a compile based on a backwards look through the fs for a tsconfig.json
    
    tsc
    
    # Emit JS for just the index.ts with the compiler defaults
    
    tsc index.ts
    
    # Emit JS for any .ts files in the folder src, with the default settings
    
    tsc src/*.ts
    
    # Emit files referenced in with the compiler settings from tsconfig.production.json
    
    tsc --project tsconfig.production.json
    
    # Emit d.ts files for a js file with showing compiler options which are booleans
    
    tsc index.js --declaration --emitDeclarationOnly
    
    # Emit a single .js file from two files via compiler options which take string arguments
    
    tsc app.ts util.ts --target esnext --outfile index.js

## Compiler Options

**If you‚Äôre looking for more information about the compiler options in a
tsconfig, check out the[TSConfig Reference](/tsconfig)**

### CLI Commands

Flag | Type  
---|---  
`--all` | `boolean`  
Show all compiler options.  
`--help` | `boolean`  
Gives local information for help on the CLI.  
`--init` | `boolean`  
Initializes a TypeScript project and creates a tsconfig.json file.  
`--listFilesOnly` | `boolean`  
Print names of files that are part of the compilation and then stop
processing.  
`--locale` | `string`  
Set the language of the messaging from TypeScript. This does not affect emit.  
`--project` | `string`  
Compile the project given the path to its configuration file, or to a folder
with a 'tsconfig.json'.  
`--showConfig` | `boolean`  
Print the final configuration instead of building.  
`--version` | `boolean`  
Print the compiler's version.  
  
### Build Options

Flag | Type  
---|---  
`--build` | `boolean`  
Build one or more projects and their dependencies, if out of date  
`--clean` | `boolean`  
Delete the outputs of all projects.  
`--dry` | `boolean`  
Show what would be built (or deleted, if specified with '--clean')  
`[--force](/tsconfig/#force)` | `boolean`  
Build all projects, including those that appear to be up to date.  
`[--verbose](/tsconfig/#verbose)` | `boolean`  
Enable verbose logging.  
  
### Watch Options

Flag | Type  
---|---  
`[--excludeDirectories](/tsconfig/#excludeDirectories)` | `list`  
Remove a list of directories from the watch process.  
`[--excludeFiles](/tsconfig/#excludeFiles)` | `list`  
Remove a list of files from the watch mode's processing.  
`[--fallbackPolling](/tsconfig/#fallbackPolling)` | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize`  
Specify what approach the watcher should use if the system runs out of native
file watchers.  
`[--synchronousWatchDirectory](/tsconfig/#synchronousWatchDirectory)` | `boolean`  
Synchronously call callbacks and update the state of directory watchers on
platforms that don`t support recursive watching natively.  
`--watch` | `boolean`  
Watch input files.  
`[--watchDirectory](/tsconfig/#watchDirectory)` | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling`  
Specify how directories are watched on systems that lack recursive file-
watching functionality.  
`[--watchFile](/tsconfig/#watchFile)` | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory`  
Specify how the TypeScript watch mode works.  
  
### Compiler Flags

Flag | Type | Default  
---|---|---  
`[--allowArbitraryExtensions](/tsconfig/#allowArbitraryExtensions)` | `boolean` | `false`  
Enable importing files with any extension, provided a declaration file is
present.  
`[--allowImportingTsExtensions](/tsconfig/#allowImportingTsExtensions)` | `boolean` | `false`  
Allow imports to include TypeScript file extensions.  
`[--allowJs](/tsconfig/#allowJs)` | `boolean` | `false`  
Allow JavaScript files to be a part of your program. Use the `checkJS` option
to get errors from these files.  
`[--allowSyntheticDefaultImports](/tsconfig/#allowSyntheticDefaultImports)` | `boolean` | `true` if `esModuleInterop` is enabled, `module` is `system`, or `moduleResolution` is `bundler`; `false` otherwise.  
Allow 'import x from y' when a module doesn't have a default export.  
`[--allowUmdGlobalAccess](/tsconfig/#allowUmdGlobalAccess)` | `boolean` | `false`  
Allow accessing UMD globals from modules.  
`[--allowUnreachableCode](/tsconfig/#allowUnreachableCode)` | `boolean` |   
Disable error reporting for unreachable code.  
`[--allowUnusedLabels](/tsconfig/#allowUnusedLabels)` | `boolean` |   
Disable error reporting for unused labels.  
`[--alwaysStrict](/tsconfig/#alwaysStrict)` | `boolean` | `true` if `strict`; `false` otherwise.  
Ensure 'use strict' is always emitted.  
`[--assumeChangesOnlyAffectDirectDependencies](/tsconfig/#assumeChangesOnlyAffectDirectDependencies)` | `boolean` | `false`  
Have recompiles in projects that use `incremental` and `watch` mode assume
that changes within a file will only affect files directly depending on it.  
`[--baseUrl](/tsconfig/#baseUrl)` | `string` |   
Specify the base directory to resolve bare specifier module names.  
`[--charset](/tsconfig/#charset)` | `string` | `utf8`  
No longer supported. In early versions, manually set the text encoding for
reading files.  
`[--checkJs](/tsconfig/#checkJs)` | `boolean` | `false`  
Enable error reporting in type-checked JavaScript files.  
`[--composite](/tsconfig/#composite)` | `boolean` | `false`  
Enable constraints that allow a TypeScript project to be used with project
references.  
`[--customConditions](/tsconfig/#customConditions)` | `list` |   
Conditions to set in addition to the resolver-specific defaults when resolving
imports.  
`[--declaration](/tsconfig/#declaration)` | `boolean` | `true` if `composite`; `false` otherwise.  
Generate .d.ts files from TypeScript and JavaScript files in your project.  
`[--declarationDir](/tsconfig/#declarationDir)` | `string` |   
Specify the output directory for generated declaration files.  
`[--declarationMap](/tsconfig/#declarationMap)` | `boolean` | `false`  
Create sourcemaps for d.ts files.  
`[--diagnostics](/tsconfig/#diagnostics)` | `boolean` | `false`  
Output compiler performance information after building.  
`[--disableReferencedProjectLoad](/tsconfig/#disableReferencedProjectLoad)` | `boolean` | `false`  
Reduce the number of projects loaded automatically by TypeScript.  
`[--disableSizeLimit](/tsconfig/#disableSizeLimit)` | `boolean` | `false`  
Remove the 20mb cap on total source code size for JavaScript files in the
TypeScript language server.  
`[--disableSolutionSearching](/tsconfig/#disableSolutionSearching)` | `boolean` | `false`  
Opt a project out of multi-project reference checking when editing.  
`[--disableSourceOfProjectReferenceRedirect](/tsconfig/#disableSourceOfProjectReferenceRedirect)` | `boolean` | `false`  
Disable preferring source files instead of declaration files when referencing
composite projects.  
`[--downlevelIteration](/tsconfig/#downlevelIteration)` | `boolean` | `false`  
Emit more compliant, but verbose and less performant JavaScript for iteration.  
`[--emitBOM](/tsconfig/#emitBOM)` | `boolean` | `false`  
Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.  
`[--emitDeclarationOnly](/tsconfig/#emitDeclarationOnly)` | `boolean` | `false`  
Only output d.ts files and not JavaScript files.  
`[--emitDecoratorMetadata](/tsconfig/#emitDecoratorMetadata)` | `boolean` | `false`  
Emit design-type metadata for decorated declarations in source files.  
`[--esModuleInterop](/tsconfig/#esModuleInterop)` | `boolean` | `true` if `module` is `node16` or `nodenext`; `false` otherwise.  
Emit additional JavaScript to ease support for importing CommonJS modules.
This enables `allowSyntheticDefaultImports` for type compatibility.  
`[--exactOptionalPropertyTypes](/tsconfig/#exactOptionalPropertyTypes)` | `boolean` | `false`  
Interpret optional property types as written, rather than adding `undefined`.  
`[--experimentalDecorators](/tsconfig/#experimentalDecorators)` | `boolean` | `false`  
Enable experimental support for TC39 stage 2 draft decorators.  
`[--explainFiles](/tsconfig/#explainFiles)` | `boolean` | `false`  
Print files read during the compilation including why it was included.  
`[--extendedDiagnostics](/tsconfig/#extendedDiagnostics)` | `boolean` | `false`  
Output more detailed compiler performance information after building.  
`[--forceConsistentCasingInFileNames](/tsconfig/#forceConsistentCasingInFileNames)` | `boolean` | `true`  
Ensure that casing is correct in imports.  
`[--generateCpuProfile](/tsconfig/#generateCpuProfile)` | `string` | `profile.cpuprofile`  
Emit a v8 CPU profile of the compiler run for debugging.  
`[--generateTrace](/tsconfig/#generateTrace)` | `string` |   
Generates an event trace and a list of types.  
`[--importHelpers](/tsconfig/#importHelpers)` | `boolean` | `false`  
Allow importing helper functions from tslib once per project, instead of
including them per-file.  
`[--importsNotUsedAsValues](/tsconfig/#importsNotUsedAsValues)` | `remove`, `preserve`, or `error` | `remove`  
Specify emit/checking behavior for imports that are only used for types.  
`[--incremental](/tsconfig/#incremental)` | `boolean` | `true` if `composite`; `false` otherwise.  
Save .tsbuildinfo files to allow for incremental compilation of projects.  
`[--inlineSourceMap](/tsconfig/#inlineSourceMap)` | `boolean` | `false`  
Include sourcemap files inside the emitted JavaScript.  
`[--inlineSources](/tsconfig/#inlineSources)` | `boolean` | `false`  
Include source code in the sourcemaps inside the emitted JavaScript.  
`[--isolatedDeclarations](/tsconfig/#isolatedDeclarations)` | `boolean` | `false`  
Require sufficient annotation on exports so other tools can trivially generate
declaration files.  
`[--isolatedModules](/tsconfig/#isolatedModules)` | `boolean` | `true` if `verbatimModuleSyntax`; `false` otherwise.  
Ensure that each file can be safely transpiled without relying on other
imports.  
`[--jsx](/tsconfig/#jsx)` | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev` |   
Specify what JSX code is generated.  
`[--jsxFactory](/tsconfig/#jsxFactory)` | `string` | `React.createElement`  
Specify the JSX factory function used when targeting React JSX emit, e.g.
'React.createElement' or 'h'.  
`[--jsxFragmentFactory](/tsconfig/#jsxFragmentFactory)` | `string` | `React.Fragment`  
Specify the JSX Fragment reference used for fragments when targeting React JSX
emit e.g. 'React.Fragment' or 'Fragment'.  
`[--jsxImportSource](/tsconfig/#jsxImportSource)` | `string` | `react`  
Specify module specifier used to import the JSX factory functions when using
`jsx: react-jsx*`.  
`[--keyofStringsOnly](/tsconfig/#keyofStringsOnly)` | `boolean` | `false`  
Make keyof only return strings instead of string, numbers or symbols. Legacy
option.  
`[--lib](/tsconfig/#lib)` | `list` |   
Specify a set of bundled library declaration files that describe the target
runtime environment.  
`[--listEmittedFiles](/tsconfig/#listEmittedFiles)` | `boolean` | `false`  
Print the names of emitted files after a compilation.  
`[--listFiles](/tsconfig/#listFiles)` | `boolean` | `false`  
Print all of the files read during the compilation.  
`[--mapRoot](/tsconfig/#mapRoot)` | `string` |   
Specify the location where debugger should locate map files instead of
generated locations.  
`[--maxNodeModuleJsDepth](/tsconfig/#maxNodeModuleJsDepth)` | `number` | `0`  
Specify the maximum folder depth used for checking JavaScript files from
`node_modules`. Only applicable with `allowJs`.  
`[--module](/tsconfig/#module)` | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `nodenext`, or `preserve` | `CommonJS` if `target` is `ES5`; `ES6`/`ES2015` otherwise.  
Specify what module code is generated.  
`[--moduleDetection](/tsconfig/#moduleDetection)` | `legacy`, `auto`, or `force` | "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.  
Specify what method is used to detect whether a file is a script or a module.  
`[--moduleResolution](/tsconfig/#moduleResolution)` | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler` | `Classic` if `module` is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if `module` is `node16` or `nodenext`; `Node` otherwise.  
Specify how TypeScript looks up a file from a given module specifier.  
`[--moduleSuffixes](/tsconfig/#moduleSuffixes)` | `list` |   
List of file name suffixes to search when resolving a module.  
`[--newLine](/tsconfig/#newLine)` | `crlf` or `lf` | `lf`  
Set the newline character for emitting files.  
`[--noCheck](/tsconfig/#noCheck)` | `boolean` | `false`  
Disable full type checking (only critical parse and emit errors will be
reported).  
`[--noEmit](/tsconfig/#noEmit)` | `boolean` | `false`  
Disable emitting files from a compilation.  
`[--noEmitHelpers](/tsconfig/#noEmitHelpers)` | `boolean` | `false`  
Disable generating custom helper functions like `__extends` in compiled
output.  
`[--noEmitOnError](/tsconfig/#noEmitOnError)` | `boolean` | `false`  
Disable emitting files if any type checking errors are reported.  
`[--noErrorTruncation](/tsconfig/#noErrorTruncation)` | `boolean` | `false`  
Disable truncating types in error messages.  
`[--noFallthroughCasesInSwitch](/tsconfig/#noFallthroughCasesInSwitch)` | `boolean` | `false`  
Enable error reporting for fallthrough cases in switch statements.  
`[--noImplicitAny](/tsconfig/#noImplicitAny)` | `boolean` | `true` if `strict`; `false` otherwise.  
Enable error reporting for expressions and declarations with an implied `any`
type.  
`[--noImplicitOverride](/tsconfig/#noImplicitOverride)` | `boolean` | `false`  
Ensure overriding members in derived classes are marked with an override
modifier.  
`[--noImplicitReturns](/tsconfig/#noImplicitReturns)` | `boolean` | `false`  
Enable error reporting for codepaths that do not explicitly return in a
function.  
`[--noImplicitThis](/tsconfig/#noImplicitThis)` | `boolean` | `true` if `strict`; `false` otherwise.  
Enable error reporting when `this` is given the type `any`.  
`[--noImplicitUseStrict](/tsconfig/#noImplicitUseStrict)` | `boolean` | `false`  
Disable adding 'use strict' directives in emitted JavaScript files.  
`[--noLib](/tsconfig/#noLib)` | `boolean` | `false`  
Disable including any library files, including the default lib.d.ts.  
`[--noPropertyAccessFromIndexSignature](/tsconfig/#noPropertyAccessFromIndexSignature)` | `boolean` | `false`  
Enforces using indexed accessors for keys declared using an indexed type.  
`[--noResolve](/tsconfig/#noResolve)` | `boolean` | `false`  
Disallow `import`s, `require`s or `<reference>`s from expanding the number of
files TypeScript should add to a project.  
`[--noStrictGenericChecks](/tsconfig/#noStrictGenericChecks)` | `boolean` | `false`  
Disable strict checking of generic signatures in function types.  
`[--noUncheckedIndexedAccess](/tsconfig/#noUncheckedIndexedAccess)` | `boolean` | `false`  
Add `undefined` to a type when accessed using an index.  
`[--noUncheckedSideEffectImports](/tsconfig/#noUncheckedSideEffectImports)` | `boolean` | `false`  
Check side effect imports.  
`[--noUnusedLocals](/tsconfig/#noUnusedLocals)` | `boolean` | `false`  
Enable error reporting when local variables aren't read.  
`[--noUnusedParameters](/tsconfig/#noUnusedParameters)` | `boolean` | `false`  
Raise an error when a function parameter isn't read.  
`[--out](/tsconfig/#out)` | `string` |   
Deprecated setting. Use `outFile` instead.  
`[--outDir](/tsconfig/#outDir)` | `string` |   
Specify an output folder for all emitted files.  
`[--outFile](/tsconfig/#outFile)` | `string` |   
Specify a file that bundles all outputs into one JavaScript file. If
`declaration` is true, also designates a file that bundles all .d.ts output.  
`[--paths](/tsconfig/#paths)` | `object` |   
Specify a set of entries that re-map imports to additional lookup locations.  
`[--plugins](/tsconfig/#plugins)` | `list` |   
Specify a list of language service plugins to include.  
`[--preserveConstEnums](/tsconfig/#preserveConstEnums)` | `boolean` | `true` if `isolatedModules`; `false` otherwise.  
Disable erasing `const enum` declarations in generated code.  
`[--preserveSymlinks](/tsconfig/#preserveSymlinks)` | `boolean` | `false`  
Disable resolving symlinks to their realpath. This correlates to the same flag
in node.  
`[--preserveValueImports](/tsconfig/#preserveValueImports)` | `boolean` | `false`  
Preserve unused imported values in the JavaScript output that would otherwise
be removed.  
`[--preserveWatchOutput](/tsconfig/#preserveWatchOutput)` | `boolean` | `false`  
Disable wiping the console in watch mode.  
`[--pretty](/tsconfig/#pretty)` | `boolean` | `true`  
Enable color and formatting in TypeScript's output to make compiler errors
easier to read.  
`[--reactNamespace](/tsconfig/#reactNamespace)` | `string` | `React`  
Specify the object invoked for `createElement`. This only applies when
targeting `react` JSX emit.  
`[--removeComments](/tsconfig/#removeComments)` | `boolean` | `false`  
Disable emitting comments.  
`[--resolveJsonModule](/tsconfig/#resolveJsonModule)` | `boolean` | `false`  
Enable importing .json files.  
`[--resolvePackageJsonExports](/tsconfig/#resolvePackageJsonExports)` | `boolean` | `true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`; otherwise `false`  
Use the package.json 'exports' field when resolving package imports.  
`[--resolvePackageJsonImports](/tsconfig/#resolvePackageJsonImports)` | `boolean` | `true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`; otherwise `false`  
Use the package.json 'imports' field when resolving imports.  
`[--rootDir](/tsconfig/#rootDir)` | `string` | Computed from the list of input files.  
Specify the root folder within your source files.  
`[--rootDirs](/tsconfig/#rootDirs)` | `list` | Computed from the list of input files.  
Allow multiple folders to be treated as one when resolving modules.  
`[--skipDefaultLibCheck](/tsconfig/#skipDefaultLibCheck)` | `boolean` | `false`  
Skip type checking .d.ts files that are included with TypeScript.  
`[--skipLibCheck](/tsconfig/#skipLibCheck)` | `boolean` | `false`  
Skip type checking all .d.ts files.  
`[--sourceMap](/tsconfig/#sourceMap)` | `boolean` | `false`  
Create source map files for emitted JavaScript files.  
`[--sourceRoot](/tsconfig/#sourceRoot)` | `string` |   
Specify the root path for debuggers to find the reference source code.  
`[--stopBuildOnErrors](/tsconfig/#stopBuildOnErrors)` | `boolean` |   
Skip building downstream projects on error in upstream project.  
`[--strict](/tsconfig/#strict)` | `boolean` | `false`  
Enable all strict type-checking options.  
`[--strictBindCallApply](/tsconfig/#strictBindCallApply)` | `boolean` | `true` if `strict`; `false` otherwise.  
Check that the arguments for `bind`, `call`, and `apply` methods match the
original function.  
`[--strictBuiltinIteratorReturn](/tsconfig/#strictBuiltinIteratorReturn)` | `boolean` | `false`, unless `strict` is set  
Built-in iterators are instantiated with a TReturn type of undefined instead
of any.  
`[--strictFunctionTypes](/tsconfig/#strictFunctionTypes)` | `boolean` | `true` if `strict`; `false` otherwise.  
When assigning functions, check to ensure parameters and the return values are
subtype-compatible.  
`[--strictNullChecks](/tsconfig/#strictNullChecks)` | `boolean` | `true` if `strict`; `false` otherwise.  
When type checking, take into account `null` and `undefined`.  
`[--strictPropertyInitialization](/tsconfig/#strictPropertyInitialization)` | `boolean` | `true` if `strict`; `false` otherwise.  
Check for class properties that are declared but not set in the constructor.  
`[--stripInternal](/tsconfig/#stripInternal)` | `boolean` | `false`  
Disable emitting declarations that have `@internal` in their JSDoc comments.  
`[--suppressExcessPropertyErrors](/tsconfig/#suppressExcessPropertyErrors)` | `boolean` | `false`  
Disable reporting of excess property errors during the creation of object
literals.  
`[--suppressImplicitAnyIndexErrors](/tsconfig/#suppressImplicitAnyIndexErrors)` | `boolean` | `false`  
Suppress `noImplicitAny` errors when indexing objects that lack index
signatures.  
`[--target](/tsconfig/#target)` | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, or `esnext` | `ES5`  
Set the JavaScript language version for emitted JavaScript and include
compatible library declarations.  
`[--traceResolution](/tsconfig/#traceResolution)` | `boolean` | `false`  
Log paths used during the `moduleResolution` process.  
`[--tsBuildInfoFile](/tsconfig/#tsBuildInfoFile)` | `string` | `.tsbuildinfo`  
The file to store `.tsbuildinfo` incremental build information in.  
`[--typeRoots](/tsconfig/#typeRoots)` | `list` |   
Specify multiple folders that act like `./node_modules/@types`.  
`[--types](/tsconfig/#types)` | `list` |   
Specify type package names to be included without being referenced in a source
file.  
`[--useDefineForClassFields](/tsconfig/#useDefineForClassFields)` | `boolean` | `true` if `target` is `ES2022` or higher, including `ESNext`; `false` otherwise.  
Emit ECMAScript-standard-compliant class fields.  
`[--useUnknownInCatchVariables](/tsconfig/#useUnknownInCatchVariables)` | `boolean` | `true` if `strict`; `false` otherwise.  
Default catch clause variables as `unknown` instead of `any`.  
`[--verbatimModuleSyntax](/tsconfig/#verbatimModuleSyntax)` | `boolean` | `false`  
Do not transform or elide any imports or exports not marked as type-only,
ensuring they are written in the output file's format based on the 'module'
setting.  
  
## Related

  * Every option is fully explained in the [TSConfig Reference](/tsconfig).
  * Learn how to use a [`tsconfig.json`](/docs/handbook/tsconfig-json.html) file.
  * Learn how to work in an [MSBuild project](/docs/handbook/compiler-options-in-msbuild.html).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Compiler
Options.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(96\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(54\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(19\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

AD![Axel D
\(14\)](https://gravatar.com/avatar/bdf735cd1dd693d2608a997927cb7e7d?s=32&&d=blank)

AG![Anton Gilgur
\(7\)](https://gravatar.com/avatar/4fbb3098af38b7c4f5b6844b276a587b?s=32&&d=blank)

62+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Configuring Watch

As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration
which controls how it watches files and directories. Prior to this version,
configuration required the use of environment variables which are still
available.

## Background

The `--watch` implementation of the compiler relies on Node‚Äôs `fs.watch` and
`fs.watchFile`. Each of these methods has pros and cons.

`fs.watch` relies on file system events to broadcast changes in the watched
files and directories. The implementation of this command is OS dependent and
unreliable - on many operating systems, it does not work as expected.
Additionally, some operating systems limit the number of watches which can
exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-
pages/man7/inotify.7.html)). Heavy use of `fs.watch` in large codebases has
the potential to exceed these limits and result in undesirable behavior.
However, because this implementation relies on an events-based model, CPU use
is comparatively light. The compiler typically uses `fs.watch` to watch
directories (e.g. source directories included by compiler configuration files
and directories in which module resolution failed, among others). TypeScript
uses these to augment potential failures in individual file watchers. However,
there is a key limitation of this strategy: recursive watching of directories
is supported on Windows and macOS, but not on Linux. This suggested a need for
additional strategies for file and directory watching.

`fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile`
is by far the most reliable mechanism available to subscribe to the events
from files and directories of interest. Under this strategy, the TypeScript
compiler typically uses `fs.watchFile` to watch source files, config files,
and files which appear missing based on reference statements. This means that
the degree to which CPU usage will be higher when using `fs.watchFile` depends
directly on number of files watched in the codebase.

## Configuring file watching using a `tsconfig.json`

The suggested method of configuring watch behavior is through the new
`watchOptions` section of `tsconfig.json`. We provide an example configuration
below. See the following section for detailed descriptions of the settings
available.

    
    
    {
    
      // Some typical compiler options
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2020",
    
        "[moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution)": "node"
    
        // ...
    
      },
    
      // NEW: Options for file/directory watching
    
      "watchOptions": {
    
        // Use native file system events for files and directories
    
        "[watchFile](https://www.typescriptlang.org/tsconfig#watchFile)": "useFsEvents",
    
        "[watchDirectory](https://www.typescriptlang.org/tsconfig#watchDirectory)": "useFsEvents",
    
        // Poll files for updates more frequently
    
        // when they're updated a lot.
    
        "[fallbackPolling](https://www.typescriptlang.org/tsconfig#fallbackPolling)": "dynamicPriority",
    
        // Don't coalesce watch notification
    
        "[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory)": true,
    
        // Finally, two additional settings for reducing the amount of possible
    
        // files to track  work from these directories
    
        "[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories)": ["**/node_modules", "_build"],
    
        "[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles)": ["build/fileWhichChangesOften.ts"]
    
      }
    
    }

For further details, see [the release notes for Typescript
3.8](/docs/handbook/release-notes/typescript-3-8.html#better-directory-
watching-on-linux-and-watchoptions).

## Configuring file watching using environment variable `TSC_WATCHFILE`

Option | Description  
---|---  
`PriorityPollingInterval` | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files  
`DynamicPriorityPolling` | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently  
`UseFsEvents` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created.  
`UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`)  
`UseFsEventsOnParentDirectory` | Use `fs.watch` on the _parent_ directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy).  
default (no value specified) | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file.  
  
## Configuring directory watching using environment variable
`TSC_WATCHDIRECTORY`

For directory watches on platforms which don‚Äôt natively allow recursive
directory watching (i.e. non macOS and Windows operating systems) is supported
through recursively creating directory watchers for each child directory using
different options selected by `TSC_WATCHDIRECTORY`.

**NOTE:** On platforms which support native recursive directory watching, the
value of `TSC_WATCHDIRECTORY` is ignored.

Option | Description  
---|---  
`RecursiveDirectoryUsingFsWatchFile` | Use `fs.watchFile` to watch included directories and child directories.  
`RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories.  
default (no value specified) | Use `fs.watch` to watch included directories and child directories.  
  
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Configuring
Watch.md) ‚ù§

Contributors to this page:  

SN![Sheetal Nandi
\(52\)](https://gravatar.com/avatar/eaddbe18695ecd437e1fb16b9eca1922?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

BS![Ben Stein
\(1\)](https://gravatar.com/avatar/60ba94c74aadb4f8105d1d97534a653a?s=32&&d=blank)

JM![Josh Malkinson
\(1\)](https://gravatar.com/avatar/5764de661b4c55558c0332e472bee011?s=32&&d=blank)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

8+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Declaration Reference

The purpose of this guide is to teach you how to write a high-quality
definition file. This guide is structured by showing documentation for some
API, along with sample usage of that API, and explaining how to write the
corresponding declaration.

These examples are ordered in approximately increasing order of complexity.

## Objects with Properties

_Documentation_

> The global variable `myLib` has a function `makeGreeting` for creating
> greetings, and a property `numberOfGreetings` indicating the number of
> greetings made so far.

_Code_

    
    
    ts
    
    let result = myLib.makeGreeting("hello, world");
    
    console.log("The computed greeting is:" + result);
    
    let count = myLib.numberOfGreetings;

_Declaration_

Use `declare namespace` to describe types or values accessed by dotted
notation.

    
    
    ts
    
    declare namespace myLib {
    
      function makeGreeting(s: string): string;
    
      let numberOfGreetings: number;
    
    }

## Overloaded Functions

_Documentation_

The `getWidget` function accepts a number and returns a Widget, or accepts a
string and returns a Widget array.

_Code_

    
    
    ts
    
    let x: Widget = getWidget(43);
    
    let arr: Widget[] = getWidget("all of them");

_Declaration_

    
    
    ts
    
    declare function getWidget(n: number): Widget;
    
    declare function getWidget(s: string): Widget[];

## Reusable Types (Interfaces)

_Documentation_

> When specifying a greeting, you must pass a `GreetingSettings` object. This
> object has the following properties:
>
> 1 - greeting: Mandatory string
>
> 2 - duration: Optional length of time (in milliseconds)
>
> 3 - color: Optional string, e.g. ‚Äò#ff00ff‚Äô

_Code_

    
    
    ts
    
    greet({
    
      greeting: "hello world",
    
      duration: 4000
    
    });

_Declaration_

Use an `interface` to define a type with properties.

    
    
    ts
    
    interface GreetingSettings {
    
      greeting: string;
    
      duration?: number;
    
      color?: string;
    
    }
    
    declare function greet(setting: GreetingSettings): void;

## Reusable Types (Type Aliases)

_Documentation_

> Anywhere a greeting is expected, you can provide a `string`, a function
> returning a `string`, or a `Greeter` instance.

_Code_

    
    
    ts
    
    function getGreeting() {
    
      return "howdy";
    
    }
    
    class MyGreeter extends Greeter {}
    
    greet("hello");
    
    greet(getGreeting);
    
    greet(new MyGreeter());

_Declaration_

You can use a type alias to make a shorthand for a type:

    
    
    ts
    
    type GreetingLike = string | (() => string) | MyGreeter;
    
    declare function greet(g: GreetingLike): void;

## Organizing Types

_Documentation_

> The `greeter` object can log to a file or display an alert. You can provide
> LogOptions to `.log(...)` and alert options to `.alert(...)`

_Code_

    
    
    ts
    
    const g = new Greeter("Hello");
    
    g.log({ verbose: true });
    
    g.alert({ modal: false, title: "Current Greeting" });

_Declaration_

Use namespaces to organize types.

    
    
    ts
    
    declare namespace GreetingLib {
    
      interface LogOptions {
    
        verbose?: boolean;
    
      }
    
      interface AlertOptions {
    
        modal: boolean;
    
        title?: string;
    
        color?: string;
    
      }
    
    }

You can also create nested namespaces in one declaration:

    
    
    ts
    
    declare namespace GreetingLib.Options {
    
      // Refer to via GreetingLib.Options.Log
    
      interface Log {
    
        verbose?: boolean;
    
      }
    
      interface Alert {
    
        modal: boolean;
    
        title?: string;
    
        color?: string;
    
      }
    
    }

## Classes

_Documentation_

> You can create a greeter by instantiating the `Greeter` object, or create a
> customized greeter by extending from it.

_Code_

    
    
    ts
    
    const myGreeter = new Greeter("hello, world");
    
    myGreeter.greeting = "howdy";
    
    myGreeter.showGreeting();
    
    class SpecialGreeter extends Greeter {
    
      constructor() {
    
        super("Very special greetings");
    
      }
    
    }

_Declaration_

Use `declare class` to describe a class or class-like object. Classes can have
properties and methods as well as a constructor.

    
    
    ts
    
    declare class Greeter {
    
      constructor(greeting: string);
    
      greeting: string;
    
      showGreeting(): void;
    
    }

## Global Variables

_Documentation_

> The global variable `foo` contains the number of widgets present.

_Code_

    
    
    ts
    
    console.log("Half the number of widgets is " + foo / 2);

_Declaration_

Use `declare var` to declare variables. If the variable is read-only, you can
use `declare const`. You can also use `declare let` if the variable is block-
scoped.

    
    
    ts
    
    /** The number of widgets present */
    
    declare var foo: number;

## Global Functions

_Documentation_

> You can call the function `greet` with a string to show a greeting to the
> user.

_Code_

    
    
    ts
    
    greet("hello, world");

_Declaration_

Use `declare function` to declare functions.

    
    
    ts
    
    declare function greet(greeting: string): void;

### [IntroductionHow to write a high-quality TypeScript Declaration (d.ts)
file](/docs/handbook/declaration-files/introduction.html)

### [Library StructuresHow to structure your d.ts
files](/docs/handbook/declaration-files/library-structures.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/By
Example.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(57\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

Y![ydz-one
\(1\)](https://gravatar.com/avatar/a1cf7e5d7e4c2f73a2789d9d1d3fe001?s=32&&d=blank)

PB![Pylyp Borysov
\(1\)](https://gravatar.com/avatar/a89473e7a895bc87515a5b3e9fbe207d?s=32&&d=blank)

RK![Rafa≈Ç Krupi≈Ñski
\(1\)](https://gravatar.com/avatar/20c66d3b08e6e3d858973b2a1c66d9a8?s=32&&d=blank)

7+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Consumption

## Downloading

Getting type declarations requires no tools apart from npm.

As an example, getting the declarations for a library like lodash takes
nothing more than the following command

    
    
    cmd
    
    npm install --save-dev @types/lodash

It is worth noting that if the npm package already includes its declaration
file as described in [Publishing](/docs/handbook/declaration-
files/publishing.html), downloading the corresponding `@types` package is not
needed.

## Consuming

From there you‚Äôll be able to use lodash in your TypeScript code with no fuss.
This works for both modules and global code.

For example, once you‚Äôve `npm install`-ed your type declarations, you can use
imports and write

    
    
    ts
    
    import * as _ from "lodash";
    
    _.padStart("Hello TypeScript!", 20, " ");

or if you‚Äôre not using modules, you can just use the global variable `_`.

    
    
    ts
    
    _.padStart("Hello TypeScript!", 20, " ");

## Searching

For the most part, type declaration packages should always have the same name
as the package name on `npm`, but prefixed with `@types/`, but if you need,
you can use the [Yarn package search](https://yarnpkg.com/) to find the
package for your favorite library.

> Note: if the declaration file you are searching for is not present, you can
> always contribute one back and help out the next developer looking for it.
> Please see the DefinitelyTyped [contribution guidelines
> page](https://definitelytyped.org/guides/contributing.html) for details.

### [PublishingHow to get your d.ts files to
users](/docs/handbook/declaration-files/publishing.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Consumption.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

KO![Kristj√°n Oddsson
\(1\)](https://gravatar.com/avatar/a4e6202ba0ad1eee13bb1e35ecf8caba?s=32&&d=blank)

EB![Eli Barzilay
\(1\)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Deep Dive

## Declaration File Theory: A Deep Dive

Structuring modules to give the exact API shape you want can be tricky. For
example, we might want a module that can be invoked with or without `new` to
produce different types, has a variety of named types exposed in a hierarchy,
and has some properties on the module object as well.

By reading this guide, you‚Äôll have the tools to write complex declaration
files that expose a friendly API surface. This guide focuses on module (or
UMD) libraries because the options here are more varied.

## Key Concepts

You can fully understand how to make any shape of declaration by understanding
some key concepts of how TypeScript works.

### Types

If you‚Äôre reading this guide, you probably already roughly know what a type in
TypeScript is. To be more explicit, though, a _type_ is introduced with:

  * A type alias declaration (`type sn = number | string;`)
  * An interface declaration (`interface I { x: number[]; }`)
  * A class declaration (`class C { }`)
  * An enum declaration (`enum E { A, B, C }`)
  * An `import` declaration which refers to a type

Each of these declaration forms creates a new type name.

### Values

As with types, you probably already understand what a value is. Values are
runtime names that we can reference in expressions. For example `let x = 5;`
creates a value called `x`.

Again, being explicit, the following things create values:

  * `let`, `const`, and `var` declarations
  * A `namespace` or `module` declaration which contains a value
  * An `enum` declaration
  * A `class` declaration
  * An `import` declaration which refers to a value
  * A `function` declaration

### Namespaces

Types can exist in _namespaces_. For example, if we have the declaration `let
x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.

This distinction is subtle and important ‚Äî here, `A.B` is not necessarily a
type or a value.

## Simple Combinations: One name, multiple meanings

Given a name `A`, we might find up to three different meanings for `A`: a
type, a value or a namespace. How the name is interpreted depends on the
context in which it is used. For example, in the declaration `let m: A.A =
A;`, `A` is used first as a namespace, then as a type name, then as a value.
These meanings might end up referring to entirely different declarations!

This may seem confusing, but it‚Äôs actually very convenient as long as we don‚Äôt
excessively overload things. Let‚Äôs look at some useful aspects of this
combining behavior.

### Built-in Combinations

Astute readers will notice that, for example, `class` appeared in both the
_type_ and _value_ lists. The declaration `class C { }` creates two things: a
_type_ `C` which refers to the instance shape of the class, and a _value_ `C`
which refers to the constructor function of the class. Enum declarations
behave similarly.

### User Combinations

Let‚Äôs say we wrote a module file `foo.d.ts`:

    
    
    ts
    
    export var SomeVar: { a: SomeType };
    
    export interface SomeType {
    
      count: number;
    
    }

Then consumed it:

    
    
    ts
    
    import * as foo from "./foo";
    
    let x: foo.SomeType = foo.SomeVar.a;
    
    console.log(x.count);

This works well enough, but we might imagine that `SomeType` and `SomeVar`
were very closely related such that you‚Äôd like them to have the same name. We
can use combining to present these two different objects (the value and the
type) under the same name `Bar`:

    
    
    ts
    
    export var Bar: { a: Bar };
    
    export interface Bar {
    
      count: number;
    
    }

This presents a very good opportunity for destructuring in the consuming code:

    
    
    ts
    
    import { Bar } from "./foo";
    
    let x: Bar = Bar.a;
    
    console.log(x.count);

Again, we‚Äôve used `Bar` as both a type and a value here. Note that we didn‚Äôt
have to declare the `Bar` value as being of the `Bar` type ‚Äî they‚Äôre
independent.

## Advanced Combinations

Some kinds of declarations can be combined across multiple declarations. For
example, `class C { }` and `interface C { }` can co-exist and both contribute
properties to the `C` types.

This is legal as long as it does not create a conflict. A general rule of
thumb is that values always conflict with other values of the same name unless
they are declared as `namespace`s, types will conflict if they are declared
with a type alias declaration (`type s = string`), and namespaces never
conflict.

Let‚Äôs see how this can be used.

### Adding using an `interface`

We can add additional members to an `interface` with another `interface`
declaration:

    
    
    ts
    
    interface Foo {
    
      x: number;
    
    }
    
    // ... elsewhere ...
    
    interface Foo {
    
      y: number;
    
    }
    
    let a: Foo = ...;
    
    console.log(a.x + a.y); // OK

This also works with classes:

    
    
    ts
    
    class Foo {
    
      x: number;
    
    }
    
    // ... elsewhere ...
    
    interface Foo {
    
      y: number;
    
    }
    
    let a: Foo = ...;
    
    console.log(a.x + a.y); // OK

Note that we cannot add to type aliases (`type s = string;`) using an
interface.

### Adding using a `namespace`

A `namespace` declaration can be used to add new types, values, and namespaces
in any way which does not create a conflict.

For example, we can add a static member to a class:

    
    
    ts
    
    class C {}
    
    // ... elsewhere ...
    
    namespace C {
    
      export let x: number;
    
    }
    
    let y = C.x; // OK

Note that in this example, we added a value to the _static_ side of `C` (its
constructor function). This is because we added a _value_ , and the container
for all values is another value (types are contained by namespaces, and
namespaces are contained by other namespaces).

We could also add a namespaced type to a class:

    
    
    ts
    
    class C {}
    
    // ... elsewhere ...
    
    namespace C {
    
      export interface D {}
    
    }
    
    let y: C.D; // OK

In this example, there wasn‚Äôt a namespace `C` until we wrote the `namespace`
declaration for it. The meaning `C` as a namespace doesn‚Äôt conflict with the
value or type meanings of `C` created by the class.

Finally, we could perform many different merges using `namespace`
declarations. This isn‚Äôt a particularly realistic example, but shows all sorts
of interesting behavior:

    
    
    ts
    
    namespace X {
    
      export interface Y {}
    
      export class Z {}
    
    }
    
    // ... elsewhere ...
    
    namespace X {
    
      export var Y: number;
    
      export namespace Z {
    
        export class C {}
    
      }
    
    }
    
    type X = string;

In this example, the first block creates the following name meanings:

  * A value `X` (because the `namespace` declaration contains a value, `Z`)
  * A namespace `X` (because the `namespace` declaration contains a type, `Y`)
  * A type `Y` in the `X` namespace
  * A type `Z` in the `X` namespace (the instance shape of the class)
  * A value `Z` that is a property of the `X` value (the constructor function of the class)

The second block creates the following name meanings:

  * A value `Y` (of type `number`) that is a property of the `X` value
  * A namespace `Z`
  * A value `Z` that is a property of the `X` value
  * A type `C` in the `X.Z` namespace
  * A value `C` that is a property of the `X.Z` value
  * A type `X`

### [Do's and Don'tsRecommendations for writing d.ts
files](/docs/handbook/declaration-files/do-s-and-don-ts.html)

### [PublishingHow to get your d.ts files to
users](/docs/handbook/declaration-files/publishing.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Deep Dive.md)
‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(54\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Do's and Don'ts

## General Types

### `Number`, `String`, `Boolean`, `Symbol` and `Object`

‚ùå **Don‚Äôt** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or
`Object` These types refer to non-primitive boxed objects that are almost
never used appropriately in JavaScript code.

    
    
    ts
    
    /* WRONG */
    
    function reverse(s: String): String;

‚úÖ **Do** use the types `number`, `string`, `boolean`, and `symbol`.

    
    
    ts
    
    /* OK */
    
    function reverse(s: string): string;

Instead of `Object`, use the non-primitive `object` type ([added in TypeScript
2.2](../release-notes/typescript-2-2.html#object-type)).

### Generics

‚ùå **Don‚Äôt** ever have a generic type which doesn‚Äôt use its type parameter. See
more details in [TypeScript FAQ
page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-
inference-work-on-this-interface-interface-foot--).

### any

‚ùå **Don‚Äôt** use `any` as a type unless you are in the process of migrating a
JavaScript project to TypeScript. The compiler _effectively_ treats `any` as
‚Äúplease turn off type checking for this thing‚Äù. It is similar to putting an
`@ts-ignore` comment around every usage of the variable. This can be very
helpful when you are first migrating a JavaScript project to TypeScript as you
can set the type for stuff you haven‚Äôt migrated yet as `any`, but in a full
TypeScript project you are disabling type checking for any parts of your
program that use it.

In cases where you don‚Äôt know what type you want to accept, or when you want
to accept anything because you will be blindly passing it through without
interacting with it, you can use [`unknown`](/play/#example/unknown-and-
never).

## Callback Types

### Return Types of Callbacks

‚ùå **Don‚Äôt** use the return type `any` for callbacks whose value will be
ignored:

    
    
    ts
    
    /* WRONG */
    
    function fn(x: () => any) {
    
      x();
    
    }

‚úÖ **Do** use the return type `void` for callbacks whose value will be ignored:

    
    
    ts
    
    /* OK */
    
    function fn(x: () => void) {
    
      x();
    
    }

‚ùî **Why:** Using `void` is safer because it prevents you from accidentally
using the return value of `x` in an unchecked way:

    
    
    ts
    
    function fn(x: () => void) {
    
      var k = x(); // oops! meant to do something else
    
      k.doSomething(); // error, but would be OK if the return type had been 'any'
    
    }

### Optional Parameters in Callbacks

‚ùå **Don‚Äôt** use optional parameters in callbacks unless you really mean it:

    
    
    ts
    
    /* WRONG */
    
    interface Fetcher {
    
      getObject(done: (data: unknown, elapsedTime?: number) => void): void;
    
    }

This has a very specific meaning: the `done` callback might be invoked with 1
argument or might be invoked with 2 arguments. The author probably intended to
say that the callback might not care about the `elapsedTime` parameter, but
there‚Äôs no need to make the parameter optional to accomplish this ‚Äî it‚Äôs
always legal to provide a callback that accepts fewer arguments.

‚úÖ **Do** write callback parameters as non-optional:

    
    
    ts
    
    /* OK */
    
    interface Fetcher {
    
      getObject(done: (data: unknown, elapsedTime: number) => void): void;
    
    }

### Overloads and Callbacks

‚ùå **Don‚Äôt** write separate overloads that differ only on callback arity:

    
    
    ts
    
    /* WRONG */
    
    declare function beforeAll(action: () => void, timeout?: number): void;
    
    declare function beforeAll(
    
      action: (done: DoneFn) => void,
    
      timeout?: number
    
    ): void;

‚úÖ **Do** write a single overload using the maximum arity:

    
    
    ts
    
    /* OK */
    
    declare function beforeAll(
    
      action: (done: DoneFn) => void,
    
      timeout?: number
    
    ): void;

‚ùî **Why:** It‚Äôs always legal for a callback to disregard a parameter, so
there‚Äôs no need for the shorter overload. Providing a shorter callback first
allows incorrectly-typed functions to be passed in because they match the
first overload.

## Function Overloads

### Ordering

‚ùå **Don‚Äôt** put more general overloads before more specific overloads:

    
    
    ts
    
    /* WRONG */
    
    declare function fn(x: unknown): unknown;
    
    declare function fn(x: HTMLElement): number;
    
    declare function fn(x: HTMLDivElement): string;
    
    var myElem: HTMLDivElement;
    
    var x = fn(myElem); // x: unknown, wat?

‚úÖ **Do** sort overloads by putting the more general signatures after more
specific signatures:

    
    
    ts
    
    /* OK */
    
    declare function fn(x: HTMLDivElement): string;
    
    declare function fn(x: HTMLElement): number;
    
    declare function fn(x: unknown): unknown;
    
    var myElem: HTMLDivElement;
    
    var x = fn(myElem); // x: string, :)

‚ùî **Why:** TypeScript chooses the _first matching overload_ when resolving
function calls. When an earlier overload is ‚Äúmore general‚Äù than a later one,
the later one is effectively hidden and cannot be called.

### Use Optional Parameters

‚ùå **Don‚Äôt** write several overloads that differ only in trailing parameters:

    
    
    ts
    
    /* WRONG */
    
    interface Example {
    
      diff(one: string): number;
    
      diff(one: string, two: string): number;
    
      diff(one: string, two: string, three: boolean): number;
    
    }

‚úÖ **Do** use optional parameters whenever possible:

    
    
    ts
    
    /* OK */
    
    interface Example {
    
      diff(one: string, two?: string, three?: boolean): number;
    
    }

Note that this collapsing should only occur when all overloads have the same
return type.

‚ùî **Why:** This is important for two reasons.

TypeScript resolves signature compatibility by seeing if any signature of the
target can be invoked with the arguments of the source, _and extraneous
arguments are allowed_. This code, for example, exposes a bug only when the
signature is correctly written using optional parameters:

    
    
    ts
    
    function fn(x: (a: string, b: number, c: number) => void) {}
    
    var x: Example;
    
    // When written with overloads, OK -- used first overload
    
    // When written with optionals, correctly an error
    
    fn(x.diff);

The second reason is when a consumer uses the ‚Äústrict null checking‚Äù feature
of TypeScript. Because unspecified parameters appear as `undefined` in
JavaScript, it‚Äôs usually fine to pass an explicit `undefined` to a function
with optional arguments. This code, for example, should be OK under strict
nulls:

    
    
    ts
    
    var x: Example;
    
    // When written with overloads, incorrectly an error because of passing 'undefined' to 'string'
    
    // When written with optionals, correctly OK
    
    x.diff("something", true ? undefined : "hour");

### Use Union Types

‚ùå **Don‚Äôt** write overloads that differ by type in only one argument position:

    
    
    ts
    
    /* WRONG */
    
    interface Moment {
    
      utcOffset(): number;
    
      utcOffset(b: number): Moment;
    
      utcOffset(b: string): Moment;
    
    }

‚úÖ **Do** use union types whenever possible:

    
    
    ts
    
    /* OK */
    
    interface Moment {
    
      utcOffset(): number;
    
      utcOffset(b: number | string): Moment;
    
    }

Note that we didn‚Äôt make `b` optional here because the return types of the
signatures differ.

‚ùî **Why:** This is important for people who are ‚Äúpassing through‚Äù a value to
your function:

    
    
    ts
    
    function fn(x: string): Moment;
    
    function fn(x: number): Moment;
    
    function fn(x: number | string) {
    
      // When written with separate overloads, incorrectly an error
    
      // When written with union types, correctly OK
    
      return moment().utcOffset(x);
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Deep DiveHow do d.ts files work, a deep dive](/docs/handbook/declaration-
files/deep-dive.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Do's and
Don'ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(55\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MZ![Micah Zoltu
\(3\)](https://gravatar.com/avatar/c0b2bfa28a2c809735b4209cbfcd357d?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

J![Jongbin
\(1\)](https://gravatar.com/avatar/f8c286e767ba74fc7f1c34f53fbe226f?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Creating .d.ts Files from .js files

[With TypeScript 3.7](/docs/handbook/release-
notes/typescript-3-7.html#--declaration-and---allowjs), TypeScript added
support for generating .d.ts files from JavaScript using JSDoc syntax.

This set up means you can own the editor experience of TypeScript-powered
editors without porting your project to TypeScript, or having to maintain
.d.ts files in your codebase. TypeScript supports most JSDoc tags, you can
find [the reference here](/docs/handbook/type-checking-javascript-
files.html#supported-jsdoc).

## Setting up your Project to emit .d.ts files

To add creation of .d.ts files in your project, you will need to do up-to four
steps:

  * Add TypeScript to your dev dependencies
  * Add a `tsconfig.json` to configure TypeScript
  * Run the TypeScript compiler to generate the corresponding d.ts files for JS files
  * (optional) Edit your package.json to reference the types

### Adding TypeScript

You can learn how to do this in our [installation page](/download).

### TSConfig

The TSConfig is a jsonc file which configures both your compiler flags, and
declare where to find files. In this case, you will want a file like the
following:

    
    
    {
    
      // Change this to match your project
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        // Tells TypeScript to read JS files, as
    
        // normally they are ignored as source files
    
        "[allowJs](https://www.typescriptlang.org/tsconfig#allowJs)": true,
    
        // Generate d.ts files
    
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
        // This compiler run should
    
        // only output d.ts files
    
        "[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)": true,
    
        // Types should go into this directory.
    
        // Removing this would place the .d.ts files
    
        // next to the .js files
    
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "dist",
    
        // go to js file when using IDE functions like
    
        // "Go to Definition" in VSCode
    
        "[declarationMap](https://www.typescriptlang.org/tsconfig#declarationMap)": true
    
      }
    
    }

You can learn more about the options in the [tsconfig reference](/tsconfig).
An alternative to using a TSConfig file is the CLI, this is the same behavior
as a CLI command.

    
    
    sh
    
    npx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types

## Run the compiler

You can learn how to do this in our [installation page](/download). You want
to make sure these files are included in your package if you have the files in
your project‚Äôs `.gitignore`.

## Editing the package.json

TypeScript replicates the node resolution for modules in a `package.json`,
with an additional step for finding .d.ts files. Roughly, the resolution will
first check the optional `types` field, then the `"main"` field, and finally
will try `index.d.ts` in the root.

Package.json | Location of default .d.ts  
---|---  
No ‚Äútypes‚Äù field | checks ‚Äúmain‚Äù, then index.d.ts  
‚Äútypes‚Äù: ‚Äúmain.d.ts‚Äù | main.d.ts  
‚Äútypes‚Äù: ‚Äú./dist/main.js‚Äù | ./dist/main.d.ts  
  
If absent, then ‚Äúmain‚Äù is used

Package.json | Location of default .d.ts  
---|---  
No ‚Äúmain‚Äù field | index.d.ts  
‚Äúmain‚Äù:‚Äúindex.js‚Äù | index.d.ts  
‚Äúmain‚Äù:‚Äú./dist/index.js‚Äù | ./dist/index.d.ts  
  
## Tips

If you‚Äôd like to write tests for your .d.ts files, try
[tsd](https://github.com/SamVerschueren/tsd).

### [JSDoc ReferenceWhat JSDoc does TypeScript-powered JavaScript
support?](/docs/handbook/jsdoc-supported-types.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Creating DTS files
From JS.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SG![Song Gao
\(1\)](https://gravatar.com/avatar/f362bb31388eee02b6a8734525afa104?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

SW![Stafford Williams
\(1\)](https://gravatar.com/avatar/bb67510301c86a5a295c453cf6d26aa6?s=32&&d=blank)

JS![Jami Suomalainen
\(1\)](https://gravatar.com/avatar/6f87c95f447d0eea9750609137eb410f?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Introduction

The Declaration Files section is designed to teach you how to write a high-
quality TypeScript Declaration File. We need to assume basic familiarity with
the TypeScript language in order to get started.

If you haven‚Äôt already, you should read the [TypeScript
Handbook](/docs/handbook/2/basic-types.html) to familiarize yourself with
basic concepts, especially types and modules.

The most common case for learning how .d.ts files work is that you‚Äôre typing
an npm package with no types. In that case, you can jump straight to [Modules
.d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html).

The Declaration Files section is broken down into the following sections.

## [Declaration Reference](/docs/handbook/declaration-files/by-example.html)

We are often faced with writing a declaration file when we only have examples
of the underlying library to guide us. The [Declaration
Reference](/docs/handbook/declaration-files/by-example.html) section shows
many common API patterns and how to write declarations for each of them. This
guide is aimed at the TypeScript novice who may not yet be familiar with every
language construct in TypeScript.

## [Library Structures](/docs/handbook/declaration-files/library-
structures.html)

The [Library Structures](/docs/handbook/declaration-files/library-
structures.html) guide helps you understand common library formats and how to
write a proper declaration file for each format. If you‚Äôre editing an existing
file, you probably don‚Äôt need to read this section. Authors of new declaration
files are strongly encouraged to read this section to properly understand how
the format of the library influences the writing of the declaration file.

In the Template section you‚Äôll find a number of declaration files that serve
as a useful starting point when writing a new file. If you already know what
your structure is, see the d.ts Template section in the sidebar.

## [Do‚Äôs and Don‚Äôts](/docs/handbook/declaration-files/do-s-and-don-ts.html)

Many common mistakes in declaration files can be easily avoided. The [Do‚Äôs and
Don‚Äôts](/docs/handbook/declaration-files/do-s-and-don-ts.html) section
identifies common errors, describes how to detect them, and how to fix them.
Everyone should read this section to help themselves avoid common mistakes.

## [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)

For seasoned authors interested in the underlying mechanics of how declaration
files work, the [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
section explains many advanced concepts in declaration writing, and shows how
to leverage these concepts to create cleaner and more intuitive declaration
files.

## [Publish to npm](/docs/handbook/declaration-files/publishing.html)

The [Publishing](/docs/handbook/declaration-files/publishing.html) section
explains how to publish your declaration files to an npm package, and shows
how to manage your dependent packages.

## [Find and Install Declaration Files](/docs/handbook/declaration-
files/consumption.html)

For JavaScript library users, the [Consumption](/docs/handbook/declaration-
files/consumption.html) section offers a few simple steps to locate and
install corresponding declaration files.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Declaration ReferenceHow to create a d.ts file for a
module](/docs/handbook/declaration-files/by-example.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Introduction.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(61\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JW![Julian Webb
\(1\)](https://gravatar.com/avatar/793712a66cc851d2edf102b14661e621?s=32&&d=blank)

NR![Nik Rahmel
\(1\)](https://gravatar.com/avatar/7801119141cc464ff44e22631ccb1093?s=32&&d=blank)

DK![Dmitrii Kartashev
\(1\)](https://gravatar.com/avatar/bc7e8738dba0b29f8a3f5859ede8ef54?s=32&&d=blank)

11+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Library Structures

Broadly speaking, the way you _structure_ your declaration file depends on how
the library is consumed. There are many ways of offering a library for
consumption in JavaScript, and you‚Äôll need to write your declaration file to
match it. This guide covers how to identify common library patterns, and how
to write declaration files which correspond to that pattern.

Each type of major library structuring pattern has a corresponding file in the
[Templates](/docs/handbook/declaration-files/templates.html) section. You can
start with these templates to help you get going faster.

## Identifying Kinds of Libraries

First, we‚Äôll review the kinds of libraries TypeScript declaration files can
represent. We‚Äôll briefly show how each kind of library is _used_ , how it is
_written_ , and list some example libraries from the real world.

Identifying the structure of a library is the first step in writing its
declaration file. We‚Äôll give hints on how to identify structure both based on
its _usage_ and its _code_. Depending on the library‚Äôs documentation and
organization, one might be easier than the other. We recommend using whichever
is more comfortable to you.

### What should you look for?

Question to ask yourself while looking at a library you are trying to type.

  1. How do you obtain the library?

For example, can you _only_ get it through npm or only from a CDN?

  2. How would you import it?

Does it add a global object? Does it use `require` or `import`/`export`
statements?

### Smaller samples for different types of libraries

### Modular Libraries

Almost every modern Node.js library falls into the module family. These type
of libraries only work in a JS environment with a module loader. For example,
`express` only works in Node.js and must be loaded using the CommonJS
`require` function.

ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and
RequireJS have similar notions of _importing_ a _module_. In JavaScript
CommonJS (Node.js), for example, you would write

    
    
    js
    
    var fs = require("fs");

In TypeScript or ES6, the `import` keyword serves the same purpose:

    
    
    ts
    
    import * as fs from "fs";

You‚Äôll typically see modular libraries include one of these lines in their
documentation:

    
    
    js
    
    var someLib = require("someLib");

or

    
    
    js
    
    define(..., ['someLib'], function(someLib) {
    
    });

As with global modules, you might see these examples in the documentation of a
UMD module, so be sure to check the code or documentation.

#### Identifying a Module Library from Code

Modular libraries will typically have at least some of the following:

  * Unconditional calls to `require` or `define`
  * Declarations like `import * as a from 'b';` or `export c;`
  * Assignments to `exports` or `module.exports`

They will rarely have:

  * Assignments to properties of `window` or `global`

#### Templates For Modules

There are four templates available for modules,
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html),
[`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-class-
d-ts.html), [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) and [`module-
plugin.d.ts`](/docs/handbook/declaration-files/templates/module-plugin-d-
ts.html).

You should first read [`module.d.ts`](/docs/handbook/declaration-
files/templates/module-d-ts.html) for an overview on the way they all work.

Then use the template [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) if your module can be _called_ like
a function:

    
    
    js
    
    const x = require("foo");
    
    // Note: calling 'x' as a function
    
    const y = x(42);

Use the template [`module-class.d.ts`](/docs/handbook/declaration-
files/templates/module-class-d-ts.html) if your module can be _constructed_
using `new`:

    
    
    js
    
    const x = require("bar");
    
    // Note: using 'new' operator on the imported variable
    
    const y = new x("hello");

If you have a module which when imported, makes changes to other modules use
template [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html):

    
    
    js
    
    const jest = require("jest");
    
    require("jest-matchers-files");

### Global Libraries

A _global_ library is one that can be accessed from the global scope (i.e.
without using any form of `import`). Many libraries simply expose one or more
global variables for use. For example, if you were using
[jQuery](https://jquery.com/), the `$` variable can be used by simply
referring to it:

    
    
    ts
    
    $(() => {
    
      console.log("hello!");
    
    });

You‚Äôll usually see guidance in the documentation of a global library of how to
use the library in an HTML script tag:

    
    
    html
    
    <script src="http://a.great.cdn.for/someLib.js"></script>

Today, most popular globally-accessible libraries are actually written as UMD
libraries (see below). UMD library documentation is hard to distinguish from
global library documentation. Before writing a global declaration file, make
sure the library isn‚Äôt actually UMD.

#### Identifying a Global Library from Code

Global library code is usually extremely simple. A global ‚ÄúHello, world‚Äù
library might look like this:

    
    
    js
    
    function createGreeting(s) {
    
      return "Hello, " + s;
    
    }

or like this:

    
    
    js
    
    // Web
    
    window.createGreeting = function (s) {
    
      return "Hello, " + s;
    
    };
    
    // Node
    
    global.createGreeting = function (s) {
    
      return "Hello, " + s;
    
    };
    
    // Potentially any runtime
    
    globalThis.createGreeting = function (s) {
    
      return "Hello, " + s;
    
    };

When looking at the code of a global library, you‚Äôll usually see:

  * Top-level `var` statements or `function` declarations
  * One or more assignments to `window.someName`
  * Assumptions that DOM primitives like `document` or `window` exist

You _won‚Äôt_ see:

  * Checks for, or usage of, module loaders like `require` or `define`
  * CommonJS/Node.js-style imports of the form `var fs = require("fs");`
  * Calls to `define(...)`
  * Documentation describing how to `require` or import the library

#### Examples of Global Libraries

Because it‚Äôs usually easy to turn a global library into a UMD library, very
few popular libraries are still written in the global style. However,
libraries that are small and require the DOM (or have _no_ dependencies) may
still be global.

#### Global Library Template

The template file [`global.d.ts`](/docs/handbook/declaration-
files/templates/global-d-ts.html) defines an example library `myLib`. Be sure
to read the ‚ÄúPreventing Name Conflicts‚Äù footnote.

### _UMD_

A _UMD_ module is one that can _either_ be used as module (through an import),
or as a global (when run in an environment without a module loader). Many
popular libraries, such as [Moment.js](https://momentjs.com/), are written
this way. For example, in Node.js or using RequireJS, you would write:

    
    
    ts
    
    import moment = require("moment");
    
    console.log(moment.format());

whereas in a vanilla browser environment you would write:

    
    
    js
    
    console.log(moment.format());

#### Identifying a UMD library

[UMD modules](https://github.com/umdjs/umd) check for the existence of a
module loader environment. This is an easy-to-spot pattern that looks
something like this:

    
    
    js
    
    (function (root, factory) {
    
        if (typeof define === "function" && define.amd) {
    
            define(["libName"], factory);
    
        } else if (typeof module === "object" && module.exports) {
    
            module.exports = factory(require("libName"));
    
        } else {
    
            root.returnExports = factory(root.libName);
    
        }
    
    }(this, function (b) {

If you see tests for `typeof define`, `typeof window`, or `typeof module` in
the code of a library, especially at the top of the file, it‚Äôs almost always a
UMD library.

Documentation for UMD libraries will also often demonstrate a ‚ÄúUsing in
Node.js‚Äù example showing `require`, and a ‚ÄúUsing in the browser‚Äù example
showing using a `<script>` tag to load the script.

#### Examples of UMD libraries

Most popular libraries are now available as UMD packages. Examples include
[jQuery](https://jquery.com/), [Moment.js](https://momentjs.com/),
[lodash](https://lodash.com/), and many more.

#### Template

Use the [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html) template.

## Consuming Dependencies

There are several kinds of dependencies your library might have. This section
shows how to import them into the declaration file.

### Dependencies on Global Libraries

If your library depends on a global library, use a `/// <reference types="..."
/>` directive:

    
    
    ts
    
    /// <reference types="someLib" />
    
    function getThing(): someLib.thing;

### Dependencies on Modules

If your library depends on a module, use an `import` statement:

    
    
    ts
    
    import * as moment from "moment";
    
    function getThing(): moment;

### Dependencies on UMD libraries

#### From a Global Library

If your global library depends on a UMD module, use a `/// <reference types`
directive:

    
    
    ts
    
    /// <reference types="moment" />
    
    function getThing(): moment;

#### From a Module or UMD Library

If your module or UMD library depends on a UMD library, use an `import`
statement:

    
    
    ts
    
    import * as someLib from "someLib";

Do _not_ use a `/// <reference` directive to declare a dependency to a UMD
library!

## Footnotes

### Preventing Name Conflicts

Note that it‚Äôs possible to define many types in the global scope when writing
a global declaration file. We strongly discourage this as it leads to possible
unresolvable name conflicts when many declaration files are in a project.

A simple rule to follow is to only declare types _namespaced_ by whatever
global variable the library defines. For example, if the library defines the
global value ‚Äòcats‚Äô, you should write

    
    
    ts
    
    declare namespace cats {
    
      interface KittySettings {}
    
    }

But _not_

    
    
    ts
    
    // at top-level
    
    interface CatsKittySettings {}

This guidance also ensures that the library can be transitioned to UMD without
breaking declaration file users.

### The Impact of ES6 on Module Call Signatures

Many popular libraries, such as Express, expose themselves as a callable
function when imported. For example, the typical Express usage looks like
this:

    
    
    ts
    
    import exp = require("express");
    
    var app = exp();

In ES6-compliant module loaders, the top-level object (here imported as `exp`)
can only have properties; the top-level module object can _never_ be callable.

The most common solution here is to define a `default` export for a
callable/constructable object; module loaders commonly detect this situation
automatically and replace the top-level object with the `default` export.
TypeScript can handle this for you, if you have [`"esModuleInterop":
true`](/tsconfig/#esModuleInterop) in your tsconfig.json.

### [Declaration ReferenceHow to create a d.ts file for a
module](/docs/handbook/declaration-files/by-example.html)

### [Modules .d.ts](/docs/handbook/declaration-files/templates/module-d-
ts.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Library
Structures.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(57\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(17\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rose
\(3\)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)

L![lilichao
\(1\)](https://gravatar.com/avatar/bb494650d641017c5c2dabfb86b786d5?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

12+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Publishing

Now that you have authored a declaration file following the steps of this
guide, it is time to publish it to npm. There are two main ways you can
publish your declaration files to npm:

  1. bundling with your npm package
  2. publishing to the [@types organization](https://www.npmjs.com/~types) on npm.

If your types are generated by your source code, publish the types with your
source code. Both TypeScript and JavaScript projects can generate types via
[`declaration`](/tsconfig#declaration).

Otherwise, we recommend submitting the types to DefinitelyTyped, which will
publish them to the `@types` organization on npm.

## Including declarations in your npm package

If your package has a main `.js` file, you will need to indicate the main
declaration file in your `package.json` file as well. Set the `types` property
to point to your bundled declaration file. For example:

    
    
    json
    
    {
    
      "name": "awesome",
    
      "author": "Vandelay Industries",
    
      "version": "1.0.0",
    
      "main": "./lib/main.js",
    
      "types": "./lib/main.d.ts"
    
    }

Note that the `"typings"` field is synonymous with `types`, and could be used
as well.

## Dependencies

All dependencies are managed by npm. Make sure all the declaration packages
you depend on are marked appropriately in the `"dependencies"` section in your
`package.json`. For example, imagine we authored a package that used
Browserify and TypeScript.

    
    
    json
    
    {
    
      "name": "browserify-typescript-extension",
    
      "author": "Vandelay Industries",
    
      "version": "1.0.0",
    
      "main": "./lib/main.js",
    
      "types": "./lib/main.d.ts",
    
      "dependencies": {
    
        "browserify": "latest",
    
        "@types/browserify": "latest",
    
        "typescript": "next"
    
      }
    
    }

Here, our package depends on the `browserify` and `typescript` packages.
`browserify` does not bundle its declaration files with its npm packages, so
we needed to depend on `@types/browserify` for its declarations. `typescript`,
on the other hand, packages its declaration files, so there was no need for
any additional dependencies.

Our package exposes declarations from each of those, so any user of our
`browserify-typescript-extension` package needs to have these dependencies as
well. For that reason, we used `"dependencies"` and not `"devDependencies"`,
because otherwise our consumers would have needed to manually install those
packages. If we had just written a command line application and not expected
our package to be used as a library, we might have used `devDependencies`.

## Red flags

### `/// <reference path="..." />`

_Don‚Äôt_ use `/// <reference path="..." />` in your declaration files.

    
    
    ts
    
    /// <reference path="../typescript/lib/typescriptServices.d.ts" />
    
    ....

_Do_ use `/// <reference types="..." />` instead.

    
    
    ts
    
    /// <reference types="typescript" />
    
    ....

Make sure to revisit the [Consuming dependencies](/docs/handbook/declaration-
files/library-structures.html#consuming-dependencies) section for more
information.

### Packaging dependent declarations

If your type definitions depend on another package:

  * _Don‚Äôt_ combine it with yours, keep each in their own file.
  * _Don‚Äôt_ copy the declarations in your package either.
  * _Do_ depend on the npm type declaration package if it doesn‚Äôt package its declaration files.

## Version selection with `typesVersions`

When TypeScript opens a `package.json` file to figure out which files it needs
to read, it first looks at a field called `typesVersions`.

#### Folder redirects (using `*`)

A `package.json` with a `typesVersions` field might look like this:

    
    
    json
    
    {
    
      "name": "package-name",
    
      "version": "1.0.0",
    
      "types": "./index.d.ts",
    
      "typesVersions": {
    
        ">=3.1": { "*": ["ts3.1/*"] }
    
      }
    
    }

This `package.json` tells TypeScript to first check the current version of
TypeScript. If it‚Äôs 3.1 or later, TypeScript figures out the path you‚Äôve
imported relative to the package, and reads from the package‚Äôs `ts3.1` folder.

That‚Äôs what that `{ "*": ["ts3.1/*"] }` means - if you‚Äôre familiar with [path
mapping](/tsconfig#paths), it works exactly like that.

In the above example, if we‚Äôre importing from `"package-name"`, TypeScript
will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts`
(and other relevant paths) when running in TypeScript 3.1. If we import from
`package-name/foo`, we‚Äôll try to look for `[...]/node_modules/package-
name/ts3.1/foo.d.ts` and `[...]/node_modules/package-
name/ts3.1/foo/index.d.ts`.

What if we‚Äôre not running in TypeScript 3.1 in this example? Well, if none of
the fields in `typesVersions` get matched, TypeScript falls back to the
`types` field, so here TypeScript 3.0 and earlier will be redirected to
`[...]/node_modules/package-name/index.d.ts`.

#### File redirects

When you want to only change the resolution for a single file at a time, you
can tell TypeScript the file to resolve differently by passing in the exact
filenames:

    
    
    json
    
    {
    
      "name": "package-name",
    
      "version": "1.0.0",
    
      "types": "./index.d.ts",
    
      "typesVersions": {
    
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
    
      }
    
    }

On TypeScript 4.0 and above, an import for `"package-name"` would resolve to
`./index.d.ts` and for 3.9 and below `"./index.v3.d.ts`.

Note that redirections only affect the _external_ API of a package; import
resolution within a project is not affected by `typesVersions`. For example, a
`d.ts` file in the previous example containing `import * as foo from
"./index"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas
another package importing `import * as foo from "package-name"` _will_ get
`index.v3.d.ts`.

## Matching behavior

The way that TypeScript decides on whether a version of the compiler &
language matches is by using Node‚Äôs [semver
ranges](https://github.com/npm/node-semver#ranges).

## Multiple fields

`typesVersions` can support multiple fields where each field name is specified
by the range to match on.

    
    
    {
    
      "name": "package-name",
    
      "version": "1.0",
    
      "[types](https://www.typescriptlang.org/tsconfig#types)": "./index.d.ts",
    
      "typesVersions": {
    
        ">=3.2": { "*": ["ts3.2/*"] },
    
        ">=3.1": { "*": ["ts3.1/*"] }
    
      }
    
    }

Since ranges have the potential to overlap, determining which redirect applies
is order-specific. That means in the above example, even though both the
`>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing
the order could have different behavior, so the above sample would not be
equivalent to the following.

    
    
    {
    
      "name": "package-name",
    
      "version": "1.0",
    
      "[types](https://www.typescriptlang.org/tsconfig#types)": "./index.d.ts",
    
      "typesVersions": {
    
        // NOTE: this doesn't work!
    
        ">=3.1": { "*": ["ts3.1/*"] },
    
        ">=3.2": { "*": ["ts3.2/*"] }
    
      }
    
    }

## Publish to [@types](https://www.npmjs.com/~types)

Packages under the [@types](https://www.npmjs.com/~types) organization are
published automatically from
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) using
the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-
tools/tree/master/packages/publisher). To get your declarations published as
an @types package, please submit a pull request to
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). You can
find more details in the [contribution guidelines
page](https://definitelytyped.github.io/guides/contributing.html).

### [Deep DiveHow do d.ts files work, a deep dive](/docs/handbook/declaration-
files/deep-dive.html)

### [ConsumptionHow to download d.ts files for your
project](/docs/handbook/declaration-files/consumption.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Publishing.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(55\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(21\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MB![Mateusz Burzy≈Ñski
\(2\)](https://gravatar.com/avatar/60e6a38ca0eda581aeaa86119f3b2e08?s=32&&d=blank)

RV![Rauno Viskus
\(2\)](https://gravatar.com/avatar/c6b61c49c6abdc9df291e31fc888ab58?s=32&&d=blank)

RC![Ryan Cavanaugh
\(2\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

19+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Templates

[global-modifying-module.d.ts](/3ed761a6c3f38d73aadf745e7454f74d/global-
modifying-module.d.ts.md)

  * [global-plugin.d.ts](/docs/handbook/declaration-files/templates/global-plugin-d-ts.html)
  * [global.d.ts](/docs/handbook/declaration-files/templates/global-d-ts.html)
  * [module-class.d.ts](/docs/handbook/declaration-files/templates/module-class-d-ts.html)
  * [module-function.d.ts](/docs/handbook/declaration-files/templates/module-function-d-ts.html)
  * [module-plugin.d.ts](/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)
  * [module.d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Templates.md)
‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Global .d.ts

## Global Libraries

A _global_ library is one that can be accessed from the global scope (i.e.
without using any form of `import`). Many libraries simply expose one or more
global variables for use. For example, if you were using
[jQuery](https://jquery.com/), the `$` variable can be used by simply
referring to it:

    
    
    ts
    
    $(() => {
    
      console.log("hello!");
    
    });

You‚Äôll usually see guidance in the documentation of a global library of how to
use the library in an HTML script tag:

    
    
    html
    
    <script src="http://a.great.cdn.for/someLib.js"></script>

Today, most popular globally-accessible libraries are actually written as UMD
libraries (see below). UMD library documentation is hard to distinguish from
global library documentation. Before writing a global declaration file, make
sure the library isn‚Äôt actually UMD.

## Identifying a Global Library from Code

Global library code is usually extremely simple. A global ‚ÄúHello, world‚Äù
library might look like this:

    
    
    js
    
    function createGreeting(s) {
    
      return "Hello, " + s;
    
    }

or like this:

    
    
    js
    
    window.createGreeting = function (s) {
    
      return "Hello, " + s;
    
    };

When looking at the code of a global library, you‚Äôll usually see:

  * Top-level `var` statements or `function` declarations
  * One or more assignments to `window.someName`
  * Assumptions that DOM primitives like `document` or `window` exist

You _won‚Äôt_ see:

  * Checks for, or usage of, module loaders like `require` or `define`
  * CommonJS/Node.js-style imports of the form `var fs = require("fs");`
  * Calls to `define(...)`
  * Documentation describing how to `require` or import the library

## Examples of Global Libraries

Because it‚Äôs usually easy to turn a global library into a UMD library, very
few popular libraries are still written in the global style. However,
libraries that are small and require the DOM (or have _no_ dependencies) may
still be global.

## Global Library Template

You can see an example DTS below:

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ If this library is callable (e.g. can be invoked as myLib(3)),
    
     *~ include those call signatures here.
    
     *~ Otherwise, delete this section.
    
     */
    
    declare function myLib(a: string): string;
    
    declare function myLib(a: number): number;
    
    /*~ If you want the name of this library to be a valid type name,
    
     *~ you can do so here.
    
     *~
    
     *~ For example, this allows us to write 'var x: myLib';
    
     *~ Be sure this actually makes sense! If it doesn't, just
    
     *~ delete this declaration and add types inside the namespace below.
    
     */
    
    interface myLib {
    
      name: string;
    
      length: number;
    
      extras?: string[];
    
    }
    
    /*~ If your library has properties exposed on a global variable,
    
     *~ place them here.
    
     *~ You should also place types (interfaces and type alias) here.
    
     */
    
    declare namespace myLib {
    
      //~ We can write 'myLib.timeout = 50;'
    
      let timeout: number;
    
      //~ We can access 'myLib.version', but not change it
    
      const version: string;
    
      //~ There's some class we can create via 'let c = new myLib.Cat(42)'
    
      //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }
    
      class Cat {
    
        constructor(n: number);
    
        //~ We can read 'c.age' from a 'Cat' instance
    
        readonly age: number;
    
        //~ We can invoke 'c.purr()' from a 'Cat' instance
    
        purr(): void;
    
      }
    
      //~ We can declare a variable as
    
      //~   'var s: myLib.CatSettings = { weight: 5, name: "Maru" };'
    
      interface CatSettings {
    
        weight: number;
    
        name: string;
    
        tailLength?: number;
    
      }
    
      //~ We can write 'const v: myLib.VetID = 42;'
    
      //~  or 'const v: myLib.VetID = "bob";'
    
      type VetID = string | number;
    
      //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'
    
      function checkCat(c: Cat, s?: VetID);
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Global: Modifying Module

##  _Global-modifying Modules_

A _global-modifying module_ alters existing values in the global scope when
they are imported. For example, there might exist a library which adds new
members to `String.prototype` when imported. This pattern is somewhat
dangerous due to the possibility of runtime conflicts, but we can still write
a declaration file for it.

## Identifying global-modifying modules

Global-modifying modules are generally easy to identify from their
documentation. In general, they‚Äôre similar to global plugins, but need a
`require` call to activate their effects.

You might see documentation like this:

    
    
    js
    
    // 'require' call that doesn't use its return value
    
    var unused = require("magic-string-time");
    
    /* or */
    
    require("magic-string-time");
    
    var x = "hello, world";
    
    // Creates new methods on built-in types
    
    console.log(x.startsWithHello());
    
    var y = [1, 2, 3];
    
    // Creates new methods on built-in types
    
    console.log(y.reverseAndSort());

Here is an example

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This is the global-modifying module template file. You should rename it to index.d.ts
    
     *~ and place it in a folder with the same name as the module.
    
     *~ For example, if you were writing a file for "super-greeter", this
    
     *~ file should be 'super-greeter/index.d.ts'
    
     */
    
    /*~ Note: If your global-modifying module is callable or constructable, you'll
    
     *~ need to combine the patterns here with those in the module-class or module-function
    
     *~ template files
    
     */
    
    declare global {
    
      /*~ Here, declare things that go in the global namespace, or augment
    
       *~ existing declarations in the global namespace
    
       */
    
      interface String {
    
        fancyFormat(opts: StringFormatOptions): string;
    
      }
    
    }
    
    /*~ If your module exports types or values, write them as usual */
    
    export interface StringFormatOptions {
    
      fancinessLevel: number;
    
    }
    
    /*~ For example, declaring a method on the module (in addition to its global side effects) */
    
    export function doSomething(): void;
    
    /*~ If your module exports nothing, you'll need this line. Otherwise, delete it */
    
    export {};

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global-modifying-module.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Global: Plugin

##  _UMD_

A _UMD_ module is one that can _either_ be used as module (through an import),
or as a global (when run in an environment without a module loader). Many
popular libraries, such as [Moment.js](http://momentjs.com/), are written this
way. For example, in Node.js or using RequireJS, you would write:

    
    
    ts
    
    import moment = require("moment");
    
    console.log(moment.format());

whereas in a vanilla browser environment you would write:

    
    
    js
    
    console.log(moment.format());

### Identifying a UMD library

[UMD modules](https://github.com/umdjs/umd) check for the existence of a
module loader environment. This is an easy-to-spot pattern that looks
something like this:

    
    
    js
    
    (function (root, factory) {
    
        if (typeof define === "function" && define.amd) {
    
            define(["libName"], factory);
    
        } else if (typeof module === "object" && module.exports) {
    
            module.exports = factory(require("libName"));
    
        } else {
    
            root.returnExports = factory(root.libName);
    
        }
    
    }(this, function (b) {

If you see tests for `typeof define`, `typeof window`, or `typeof module` in
the code of a library, especially at the top of the file, it‚Äôs almost always a
UMD library.

Documentation for UMD libraries will also often demonstrate a ‚ÄúUsing in
Node.js‚Äù example showing `require`, and a ‚ÄúUsing in the browser‚Äù example
showing using a `<script>` tag to load the script.

### Examples of UMD libraries

Most popular libraries are now available as UMD packages. Examples include
[jQuery](https://jquery.com/), [Moment.js](http://momentjs.com/),
[lodash](https://lodash.com/), and many more.

### Template

There are three templates available for modules,
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html),
[`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-class-
d-ts.html) and [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html).

Use [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) if your module can be _called_ like
a function:

    
    
    js
    
    var x = require("foo");
    
    // Note: calling 'x' as a function
    
    var y = x(42);

Be sure to read the footnote ‚ÄúThe Impact of ES6 on Module Call Signatures‚Äù

Use [`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-
class-d-ts.html) if your module can be _constructed_ using `new`:

    
    
    js
    
    var x = require("bar");
    
    // Note: using 'new' operator on the imported variable
    
    var y = new x("hello");

The same footnote applies to these modules.

If your module is not callable or constructable, use the
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html)
file.

## _Module Plugin_ or _UMD Plugin_

A _module plugin_ changes the shape of another module (either UMD or module).
For example, in Moment.js, `moment-range` adds a new `range` method to the
`moment` object.

For the purposes of writing a declaration file, you‚Äôll write the same code
whether the module being changed is a plain module or UMD module.

### Template

Use the [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html) template.

## _Global Plugin_

A _global plugin_ is global code that changes the shape of some global. As
with _global-modifying modules_ , these raise the possibility of runtime
conflict.

For example, some libraries add new functions to `Array.prototype` or
`String.prototype`.

### Identifying global plugins

Global plugins are generally easy to identify from their documentation.

You‚Äôll see examples that look like this:

    
    
    js
    
    var x = "hello, world";
    
    // Creates new methods on built-in types
    
    console.log(x.startsWithHello());
    
    var y = [1, 2, 3];
    
    // Creates new methods on built-in types
    
    console.log(y.reverseAndSort());

### Template

Use the [`global-plugin.d.ts`](/docs/handbook/declaration-
files/templates/global-plugin-d-ts.html) template.

## _Global-modifying Modules_

A _global-modifying module_ alters existing values in the global scope when
they are imported. For example, there might exist a library which adds new
members to `String.prototype` when imported. This pattern is somewhat
dangerous due to the possibility of runtime conflicts, but we can still write
a declaration file for it.

### Identifying global-modifying modules

Global-modifying modules are generally easy to identify from their
documentation. In general, they‚Äôre similar to global plugins, but need a
`require` call to activate their effects.

You might see documentation like this:

    
    
    js
    
    // 'require' call that doesn't use its return value
    
    var unused = require("magic-string-time");
    
    /* or */
    
    require("magic-string-time");
    
    var x = "hello, world";
    
    // Creates new methods on built-in types
    
    console.log(x.startsWithHello());
    
    var y = [1, 2, 3];
    
    // Creates new methods on built-in types
    
    console.log(y.reverseAndSort());

### Template

Use the [`global-modifying-module.d.ts`](/docs/handbook/declaration-
files/templates/global-modifying-module-d-ts.html) template.

## Consuming Dependencies

There are several kinds of dependencies your library might have. This section
shows how to import them into the declaration file.

### Dependencies on Global Libraries

If your library depends on a global library, use a `/// <reference types="..."
/>` directive:

    
    
    ts
    
    /// <reference types="someLib" />
    
    function getThing(): someLib.thing;

### Dependencies on Modules

If your library depends on a module, use an `import` statement:

    
    
    ts
    
    import * as moment from "moment";
    
    function getThing(): moment;

### Dependencies on UMD libraries

#### From a Global Library

If your global library depends on a UMD module, use a `/// <reference types`
directive:

    
    
    ts
    
    /// <reference types="moment" />
    
    function getThing(): moment;

#### From a Module or UMD Library

If your module or UMD library depends on a UMD library, use an `import`
statement:

    
    
    ts
    
    import * as someLib from "someLib";

Do _not_ use a `/// <reference` directive to declare a dependency to a UMD
library!

## Footnotes

### Preventing Name Conflicts

Note that it‚Äôs possible to define many types in the global scope when writing
a global declaration file. We strongly discourage this as it leads to possible
unresolvable name conflicts when many declaration files are in a project.

A simple rule to follow is to only declare types _namespaced_ by whatever
global variable the library defines. For example, if the library defines the
global value ‚Äòcats‚Äô, you should write

    
    
    ts
    
    declare namespace cats {
    
      interface KittySettings {}
    
    }

But _not_

    
    
    ts
    
    // at top-level
    
    interface CatsKittySettings {}

This guidance also ensures that the library can be transitioned to UMD without
breaking declaration file users.

### The Impact of ES6 on Module Plugins

Some plugins add or modify top-level exports on existing modules. While this
is legal in CommonJS and other loaders, ES6 modules are considered immutable
and this pattern will not be possible. Because TypeScript is loader-agnostic,
there is no compile-time enforcement of this policy, but developers intending
to transition to an ES6 module loader should be aware of this.

### The Impact of ES6 on Module Call Signatures

Many popular libraries, such as Express, expose themselves as a callable
function when imported. For example, the typical Express usage looks like
this:

    
    
    ts
    
    import exp = require("express");
    
    var app = exp();

In ES6 module loaders, the top-level object (here imported as `exp`) can only
have properties; the top-level module object is _never_ callable. The most
common solution here is to define a `default` export for a
callable/constructable object; some module loader shims will automatically
detect this situation and replace the top-level object with the `default`
export.

### Library file layout

The layout of your declaration files should mirror the layout of the library.

A library can consist of multiple modules, such as

    
    
    myLib
    
      +---- index.js
    
      +---- foo.js
    
      +---- bar
    
             +---- index.js
    
             +---- baz.js

These could be imported as

    
    
    js
    
    var a = require("myLib");
    
    var b = require("myLib/foo");
    
    var c = require("myLib/bar");
    
    var d = require("myLib/bar/baz");

Your declaration files should thus be

    
    
    @types/myLib
    
      +---- index.d.ts
    
      +---- foo.d.ts
    
      +---- bar
    
             +---- index.d.ts
    
             +---- baz.d.ts
    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This template shows how to write a global plugin. */
    
    /*~ Write a declaration for the original type and add new members.
    
     *~ For example, this adds a 'toBinaryString' method with overloads to
    
     *~ the built-in number type.
    
     */
    
    interface Number {
    
      toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;
    
      toBinaryString(
    
        callback: MyLibrary.BinaryFormatCallback,
    
        opts?: MyLibrary.BinaryFormatOptions
    
      ): string;
    
    }
    
    /*~ If you need to declare several types, place them inside a namespace
    
     *~ to avoid adding too many things to the global namespace.
    
     */
    
    declare namespace MyLibrary {
    
      type BinaryFormatCallback = (n: number) => string;
    
      interface BinaryFormatOptions {
    
        prefix?: string;
    
        padding: number;
    
      }
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global-plugin.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

JH![Jonathan Harrison
\(1\)](https://gravatar.com/avatar/5b0ed0bbee3827f487ffbcafa3b70142?s=32&&d=blank)

J![Johnny
\(1\)](https://gravatar.com/avatar/d33dd700ab180cf167ec9b6a5c510510?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Module: Class

For example, when you want to work with JavaScript code which looks like:

    
    
    ts
    
    const Greeter = require("super-greeter");
    
    const greeter = new Greeter();
    
    greeter.greet();

To handle both importing via UMD and modules:

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This is the module template file for class modules.
    
     *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.
    
     *~ For example, if you were writing a file for "super-greeter", this
    
     *~ file should be 'super-greeter/index.d.ts'
    
     */
    
    // Note that ES6 modules cannot directly export class objects.
    
    // This file should be imported using the CommonJS-style:
    
    //   import x = require('[~THE MODULE~]');
    
    //
    
    // Alternatively, if --allowSyntheticDefaultImports or
    
    // --esModuleInterop is turned on, this file can also be
    
    // imported as a default import:
    
    //   import x from '[~THE MODULE~]';
    
    //
    
    // Refer to the TypeScript documentation at
    
    // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require
    
    // to understand common workarounds for this limitation of ES6 modules.
    
    /*~ If this module is a UMD module that exposes a global variable 'myClassLib' when
    
     *~ loaded outside a module loader environment, declare that global here.
    
     *~ Otherwise, delete this declaration.
    
     */
    
    export as namespace "super-greeter";
    
    /*~ This declaration specifies that the class constructor function
    
     *~ is the exported object from the file
    
     */
    
    export = Greeter;
    
    /*~ Write your module's methods and properties in this class */
    
    declare class Greeter {
    
      constructor(customGreeting?: string);
    
      greet: void;
    
      myMethod(opts: MyClass.MyClassMethodOptions): number;
    
    }
    
    /*~ If you want to expose types from your module as well, you can
    
     *~ place them in this block.
    
     *~
    
     *~ Note that if you decide to include this namespace, the module can be
    
     *~ incorrectly imported as a namespace object, unless
    
     *~ --esModuleInterop is turned on:
    
     *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!
    
     */
    
    declare namespace MyClass {
    
      export interface MyClassMethodOptions {
    
        width?: number;
    
        height?: number;
    
      }
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-class.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AC![Alper Cugun
\(1\)](https://gravatar.com/avatar/3ec178b3d2e7d4e44923b29b4c1f1cdb?s=32&&d=blank)

DR![Daniel Rose
\(1\)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules .d.ts

## Comparing JavaScript to an example DTS

## Common CommonJS Patterns

A module using CommonJS patterns uses `module.exports` to describe the
exported values. For example, here is a module which exports a function and a
numerical constant:

    
    
    js
    
    const maxInterval = 12;
    
    function getArrayLength(arr) {
    
      return arr.length;
    
    }
    
    module.exports = {
    
      getArrayLength,
    
      maxInterval,
    
    };

This can be described by the following `.d.ts`:

    
    
    ts
    
    export function getArrayLength(arr: any[]): number;
    
    export const maxInterval: 12;

The TypeScript playground can show you the `.d.ts` equivalent for JavaScript
code. You can [try it yourself
here](/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA).

The `.d.ts` syntax intentionally looks like [ES
Modules](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Statements/import) syntax. ES Modules was
ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available
via transpilers for a long time, however if you have a JavaScript codebase
using ES Modules:

    
    
    js
    
    export function getArrayLength(arr) {
    
      return arr.length;
    
    }

This would have the following `.d.ts` equivalent:

    
    
    ts
    
    export function getArrayLength(arr: any[]): number;

### Default Exports

In CommonJS you can export any value as the default export, for example here
is a regular expression module:

    
    
    js
    
    module.exports = /hello( world)?/;

Which can be described by the following .d.ts:

    
    
    ts
    
    declare const helloWorld: RegExp;
    
    export default helloWorld;

Or a number:

    
    
    js
    
    module.exports = 3.142;
    
    
    ts
    
    declare const pi: number;
    
    export default pi;

One style of exporting in CommonJS is to export a function. Because a function
is also an object, then extra fields can be added and are included in the
export.

    
    
    js
    
    function getArrayLength(arr) {
    
      return arr.length;
    
    }
    
    getArrayLength.maxInterval = 12;
    
    module.exports = getArrayLength;

Which can be described with:

    
    
    ts
    
    export default function getArrayLength(arr: any[]): number;
    
    export const maxInterval: 12;

Note that using `export default` in your .d.ts files requires
[`esModuleInterop: true`](/tsconfig#esModuleInterop) to work. If you can‚Äôt
have `esModuleInterop: true` in your project, such as when you‚Äôre submitting a
PR to Definitely Typed, you‚Äôll have to use the `export=` syntax instead. This
older syntax is harder to use but works everywhere. Here‚Äôs how the above
example would have to be written using `export=`:

    
    
    ts
    
    declare function getArrayLength(arr: any[]): number;
    
    declare namespace getArrayLength {
    
      declare const maxInterval: 12;
    
    }
    
    export = getArrayLength;

See [Module: Functions](/docs/handbook/declaration-files/templates/module-
function-d-ts.html) for details of how that works, and the [Modules
reference](/docs/handbook/modules.html) page.

## Handling Many Consuming Import

There are many ways to import a module in modern consuming code:

    
    
    ts
    
    const fastify = require("fastify");
    
    const { fastify } = require("fastify");
    
    import fastify = require("fastify");
    
    import * as Fastify from "fastify";
    
    import { fastify, FastifyInstance } from "fastify";
    
    import fastify from "fastify";
    
    import fastify, { FastifyInstance } from "fastify";

Covering all of these cases requires the JavaScript code to actually support
all of these patterns. To support many of these patterns, a CommonJS module
would need to look something like:

    
    
    js
    
    class FastifyInstance {}
    
    function fastify() {
    
      return new FastifyInstance();
    
    }
    
    fastify.FastifyInstance = FastifyInstance;
    
    // Allows for { fastify }
    
    fastify.fastify = fastify;
    
    // Allows for strict ES Module support
    
    fastify.default = fastify;
    
    // Sets the default export
    
    module.exports = fastify;

## Types in Modules

You may want to provide a type for JavaScript code which does not exist

    
    
    js
    
    function getArrayMetadata(arr) {
    
      return {
    
        length: getArrayLength(arr),
    
        firstObject: arr[0],
    
      };
    
    }
    
    module.exports = {
    
      getArrayMetadata,
    
    };

This can be described with:

    
    
    ts
    
    export type ArrayMetadata = {
    
      length: number;
    
      firstObject: any | undefined;
    
    };
    
    export function getArrayMetadata(arr: any[]): ArrayMetadata;

This example is a good case for [using
generics](/docs/handbook/generics.html#generic-types) to provide richer type
information:

    
    
    ts
    
    export type ArrayMetadata<ArrType> = {
    
      length: number;
    
      firstObject: ArrType | undefined;
    
    };
    
    export function getArrayMetadata<ArrType>(
    
      arr: ArrType[]
    
    ): ArrayMetadata<ArrType>;

Now the type of the array propagates into the `ArrayMetadata` type.

The types which are exported can then be re-used by consumers of the modules
using either `import` or `import type` in TypeScript code or [JSDoc
imports](/docs/handbook/jsdoc-supported-types.html#import-types).

### Namespaces in Module Code

Trying to describe the runtime relationship of JavaScript code can be tricky.
When the ES Module-like syntax doesn‚Äôt provide enough tools to describe the
exports then you can use `namespaces`.

For example, you may have complex enough types to describe that you choose to
namespace them inside your `.d.ts`:

    
    
    ts
    
    // This represents the JavaScript class which would be available at runtime
    
    export class API {
    
      constructor(baseURL: string);
    
      getInfo(opts: API.InfoRequest): API.InfoResponse;
    
    }
    
    // This namespace is merged with the API class and allows for consumers, and this file
    
    // to have types which are nested away in their own sections.
    
    declare namespace API {
    
      export interface InfoRequest {
    
        id: string;
    
      }
    
      export interface InfoResponse {
    
        width: number;
    
        height: number;
    
      }
    
    }

To understand how namespaces work in `.d.ts` files read the [`.d.ts` deep
dive](/docs/handbook/declaration-files/deep-dive.html).

### Optional Global Usage

You can use `export as namespace` to declare that your module will be
available in the global scope in UMD contexts:

    
    
    ts
    
    export as namespace moduleName;

## Reference Example

To give you an idea of how all these pieces can come together, here is a
reference `.d.ts` to start with when making a new module

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This is the module template file. You should rename it to index.d.ts
    
     *~ and place it in a folder with the same name as the module.
    
     *~ For example, if you were writing a file for "super-greeter", this
    
     *~ file should be 'super-greeter/index.d.ts'
    
     */
    
    /*~ If this module is a UMD module that exposes a global variable 'myLib' when
    
     *~ loaded outside a module loader environment, declare that global here.
    
     *~ Otherwise, delete this declaration.
    
     */
    
    export as namespace myLib;
    
    /*~ If this module exports functions, declare them like so.
    
     */
    
    export function myFunction(a: string): string;
    
    export function myOtherFunction(a: number): number;
    
    /*~ You can declare types that are available via importing the module */
    
    export interface SomeType {
    
      name: string;
    
      length: number;
    
      extras?: string[];
    
    }
    
    /*~ You can declare properties of the module using const, let, or var */
    
    export const myField: number;

### Library file layout

The layout of your declaration files should mirror the layout of the library.

A library can consist of multiple modules, such as

    
    
    myLib
    
      +---- index.js
    
      +---- foo.js
    
      +---- bar
    
             +---- index.js
    
             +---- baz.js

These could be imported as

    
    
    js
    
    var a = require("myLib");
    
    var b = require("myLib/foo");
    
    var c = require("myLib/bar");
    
    var d = require("myLib/bar/baz");

Your declaration files should thus be

    
    
    @types/myLib
    
      +---- index.d.ts
    
      +---- foo.d.ts
    
      +---- bar
    
             +---- index.d.ts
    
             +---- baz.d.ts

### Testing your types

If you are planning on submitting these changes to DefinitelyTyped for
everyone to also use, then we recommend you:

>   1. Create a new folder in `node_modules/@types/[libname]`
>   2. Create an `index.d.ts` in that folder, and copy the example in
>   3. See where your usage of the module breaks, and start to fill out the
> index.d.ts
>   4. When you‚Äôre happy, clone
> [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped) and
> follow the instructions in the README.
>

Otherwise

>   1. Create a new file in the root of your source tree: `[libname].d.ts`
>   2. Add `declare module "[libname]" { }`
>   3. Add the template inside the braces of the declare module, and see where
> your usage breaks
>

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MF![Mike Frysinger
\(1\)](https://gravatar.com/avatar/b50edfe0f2c02b65423409d53acb9312?s=32&&d=blank)

H![hzrong
\(1\)](https://gravatar.com/avatar/c0f8b9cc93b61fe1cb46edc54eb75cc8?s=32&&d=blank)

GS![Guilherme Samuel
\(1\)](https://gravatar.com/avatar/1d9175c80d6ed9b843481fe974f363eb?s=32&&d=blank)

4+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Module: Function

For example, when you want to work with JavaScript code which looks like:

    
    
    ts
    
    import greeter from "super-greeter";
    
    greeter(2);
    
    greeter("Hello world");

To handle both importing via UMD and modules:

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This is the module template file for function modules.
    
     *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.
    
     *~ For example, if you were writing a file for "super-greeter", this
    
     *~ file should be 'super-greeter/index.d.ts'
    
     */
    
    // Note that ES6 modules cannot directly export class objects.
    
    // This file should be imported using the CommonJS-style:
    
    //   import x = require('[~THE MODULE~]');
    
    //
    
    // Alternatively, if --allowSyntheticDefaultImports or
    
    // --esModuleInterop is turned on, this file can also be
    
    // imported as a default import:
    
    //   import x from '[~THE MODULE~]';
    
    //
    
    // Refer to the TypeScript documentation at
    
    // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require
    
    // to understand common workarounds for this limitation of ES6 modules.
    
    /*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when
    
     *~ loaded outside a module loader environment, declare that global here.
    
     *~ Otherwise, delete this declaration.
    
     */
    
    export as namespace myFuncLib;
    
    /*~ This declaration specifies that the function
    
     *~ is the exported object from the file
    
     */
    
    export = Greeter;
    
    /*~ This example shows how to have multiple overloads for your function */
    
    declare function Greeter(name: string): Greeter.NamedReturnType;
    
    declare function Greeter(length: number): Greeter.LengthReturnType;
    
    /*~ If you want to expose types from your module as well, you can
    
     *~ place them in this block. Often you will want to describe the
    
     *~ shape of the return type of the function; that type should
    
     *~ be declared in here, as this example shows.
    
     *~
    
     *~ Note that if you decide to include this namespace, the module can be
    
     *~ incorrectly imported as a namespace object, unless
    
     *~ --esModuleInterop is turned on:
    
     *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!
    
     */
    
    declare namespace Greeter {
    
      export interface LengthReturnType {
    
        width: number;
    
        height: number;
    
      }
    
      export interface NamedReturnType {
    
        firstName: string;
    
        lastName: string;
    
      }
    
      /*~ If the module also has properties, declare them here. For example,
    
       *~ this declaration says that this code is legal:
    
       *~   import f = require('super-greeter');
    
       *~   console.log(f.defaultName);
    
       */
    
      export const defaultName: string;
    
      export let defaultLength: number;
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-function.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rose
\(1\)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Module: Plugin

For example, when you want to work with JavaScript code which extends another
library.

    
    
    ts
    
    import { greeter } from "super-greeter";
    
    // Normal Greeter API
    
    greeter(2);
    
    greeter("Hello world");
    
    // Now we extend the object with a new function at runtime
    
    import "hyper-super-greeter";
    
    greeter.hyperGreet();

The definition for ‚Äúsuper-greeter‚Äù:

    
    
    ts
    
    /*~ This example shows how to have multiple overloads for your function */
    
    export interface GreeterFunction {
    
      (name: string): void
    
      (time: number): void
    
    }
    
    /*~ This example shows how to export a function specified by an interface */
    
    export const greeter: GreeterFunction;

We can extend the existing module like the following:

    
    
    ts
    
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    
    // Project: [~THE PROJECT NAME~]
    
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    
    /*~ This is the module plugin template file. You should rename it to index.d.ts
    
     *~ and place it in a folder with the same name as the module.
    
     *~ For example, if you were writing a file for "super-greeter", this
    
     *~ file should be 'super-greeter/index.d.ts'
    
     */
    
    /*~ On this line, import the module which this module adds to */
    
    import { greeter } from "super-greeter";
    
    /*~ Here, declare the same module as the one you imported above
    
     *~ then we expand the existing declaration of the greeter function
    
     */
    
    export module "super-greeter" {
    
      export interface GreeterFunction {
    
        /** Greets even better! */
    
        hyperGreet(): void;
    
      }
    
    }

This uses [declaration merging](/docs/handbook/declaration-merging.html)

## The Impact of ES6 on Module Plugins

Some plugins add or modify top-level exports on existing modules. While this
is legal in CommonJS and other loaders, ES6 modules are considered immutable
and this pattern will not be possible. Because TypeScript is loader-agnostic,
there is no compile-time enforcement of this policy, but developers intending
to transition to an ES6 module loader should be aware of this.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-plugin.d.ts.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

B![B2D1
\(1\)](https://gravatar.com/avatar/3fe7ac4058d3b92e8420cb8c3eeb71e8?s=32&&d=blank)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Declaration Merging

## Introduction

Some of the unique concepts in TypeScript describe the shape of JavaScript
objects at the type level. One example that is especially unique to TypeScript
is the concept of ‚Äòdeclaration merging‚Äô. Understanding this concept will give
you an advantage when working with existing JavaScript. It also opens the door
to more advanced abstraction concepts.

For the purposes of this article, ‚Äúdeclaration merging‚Äù means that the
compiler merges two separate declarations declared with the same name into a
single definition. This merged definition has the features of both of the
original declarations. Any number of declarations can be merged; it‚Äôs not
limited to just two declarations.

## Basic Concepts

In TypeScript, a declaration creates entities in at least one of three groups:
namespace, type, or value. Namespace-creating declarations create a namespace,
which contains names that are accessed using a dotted notation. Type-creating
declarations do just that: they create a type that is visible with the
declared shape and bound to the given name. Lastly, value-creating
declarations create values that are visible in the output JavaScript.

Declaration Type | Namespace | Type | Value  
---|---|---|---  
Namespace | X |  | X  
Class |  | X | X  
Enum |  | X | X  
Interface |  | X |   
Type Alias |  | X |   
Function |  |  | X  
Variable |  |  | X  
  
Understanding what is created with each declaration will help you understand
what is merged when you perform a declaration merge.

## Merging Interfaces

The simplest, and perhaps most common, type of declaration merging is
interface merging. At the most basic level, the merge mechanically joins the
members of both declarations into a single interface with the same name.

    
    
    ts
    
    interface Box {
    
      height: number;
    
      width: number;
    
    }
    
    interface Box {
    
      scale: number;
    
    }
    
    let box: Box = { height: 5, width: 6, scale: 10 };

Non-function members of the interfaces should be unique. If they are not
unique, they must be of the same type. The compiler will issue an error if the
interfaces both declare a non-function member of the same name, but of
different types.

For function members, each function member of the same name is treated as
describing an overload of the same function. Of note, too, is that in the case
of interface `A` merging with later interface `A`, the second interface will
have a higher precedence than the first.

That is, in the example:

    
    
    ts
    
    interface Cloner {
    
      clone(animal: Animal): Animal;
    
    }
    
    interface Cloner {
    
      clone(animal: Sheep): Sheep;
    
    }
    
    interface Cloner {
    
      clone(animal: Dog): Dog;
    
      clone(animal: Cat): Cat;
    
    }

The three interfaces will merge to create a single declaration as so:

    
    
    ts
    
    interface Cloner {
    
      clone(animal: Dog): Dog;
    
      clone(animal: Cat): Cat;
    
      clone(animal: Sheep): Sheep;
    
      clone(animal: Animal): Animal;
    
    }

Notice that the elements of each group maintains the same order, but the
groups themselves are merged with later overload sets ordered first.

One exception to this rule is specialized signatures. If a signature has a
parameter whose type is a _single_ string literal type (e.g. not a union of
string literals), then it will be bubbled toward the top of its merged
overload list.

For instance, the following interfaces will merge together:

    
    
    ts
    
    interface Document {
    
      createElement(tagName: any): Element;
    
    }
    
    interface Document {
    
      createElement(tagName: "div"): HTMLDivElement;
    
      createElement(tagName: "span"): HTMLSpanElement;
    
    }
    
    interface Document {
    
      createElement(tagName: string): HTMLElement;
    
      createElement(tagName: "canvas"): HTMLCanvasElement;
    
    }

The resulting merged declaration of `Document` will be the following:

    
    
    ts
    
    interface Document {
    
      createElement(tagName: "canvas"): HTMLCanvasElement;
    
      createElement(tagName: "div"): HTMLDivElement;
    
      createElement(tagName: "span"): HTMLSpanElement;
    
      createElement(tagName: string): HTMLElement;
    
      createElement(tagName: any): Element;
    
    }

## Merging Namespaces

Similarly to interfaces, namespaces of the same name will also merge their
members. Since namespaces create both a namespace and a value, we need to
understand how both merge.

To merge the namespaces, type definitions from exported interfaces declared in
each namespace are themselves merged, forming a single namespace with merged
interface definitions inside.

To merge the namespace value, at each declaration site, if a namespace already
exists with the given name, it is further extended by taking the existing
namespace and adding the exported members of the second namespace to the
first.

The declaration merge of `Animals` in this example:

    
    
    ts
    
    namespace Animals {
    
      export class Zebra {}
    
    }
    
    namespace Animals {
    
      export interface Legged {
    
        numberOfLegs: number;
    
      }
    
      export class Dog {}
    
    }

is equivalent to:

    
    
    ts
    
    namespace Animals {
    
      export interface Legged {
    
        numberOfLegs: number;
    
      }
    
      export class Zebra {}
    
      export class Dog {}
    
    }

This model of namespace merging is a helpful starting place, but we also need
to understand what happens with non-exported members. Non-exported members are
only visible in the original (un-merged) namespace. This means that after
merging, merged members that came from other declarations cannot see non-
exported members.

We can see this more clearly in this example:

    
    
    ts
    
    namespace Animal {
    
      let haveMuscles = true;
    
      export function animalsHaveMuscles() {
    
        return haveMuscles;
    
      }
    
    }
    
    namespace Animal {
    
      export function doAnimalsHaveMuscles() {
    
        return haveMuscles; // Error, because haveMuscles is not accessible here
    
      }
    
    }

Because `haveMuscles` is not exported, only the `animalsHaveMuscles` function
that shares the same un-merged namespace can see the symbol. The
`doAnimalsHaveMuscles` function, even though it‚Äôs part of the merged `Animal`
namespace can not see this un-exported member.

## Merging Namespaces with Classes, Functions, and Enums

Namespaces are flexible enough to also merge with other types of declarations.
To do so, the namespace declaration must follow the declaration it will merge
with. The resulting declaration has properties of both declaration types.
TypeScript uses this capability to model some of the patterns in JavaScript as
well as other programming languages.

### Merging Namespaces with Classes

This gives the user a way of describing inner classes.

    
    
    ts
    
    class Album {
    
      label: Album.AlbumLabel;
    
    }
    
    namespace Album {
    
      export class AlbumLabel {}
    
    }

The visibility rules for merged members is the same as described in the
[Merging Namespaces](./declaration-merging.html#merging-namespaces) section,
so we must export the `AlbumLabel` class for the merged class to see it. The
end result is a class managed inside of another class. You can also use
namespaces to add more static members to an existing class.

In addition to the pattern of inner classes, you may also be familiar with the
JavaScript practice of creating a function and then extending the function
further by adding properties onto the function. TypeScript uses declaration
merging to build up definitions like this in a type-safe way.

    
    
    ts
    
    function buildLabel(name: string): string {
    
      return buildLabel.prefix + name + buildLabel.suffix;
    
    }
    
    namespace buildLabel {
    
      export let suffix = "";
    
      export let prefix = "Hello, ";
    
    }
    
    console.log(buildLabel("Sam Smith"));

Similarly, namespaces can be used to extend enums with static members:

    
    
    ts
    
    enum Color {
    
      red = 1,
    
      green = 2,
    
      blue = 4,
    
    }
    
    namespace Color {
    
      export function mixColor(colorName: string) {
    
        if (colorName == "yellow") {
    
          return Color.red + Color.green;
    
        } else if (colorName == "white") {
    
          return Color.red + Color.green + Color.blue;
    
        } else if (colorName == "magenta") {
    
          return Color.red + Color.blue;
    
        } else if (colorName == "cyan") {
    
          return Color.green + Color.blue;
    
        }
    
      }
    
    }

## Disallowed Merges

Not all merges are allowed in TypeScript. Currently, classes can not merge
with other classes or with variables. For information on mimicking class
merging, see the [Mixins in TypeScript](/docs/handbook/mixins.html) section.

## Module Augmentation

Although JavaScript modules do not support merging, you can patch existing
objects by importing and then updating them. Let‚Äôs look at a toy Observable
example:

    
    
    ts
    
    // observable.ts
    
    export class Observable<T> {
    
      // ... implementation left as an exercise for the reader ...
    
    }
    
    // map.ts
    
    import { Observable } from "./observable";
    
    Observable.prototype.map = function (f) {
    
      // ... another exercise for the reader
    
    };

This works fine in TypeScript too, but the compiler doesn‚Äôt know about
`Observable.prototype.map`. You can use module augmentation to tell the
compiler about it:

    
    
    ts
    
    // observable.ts
    
    export class Observable<T> {
    
      // ... implementation left as an exercise for the reader ...
    
    }
    
    // map.ts
    
    import { Observable } from "./observable";
    
    declare module "./observable" {
    
      interface Observable<T> {
    
        map<U>(f: (x: T) => U): Observable<U>;
    
      }
    
    }
    
    Observable.prototype.map = function (f) {
    
      // ... another exercise for the reader
    
    };
    
    // consumer.ts
    
    import { Observable } from "./observable";
    
    import "./map";
    
    let o: Observable<number>;
    
    o.map((x) => x.toFixed());

The module name is resolved the same way as module specifiers in
`import`/`export`. See [Modules](/docs/handbook/modules.html) for more
information. Then the declarations in an augmentation are merged as if they
were declared in the same file as the original.

However, there are two limitations to keep in mind:

  1. You can‚Äôt declare new top-level declarations in the augmentation ‚Äî just patches to existing declarations.
  2. Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [#14080](https://github.com/Microsoft/TypeScript/issues/14080) for details)

### Global augmentation

You can also add declarations to the global scope from inside a module:

    
    
    ts
    
    // observable.ts
    
    export class Observable<T> {
    
      // ... still no implementation ...
    
    }
    
    declare global {
    
      interface Array<T> {
    
        toObservable(): Observable<T>;
    
      }
    
    }
    
    Array.prototype.toObservable = function () {
    
      // ...
    
    };

Global augmentations have the same behavior and limits as module
augmentations.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Declaration
Merging.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(53\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DR![Daniel Rosenwasser
\(20\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nathan Shively-Sanders
\(10\)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Decorators

> NOTE This document refers to an experimental stage 2 decorators
> implementation. Stage 3 decorator support is available since Typescript 5.0.
> See: [Decorators in Typescript
> 5.0](https://devblogs.microsoft.com/typescript/announcing-
> typescript-5-0/#decorators)

## Introduction

With the introduction of Classes in TypeScript and ES6, there now exist
certain scenarios that require additional features to support annotating or
modifying classes and class members. Decorators provide a way to add both
annotations and a meta-programming syntax for class declarations and members.

> Further Reading (stage 2): [A Complete Guide to TypeScript
> Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-
> decorator/)

To enable experimental support for decorators, you must enable the
[`experimentalDecorators`](/tsconfig#experimentalDecorators) compiler option
either on the command line or in your `tsconfig.json`:

**Command Line** :

    
    
    shell
    
    tsc --target ES5 --experimentalDecorators

**tsconfig.json** :

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "ES5",
    
        "[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators)": true
    
      }
    
    }

## Decorators

A _Decorator_ is a special kind of declaration that can be attached to a class
declaration, method, accessor, property, or parameter. Decorators use the form
`@expression`, where `expression` must evaluate to a function that will be
called at runtime with information about the decorated declaration.

For example, given the decorator `@sealed` we might write the `sealed`
function as follows:

    
    
    ts
    
    function sealed(target) {
    
      // do something with 'target' ...
    
    }

## Decorator Factories

If we want to customize how a decorator is applied to a declaration, we can
write a decorator factory. A _Decorator Factory_ is simply a function that
returns the expression that will be called by the decorator at runtime.

We can write a decorator factory in the following fashion:

    
    
    ts
    
    function color(value: string) {
    
      // this is the decorator factory, it sets up
    
      // the returned decorator function
    
      return function (target) {
    
        // this is the decorator
    
        // do something with 'target' and 'value'...
    
      };
    
    }

## Decorator Composition

Multiple decorators can be applied to a declaration, for example on a single
line:

    
    
    ts
    
    @f @g x
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAcIS0NCA)

On multiple lines:

    
    
    ts
    
    @f
    
    @g
    
    x
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAdDSmtCA)

When multiple decorators apply to a single declaration, their evaluation is
similar to [function composition in
mathematics](https://wikipedia.org/wiki/Function_composition). In this model,
when composing functions _f_ and _g_ , the resulting composite (_f_ ‚àò
_g_)(_x_) is equivalent to _f_(_g_(_x_)).

As such, the following steps are performed when evaluating multiple decorators
on a single declaration in TypeScript:

  1. The expressions for each decorator are evaluated top-to-bottom.
  2. The results are then called as functions from bottom-to-top.

If we were to use decorator factories, we can observe this evaluation order
with the following example:

    
    
    ts
    
    function first() {
    
      console.log("first(): factory evaluated");
    
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    
        console.log("first(): called");
    
      };
    
    }
    
    ¬†
    
    function second() {
    
      console.log("second(): factory evaluated");
    
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    
        console.log("second(): called");
    
      };
    
    }
    
    ¬†
    
    class ExampleClass {
    
      @first()
    
      @second()
    
      method() {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqh1IJWYAUASlABvGqFCl0VErkgA6XCQDmfAERce-AQC5O2FmQCeoSADc8DCpAAmqgQG4xoBJEwMEHRs1btQfHAhKrrrY6IYANKCwCCTwCJiGANKQhrq8yOhKkdaQVETIsJQIugAKMXEJhHkFRUKi4uKS0rIKymoavIK6RHiytg5OAL6OgzT0TCxsHFTE7NaCIk5NMvKKKqozkvM6egYIxmYWVv2O4i5uHpwTPhz+2IHBoKERUeWICcmpoOlImdm5+SQhTIpTe8UMVUBwIQdScjXYzVWbQ2s3Q226vRsdlOoGGNFGNCIuGwVCooAAotBsChYLIAMLE0mLcTgDpaJzgTZzQRONCYAAWJG2IlGgyAA)

Which would print this output to the console:

    
    
    shell
    
    first(): factory evaluated
    
    second(): factory evaluated
    
    second(): called
    
    first(): called

## Decorator Evaluation

There is a well defined order to how decorators applied to various
declarations inside of a class are applied:

  1. _Parameter Decorators_ , followed by _Method_ , _Accessor_ , or _Property Decorators_ are applied for each instance member.
  2. _Parameter Decorators_ , followed by _Method_ , _Accessor_ , or _Property Decorators_ are applied for each static member.
  3. _Parameter Decorators_ are applied for the constructor.
  4. _Class Decorators_ are applied for the class.

## Class Decorators

A _Class Decorator_ is declared just before a class declaration. The class
decorator is applied to the constructor of the class and can be used to
observe, modify, or replace a class definition. A class decorator cannot be
used in a declaration file, or in any other ambient context (such as on a
`declare` class).

The expression for the class decorator will be called as a function at
runtime, with the constructor of the decorated class as its only argument.

If the class decorator returns a value, it will replace the class declaration
with the provided constructor function.

> NOTE Should you choose to return a new constructor function, you must take
> care to maintain the original prototype. The logic that applies decorators
> at runtime will **not** do this for you.

The following is an example of a class decorator (`@sealed`) applied to a
`BugReport` class:

    
    
    ts
    
    @sealed
    
    class BugReport {
    
      type = "report";
    
      title: string;
    
    ¬†
    
      constructor(t: string) {
    
        this.title = t;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqhWR6QAmAFKXRVMCBizIAuUADEmLNugCUoAN41QoAPIAjAFbFMAOi55B7EWIkIlAbg3b9hk91znho8ZQRHYCEpSYAJ7wdjQAvjQgoAC0cUQMmHExNOCmuHw0RLjYVFSgAEIMAOYASpCwZJhqDsHwoAC8oABECBVVzfaarJgZ0pZI6MX2DkKWXmT8mP2ig8Uq6prdABZIVEY9GY2gmF2gkeFAA)

We can define the `@sealed` decorator using the following function
declaration:

    
    
    ts
    
    function sealed(constructor: Function) {
    
      Object.seal(constructor);
    
      Object.seal(constructor.prototype);
    
    }

When `@sealed` is executed, it will seal both the constructor and its
prototype, and will therefore prevent any further functionality from being
added to or removed from this class during runtime by accessing
`BugReport.prototype` or by defining properties on `BugReport` itself (note
that ES2015 classes are really just syntactic sugar to prototype-based
constructor functions). This decorator does **not** prevent classes from sub-
classing `BugReport`.

Next we have an example of how to override the constructor to set new
defaults.

    
    
    ts
    
    function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
    
      return class extends constructor {
    
        reportingURL = "http://www...";
    
      };
    
    }
    
    ¬†
    
    @reportableClassDecorator
    
    class BugReport {
    
      type = "report";
    
      title: string;
    
    ¬†
    
      constructor(t: string) {
    
        this.title = t;
    
      }
    
    }
    
    ¬†
    
    const bug = new BugReport("Needs dark mode");
    
    console.log(bug.title); // Prints "Needs dark mode"
    
    console.log(bug.type); // Prints "report"
    
    ¬†
    
    // Note that the decorator _does not_ change the TypeScript type
    
    // and so the new property `reportingURL` is not known
    
    // to the type system:
    
    bug.reportingURL;
    
    Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQIJIAPABxgEsBbSAOwBcBDAGwBFIBjBBuhRXAMwCuNdnXJwaoaJBIJGAIyaQAwkwaJEbTtG4IAPABVQxOrQAmiUAG9QNSAHdQACgB0bhtADmKUAxoBPAG0AXQBKVCsAX1BIgD4nThpEOmhBUQRUA1DrXFApSDpBaEl2NQ1jIlMaC1BE5NT06By8vOlZaDEaTwBVACUAGVAAXlAAIgALOjoSZBB7ebcXUYBuXJjVyNxccDa5BkUVMs0OLh5oXFL1SwAhQU9emTlm0Dp-MmGx3Y6VtbE6JVQ9XIXVWazqKTSZycdEBKWBnmyVjWeTo43IiBcfyUHzoqzym02FwkyVA8juHzsjlu90eHScowAcpBIDUzB4ANagShwMyQUahVZ1OBKFxMOCeJxkzyY8j-SAC0AEAAK0GBdEsjOZrI5XJ5fKJSWFkFF4sld0xb3ly0VYBVao1Xzooy2BAZcFML3G3E9kFAvO0uiaAH0zHBIJYaO6g7UvV1fajfQZLQBldiqkh0F6W-BgPxmUCIOA+2wOUAkeBkDr+UAAA0d8L6-RroHRtndoHZkfsNBzLyLCaz70Q-mSkEoyFwUpc9a6jeWQA)

## Method Decorators

A _Method Decorator_ is declared just before a method declaration. The
decorator is applied to the _Property Descriptor_ for the method, and can be
used to observe, modify, or replace a method definition. A method decorator
cannot be used in a declaration file, on an overload, or in any other ambient
context (such as in a `declare` class).

The expression for the method decorator will be called as a function at
runtime, with the following three arguments:

  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The _Property Descriptor_ for the member.

> NOTE The _Property Descriptor_ will be `undefined` if your script target is
> less than `ES5`.

If the method decorator returns a value, it will be used as the _Property
Descriptor_ for the method.

> NOTE The return value is ignored if your script target is less than `ES5`.

The following is an example of a method decorator (`@enumerable`) applied to a
method on the `Greeter` class:

    
    
    ts
    
    class Greeter {
    
      greeting: string;
    
      constructor(message: string) {
    
        this.greeting = message;
    
      }
    
    ¬†
    
      @enumerable(false)
    
      greet() {
    
        return "Hello, " + this.greeting;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgYNrkBGukABQA3PA0gAuULxIkB2dAEpQAbxqhQCSJgYIOjZq3ahBOBAHNtUhQE8ANLAQl4CTDYDSkG1KqZk6czsAE0gqImRYSgQpAAUnFzdCMIio5TUNDRDkpEiyADouHmx+SFAAXlBRXHEAbnVQAF86hpoQUABaTqIGTE72miJcbCoqUABxLW1EVXrzSdYAnz8kALqNUnRfBAYWMkE0EexLJf9zNPqNTAALJCo8uchtFfNy0AOqI8g1xpp6qHRuIhigJBHQ8FRIIpZvNBOcMpptLoOAAiAASkFwuBIdlAyNAAGpQNdbvd5s9vi0GkA)

We can define the `@enumerable` decorator using the following function
declaration:

    
    
    ts
    
    function enumerable(value: boolean) {
    
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    
        descriptor.enumerable = value;
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUzCAtsgTgQwEYA2yAFAG44EjIBcieccROYAlIgN4BQiiWyUILElCRYCRMSg4sAc361mATwA0iAA5Y4a7FEUBpZItoBnKFhhgZqgCbJjEc2qhwstAAqbtWXQBE7DmCcXNi4eHlt7R2csADpUDGx8IkQAXkRySmQAbm5EAF8cvKA)

The `@enumerable(false)` decorator here is a decorator factory. When the
`@enumerable(false)` decorator is called, it modifies the `enumerable`
property of the property descriptor.

## Accessor Decorators

An _Accessor Decorator_ is declared just before an accessor declaration. The
accessor decorator is applied to the _Property Descriptor_ for the accessor
and can be used to observe, modify, or replace an accessor‚Äôs definitions. An
accessor decorator cannot be used in a declaration file, or in any other
ambient context (such as in a `declare` class).

> NOTE TypeScript disallows decorating both the `get` and `set` accessor for a
> single member. Instead, all decorators for the member must be applied to the
> first accessor specified in document order. This is because decorators apply
> to a _Property Descriptor_ , which combines both the `get` and `set`
> accessor, not each declaration separately.

The expression for the accessor decorator will be called as a function at
runtime, with the following three arguments:

  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The _Property Descriptor_ for the member.

> NOTE The _Property Descriptor_ will be `undefined` if your script target is
> less than `ES5`.

If the accessor decorator returns a value, it will be used as the _Property
Descriptor_ for the member.

> NOTE The return value is ignored if your script target is less than `ES5`.

The following is an example of an accessor decorator (`@configurable`) applied
to a member of the `Point` class:

    
    
    ts
    
    class Point {
    
      private _x: number;
    
      private _y: number;
    
      constructor(x: number, y: number) {
    
        this._x = x;
    
        this._y = y;
    
      }
    
    ¬†
    
      @configurable(false)
    
      get x() {
    
        return this._x;
    
      }
    
    ¬†
    
      @configurable(false)
    
      get y() {
    
        return this._y;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqinp1IDmD5AEa5IACgBueBpABcoQSRIjs6AJSgA3jVCgEkTAI6NmrdqFHadoHAl765KgJ4AaSztgIS8BJkcBpSEc5KkxkdF5XK1AAE0gqImRYSgQ5AAVPb19CeMTky3UtKNicpCSyADouHn4hEVAAXlBJXGkAbksAX3aOmhBQAFpBogZMQf6aIlxsKipQVJIkLE1LDyRJTEhQAH1oOXQGFEFEdvdkdc2toNB9w+PLLhCEBhYyUV3rg6OEZ1Arm6+Cm5rAALJBUco7BqgaAnKyYUHgy5QxywnqWcBVPgCbDCMR0PBUSCqSx2TDQ0SAqJ6AwIDjwsEQmGdGjozE1HEiUT43CE4k6Um-CnLKn6QwghmXVE0DpAA)

We can define the `@configurable` decorator using the following function
declaration:

    
    
    ts
    
    function configurable(value: boolean) {
    
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    
        descriptor.configurable = value;
    
      };
    
    }

## Property Decorators

A _Property Decorator_ is declared just before a property declaration. A
property decorator cannot be used in a declaration file, or in any other
ambient context (such as in a `declare` class).

The expression for the property decorator will be called as a function at
runtime, with the following two arguments:

  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.

> NOTE A _Property Descriptor_ is not provided as an argument to a property
> decorator due to how property decorators are initialized in TypeScript. This
> is because there is currently no mechanism to describe an instance property
> when defining members of a prototype, and no way to observe or modify the
> initializer for a property. The return value is ignored too. As such, a
> property decorator can only be used to observe that a property of a specific
> name has been declared for a class.

We can use this information to record metadata about the property, as in the
following example:

    
    
    ts
    
    class Greeter {
    
      @format("Hello, %s")
    
      greeting: string;
    
      constructor(message: string) {
    
        this.greeting = message;
    
      }
    
      greet() {
    
        let formatString = getFormat(this, "greeting");
    
        return formatString.replace("%s", this.greeting);
    
      }
    
    }

We can then define the `@format` decorator and `getFormat` functions using the
following function declarations:

    
    
    ts
    
    import "reflect-metadata";
    
    const formatMetadataKey = Symbol("format");
    
    function format(formatString: string) {
    
      return Reflect.metadata(formatMetadataKey, formatString);
    
    }
    
    function getFormat(target: any, propertyKey: string) {
    
      return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
    
    }

The `@format("Hello, %s")` decorator here is a decorator factory. When
`@format("Hello, %s")` is called, it adds a metadata entry for the property
using the `Reflect.metadata` function from the `reflect-metadata` library.
When `getFormat` is called, it reads the metadata value for the format.

> NOTE This example requires the `reflect-metadata` library. See Metadata for
> more information about the `reflect-metadata` library.

## Parameter Decorators

A _Parameter Decorator_ is declared just before a parameter declaration. The
parameter decorator is applied to the function for a class constructor or
method declaration. A parameter decorator cannot be used in a declaration
file, an overload, or in any other ambient context (such as in a `declare`
class).

The expression for the parameter decorator will be called as a function at
runtime, with the following three arguments:

  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The ordinal index of the parameter in the function‚Äôs parameter list.

> NOTE A parameter decorator can only be used to observe that a parameter has
> been declared on a method.

The return value of the parameter decorator is ignored.

The following is an example of a parameter decorator (`@required`) applied to
parameter of a member of the `BugReport` class:

    
    
    ts
    
    class BugReport {
    
      type = "report";
    
      title: string;
    
    ¬†
    
      constructor(t: string) {
    
        this.title = t;
    
      }
    
    ¬†
    
      @validate
    
      print(@required verbose: boolean) {
    
        if (verbose) {
    
          return `type: ${this.type}\ntitle: ${this.title}`;
    
        } else {
    
         return this.title; 
    
        }
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgBueSAJhZAAUOBAHNImAFyhs6AJ4AaULAQl4CTHIBy2NNKqZk6UUt6QqRZLEoJpAFTnxeABVXrNhC1ZsAeWXIA+AEpQAG8AX3omFjYOBEgARwYkeN5hbDEJaQB5ACMAK2JMJRU1RE0AaUg5fUMkY1AAH1AqORRcklwSjN0JRABJdDNoaXQGdsQQiJoQUABaBaIGTAW5miJcbCoqUAAhBlEAJUhYMkwwmlBQTXhQAF5QACJ4041HgG5L66RMXEhaoyiT5fUjoAwIBgsMjCAH1URTL5XTAACyQVAAdKxfpB7tdPldIl9wNxcHwBF8VPVMIJwPEkilILwuIgOlR-qAOp1ILIEVcrkg6KBBJwWSQ2by+Vd4pgGAgOAADG7sgAkoRRaMxjkg4QAOlgfn9pKr1RisX9wvL8XzwqBILg2RdJaBpbKOCbMQbIO9QIjQJECTRwkA)

We can then define the `@required` and `@validate` decorators using the
following function declarations:

    
    
    ts
    
    import "reflect-metadata";
    
    const requiredMetadataKey = Symbol("required");
    
    ¬†
    
    function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    
      let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
    
      existingRequiredParameters.push(parameterIndex);
    
      Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);
    
    }
    
    ¬†
    
    function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    
      let method = descriptor.value!;
    
    ¬†
    
      descriptor.value = function () {
    
        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
    
        if (requiredParameters) {
    
          for (let parameterIndex of requiredParameters) {
    
            if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {
    
              throw new Error("Missing required argument.");
    
            }
    
          }
    
        }
    
        return method.apply(this, arguments);
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEkKSmhp5lCAspDgCYXYaqWGUygARAkgAzXMUwBaNHwHiA3DVLoqYqQEcArkim9uKnAGlIAT1ABeUAGVrKAEYlcACkmRDxyLziAJQaNNIG6ESYSCTooPpGJp44CADmPABcoADyrgBW8gA0oLAIJPAImNZW1lk6yOipoAA+oFQu7rjFsNjkyogAkui8MFnoBm6IQaAA3jSgoHJiMEg6SI0ASr6JAQAKvdj9CFRjE66IANoAuvagW7LyAHTpmNkA7uhm2Pw4ngn+ph43wENWKKRe3TKFSqNWmzVa1w0CxWa022wB+z6PEQVEesAMVAAFp4eljMINhjAQvM7jI5FFHiNpOtIF8fthPPF0SY2SCbMUUdE0X4TJjDtjjmDehCSlDEDCbNSAL40MIRKIxOIANzwSB+kGS0syoGw6GskPK8usADlxXVMA1UsURlQiMhYBwsgAVazwXi7OWVayEV3ujgAHgAYurorEAHzTOYLJagZSEki8W4ut1ID1kR463AGSAAQlCC2zYfzheLt3CkVjcU8iZpyZ4XJFewORxOoHGkwQ11u93pmGePHenyB7L+3ICvMs-NA4J4FuhNvF1IWCyQ0lAs87-u7EqoLe32+kZH3KdJ4vJCCGI2goBIe-+ouP99Ps1b59Au-3W8jkfGBQDjBxpQmDBMFxORGkwQkWlaSC0CwKgLiAiUQOgG47Dw0AIiZFleDPP9zwQso3j7SAqIAUQQMoEG8ThViodYmnfAITTSKCsEeYIkTI0AVTIkTtzEhYpEwAwEDiNMM0ebBYFgXBrGSQlVmKFDoNPQSlQ0JUgA)

The `@required` decorator adds a metadata entry that marks the parameter as
required. The `@validate` decorator then wraps the existing `print` method in
a function that validates the arguments before invoking the original method.

> NOTE This example requires the `reflect-metadata` library. See Metadata for
> more information about the `reflect-metadata` library.

## Metadata

Some examples use the `reflect-metadata` library which adds a polyfill for an
[experimental metadata API](https://github.com/rbuckton/ReflectDecorators).
This library is not yet part of the ECMAScript (JavaScript) standard. However,
once decorators are officially adopted as part of the ECMAScript standard
these extensions will be proposed for adoption.

You can install this library via npm:

    
    
    shell
    
    npm i reflect-metadata --save

TypeScript includes experimental support for emitting certain types of
metadata for declarations that have decorators. To enable this experimental
support, you must set the
[`emitDecoratorMetadata`](/tsconfig#emitDecoratorMetadata) compiler option
either on the command line or in your `tsconfig.json`:

**Command Line** :

    
    
    shell
    
    tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata

**tsconfig.json** :

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "ES5",
    
        "[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators)": true,
    
        "[emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata)": true
    
      }
    
    }

When enabled, as long as the `reflect-metadata` library has been imported,
additional design-time type information will be exposed at runtime.

We can see this in action in the following example:

    
    
    ts
    
    import "reflect-metadata";
    
    ¬†
    
    class Point {
    
      constructor(public x: number, public y: number) {}
    
    }
    
    ¬†
    
    class Line {
    
      private _start: Point;
    
      private _end: Point;
    
    ¬†
    
      @validate
    
      set start(value: Point) {
    
        this._start = value;
    
      }
    
    ¬†
    
      get start() {
    
        return this._start;
    
      }
    
    ¬†
    
      @validate
    
      set end(value: Point) {
    
        this._end = value;
    
      }
    
    ¬†
    
      get end() {
    
        return this._end;
    
      }
    
    }
    
    ¬†
    
    function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {
    
      let set = descriptor.set!;
    
      
    
      descriptor.set = function (value: T) {
    
        let type = Reflect.getMetadata("design:type", target, propertyKey);
    
    ¬†
    
        if (!(value instanceof type)) {
    
          throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);
    
        }
    
    ¬†
    
        set.call(this, value);
    
      };
    
    }
    
    ¬†
    
    const line = new Line()
    
    line.start = new Point(0, 0)
    
    ¬†
    
    // @ts-ignore
    
    // line.end = {}
    
    ¬†
    
    // Fails at runtime with:
    
    // > Invalid type, got object not Point
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMFsEsBcAikDGB7ATgQ3pgspPFgCY5YBQIEkAHgA6QazSQB2RANsutrhgM6Uw4fvCYp4ABQxoGGeAE8AkqwSwsHWAC8csNKwBcoAGYb+kcszqZ4oAEQZIxjqngBaFkVJE7AbnLkKBxY-Pygkmiw7KAA3uSgoOisohgArhKYABR0qQBGmiigNEasqdC5jAA0oDn5sIUKJWUVGACUsQC+5F2BwaGgADJRkLHxNUwAbjgjAPqiWPJGEVHw-gl0k9OgM2zES5Hs-mPgU5reFgnmtvPymaepkPsr7XEJCfAAFrD8AHRzRPJQABeUD3SBrUA9BIAc0IoBu8EyLzGCUc8FSGFYoE+3z+CIhUIgp1g5zGV1AuzuGgeT3YyLe2K+vx2rGIwNB1PBY0JsNslPpbzRGKxOOZuwJ3QCxlSrAkeixxPOAB4ACoAPkyAN5RiwrAU1Q2skYigA0pBGvCxFFodViJB+CgmHQ+EYVQoGMRpEb5ApkA6nXxVWqBS5rnCQXb-bBnZgflcAIQQsaRx3Rvhx8MmGVy-SgKkcGmgFUChKh7HukYggBKThcEh+vIIXjImTskdg0MMigYdmqWsIBpkclN5taRwZsGMefj+YeoCi81lkDQU+7kFaJbenxkAHdQKxIHu3QwAKIYGQYTIAAxUivLDGq0LQtgAJDE1yuOQXIB198-QG+a4-KwWAsB0PxXmOKKQgEDJXD8KAaBwmpMtUYJQQkHT+D0SSiKAmgHuyB57kMB5IuQBGQHGAK2CCxHhAciIAAzVExrQBFQ4DwPwbgdqwmAWFQlE-Ls7IxD0VAAGJYLAHBhDgoBpOwzAjDuCAfAYQigGqoC3hoJL3pAj7-mguQAFauH+tjLOw5BAA)

The TypeScript compiler will inject design-time type information using the
`@Reflect.metadata` decorator. You could consider it the equivalent of the
following TypeScript:

    
    
    ts
    
    class Line {
    
      private _start: Point;
    
      private _end: Point;
    
      @validate
    
      @Reflect.metadata("design:type", Point)
    
      set start(value: Point) {
    
        this._start = value;
    
      }
    
      get start() {
    
        return this._start;
    
      }
    
      @validate
    
      @Reflect.metadata("design:type", Point)
    
      set end(value: Point) {
    
        this._end = value;
    
      }
    
      get end() {
    
        return this._end;
    
      }
    
    }

> NOTE Decorator metadata is an experimental feature and may introduce
> breaking changes in future releases.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Decorators.md) ‚ù§

Contributors to this page:  

RB![Ron Buckton
\(54\)](https://gravatar.com/avatar/745f702d55c379fb824f5a03e0651e78?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MH![Mohamed Hegazy
\(3\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

DR![Dinanjanan Ravindran
\(2\)](https://gravatar.com/avatar/1bcdaa07af6253be79adc34bfba64898?s=32&&d=blank)

HA![Hossein Ahmadian-Yazdi
\(2\)](https://gravatar.com/avatar/e486af78745bd81069f00ebb26364938?s=32&&d=blank)

22+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# DOM Manipulation

## DOM Manipulation

### _An exploration into the`HTMLElement` type_

In the 20+ years since its standardization, JavaScript has come a very long
way. While in 2020, JavaScript can be used on servers, in data science, and
even on IoT devices, it is important to remember its most popular use case:
web browsers.

Websites are made up of HTML and/or XML documents. These documents are static,
they do not change. The _Document Object Model (DOM)_ is a programming
interface implemented by browsers to make static websites functional. The DOM
API can be used to change the document structure, style, and content. The API
is so powerful that countless frontend frameworks (jQuery, React, Angular,
etc.) have been developed around it to make dynamic websites even easier to
develop.

TypeScript is a typed superset of JavaScript, and it ships type definitions
for the DOM API. These definitions are readily available in any default
TypeScript project. Of the 20,000+ lines of definitions in _lib.dom.d.ts_ ,
one stands out among the rest: `HTMLElement`. This type is the backbone for
DOM manipulation with TypeScript.

> You can explore the source code for the [DOM type
> definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)

## Basic Example

Given a simplified _index.html_ file:

    
    
    html
    
    <!DOCTYPE html>
    
    <html lang="en">
    
      <head><title>TypeScript Dom Manipulation</title></head>
    
      <body>
    
        <div id="app"></div>
    
        <!-- Assume index.js is the compiled output of index.ts -->
    
        <script src="index.js"></script>
    
      </body>
    
    </html>

Let‚Äôs explore a TypeScript script that adds a `<p>Hello, World!</p>` element
to the `#app` element.

    
    
    ts
    
    // 1. Select the div element using the id property
    
    const app = document.getElementById("app");
    
    // 2. Create a new <p></p> element programmatically
    
    const p = document.createElement("p");
    
    // 3. Add the text content
    
    p.textContent = "Hello, World!";
    
    // 4. Append the p element to the div element
    
    app?.appendChild(p);

After compiling and running the _index.html_ page, the resulting HTML will be:

    
    
    html
    
    <div id="app">
    
      <p>Hello, World!</p>
    
    </div>

## The `Document` Interface

The first line of the TypeScript code uses a global variable `document`.
Inspecting the variable shows it is defined by the `Document` interface from
the _lib.dom.d.ts_ file. The code snippet contains calls to two methods,
`getElementById` and `createElement`.

### `Document.getElementById`

The definition for this method is as follows:

    
    
    ts
    
    getElementById(elementId: string): HTMLElement | null;

Pass it an element id string and it will return either `HTMLElement` or
`null`. This method introduces one of the most important types, `HTMLElement`.
It serves as the base interface for every other element interface. For
example, the `p` variable in the code example is of type
`HTMLParagraphElement`. Also, take note that this method can return `null`.
This is because the method can‚Äôt be certain pre-runtime if it will be able to
actually find the specified element or not. In the last line of the code
snippet, the new _optional chaining_ operator is used to call `appendChild`.

### `Document.createElement`

The definition for this method is (I have omitted the _deprecated_
definition):

    
    
    ts
    
    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];
    
    createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;

This is an overloaded function definition. The second overload is simplest and
works a lot like the `getElementById` method does. Pass it any `string` and it
will return a standard HTMLElement. This definition is what enables developers
to create unique HTML element tags.

For example `document.createElement('xyz')` returns a `<xyz></xyz>` element,
clearly not an element that is specified by the HTML specification.

> For those interested, you can interact with custom tag elements using the
> `document.getElementsByTagName`

For the first definition of `createElement`, it is using some advanced generic
patterns. It is best understood broken down into chunks, starting with the
generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression
defines a generic parameter `K` that is _constrained_ to the keys of the
interface `HTMLElementTagNameMap`. The map interface contains every specified
HTML tag name and its corresponding type interface. For example here are the
first 5 mapped values:

    
    
    ts
    
    interface HTMLElementTagNameMap {
    
        "a": HTMLAnchorElement;
    
        "abbr": HTMLElement;
    
        "address": HTMLElement;
    
        "applet": HTMLAppletElement;
    
        "area": HTMLAreaElement;
    
            ...
    
    }

Some elements do not exhibit unique properties and so they just return
`HTMLElement`, but other types do have unique properties and methods so they
return their specific interface (which will extend from or implement
`HTMLElement`).

Now, for the remainder of the `createElement` definition: `(tagName: K,
options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first
argument `tagName` is defined as the generic parameter `K`. The TypeScript
interpreter is smart enough to _infer_ the generic parameter from this
argument. This means that the developer does not have to specify the generic
parameter when using the method; whatever value is passed to the `tagName`
argument will be inferred as `K` and thus can be used throughout the remainder
of the definition. This is exactly what happens; the return value
`HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return
the corresponding type. This definition is how the `p` variable from the code
snippet gets a type of `HTMLParagraphElement`. And if the code was
`document.createElement('a')`, then it would be an element of type
`HTMLAnchorElement`.

## The `Node` interface

The `document.getElementById` function returns an `HTMLElement`. `HTMLElement`
interface extends the `Element` interface which extends the `Node` interface.
This prototypal extension allows for all `HTMLElements` to utilize a subset of
standard methods. In the code snippet, we use a property defined on the `Node`
interface to append the new `p` element to the website.

### `Node.appendChild`

The last line of the code snippet is `app?.appendChild(p)`. The previous,
`document.getElementById`, section detailed that the _optional chaining_
operator is used here because `app` can potentially be null at runtime. The
`appendChild` method is defined by:

    
    
    ts
    
    appendChild<T extends Node>(newChild: T): T;

This method works similarly to the `createElement` method as the generic
parameter `T` is inferred from the `newChild` argument. `T` is _constrained_
to another base interface `Node`.

## Difference between `children` and `childNodes`

Previously, this document details the `HTMLElement` interface extends from
`Element` which extends from `Node`. In the DOM API there is a concept of
_children_ elements. For example in the following HTML, the `p` tags are
children of the `div` element

    
    
    tsx
    
    <div>
    
      <p>Hello, World</p>
    
      <p>TypeScript!</p>
    
    </div>;
    
    const div = document.getElementsByTagName("div")[0];
    
    div.children;
    
    // HTMLCollection(2) [p, p]
    
    div.childNodes;
    
    // NodeList(2) [p, p]

After capturing the `div` element, the `children` prop will return an
`HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes`
property will return a similar `NodeList` list of nodes. Each `p` tag will
still be of type `HTMLParagraphElements`, but the `NodeList` can contain
additional _HTML nodes_ that the `HTMLCollection` list cannot.

Modify the HTML by removing one of the `p` tags, but keep the text.

    
    
    tsx
    
    <div>
    
      <p>Hello, World</p>
    
      TypeScript!
    
    </div>;
    
    const div = document.getElementsByTagName("div")[0];
    
    div.children;
    
    // HTMLCollection(1) [p]
    
    div.childNodes;
    
    // NodeList(2) [p, text]

See how both lists change. `children` now only contains the `<p>Hello,
World</p>` element, and the `childNodes` contains a `text` node rather than
two `p` nodes. The `text` part of the `NodeList` is the literal `Node`
containing the text `TypeScript!`. The `children` list does not contain this
`Node` because it is not considered an `HTMLElement`.

## The `querySelector` and `querySelectorAll` methods

Both of these methods are great tools for getting lists of dom elements that
fit a more unique set of constraints. They are defined in _lib.dom.d.ts_ as:

    
    
    ts
    
    /**
    
     * Returns the first element that is a descendant of node that matches selectors.
    
     */
    
    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    
    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
    
    querySelector<E extends Element = Element>(selectors: string): E | null;
    
    /**
    
     * Returns all element descendants of node that match selectors.
    
     */
    
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
    
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;

The `querySelectorAll` definition is similar to `getElementsByTagName`, except
it returns a new type: `NodeListOf`. This return type is essentially a custom
implementation of the standard JavaScript list element. Arguably, replacing
`NodeListOf<E>` with `E[]` would result in a very similar user experience.
`NodeListOf` only implements the following properties and methods: `length`,
`item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing.
Additionally, this method returns a list of _elements_ , not _nodes_ , which
is what `NodeList` was returning from the `.childNodes` method. While this may
appear as a discrepancy, take note that interface `Element` extends from
`Node`.

To see these methods in action modify the existing code to:

    
    
    tsx
    
    <ul>
    
      <li>First :)</li>
    
      <li>Second!</li>
    
      <li>Third times a charm.</li>
    
    </ul>;
    
    const first = document.querySelector("li"); // returns the first li element
    
    const all = document.querySelectorAll("li"); // returns the list of all li elements

## Interested in learning more?

The best part about the _lib.dom.d.ts_ type definitions is that they are
reflective of the types annotated in the Mozilla Developer Network (MDN)
documentation site. For example, the `HTMLElement` interface is documented by
this [HTMLElement
page](https://developer.mozilla.org/docs/Web/API/HTMLElement) on MDN. These
pages list all available properties, methods, and sometimes even examples.
Another great aspect of the pages is that they provide links to the
corresponding standard documents. Here is the link to the [W3C Recommendation
for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement).

Sources:

  * [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)
  * [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/DOM Manipulation.md)
‚ù§

Contributors to this page:  

EA![Ethan Arrowood
\(6\)](https://gravatar.com/avatar/b9fb0cf118e9cbf9a15d52d7071e554b?s=32&&d=blank)

OT![Orta Therox
\(5\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SA![Safei Ashraf
\(1\)](https://gravatar.com/avatar/82511a3c25761180c9795f778741c1da?s=32&&d=blank)

M![Mateusz
\(1\)](https://gravatar.com/avatar/a95e1e2931d8a09b5281659afeee992b?s=32&&d=blank)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

6+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Enums

Enums are one of the few features TypeScript has which is not a type-level
extension of JavaScript.

Enums allow a developer to define a set of named constants. Using enums can
make it easier to document intent, or create a set of distinct cases.
TypeScript provides both numeric and string-based enums.

## Numeric enums

We‚Äôll first start off with numeric enums, which are probably more familiar if
you‚Äôre coming from other languages. An enum can be defined using the `enum`
keyword.

    
    
    ts
    
    enum Direction {
    
      Up = 1,
    
      Down,
    
      Left,
    
      Right,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQCMANAbBgO4h2EAywAZqq1AEpwA5gAseeAL5A)

Above, we have a numeric enum where `Up` is initialized with `1`. All of the
following members are auto-incremented from that point on. In other words,
`Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right`
has `4`.

If we wanted, we could leave off the initializers entirely:

    
    
    ts
    
    enum Direction {
    
      Up,
    
      Down,
    
      Left,
    
      Right,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBZt4AvkA)

Here, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-
incrementing behavior is useful for cases where we might not care about the
member values themselves, but do care that each value is distinct from other
values in the same enum.

Using an enum is simple: just access any member as a property off of the enum
itself, and declare types using the name of the enum:

    
    
    ts
    
    enum UserResponse {
    
      No = 0,
    
      Yes = 1,
    
    }
    
    ¬†
    
    function respond(recipient: string, message: UserResponse): void {
    
      // ...
    
    }
    
    ¬†
    
    respond("Princess Caroline", UserResponse.Yes);
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAqgzsATgJWHADgexAqBvAKCigDlMoBeKABgBoioBNNSqARnoF8CCAzMEAGMALgEtsURGiwgAJgAopg0elGhhALihxhiUSADmtKBDRwAhgeBb4SVBmwIAlFoBumUbPwMA9D6gAdEEE3ARSDnLyAEQACnpCZlAAwuaImAA2+sBRxrYo0o7AAcxwTgDcQA)

Numeric enums can be mixed in computed and constant members (see below). The
short story is, enums without initializers either need to be first, or have to
come after numeric enums initialized with numeric constants or other constant
enum members. In other words, the following isn‚Äôt allowed:

    
    
    ts
    
    enum E {
    
      A = getSomeValue(),
    
      B,
    
    Enum member must have initializer.1061Enum member must have initializer.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYBsaBQBjOAO0QBdQBzSUgZTgFtIA1AQwBsBXSUAXlAAoAlLwB8oAEwBmANy4QoALRL8HUkoW5IRDvVABRUAG9coUAEFelanUatOkIQBoToAELOAvkA)

## String enums

String enums are a similar concept, but have some subtle runtime differences
as documented below. In a string enum, each member has to be constant-
initialized with a string literal, or with another string enum member.

    
    
    ts
    
    enum Direction {
    
      Up = "UP",
    
      Down = "DOWN",
    
      Left = "LEFT",
    
      Right = "RIGHT",
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQBERAClQDQGwYDu2lVMA8gOoByjZgBlgAM1QVqwgKIAxACpDCAJTgBzABaTOKgJIBxABJKmAXyA)

While string enums don‚Äôt have auto-incrementing behavior, string enums have
the benefit that they ‚Äúserialize‚Äù well. In other words, if you were debugging
and had to read the runtime value of a numeric enum, the value is often opaque
- it doesn‚Äôt convey any useful meaning on its own (though reverse mapping can
often help). String enums allow you to give a meaningful and readable value
when your code runs, independent of the name of the enum member itself.

## Heterogeneous enums

Technically enums can be mixed with string and numeric members, but it‚Äôs not
clear why you would ever want to do so:

    
    
    ts
    
    enum BooleanLikeHeterogeneousEnum {
    
      No = 0,
    
      Yes = "YES",
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAQg9nANsAhiAMgSwNbABLAAuwATnAOajBxgDOAouNAN4BQUUAcnFALxQAGADTsoATWC0+UAERj6AZRkiAvkA)

Unless you‚Äôre really trying to take advantage of JavaScript‚Äôs runtime behavior
in a clever way, it‚Äôs advised that you don‚Äôt do this.

## Computed and constant members

Each enum member has a value associated with it which can be either _constant_
or _computed_. An enum member is considered constant if:

  * It is the first member in the enum and it has no initializer, in which case it‚Äôs assigned the value `0`:
    
        ts
    
    // E.X is constant:
    
    enum E {
    
      X,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEFEDoA1QSwM6gMYHsB2CAuBDdWAuAKAFN0BXAWwlAG8jRRoAaIgXyA)

  * It does not have an initializer and the preceding enum member was a _numeric_ constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.
    
        ts
    
    // All enum members in 'E1' and 'E2' are constant.
    
    ¬†
    
    enum E1 {
    
      X,
    
      Y,
    
      Z,
    
    }
    
    ¬†
    
    enum E2 {
    
      A = 1,
    
      B,
    
      C,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEEEBtNBTA7ArgW1M2yBGsBOBnUAS3lAHIBRARlNAEN4ATM8gJhtp1lAGMB7ePABd6ggHQAocQhSgqoAN7jQoABoAaJaACaG5QC0NAX0nTUrBZvCgAvKEq7QAIQcBhI0A)

  * The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:

    1. a literal enum expression (basically a string literal or a numeric literal)
    2. a reference to previously defined constant enum member (which can originate from a different enum)
    3. a parenthesized constant enum expression
    4. one of the `+`, `-`, `~` unary operators applied to constant enum expression
    5. `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands

It is a compile time error for constant enum expressions to be evaluated to
`NaN` or `Infinity`.

In all other cases enum member is considered computed.

    
    
    ts
    
    enum FileAccess {
    
      // constant members
    
      None,
    
      Read = 1 << 1,
    
      Write = 1 << 2,
    
      ReadWrite = Read | Write,
    
      // computed member
    
      G = "123".length,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAYglgG2AQQMauAZ01A3gKCigHpipUB7ETAFwEMQaoJgIAjYAJ00KgDkqwADS8ASsDoATKAF4oARigAeJQpFEA6pzg1gshctUAmdVHFStOvXPPSAPlEu7TpchQgAHMLukt2XXgBxfQAieSMAZhCAOiQQAHMaAAsRAF8gA)

## Union enums and enum member types

There is a special subset of constant enum members that aren‚Äôt calculated:
literal enum members. A literal enum member is a constant enum member with no
initialized value, or with values that are initialized to

  * any string literal (e.g. `"foo"`, `"bar"`, `"baz"`)
  * any numeric literal (e.g. `1`, `100`)
  * a unary minus applied to any numeric literal (e.g. `-1`, `-100`)

When all members in an enum have literal enum values, some special semantics
come into play.

The first is that enum members also become types as well! For example, we can
say that certain members can _only_ have the value of an enum member:

    
    
    ts
    
    enum ShapeKind {
    
      Circle,
    
      Square,
    
    }
    
    ¬†
    
    interface Circle {
    
      kind: ShapeKind.Circle;
    
      radius: number;
    
    }
    
    ¬†
    
    interface Square {
    
      kind: ShapeKind.Square;
    
      sideLength: number;
    
    }
    
    ¬†
    
    let c: Circle = {
    
      kind: ShapeKind.Square,
    
    Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
    
      radius: 100,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFCQHYCuAtqAMoAWAhgA6QDSAlvgCagDeOooAwo9AGMANpAA0XcgEdCVaGJwBfHDmYAXGADMqAyL37DdnbgGtmLVJVoMzAOj6CRAbgnQqLRoRSgixAEYxnJRV8dWgtHSkZOQ4JU1YLajomVhsyaVlIZ25ERhZIABkCAHNVClQff2hA5RFVUAFUewNQAF4YkzMEq2SWVPS5cW5Xd09UAEYABgnxBUcgA)

The other change is that enum types themselves effectively become a _union_ of
each enum member. With union enums, the type system is able to leverage the
fact that it knows the exact set of values that exist in the enum itself.
Because of that, TypeScript can catch bugs where we might be comparing values
incorrectly. For example:

    
    
    ts
    
    enum E {
    
      Foo,
    
      Bar,
    
    }
    
    ¬†
    
    function f(x: E) {
    
      if (x !== E.Foo || x !== E.Bar) {
    
    This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.
    
        //
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUJAHYCuAtqAKKgDeeooAYnHADR2gBCAhtGwL548AM2KEAxgBcAlnEKghACgAeqCgEoa7KUNDLQAQgC8hygDomcUAB8roJQeNnu0DbXr0Q7AXyA)

In that example, we first checked whether `x` was _not_ `E.Foo`. If that check
succeeds, then our `||` will short-circuit, and the body of the ‚Äòif‚Äô will run.
However, if the check didn‚Äôt succeed, then `x` can _only_ be `E.Foo`, so it
doesn‚Äôt make sense to see whether it‚Äôs _not_ equal to `E.Bar`.

## Enums at runtime

Enums are real objects that exist at runtime. For example, the following enum

    
    
    ts
    
    enum E {
    
      X,
    
      Y,
    
      Z,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfIA)

can actually be passed around to functions

    
    
    ts
    
    enum E {
    
      X,
    
      Y,
    
      Z,
    
    }
    
    ¬†
    
    function f(obj: { X: number }) {
    
      return obj.X;
    
    }
    
    ¬†
    
    // Works, since 'E' has a property named 'X' which is a number.
    
    f(E);
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfRRAMzBAGMAXASwHsQoyAKBgIwCsAuBNPuAgdgAJyhEAlAiyjgNMKOacuAOlQBuRCUQB6XVADqDUQGsAzuijm61YFADkMB1AAWAQ3NR3UAA6iGXzEaAE8oEHcIYAATR1QXAHdXOipXKDovHyERUVVyVhhJDSA)

## Enums at compile time

Even though Enums are real objects that exist at runtime, the `keyof` keyword
works differently than you might expect for typical objects. Instead, use
`keyof typeof` to get a Type that represents all Enum keys as strings.

    
    
    ts
    
    enum LogLevel {
    
      ERROR,
    
      WARN,
    
      INFO,
    
      DEBUG,
    
    }
    
    ¬†
    
    /**
    
     * This is equivalent to:
    
     * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
    
     */
    
    type LogLevelStrings = keyof typeof LogLevel;
    
    ¬†
    
    function printImportant(key: LogLevelStrings, message: string) {
    
      const num = LogLevel[key];
    
      if (num <= LogLevel.WARN) {
    
        console.log("Log level key is:", key);
    
        console.log("Log level value is:", num);
    
        console.log("Log level message is:", message);
    
      }
    
    }
    
    printImportant("ERROR", "This is a message");
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAMg9gcxsAbsANlA3gKClAUQCUiB5IgGjygHUBBIgOSvwElGAxUlqAEQIBCAVQDiVAL44cAegBUsvLKgAVABYBLAM5QtUYAEcw6lAEN0oAC5QLcAFyLrATwAOwWImRp0AZQsAndRAEbQBeKAByYjIicKgAHwj6JliE8PYuFIj+YRFwgG5FaRwLFzd4JFQMXwCg0KgAa2BHOAAzJ1dW9wqvApwWsBAAYwt1OBAoZxqLVghnOD8LExALAApGx1suzyr-QOCKKAhgTU0TBGBNzV2ggEpsakGxq6hwaDDy7fQAbXWAXQL8Oo2itXlAADzvDyVdAAOiSjDuuHw+EeIE0cHMMPQiBWACJylBzF4Gk0dJpbLiDusbgDkaj0ZjsQg8QSiRgoKZ0GA3FoKQdXjTqCinhjgFicfjEIToYdjqdzmS+bKTmdgIL8JJJJNAtNZvNFss8VFyJSoLi1LpdCZlfLgLiaUA)

### Reverse mappings

In addition to creating an object with property names for members, numeric
enums members also get a _reverse mapping_ from enum values to enum names. For
example, in this example:

    
    
    ts
    
    enum Enum {
    
      A,
    
    }
    
    ¬†
    
    let a = Enum.A;
    
    let nameOfA = Enum[a]; // "A"
    
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAou0G8BQUoEEA0SC+SkBtgAXKAQygF5Z4A6NAbgOKhFImAHkAzNS6yANqkAuvSgB6cVABEaaUA)

TypeScript compiles this down to the following JavaScript:

    
    
    ts
    
    "use strict";
    
    var Enum;
    
    (function (Enum) {
    
        Enum[Enum["A"] = 0] = "A";
    
    })(Enum || (Enum = {}));
    
    let a = Enum.A;
    
    let nameOfA = Enum[a]; // "A"
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMB2BXZURAogb01FAEEAaTAX00wBtt1QBDUAXmNIB01ANyt2oXJ2TYA8gDNqvfoQDanALrDQIUACJquoA)

In this generated code, an enum is compiled into an object that stores both
forward (`name` -> `value`) and reverse (`value` -> `name`) mappings.
References to other enum members are always emitted as property accesses and
never inlined.

Keep in mind that string enum members _do not_ get a reverse mapping generated
at all.

### `const` enums

In most cases, enums are a perfectly valid solution. However sometimes
requirements are tighter. To avoid paying the cost of extra generated code and
additional indirection when accessing enum values, it‚Äôs possible to use
`const` enums. Const enums are defined using the `const` modifier on our
enums:

    
    
    ts
    
    const enum Enum {
    
      A = 1,
    
      B = A * 2,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUSag3gKBjAQRgF4YBGAGjxgCETCYAqGAJioF8g)

Const enums can only use constant enum expressions and unlike regular enums
they are completely removed during compilation. Const enum members are inlined
at use sites. This is possible since const enums cannot have computed members.

    
    
    ts
    
    const enum Direction {
    
      Up,
    
      Down,
    
      Left,
    
      Right,
    
    }
    
    ¬†
    
    let directions = [
    
      Direction.Up,
    
      Direction.Down,
    
      Direction.Left,
    
      Direction.Right,
    
    ];
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgEQJYCc7Ch8GAbwCgYYBVABwBoz0QB3MO8gGTgDMpWYAlDAHMAFjxIBfEiQA2cWABNsufOAgwAvDADa9TDjwEwAOmq89yw0bRMWupQfBGO3M-ZXGBIsQF0A3EA)

in generated code will become

    
    
    ts
    
    "use strict";
    
    let directions = [
    
        0 /* Direction.Up */,
    
        1 /* Direction.Down */,
    
        2 /* Direction.Left */,
    
        3 /* Direction.Right */,
    
    ];
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VABFUAnY7dVfUAb01FAFUAHAGg7UEeAZwAyxAGbpRoAEqoA5tBmYAvpkwAbYkQAmdBk3yRQAXlABtQTXqNmeAHS9Ztow8dVhrw-fyOJaR87YycFZVUAXQBuIA)

#### Const enum pitfalls

Inlining enum values is straightforward at first, but comes with subtle
implications. These pitfalls pertain to _ambient_ const enums only (basically
const enums in `.d.ts` files) and sharing them between projects, but if you
are publishing or consuming `.d.ts` files, these pitfalls likely apply to you,
because `tsc --declaration` transforms `.ts` files into `.d.ts` files.

  1. For the reasons laid out in the [`isolatedModules` documentation](/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](/tsconfig#isolatedModules) and those enum values at the same time.
  2. You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B‚Äôs enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.
  3. [`importsNotUsedAsValues: "preserve"`](/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](/docs/handbook/modules/reference.html#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.

Here are two approaches to avoiding these pitfalls:

  1. Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project‚Äôs own enums is not problematic and has performance implications.

  2. Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [`preserveConstEnums`](/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).

This way downstream consumers will not inline enums from your project,
avoiding the pitfalls above, but a project can still inline its own enums,
unlike banning const enums entirely.

## Ambient enums

Ambient enums are used to describe the shape of already existing enum types.

    
    
    ts
    
    declare enum Enum {
    
      A = 1,
    
      B,
    
      C = 2,
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEIB2BXAtvAoqjBvAUPPAILwC88AjADSHwBCtRAwufAEy0C+QA)

One important difference between ambient and non-ambient enums is that, in
regular enums, members that don‚Äôt have an initializer will be considered
constant if its preceding enum member is considered constant. By contrast, an
ambient (and non-const) enum member that does not have an initializer is
_always_ considered computed.

## Objects vs Enums

In modern TypeScript, you may not need an enum when an object with `as const`
could suffice:

    
    
    ts
    
    const enum EDirection {
    
      Up,
    
      Down,
    
      Left,
    
      Right,
    
    }
    
    ¬†
    
    const ODirection = {
    
      Up: 0,
    
      Down: 1,
    
      Left: 2,
    
      Right: 3,
    
    } as const;
    
    ¬†
    
    EDirection.Up;
    
               
    
    (enum member) EDirection.Up = 0
    
    ¬†
    
    ODirection.Up;
    
               
    
    (property) Up: 0
    
    ¬†
    
    // Using the enum as a parameter
    
    function walk(dir: EDirection) {}
    
    ¬†
    
    // It requires an extra line to pull out the values
    
    type Direction = typeof ODirection[keyof typeof ODirection];
    
    function run(dir: Direction) {}
    
    ¬†
    
    walk(EDirection.Left);
    
    run(ODirection.Right);
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUQCIEsBOdhRbgwDeAUDDAKoAOANBTBiAO5gOUAycAZlBzABKWAOYALfmQC+ZMqEiwA8tjwEiYGAF5SjWgC4YABgHM2BgIwDufAwCYBw8VAMBmBlJgBDCDHnQA3LKYuPiE4AB0tIEA9NGU8QkAegD8ssohahFRZLEJeSmyuVQQWGAiMFBicPBIqN5eMDSeOJ7IcFBwOGQ8iGCZGiyeADYA1gAUACa4BsGqYWAAlKQyOXEAkrB4AI6IIT6eGnAAHlAtMEOl1VAgjYhDQzAgiLCV1QBuw4hwEGRQAJ40aoqULqLQVAFwEA8GDpObqADaIzgfyh4MBqNhIPAAF1Aj0+vMYDhepNpkwMvMliQVoNRmNZliwOFrFAFoFiWAxpj+uFHBI2UA)

The biggest argument in favour of this format over TypeScript‚Äôs `enum` is that
it keeps your codebase aligned with the state of JavaScript, and
[when/if](https://github.com/rbuckton/proposal-enum) enums are added to
JavaScript then you can move to the additional syntax.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Enums.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(17\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AG![Attila Gonda
\(1\)](https://gravatar.com/avatar/68d74196326d4e28b67ea17484cb86a0?s=32&&d=blank)

FDG-S![Frank de Groot - Schouten
\(1\)](https://gravatar.com/avatar/49fa8984f48bfe9d972c24786b9f7b83?s=32&&d=blank)

G![green961
\(1\)](https://gravatar.com/avatar/a451a0d3c90d361ce0fdaced1460f946?s=32&&d=blank)

TA![Tex Andersen
\(1\)](https://gravatar.com/avatar/bab069c1e51e51d5bfaf1745976b4d2e?s=32&&d=blank)

11+

Last updated: Sep 16, 2024  
  

  Was this page helpful?

### This page has been deprecated

This handbook page has been replaced, [go to the new
page](/docs/handbook/2/functions.html)

[Go to new page](/docs/handbook/2/functions.html)

# Functions

Functions are the fundamental building block of any application in JavaScript.
They‚Äôre how you build up layers of abstraction, mimicking classes, information
hiding, and modules. In TypeScript, while there are classes, namespaces, and
modules, functions still play the key role in describing how to _do_ things.
TypeScript also adds some new capabilities to the standard JavaScript
functions to make them easier to work with.

## Functions

To begin, just as in JavaScript, TypeScript functions can be created both as a
named function or as an anonymous function. This allows you to choose the most
appropriate approach for your application, whether you‚Äôre building a list of
functions in an API or a one-off function to hand off to another function.

To quickly recap what these two approaches look like in JavaScript:

    
    
    ts
    
    // Named function
    
    function add(x, y) {
    
      return x + y;
    
    }
    
    ¬†
    
    // Anonymous function
    
    let myAdd = function (x, y) {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigBymAtngCYYCuAdsvAPb0HoNOuiZVUAUADwA0oAJ4BKUAG8CoULDzRaseqEGgA1OIDcBAL4EiYAIL1WY8s1qQ6jaCzbYlocmJN9QAXjtc1Q0UkZOQUlFTUNbTE9fR0gA)

Just as in JavaScript, functions can refer to variables outside of the
function body. When they do so, they‚Äôre said to _capture_ these variables.
While understanding how this works (and the trade-offs when using this
technique) is outside of the scope of this article, having a firm
understanding how this mechanic works is an important piece of working with
JavaScript and TypeScript.

    
    
    ts
    
    let z = 100;
    
    ¬†
    
    function addToZ(x, y) {
    
      return x + y + z;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgBeoAvKAIwAMdA3AQegK4B2y8A9h6JgAmggCo8AWgAoAHgBpQATwCUoAN4FQoWCTax+00AGpFR8swC+QA)

## Function Types

### Typing the function

Let‚Äôs add types to our simple examples from earlier:

    
    
    ts
    
    function add(x: number, y: number): number {
    
      return x + y;
    
    }
    
    ¬†
    
    let myAdd = function (x: number, y: number): number {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAQwCaoBQA8BciwgC2ARgKYBOANIgJ54EkUCU9RZ5iA3gFCKLmkoIckiyIA1LQDc3AL7duAG0GJCNAILpEAXkShIsBImytGVWqfYt8bCl179Bw0ROlypQA)

We can add types to each of the parameters and then to the function itself to
add a return type. TypeScript can figure the return type out by looking at the
return statements, so we can also optionally leave this off in many cases.

### Writing the function type

Now that we‚Äôve typed the function, let‚Äôs write the full type of the function
out by looking at each piece of the function type.

    
    
    ts
    
    let myAdd: (x: number, y: number) => number = function (
    
      x: number,
    
      y: number
    
    ): number {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngggEwQLggCgB6oHYFcoBGIATgDQQw75HECUEAvAHwR6EmMQBmu2AxmACWAe2zoAUBAhZW1EqUkUq7YuNrKaEAN6Li4XMTEYIAagoBucQF9zQA)

A function‚Äôs type has the same two parts: the type of the arguments and the
return type. When writing out the whole function type, both parts are
required. We write out the parameter types just like a parameter list, giving
each parameter a name and a type. This name is just to help with readability.
We could have instead written:

    
    
    ts
    
    let myAdd: (baseValue: number, increment: number) => number = function (
    
      x: number,
    
      y: number
    
    ): number {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngggEwQLggCgEYEMDOIBqWwAriKgHbFQYgBOANBAJbkDGtIUI5YFVNtAJQQAvAD4IlanVEQAZsTZgmAe3LoAUBAgAPPtIZaIMfQI2DTMgN5GOYYrXU6IAamMBuDQF93QA)

As long as the parameter types line up, it‚Äôs considered a valid type for the
function, regardless of the names you give the parameters in the function
type.

The second part is the return type. We make it clear which is the return type
by using an arrow (`=>`) between the parameters and the return type. As
mentioned before, this is a required part of the function type, so if the
function doesn‚Äôt return a value, you would use `void` instead of leaving it
off.

Of note, only the parameters and the return type make up the function type.
Captured variables are not reflected in the type. In effect, captured
variables are part of the ‚Äúhidden state‚Äù of any function and do not make up
its API.

### Inferring the types

In playing with the example, you may notice that the TypeScript compiler can
figure out the type even if you only have types on one side of the equation:

    
    
    ts
    
    // The parameters 'x' and 'y' have the type number
    
    let myAdd = function (x: number, y: number): number {
    
      return x + y;
    
    };
    
    ¬†
    
    // myAdd has the full function type
    
    let myAdd2: (baseValue: number, increment: number) => number = function (x, y) {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIM6gOQAe+oCAdgCYECeJkCAbrBjKBtXLGQK6oBG2AFAAbTKFTUAghSoBeUADNuZAMYYAlgHsyoABSEAXKB79sAGlDUjJgUgCU13rdABvQaFBJM3JDsKgAaksAbkEAX1DBEHEpGVB6PBZYJWFhRWU1LR12ThExCWkKACYjXT4EHGgANQRhbmhHUyQLdVUvdDIMRts7UFkAPmMnbD701Q1tPUILal63Dy8MHz9AkPDgoA)

This is called ‚Äúcontextual typing‚Äù, a form of type inference. This helps cut
down on the amount of effort to keep your program typed.

## Optional and Default Parameters

In TypeScript, every parameter is assumed to be required by the function. This
doesn‚Äôt mean that it can‚Äôt be given `null` or `undefined`, but rather, when
the function is called, the compiler will check that the user has provided a
value for each parameter. The compiler also assumes that these parameters are
the only parameters that will be passed to the function. In short, the number
of arguments given to a function has to match the number of parameters the
function expects.

    
    
    ts
    
    function buildName(firstName: string, lastName: string) {
    
      return firstName + " " + lastName;
    
    }
    
    ¬†
    
    let result1 = buildName("Bob"); // error, too few parameters
    
    Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.
    
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    
    Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.
    
    let result3 = buildName("Bob", "Adams"); // ah, just right
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIYiVOkBKUAG9coUNEjlC0WgKErQAalAAiezYVLh3SAG5cAX1y4mxw0hEQiZyAEZQAF56RlYVXjsAITg6O013UBBQGHhoeXI4OFB8SAB3UAAHDmg3chhEPwCjYNC0KJjmdjcE5NT5OwBBFm5EO36AZWgAOjSMrJyEfMLQLg5iAE9K6tr6xvJAlvIAZnaGTviklLH7IZHZzLAOAAt5ACtCcUNKaSfyIA)

In JavaScript, every parameter is optional, and users may leave them off as
they see fit. When they do, their value is `undefined`. We can get this
functionality in TypeScript by adding a `?` to the end of parameters we want
to be optional. For example, let‚Äôs say we want the last name parameter from
above to be optional:

    
    
    ts
    
    function buildName(firstName: string, lastName?: string) {
    
      if (lastName) return firstName + " " + lastName;
    
      else return firstName;
    
    }
    
    ¬†
    
    let result1 = buildName("Bob"); // works correctly now
    
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    
    Expected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.
    
    let result3 = buildName("Bob", "Adams"); // ah, just right
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIAfjESp0gJSgA3rlChK+UL0XLukXdEjlC0WgKErQAalAAiL+4VLhVgDchqCQTIiQoLb2jqDOljzBAL64uEx2UZCIhEzkAIygALz0jKwqvJ4AQnB0ntqBoCCgAO4IANaIoKQIthRMAJ6gxHDNaRm22bloRSXM7FYV1bXyngCCLNyInisAytAAdHUNTTDw0PLkcHCgXBzEgwAOHNBW5DCIY+SZk+QAzDMMOblKo1bZedabI6NMAcAAW8gAVoRxFFKNJYeQgA)

Any optional parameters must follow required parameters. Had we wanted to make
the first name optional, rather than the last name, we would need to change
the order of parameters in the function, putting the first name last in the
list.

In TypeScript, we can also set a value that a parameter will be assigned if
the user does not provide one, or if the user passes `undefined` in its place.
These are called default-initialized parameters. Let‚Äôs take the previous
example and default the last name to `"Smith"`.

    
    
    ts
    
    function buildName(firstName: string, lastName = "Smith") {
    
      return firstName + " " + lastName;
    
    }
    
    ¬†
    
    let result1 = buildName("Bob"); // works correctly now, returns "Bob Smith"
    
    let result2 = buildName("Bob", undefined); // still works, also returns "Bob Smith"
    
    let result3 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    
    Expected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.
    
    let result4 = buildName("Bob", "Adams"); // ah, just right
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIoALygARAGUulcgAtNASlABvXKFDRI5QtFoChK0AGotH94uXdIAblwAX1xcJltrSERCJnIARnV6RlYVXk0AITg6Ez9QEFAAdwQAa0RQUgQbCiYAT1BiOHz5GzsHUvTM0F19I1DwmyiYtASGZnZfVIys+RIWSAFiSBZjHLzxZiYC4sR5DiZEOAiW4jbJzr1DTV7yCIHyAGZhpLGeCczNeU0AQRZuRHetbTQAB02VyYBg8Gg8nIcAOXA4xFqAAcONBfOQYIgrjdouRsI9Ril2lMtN9fqC8hwDPIAFaEcTWSjSAzkIA)

Default-initialized parameters that come after all required parameters are
treated as optional, and just like optional parameters, can be omitted when
calling their respective function. This means optional parameters and trailing
default parameters will share commonality in their types, so both

    
    
    ts
    
    function buildName(firstName: string, lastName?: string) {
    
      // ...
    
    }

and

    
    
    ts
    
    function buildName(firstName: string, lastName = "Smith") {
    
      // ...
    
    }

share the same type `(firstName: string, lastName?: string) => string`. The
default value of `lastName` disappears in the type, only leaving behind the
fact that the parameter is optional.

Unlike plain optional parameters, default-initialized parameters don‚Äôt _need_
to occur after required parameters. If a default-initialized parameter comes
before a required parameter, users need to explicitly pass `undefined` to get
the default initialized value. For example, we could write our last example
with only a default initializer on `firstName`:

    
    
    ts
    
    function buildName(firstName = "Will", lastName: string) {
    
      return firstName + " " + lastName;
    
    }
    
    ¬†
    
    let result1 = buildName("Bob"); // error, too few parameters
    
    Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.
    
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    
    Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.
    
    let result3 = buildName("Bob", "Adams"); // okay and returns "Bob Adams"
    
    let result4 = buildName(undefined, "Adams"); // okay and returns "Will Adams"
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceoALygARAHVmTSQBpQTDomHdIqNdErEA5gEpQAb1yhQ0SOULRaAoSMigA1FLeuVaxwG5cAX1xcJisLSERCJnIARnF6RlZHXkkAITg6SQNvUBBQGHhoJXI4OFB8SAB3UAAHDmgNchhEIJDLcMi0WIZmdg0k1PSlSQBBFm5ERSkAZWgAOgysnLyEQuLQLg5iAE9q2vrG5vJQtvIAZk74np4+tInh0a5xzOywOABrDm2NllDrW0QpfqgEZjSQHI4RcjYc7dRIkFiQATESAsQbAh7zZ6gN4fUBfH42Yj-GRyIH3cZAA)

### Rest Parameters

Required, optional, and default parameters all have one thing in common: they
talk about one parameter at a time. Sometimes, you want to work with multiple
parameters as a group, or you may not know how many parameters a function will
ultimately take. In JavaScript, you can work with the arguments directly using
the `arguments` variable that is visible inside every function body.

In TypeScript, you can gather these arguments together into a variable:

    
    
    ts
    
    function buildName(firstName: string, ...restOfName: string[]) {
    
      return firstName + " " + restOfName.join(" ");
    
    }
    
    ¬†
    
    // employeeName will be "Joseph Samuel Lucas MacKinzie"
    
    let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIxDANgEwHIEMC2ApgBTAwBOAzlHkQFyLXkxgDmANIgHQ-mHUB5YLUIMmLVgG0AugEpEAbwBQiRHyghySMlRoFCiANSIARKaNr+UISK4ArOC2JmTsgNxKAvkqUB6X4iE+AAO6HAAnoSEIogA7hjoKAYmAFJwlITBABaIAMoEIISJADIgELiUiACyuBAA0iwAXjCEJkrohFCBIWGR0fqIALwoaFgizmkZ2SacJvn4hegzpqXllMsmNfVNLa5uQA)

_Rest parameters_ are treated as a boundless number of optional parameters.
When passing arguments for a rest parameter, you can use as many as you want;
you can even pass none. The compiler will build an array of the arguments
passed in with the name given after the ellipsis (`...`), allowing you to use
it in your function.

The ellipsis is also used in the type of the function with rest parameters:

    
    
    ts
    
    function buildName(firstName: string, ...restOfName: string[]) {
    
      return firstName + " " + restOfName.join(" ");
    
    }
    
    ¬†
    
    let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIxDANgEwHIEMC2ApgBTAwBOAzlHkQFyLXkxgDmANIgHQ-mHUB5YLUIMmLVgG0AugEpEAbwBQiRHyghySMlRoFCiANSIARKaNr+UISK4ArOC2JmTsgNxKAvkqXpCUFDQsEQAxcAZSMH0xKGY2Th4uPmoYuKk5RABeAD5GWIkswIwcfTcgA)

## `this`

Learning how to use `this` in JavaScript is something of a rite of passage.
Since TypeScript is a superset of JavaScript, TypeScript developers also need
to learn how to use `this` and how to spot when it‚Äôs not being used correctly.
Fortunately, TypeScript lets you catch incorrect uses of `this` with a couple
of techniques. If you need to learn how `this` works in JavaScript, though,
first read Yehuda Katz‚Äôs [Understanding JavaScript Function Invocation and
‚Äúthis‚Äù](http://yehudakatz.com/2011/08/11/understanding-javascript-function-
invocation-and-this/). Yehuda‚Äôs article explains the inner workings of `this`
very well, so we‚Äôll just cover the basics here.

### `this` and arrow functions

In JavaScript, `this` is a variable that‚Äôs set when a function is called. This
makes it a very powerful and flexible feature, but it comes at the cost of
always having to know about the context that a function is executing in. This
is notoriously confusing, especially when returning a function or passing a
function as an argument.

Let‚Äôs look at an example:

    
    
    ts
    
    let deck = {
    
      suits: ["hearts", "spades", "clubs", "diamonds"],
    
      cards: Array(52),
    
      createCardPicker: function () {
    
        return function () {
    
          let pickedCard = Math.floor(Math.random() * 52);
    
          let pickedSuit = Math.floor(pickedCard / 13);
    
    ¬†
    
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
    
        };
    
      },
    
    };
    
    ¬†
    
    let cardPicker = deck.createCardPicker();
    
    let pickedCard = cardPicker();
    
    ¬†
    
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgAmeiA1qALygDeBookArvNJGgNoBEACzyZYXPgBpQfSAAdMFSBKmJsbAEaLJfMvEwBbAPYA7MooC645qEQjTaAIKxYmAJ4AKAKwAmAJSWWiLDC0HgAwrYACkhUeLBo6GxGyPDGoG4+jFYsQdBssEYYicmp6Zks5aDEpDLReGThsGR0oACymNACAHTo2AYGsG5tHZ3OJgZ6pQBUoN4+ANxZ5VWgNdR1AMocpPRDXT19A6sx9bagYACMAMzzBIvZJHkFDKxbaB3wkJ3snJA8RxtbCzWWxof4nRqgACkoCuoAAvgsKgirHDLMiiCRgY0omtYM0KNROoFgmFIrUBjdlmCGk16DZseT0gsCDhYtA3Hx6WQ0HxQABqFa1cFkImnAW8gzoKT8wVrYVfLbzIA)

Notice that `createCardPicker` is a function that itself returns a function.
If we tried to run the example, we would get an error instead of the expected
alert box. This is because the `this` being used in the function created by
`createCardPicker` will be set to `window` instead of our `deck` object.
That‚Äôs because we call `cardPicker()` on its own. A top-level non-method
syntax call like this will use `window` for `this`. (Note: under strict mode,
`this` will be `undefined` rather than `window`).

We can fix this by making sure the function is bound to the correct `this`
before we return the function to be used later. This way, regardless of how
it‚Äôs later used, it will still be able to see the original `deck` object. To
do this, we change the function expression to use the ECMAScript 6 arrow
syntax. Arrow functions capture the `this` where the function is created
rather than where it is invoked:

    
    
    ts
    
    let deck = {
    
      suits: ["hearts", "spades", "clubs", "diamonds"],
    
      cards: Array(52),
    
      createCardPicker: function () {
    
        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here
    
        return () => {
    
          let pickedCard = Math.floor(Math.random() * 52);
    
          let pickedSuit = Math.floor(pickedCard / 13);
    
    ¬†
    
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
    
        };
    
      },
    
    };
    
    ¬†
    
    let cardPicker = deck.createCardPicker();
    
    let pickedCard = cardPicker();
    
    ¬†
    
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgAmeiA1qALygDeBookArvNJGgNoBEACzyZYXPgBpQfSAAdMFSBKmJsbAEaLJfMvEwBbAPYA7MooC645qEQjTaAIKxYmAJ4AKAKwAmAJSWWiLDC0HgAwrYACkhUeLBo6GxGyPDGoG4+jFYsIKAAcgDyACoAomjQQqDY8EZ4oGp42AYA7qDwkKBGzaCYRt1OXQlJ0ClGkjiNTdUA5qBs7dAG1pgy0GxBoADk5W0boAhTAqRCQVl7JGu96XQAfJks95UkoDLReGThsGR0oACymOUAOnQjQMsDcf0BzhMBj0VwAVKBvD4ANynFjEUgvahvADKHFI9AhAiBILBWJi71soDAAEYAMwoghos6rWC9BisfFlARtAHsTiQHjk3H4ixLT5oYWUz6gACkoHpoAAvqiHiqrErLOqiE8bJ8otjYN8KNQAYFgmFIq8wYyMc9XtKvvQ9WQDTEbaiCDhYtA3HwXWg+KAANT27GOs1U0NBgzoKQhsMUj5kPn4lFAA)

Even better, TypeScript will warn you when you make this mistake if you pass
the [`noImplicitThis`](/tsconfig#noImplicitThis) flag to the compiler. It will
point out that `this` in `this.suits[pickedSuit]` is of type `any`.

### `this` parameters

Unfortunately, the type of `this.suits[pickedSuit]` is still `any`. That‚Äôs
because `this` comes from the function expression inside the object literal.
To fix this, you can provide an explicit `this` parameter. `this` parameters
are fake parameters that come first in the parameter list of a function:

    
    
    ts
    
    function f(this: void) {
    
      // make sure `this` is unusable in this standalone function
    
    }

Let‚Äôs add a couple of interfaces to our example above, `Card` and `Deck`, to
make the types clearer and easier to reuse:

    
    
    ts
    
    interface Card {
    
      suit: string;
    
      card: number;
    
    }
    
    ¬†
    
    interface Deck {
    
      suits: string[];
    
      cards: number[];
    
      createCardPicker(this: Deck): () => Card;
    
    }
    
    ¬†
    
    let deck: Deck = {
    
      suits: ["hearts", "spades", "clubs", "diamonds"],
    
      cards: Array(52),
    
      // NOTE: The function now explicitly specifies that its callee must be of type Deck
    
      createCardPicker: function (this: Deck) {
    
        return () => {
    
          let pickedCard = Math.floor(Math.random() * 52);
    
          let pickedSuit = Math.floor(pickedCard / 13);
    
    ¬†
    
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
    
        };
    
      },
    
    };
    
    ¬†
    
    let cardPicker = deck.createCardPicker();
    
    let pickedCard = cardPicker();
    
    ¬†
    
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJygE2QbwFDLIDOArsGAFzFhSgDmA3AcghplSCQLYBG0TAXzx5QkWIhQARCAgDWuZqXJEqRGvQDaAXSaFWWFck69o23SygQ4kdFgAKwOdAAUYABbBD0uQEoqzn2QAXgA+NDZBYQAbCDBkTBlZKm95IIVCJTBDDQAiNysoLJyAGmQcogAHOASiErKEKJIeWtKczGA4LgB7EExarWLmfT6qAEEoKDgAT2cAVgAmH0HCAHoV5AA5AHkAFQBRKh385BgSEAQwYB6jLoB3ZAgADwqox3IoqeIKmWAYYAgiMh3NZkMoWHAojEUFwSGpkHxkF0YECpt9kCkhpZrBBbJgHE4oFRTudLtdXB4vIlAvhCIRLGASFAQMgAsEwjTaYQYnEKo5ZBBMLjgsgALLWNwAOhgUS6XSgzjF7glk16XS4rIAVMgFj5zJzucheU5MABlMhxNKKyXS2Xyo38wVsZDrACMAGZdcJOXTYozmThiOaqO5PBLMkQNPaBWbyANwVgqFHHVhkABSZDu5ACPVZ8wCQbZ6KxeN4vnQYUJOQShBYmxsfH8+Weg1JoVpYYNlyevAQ6BgZw5YZUHLIADUhrLycw1ad45HSLKY4nxtxYfNuqAA)

Now TypeScript knows that `createCardPicker` expects to be called on a `Deck`
object. That means that `this` is of type `Deck` now, not `any`, so
[`noImplicitThis`](/tsconfig#noImplicitThis) will not cause any errors.

#### `this` parameters in callbacks

You can also run into errors with `this` in callbacks, when you pass functions
to a library that will later call them. Because the library that calls your
callback will call it like a normal function, `this` will be `undefined`. With
some work you can use `this` parameters to prevent errors with callbacks too.
First, the library author needs to annotate the callback type with `this`:

    
    
    ts
    
    interface UIElement {
    
      addClickListener(onclick: (this: void, e: Event) => void): void;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoEkCiAbCBbCcZAbwChlk4ATKgYW2AQGsAZYAZ0hGgAoB7EAgbMAXMh5gAFhzEA3PsCoAaZBDGZZhMAEpkAXgB8yeYu1yFVANykAvkA)

`this: void` means that `addClickListener` expects `onclick` to be a function
that does not require a `this` type. Second, annotate your calling code with
`this`:

    
    
    ts
    
    class Handler {
    
      info: string;
    
      onClickBad(this: Handler, e: Event) {
    
        // oops, used `this` here. using this callback would crash at runtime
    
        this.info = e.message;
    
      }
    
    }
    
    ¬†
    
    let h = new Handler();
    
    uiElement.addClickListener(h.onClickBad); // error!
    
    Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.
      The 'this' types of each signature are incompatible.
        Type 'void' is not assignable to type 'Handler'.2345Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.
      The 'this' types of each signature are incompatible.
        Type 'void' is not assignable to type 'Handler'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAgR6ywD2skaATAMwAsArAfAHbSlaJ6gCqASQCi2PAFs8HUAG8CoUJgAmigMLYkAawAy8GJNIAKcm0TrEGtAegALXWgBu5eIoA0oPGiH3J0AJSgAXgA+UEdnXwcnRQBuAgBfVg4uTB5QLx8ZOVAJSEhMAHMPUBgENnzYhMU8U0xYXkRjGFAAV3gRcR80QXaJDljiAFohxGboIYGCGtzQAAlMNkVRWEz5dnRyNBL2cqzjNU0AISUrW2pZ+cXSNyL0jn9ZeXlicnIAB0g3ZvxFUAADG10v1A1lIeAAdC1INtQADIKBEDhsAAjFIaUAAd3IzWwP0QsEwkGsCmgoFgzQ48AkWXksLBa3IgXcYJyeUKsXkCQSBFEJKJAVAbDw6POCyWBl8sVaPR8YKUqjM2l0nEFsAM1jBewVR0UEtAxFIFFgAEIgA)

With `this` annotated, you make it explicit that `onClickBad` must be called
on an instance of `Handler`. Then TypeScript will detect that
`addClickListener` requires a function that has `this: void`. To fix the
error, change the type of `this`:

    
    
    ts
    
    class Handler {
    
      info: string;
    
      onClickGood(this: void, e: Event) {
    
        // can't use `this` here because it's of type void!
    
        console.log("clicked!");
    
      }
    
    }
    
    ¬†
    
    let h = new Handler();
    
    uiElement.addClickListener(h.onClickGood);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDwB20esWieoAqgJICi2eAtnqaAN4GiiYAm-AMLYkAawAy8GO3IAKAPbFEoxGLRzoAC2loAbgvj8ANKDxoGe9tACUoALwA+UAaM39h-gG4CAXyKk5JTUltZcPKBskJCYAObmoDAIxLE+-vx4Kpiw1IhKMKAArvBMrNZo9KVspD4goAC0jYiF0I31BFnRoAASmMT8zLDhvCToCmhJJKkRSiLiAOIKCvyaOpAeRqYJoaR23Ly8dYh9AOTQRfigAAba0legWuTUAEaZmIWX8NAnkKAK6KBoABPAAO1Fc-AAhBFeHliJAFMwAHTYBSxOQAIhU4jwUIxNh8vH8-gIzHOWgcoGIeAA7j0+gN5ASCMUqtYkQJhKpJNIyNTYHItEjZtzFssCUA)

Because `onClickGood` specifies its `this` type as `void`, it is legal to pass
to `addClickListener`. Of course, this also means that it can‚Äôt use
`this.info`. If you want both then you‚Äôll have to use an arrow function:

    
    
    ts
    
    class Handler {
    
      info: string;
    
      onClickGood = (e: Event) => {
    
        this.info = e.message;
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDwB20esWieoAqgJICi2eAtnqaAN4GiiYAm-AMLYkAawAy8GO3IAKAPbFEoxGLRzoAC2loAbgvj8ANKDxoGe9tACUoALwA+UAaM39h-gG4CAXyKk5JTUltZcPKBskJCYAObmoDAIxLE+-vx4Kpiw1IhKMKAArvBMrNZo9KVspD4goAC0jYiF0I31BFnRoAASmMT8zLDhvCToCmhJJKkRSiLiAOIKCvwOoHIJoaR2TsO8oNrSAHSjCqt4h1Ex8T68vmlAA)

This works because arrow functions use the outer `this`, so you can always
pass them to something that expects `this: void`. The downside is that one
arrow function is created per object of type Handler. Methods, on the other
hand, are only created once and attached to Handler‚Äôs prototype. They are
shared between all objects of type Handler.

## Overloads

JavaScript is inherently a very dynamic language. It‚Äôs not uncommon for a
single JavaScript function to return different types of objects based on the
shape of the arguments passed in.

    
    
    ts
    
    let suits = ["hearts", "spades", "clubs", "diamonds"];
    
    ¬†
    
    function pickCard(x: any): any {
    
      // Check to see if we're working with an object/array
    
      // if so, they gave us the deck and we'll pick the card
    
      if (typeof x == "object") {
    
        let pickedCard = Math.floor(Math.random() * x.length);
    
        return pickedCard;
    
      }
    
      // Otherwise just let them pick the card
    
      else if (typeof x == "number") {
    
        let pickedSuit = Math.floor(x / 13);
    
        return { suit: suits[pickedSuit], card: x % 13 };
    
      }
    
    }
    
    ¬†
    
    let myDeck = [
    
      { suit: "diamonds", card: 2 },
    
      { suit: "spades", card: 10 },
    
      { suit: "hearts", card: 4 },
    
    ];
    
    ¬†
    
    let pickedCard1 = myDeck[pickCard(myDeck)];
    
    alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
    
    ¬†
    
    let pickedCard2 = pickCard(15);
    
    alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SiQCu80koAvKANoBEAFnprNUwDShOQAHTABM8kHn0TZyAI3G8mw+JgC2AewB2w8QF0A3AQLpyG5PE2gBSANYBhDsIAUADzSYNATwCUbz6ADeBKCgIKC2bIjWoNBqZHh4oPDooADueADksAkparDW8BoA5qlULKDuoGoyAFZ4yMAcsJgeQSFgSWRqvNBsHqCFmABuCeQ0PQmikeVaqRnY2JY20WygiA6tHY7QHgJ4asnOdPRMVbXITF4BrcHEpFaReML2sMJ0oACymD0AdOjYarlHJ8fk0tGoVI5LgAqUDOb7EIo9LwGYLBLLQciwDSLB5PBwo0AAX1aoQA8uNYCl4PhQNVRqRbss8CocVFxqt1sE8LgEpttrt9rCjnwNOQVDI8LALldUaBGfdrI8AMqUUj0YEsX7-QGHMAARgAzMjrqB0Zjsf4yKq0BQqJAGArlaqdLw1i80IcAKSgQ1EgnE4lEEigFQeAAidSi9AYrUtttQfCUqk02gkbuEaAATETuLGrVQ0PwhKJ5Bz3T6AAw5vPxwtsDhcV0ONAAFmr+kM8psj2ewj1b1DEciDpsvccg8jXg7OEl0EcTHThdAAGpWT2HHrvumV3xKskmDvHXiXpv48ag3du8fhNn6Aqx3qAKzGmeceeL3ero+9zNbhw7g9BQPL8rx-b4zz0IA)

Here, the `pickCard` function will return two different things based on what
the user has passed in. If the users passes in an object that represents the
deck, the function will pick the card. If the user picks the card, we tell
them which card they‚Äôve picked. But how do we describe this to the type
system?

The answer is to supply multiple function types for the same function as a
list of overloads. This list is what the compiler will use to resolve function
calls. Let‚Äôs create a list of overloads that describe what our `pickCard`
accepts and what it returns.

    
    
    ts
    
    let suits = ["hearts", "spades", "clubs", "diamonds"];
    
    ¬†
    
    function pickCard(x: { suit: string; card: number }[]): number;
    
    function pickCard(x: number): { suit: string; card: number };
    
    function pickCard(x: any): any {
    
      // Check to see if we're working with an object/array
    
      // if so, they gave us the deck and we'll pick the card
    
      if (typeof x == "object") {
    
        let pickedCard = Math.floor(Math.random() * x.length);
    
        return pickedCard;
    
      }
    
      // Otherwise just let them pick the card
    
      else if (typeof x == "number") {
    
        let pickedSuit = Math.floor(x / 13);
    
        return { suit: suits[pickedSuit], card: x % 13 };
    
      }
    
    }
    
    ¬†
    
    let myDeck = [
    
      { suit: "diamonds", card: 2 },
    
      { suit: "spades", card: 10 },
    
      { suit: "hearts", card: 4 },
    
    ];
    
    ¬†
    
    let pickedCard1 = myDeck[pickCard(myDeck)];
    
    alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
    
    ¬†
    
    let pickedCard2 = pickCard(15);
    
    alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzgrglmKEC8EDaAiAFiAhgJ0QwBoIMoAHXAExChLIGNgYAje0jauXAWwHsAdtXoBdANwAoSQDMYgxmDhCIFOIwDWAYQLUAFAA8AXBADe0eGBNQw+OIIDm4iI10nBMXqxD4IAXzRRAEp3T298KTkFJRU1TR18fWMIDy8fELMLBGtbeycXNxSwn39I+UVlQVV1bV1DE1xBAE8MxqazSQgIAHpuiC0cTQgwfmgQEAg4GQgAdxAAcnwJmf58DTzZhCwIRoh+VgArEEVugnxcJs6evqnoflIwHHaHXAA3CZgkR4naIcbqWYLYDAapDb4FRJXW56MBNCggfjTAwoVAYfZHRQYIIdLpdUCQOIaEDUBIA1AAWVwjwAdDJgPxVnpKTTzsJ+Lw9NiAFQQAzU0COR5BKS4iBLMAwfBVQnE0ki-xXXoQADy33wMzgUAmB0+kHxwxwvFBGgNE1ckK6IGAWsm0xhcIRSJRZFS4SxONx+pl1AAypYUBBmVhafTGci+gBGADMwquXXFkqq5lg2SyiDQ3r9CFEpHN1BMyIApBBo6Urn5JBXJPreE0ACLHE2oNBXZOWExcHgCYQcCH5iAAJn8xFbaY7lBodAYeZMEYADMPRymrGQcAQiLnCgAWRcSaRemqy3QRgO1huaDM1Ul6M+NoJ73CgQh6DAzsgQADUxqPiQj1Lzn7voi75ft6pJ-susbVuA34kroQ6oIS14RgArLGj4+GAL5vhggFgfB-66IBuHAbhoGHnBiQDtSkHiEAA)

With this change, the overloads now give us type checked calls to the
`pickCard` function.

In order for the compiler to pick the correct type check, it follows a similar
process to the underlying JavaScript. It looks at the overload list and,
proceeding with the first overload, attempts to call the function with the
provided parameters. If it finds a match, it picks this overload as the
correct overload. For this reason, it‚Äôs customary to order overloads from most
specific to least specific.

Note that the `function pickCard(x): any` piece is not part of the overload
list, so it only has two overloads: one that takes an object and one that
takes a number. Calling `pickCard` with any other parameter types would cause
an error.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Functions.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(55\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DR![Daniel Rosenwasser
\(23\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

OT![Orta Therox
\(18\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nathan Shively-Sanders
\(4\)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

24+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

### This page has been deprecated

This handbook page has been replaced, [go to the new
page](/docs/handbook/2/generics.html)

[Go to new page](/docs/handbook/2/generics.html)

# Generics

A major part of software engineering is building components that not only have
well-defined and consistent APIs, but are also reusable. Components that are
capable of working on the data of today as well as the data of tomorrow will
give you the most flexible capabilities for building up large software
systems.

In languages like C# and Java, one of the main tools in the toolbox for
creating reusable components is _generics_ , that is, being able to create a
component that can work over a variety of types rather than a single one. This
allows users to consume these components and use their own types.

## Hello World of Generics

To start off, let‚Äôs do the ‚Äúhello world‚Äù of generics: the identity function.
The identity function is a function that will return back whatever is passed
in. You can think of this in a similar way to the `echo` command.

Without generics, we would either have to give the identity function a
specific type:

    
    
    ts
    
    function identity(arg: number): number {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)

Or, we could describe the identity function using the `any` type:

    
    
    ts
    
    function identity(arg: any): any {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)

While using `any` is certainly generic in that it will cause the function to
accept any and all types for the type of `arg`, we actually are losing the
information about what that type was when the function returns. If we passed
in a number, the only information we have is that any type could be returned.

Instead, we need a way of capturing the type of the argument in such a way
that we can also use it to denote what is being returned. Here, we will use a
_type variable_ , a special kind of variable that works on types rather than
values.

    
    
    ts
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+QA)

We‚Äôve now added a type variable `T` to the identity function. This `T` allows
us to capture the type the user provides (e.g. `number`), so that we can use
that information later. Here, we use `T` again as the return type. On
inspection, we can now see the same type is used for the argument and the
return type. This allows us to traffic that type information in one side of
the function and out the other.

We say that this version of the `identity` function is generic, as it works
over a range of types. Unlike using `any`, it‚Äôs also just as precise (ie, it
doesn‚Äôt lose any information) as the first `identity` function that used
numbers for the argument and return type.

Once we‚Äôve written the generic identity function, we can call it in one of two
ways. The first way is to pass all of the arguments, including the type
argument, to the function:

    
    
    ts
    
    let output = identity<string>("myString");
    
          
    
    let output: string
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bAPQTEAWjkQQUOTLYAbHojiKADosQBeZOkwwcuAM5RyMMJRIAiALbYAylZuV79EVM5-OAHoA-EA)

Here we explicitly set `T` to be `string` as one of the arguments to the
function call, denoted using the `<>` around the arguments rather than `()`.

The second way is also perhaps the most common. Here we use _type argument
inference_ ‚Äî that is, we want the compiler to set the value of `T` for us
automatically based on the type of the argument we pass in:

    
    
    ts
    
    let output = identity("myString");
    
          
    
    let output: string
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bAPQTEAWjkQQUOTLYAbHojiKADosQBeZOkwwcxAEQBbbAGUo5GGErn6IqZw+cAegH4gA)

Notice that we didn‚Äôt have to explicitly pass the type in the angle brackets
(`<>`); the compiler just looked at the value `"myString"`, and set `T` to its
type. While type argument inference can be a helpful tool to keep code shorter
and more readable, you may need to explicitly pass in the type arguments as we
did in the previous example when the compiler fails to infer the type, as may
happen in more complex examples.

## Working with Generic Type Variables

When you begin to use generics, you‚Äôll notice that when you create generic
functions like `identity`, the compiler will enforce that you use any
generically typed parameters in the body of the function correctly. That is,
that you actually treat these parameters as if they could be any and all
types.

Let‚Äôs take our `identity` function from earlier:

    
    
    ts
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+QA)

What if we want to also log the length of the argument `arg` to the console
with each call? We might be tempted to write this:

    
    
    ts
    
    function loggingIdentity<T>(arg: T): T {
    
      console.log(arg.length);
    
    Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFQB8ACgCG0RqmEBKOaADeuUKFI1EcOpAB0DRlJkGejcgAt5AbjWhokcoWi1pjWwF8gA)

When we do, the compiler will give us an error that we‚Äôre using the `.length`
member of `arg`, but nowhere have we said that `arg` has this member.
Remember, we said earlier that these type variables stand in for any and all
types, so someone using this function could have passed in a `number` instead,
which does not have a `.length` member.

Let‚Äôs say that we‚Äôve actually intended this function to work on arrays of `T`
rather than `T` directly. Since we‚Äôre working with arrays, the `.length`
member should be available. We can describe this just like we would create
arrays of other types:

    
    
    ts
    
    function loggingIdentity<T>(arg: T[]): T[] {
    
      console.log(arg.length);
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFQD4AKAQwCc0AuRSgbQF0BKNzrogDeAKESIICAM5xkBAHSo0DZoqJooACx4BuMYkYEoIRkiZo9AXyA)

You can read the type of `loggingIdentity` as ‚Äúthe generic function
`loggingIdentity` takes a type parameter `T`, and an argument `arg` which is
an array of `T`s, and returns an array of `T`s.‚Äù If we passed in an array of
numbers, we‚Äôd get an array of numbers back out, as `T` would bind to `number`.
This allows us to use our generic type variable `T` as part of the types we‚Äôre
working with, rather than the whole type, giving us greater flexibility.

We can alternatively write the sample example this way:

    
    
    ts
    
    function loggingIdentity<T>(arg: Array<T>): Array<T> {
    
      console.log(arg.length); // Array has a .length, so no more error
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFQD4AKAQwCc0AuRAQUcfopoEo2nbr2qIA3gChEiCAgDOcZAQB0qNA2aqiaKAAs+AbkQB6Yxy49Eu+nMT1EW7HoA0iBYjBxEAWziMCiARcflKI-lAgjEhMaAYSAL5AA)

You may already be familiar with this style of type from other languages. In
the next section, we‚Äôll cover how you can create your own generic types like
`Array<T>`.

## Generic Types

In previous sections, we created generic identity functions that worked over a
range of types. In this section, we‚Äôll explore the type of the functions
themselves and how to create generic interfaces.

The type of generic functions is just like those of non-generic functions,
with the type parameters listed first, similarly to function declarations:

    
    
    ts
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: <T>(arg: T) => T = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctAiUFN6iALyE6e5MqzYhQA)

We could also have used a different name for the generic type parameter in the
type, so long as the number of type variables and how the type variables are
used line up.

    
    
    ts
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: <U>(arg: U) => U = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctXAFUSg2hvqIAvIUQbDyZVmxCgA)

We can also write the generic type as a call signature of an object literal
type:

    
    
    ts
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: { <T>(arg: T): T } = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctFogIlBTRnUSjEAXmTKs2IUA)

Which leads us to writing our first generic interface. Let‚Äôs take the object
literal from the previous example and move it to an interface:

    
    
    ts
    
    interface GenericIdentityFn {
    
      <T>(arg: T): T;
    
    }
    
    ¬†
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: GenericIdentityFn = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVAPgAo4oBzALmSYCUfJgG4aAXxo0YAVxAIiAe0rAC4YiWbtOvfkP7U6yKBDAyolHWMk0ANqeQBbEvkIa+6TFGyv1pCsgAvMiqbqQiQA)

In a similar example, we may want to move the generic parameter to be a
parameter of the whole interface. This lets us see what type(s) we‚Äôre generic
over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the
type parameter visible to all the other members of the interface.

    
    
    ts
    
    interface GenericIdentityFn<T> {
    
      (arg: T): T;
    
    }
    
    ¬†
    
    function identity<T>(arg: T): T {
    
      return arg;
    
    }
    
    ¬†
    
    let myIdentity: GenericIdentityFn<number> = identity;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFQD5kBvAKGWQAo4oBzALmWoCUfagG4mAXyZMYAVxAIiAexDJgBcMRI1aHbsKH9GLZFAhgZUFZy5jJTADZnkAWxL5CmvukxRs7jaQUlCAyzgBG0PQAvKrqRKQiQA)

Notice that our example has changed to be something slightly different.
Instead of describing a generic function, we now have a non-generic function
signature that is a part of a generic type. When we use `GenericIdentityFn`,
we now will also need to specify the corresponding type argument (here:
`number`), effectively locking in what the underlying call signature will use.
Understanding when to put the type parameter directly on the call signature
and when to put it on the interface itself will be helpful in describing what
aspects of a type are generic.

In addition to generic interfaces, we can also create generic classes. Note
that it is not possible to create generic enums and namespaces.

## Generic Classes

A generic class has a similar shape to a generic interface. Generic classes
have a generic type parameter list in angle brackets (`<>`) following the name
of the class.

    
    
    ts
    
    class GenericNumber<T> {
    
      zeroValue: T;
    
      add: (x: T, y: T) => T;
    
    }
    
    ¬†
    
    let myGenericNumber = new GenericNumber<number>();
    
    myGenericNumber.zeroValue = 0;
    
    myGenericNumber.add = function (x, y) {
    
      return x + y;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8AKgHygBvAqFAAvOgHsAajiZ403ANzDQmACZq0ACgAeCgDSgAngoCUoALz8lBAL4EC2PNFAsjVWvWbs6l0LQB3Sho6JG8OWE5qVgjeLVNlNw9Qxhi6ADpxWGlZPD8ABkT3EK802HT1NT90JmpkeAlqUF1DI3MhEVhnJlgmnVAAamNlW0UgA)

This is a pretty literal use of the `GenericNumber` class, but you may have
noticed that nothing is restricting it to only use the `number` type. We could
have instead used `string` or even more complex objects.

    
    
    ts
    
    let stringNumeric = new GenericNumber<string>();
    
    stringNumeric.zeroValue = "";
    
    stringNumeric.add = function (x, y) {
    
      return x + y;
    
    };
    
    ¬†
    
    console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8AKgHygBvAqFAAvOgHsAajiZ403ANzDQmACZq0ACgAeCgDSgAngoCUoALz8lBAL4EQoALQvETaC6cFseaKBgI1ADmzCx0SJagtADulDThjKwcsJwB8MG8WqbKacGhCQB04rDSsniRAEQVOXDpIayF6mqR6EzUyPAS1KC6hkbmQiKwvkyw3TqgANTGyrbKRF2QEj4F2BJBWrn1YfQFTZu1eQ27xaXYcoYV0HgwFabZQA)

Just as with interface, putting the type parameter on the class itself lets us
make sure all of the properties of the class are working with the same type.

As we covered in [our section on classes](/docs/handbook/classes.html), a
class has two sides to its type: the static side and the instance side.
Generic classes are only generic over their instance side rather than their
static side, so when working with classes, static members can not use the
class‚Äôs type parameter.

## Generic Constraints

If you remember from an earlier example, you may sometimes want to write a
generic function that works on a set of types where you have some knowledge
about what capabilities that set of types will have. In our `loggingIdentity`
example, we wanted to be able to access the `.length` property of `arg`, but
the compiler could not prove that every type had a `.length` property, so it
warns us that we can‚Äôt make this assumption.

    
    
    ts
    
    function loggingIdentity<T>(arg: T): T {
    
      console.log(arg.length);
    
    Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFQB8ACgCG0RqmEBKOaADeuUKFI1EcOpAB0DRlJkGejcgAt5AbjWhokcoWi1pjWwF8gA)

Instead of working with any and all types, we‚Äôd like to constrain this
function to work with any and all types that also have the `.length` property.
As long as the type has this member, we‚Äôll allow it, but it‚Äôs required to have
at least this member. To do so, we must list our requirement as a constraint
on what T can be.

To do so, we‚Äôll create an interface that describes our constraint. Here, we‚Äôll
create an interface that has a single `.length` property and then we‚Äôll use
this interface and the `extends` keyword to denote our constraint:

    
    
    ts
    
    interface Lengthwise {
    
      length: number;
    
    }
    
    ¬†
    
    function loggingIdentity<T extends Lengthwise>(arg: T): T {
    
      console.log(arg.length); // Now we know it has a .length property, so no more error
    
      return arg;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABVkEAB6QQSwmlq4CxAHwAKOFEyNtASifJylBJMLiaAOioZOwcA8xxnLmQAeijkADlxPGQ8FABrEETkYDBkHDhTOGRQrFxkAAcocTLoDQAaZB8mcWRWcSgUaEqoCmR2sGYoKXtMHl4gA)

Because the generic function is now constrained, it will no longer work over
any and all types:

    
    
    ts
    
    loggingIdentity(3);
    
    Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVUJAAeZIucQNR7LjwB8ABSU0MyoDgCU4aD8gtR6iHAiAHRChsGhqT5sEUqC0JAkktD6IcxKqiCgALS11JIktdV4aUYmFlYEtoEYuUA)

Instead, we need to pass in values whose type has all the required properties:

    
    
    ts
    
    loggingIdentity({ length: 10, value: 3 });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABVkEAB6QQSwmlq4CxAHwAKOFEyNtASifJylBJMLiaAOioZOwcA8xxnHkooCDBmKCl7TB5+AHoU5ABaLIRmMCyMskDZeWVVYA0bEmowxgBGAAYAGmQANzgqZghGAGZkXgigA)

### Using Type Parameters in Generic Constraints

You can declare a type parameter that is constrained by another type
parameter. For example, here we‚Äôd like to get a property from an object given
its name. We‚Äôd like to ensure that we‚Äôre not accidentally grabbing a property
that does not exist on the `obj`, so we‚Äôll place a constraint between the two
types:

    
    
    ts
    
    function getProperty<T, K extends keyof T>(obj: T, key: K) {
    
      return obj[key];
    
    }
    
    ¬†
    
    let x = { a: 1, b: 2, c: 3, d: 4 };
    
    ¬†
    
    getProperty(x, "a");
    
    getProperty(x, "m");
    
    Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.2345Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKgBpQAaVCQAHhUgkAJolABrSFzgFQfAHwAKOACMAVqkGLlqYQEpQAbzyhQ0JkWh09+gNpKuAXQDceAL54eAA2TKDioAC81qAAhqgAjEK6qGhCZKgYQjKoWKD+fniMLOycXFriQgBEsVXmfsWscBzQ3BXVALZ1PkA)

### Using Class Types in Generics

When creating factories in TypeScript using generics, it is necessary to refer
to class types by their constructor functions. For example,

    
    
    ts
    
    function create<T>(c: { new (): T }): T {
    
      return new c();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoB8AFBAFyIDeiYaA7okQJTl6IC+zirFAUIouiggUSGvQhMA3DzZA)

A more advanced example uses the prototype property to infer and constrain
relationships between the constructor function and the instance side of class
types.

    
    
    ts
    
    class BeeKeeper {
    
      hasMask: boolean;
    
    }
    
    ¬†
    
    class ZooKeeper {
    
      nametag: string;
    
    }
    
    ¬†
    
    class Animal {
    
      numLegs: number;
    
    }
    
    ¬†
    
    class Bee extends Animal {
    
      keeper: BeeKeeper;
    
    }
    
    ¬†
    
    class Lion extends Animal {
    
      keeper: ZooKeeper;
    
    }
    
    ¬†
    
    function createInstance<A extends Animal>(c: new () => A): A {
    
      return new c();
    
    }
    
    ¬†
    
    createInstance(Lion).keeper.nametag;
    
    createInstance(Bee).keeper.hasMask;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdgG4CAXwJESZUAC0xdPI2ZsOUzAFs80TAHM0MBFLNzFy0uQCCU+IZyt2oKQFdDAGTwzSDRfQyEmOyViR0pqUDwAD2g8KQATZ1d3bE8OfgYmNCpaAtgoh1V-eBEpBOTUjNAXNw89UHztQvVNUvL0HylkatrEWEkUgEkpGGlEPAAeJzqU9MyW7AA+AApEULwAd1AtgEpQAF4NpuO0Jbax6B9YWqkD0EQT8tHxvCmZwbwtlUascAHQdHQggzGUy2IhjTCTaamf5bYqg8FMEHcSB8SD8GRAA)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Generics.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(51\)](https://gravatar.com/avatar/b9d274ea3df40f132936da582f71b18f?s=32&&d=blank)

OT![Orta Therox
\(19\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(19\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

MH![Mohamed Hegazy
\(5\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

RC![Rick Carlino
\(4\)](https://gravatar.com/avatar/f8b1ebd488deae76d970e7944fbae8e5?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Gulp

This quick start guide will teach you how to build TypeScript with
[gulp](https://gulpjs.com) and then add [Browserify](https://browserify.org),
[terser](https://terser.org), or
[Watchify](https://github.com/substack/watchify) to the gulp pipeline. This
guide also shows how to add [Babel](https://babeljs.io/) functionality using
[Babelify](https://github.com/babel/babelify).

We assume that you‚Äôre already using [Node.js](https://nodejs.org/) with
[npm](https://www.npmjs.com/).

## Minimal project

Let‚Äôs start out with a new directory. We‚Äôll name it `proj` for now, but you
can change it to whatever you want.

    
    
    shell
    
    mkdir proj
    
    cd proj

To start, we‚Äôre going to structure our project in the following way:

    
    
    proj/
    
       ‚îú‚îÄ src/
    
       ‚îî‚îÄ dist/

TypeScript files will start out in your `src` folder, run through the
TypeScript compiler and end up in `dist`.

Let‚Äôs scaffold this out:

    
    
    shell
    
    mkdir src
    
    mkdir dist

### Initialize the project

Now we‚Äôll turn this folder into an npm package.

    
    
    shell
    
    npm init

You‚Äôll be given a series of prompts. You can use the defaults except for your
entry point. For your entry point, use `./dist/main.js`. You can always go
back and change these in the `package.json` file that‚Äôs been generated for
you.

### Install our dependencies

Now we can use `npm install` to install packages. First install `gulp-cli`
globally (if you use a Unix system, you may need to prefix the `npm install`
commands in this guide with `sudo`).

    
    
    shell
    
    npm install -g gulp-cli

Then install `typescript`, `gulp` and `gulp-typescript` in your project‚Äôs dev
dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript)
is a gulp plugin for TypeScript.

    
    
    shell
    
    npm install --save-dev typescript gulp@4.0.0 gulp-typescript

### Write a simple example

Let‚Äôs write a Hello World program. In `src`, create the file `main.ts`:

    
    
    ts
    
    function hello(compiler: string) {
    
      console.log(`Hello from ${compiler}`);
    
    }
    
    hello("TypeScript");

In the project root, `proj`, create the file `tsconfig.json`:

    
    
    {
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts"],
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es5"
    
      }
    
    }

### Create a `gulpfile.js`

In the project root, create the file `gulpfile.js`:

    
    
    js
    
    var gulp = require("gulp");
    
    var ts = require("gulp-typescript");
    
    var tsProject = ts.createProject("tsconfig.json");
    
    gulp.task("default", function () {
    
      return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist"));
    
    });

### Test the resulting app

    
    
    shell
    
    gulp
    
    node dist/main.js

The program should print ‚ÄúHello from TypeScript!‚Äú.

## Add modules to the code

Before we get to Browserify, let‚Äôs build our code out and add modules to the
mix. This is the structure you‚Äôre more likely to use for a real app.

Create a file called `src/greet.ts`:

    
    
    ts
    
    export function sayHello(name: string) {
    
      return `Hello from ${name}`;
    
    }

Now change the code in `src/main.ts` to import `sayHello` from `greet.ts`:

    
    
    ts
    
    import { sayHello } from "./greet";
    
    console.log(sayHello("TypeScript"));

Finally, add `src/greet.ts` to `tsconfig.json`:

    
    
    {
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts", "src/greet.ts"],
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es5"
    
      }
    
    }

Make sure that the modules work by running `gulp` and then testing in Node:

    
    
    shell
    
    gulp
    
    node dist/main.js

Notice that even though we used ES2015 module syntax, TypeScript emitted
CommonJS modules that Node uses. We‚Äôll stick with CommonJS for this tutorial,
but you could set `module` in the options object to change this.

## Browserify

Now let‚Äôs move this project from Node to the browser. To do this, we‚Äôd like to
bundle all our modules into one JavaScript file. Fortunately, that‚Äôs exactly
what Browserify does. Even better, it lets us use the CommonJS module system
used by Node, which is the default TypeScript emit. That means our TypeScript
and Node setup will transfer to the browser basically unchanged.

First, install browserify, [tsify](https://www.npmjs.com/package/tsify), and
vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript,
gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the
file output of Browserify back into a format that gulp understands called
[vinyl](https://github.com/gulpjs/vinyl).

    
    
    shell
    
    npm install --save-dev browserify tsify vinyl-source-stream

### Create a page

Create a file in `src` named `index.html`:

    
    
    html
    
    <!DOCTYPE html>
    
    <html>
    
      <head>
    
        <meta charset="UTF-8" />
    
        <title>Hello World!</title>
    
      </head>
    
      <body>
    
        <p id="greeting">Loading ...</p>
    
        <script src="bundle.js"></script>
    
      </body>
    
    </html>

Now change `main.ts` to update the page:

    
    
    ts
    
    import { sayHello } from "./greet";
    
    function showHello(divName: string, name: string) {
    
      const elt = document.getElementById(divName);
    
      elt.innerText = sayHello(name);
    
    }
    
    showHello("greeting", "TypeScript");

Calling `showHello` calls `sayHello` to change the paragraph‚Äôs text. Now
change your gulpfile to the following:

    
    
    js
    
    var gulp = require("gulp");
    
    var browserify = require("browserify");
    
    var source = require("vinyl-source-stream");
    
    var tsify = require("tsify");
    
    var paths = {
    
      pages: ["src/*.html"],
    
    };
    
    gulp.task("copy-html", function () {
    
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    
    });
    
    gulp.task(
    
      "default",
    
      gulp.series(gulp.parallel("copy-html"), function () {
    
        return browserify({
    
          basedir: ".",
    
          debug: true,
    
          entries: ["src/main.ts"],
    
          cache: {},
    
          packageCache: {},
    
        })
    
          .plugin(tsify)
    
          .bundle()
    
          .pipe(source("bundle.js"))
    
          .pipe(gulp.dest("dist"));
    
      })
    
    );

This adds the `copy-html` task and adds it as a dependency of `default`. That
means any time `default` is run, `copy-html` has to run first. We‚Äôve also
changed `default` to call Browserify with the tsify plugin instead of gulp-
typescript. Conveniently, they both allow us to pass the same options object
to the TypeScript compiler.

After calling `bundle` we use `source` (our alias for vinyl-source-stream) to
name our output bundle `bundle.js`.

Test the page by running gulp and then opening `dist/index.html` in a browser.
You should see ‚ÄúHello from TypeScript‚Äù on the page.

Notice that we specified `debug: true` to Browserify. This causes tsify to
emit source maps inside the bundled JavaScript file. Source maps let you debug
your original TypeScript code in the browser instead of the bundled
JavaScript. You can test that source maps are working by opening the debugger
for your browser and putting a breakpoint inside `main.ts`. When you refresh
the page the breakpoint should pause the page and let you debug `greet.ts`.

## Watchify, Babel, and Terser

Now that we are bundling our code with Browserify and tsify, we can add
various features to our build with browserify plugins.

  * Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.

  * Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn‚Äôt support.

  * Terser compacts your code so that it takes less time to download.

### Watchify

We‚Äôll start with Watchify to provide background compilation:

    
    
    shell
    
    npm install --save-dev watchify fancy-log

Now change your gulpfile to the following:

    
    
    js
    
    var gulp = require("gulp");
    
    var browserify = require("browserify");
    
    var source = require("vinyl-source-stream");
    
    var watchify = require("watchify");
    
    var tsify = require("tsify");
    
    var fancy_log = require("fancy-log");
    
    var paths = {
    
      pages: ["src/*.html"],
    
    };
    
    var watchedBrowserify = watchify(
    
      browserify({
    
        basedir: ".",
    
        debug: true,
    
        entries: ["src/main.ts"],
    
        cache: {},
    
        packageCache: {},
    
      }).plugin(tsify)
    
    );
    
    gulp.task("copy-html", function () {
    
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    
    });
    
    function bundle() {
    
      return watchedBrowserify
    
        .bundle()
    
        .on("error", fancy_log)
    
        .pipe(source("bundle.js"))
    
        .pipe(gulp.dest("dist"));
    
    }
    
    gulp.task("default", gulp.series(gulp.parallel("copy-html"), bundle));
    
    watchedBrowserify.on("update", bundle);
    
    watchedBrowserify.on("log", fancy_log);

There are basically three changes here, but they require you to refactor your
code a bit.

  1. We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.
  2. We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.
  3. We called `watchedBrowserify.on('log', fancy_log);` to log to the console.

Together (1) and (2) mean that we have to move our call to `browserify` out of
the `default` task. And we have to give the function for `default` a name
since both Watchify and Gulp need to call it. Adding logging with (3) is
optional but very useful for debugging your setup.

Now when you run Gulp, it should start and stay running. Try changing the code
for `showHello` in `main.ts` and saving it. You should see output that looks
like this:

    
    
    shell
    
    proj$ gulp
    
    [10:34:20] Using gulpfile ~/src/proj/gulpfile.js
    
    [10:34:20] Starting 'copy-html'...
    
    [10:34:20] Finished 'copy-html' after 26 ms
    
    [10:34:20] Starting 'default'...
    
    [10:34:21] 2824 bytes written (0.13 seconds)
    
    [10:34:21] Finished 'default' after 1.36 s
    
    [10:35:22] 2261 bytes written (0.02 seconds)
    
    [10:35:24] 2808 bytes written (0.05 seconds)

### Terser

First install Terser. Since the point of Terser is to mangle your code, we
also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps
working.

    
    
    shell
    
    npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps

Now change your gulpfile to the following:

    
    
    js
    
    var gulp = require("gulp");
    
    var browserify = require("browserify");
    
    var source = require("vinyl-source-stream");
    
    var terser = require("gulp-terser");
    
    var tsify = require("tsify");
    
    var sourcemaps = require("gulp-sourcemaps");
    
    var buffer = require("vinyl-buffer");
    
    var paths = {
    
      pages: ["src/*.html"],
    
    };
    
    gulp.task("copy-html", function () {
    
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    
    });
    
    gulp.task(
    
      "default",
    
      gulp.series(gulp.parallel("copy-html"), function () {
    
        return browserify({
    
          basedir: ".",
    
          debug: true,
    
          entries: ["src/main.ts"],
    
          cache: {},
    
          packageCache: {},
    
        })
    
          .plugin(tsify)
    
          .bundle()
    
          .pipe(source("bundle.js"))
    
          .pipe(buffer())
    
          .pipe(sourcemaps.init({ loadMaps: true }))
    
          .pipe(terser())
    
          .pipe(sourcemaps.write("./"))
    
          .pipe(gulp.dest("dist"));
    
      })
    
    );

Notice that `terser` itself has just one call ‚Äî the calls to `buffer` and
`sourcemaps` exist to make sure sourcemaps keep working. These calls give us a
separate sourcemap file instead of using inline sourcemaps like before. Now
you can run Gulp and check that `bundle.js` does get minified into an
unreadable mess:

    
    
    shell
    
    gulp
    
    cat dist/bundle.js

### Babel

First install Babelify and the Babel preset for ES2015. Like Terser, Babelify
mangles code, so we‚Äôll need vinyl-buffer and gulp-sourcemaps. By default
Babelify will only process files with extensions of `.js`, `.es`, `.es6` and
`.jsx` so we need to add the `.ts` extension as an option to Babelify.

    
    
    shell
    
    npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps

Now change your gulpfile to the following:

    
    
    js
    
    var gulp = require("gulp");
    
    var browserify = require("browserify");
    
    var source = require("vinyl-source-stream");
    
    var tsify = require("tsify");
    
    var sourcemaps = require("gulp-sourcemaps");
    
    var buffer = require("vinyl-buffer");
    
    var paths = {
    
      pages: ["src/*.html"],
    
    };
    
    gulp.task("copy-html", function () {
    
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    
    });
    
    gulp.task(
    
      "default",
    
      gulp.series(gulp.parallel("copy-html"), function () {
    
        return browserify({
    
          basedir: ".",
    
          debug: true,
    
          entries: ["src/main.ts"],
    
          cache: {},
    
          packageCache: {},
    
        })
    
          .plugin(tsify)
    
          .transform("babelify", {
    
            presets: ["es2015"],
    
            extensions: [".ts"],
    
          })
    
          .bundle()
    
          .pipe(source("bundle.js"))
    
          .pipe(buffer())
    
          .pipe(sourcemaps.init({ loadMaps: true }))
    
          .pipe(sourcemaps.write("./"))
    
          .pipe(gulp.dest("dist"));
    
      })
    
    );

We also need to have TypeScript target ES2015. Babel will then produce ES5
from the ES2015 code that TypeScript emits. Let‚Äôs modify `tsconfig.json`:

    
    
    {
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts"],
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2015"
    
      }
    
    }

Babel‚Äôs ES5 output should be very similar to TypeScript‚Äôs output for such a
simple script.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Gulp.md) ‚ù§

Contributors to this page:  

BK![Bowden Kelly
\(51\)](https://gravatar.com/avatar/e87ecf3e2da8b667dd3a8005ac610d4a?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(3\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

RC![Ryan Cavanaugh
\(2\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

19+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Integrating with Build Tools

## Babel

### Install

    
    
    sh
    
    npm install @babel/cli @babel/core @babel/preset-typescript --save-dev

### .babelrc

    
    
    js
    
    {
    
      "presets": ["@babel/preset-typescript"]
    
    }

### Using Command Line Interface

    
    
    sh
    
    ./node_modules/.bin/babel --out-file bundle.js src/index.ts

### package.json

    
    
    js
    
    {
    
      "scripts": {
    
        "build": "babel --out-file bundle.js main.ts"
    
      },
    
    }

### Execute Babel from the command line

    
    
    sh
    
    npm run build

## Browserify

### Install

    
    
    sh
    
    npm install tsify

### Using Command Line Interface

    
    
    sh
    
    browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js

### Using API

    
    
    js
    
    var browserify = require("browserify");
    
    var tsify = require("tsify");
    
    browserify()
    
      .add("main.ts")
    
      .plugin("tsify", { noImplicitAny: true })
    
      .bundle()
    
      .pipe(process.stdout);

More details: [smrq/tsify](https://github.com/smrq/tsify)

## Grunt

### Using `grunt-ts` (no longer maintained)

#### Install

    
    
    sh
    
    npm install grunt-ts --save-dev

#### Basic Gruntfile.js

    
    
    js
    
    module.exports = function (grunt) {
    
      grunt.initConfig({
    
        ts: {
    
          default: {
    
            src: ["**/*.ts", "!node_modules/**/*.ts"],
    
          },
    
        },
    
      });
    
      grunt.loadNpmTasks("grunt-ts");
    
      grunt.registerTask("default", ["ts"]);
    
    };

More details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)

### Using `grunt-browserify` combined with `tsify`

#### Install

    
    
    sh
    
    npm install grunt-browserify tsify --save-dev

#### Basic Gruntfile.js

    
    
    js
    
    module.exports = function (grunt) {
    
      grunt.initConfig({
    
        browserify: {
    
          all: {
    
            src: "src/main.ts",
    
            dest: "dist/main.js",
    
            options: {
    
              plugin: ["tsify"],
    
            },
    
          },
    
        },
    
      });
    
      grunt.loadNpmTasks("grunt-browserify");
    
      grunt.registerTask("default", ["browserify"]);
    
    };

More details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-
browserify), [TypeStrong/tsify](https://github.com/TypeStrong/tsify)

## Gulp

### Install

    
    
    sh
    
    npm install gulp-typescript

### Basic gulpfile.js

    
    
    js
    
    var gulp = require("gulp");
    
    var ts = require("gulp-typescript");
    
    gulp.task("default", function () {
    
      var tsResult = gulp.src("src/*.ts").pipe(
    
        ts({
    
          noImplicitAny: true,
    
          out: "output.js",
    
        })
    
      );
    
      return tsResult.js.pipe(gulp.dest("built/local"));
    
    });

More details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-
typescript)

## Jspm

### Install

    
    
    sh
    
    npm install -g jspm@beta

_Note: Currently TypeScript support in jspm is in 0.16beta_

More details:
[TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)

## MSBuild

Update project file to include locally installed
`Microsoft.TypeScript.Default.props` (at the top) and
`Microsoft.TypeScript.targets` (at the bottom) files:

    
    
    xml
    
    <?xml version="1.0" encoding="utf-8"?>
    
    <Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    
      <!-- Include default props at the top -->
    
      <Import
    
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props"
    
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props')" />
    
      <!-- TypeScript configurations go here -->
    
      <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
    
        <TypeScriptRemoveComments>false</TypeScriptRemoveComments>
    
        <TypeScriptSourceMap>true</TypeScriptSourceMap>
    
      </PropertyGroup>
    
      <PropertyGroup Condition="'$(Configuration)' == 'Release'">
    
        <TypeScriptRemoveComments>true</TypeScriptRemoveComments>
    
        <TypeScriptSourceMap>false</TypeScriptSourceMap>
    
      </PropertyGroup>
    
      <!-- Include default targets at the bottom -->
    
      <Import
    
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
    
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" />
    
    </Project>

More details about defining MSBuild compiler options: [Setting Compiler
Options in MSBuild projects](/docs/handbook/compiler-options-in-msbuild.html)

## NuGet

  * Right-Click -> Manage NuGet Packages
  * Search for `Microsoft.TypeScript.MSBuild`
  * Hit `Install`
  * When install is complete, rebuild!

More details can be found at [Package Manager
Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog) and [using
nightly builds with
NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-
with-msbuild)

## Rollup

### Install

    
    
    npm install @rollup/plugin-typescript --save-dev

Note that both `typescript` and `tslib` are peer dependencies of this plugin
that need to be installed separately.

### Usage

Create a `rollup.config.js` [configuration
file](https://www.rollupjs.org/guide/en/#configuration-files) and import the
plugin:

    
    
    js
    
    // rollup.config.js
    
    import typescript from '@rollup/plugin-typescript';
    
    export default {
    
      input: 'src/index.ts',
    
      output: {
    
        dir: 'output',
    
        format: 'cjs'
    
      },
    
      plugins: [typescript()]
    
    };

## Svelte Compiler

### Install

    
    
    npm install --save-dev svelte-preprocess

Note that `typescript` is an optional peer dependencies of this plugin and
needs to be installed separately. `tslib` is not provided either.

You may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-
check) for CLI type checking.

### Usage

Create a `svelte.config.js` configuration file and import the plugin:

    
    
    js
    
    // svelte.config.js
    
    import preprocess from 'svelte-preprocess';
    
    const config = {
    
      // Consult https://github.com/sveltejs/svelte-preprocess
    
      // for more information about preprocessors
    
      preprocess: preprocess()
    
    };
    
    export default config;

You can now specify that script blocks are written in TypeScript:

    
    
    <script lang="ts">

## Vite

Vite supports importing `.ts` files out-of-the-box. It only performs
transpilation and not type checking. It also requires that some
`compilerOptions` have certain values. See the [Vite
docs](https://vitejs.dev/guide/features.html#typescript) for more details.

## Webpack

### Install

    
    
    sh
    
    npm install ts-loader --save-dev

### Basic webpack.config.js when using Webpack 5 or 4

    
    
    js
    
    const path = require('path');
    
    module.exports = {
    
      entry: './src/index.ts',
    
      module: {
    
        rules: [
    
          {
    
            test: /\.tsx?$/,
    
            use: 'ts-loader',
    
            exclude: /node_modules/,
    
          },
    
        ],
    
      },
    
      resolve: {
    
        extensions: ['.tsx', '.ts', '.js'],
    
      },
    
      output: {
    
        filename: 'bundle.js',
    
        path: path.resolve(__dirname, 'dist'),
    
      },
    
    };

See [more details on ts-loader here](https://www.npmjs.com/package/ts-loader).

Alternatives:

  * [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Integrating with
Build Tools.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MDB![Maurice de Beijer
\(6\)](https://gravatar.com/avatar/974aa89116fa46b6895f67236546f417?s=32&&d=blank)

RC![Ryan Cavanaugh
\(3\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DR![Daniel Rosenwasser
\(3\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

### This page has been deprecated

This handbook page has been replaced, [go to the new
page](/docs/handbook/2/objects.html)

[Go to new page](/docs/handbook/2/objects.html)

# Interfaces

One of TypeScript‚Äôs core principles is that type checking focuses on the
_shape_ that values have. This is sometimes called ‚Äúduck typing‚Äù or
‚Äústructural subtyping‚Äù. In TypeScript, interfaces fill the role of naming
these types, and are a powerful way of defining contracts within your code as
well as contracts with code outside of your project.

## Our First Interface

The easiest way to see how interfaces work is to start with a simple example:

    
    
    ts
    
    function printLabel(labeledObj: { label: string }) {
    
      console.log(labeledObj.label);
    
    }
    
    ¬†
    
    let myObj = { size: 10, label: "Size 10 Object" };
    
    printLabel(myObj);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAMgQwEYCmANgBRH7EEAmA8ngFYBciA3ouYUcwM5TpgBzRAF8AlKwBQiRBATc4RAgDoicAWQqLaDFZtEBuCcIkTFURAFsAnnXqIAvK0TcYALwLMAjAAYANO01mACIAZTcCRB9EWwJoIJFDNAxsTRJrWwMgA)

The type checker checks the call to `printLabel`. The `printLabel` function
has a single parameter that requires that the object passed in has a property
called `label` of type `string`. Notice that our object actually has more
properties than this, but the compiler only checks that _at least_ the ones
required are present and match the types required. There are some cases where
TypeScript isn‚Äôt as lenient, which we‚Äôll cover in a bit.

We can write the same example again, this time using an interface to describe
the requirement of having the `label` property that is a string:

    
    
    ts
    
    interface LabeledValue {
    
      label: string;
    
    }
    
    ¬†
    
    function printLabel(labeledObj: LabeledValue) {
    
      console.log(labeledObj.label);
    
    }
    
    ¬†
    
    let myObj = { size: 10, label: "Size 10 Object" };
    
    printLabel(myObj);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDJwEYQDYQCYBqc2ArigN4BQyy2mOAXMgM5hSgDmA3JQL6WUYJEAjDAA9iGQAHduHRZsACjqL8AeQwArJgpz4ipCAEpkVGgknNxuAHTZxHFfVx5NW+y+M9+lXGGQAWwBPd2QAXjMWYAAvCCYARgAGABpaFyYAIgBlWJRk5HcIUUzkXh5ZUDA9ZRD3byA)

The interface `LabeledValue` is a name we can now use to describe the
requirement in the previous example. It still represents having a single
property called `label` that is of type `string`. Notice we didn‚Äôt have to
explicitly say that the object we pass to `printLabel` implements this
interface like we might have to in other languages. Here, it‚Äôs only the shape
that matters. If the object we pass to the function meets the requirements
listed, then it‚Äôs allowed.

It‚Äôs worth pointing out that the type checker does not require that these
properties come in any sort of order, only that the properties the interface
requires are present and have the required type.

## Optional Properties

Not all properties of an interface may be required. Some exist under certain
conditions or may not be there at all. These optional properties are popular
when creating patterns like ‚Äúoption bags‚Äù where you pass an object to a
function that only has a couple of properties filled in.

Here‚Äôs an example of this pattern:

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
    }
    
    ¬†
    
    function createSquare(config: SquareConfig): { color: string; area: number } {
    
      let newSquare = { color: "white", area: 100 };
    
      if (config.color) {
    
        newSquare.color = config.color;
    
      }
    
      if (config.width) {
    
        newSquare.area = config.width * config.width;
    
      }
    
      return newSquare;
    
    }
    
    ¬†
    
    let mySquare = createSquare({ color: "black" });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iCAvlSoxMIBGGBE6uOJAzZcACnrEyHUznxESpAJQcKdRsw7deIAcns4DjklaGRVSiEGCDBZCGE7XGQAXkoPJigOACJhSWBILIAaAKMOAEYABgrwwVpgGGRLRzIAOnoM50jaWhB4xIg2zygUj2tSQYza8KF6xqsnFtEJSU7qbriErHsWwJH51qWpZAAqUYXDySn1WlwwTCgQDf61DWjY+QBPfr2jEy2LdztLzILKKBiIADWWXCzn4QA)

Interfaces with optional properties are written similar to other interfaces,
with each optional property denoted by a `?` at the end of the property name
in the declaration.

The advantage of optional properties is that you can describe these possibly
available properties while still also preventing use of properties that are
not part of the interface. For example, had we mistyped the name of the
`color` property in `createSquare`, we would get an error message letting us
know:

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
    }
    
    ¬†
    
    function createSquare(config: SquareConfig): { color: string; area: number } {
    
      let newSquare = { color: "white", area: 100 };
    
      if (config.clor) {
    
    Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
    
        // Error: Property 'clor' does not exist on type 'SquareConfig'
    
        newSquare.color = config.clor;
    
    Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
    
      }
    
      if (config.width) {
    
        newSquare.area = config.width * config.width;
    
      }
    
      return newSquare;
    
    }
    
    ¬†
    
    let mySquare = createSquare({ color: "black" });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCquKQxAaQaoFsoAC8gtGS0KgARGo6+KQ1ADRJrqjYAAydmSoi+GSgPiF8AHRUVWHZIiIgoACisLGgAArwAA4wxACeoADkEwh7oJpwkIgGcPmQAB74cqDOO5v7xcF+vHuqIoSFb+MxaBlaIfcZVPqZVQDIa+UKjDTaHRTIQzApFZhBUbJYGwsYI3SgABUILh+J0EKsIjYxCY0EIaLelmsuXyRm2bxxrncGO8UTEVVqJnE1AA1jVMmElEA)

## Readonly properties

Some properties should only be modifiable when an object is first created. You
can specify this by putting `readonly` before the name of the property:

    
    
    ts
    
    interface Point {
    
      readonly x: number;
    
      readonly y: number;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLJQRwAm6IANgJ7IAeAXMiAK4C2ARtANwFEnkqtak1aceeAL5A)

You can construct a `Point` by assigning an object literal. After the
assignment, `x` and `y` can‚Äôt be changed.

    
    
    ts
    
    let p1: Point = { x: 10, y: 20 };
    
    p1.x = 5; // error!
    
    Cannot assign to 'x' because it is a read-only property.2540Cannot assign to 'x' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAApzEmgDeeoo0klAJnEQA2AT1AAPVEQCuAWwBGMANwcuPfkNHDJshdGUBfPCFABaM9SkkzJvIMgsADgEZUjZqAC8bcaic4ANKBa6Dig+srOAHRinqAYiqDGMPDQAIRAA)

TypeScript comes with a `ReadonlyArray<T>` type that is the same as `Array<T>`
with all mutating methods removed, so you can make sure you don‚Äôt change your
arrays after creation:

    
    
    ts
    
    let a: number[] = [1, 2, 3, 4];
    
    let ro: ReadonlyArray<number> = a;
    
    ¬†
    
    ro[0] = 12; // error!
    
    Index signature in type 'readonly number[]' only permits reading.2542Index signature in type 'readonly number[]' only permits reading.
    
    ro.push(5); // error!
    
    Property 'push' does not exist on type 'readonly number[]'.2339Property 'push' does not exist on type 'readonly number[]'.
    
    ro.length = 100; // error!
    
    Cannot assign to 'length' because it is a read-only property.2540Cannot assign to 'length' because it is a read-only property.
    
    a = ro; // error!
    
    The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.4104The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsb0GY8BOdbABlCwEZSsAoAG0gBdQBDVAOwFcBbAIxgBtALqgAvKEGUANOll5ZWYQG4GzUPFQAlSKwAmcDvQCeAQVitjAHm78YAPnFtVteINKiJlNMtAhQMPDQAISucAB0AA5ciAAWABQYAJS+-oEIofDhjBwA5kyxTtSkqWDpIbSsTvClAbAZQA)

On the last line of the snippet you can see that even assigning the entire
`ReadonlyArray` back to a normal array is illegal. You can still override it
with a type assertion, though:

    
    
    ts
    
    let a: number[] = [1, 2, 3, 4];
    
    let ro: ReadonlyArray<number> = a;
    
    ¬†
    
    a = ro as number[];
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAhgXBB2BXAtgIxAJwNoF0IF4IsBGAGggCZyBmcgFhwG4AoUSDAezgCUQoATDvGABPAIIYMUEQB4kaTAD4C0FsygrO0AM4IU6bEyA)

### `readonly` vs `const`

The easiest way to remember whether to use `readonly` or `const` is to ask
whether you‚Äôre using it on a variable or a property. Variables use `const`
whereas properties use `readonly`.

## Excess Property Checks

In our first example using interfaces, TypeScript lets us pass `{ size:
number; label: string; }` to something that only expected a `{ label: string;
}`. We also just learned about optional properties, and how they‚Äôre useful
when describing so-called ‚Äúoption bags‚Äù.

However, combining the two naively would allow an error to sneak in. For
example, taking our last example using `createSquare`:

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
    }
    
    ¬†
    
    function createSquare(config: SquareConfig): { color: string; area: number } {
    
      return {
    
        color: config.color || "red",
    
        area: config.width ? config.width * config.width : 20,
    
      };
    
    }
    
    ¬†
    
    let mySquare = createSquare({ colour: "red", width: 100 });
    
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)

Notice the given argument to `createSquare` is spelled _`colour`_ instead of
`color`. In plain JavaScript, this sort of thing fails silently.

You could argue that this program is correctly typed, since the `width`
properties are compatible, there‚Äôs no `color` property present, and the extra
`colour` property is insignificant.

However, TypeScript takes the stance that there‚Äôs probably a bug in this code.
Object literals get special treatment and undergo _excess property checking_
when assigning them to other variables, or passing them as arguments. If an
object literal has any properties that the ‚Äútarget type‚Äù doesn‚Äôt have, you‚Äôll
get an error:

    
    
    ts
    
    let mySquare = createSquare({ colour: "red", width: 100 });
    
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)

Getting around these checks is actually really simple. The easiest method is
to just use a type assertion:

    
    
    ts
    
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)

However, a better approach might be to add a string index signature if you‚Äôre
sure that the object can have some extra properties that are used in some
special way. If `SquareConfig` can have `color` and `width` properties with
the above types, but could _also_ have any number of other properties, then we
could define it like so:

    
    
    ts
    
    interface SquareConfig {
    
      color?: string;
    
      width?: number;
    
      [propName: string]: any;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXyA)

We‚Äôll discuss index signatures in a bit, but here we‚Äôre saying a
`SquareConfig` can have any number of properties, and as long as they aren‚Äôt
`color` or `width`, their types don‚Äôt matter.

One final way to get around these checks, which might be a bit surprising, is
to assign the object to another variable: Since `squareOptions` won‚Äôt undergo
excess property checks, the compiler won‚Äôt give you an error.

    
    
    ts
    
    let squareOptions = { colour: "red", width: 100 };
    
    let mySquare = createSquare(squareOptions);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXypUYmEAjDAidXHEgZsuAAU9MRkHP44+EQkpACUHBR0jMzGPHz8yJFwHHJK0Mj2lEK4YJhQIEW0tPRMUBwhMQB0NczIAD5tyABEuGJdADRCtFn10WSNohKSyCxJoaQT4lLIAFRzTZPLHABMAAyDtPYOVAD0J8gAtFcImGBXF1QMEGBcWJEA8hoeRJzIALyUJJMMocHoQPr9ERLSQcACMu12BUETxe8hsEVw-28EF8EAxEECnDeuE+3xAnFi-CAA)

The above workaround will work as long as you have a common property between
`squareOptions` and `SquareConfig`. In this example, it was the property
`width`. It will however, fail if the variable does not have any common object
property. For example:

    
    
    ts
    
    let squareOptions = { colour: "red" };
    
    let mySquare = createSquare(squareOptions);
    
    Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)

Keep in mind that for simple code like above, you probably shouldn‚Äôt be trying
to ‚Äúget around‚Äù these checks. For more complex object literals that have
methods and hold state, you might need to keep these techniques in mind, but a
majority of excess property errors are actually bugs. That means if you‚Äôre
running into excess property checking problems for something like option bags,
you might need to revise some of your type declarations. In this instance, if
it‚Äôs okay to pass an object with both a `color` or `colour` property to
`createSquare`, you should fix up the definition of `SquareConfig` to reflect
that.

## Function Types

Interfaces are capable of describing the wide range of shapes that JavaScript
objects can take. In addition to describing an object with properties,
interfaces are also capable of describing function types.

To describe a function type with an interface, we give the interface a call
signature. This is like a function declaration with only the parameter list
and return type given. Each parameter in the parameter list requires both name
and type.

    
    
    ts
    
    interface SearchFunc {
    
      (source: string, subString: string): boolean;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfIA)

Once defined, we can use this function type interface like we would other
interfaces. Here, we show how you can create a variable of a function type and
assign it a function value of the same type.

    
    
    ts
    
    let mySearch: SearchFunc;
    
    ¬†
    
    mySearch = function (source: string, subString: string): boolean {
    
      let result = source.search(subString);
    
      return result > -1;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGp6RiQxEUk+GkFhCS5opJlkOUVlUgpkC2QoCHiFS38IpgA6GgwXWgSY6TVKArBGMIKiywA+fQBGNXUVIA)

For function types to correctly type check, the names of the parameters do not
need to match. We could have, for example, written the above example like
this:

    
    
    ts
    
    let mySearch: SearchFunc;
    
    ¬†
    
    mySearch = function (src: string, sub: string): boolean {
    
      let result = src.search(sub);
    
      return result > -1;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGoaLDERST4aQSiJaVl5JTgw8koLZCgIOIVLfwiEADoaDBdaQSk1ShywRjCcvMsAPn0ARjV1FSA)

Function parameters are checked one at a time, with the type in each
corresponding parameter position checked against each other. If you do not
want to specify types at all, TypeScript‚Äôs contextual typing can infer the
argument types since the function value is assigned directly to a variable of
type `SearchFunc`. Here, also, the return type of our function expression is
implied by the values it returns (here `false` and `true`).

    
    
    ts
    
    let mySearch: SearchFunc;
    
    ¬†
    
    mySearch = function (src, sub) {
    
      let result = src.search(sub);
    
      return result > -1;
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGoaLD4aQSlSCmQLZCgIaIVLfwiEADoaDBdaGLVKZLBGMOTUywA+fQBGNXUVIA)

Had the function expression returned numbers or strings, the type checker
would have made an error that indicates return type doesn‚Äôt match the return
type described in the `SearchFunc` interface.

    
    
    ts
    
    let mySearch: SearchFunc;
    
    ¬†
    
    mySearch = function (src, sub) {
    
    Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
      Type 'string' is not assignable to type 'boolean'.2322Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
      Type 'string' is not assignable to type 'boolean'.
    
      let result = src.search(sub);
    
      return "string";
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGVJzpKALAMQFcDLQBvHUUAApEcdk0ipERaIQDmAGlCJ2AI1rS5kjQVkBKVCrhwANgwIBuHAF8cIUAFpHldkUf2cpoqAC2AT3qMLKgBTGyclJY4fiEsoAC8oKThRHhwBEKITIrKKrq8-KCeoNCQysZeCZmUAHSIDKHCqrqWAiVEYukARFIyOp2WVuZAA)

## Indexable Types

Similarly to how we can use interfaces to describe function types, we can also
describe types that we can ‚Äúindex into‚Äù like `a[10]`, or `ageMap["daniel"]`.
Indexable types have an _index signature_ that describes the types we can use
to index into the object, along with the corresponding return types when
indexing.

Let‚Äôs take an example:

    
    
    ts
    
    interface StringArray {
    
      [index: number]: string;
    
    }
    
    ¬†
    
    let myArray: StringArray;
    
    myArray = ["Bob", "Fred"];
    
    ¬†
    
    let myStr: string = myArray[0];
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gQSlOAT2QG8AoZZAbVABMIAPALmRAFcBbAI2gF0WAzhmwBuMgF8yZADYQwyDoTwFCLdJhC58RMYuVFkAXmoAiAEIB7LiYA0yEwDEoEWid5iZchYXWDhmo299QioABncgA)

Above, we have a `StringArray` interface that has an index signature. This
index signature states that when a `StringArray` is indexed with a `number`,
it will return a `string`.

There are four types of supported index signatures: string, number, symbol and
template strings. It is possible to support many types of indexers, but the
type returned from a numeric indexer must be a subtype of the type returned
from the string indexer.

This is because when indexing with a `number`, JavaScript will actually
convert that to a `string` before indexing into an object. That means that
indexing with `100` (a `number`) is the same thing as indexing with `"100"` (a
`string`), so the two need to be consistent.

    
    
    ts
    
    interface Animal {
    
      name: string;
    
    }
    
    ¬†
    
    interface Dog extends Animal {
    
      breed: string;
    
    }
    
    ¬†
    
    // Error: indexing with a numeric string might get you a completely separate type of Animal!
    
    interface NotOkay {
    
      [x: number]: Animal;
    
    'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
    
      [x: string]: Dog;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)

While string index signatures are a powerful way to describe the ‚Äúdictionary‚Äù
pattern, they also enforce that all properties match their return type. This
is because a string index declares that `obj.property` is also available as
`obj["property"]`. In the following example, `name`‚Äôs type does not match the
string index‚Äôs type, and the type checker gives an error:

    
    
    ts
    
    interface NumberDictionary {
    
      [index: string]: number;
    
    ¬†
    
      length: number; // ok, length is a number
    
      name: string; // error, the type of 'name' is not a subtype of the indexer
    
    Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQBLAOwBcYAzAQwGNJQA5AVwFsAjGAEXyuPzkIugBPUAG9coUAG0iAE0gAPVImLQiAcwC6qQszbQA3LnGgANpEJriAC226Y+0CFBwA1gBpT5y1dD5EoClAdVhhjfiZIJRV1BycYeGgPa1piQQAHWjgyUABycMgc339COGIA0EQGFlSM52zk30I5eVCAXyA)

However, properties of different types are acceptable if the index signature
is a union of the property types:

    
    
    ts
    
    interface NumberOrStringDictionary {
    
      [index: string]: number | string;
    
    ¬†
    
      length: number; // ok, length is a number
    
      name: string; // ok, name is a string
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbg5dkAGwgawACzkLom5AHoryOgGsANPsNkTyYOORxk8nNF1GTAgxSVINSxs7J184YI8vHzDyDgBfIA)

Finally, you can make index signatures `readonly` in order to prevent
assignment to their indices:

    
    
    ts
    
    interface ReadonlyStringArray {
    
      readonly [index: number]: string;
    
    }
    
    ¬†
    
    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
    
    myArray[2] = "Mallory"; // error!
    
    Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsaBQBLAOwBcYAzAQwGNJQAlSCgEzkIBsBPAZWOiIHMAgrAodQAb1yhQ0Ri3ZiA2kSaQAHqkIBXALYAjGAF1UiXgIDcuAL65cbSMVA6Ow6KNQNmrTjz6EhImIAvKCKAESCbPg0YQA0oGEAQnB6YYaWzq6iimiGoCFhALIUbGwIHGHmoCCgMPDQAIRAA)

You can‚Äôt set `myArray[2]` because the index signature is `readonly`.

### Indexable Types with Template Strings

A template string can be used to indicate that a particular pattern is
allowed, but not all. For example, a HTTP headers object may have a set list
of known headers and support any [custom defined
properties](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) which
are prefixed with `x-`.

    
    
    ts
    
    interface HeadersResponse {
    
      "content-type": string,
    
      date: string,
    
      "content-length": string
    
    ¬†
    
      // Permit any property starting with 'x-'.
    
      [headerName: `x-${string}`]: string;
    
    }
    
    ¬†
    
    function handleResponse(r: HeadersResponse) {
    
      // Handle known, and x- prefixed
    
      const type = r["content-type"]
    
      const poweredBy = r["x-powered-by"]
    
    ¬†
    
      // Unknown keys without the prefix raise errors
    
      const origin = r.origin
    
    Property 'origin' does not exist on type 'HeadersResponse'.2339Property 'origin' does not exist on type 'HeadersResponse'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQuBLAOwBcYAzAQwGNJQAJSSgExkQCVJEAHOIxOgG9coUACJqfMqQC0JAJ7dIY1IhLRiAcwA0I0M0plV6rbtESpkWQBsrmkgAsVoNRqKb8okKAAKMALYEJKCURPKg3PBK0AouJJQxWqAA7kEOoADkAB4yGQB0egDaDkys0ABylP6QqAAGOQAkgq5aAL61ALrGbpoA3Lit+OQArkTUJAR8oA6hzLacPHwCABTQqIwsbAu8-JAAlKDCXmD0s7agANZEcMlE2iFEzKA5EdCQ5ARZkMx6kvzBCiUoAAvKBoIULKQrCQ5IplB1fktgrxkjBvgAhcKg8FiHIotHMGQAI3kYgRem8AFUiFcbkRLpB5IgUmk4MMASVXu9PmDKAQBKAYPAkIj-qAEARNMQQWC8hKpUQBkA)

## Class Types

### Implementing an interface

One of the most common uses of interfaces in languages like C# and Java, that
of explicitly enforcing that a class meets a particular contract, is also
possible in TypeScript.

    
    
    ts
    
    interface ClockInterface {
    
      currentTime: Date;
    
    }
    
    ¬†
    
    class Clock implements ClockInterface {
    
      currentTime: Date = new Date();
    
      constructor(h: number, m: number) {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIBsD2CDWBJcaeJZAbwChlkEBXKKCcAFWAFsIAuZAETkgG5yAX3LkE6OAGdJaLLmRsADugjtwMjNnyFYiFBSq16jMC3ZdekZAF5kICAHcefCAAoAlIMOYQksFBoEMEwoVwALLhAaVgAjaAAaZFZI6LiodzIRISA)

You can also describe methods in an interface that are implemented in the
class, as we do with `setTime` in the below example:

    
    
    ts
    
    interface ClockInterface {
    
      currentTime: Date;
    
      setTime(d: Date): void;
    
    }
    
    ¬†
    
    class Clock implements ClockInterface {
    
      currentTime: Date = new Date();
    
      setTime(d: Date) {
    
        this.currentTime = d;
    
      }
    
      constructor(h: number, m: number) {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwCh5jpcHRNlABhKukQBrEgNhCRAb26hQiAK6xY2fgBV4AW2ysAIg2wBuFaC7R9RgBQATU+YCUrAG7p4TqwF9ubkQqCkhIMQlpUENMKmwjfgjxSRl+QQphUGVVDS0dO0NjUDMBUABeUGJsAHcS8wc3K1Vbe2xnVwE3bOtVaAALeEgAOjztPSKK0D9rQNymGFh1ZHRYB37WYnUDACNcABpQA03tvdhuxUD-IA)

Interfaces describe the public side of the class, rather than both the public
and private side. This prohibits you from using them to check that a class
also has particular types for the private side of the class instance.

### Difference between the static and instance sides of classes

When working with classes and interfaces, it helps to keep in mind that a
class has _two_ types: the type of the static side and the type of the
instance side. You may notice that if you create an interface with a construct
signature and try to create a class that implements this interface you get an
error:

    
    
    ts
    
    interface ClockConstructor {
    
      new (hour: number, minute: number);
    
    }
    
    ¬†
    
    class Clock implements ClockConstructor {
    
    Class 'Clock' incorrectly implements interface 'ClockConstructor'.
      Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.2420Class 'Clock' incorrectly implements interface 'ClockConstructor'.
      Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.
    
      currentTime: Date;
    
      constructor(h: number, m: number) {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYCMBmUAmAFnwwIFYA2QgKBAkQBdoBLAYwYAV4AHGBgTwCSAO2YNmAQwA2zAF4TxcYagBm0xJFphwwuIIC23GazEBBYf1XrNzYQxhrWkUAGEpcVgGsXSxtACu7AigAN7UoKDCkADuoAAUABZw-tCowv76AEYwADSg+rb+9mkZ2dAAlADc1AC+1NSsUhKIiK7uXqDMhlKQ+pB2rW4e3r5MgQzBYRGsKdD9DAAqXZCoACIKkNXTowFB0IklWbn5h2XloXU1QA)

This is because when a class implements an interface, only the instance side
of the class is checked. Since the constructor sits in the static side, it is
not included in this check.

Instead, you would need to work with the static side of the class directly. In
this example, we define two interfaces, `ClockConstructor` for the constructor
and `ClockInterface` for the instance methods. Then, for convenience, we
define a constructor function `createClock` that creates instances of the type
that is passed to it:

    
    
    ts
    
    interface ClockConstructor {
    
      new (hour: number, minute: number): ClockInterface;
    
    }
    
    ¬†
    
    interface ClockInterface {
    
      tick(): void;
    
    }
    
    ¬†
    
    function createClock(
    
      ctor: ClockConstructor,
    
      hour: number,
    
      minute: number
    
    ): ClockInterface {
    
      return new ctor(hour, minute);
    
    }
    
    ¬†
    
    class DigitalClock implements ClockInterface {
    
      constructor(h: number, m: number) {}
    
      tick() {
    
        console.log("beep beep");
    
      }
    
    }
    
    ¬†
    
    class AnalogClock implements ClockInterface {
    
      constructor(h: number, m: number) {}
    
      tick() {
    
        console.log("tick tock");
    
      }
    
    }
    
    ¬†
    
    let digital = createClock(DigitalClock, 12, 17);
    
    let analog = createClock(AnalogClock, 7, 32);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIBsD2CDWrMgDOYUArgmJlMgN4BQyyIEA7sgBQAWmpUAXE1IBbAEbQANMiGhSkASGFioASgEZsOAJLho8JAG46AXzp1QkWIhTrc2i3pT1GYYLnarkAN0zAAJoZM6GFIQCmACZAQoCDhIGxx2BkjKfjQsXHwiEnIU8STuXnlFCSTpBTlBUWg6D3i7XStaJOiwXhAmVmSqLh4oSTLZCGUA0wR0OEJCZAARYABzYDA4dHjkYCEAB3QIIQhwKbqdSyQmxgQCYjIKbs4iqr6pO6VlWhNnVwSXp0ZIi8xtgB0WDm7AARGIIBtkBCNqDhkkTIExhMpgBBEDLTBzVbrLY7PZgA7pLRHBynX5ZK4pLhPCSPSrPV5JFxuL5JM5-QHAsEsnDISi4OGGRiI0zbMDIXzzRbLZAAXki0ViEHi7FmCyWK2JkgAjAAmXUAdnh4uQcAxwPlipicWJ7HRmOx2uQhskAGY9cMgA)

Because `createClock`‚Äôs first parameter is of type `ClockConstructor`, in
`createClock(AnalogClock, 7, 32)`, it checks that `AnalogClock` has the
correct constructor signature.

Another simple way is to use class expressions:

    
    
    ts
    
    interface ClockConstructor {
    
      new (hour: number, minute: number): ClockInterface;
    
    }
    
    ¬†
    
    interface ClockInterface {
    
      tick(): void;
    
    }
    
    ¬†
    
    const Clock: ClockConstructor = class Clock implements ClockInterface {
    
      constructor(h: number, m: number) {}
    
      tick() {
    
        console.log("beep beep");
    
      }
    
    };
    
    ¬†
    
    let clock = new Clock(12, 17);
    
    clock.tick();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwCgQJj0hALaYaiMgEFi+Vhypdu8YtFwdE2UAGEq6RAGtNTGLACuydLFABvbqFDFsAd1AAKABboTsVsRNCARrgANKBCSiYqPn6BsACUrNq6eiQqsGrYANzcAL7cisqqFOpaOvophcU2duT6LvGgAG7o8AAmWbnciEbQJUkJpQbdpuaWALygiFQUkJC9+qDwIlTYQtjKs4llBWlFGlUTQ2bQFu5RAcGhZzGx1rnVSHp11rZ2B8SQ6MsAdDoA5i4AIkC2EwoGBmABsSydly2Sy3GWPUmSVA4wczk2jwAjAAmEJYgDsUM6Ay+NUeUKAA)

## Extending Interfaces

Like classes, interfaces can extend each other. This allows you to copy the
members of one interface into another, which gives you more flexibility in how
you separate your interfaces into reusable components.

    
    
    ts
    
    interface Shape {
    
      color: string;
    
    }
    
    ¬†
    
    interface Square extends Shape {
    
      sideLength: number;
    
    }
    
    ¬†
    
    let square = {} as Square;
    
    square.color = "blue";
    
    square.sideLength = 10;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyCA9gDYlQBcyAzmFKAOYDc+AvvvqJLIiqgCOAVzhQUEAB6QQAE1ppMOZASK1gsiABkIIJmHQ0QwgLYAjaG074yEMHRFiUAXhXtkcBUNHi2tR+IAdKQUUMiuAERmZMIQEX4BEIHqmjp6BuHIAIwADCxAA)

An interface can extend multiple interfaces, creating a combination of all of
the interfaces.

    
    
    ts
    
    interface Shape {
    
      color: string;
    
    }
    
    ¬†
    
    interface PenStroke {
    
      penWidth: number;
    
    }
    
    ¬†
    
    interface Square extends Shape, PenStroke {
    
      sideLength: number;
    
    }
    
    ¬†
    
    let square = {} as Square;
    
    square.color = "blue";
    
    square.sideLength = 10;
    
    square.penWidth = 5.0;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyCA9gDYlQBcyAzmFKAOYDc+AvvvqJLIigAUIIVAxIBrPIWQ4QAdWAATMOhogArgFsARtDadu4aPCRoAjurhQUEAB6QQi2mkw4ANMiEixk5ASK0ShAAMsJMKmpaulD6XGQQYHQWVigAvH7syHDOqMnWbLR5EAB0pBRQyOkARNpk6hBVBUXFgYohYSqVyACMAAxNltbFsgrK6F0ArMX9QA)

## Hybrid Types

As we mentioned earlier, interfaces can describe the rich types present in
real world JavaScript. Because of JavaScript‚Äôs dynamic and flexible nature,
you may occasionally encounter an object that works as a combination of some
of the types described above.

One such example is an object that acts as both a function and an object, with
additional properties:

    
    
    ts
    
    interface Counter {
    
      (start: number): string;
    
      interval: number;
    
      reset(): void;
    
    }
    
    ¬†
    
    function getCounter(): Counter {
    
      let counter = function (start: number) {} as Counter;
    
      counter.interval = 123;
    
      counter.reset = function () {};
    
      return counter;
    
    }
    
    ¬†
    
    let c = getCounter();
    
    c(10);
    
    c.reset();
    
    c.interval = 5.0;
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsCu5rIN4BQyyAFAM5hxRgBcyImAtgEbQCUdFUoA5gNxFkoSFABucADZ0GLaAOJQIZCGBIdko9MAAmAgL4ECMbAjDB0IZDxUZsItXVs4o+QRJXIEWZ8gC8yYxBTc0tySmppJlYoNnw9ZDgyNG8ReU8U6AA6YWhxCT9kAEYAJgBmNK87LMVlMALA4ItSWLw9NMUwTChLSud9Q3c6hALrMCd7NgEEEkKABkmCBEyalTUp7Oc8goBWTNm+IA)

When interacting with 3rd-party JavaScript, you may need to use patterns like
the above to fully describe the shape of the type.

## Interfaces Extending Classes

When an interface type extends a class type it inherits the members of the
class but not their implementations. It is as if the interface had declared
all of the members of the class without providing an implementation.
Interfaces inherit even the private and protected members of a base class.
This means that when you create an interface that extends a class with private
or protected members, that interface type can only be implemented by that
class or a subclass of it.

This is useful when you have a large inheritance hierarchy, but want to
specify that your code works with only subclasses that have certain
properties. The subclasses don‚Äôt have to be related besides inheriting from
the base class. For example:

    
    
    ts
    
    class Control {
    
      private state: any;
    
    }
    
    ¬†
    
    interface SelectableControl extends Control {
    
      select(): void;
    
    }
    
    ¬†
    
    class Button extends Control implements SelectableControl {
    
      select() {}
    
    }
    
    ¬†
    
    class TextBox extends Control {
    
      select() {}
    
    }
    
    ¬†
    
    class ImageControl implements SelectableControl {
    
    Class 'ImageControl' incorrectly implements interface 'SelectableControl'.
      Types have separate declarations of a private property 'state'.2420Class 'ImageControl' incorrectly implements interface 'SelectableControl'.
      Types have separate declarations of a private property 'state'.
    
      private state: any;
    
      select() {}
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMX0BY1dMcAoAYwBsBDRRUAYTgDsAXeC0AbxNFAAdoASwBuVFpFCIWYyKipMAngG4SAXxIlBrGADMqZCQGVIFSGWkAjU41btQkAB7imAEzo22cDt16ITZlgAKAEpUYThBFxV1cmpaUAAhAFcWFmZ7J0hXd2ZPDkEAWz5TAqyWOmNTcyorSA87H0l-cxCudRjKGjoAFUcWBLgHDOc3BlyGniaqoOC2tQ1O+IBJAqoAczrxr1BC4shS1grmy2st70mBERlJaXE5RRVfY9bOdqA)

In the above example, `SelectableControl` contains all of the members of
`Control`, including the private `state` property. Since `state` is a private
member it is only possible for descendants of `Control` to implement
`SelectableControl`. This is because only descendants of `Control` will have a
`state` private member that originates in the same declaration, which is a
requirement for private members to be compatible.

Within the `Control` class it is possible to access the `state` private member
through an instance of `SelectableControl`. Effectively, a `SelectableControl`
acts like a `Control` that is known to have a `select` method. The `Button`
and `TextBox` classes are subtypes of `SelectableControl` (because they both
inherit from `Control` and have a `select` method). The `ImageControl` class
has its own `state` private member rather than extending `Control`, so it
cannot implement `SelectableControl`.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Interfaces.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(55\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DR![Daniel Rosenwasser
\(25\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

OT![Orta Therox
\(23\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

J![jswheeler
\(3\)](https://gravatar.com/avatar/5ebf4b33539734b347c7a47f52a0177b?s=32&&d=blank)

MH![Mohamed Hegazy
\(3\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

44+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# JS Projects Utilizing TypeScript

The type system in TypeScript has different levels of strictness when working
with a codebase:

  * A type-system based only on inference with JavaScript code
  * Incremental typing in JavaScript [via JSDoc](/docs/handbook/jsdoc-supported-types.html)
  * Using `// @ts-check` in a JavaScript file
  * TypeScript code
  * TypeScript with [`strict`](/tsconfig#strict) enabled

Each step represents a move towards a safer type-system, but not every project
needs that level of verification.

## TypeScript with JavaScript

This is when you use an editor which uses TypeScript to provide tooling like
auto-complete, jump to symbol and refactoring tools like rename. The
[homepage](/) has a list of editors which have TypeScript plugins.

## Providing Type Hints in JS via JSDoc

In a `.js` file, types can often be inferred. When types can‚Äôt be inferred,
they can be specified using JSDoc syntax.

JSDoc annotations come before a declaration will be used to set the type of
that declaration. For example:

    
    
    js
    
    /** @type {number} */
    
    var x;
    
    ¬†
    
    x = 0; // OK
    
    x = false; // OK?!
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4C+4IwAUAG4CG+4AHgNxll3gC84ADA+MMOAHkA0i3bgAZlQA2AZ0Q8+goQH4AhEA)

You can find the full list of supported JSDoc patterns [in JSDoc Supported
Types](/docs/handbook/jsdoc-supported-types.html).

## `@ts-check`

The last line of the previous code sample would raise an error in TypeScript,
but it doesn‚Äôt by default in a JS project. To enable errors in your JavaScript
files add: `// @ts-check` to the first line in your `.js` files to have
TypeScript raise it as an error.

    
    
    js
    
    // @ts-check
    
    /** @type {number} */
    
    var x;
    
    ¬†
    
    x = 0; // OK
    
    x = false; // Not OK
    
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUCCyBOuB7XaALlACYBmc8rAKjokgE8AHZUAbwDsBXAWwBGeAL6g6wDADcAhrlAAPANwYMC0AF5QABiWhsAeQDSazaABmMgDbRke7ADkCkUMaA)

If you have a lot of JavaScript files you want to add errors to then you can
switch to using a [`jsconfig.json`](/docs/handbook/tsconfig-json.html). You
can skip checking some files by adding a `// @ts-nocheck` comment to files.

TypeScript may offer you errors which you disagree with, in those cases you
can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-
expect-error` on the preceding line.

    
    
    js
    
    // @ts-check
    
    /** @type {number} */
    
    var x;
    
    ¬†
    
    x = 0; // OK
    
    // @ts-expect-error
    
    x = false; // Not OK
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNikBPAB2VAG8A7AVwFsAjZAJwF9RtgMA3AQ0dAA8A3Bgz9QAXlAAGQaBCgA8gGksYKHGT8S8SLCaMA9o1ETQAM24AbaMlnyAcgciKlQA)

To learn more about how JavaScript is interpreted by TypeScript read [How TS
Type Checks JS](/docs/handbook/type-checking-javascript-files.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Type Checking JavaScript FilesHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/type-checking-javascript-files.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Intro to JS with
TS.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(6\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# The TypeScript Handbook

## About this Handbook

Over 20 years after its introduction to the programming community, JavaScript
is now one of the most widespread cross-platform languages ever created.
Starting as a small scripting language for adding trivial interactivity to
webpages, JavaScript has grown to be a language of choice for both frontend
and backend applications of every size. While the size, scope, and complexity
of programs written in JavaScript has grown exponentially, the ability of the
JavaScript language to express the relationships between different units of
code has not. Combined with JavaScript‚Äôs rather peculiar runtime semantics,
this mismatch between language and program complexity has made JavaScript
development a difficult task to manage at scale.

The most common kinds of errors that programmers write can be described as
type errors: a certain kind of value was used where a different kind of value
was expected. This could be due to simple typos, a failure to understand the
API surface of a library, incorrect assumptions about runtime behavior, or
other errors. The goal of TypeScript is to be a static typechecker for
JavaScript programs - in other words, a tool that runs before your code runs
(static) and ensures that the types of the program are correct (typechecked).

If you are coming to TypeScript without a JavaScript background, with the
intention of TypeScript being your first language, we recommend you first
start reading the documentation on either the [Microsoft Learn JavaScript
tutorial](https://developer.microsoft.com/javascript/) or read [JavaScript at
the Mozilla Web
Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide). If you have
experience in other languages, you should be able to pick up JavaScript syntax
quite quickly by reading the handbook.

## How is this Handbook Structured

The handbook is split into two sections:

  * **The Handbook**

The TypeScript Handbook is intended to be a comprehensive document that
explains TypeScript to everyday programmers. You can read the handbook by
going from top to bottom in the left-hand navigation.

You should expect each chapter or page to provide you with a strong
understanding of the given concepts. The TypeScript Handbook is not a complete
language specification, but it is intended to be a comprehensive guide to all
of the language‚Äôs features and behaviors.

A reader who completes the walkthrough should be able to:

    * Read and understand commonly-used TypeScript syntax and patterns
    * Explain the effects of important compiler options
    * Correctly predict type system behavior in most cases

In the interests of clarity and brevity, the main content of the Handbook will
not explore every edge case or minutiae of the features being covered. You can
find more details on particular concepts in the reference articles.

  * **Reference Files**

The reference section below the handbook in the navigation is built to provide
a richer understanding of how a particular part of TypeScript works. You can
read it top-to-bottom, but each section aims to provide a deeper explanation
of a single concept - meaning there is no aim for continuity.

### Non-Goals

The Handbook is also intended to be a concise document that can be comfortably
read in a few hours. Certain topics won‚Äôt be covered in order to keep things
short.

Specifically, the Handbook does not fully introduce core JavaScript basics
like functions, classes, and closures. Where appropriate, we‚Äôll include links
to background reading that you can use to read up on those concepts.

The Handbook also isn‚Äôt intended to be a replacement for a language
specification. In some cases, edge cases or formal descriptions of behavior
will be skipped in favor of high-level, easier-to-understand explanations.
Instead, there are separate reference pages that more precisely and formally
describe many aspects of TypeScript‚Äôs behavior. The reference pages are not
intended for readers unfamiliar with TypeScript, so they may use advanced
terminology or reference topics you haven‚Äôt read about yet.

Finally, the Handbook won‚Äôt cover how TypeScript interacts with other tools,
except where necessary. Topics like how to configure TypeScript with webpack,
rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue,
angular, svelte, jquery, yarn, or npm are out of scope - you can find these
resources elsewhere on the web.

## Get Started

Before getting started with [The Basics](/docs/handbook/2/basic-types.html),
we recommend reading one of the following introductory pages. These
introductions are intended to highlight key similarities and differences
between TypeScript and your favored programming language, and clear up common
misconceptions specific to those languages.

  * [TypeScript for the New Programmer](/docs/handbook/typescript-from-scratch.html)
  * [TypeScript for JavaScript Programmers](/docs/handbook/typescript-in-5-minutes.html)
  * [TypeScript for Java/C# Programmers](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [TypeScript for Functional Programmers](/docs/handbook/typescript-in-5-minutes-func.html)

Otherwise, jump to [The Basics](/docs/handbook/2/basic-types.html).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [The BasicsStep one in learning TypeScript: The basic
types.](/docs/handbook/2/basic-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/The Handbook.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(22\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MW![Maira Wenzel
\(1\)](https://gravatar.com/avatar/7613cffac432d1dc5c4e06a5b6a9d24a?s=32&&d=blank)

M![MingYuan
\(1\)](https://gravatar.com/avatar/7d984cad231cd43cc00c830cf5cca739?s=32&&d=blank)

N![navya9singh
\(1\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

Ë∞≠![Ë∞≠‰πùÈºé
\(1\)](https://gravatar.com/avatar/78c4a8a4e90d69337863232163bc902f?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Iterators and Generators

## Iterables

An object is deemed iterable if it has an implementation for the
[`Symbol.iterator`](symbols.html#symboliterator) property. Some built-in types
like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have
their `Symbol.iterator` property already implemented. `Symbol.iterator`
function on an object is responsible for returning the list of values to
iterate on.

### `Iterable` interface

`Iterable` is a type we can use if we want to take in types listed above which
are iterable. Here is an example:

    
    
    ts
    
    function toArray<X>(xs: Iterable<X>): X[] {
    
      return [...xs]
    
    }

### `for..of` statements

`for..of` loops over an iterable object, invoking the `Symbol.iterator`
property on the object. Here is a simple `for..of` loop on an array:

    
    
    ts
    
    let someArray = [1, "string", false];
    
    for (let entry of someArray) {
    
      console.log(entry); // 1, "string", false
    
    }

### `for..of` vs. `for..in` statements

Both `for..of` and `for..in` statements iterate over lists; the values
iterated on are different though, `for..in` returns a list of _keys_ on the
object being iterated, whereas `for..of` returns a list of _values_ of the
numeric properties of the object being iterated.

Here is an example that demonstrates this distinction:

    
    
    ts
    
    let list = [4, 5, 6];
    
    for (let i in list) {
    
      console.log(i); // "0", "1", "2",
    
    }
    
    for (let i of list) {
    
      console.log(i); // 4, 5, 6
    
    }

Another distinction is that `for..in` operates on any object; it serves as a
way to inspect properties on this object. `for..of` on the other hand, is
mainly interested in values of iterable objects. Built-in objects like `Map`
and `Set` implement `Symbol.iterator` property allowing access to stored
values.

    
    
    ts
    
    let pets = new Set(["Cat", "Dog", "Hamster"]);
    
    pets["species"] = "mammals";
    
    for (let pet in pets) {
    
      console.log(pet); // "species"
    
    }
    
    for (let pet of pets) {
    
      console.log(pet); // "Cat", "Dog", "Hamster"
    
    }

### Code generation

#### Targeting ES5

When targeting an ES5-compliant engine, iterators are only allowed on values
of `Array` type. It is an error to use `for..of` loops on non-Array values,
even if these non-Array values implement the `Symbol.iterator` property.

The compiler will generate a simple `for` loop for a `for..of` loop, for
instance:

    
    
    ts
    
    let numbers = [1, 2, 3];
    
    for (let num of numbers) {
    
      console.log(num);
    
    }

will be generated as:

    
    
    js
    
    var numbers = [1, 2, 3];
    
    for (var _i = 0; _i < numbers.length; _i++) {
    
      var num = numbers[_i];
    
      console.log(num);
    
    }

#### Targeting ECMAScript 2015 and higher

When targeting an ECMAScript 2015-compliant engine, the compiler will generate
`for..of` loops to target the built-in iterator implementation in the engine.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Iterators and
Generators.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(57\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

GB![Gabriel Burdeti
\(3\)](https://gravatar.com/avatar/28ff7ada33ca80bfae575ae1321176ca?s=32&&d=blank)

JB![Jake Bailey
\(1\)](https://gravatar.com/avatar/e1aaca71f55a5b193ecedfa5ea857ea2?s=32&&d=blank)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

12+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# JSDoc Reference

The list below outlines which constructs are currently supported when using
JSDoc annotations to provide type information in JavaScript files.

Note:

  * Any tags which are not explicitly listed below (such as `@async`) are not yet supported.
  * Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files.

#### Types

  * `@type`
  * `@param` (or `@arg` or `@argument`)
  * `@returns` (or `@return`)
  * `@typedef`
  * `@callback`
  * `@template`
  * `@satisfies`

#### Classes

  * Property Modifiers `@public`, `@private`, `@protected`, `@readonly`
  * `@override`
  * `@extends` (or `@augments`)
  * `@implements`
  * `@class` (or `@constructor`)
  * `@this`

#### Documentation

Documentation tags work in both TypeScript and JavaScript.

  * `@deprecated`
  * `@see`
  * `@link`

#### Other

  * `@enum`
  * `@author`
  * Other supported patterns
  * Unsupported patterns
  * Unsupported tags

The meaning is usually the same, or a superset, of the meaning of the tag
given at [jsdoc.app](https://jsdoc.app). The code below describes the
differences and gives some example usage of each tag.

**Note:** You can use [the playground to explore JSDoc
support](/play?useJavaScript=truee=4#example/jsdoc-support).

## Types

### `@type`

You can reference types with the ‚Äú@type‚Äù tag. The type can be:

  1. Primitive, like `string` or `number`.
  2. Declared in a TypeScript declaration, either global or imported.
  3. Declared in a JSDoc `@typedef` tag.

You can use most JSDoc type syntax and any TypeScript syntax, from [the most
basic like `string`](/docs/handbook/2/basic-types.html) to [the most advanced,
like conditional types](/docs/handbook/2/conditional-types.html).

    
    
    js
    
    /**
    
     * @type {string}
    
     */
    
    var s;
    
    ¬†
    
    /** @type {Window} */
    
    var win;
    
    ¬†
    
    /** @type {PromiseLike<string>} */
    
    var promisedString;
    
    ¬†
    
    // You can specify an HTML Element with DOM properties
    
    /** @type {HTMLElement} */
    
    var myElement = document.querySelector(selector);
    
    element.dataset.myData = "";
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOYC+UIw4AbgIa6RYDc44oMCK6GA6kQCYB7AO6loVOg2FEWbMHCRpMABVyCAtviyoAMvgDWqADw4CJAHxjKNepGRrN2-gGU8RYrODBIATUEBXSABjWkJGNCD8ADNESFDIAAkAFQBZHUgAUQAbVHVUQnhIaXgAC0gAEQB5FLs1NFx4fFQsOQ5FbmS07Nz8+CsJW3VEbryCyABeSCEg-1H4ADoAR39UXERnVByg+EFcAAptLZ3cAEoWTZ6C+f5aeFptBaHy29oJyAAid6YgA)

`@type` can specify a union type ‚Äî for example, something can be either a
string or a boolean.

    
    
    js
    
    /**
    
     * @type {string | boolean}
    
     */
    
    var sb;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOaQA+kARgPbUA2qAhoQL5QjDgBujukWlANxA)

You can specify array types using a variety of syntaxes:

    
    
    js
    
    /** @type {number[]} */
    
    var ns;
    
    /** @type {Array.<number>} */
    
    var jsdoc;
    
    /** @type {Array<number>} */
    
    var nas;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4DaAugL7gjABQAbgIb7hoDOA3FaBDAsigIL58dWADoAPJlwEAfOUq0G4AFbMAJgHsAxu05Q4SVAKGwJ2PPlkVq9RmjpsgA)

You can also specify object literal types. For example, an object with
properties ‚Äòa‚Äô (string) and ‚Äòb‚Äô (number) uses the following syntax:

    
    
    js
    
    /** @type {{ a: string, b: number }} */
    
    var var9;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeLwEMBc4DO0AnASwDsBzAGnACMcSBXAW2sQPAF93wRgAoANwxtBBAJwBuIA)

You can specify map-like and array-like objects using string and number index
signatures, using either standard JSDoc syntax or TypeScript syntax.

    
    
    js
    
    /**
    
     * A map-like object that maps arbitrary `string` properties to `number`s.
    
     *
    
     * @type {Object.<string, number>}
    
     */
    
    var stringToNumber;
    
    ¬†
    
    /** @type {Object.<number, object>} */
    
    var arrayLike;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUhBSC2BDADgWgDYEsDWBTSAewCMArPAYwBdIqALJG5FAZ0iQCdisqPOBPSAAMWvLADsA5kMgoOhFHg5UseNlULDxAVwTElIgHRQI0SAAEq-RZADeAeTKUqhgDyiOEyQBpIOvUoAfAC+JsDgAG6ckB5eACqEAHK6+hwA3ODgoDCW1gQOTtRu-qm+JOTUIdDhURzsHHz8ADK4eGlAA)

The preceding two types are equivalent to the TypeScript types `{ [x: string]:
number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.

You can specify function types using either TypeScript or Google Closure
syntax:

    
    
    js
    
    /** @type {function(string, boolean): number} Closure syntax */
    
    var sbn;
    
    /** @type {(s: string, b: boolean) => number} TypeScript syntax */
    
    var sbn2;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAzArgOwMbQJYD2WAFAM7QBO+WA5gDTgBGhhANogIZYCUAXOCwYAtk0SUAvuADCbQmQyVkZWFmicAHuBDAAUADdOlcGSZYA3LtAQYCZCnICK1OoyYCW7Lr3ABeAHyCImKS4AAqdgDKONTw0Caq6lo6BkYmZgBM5kA)

Or you can just use the unspecified `Function` type:

    
    
    js
    
    /** @type {Function} */
    
    var fn7;
    
    /** @type {function} */
    
    var fn6;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAxArgOwMbQJYD2WAvuCMAFABuAhgE7gBmWA7ANyWgQwLIpNseIqXJU6jFgDZ2QA)

Other types from Closure also work:

    
    
    js
    
    /**
    
     * @type {*} - can be 'any' type
    
     */
    
    var star;
    
    /**
    
     * @type {?} - unknown type (same as 'any')
    
     */
    
    var question;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4gL6QLSQDGAhgHaQBG6A5GYtZEmlCMOAG7EBOkAzvNwDc4UBGhwm6DAH5cBAK6kA1qQD2Ad3KTIACl7EAtumK9ItUvQCULNpx4BHean4BLVaUFA)

#### Casts

TypeScript borrows cast syntax from Google Closure. This lets you cast types
to other types by adding a `@type` tag before any parenthesized expression.

    
    
    js
    
    /**
    
     * @type {number | string}
    
     */
    
    var numberOrString = Math.random() < 0.5 ? "hello" : 100;
    
    var typeAssertedNumber = /** @type {number} */ (numberOrString);
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSAZ3mIEssBzAXyhGHADcBDU3QkgPLEAyjXoNIAXkgBZLvAAWAOmJcsAEwD2eABQBKSAB5IABiUBWSAH5IAIgWoANo823IALkgBGEyYDcnDyQSGgAgpSUJPCo6gBy+ESk0qAwCCjo2AkkTNDAkDp8iUKidIx6fkA)

You can even cast to `const` just like TypeScript:

    
    
    js
    
    let one = /** @type {const} */(1);
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gdiEF4IHoBUqIAEwE8AO8A3gMawDOYAvhKsgBQCMAlANxA)

#### Import types

You can import declarations from other files using import types. This syntax
is TypeScript-specific and differs from the JSDoc standard:

    
    
    js
    
    // @filename: types.d.ts
    
    export type Pet = {
    
      name: string,
    
    };
    
    ¬†
    
    // @filename: main.js
    
    /**
    
     * @param {import("./types").Pet} p
    
     */
    
    function walk(p) {
    
      console.log(`Walking ${p.name}...`);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NWogIMBOMyhUyWSQBWNYACoLIixHzJmaIdFRNWACgBEJYHkJFPAEoSHmxlUHwbYGpIAFdEAGNsaEZEUAB3ZFgAa3d8QKERUATUokYEElhGOXcAAwB1LOzZOVAAEkF8Ej1lEj7awPVlIA)

import types can be used in type alias declarations:

    
    
    js
    
    /**
    
     * @typedef {import("./types").Pet} Pet
    
     */
    
    ¬†
    
    /**
    
     * @type {Pet}
    
     */
    
    var myPet;
    
    myPet.name;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NRAQYCcZlCpkskgCsamgLSWAxgFdsl8xoBUTkU4h5CZeJCHRUTKwAFABEJMCexCEAlCQ82MrcvG7A1M6uoO7gkULxyinUAG7IzPq48eqo5bwkuqpAA)

import types can be used to get the type of a value from a module if you don‚Äôt
know the type, or if it has a large type that is annoying to type:

    
    
    js
    
    /**
    
     * @type {typeof import("./accounts").userAccount}
    
     */
    
    var x = require("./accounts").userAccount;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZBjHB7AV0QBcBnAOgBMLyAoeADwAd8AnE0AxMzws+GwCCeIqVABeUAG86oUCnRYARADk08ZQBo52KlTbwyZFUMR6DRstt2teyWAGF8VTKGU35BYiTYBPFU9QZlhkRHgSQJ15Mj9eeFQo3QBzB2RGAPcg4mgAN0EBJIBfAG46EAgYBEU3VGRoRAoAKzJysABaTpxCEk728oAqAbkBiBI-ZngZccn8SFBoVFYOAAplCmBcb1JrAEoKfkERbZIikeA6XOQ2UEZJUEMAR0JoQzWNrbFyZX3D4VEfCUgA)

### `@param` and `@returns`

`@param` uses the same type syntax as `@type`, but adds a parameter name. The
parameter may also be declared optional by surrounding the name with square
brackets:

    
    
    js
    
    // Parameters may be declared in a variety of syntactic forms
    
    /**
    
     * @param {string}  p1 - A string param.
    
     * @param {string=} p2 - An optional param (Google Closure syntax)
    
     * @param {string} [p3] - Another optional param (JSDoc syntax).
    
     * @param {string} [p4="test"] - An optional param with a default value
    
     * @returns {string} This is the result
    
     */
    
    function stringsStringStrings(p1, p2, p3, p4) {
    
      // TODO
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHQM6jpAnqARgqACYIDGANjAkaAJYB2okoAbjLcrgPYBmoa2ekkikktUqB5docNAChgAKkVzQi0AAEADjHigA3miTQGAcwC+oUFoCMoALSgAgv2NnruuADpV67Z4MjE3pTAF5LLQAmB2dGLi0xLnpIcg9YOFAACgBxLi5TckIAYXIuNABXaEIBIUgADwBKX00ddMC3EMsAbS0AZgBdGKd6LiQAC1RQeMTk1Na9TIApAGUAES4JGuFGnzUWgMMOi1AegBZQgCIUIwvBx2GphNoklLS9AHdacaZiBB5IcrkJCsFLlBDNDRVJCVegYQ7BY4AFTGtAwqNA40IVQqQN8wDkPHK9FEz0YQTMaGWRypCLQmVsABprJEmX1WacGgZVKAQKBEQB5Vb8uTmIA)

Likewise, for the return type of a function:

    
    
    js
    
    /**
    
     * @return {PromiseLike<string>}
    
     */
    
    function ps() {}
    
    ¬†
    
    /**
    
     * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'
    
     */
    
    function ab() {}
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAnApgFwK7wHaQN4AV4D2AtgJYDOiAMiQNaIA8Zy8JGA5gHwC+UIw4AM1QYAxshIEsABzIAKAJQ4e4UBGhwkaTGRzZIAQwBckJi3YAaSACNjGVESuJ4kLl0gBaSAFl9AT0ioFJAA5Ago6BhkwQY6AO6IADYJMSFhWhjBvPxCouKSBlYKSkA)

### `@typedef`, `@callback`, and `@param`

You can define complex types with `@typedef`. Similar syntax works with
`@param`.

    
    
    js
    
    /**
    
     * @typedef {Object} SpecialType - creates a new type named 'SpecialType'
    
     * @property {string} prop1 - a string property of SpecialType
    
     * @property {number} prop2 - a number property of SpecialType
    
     * @property {number=} prop3 - an optional number property of SpecialType
    
     * @prop {number} [prop4] - an optional number property of SpecialType
    
     * @prop {number} [prop5=42] - an optional number property of SpecialType with default
    
     */
    
    ¬†
    
    /** @type {SpecialType} */
    
    var specialTypeObject;
    
    specialTypeObject.prop3;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8DyARgFaoDG8AvpAMppkCWAhgDYAqKqkAtJGQE6om8VAGdITSADtUAd0hI00pgFsMkAOR1yzdpw1QYsZPwD2afkjyj4-BlIDm1E+YCMPCZBt3HkFxatTHG1GVg40Qzh-VEtEPCkAVxVCGOczZAAmD0lE5Ji-dJjA4PpdcNRI40LY+KSU-gBeNPMAZmypSHN4BlMpVmk6-OiaoNpSsM5K-1q8-moAbX8AFgBdds7kbt7+3PqC8yK40ZCyyego9Jn6hf8AVgaljLXeJg6unr6WAdn9gKOSnQTJSyBjwAAWkEwWCYCRY8EMwHA4FARkUXFwJyBqGoIERADcmPwvOM9GgiKQKABucCiEnlcnkeAAOn8LUpQA)

You can use either `object` or `Object` on the first line.

    
    
    js
    
    /**
    
     * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'
    
     * @property {string} prop1 - a string property of SpecialType1
    
     * @property {number} prop2 - a number property of SpecialType1
    
     * @property {number=} prop3 - an optional number property of SpecialType1
    
     */
    
    ¬†
    
    /** @type {SpecialType1} */
    
    var specialTypeObject1;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8D2ARgFaoDG8AvpAMppkCWAhgDYAqKqAjJALSRkATqibxUAZ0hNIAO1QB3SEjSymAWwyQA5HXLN2nLlqgxYyQfjSCkecfEEMZAc2rnLPftLsPnkN1Zt8HF1GVg40LhM4f1RrRDwZAFc1QljXC2QAJj4pWWTUwT8M2MDg+n1w7iizYriE-NiAXnTLAGYcphlIS3gGfBlWPJTYossS+KDacrDDE2BwcFBTZVQ8EIrDahB5gDcmQvFpgzQAeRJyeC4AbiA)

`@param` allows a similar syntax for one-off type specifications. Note that
the nested property names must be prefixed with the name of the parameter:

    
    
    js
    
    /**
    
     * @param {Object} options - The shape is the same as SpecialType above
    
     * @param {string} options.prop1
    
     * @param {number} options.prop2
    
     * @param {number=} options.prop3
    
     * @param {number} [options.prop4]
    
     * @param {number} [options.prop5=42]
    
     */
    
    function special(options) {
    
      return (options.prop4 || 1001) + options.prop5;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwPICMBWApgMYAuAvpAPbykCWVAdgM6QC0kAKgBaGTPdE8PnVale-dH0SsAysOJ1EAG04BPYZES4qAN0JQYCFOizNSyOowDmlGvSbMAdPGQ0AjIbhJUGTIwBXNFxCZDtaBhYXN3gAJi9jXyxA4NCAXnCHKNcaAGYEn1N-IJCwyABte0jnHPgAFgBdApM-FNLKSojHaJoAVjS62KboYHAAMwDGMkj+BSVlAAoqxwBKLChIZEJSAORGSCWu7Ji6yAAfM8h3AAZr9zWAamojmpjegG5wciA)

`@callback` is similar to `@typedef`, but it specifies a function type instead
of an object type:

    
    
    js
    
    /**
    
     * @callback Predicate
    
     * @param {string} data
    
     * @param {number} [index]
    
     * @returns {boolean}
    
     */
    
    ¬†
    
    /** @type {Predicate} */
    
    const ok = (s) => !(s.length % 2);
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBBjAhgG2QI0fA1pACgJwFMATASyQBdCoZYAHRfRAW0gG8BnC-UgOwHMAvpGKIKiGnAZNWbXgFdmaQvmEBtPsUIAPALqTYRCvPy8O7NAHtLyQol6CawcOFC0KATzqF2BEuTFCYRBneEszCkhLHABeSAAKDgBKSBiAPkgAQkSAOlsBCgALSABSSAAmJIBuIA)

Of course, any of these types can be declared using TypeScript syntax in a
single-line `@typedef`:

    
    
    js
    
    /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */
    
    /** @typedef {(data: string, index?: number) => boolean} Predicate */

### `@template`

You can declare type parameters with the `@template` tag. This lets you make
functions, classes, or types that are generic:

    
    
    js
    
    /**
    
     * @template T
    
     * @param {T} x - A generic parameter that flows through to the return type
    
     * @returns {T}
    
     */
    
    function id(x) {
    
      return x;
    
    }
    
    ¬†
    
    const a = id("string");
    
    const b = id(123);
    
    const c = id({});
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyqYBOmykA3rgL6QAekAtJAIKQDmiAdoiQJYBjSMTLJESEpHgALbJABm6APYB3AM7SZJZQFcOM6cq2JIJCbpLdpAT1SICcc-EvdN1GgWDgFu7oPh+ZWt+ABMACnoASiooMwsrBgBucE9wQWD1eEhMSABeSDDwgCIsgW4OYqiUjLdsgCN8woiARgAmAGZq9Mzs4QKiyhpqoA)

Use comma or multiple tags to declare multiple type parameters:

    
    
    js
    
    /**
    
     * @template T,U,V
    
     * @template W,X
    
     */

You can also specify a type constraint before the type parameter name. Only
the first type parameter in a list is constrained:

    
    
    js
    
    /**
    
     * @template {string} K - K must be a string or string literal
    
     * @template {{ serious(): string }} Seriousalizable - must have a serious method
    
     * @param {K} key
    
     * @param {Seriousalizable} object
    
     */
    
    function seriousalize(key, object) {
    
      // ????
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIG8DO8ATgJYB2A5gL6QDSkAtHZMgK6GQBGikmkhpSpAD2RfsXIVI6EkiKZ0UGAhQZsPXLn6JSw9gAoAlAC5xgqVRoBlHST34FJAF6ZO6HkzYcAFpgBuPHz4tvYsiPDewgAmSnComPLIeLQ0ANaIAJ6xsPGJeDa67I4ubog0wpwAVogAxvBKwOAAZqxkdXZk2oUOMk6I+ukZADQiVbXwhnhQkMDAkAD8i-PgVEA)

Finally, you can specify a default for a type parameter:

    
    
    js
    
    /** @template [T=object] */
    
    class Cache {
    
        /** @param {T} initial */
    
        constructor(initial) {
    
        }
    
    }
    
    let c = new Cache()
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcFMFsAOAbAhncBtAKgXgPYBGAVrAMbQC64IwAUGWgM5PgDCqZAFrOAN51wQ8KAiREqAE6p4-bAF9wASwB2S6EtTIa9YeDL4VTaJICuFfJIAUq9ZuQBKfoOHy6b5LGj7wucCtgAd3ZOHisHIA)

### `@satisfies`

`@satisfies` provides access to the postfix [operator
`satisfies`](/docs/handbook/release-notes/typescript-4-9.html) in TypeScript.
Satisfies is used to declare that a value implements a type but does not
affect the type of the value.

    
    
    js
    
    // @ts-check
    
    /**
    
     * @typedef {"hello world" | "Hello, world"} WelcomeMessage
    
     */
    
    ¬†
    
    /** @satisfies {WelcomeMessage} */
    
    const message = "hello world"
    
            
    
    const message: "hello world"
    
    ¬†
    
    /** @satisfies {WelcomeMessage} */
    
    Type '"Hello world!"' does not satisfy the expected type 'WelcomeMessage'.1360Type '"Hello world!"' does not satisfy the expected type 'WelcomeMessage'.
    
    const failingMessage = "Hello world!"
    
    ¬†
    
    /** @type {WelcomeMessage} */
    
    const messageUsingType = "hello world"
    
                 
    
    const messageUsingType: WelcomeMessage
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYBsAGAUCBAC6IC0AxgBaTkDWBAVA3qA8QJ4AOkAJpAGagA3gCJqAG3FxQAdwTieI0AB9QIgBKRJcADSz5igL6gA6lvJwAtpACykRIgCGAc0gsGwPIzbgnRAJaI-P72wmbiFtZ2Di6Qxh54FgB2iESg1jGuoAC8ahJS+tAKIgRgoOWgAHoA-F7ATBB+gcGhQuGRtvZOrvGeyamg-I7+4v5JztHdkDlqmtqFCgCEJd4c3GHmVp2Zcax9cClpGVMAqohjzgAqXNO5YloFckWKpRXlNUA)

## Classes

Classes can be declared as ES6 classes.

    
    
    js
    
    class C {
    
      /**
    
       * @param {number} data
    
       */
    
      constructor(data) {
    
        // property types can be inferred
    
        this.name = "foo";
    
    ¬†
    
        // or set explicitly
    
        /** @type {string | null} */
    
        this.title = null;
    
    ¬†
    
        // or simply annotated, if they're set elsewhere
    
        /** @type {number} */
    
        this.size;
    
    ¬†
    
        this.initialize(data); // Should error, initializer expects a string
    
      }
    
      /**
    
       * @param {string} s
    
       */
    
      initialize = function (s) {
    
        this.size = s.length;
    
      };
    
    }
    
    ¬†
    
    var c = new C(0);
    
    ¬†
    
    // C should only be called with new, but
    
    // because it is JavaScript, this is allowed and
    
    // considered an 'any'.
    
    var result = C(1);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8BQ1oHoBUGWo9AAgA5gBOYAtogHYCu5ARgKYkC+0AJmAC5g7QZocwAPZUIXEjWBdhJABSceASkR90aaIRLDCzLgE9oB3TGBgq0JtACWVAGbMSjdmq4ALaxAB0VCo2gAvNAARHbCwsEA3EhqaBqy0BCMXNCMAB6EINbA1lwg+rFYBMb+COIktgDm0AA+0LQgIGwCrh7eXLkg-kENINGx8SSJ1uSZhuZUwjxczgA0NnZGboz6AOROicmpIEkA7stOhXj4JdR0TKz8gqio7p5eENYAXoz9N0v3trnWYFkvCtwwEpIupoABlNzCGggdipEjaEjzL4dX7PZipDKMaQwMCJCRVHAsHCYbA3Y7EMiUMr4qiVNgQPgtVDIn5-brQOw0KjSayiaByCAqZDvO7eR4vQKJLxdWnuaKoFjRIlIABupGgwElVEYuzgcgADMCYnE4IlIdDYaJ8pZ-GZGs5oLtcm56jr5vQaFwkCamGYaEkbClPNAAFJgNVg4AVQhceaimw4xrCXYO8wuE0iMTWdjMVMWVbmNZeVXqpwQaEpIKwOQARmBQA)

They can also be declared as constructor functions; use `@constructor` along
with `@this` for this.

### Property Modifiers

`@public`, `@private`, and `@protected` work exactly like `public`, `private`,
and `protected` in TypeScript:

    
    
    js
    
    // @ts-check
    
    ¬†
    
    class Car {
    
      constructor() {
    
        /** @private */
    
        this.identifier = 100;
    
      }
    
    ¬†
    
      printIdentifier() {
    
        console.log(this.identifier);
    
      }
    
    }
    
    ¬†
    
    const c = new Car();
    
    console.log(c.identifier);
    
    Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0QADtACWANxZFIoDcFVCilfYgB0+gCaRRRfQDN9MUAF5QOAAMgQDcqgC+DEJ6+m4Aki5unt7QSipqwmKIcEyQ9kxwAObyNnaOie5eMIphQpGRjFlEwn6gopAA7lw8SmEi4jl5BcXk5a6VKTVAA)

  * `@public` is always implied and can be left off, but means that a property can be reached from anywhere.
  * `@private` means that a property can only be used within the containing class.
  * `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.

`@public`, `@private`, and `@protected` do not work in constructor functions.

### `@readonly`

The `@readonly` modifier ensures that a property is only ever written to
during initialization.

    
    
    js
    
    // @ts-check
    
    ¬†
    
    class Car {
    
      constructor() {
    
        /** @readonly */
    
        this.identifier = 100;
    
      }
    
    ¬†
    
      printIdentifier() {
    
        console.log(this.identifier);
    
      }
    
    }
    
    ¬†
    
    const c = new Car();
    
    console.log(c.identifier);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0RokFgBMxTAJ6gNwVUKKUAlogB0N-ZFFEbAMxsxQAXlABGHBwAblUAXwYhAAdoG1cASWdXDy9oJRU1YTFEOCZIeyY4AHN5aztHJLdPGEVQoQiIxmyiYV9QUUgAdy4eJVCRcVz8wpLyCpcq1NqgA)

### `@override`

`@override` works the same way as in TypeScript; use it on methods that
override a method from a base class:

    
    
    js
    
    export class C {
    
      m() { }
    
    }
    
    class D extends C {
    
      /** @override */
    
      m() { }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAYwDYEMDOa4GE4G8BQccAtgBQCUecAvvrcupgCJygzAB2AJpjgUQHoAVELgABCADdgUKAEsuwOEIGESFKrWpA)

Set `noImplicitOverride: true` in tsconfig to check overrides.

### `@extends`

When JavaScript classes extend a generic base class, there is no JavaScript
syntax for passing a type argument. The `@extends` tag allows this:

    
    
    js
    
    /**
    
     * @template T
    
     * @extends {Set<T>}
    
     */
    
    class SortableSet extends Set {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyIAeSAdgCYDOkA3gMqLwA8uAfAL4HDgDGWVGvQD2AJ3iYARukSN4kEuWqQ5dKJGDBIAOl3gOQA)

Note that `@extends` only works with classes. Currently, there is no way for a
constructor function to extend a class.

### `@implements`

In the same way, there is no JavaScript syntax for implementing a TypeScript
interface. The `@implements` tag works just like in TypeScript:

    
    
    js
    
    /** @implements {Print} */
    
    class TextBook {
    
      print() {
    
        // TODO
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEEsFsAcA2BTWyB2AXAzuA3gAoBO0WAvuCMAFADGiAhtrgCrIAemAQgPY8DW+auHDwSWABQBKISJHBg4FgHkAIsuHgy1MkA)

### `@constructor`

The compiler infers constructor functions based on this-property assignments,
but you can make checking stricter and suggestions better if you add a
`@constructor` tag:

    
    
    js
    
    /**
    
     * @constructor
    
     * @param {number} data
    
     */
    
    function C(data) {
    
      // property types can be inferred
    
      this.name = "foo";
    
    ¬†
    
      // or set explicitly
    
      /** @type {string | null} */
    
      this.title = null;
    
    ¬†
    
      // or simply annotated, if they're set elsewhere
    
      /** @type {number} */
    
      this.size;
    
    ¬†
    
      this.initialize(data);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    
    }
    
    /**
    
     * @param {string} s
    
     */
    
    C.prototype.initialize = function (s) {
    
      this.size = s.length;
    
    };
    
    ¬†
    
    var c = new C(0);
    
    c.size;
    
    ¬†
    
    var result = C(1);
    
    Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGYAWAVjKoA4MAqJtUJiSPAOxQBdsAV0h8CbDuAAOAQ2zSAtqADe3QfIBGOAL6gAJtL7TxwNADNB3EQEseoAMIAKfYYCUytqEyT8knHwCeoAG+KKCQ0tygmqBW3KY42LC6HnzQVigAdNwKsKAAvKAARKZ4eIUA3GgemASgKLB8oLAAHpIANlaQVnxt-tUsEMG5SvzYsQDmoAA+oKptbTpMJqBBaZl83W25BXNtldVgtShW8u2BEdx4hnxJADQxpquw-gDkiXUNTW31AO5wif0JENlKoNNp2MtVukMscAF6wfYrVLQ2LdKzSDrwpwGaQuSpaZisdgQGRyRQjAQTHToCFoOwZbxXK7+XwZVEbDFWeH5UDmSwbWwOFBuJQpNYwrnbOoZLbccapfH7ABusjCPO4sB+9gcAAY8WhIBL4crVYkUII2o0Co4AIx4oA)

> Note: Error messages only show up in JS codebases with [a
> JSConfig](/docs/handbook/tsconfig-json.html) and
> [`checkJs`](/tsconfig#checkJs) enabled.

With `@constructor`, `this` is checked inside the constructor function `C`, so
you will get suggestions for the `initialize` method and an error if you pass
it a number. Your editor may also show warnings if you call `C` instead of
constructing it.

Unfortunately, this means that constructor functions that are also callable
cannot use `@constructor`.

### `@this`

The compiler can usually figure out the type of `this` when it has some
context to work with. When it doesn‚Äôt, you can explicitly specify the type of
`this` with `@this`:

    
    
    js
    
    /**
    
     * @this {HTMLElement}
    
     * @param {*} e
    
     */
    
    function callbackForLater(e) {
    
      this.clientHeight = parseInt(e); // should be fine!
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAFgSwM6QN4AkAqBZAGQFEAbAUwFsyA7eAXyhlgAcBDAJ1YsxDsjMbBwAMwCu1AMbxkAe2qQJrEiQBGrCQGsAYjPYFW8MuwAUZAJSYokJGgB0EkshrwsZZAHNE8SAF5IbdlQyAElaUzMAbkhgYEhURBlREgATSBUySGFkajIAQnA6IA)

## Documentation

### `@deprecated`

When a function, method, or property is deprecated you can let users know by
marking it with a `/** @deprecated */` JSDoc comment. That information is
surfaced in completion lists and as a suggestion diagnostic that editors can
handle specially. In an editor like VS Code, deprecated values are typically
displayed in a strike-through style ~~like this~~.

    
    
    js
    
    /** @deprecated */
    
    const apiV1 = {};
    
    const apiV2 = {};
    
    ¬†
    
    apiV;
    
    ¬†¬†¬†
    
      * apiV1
      * apiV2
    
    
    
    ¬†
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFDAFSYgEwKYAO8+AxgIYAu+uomwap0kKlo5hAlgGoCMoAXlABvAL4BuRs1bsu3AEyCREtGg49JIUAD0APqqA)

### `@see`

`@see` lets you link to other names in your program:

    
    
    ts
    
    type Box<T> = { t: T }
    
    /** @see Box for implementation details */
    
    type Boxify<T> = { [K in keyof T]: Box<T> };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIDOE08CUAZnAE5QCWAWzAAbCAIgA7YAENgfOBKgATCDL7DGUapXKhIsRHw4hUGbHgDaAaX6KA1hBBwOxALpE2psgG4gA)

Some editors will turn `Box` into a link to make it easy to jump there and
back.

### `@link`

`@link` is like `@see`, except that it can be used inside other tags:

    
    
    ts
    
    type Box<T> = { t: T }
    
    /** @returns A {@link Box} containing the parameter. */
    
    function box<U>(u: U): Box<U> {
    
      return { t: u };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIBOEwArowHYDOUAgrvQA2ASw4BrWIlJQAxnA7AAhqNEBzfAAtoYRY0UBbFhEYA6KNUrkAZqw4zgw+VABGiJAFU0AClZF3ASiJ4ZE9ccigoZjZOXHwiVjIAbnJSIA)

## Other

### `@enum`

The `@enum` tag allows you to create an object literal whose members are all
of a specified type. Unlike most object literals in JavaScript, it does not
allow other members. `@enum` is intended for compatibility with Google
Closure‚Äôs `@enum` tag.

    
    
    js
    
    /** @enum {number} */
    
    const JSDocState = {
    
      BeginningOfLine: 0,
    
      SawAsterisk: 1,
    
      SavingComments: 2,
    
    };
    
    ¬†
    
    JSDocState.SawAsterisk;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeDECNoCcC+4RgAoAYwHtYBnAF3ACkBlAETJIeoENrpwBeVIuHAAhaAHMAlrFhSxAeQBmAGSnQAXOAAMAGkHgGHAO4BBGjgmUA1hoCMuoQYBusgMJlEiONUoaATLtwAbiIiRhY2Tm4AOgMTM2wLS0CgA)

Note that `@enum` is quite different from, and much simpler than, TypeScript‚Äôs
`enum`. However, unlike TypeScript‚Äôs enums, `@enum` can have any type:

    
    
    js
    
    /** @enum {function(number): number} */
    
    const MathFuncs = {
    
      add1: (n) => n + 1,
    
      id: (n) => -n,
    
      sub1: (n) => n - 1,
    
    };
    
    ¬†
    
    MathFuncs.add1;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeAzesDGAXAlgPawAUCiARtAE4CUAXOGZVQL7gjABQWRAzjuACyAQxwALAGKYsvcAF5UncOGEATVQEYGpGvIB8jcAGpwGgDRLweVdti65BgLSwLy3vHJbwO-YcemLFgBuTk4RcSlsXgA6NU0goA)

### `@author`

You can specify the author of an item with `@author`:

    
    
    ts
    
    /**
    
     * Welcome to awesome.ts
    
     * @author Ian Awesome <i.am.awesome@example.com>
    
     */
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUh1BTANgYwPYFt6QC6sgQwHd4BnDeAOmxKhgAF8BXbAC1QCdIBJfAO0gCCxMpkgAeAJYV86acPJ14ADxkAHRJTToAfLWBA)

Remember to surround the email address with angle brackets. Otherwise,
`@example` will be parsed as a new tag.

### Other supported patterns

    
    
    js
    
    var someObj = {
    
      /**
    
       * @param {string} param1 - JSDocs on property assignments work
    
       */
    
      x: function (param1) {},
    
    };
    
    ¬†
    
    /**
    
     * As do jsdocs on variable assignments
    
     * @return {Window}
    
     */
    
    let someFunc = function () {};
    
    ¬†
    
    /**
    
     * And class methods
    
     * @param {string} greeting The greeting to use
    
     */
    
    Foo.prototype.sayHi = (greeting) => console.log("Hi!");
    
    ¬†
    
    /**
    
     * And arrow function expressions
    
     * @param {number} x - A multiplier
    
     */
    
    let myArrow = (x) => x * x;
    
    ¬†
    
    /**
    
     * Which means it works for function components in JSX too
    
     * @param {{a: string, b: number}} props - Some param
    
     */
    
    var fc = (props) => <div>{props.a.charAt(0)}</div>;
    
    ¬†
    
    /**
    
     * A parameter can be a class constructor, using Google Closure syntax.
    
     *
    
     * @param {{new(...args: any[]): object}} C - The class to register
    
     */
    
    function registerClass(C) {}
    
    ¬†
    
    /**
    
     * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
    
     */
    
    function fn10(p1) {}
    
    ¬†
    
    /**
    
     * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
    
     */
    
    function fn9(p1) {
    
      return p1.join();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBiD29oG8C+AoA9J6BafwArgC767oBuYATtBPALYCmA8gEYBW0AvCutNEwAqIfwFDoAAQAONMAxQRi1AJYA7AOapos6vICMeaACkAygBF4wGPDU7q8aU2rEAntEgQVGtczXEYAHd4agBrMWghTDEADwAuaAAzQjVgYhVbaAAKXQMAShRUABp0VABudCwRfgkAQRgAEyQOCCbraEyqVTA2ECYPKG9fJn8IGqlqJmJCajtkAHV1JsCMSOi+4jpGJlgU4B4kvfTMrIK0CqrRSOhatQboUE9oZmIAC3gGseuZOQVkJVUmm0GkmU3UGmgABVXv0QUwwZpoMQkIQIEwatEEPAAHTSBzItxObEQMCuAASKgOWThCI0BW4AD4HrZ6H1sSB4BosgAiCkAQm5eQuwiudTuHmoDkCh1SxzsTBieKYgxZ4x+ej+akIDDYzm0MSMtWehBA6WkIBUzgx6A2z1ctUl8GlvCyMXpTINEhiwuq13mrxUwFezyYYDUMBUm2CYRgiRCMrSGTswEY0lsIwC0HUJlMAA0kYg1bk-sgwAkAeCitA2AktTq9do8Y4YLhoKZtjpftaukl9i6m9IIO7oAAeBoqCgM5ADiDYsDYoM0WrELIABjyqBHmHHk59opunY1U2cDzD1f6YAe4CgzPDykIaRCVdR4OgAHFEBo+tAAMIciAzP0ECuP4YAxNiNRFr8KDIGoTCBFk2JITQGgQAkYauAA2gAunkCTwJwTBpKg2g-kY0L9I8N7ItAkwaCoShWms6DJLKSa0Uw9GMdQf6eFkP5nBglxQRqKBIcSyjgo2hitkaADkkxKHJEoQlkNB6K4BTwIkdCSZos7ZMoobEEw9yQNAckYXJeTWqxiaZIkaj6KuOT6IJlQiiJ8hiUhFZAjoMkHgpyrEMpKHZOppJaTpfmodihmTGAJlmTAllqK41m2Uc7GOQAnK5ZxiJM0yzAF2IcPA6inBUqBAA)

### Unsupported patterns

Postfix equals on a property type in an object literal type doesn‚Äôt specify an
optional property:

    
    
    js
    
    /**
    
     * @type {{ a: string, b: number= }}
    
     */
    
    var wrong;
    
    /**
    
     * Use postfix question on the property name instead:
    
     * @type {{ a: string, b?: number }}
    
     */
    
    var right;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4cgQwFyQDO8ATgJYB2A5gDSQBGBFArgLb2okC8kAvr1BDBwANxwlIAdxIB7agG5woCNEgBVQumQziAMzIAPSAEdmqYmTmQr8ABZbZaEkkgUcrdJWKocAEzyCcEhomNj4RKSUtAwA-ExsHBL8gsJiEuRUtvDyQA)

Nullable types only have meaning if
[`strictNullChecks`](/tsconfig#strictNullChecks) is on:

    
    
    js
    
    /**
    
     * @type {?number}
    
     * With strictNullChecks: true  -- number | null
    
     * With strictNullChecks: false -- number
    
     */
    
    var nullable;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4H4B2BXAWwCNUAnAXyhgHUBLeAC0gGd5TaBjeAOTwBs+AYQaoOAa2YAuSGzzpIAWgWR8xMpAA+K-nyqQ6jFm048dw0ROkAzAIZ9m6JdrWkqwcADcbpbQJtE+VABuIA)

The TypeScript-native syntax is a union type:

    
    
    js
    
    /**
    
     * @type {number | null}
    
     * With strictNullChecks: true  -- number | null
    
     * With strictNullChecks: false -- number
    
     */
    
    var unionNullable;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSXAGyoF8oYB1AS3gAtIBneY5gY3gA5HDQDCbVHwDWnAFyQeOdJAC0KyviKkK1Kg0gt2XHvyEiq4yTPkAzAIZVO6NRsIkGwcADc7pHFmYAeyxhGjsCKlQAbiA)

Non-nullable types have no meaning and are treated just as their original
type:

    
    
    js
    
    /**
    
     * @type {!number}
    
     * Just has type number
    
     */
    
    var normal;
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4EIB2BXAWwCNUAnAXyhgCk8BneSACwEM7Ik1J9iyrhwANxaluAe1IEWAGwDcQA)

Unlike JSDoc‚Äôs type system, TypeScript only allows you to mark types as
containing null or not. There is no explicit non-nullability ‚Äî if
strictNullChecks is on, then `number` is not nullable. If it is off, then
`number` is nullable.

### Unsupported tags

TypeScript ignores any unsupported JSDoc tags.

The following tags have open issues to support them:

  * `@memberof` ([issue #7237](https://github.com/Microsoft/TypeScript/issues/7237))
  * `@yields` ([issue #23857](https://github.com/Microsoft/TypeScript/issues/23857))
  * `@member` ([issue #56674](https://github.com/microsoft/TypeScript/issues/56674))

### Legacy type synonyms

A number of common types are given aliases for compatibility with old
JavaScript code. Some of the aliases are the same as existing types, although
most of those are rarely used. For example, `String` is treated as an alias
for `string`. Even though `String` is a type in TypeScript, old JSDoc often
uses it to mean `string`. Besides, in TypeScript, the capitalized versions of
primitive types are wrapper types ‚Äî almost always a mistake to use. So the
compiler treats these types as synonyms based on usage in old JSDoc:

  * `String -> string`
  * `Number -> number`
  * `Boolean -> boolean`
  * `Void -> void`
  * `Undefined -> undefined`
  * `Null -> null`
  * `function -> Function`
  * `array -> Array<any>`
  * `promise -> Promise<any>`
  * `Object -> any`
  * `object -> any`

The last four aliases are turned off when `noImplicitAny: true`:

  * `object` and `Object` are built-in types, although `Object` is rarely used.
  * `array` and `promise` are not built-in, but might be declared somewhere in your program.

### [Type Checking JavaScript FilesHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/type-checking-javascript-files.html)

### [Creating .d.ts Files from .js filesHow to add d.ts generation to
JavaScript projects](/docs/handbook/declaration-files/dts-from-js.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/JSDoc Reference.md)
‚ù§

Contributors to this page:  

OT![Orta Therox
\(23\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nathan Shively-Sanders
\(7\)](https://gravatar.com/avatar/8c5596e6ef2b41132cee585c9b146116?s=32&&d=blank)

RG![Rohit Gohri
\(2\)](https://gravatar.com/avatar/b7d0f744a7c6fc101513238926c9c88a?s=32&&d=blank)

L![LqdBcnAtWork
\(1\)](https://gravatar.com/avatar/86fb2d72181ca56b23a141530270977a?s=32&&d=blank)

K![Kisaragi
\(1\)](https://gravatar.com/avatar/5d02b7d2752e2b68e93de90618388ab0?s=32&&d=blank)

8+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# JSX

[JSX](https://facebook.github.io/jsx/) is an embeddable XML-like syntax. It is
meant to be transformed into valid JavaScript, though the semantics of that
transformation are implementation-specific. JSX rose to popularity with the
[React](https://reactjs.org/) framework, but has since seen other
implementations as well. TypeScript supports embedding, type checking, and
compiling JSX directly to JavaScript.

## Basic usage

In order to use JSX you must do two things.

  1. Name your files with a `.tsx` extension
  2. Enable the [`jsx`](/tsconfig#jsx) option

TypeScript ships with several JSX modes: `preserve`, `react` (classic
runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic
development runtime), and `react-native`. The `preserve` mode will keep the
JSX as part of the output to be further consumed by another transform step
(e.g. [Babel](https://babeljs.io/)). Additionally the output will have a
`.jsx` file extension. The `react` mode will emit `React.createElement`, does
not need to go through a JSX transformation before use, and the output will
have a `.js` file extension. The `react-native` mode is the equivalent of
`preserve` in that it keeps all JSX, but the output will instead have a `.js`
file extension.

Mode | Input | Output | Output File Extension  
---|---|---|---  
`preserve` | `<div />` | `<div />` | `.jsx`  
`react` | `<div />` | `React.createElement("div")` | `.js`  
`react-native` | `<div />` | `<div />` | `.js`  
`react-jsx` | `<div />` | `_jsx("div", {}, void 0);` | `.js`  
`react-jsxdev` | `<div />` | `_jsxDEV("div", {}, void 0, false, {...}, this);` | `.js`  
  
You can specify this mode using either the [`jsx`](/tsconfig#jsx) command line
flag or the corresponding option [`jsx` in your tsconfig.json](/tsconfig#jsx)
file.

> *Note: You can specify the JSX factory function to use when targeting react
> JSX emit with [`jsxFactory`](/tsconfig#jsxFactory) option (defaults to
> `React.createElement`)

## The `as` operator

Recall how to write a type assertion:

    
    
    ts
    
    const foo = <foo>bar;

This asserts the variable `bar` to have the type `foo`. Since TypeScript also
uses angle brackets for type assertions, combining it with JSX‚Äôs syntax would
introduce certain parsing difficulties. As a result, TypeScript disallows
angle bracket type assertions in `.tsx` files.

Since the above syntax cannot be used in `.tsx` files, an alternate type
assertion operator should be used: `as`. The example can easily be rewritten
with the `as` operator.

    
    
    ts
    
    const foo = bar as foo;

The `as` operator is available in both `.ts` and `.tsx` files, and is
identical in behavior to the angle-bracket type assertion style.

## Type Checking

In order to understand type checking with JSX, you must first understand the
difference between intrinsic elements and value-based elements. Given a JSX
expression `<expr />`, `expr` may either refer to something intrinsic to the
environment (e.g. a `div` or `span` in a DOM environment) or to a custom
component that you‚Äôve created. This is important for two reasons:

  1. For React, intrinsic elements are emitted as strings (`React.createElement("div")`), whereas a component you‚Äôve created is not (`React.createElement(MyComponent)`).
  2. The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known _intrinsically_ whereas components will likely want to specify their own set of attributes.

TypeScript uses the [same convention that React
does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-
vs.-react-components) for distinguishing between these. An intrinsic element
always begins with a lowercase letter, and a value-based element always begins
with an uppercase letter.

### The `JSX` namespace

JSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be
defined in various places, depending on the `jsx` compiler option.

The `jsx` options `preserve`, `react`, and `react-native` use the type
definitions for classic runtime. This means a variable needs to be in scope
that‚Äôs determined by the `jsxFactory` compiler option. The `JSX` namespace
should be specified on the top-most identifier of the JSX factory. For
example, React uses the default factory `React.createElement`. This means its
`JSX` namespace should be defined as `React.JSX`.

    
    
    ts
    
    export function createElement(): any;
    
    export namespace JSX {
    
      // ‚Ä¶
    
    }

And the user should always import React as `React`.

    
    
    ts
    
    import * as React from 'react';

Preact uses the JSX factory `h`. That means its types should be defined as the
`h.JSX`.

    
    
    ts
    
    export function h(props: any): any;
    
    export namespace h.JSX {
    
      // ‚Ä¶
    
    }

The user should use a named import to import `h`.

    
    
    ts
    
    import { h } from 'preact';

For the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace
should be exported from the matching entry points. For `react-jsx` this is
`${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is
`${jsxImportSource}/jsx-dev-runtime`. Since these don‚Äôt use a file extension,
you must use the [`exports`](https://nodejs.org/api/packages.html#exports)
field in `package.json` map in order to support ESM users.

    
    
    json
    
    {
    
      "exports": {
    
        "./jsx-runtime": "./jsx-runtime.js",
    
        "./jsx-dev-runtime": "./jsx-dev-runtime.js",
    
      }
    
    }

Then in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:

    
    
    ts
    
    export namespace JSX {
    
      // ‚Ä¶
    
    }

Note that while exporting the `JSX` namespace is sufficient for type checking,
the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at
runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally
you add types for those too.

If the `JSX` namespace isn‚Äôt available in the appropriate location, both the
classic and the automatic runtime fall back to the global `JSX` namespace.

### Intrinsic elements

Intrinsic elements are looked up on the special interface
`JSX.IntrinsicElements`. By default, if this interface is not specified, then
anything goes and intrinsic elements will not be type checked. However, if
this interface _is_ present, then the name of the intrinsic element is looked
up as a property on the `JSX.IntrinsicElements` interface. For example:

    
    
    tsx
    
    declare namespace JSX {
    
      interface IntrinsicElements {
    
        foo: any;
    
      }
    
    }
    
    <foo />; // ok
    
    <bar />; // error

In the above example, `<foo />` will work fine but `<bar />` will result in an
error since it has not been specified on `JSX.IntrinsicElements`.

> Note: You can also specify a catch-all string indexer on
> `JSX.IntrinsicElements` as follows:
    
    
    ts
    
    declare namespace JSX {
    
      interface IntrinsicElements {
    
        [elemName: string]: any;
    
      }
    
    }

### Value-based elements

Value-based elements are simply looked up by identifiers that are in scope.

    
    
    tsx
    
    import MyComponent from "./myComponent";
    
    <MyComponent />; // ok
    
    <SomeOtherComponent />; // error

There are two ways to define a value-based element:

  1. Function Component (FC)
  2. Class Component

Because these two types of value-based elements are indistinguishable from
each other in a JSX expression, first TS tries to resolve the expression as a
Function Component using overload resolution. If the process succeeds, then TS
finishes resolving the expression to its declaration. If the value fails to
resolve as a Function Component, TS will then try to resolve it as a class
component. If that fails, TS will report an error.

#### Function Component

As the name suggests, the component is defined as a JavaScript function where
its first argument is a `props` object. TS enforces that its return type must
be assignable to `JSX.Element`.

    
    
    tsx
    
    interface FooProp {
    
      name: string;
    
      X: number;
    
      Y: number;
    
    }
    
    declare function AnotherComponent(prop: { name: string });
    
    function ComponentFoo(prop: FooProp) {
    
      return <AnotherComponent name={prop.name} />;
    
    }
    
    const Button = (prop: { value: string }, context: { color: string }) => (
    
      <button />
    
    );

Because a Function Component is simply a JavaScript function, function
overloads may be used here as well:

    
    
    ts
    
    interface ClickableProps {
    
      children: JSX.Element[] | JSX.Element;
    
    }
    
    ¬†
    
    interface HomeProps extends ClickableProps {
    
      home: JSX.Element;
    
    }
    
    ¬†
    
    interface SideProps extends ClickableProps {
    
      side: JSX.Element | string;
    
    }
    
    ¬†
    
    function MainButton(prop: HomeProps): JSX.Element;
    
    function MainButton(prop: SideProps): JSX.Element;
    
    function MainButton(prop: ClickableProps): JSX.Element {
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagC20GArniQFIDKAGqAN5qigCWkALlvADMCOErBqksvVgF92XXvyEjQASV7xuKTjjFYJvFKzkcA2igBcoFDw2QA5gF1LBSAE8A3HNmyQoALQBOJQ8AX5o3HyCwiQAwnjaANYEAEY0AApIAA6GbBw4ABaceBjEkJYMjAB0uvo8Jg6gAD6gFdXikjyesuEKUcoAEtASGdDZoFgAHnyQGIZxiSnpWTly+UNY5Uxteh1daD2RSiT0nNgjY5PTs6DzOEmpWOcrHFrYm1U1HU1WNtx2e2gBJRIDgeJxoJBQABZAjcABCwR4EIAFJkspZBsNlgBKd7bWqeIEgsEQ6GwyAInhIyCo9GgE5nHF4z68QnA0HgyEw+GIlFo0aWW73JajFC4lpbFk8IwcXyVeVoaRAA)

> Note: Function Components were formerly known as Stateless Function
> Components (SFC). As Function Components can no longer be considered
> stateless in recent versions of react, the type `SFC` and its alias
> `StatelessComponent` were deprecated.

#### Class Component

It is possible to define the type of a class component. However, to do so it
is best to understand two new terms: the _element class type_ and the _element
instance type_.

Given `<Expr />`, the _element class type_ is the type of `Expr`. So in the
example above, if `MyComponent` was an ES6 class the class type would be that
class‚Äôs constructor and statics. If `MyComponent` was a factory function, the
class type would be that function.

Once the class type is established, the instance type is determined by the
union of the return types of the class type‚Äôs construct or call signatures
(whichever is present). So again, in the case of an ES6 class, the instance
type would be the type of an instance of that class, and in the case of a
factory function, it would be the type of the value returned from the
function.

    
    
    ts
    
    class MyComponent {
    
      render() {}
    
    }
    
    // use a construct signature
    
    const myComponent = new MyComponent();
    
    // element class type => MyComponent
    
    // element instance type => { render: () => void }
    
    function MyFactoryFunction() {
    
      return {
    
        render: () => {},
    
      };
    
    }
    
    // use a call signature
    
    const myComponent = MyFactoryFunction();
    
    // element class type => MyFactoryFunction
    
    // element instance type => { render: () => void }

The element instance type is interesting because it must be assignable to
`JSX.ElementClass` or it will result in an error. By default
`JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to
only those types that conform to the proper interface.

    
    
    tsx
    
    declare namespace JSX {
    
      interface ElementClass {
    
        render: any;
    
      }
    
    }
    
    class MyComponent {
    
      render() {}
    
    }
    
    function MyFactoryFunction() {
    
      return { render: () => {} };
    
    }
    
    <MyComponent />; // ok
    
    <MyFactoryFunction />; // ok
    
    class NotAValidComponent {}
    
    function NotAValidFactoryFunction() {
    
      return {};
    
    }
    
    <NotAValidComponent />; // error
    
    <NotAValidFactoryFunction />; // error

### Attribute type checking

The first step to type checking attributes is to determine the _element
attributes type_. This is slightly different between intrinsic and value-based
elements.

For intrinsic elements, it is the type of the property on
`JSX.IntrinsicElements`

    
    
    tsx
    
    declare namespace JSX {
    
      interface IntrinsicElements {
    
        foo: { bar?: boolean };
    
      }
    
    }
    
    // element attributes type for 'foo' is '{bar?: boolean}'
    
    <foo bar />;

For value-based elements, it is a bit more complex. It is determined by the
type of a property on the _element instance type_ that was previously
determined. Which property to use is determined by
`JSX.ElementAttributesProperty`. It should be declared with a single property.
The name of that property is then used. As of TypeScript 2.8, if
`JSX.ElementAttributesProperty` is not provided, the type of first parameter
of the class element‚Äôs constructor or Function Component‚Äôs call will be used
instead.

    
    
    tsx
    
    declare namespace JSX {
    
      interface ElementAttributesProperty {
    
        props; // specify the property name to use
    
      }
    
    }
    
    class MyComponent {
    
      // specify the property on the element instance type
    
      props: {
    
        foo?: string;
    
      };
    
    }
    
    // element attributes type for 'MyComponent' is '{foo?: string}'
    
    <MyComponent foo="bar" />;

The element attribute type is used to type check the attributes in the JSX.
Optional and required properties are supported.

    
    
    tsx
    
    declare namespace JSX {
    
      interface IntrinsicElements {
    
        foo: { requiredProp: string; optionalProp?: number };
    
      }
    
    }
    
    <foo requiredProp="bar" />; // ok
    
    <foo requiredProp="bar" optionalProp={0} />; // ok
    
    <foo />; // error, requiredProp is missing
    
    <foo requiredProp={0} />; // error, requiredProp should be a string
    
    <foo requiredProp="bar" unknownProp />; // error, unknownProp does not exist
    
    <foo requiredProp="bar" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier

> Note: If an attribute name is not a valid JS identifier (like a `data-*`
> attribute), it is not considered to be an error if it is not found in the
> element attributes type.

Additionally, the `JSX.IntrinsicAttributes` interface can be used to specify
extra properties used by the JSX framework which are not generally used by the
components‚Äô props or arguments - for instance `key` in React. Specializing
further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used
to specify the same kind of extra attributes just for class components (and
not Function Components). In this type, the generic parameter corresponds to
the class instance type. In React, this is used to allow the `ref` attribute
of type `Ref<T>`. Generally speaking, all of the properties on these
interfaces should be optional, unless you intend that users of your JSX
framework need to provide some attribute on every tag.

The spread operator also works:

    
    
    tsx
    
    const props = { requiredProp: "bar" };
    
    <foo {...props} />; // ok
    
    const badProps = {};
    
    <foo {...badProps} />; // error

### Children Type Checking

In TypeScript 2.3, TS introduced type checking of _children_. _children_ is a
special property in an _element attributes type_ where child _JSXExpression_ s
are taken to be inserted into the attributes. Similar to how TS uses
`JSX.ElementAttributesProperty` to determine the name of _props_ , TS uses
`JSX.ElementChildrenAttribute` to determine the name of _children_ within
those props. `JSX.ElementChildrenAttribute` should be declared with a single
property.

    
    
    ts
    
    declare namespace JSX {
    
      interface ElementChildrenAttribute {
    
        children: {}; // specify children name to use
    
      }
    
    }
    
    
    tsx
    
    <div>
    
      <h1>Hello</h1>
    
    </div>;
    
    <div>
    
      <h1>Hello</h1>
    
      World
    
    </div>;
    
    const CustomComp = (props) => <div>{props.children}</div>
    
    <CustomComp>
    
      <div>Hello World</div>
    
      {"This is just a JS expression..." + 1000}
    
    </CustomComp>

You can specify the type of _children_ like any other attribute. This will
override the default type from, e.g. the [React
typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)
if you use them.

    
    
    tsx
    
    interface PropsType {
    
      children: JSX.Element
    
      name: string
    
    }
    
    class Component extends React.Component<PropsType, {}> {
    
      render() {
    
        return (
    
          <h2>
    
            {this.props.children}
    
          </h2>
    
        )
    
      }
    
    }
    
    // OK
    
    <Component name="foo">
    
      <h1>Hello World</h1>
    
    </Component>
    
    // Error: children is of type JSX.Element not array of JSX.Element
    
    <Component name="bar">
    
      <h1>Hello World</h1>
    
      <h2>Hello World</h2>
    
    </Component>
    
    // Error: children is of type JSX.Element not array of JSX.Element or string.
    
    <Component name="baz">
    
      <h1>Hello</h1>
    
      World
    
    </Component>

## The JSX result type

By default the result of a JSX expression is typed as `any`. You can customize
the type by specifying the `JSX.Element` interface. However, it is not
possible to retrieve type information about the element, attributes or
children of the JSX from this interface. It is a black box.

## The JSX function return type

By default, function components must return `JSX.Element | null`. However, this doesn‚Äôt always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn‚Äôt define what props are valid. The type of props is always defined by the first argument of the component that‚Äôs passed. The default looks something like this:
    
    
    ts
    
    namespace JSX {
    
        export type ElementType =
    
            // All the valid lowercase tags
    
            keyof IntrinsicAttributes
    
            // Function components
    
            (props: any) => Element
    
            // Class components
    
            new (props: any) => ElementClass;
    
        export interface IntrinsicAttributes extends /*...*/ {}
    
        export type Element = /*...*/;
    
        export type ElementClass = /*...*/;
    
    }

## Embedding Expressions

JSX allows you to embed expressions between tags by surrounding the
expressions with curly braces (`{ }`).

    
    
    tsx
    
    const a = (
    
      <div>
    
        {["foo", "bar"].map((i) => (
    
          <span>{i / 2}</span>
    
        ))}
    
      </div>
    
    );

The above code will result in an error since you cannot divide a string by a
number. The output, when using the `preserve` option, looks like:

    
    
    tsx
    
    const a = (
    
      <div>
    
        {["foo", "bar"].map(function (i) {
    
          return <span>{i / 2}</span>;
    
        })}
    
      </div>
    
    );

## React integration

To use JSX with React you should use the [React
typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react).
These typings define the `JSX` namespace appropriately for use with React.

    
    
    tsx
    
    /// <reference path="react.d.ts" />
    
    interface Props {
    
      foo: string;
    
    }
    
    class MyComponent extends React.Component<Props, {}> {
    
      render() {
    
        return <span>{this.props.foo}</span>;
    
      }
    
    }
    
    <MyComponent foo="bar" />; // ok
    
    <MyComponent foo={0} />; // error

### Configuring JSX

There are multiple compiler flags which can be used to customize your JSX,
which work as both a compiler flag and via inline per-file pragmas. To learn
more see their tsconfig reference pages:

  * [`jsxFactory`](/tsconfig#jsxFactory)
  * [`jsxFragmentFactory`](/tsconfig#jsxFragmentFactory)
  * [`jsxImportSource`](/tsconfig#jsxImportSource)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/JSX.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(55\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(20\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RC![Ryan Cavanaugh
\(6\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

DZ![David Zulaica
\(3\)](https://gravatar.com/avatar/da0a821c09edbd8369777d622b446cc2?s=32&&d=blank)

KT![Kanchalai Tanglertsampan
\(3\)](https://gravatar.com/avatar/c8404f96910ba93ddc3e881b4bff24a4?s=32&&d=blank)

33+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Migrating from JavaScript

TypeScript doesn‚Äôt exist in a vacuum. It was built with the JavaScript
ecosystem in mind, and a lot of JavaScript exists today. Converting a
JavaScript codebase over to TypeScript is, while somewhat tedious, usually not
challenging. In this tutorial, we‚Äôre going to look at how you might start out.
We assume you‚Äôve read enough of the handbook to write new TypeScript code.

If you‚Äôre looking to convert a React project, we recommend looking at the
[React Conversion Guide](https://github.com/Microsoft/TypeScript-React-
Conversion-Guide#typescript-react-conversion-guide) first.

## Setting up your Directories

If you‚Äôre writing in plain JavaScript, it‚Äôs likely that you‚Äôre running your
JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist`
directory, and then run as desired.

If that‚Äôs the case, the files that you‚Äôve written are going to be used as
inputs to TypeScript, and you‚Äôll run the outputs it produces. During our JS to
TS migration, we‚Äôll need to separate our input files to prevent TypeScript
from overwriting them. If your output files need to reside in a specific
directory, then that will be your output directory.

You might also be running some intermediate steps on your JavaScript, such as
bundling or using another transpiler like Babel. In this case, you might
already have a folder structure like this set up.

From this point on, we‚Äôre going to assume that your directory is set up
something like this:

    
    
    projectRoot
    
    ‚îú‚îÄ‚îÄ src
    
    ‚îÇ   ‚îú‚îÄ‚îÄ file1.js
    
    ‚îÇ   ‚îî‚îÄ‚îÄ file2.js
    
    ‚îú‚îÄ‚îÄ built
    
    ‚îî‚îÄ‚îÄ tsconfig.json

If you have a `tests` folder outside of your `src` directory, you might have
one `tsconfig.json` in `src`, and one in `tests` as well.

## Writing a Configuration File

TypeScript uses a file called `tsconfig.json` for managing your project‚Äôs
options, such as which files you want to include, and what sorts of checking
you want to perform. Let‚Äôs create a bare-bones one for our project:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "outDir": "./built",
    
        "allowJs": true,
    
        "target": "es5"
    
      },
    
      "include": ["./src/**/*"]
    
    }

Here we‚Äôre specifying a few things to TypeScript:

  1. Read in any files it understands in the `src` directory (with [`include`](/tsconfig#include)).
  2. Accept JavaScript files as inputs (with [`allowJs`](/tsconfig#allowJs)).
  3. Emit all of the output files in `built` (with [`outDir`](/tsconfig#outDir)).
  4. Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](/tsconfig#target)).

At this point, if you try running `tsc` at the root of your project, you
should see output files in the `built` directory. The layout of files in
`built` should look identical to the layout of `src`. You should now have
TypeScript working with your project.

## Early Benefits

Even at this point you can get some great benefits from TypeScript
understanding your project. If you open up an editor like [VS
Code](https://code.visualstudio.com) or [Visual
Studio](https://visualstudio.com), you‚Äôll see that you can often get some
tooling support like completion. You can also catch certain bugs with options
like:

  * [`noImplicitReturns`](/tsconfig#noImplicitReturns) which prevents you from forgetting to return at the end of a function.
  * [`noFallthroughCasesInSwitch`](/tsconfig#noFallthroughCasesInSwitch) which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.

TypeScript will also warn about unreachable code and labels, which you can
disable with [`allowUnreachableCode`](/tsconfig#allowUnreachableCode) and
[`allowUnusedLabels`](/tsconfig#allowUnusedLabels) respectively.

## Integrating with Build Tools

You might have some more build steps in your pipeline. Perhaps you concatenate
something to each of your files. Each build tool is different, but we‚Äôll do
our best to cover the gist of things.

### Gulp

If you‚Äôre using Gulp in some fashion, we have a tutorial on [using
Gulp](/docs/handbook/gulp.html) with TypeScript, and integrating with common
build tools like Browserify, Babelify, and Uglify. You can read more there.

### Webpack

Webpack integration is pretty simple. You can use `ts-loader`, a TypeScript
loader, combined with `source-map-loader` for easier debugging. Simply run

    
    
    shell
    
    npm install ts-loader source-map-loader

and merge in options from the following into your `webpack.config.js` file:

    
    
    js
    
    module.exports = {
    
      entry: "./src/index.ts",
    
      output: {
    
        filename: "./dist/bundle.js",
    
      },
    
      // Enable sourcemaps for debugging webpack's output.
    
      devtool: "source-map",
    
      resolve: {
    
        // Add '.ts' and '.tsx' as resolvable extensions.
    
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"],
    
      },
    
      module: {
    
        rules: [
    
          // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.
    
          { test: /\.tsx?$/, loader: "ts-loader" },
    
          // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
    
          { test: /\.js$/, loader: "source-map-loader" },
    
        ],
    
      },
    
      // Other options...
    
    };

It‚Äôs important to note that ts-loader will need to run before any other loader
that deals with `.js` files.

You can see an example of using Webpack in our [tutorial on React and
Webpack](/docs/handbook/react-&-webpack.html).

## Moving to TypeScript Files

At this point, you‚Äôre probably ready to start using TypeScript files. The
first step is to rename one of your `.js` files to `.ts`. If your file uses
JSX, you‚Äôll need to rename it to `.tsx`.

Finished with that step? Great! You‚Äôve successfully migrated a file from
JavaScript to TypeScript!

Of course, that might not feel right. If you open that file in an editor with
TypeScript support (or if you run `tsc --pretty`), you might see red squiggles
on certain lines. You should think of these the same way you‚Äôd think of red
squiggles in an editor like Microsoft Word. TypeScript will still translate
your code, just like Word will still let you print your documents.

If that sounds too lax for you, you can tighten that behavior up. If, for
instance, you _don‚Äôt_ want TypeScript to compile to JavaScript in the face of
errors, you can use the [`noEmitOnError`](/tsconfig#noEmitOnError) option. In
that sense, TypeScript has a dial on its strictness, and you can turn that
knob up as high as you want.

If you plan on using the stricter settings that are available, it‚Äôs best to
turn them on now (see Getting Stricter Checks below). For instance, if you
never want TypeScript to silently infer `any` for a type without you
explicitly saying so, you can use [`noImplicitAny`](/tsconfig#noImplicitAny)
before you start modifying your files. While it might feel somewhat
overwhelming, the long-term gains become apparent much more quickly.

### Weeding out Errors

Like we mentioned, it‚Äôs not unexpected to get error messages after conversion.
The important thing is to actually go one by one through these and decide how
to deal with the errors. Often these will be legitimate bugs, but sometimes
you‚Äôll have to explain what you‚Äôre trying to do a little better to TypeScript.

#### Importing from Modules

You might start out getting a bunch of errors like `Cannot find name
'require'.`, and `Cannot find name 'define'.`. In these cases, it‚Äôs likely
that you‚Äôre using modules. While you can just convince TypeScript that these
exist by writing out

    
    
    ts
    
    // For Node/CommonJS
    
    declare function require(path: string): any;

or

    
    
    ts
    
    // For RequireJS/AMD
    
    declare function define(...args: any[]): any;

it‚Äôs better to get rid of those calls and use TypeScript syntax for imports.

First, you‚Äôll need to enable some module system by setting TypeScript‚Äôs
[`module`](/tsconfig#module) option. Valid options are `commonjs`, `amd`,
`system`, and `umd`.

If you had the following Node/CommonJS code:

    
    
    js
    
    var foo = require("foo");
    
    foo.doStuff();

or the following RequireJS/AMD code:

    
    
    js
    
    define(["foo"], function (foo) {
    
      foo.doStuff();
    
    });

then you would write the following TypeScript code:

    
    
    ts
    
    import foo = require("foo");
    
    foo.doStuff();

#### Getting Declaration Files

If you started converting over to TypeScript imports, you‚Äôll probably run into
errors like `Cannot find module 'foo'.`. The issue here is that you likely
don‚Äôt have _declaration files_ to describe your library. Luckily this is
pretty easy. If TypeScript complains about a package like `lodash`, you can
just write

    
    
    shell
    
    npm install -S @types/lodash

If you‚Äôre using a module option other than `commonjs`, you‚Äôll need to set your
[`moduleResolution`](/tsconfig#moduleResolution) option to `node`.

After that, you‚Äôll be able to import lodash with no issues, and get accurate
completions.

#### Exporting from Modules

Typically, exporting from a module involves adding properties to a value like
`exports` or `module.exports`. TypeScript allows you to use top-level export
statements. For instance, if you exported a function like so:

    
    
    js
    
    module.exports.feedPets = function (pets) {
    
      // ...
    
    };

you could write that out as the following:

    
    
    ts
    
    export function feedPets(pets) {
    
      // ...
    
    }

Sometimes you‚Äôll entirely overwrite the exports object. This is a common
pattern people use to make their modules immediately callable like in this
snippet:

    
    
    js
    
    var express = require("express");
    
    var app = express();

You might have previously written that like so:

    
    
    js
    
    function foo() {
    
      // ...
    
    }
    
    module.exports = foo;

In TypeScript, you can model this with the `export =` construct.

    
    
    ts
    
    function foo() {
    
      // ...
    
    }
    
    export = foo;

#### Too many/too few arguments

You‚Äôll sometimes find yourself calling a function with too many/few arguments.
Typically, this is a bug, but in some cases, you might have declared a
function that uses the `arguments` object instead of writing out any
parameters:

    
    
    js
    
    function myCoolFunction() {
    
      if (arguments.length == 2 && !Array.isArray(arguments[1])) {
    
        var f = arguments[0];
    
        var arr = arguments[1];
    
        // ...
    
      }
    
      // ...
    
    }
    
    myCoolFunction(
    
      function (x) {
    
        console.log(x);
    
      },
    
      [1, 2, 3, 4]
    
    );
    
    myCoolFunction(
    
      function (x) {
    
        console.log(x);
    
      },
    
      1,
    
      2,
    
      3,
    
      4
    
    );

In this case, we need to use TypeScript to tell any of our callers about the
ways `myCoolFunction` can be called using function overloads.

    
    
    ts
    
    function myCoolFunction(f: (x: number) => void, nums: number[]): void;
    
    function myCoolFunction(f: (x: number) => void, ...nums: number[]): void;
    
    function myCoolFunction() {
    
      if (arguments.length == 2 && !Array.isArray(arguments[1])) {
    
        var f = arguments[0];
    
        var arr = arguments[1];
    
        // ...
    
      }
    
      // ...
    
    }

We added two overload signatures to `myCoolFunction`. The first checks states
that `myCoolFunction` takes a function (which takes a `number`), and then a
list of `number`s. The second one says that it will take a function as well,
and then uses a rest parameter (`...nums`) to state that any number of
arguments after that need to be `number`s.

#### Sequentially Added Properties

Some people find it more aesthetically pleasing to create an object and add
properties immediately after like so:

    
    
    js
    
    var options = {};
    
    options.color = "red";
    
    options.volume = 11;

TypeScript will say that you can‚Äôt assign to `color` and `volume` because it
first figured out the type of `options` as `{}` which doesn‚Äôt have any
properties. If you instead moved the declarations into the object literal
themselves, you‚Äôd get no errors:

    
    
    ts
    
    let options = {
    
      color: "red",
    
      volume: 11,
    
    };

You could also define the type of `options` and add a type assertion on the
object literal.

    
    
    ts
    
    interface Options {
    
      color: string;
    
      volume: number;
    
    }
    
    let options = {} as Options;
    
    options.color = "red";
    
    options.volume = 11;

Alternatively, you can just say `options` has the type `any` which is the
easiest thing to do, but which will benefit you the least.

#### `any`, `Object`, and `{}`

You might be tempted to use `Object` or `{}` to say that a value can have any
property on it because `Object` is, for most purposes, the most general type.
However **`any` is actually the type you want to use** in those situations,
since it‚Äôs the most _flexible_ type.

For instance, if you have something that‚Äôs typed as `Object` you won‚Äôt be able
to call methods like `toLowerCase()` on it. Being more general usually means
you can do less with a type, but `any` is special in that it is the most
general type while still allowing you to do anything with it. That means you
can call it, construct it, access properties on it, etc. Keep in mind though,
whenever you use `any`, you lose out on most of the error checking and editor
support that TypeScript gives you.

If a decision ever comes down to `Object` and `{}`, you should prefer `{}`.
While they are mostly the same, technically `{}` is a more general type than
`Object` in certain esoteric cases.

### Getting Stricter Checks

TypeScript comes with certain checks to give you more safety and analysis of
your program. Once you‚Äôve converted your codebase to TypeScript, you can start
enabling these checks for greater safety.

#### No Implicit `any`

There are certain cases where TypeScript can‚Äôt figure out what certain types
should be. To be as lenient as possible, it will decide to use the type `any`
in its place. While this is great for migration, using `any` means that you‚Äôre
not getting any type safety, and you won‚Äôt get the same tooling support you‚Äôd
get elsewhere. You can tell TypeScript to flag these locations down and give
an error with the [`noImplicitAny`](/tsconfig#noImplicitAny) option.

#### Strict `null` & `undefined` Checks

By default, TypeScript assumes that `null` and `undefined` are in the domain
of every type. That means anything declared with the type `number` could be
`null` or `undefined`. Since `null` and `undefined` are such a frequent source
of bugs in JavaScript and TypeScript, TypeScript has the
[`strictNullChecks`](/tsconfig#strictNullChecks) option to spare you the
stress of worrying about these issues.

When [`strictNullChecks`](/tsconfig#strictNullChecks) is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is _possibly_ `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you‚Äôd write the type out as `number | null`.

If you ever have a value that TypeScript thinks is possibly
`null`/`undefined`, but you know better, you can use the postfix `!` operator
to tell it otherwise.

    
    
    ts
    
    declare var foo: string[] | null;
    
    foo.length; // error - 'foo' is possibly 'null'
    
    foo!.length; // okay - 'foo!' just has type 'string[]'

As a heads up, when using [`strictNullChecks`](/tsconfig#strictNullChecks),
your dependencies may need to be updated to use
[`strictNullChecks`](/tsconfig#strictNullChecks) as well.

#### No Implicit `any` for `this`

When you use the `this` keyword outside of classes, it has the type `any` by
default. For instance, imagine a `Point` class, and imagine a function that we
wish to add as a method:

    
    
    ts
    
    class Point {
    
      constructor(public x, public y) {}
    
      getDistance(p: Point) {
    
        let dx = p.x - this.x;
    
        let dy = p.y - this.y;
    
        return Math.sqrt(dx ** 2 + dy ** 2);
    
      }
    
    }
    
    // ...
    
    // Reopen the interface.
    
    interface Point {
    
      distanceFromOrigin(): number;
    
    }
    
    Point.prototype.distanceFromOrigin = function () {
    
      return this.getDistance({ x: 0, y: 0 });
    
    };

This has the same problems we mentioned above - we could easily have
misspelled `getDistance` and not gotten an error. For this reason, TypeScript
has the [`noImplicitThis`](/tsconfig#noImplicitThis) option. When that option
is set, TypeScript will issue an error when `this` is used without an explicit
(or inferred) type. The fix is to use a `this`-parameter to give an explicit
type in the interface or in the function itself:

    
    
    ts
    
    Point.prototype.distanceFromOrigin = function (this: Point) {
    
      return this.getDistance({ x: 0, y: 0 });
    
    };

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Migrating from
JavaScript.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(57\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

TA![Thomas Ankcorn
\(3\)](https://gravatar.com/avatar/0b4fb980ef758e71d214852ed0dcba68?s=32&&d=blank)

MG![Maayan Glikser
\(3\)](https://gravatar.com/avatar/3a615b34ef2060face8fcd481c6377e1?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

19+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Mixins

Along with traditional OO hierarchies, another popular way of building up
classes from reusable components is to build them by combining simpler partial
classes. You may be familiar with the idea of mixins or traits for languages
like Scala, and the pattern has also reached some popularity in the JavaScript
community.

## How Does A Mixin Work?

The pattern relies on using generics with class inheritance to extend a base
class. TypeScript‚Äôs best mixin support is done via the class expression
pattern. You can read more about how this pattern works in JavaScript
[here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-
classes/).

To get started, we‚Äôll need a class which will have the mixins applied on top
of:

    
    
    ts
    
    class Sprite {
    
      name = "";
    
      x = 0;
    
      y = 0;
    
    ¬†
    
      constructor(name: string) {
    
        this.name = name;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHNaA)

Then you need a type and a factory function which returns a class expression
extending the base class.

    
    
    ts
    
    // To get started, we need a type which we'll use to extend
    
    // other classes from. The main responsibility is to declare
    
    // that the type being passed in is a class.
    
    ¬†
    
    type Constructor = new (...args: any[]) => {};
    
    ¬†
    
    // This mixin adds a scale property, with getters and setters
    
    // for changing it with an encapsulated private property:
    
    ¬†
    
    function Scale<TBase extends Constructor>(Base: TBase) {
    
      return class Scaling extends Base {
    
        // Mixins may not declare private/protected properties
    
        // however, you can use ES2020 private fields
    
        _scale = 1;
    
    ¬†
    
        setScale(scale: number) {
    
          this._scale = scale;
    
        }
    
    ¬†
    
        get scale(): number {
    
          return this._scale;
    
        }
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUHtQcwUwC6gM4IIYCcFwCYBpQB3OUAOzl1DVAQE8AHEwgCwEsBjZouAcgBs+oAK7ISCaHAAe2UjgBQIUJATM4GUOz5pko5KABmGSAFsAdBFWhjaVqVAY4yepFLJWAI1Z9WdUKz3ioDhwmphwCmAqaEgqYgwk7nC2MKD02qI4fnb+VBpaOqZycnSMoADCLqgYQuzi6gC8ZHCEoAAUph2YMMgAXFSktADaALoAlKD1AHygAN4AvgDcRYrgbHrGrJK2VDg4etTI7Gh8JPRGjFi0BIQ+XPAI2Bj7siiIj8gRBpDqnGikMMk-Egbip+qA4KQjvRkEItNhMmdWAA3aKnc5qOg9Ir6ISQhCsFygADKRxOAB5wAAhbQkKQyPblSoIaq1b6TVrU0R9Kk08YzOSgeyIIQYOyhHTE0mAukQhmckj8wWCxQAWU2tnWaFoZGUQRCWgcqQwyNRwDOyhC8KNkAu+McAqVimYkGISLUBFokCEGj+wlEoAAokSAEwABjDRpN2AMrDgfD2DsFAH1DscSI0AIxLROvBAktOtVMnPqkITGRIYPk5wUqfymFOk9MoRtLJWgOZFNv3ZsF0YlssV2bVoUIEV2WvIetFuCtpUdwWLORzIA)

With these all set up, then you can create a class which represents the base
class with mixins applied:

    
    
    ts
    
    // Compose a new class from the Sprite class,
    
    // with the Mixin Scale applier:
    
    const EightBitSprite = Scale(Sprite);
    
    ¬†
    
    const flappySprite = new EightBitSprite("Bird");
    
    flappySprite.setScale(0.8);
    
    console.log(flappySprite.scale);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHLdQd4mAMJCVEqYm4F0Ad2gyRkFgiGoQSmAEHADaALpaZAB82NZ0AGZiBJLIQnDAYCDoADwAKgBCkJjoDBgEACYwrsKiHtKJMhUQ6ErllVq4+IjoqGKIBNCgkDCw+SDI6tDVtQ3QnZgD+NAA9FvQALLIDPMwxGBcBAKo0HXok0PQSMgAbmAYW0iXtxh1D4gCTohUMh0BAdNtdnoBL50E90IgADTQDgCMQTSLQMRdaAAUVgACYWATfs9Xpg0sCQA0wQB9CCzMwARjoYK6qBmBXQMjpHKUBDExAARnD+mDdAZjLT6dxuYUrPhbGC1MNlPSZBpefyhV4NptoEMRmNoPpDEZJRy5TZ6Kk7DgdtAALSO4BiVCO+223auYjwARYsCEPwTcBQaBpP7EI16TAIFAYINTeEe6C+NB6SOYA5HcbswrQMDweBzOEKHCCZo45BqPSoMpoGNoMw5zn1jAaZllkSh8AFjgtsw+fzYyvV2tsx4YGSUWuIOqUNs4NLd+C98foIyspsyFhGAAc847AkKRhAAjUMkX+eXffX9LbQA)

## Constrained Mixins

In the above form, the mixin‚Äôs have no underlying knowledge of the class which
can make it hard to create the design you want.

To model this, we modify the original constructor type to accept a generic
argument.

    
    
    ts
    
    // This was our previous constructor:
    
    type Constructor = new (...args: any[]) => {};
    
    // Now we use a generic version which can apply a constraint on
    
    // the class which this mixin is applied to
    
    type GConstructor<T = {}> = new (...args: any[]) => T;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsEsGdQO4EN4HsCuAnUAHTBTAN2g3gGNUA7WAF03TJtUwC4AoGgTx31AGEqteo2agAvKEr4EoABQA6RUkwBzWC1BJKnANoBdAJTiAfKADeAXwDcbEKAByqGQl7pYvJKBX4pmaGVBCfExYEkpEGDJIUDItTRwcABtOTRjBOiRoShpQKlswGkheMkSUeARI6MK4UABbaAAPLNAapATE6HwAE1AmDm5eAHEBajoGJkwAHnBxcwtTCSkZBSVVdU1tfSMxU3ArIA)

This allows for creating classes which only work with constrained base
classes:

    
    
    ts
    
    type Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;
    
    type Spritable = GConstructor<Sprite>;
    
    type Loggable = GConstructor<{ print: () => void }>;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUcgHo8qABaEuxMYBKixVBIKAAFBBQDPWQuACMVK1hEVAwcPEIKKBQIYAbBNgchJExzNoh0ABp3adn59BlSOgA3BD0AEyhaJRroHX1gds76eD8+wMJzgwgaE-BoABkEXl4rrtvegEBgQhrpIsAhKxNjs9odjkA)

Then you can create mixins which only work when you have a particular base to
build on:

    
    
    ts
    
    function Jumpable<TBase extends Positionable>(Base: TBase) {
    
      return class Jumpable extends Base {
    
        jump() {
    
          // This mixin will only work if it is passed a base
    
          // class which has setPos defined because of the
    
          // Positionable constraint.
    
          this.setPos(0, 20);
    
        }
    
      };
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUc0EgoAAUEFAM9ZC4AIxUrWERUDBw8QgooFAhgYsE2ByEkTHNKiHQAGnc+gaH0GVI6ADcEPQATKFolfOgdfWAqmvp4P0bAwi2DCBp18GgAGQReXl3ag4aA5oJW3UjgIVYZ+cWVmtFAB6YFQAC0kOwmGAkPBikUADNMEhcOUkFAAFIDMCPYgAIXU0AgDkMSCWmi6ZQq1XOrEJ7SERAZEBi3nQHUw6AxqnUmmx5lxtKgJLJFKgLMo3lMACscb8pXE4qCoEQkppzHoHJEoEw9CoVFBkCoPEx8ABrKB6RFW4BWzS4jQQFZcKCVInS5Vg3kaXVJbAJKAJdRtDpdKBLCCIyLOt0QbBcTDtI02xIQT2mFVU4Dox4+Q7oLhfdgZqCJZLsdqdEqsZxjABMzikblMOVbSioQA)

## Alternative Pattern

Previous versions of this document recommended a way to write mixins where you
created both the runtime and type hierarchies separately, then merged them at
the end:

    
    
    ts
    
    // Each mixin is a traditional ES class
    
    class Jumpable {
    
      jump() {}
    
    }
    
    ¬†
    
    class Duckable {
    
      duck() {}
    
    }
    
    ¬†
    
    // Including the base
    
    class Sprite {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    // Then you create an interface which merges
    
    // the expected mixins with the same name as your base
    
    interface Sprite extends Jumpable, Duckable {}
    
    // Apply the mixins into the base class via
    
    // the JS at runtime
    
    applyMixins(Sprite, [Jumpable, Duckable]);
    
    ¬†
    
    let player = new Sprite();
    
    player.jump();
    
    console.log(player.x, player.y);
    
    ¬†
    
    // This can live anywhere in your codebase:
    
    function applyMixins(derivedCtor: any, constructors: any[]) {
    
      constructors.forEach((baseCtor) => {
    
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
    
          Object.defineProperty(
    
            derivedCtor.prototype,
    
            name,
    
            Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||
    
              Object.create(null)
    
          );
    
        });
    
      });
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigCimiAFqALbwAe8AdqPJKJqHJgCbzTwB7RjlIBlUImyZIkApOlsAUgFdqAB0wAjbHlABvAqFAArVWoAUASn0BfAnblSZoACLLEAay079h0N3cPK1t7AiIwAElGSWVeRgBzTgpdTWlCeWdRNQRoXQMjOlAAXlAABgBuPwBPYrLKh2IAFWTmKoFlCVg8TFz2ZiZc2CxEXQB3CiQqajxYeLxZYmhk0Dw6NTxkPG4aeiY2Ub4qJd1ITGnQYXPpUDblWFBU-AIBmeHdLJzdVdzGbiUzbx4AA0rkCgJCxAAgmo1NgascdgxGGwBgIkik0hInGwAG7wTDhdGgRTiHqgWDKRj8aYETAwuEAWV2yPMHz4wNAAG0VOpASC3J5AQBdSyVAg6aCgWGYKozWqMPCjUBs3JWSrS2WwAB0pnUarkQkgAh0WuwAni5g1My1dBBVu1VVFYSaEzYiEwzGw8Bxug9VXGM10TBu7XuiAE3DwjzwKAI6EpyEEzDpsKqTKRkHMkYQPu4AGFoAJYGg-SDw8i4O5C7BICXGFVOSLfEZyzAKcgi5Ategi2RKOZzNGC0XrEUAHzNoygADymmMG2gWrm0Gno0YAAVYAJ1rBoFUAHJneaDtLD7XZASFvfrSzd3vkCgDy54UcT-JToyz+fILWR9BMPBN23GY93MPwPyMbNvS2M8tQvK8qnWIFwIg59kIgqcvwXJc8BXNcgJ3PcXHmRAEDUasT3wWD4MvRCOWfawAB9GJQjCsJ-UjulVRhlGwbBLFY0AnQ-GxhNAUT6iAA)

This pattern relies less on the compiler, and more on your codebase to ensure
both runtime and type-system are correctly kept in sync.

## Constraints

The mixin pattern is supported natively inside the TypeScript compiler by code
flow analysis. There are a few cases where you can hit the edges of the native
support.

#### Decorators and Mixins
[`#4881`](https://github.com/microsoft/TypeScript/issues/4881)

You cannot use decorators to provide mixins via code flow analysis:

    
    
    ts
    
    // A decorator function which replicates the mixin pattern:
    
    const Pausable = (target: typeof Player) => {
    
      return class Pausable extends target {
    
        shouldFreeze = false;
    
      };
    
    };
    
    ¬†
    
    @Pausable
    
    class Player {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    // The Player class does not have the decorator's type merged:
    
    const player = new Player();
    
    player.shouldFreeze;
    
    Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.
    
    ¬†
    
    // The runtime aspect could be manually replicated via
    
    // type composition or interface merging.
    
    type FreezablePlayer = Player & { shouldFreeze: boolean };
    
    ¬†
    
    const playerTwo = (new Player() as unknown) as FreezablePlayer;
    
    playerTwo.shouldFreeze;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEiC1AXKAEwDMHAnHWAIKgAJsTIUyoAGYBXdEUxIS6UAHcAFkiJrQCSLFyaKkKqExrIoFEmhJlsCpkTpmNUuiqZQABWzSq2ACNcCwBeUAAKHAQAc0hMVkwAT3gSSW9cbETEAEpQEIA+UABvGlAdOOkEZSIMqhMfP0Dg0BhHdCETKNjPErKyqjUSaVwhADFdSAAvUKk8KkgAblLQAF8ltZoacAb-IMhXWvqMrIRi5eg80AAGJbLEy5uaFc36ABVzdMzEUBrsOuESMZQOgSJ41NgAG4WMwWESkciUBAAck6yQsaBikCELjcHlA+i+pzC6EgKk+J3C2SWBJOADoBkMRuNIFNFi8wO8LAhZAo0KA-vB5D9GUJQAF0dh0NI8Lh7rp9IZHKKIUhsHxTGjhShYCQqEgFEpQBJbI4EJJsER0YhorZorSaEl4KBmVMmpAvMdvmEPYTQAAyYqgBnDMYTaasAIkEjBSWrJauJR4mmIV4qEiXcIksk+im5P6gWQAaxBKnQeZMLsmbpziGpnoQqZI9MGIcriyAA)

#### Static Property Mixins
[`#17829`](https://github.com/microsoft/TypeScript/issues/17829)

More of a gotcha than a constraint. The class expression pattern creates
singletons, so they can‚Äôt be mapped at the type system to support different
variable types.

You can work around this by using functions to return your classes which
differ based on a generic:

    
    
    ts
    
    function base<T>() {
    
      class Base {
    
        static prop: T;
    
      }
    
      return Base;
    
    }
    
    ¬†
    
    function derived<T>() {
    
      class Derived extends base<T>() {
    
        static anotherProp: T;
    
      }
    
      return Derived;
    
    }
    
    ¬†
    
    class Spec extends derived<string>() {}
    
    ¬†
    
    Spec.prop; // string
    
    Spec.anotherProp; // string
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIwIYGcCmAeAKgPgAoBKRAbwChFEIAbDdRAIQ03KusXSlVgkQAOAJzgCAXIlwBuDgF8OQzFBBCkLLDPkVQkWAkQATTEJgA3TAbxFSlanQaIAIsbMXEmAB5RMYA4zRYViTsnFw8fIioYHBQABbGAAoi4pIy1PLUisqqTi7mBpoUFPbojADKApj8nt6+jEYm+djcJmAA5tbkWhVVAHTColKIAPTDYa1tFD0QvVEx8UJJgyNjLTDtQA)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Mixins.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(16\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

GM![Gleb Maksimenko
\(1\)](https://gravatar.com/avatar/2bd94d21de9c4867b0a7d66bacec2e3c?s=32&&d=blank)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

DE![Dom Eccleston
\(1\)](https://gravatar.com/avatar/0c3416c2a2642e67e122ab4f233631c0?s=32&&d=blank)

O![Oblosys
\(1\)](https://gravatar.com/avatar/c08d37535f8b1f2d7c5785cfd21067b9?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

   Was this page helpful?

# Modules - ESM/CJS Interoperability

It‚Äôs 2015, and you‚Äôre writing an ESM-to-CJS transpiler. There‚Äôs no
specification for how to do this; all you have is a specification of how ES
modules are supposed to interact with each other, knowledge of how CommonJS
modules interact with each other, and a knack for figuring things out.
Consider an exporting ES module:

    
    
    ts
    
    export const A = {};
    
    export const B = {};
    
    export default "Hello, world!";

How would you turn this into a CommonJS module? Recalling that default exports
are just named exports with special syntax, there seems to be only one choice:

    
    
    ts
    
    exports.A = {};
    
    exports.B = {};
    
    exports.default = "Hello, world!";

This is a nice analog, and it lets you implement a similar on the importing
side:

    
    
    ts
    
    import hello, { A, B } from "./module";
    
    console.log(hello, A, B);
    
    // transpiles to:
    
    const module_1 = require("./module");
    
    console.log(module_1.default, module_1.A, module_1.B);

So far, everything in CJS-world matches up one-to-one with everything in ESM-
world. Extending the equivalence above one step further, we can see that we
also have:

    
    
    ts
    
    import * as mod from "./module";
    
    console.log(mod.default, mod.A, mod.B);
    
    // transpiles to:
    
    const mod = require("./module");
    
    console.log(mod.default, mod.A, mod.B);

You might notice that in this scheme, there‚Äôs no way to write an ESM export
that produces an output where `exports` is assigned a function, class, or
primitive:

    
    
    ts
    
    // @Filename: exports-function.js
    
    module.exports = function hello() {
    
      console.log("Hello, world!");
    
    };

But existing CommonJS modules frequently take this form. How might an ESM
import, processed with our transpiler, access this module? We just established
that a namespace import (`import *`) transpiles to a plain `require` call, so
we can support an input like:

    
    
    ts
    
    import * as hello from "./exports-function";
    
    hello();
    
    // transpiles to:
    
    const hello = require("./exports-function");
    
    hello();

Our output works at runtime, but we have a compliance problem: according to
the JavaScript specification, a namespace import always resolves to a [_Module
Namespace Object_](https://tc39.es/ecma262/#sec-module-namespace-objects),
that is, an object whose members are the exports of the module. In this case,
`require` would return the function `hello`, but `import *` can never return a
function. The correspondence we assumed appears invalid.

It‚Äôs worth taking a step back here and clarifying what the _goal_ is. As soon
as modules landed in the ES2015 specification, transpilers emerged with
support for downleveling ESM to CJS, allowing users to adopt the new syntax
long before runtimes implemented support for it. There was even a sense that
writing ESM code was a good way to ‚Äúfuture-proof‚Äù new projects. For this to be
true, there needed to be a seamless migration path from executing the
transpilers‚Äô CJS output to executing the ESM input natively once runtimes
developed support for it. The goal was to find a way to downlevel ESM to CJS
that would allow any or all of those transpiled outputs to be replaced by
their true ESM inputs in a future runtime, with no observable change in
behavior.

By following the specification, it was easy enough for transpilers to find a
set of transformations that made the semantics of their transpiled CommonJS
outputs match the specified semantics of their ESM inputs (arrows represent
imports):

![A flowchart with two similar flows side-by-side. Left: ESM. Right: ESM
transpiled to CJS. In the ESM flow: "Importing module" flows to "Imported
module" through arrow labeled "specified behavior". In the ESM transpiled to
CJS flow: "Importing module" flows to "Imported module" through arrow labeled
"designed based on spec".](/d789cdf9a8f7f88a40e9e703e0698245/esm-cjs-
interop.md-1.svg)

However, CommonJS modules (written as CommonJS, not as ESM transpiled to
CommonJS) were already well-established in the Node.js ecosystem, so it was
inevitable that modules written as ESM and transpiled to CJS would start
‚Äúimporting‚Äù modules written as CommonJS. The behavior for this
interoperability, though, was not specified by ES2015, and didn‚Äôt yet exist in
any real runtime.

![A flowchart with three areas side-by-side. Left: ESM. Middle: True CJS.
Right: ESM transpiled to CJS. Left: ESM "Importing module" flows to ESM
"Imported module" through arrow labeled "specified behavior," and to True CJS
"Imported module" through dotted arrow labeled "unspecified behavior." Right:
ESM transpiled to CJS "Importing module" flows to ESM transpiled to CJS
"Imported module" through arrow labeled "designed based on spec," and to True
CJS "Imported module" through dotted arrow labeled
"‚ùìü§∑‚Äç‚ôÇÔ∏è‚ùì"](/f935787a9210481bf751b445c081f07b/esm-cjs-interop.md-2.svg)

Even if transpiler authors did nothing, a behavior would emerge from the
existing semantics between the `require` calls they emitted in transpiled code
and the `exports` defined in existing CJS modules. And to allow users to
transition seamlessly from transpiled ESM to true ESM once their runtime
supported it, that behavior would have to match the one the runtime chose to
implement.

Guessing what interop behavior runtimes would support wasn‚Äôt limited to ESM
importing ‚Äútrue CJS‚Äù modules either. Whether ESM would be able to recognize
ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to
`require` ES modules, were also unspecified. Even whether ESM imports would
use the same module resolution algorithm as CJS `require` calls was
unknowable. All these variables would have to be predicted correctly in order
to give transpiler users a seamless migration path toward native ESM.

## `allowSyntheticDefaultImports` and `esModuleInterop`

Let‚Äôs return to our specification compliance problem, where `import *`
transpiles to `require`:

    
    
    ts
    
    // Invalid according to the spec:
    
    import * as hello from "./exports-function";
    
    hello();
    
    // but the transpilation works:
    
    const hello = require("./exports-function");
    
    hello();

When TypeScript first added support for writing and transpiling ES modules,
the compiler addressed this problem by issuing an error on any namespace
import of a module whose `exports` was not a namespace-like object:

    
    
    ts
    
    import * as hello from "./exports-function";
    
    // TS2497              ^^^^^^^^^^^^^^^^^^^^
    
    // External module '"./exports-function"' resolves to a non-module entity
    
    // and cannot be imported using this construct.

The only workaround was for users to go back to using the older TypeScript
import syntax representing a CommonJS `require`:

    
    
    ts
    
    import hello = require("./exports-function");

Forcing users to revert to non-ESM syntax was essentially an admission that
‚Äúwe don‚Äôt know how or if a CJS module like `"./exports-function"` will be
accessible with ESM imports in the future, but we know it _can‚Äôt_ be with
`import *`, even though it will work at runtime in the transpilation scheme
we‚Äôre using.‚Äù It doesn‚Äôt meet the goal of allowing this file to be migrated to
real ESM without changes, but neither does the alternative of allowing the
`import *` to link to a function. This is still the behavior in TypeScript
today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.

> Unfortunately, this is a slight oversimplification‚ÄîTypeScript didn‚Äôt fully
> avoid the compliance issue with this error, because it allowed namespace
> imports of functions to work, and retain their call signatures, as long as
> the function declaration merged with a namespace declaration‚Äîeven if the
> namespace was empty. So while a module exporting a bare function was
> recognized as a ‚Äúnon-module entity‚Äù:
>  
>  
>     ts
>  
>     declare function $(selector: string): any;
>  
>     export = $; // Cannot `import *` this üëç
>
> A should-be-meaningless change allowed the invalid import to type check
> without errors:
>  
>  
>     ts
>  
>     declare namespace $ {}
>  
>     declare function $(selector: string): any;
>  
>     export = $; // Allowed to `import *` this and call it üò±

Meanwhile, other transpilers were coming up with a way to solve the same
problem. The thought process went something like this:

  1. To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don‚Äôt make sense here.
  2. Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules _always_ link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.
  3. So, a default import of a true CJS module should work just like a `require` call. But we‚Äôll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default "hello"` to `exports.default = "hello"` and have a default import of _that_ module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).
  4. When we transpile an ES module to CJS, let‚Äôs add a special extra field to the output: 
    
        ts
    
    exports.A = {};
    
    exports.B = {};
    
    exports.default = "Hello, world!";
    
    // Extra special flag!
    
    exports.__esModule = true;

that we can check for when we transpile a default import:

    
        ts
    
    // import hello from "./module";
    
    const _mod = require("./module");
    
    const hello = _mod.__esModule ? _mod.default : _mod;

The `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and
Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in
1.8 to allow the type checker to link default imports directly to the
`exports`, rather than the `exports.default`, of any module types that lacked
an `export default` declaration. The flag didn‚Äôt modify how imports or exports
were emitted, but it allowed default imports to reflect how other transpilers
would treat them. Namely, it allowed a default import to be used to resolve to
‚Äúnon-module entities,‚Äù where `import *` was an error:

    
    
    ts
    
    // Error:
    
    import * as hello from "./exports-function";
    
    // Old workaround:
    
    import hello = require("./exports-function");
    
    // New way, with `allowSyntheticDefaultImports`:
    
    import hello from "./exports-function";

This was usually enough to let Babel and Webpack users write code that already
worked in those systems without TypeScript complaining, but it was only a
partial solution, leaving a few issues unsolved:

  1. Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a _fallback_ behavior when no default export was found in the target module‚Äôs types. This created an inconsistency if the target module had an `__esModule` flag but _no_ default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can‚Äôt be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.
  2. `allowSyntheticDefaultImports` didn‚Äôt change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type: 
    
        ts
    
    // @Filename: exportEqualsObject.d.ts
    
    declare const obj: object;
    
    export = obj;
    
    // @Filename: main.ts
    
    import objDefault from "./exportEqualsObject";
    
    import * as objNamespace from "./exportEqualsObject";
    
    // This should be true at runtime, but TypeScript gives an error:
    
    objNamespace.default === objDefault;
    
    //           ^^^^^^^ Property 'default' does not exist on type 'typeof import("./exportEqualsObject")'.

  3. Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.

TypeScript introduced the `esModuleInterop` flag in 2.7, which refined the
type checking of imports to address the remaining inconsistencies between
TypeScript‚Äôs analysis and the interop behavior used in existing transpilers
and bundlers, and critically, adopted the same `__esModule`-conditional
CommonJS emit that transpilers had adopted years before. (Another new emit
helper for `import *` ensured the result was always an object, with call
signatures stripped, fully resolving the specification compliance issue that
the aforementioned ‚Äúresolves to a non-module entity‚Äù error didn‚Äôt quite
sidestep.) Finally, with the new flag enabled, TypeScript‚Äôs type checking,
TypeScript‚Äôs emit, and the rest of the transpiling and bundling ecosystem were
in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps,
plausibly adoptable by Node.

## Interop in Node.js

Node.js shipped support for ES modules unflagged in v12. Like the bundlers and
transpilers began doing years before, Node.js gave CommonJS modules a
‚Äúsynthetic default export‚Äù of their `exports` object, allowing the entire
module contents to be accessed with a default import from ESM:

    
    
    ts
    
    // @Filename: export.cjs
    
    module.exports = { hello: "world" };
    
    // @Filename: import.mjs
    
    import greeting from "./export.cjs";
    
    greeting.hello; // "world"

That‚Äôs one win for seamless migration! Unfortunately, the similarities mostly
end there.

### No `__esModule` detection (the ‚Äúdouble default‚Äù problem)

Node.js wasn‚Äôt able to respect the `__esModule` marker to vary its default
import behavior. So a transpiled module with a ‚Äúdefault export‚Äù behaves one
way when ‚Äúimported‚Äù by another transpiled module, and another way when
imported by a true ES module in Node.js:

    
    
    ts
    
    // @Filename: node_modules/dependency/index.js
    
    exports.__esModule = true;
    
    exports.default = function doSomething() { /*...*/ }
    
    // @Filename: transpile-vs-run-directly.{js/mjs}
    
    import doSomething from "dependency";
    
    // Works after transpilation, but not a function in Node.js ESM:
    
    doSomething();
    
    // Doesn't exist after trasnpilation, but works in Node.js ESM:
    
    doSomething.default();

While the transpiled default import only makes the synthetic default export if
the target module lacks an `__esModule` flag, Node.js _always_ synthesizes a
default export, creating a ‚Äúdouble default‚Äù on the transpiled module.

### Unreliable named exports

In addition to making a CommonJS module‚Äôs `exports` object available as a
default import, Node.js attempts to find properties of `exports` to make
available as named imports. This behavior matches bundlers and transpilers
when it works; however, Node.js uses [syntactic
analysis](https://github.com/nodejs/cjs-module-lexer) to synthesize named
exports before any code executes, whereas transpiled modules resolve their
named imports at runtime. The result is that imports from CJS modules that
work in transpiled modules may not work in Node.js:

    
    
    ts
    
    // @Filename: named-exports.cjs
    
    exports.hello = "world";
    
    exports["worl" + "d"] = "hello";
    
    // @Filename: transpile-vs-run-directly.{js/mjs}
    
    import { hello, world } from "./named-exports.cjs";
    
    // `hello` works, but `world` is missing in Node.js üí•
    
    import mod from "./named-exports.cjs";
    
    mod.world;
    
    // Accessing properties from the default always works ‚úÖ

### Cannot `require` a true ES module

True CommonJS modules can `require` an ESM-transpiled-to-CJS module, since
they‚Äôre both CommonJS at runtime. But in Node.js, `require` crashes if it
resolves to an ES module. This means published libraries cannot migrate from
transpiled modules to true ESM without breaking their CommonJS (true or
transpiled) consumers:

    
    
    ts
    
    // @Filename: node_modules/dependency/index.js
    
    export function doSomething() { /* ... */ }
    
    // @Filename: dependent.js
    
    import { doSomething } from "dependency";
    
    // ‚úÖ Works if dependent and dependency are both transpiled
    
    // ‚úÖ Works if dependent and dependency are both true ESM
    
    // ‚úÖ Works if dependent is true ESM and dependency is transpiled
    
    // üí• Crashes if dependent is transpiled and dependency is true ESM

### Different module resolution algorithms

Node.js introduced a new module resolution algorithm for resolving ESM imports
that differed significantly from the long-standing algorithm for resolving
`require` calls. While not directly related to interop between CJS and ES
modules, this difference was one more reason why a seamless migration from
transpiled modules to true ESM might not be possible:

    
    
    ts
    
    // @Filename: add.js
    
    export function add(a, b) {
    
      return a + b;
    
    }
    
    // @Filename: math.js
    
    export * from "./add";
    
    //            ^^^^^^^
    
    // Works when transpiled to CJS,
    
    // but would have to be "./add.js"
    
    // in Node.js ESM.

## Conclusions

Clearly, a seamless migration from transpiled modules to ESM isn‚Äôt possible,
at least in Node.js. Where does this leave us?

### Setting the right `module` compiler option is critical

Since interoperability rules differ between hosts, TypeScript can‚Äôt offer
correct checking behavior unless it understands what kind of module is
represented by each file it sees, and what set of rules to apply to them. This
is the purpose of the `module` compiler option. (In particular, code that is
intended to run in Node.js is subject to stricter rules than code that will be
processed by a bundler. The compiler‚Äôs output is not checked for Node.js
compatibility unless `module` is set to `node16` or `nodenext`.)

### Applications with CommonJS code should always enable `esModuleInterop`

In a TypeScript _application_ (as opposed to a library that others may
consume) where `tsc` is used to emit JavaScript files, whether
`esModuleInterop` is enabled doesn‚Äôt have major consequences. The way you
write imports for certain kinds of modules will change, but TypeScript‚Äôs
checking and emit are in sync, so error-free code should be safe to run in
either mode. The downside of leaving `esModuleInterop` disabled in this case
is that it allows you to write JavaScript code with semantics that clearly
violate the ECMAScript specification, confusing intuitions about namespace
imports and making it harder to migrate to running ES modules in the future.

In an application that gets processed by a third-party transpiler or bundler,
on the other hand, enabling `esModuleInterop` is more important. All major
bundlers and transpilers use an `esModuleInterop`-like emit strategy, so
TypeScript needs to adjust its checking to match. (The compiler always reasons
about what will happen in the JavaScript files that `tsc` would emit, so even
if another tool is being used in place of `tsc`, emit-affecting compiler
options should still be set to match the output of that tool as closely as
possible.)

`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It
changes the compiler‚Äôs checking behavior without changing the code emitted by
`tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the
checking changes it introduces are an incomplete version of the ones
introduced by `esModuleInterop`. Even if `tsc` isn‚Äôt being used for emit, it‚Äôs
better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.

Some people object to the inclusion of the `__importDefault` and
`__importStar` helper functions included in `tsc`‚Äôs JavaScript output when
`esModuleInterop` is enabled, either because it marginally increases the
output size on disk or because the interop algorithm employed by the helpers
seems to misrepresent Node.js‚Äôs interop behavior by checking for `__esModule`,
leading to the hazards discussed earlier. Both of these objections can be
addressed, at least partially, without accepting the flawed checking behavior
exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler
option can be used to import the helper functions from `tslib` rather than
inlining them into each file that needs them. To discuss the second objection,
let‚Äôs look at a final example:

    
    
    ts
    
    // @Filename: node_modules/transpiled-dependency/index.js
    
    exports.__esModule = true;
    
    exports.default = function doSomething() { /* ... */ };
    
    exports.something = "something";
    
    // @Filename: node_modules/true-cjs-dependency/index.js
    
    module.exports = function doSomethingElse() { /* ... */ };
    
    // @Filename: src/sayHello.ts
    
    export default function sayHello() { /* ... */ }
    
    export const hello = "hello";
    
    // @Filename: src/main.ts
    
    import doSomething from "transpiled-dependency";
    
    import doSomethingElse from "true-cjs-dependency";
    
    import sayHello from "./sayHello.js";

Assume we‚Äôre compiling `src` to CommonJS for use in Node.js. Without
`allowSyntheticDefaultImports` or `esModuleInterop`, the import of
`doSomethingElse` from `"true-cjs-dependency"` is an error, and the others are
not. To fix the error without changing any compiler options, you could change
the import to `import doSomethingElse = require("true-cjs-dependency")`.
However, depending on how the types for the module (not shown) are written,
you may also be able to write and call a namespace import, which would be a
language-level specification violation. With `esModuleInterop`, none of the
imports shown are errors (and all are callable), but the invalid namespace
import would be caught.

What would change if we decided to migrate `src` to true ESM in Node.js (say,
add `"type": "module"` to our root package.json)? The first import,
`doSomething` from `"transpiled-dependency"`, would no longer be callable‚Äîit
exhibits the ‚Äúdouble default‚Äù problem, where we‚Äôd have to call
`doSomething.default()` rather than `doSomething()`. (TypeScript understands
and catches this under `--module node16` and `nodenext`.) But notably, the
_second_ import of `doSomethingElse`, which needed `esModuleInterop` to work
when compiling to CommonJS, works fine in true ESM.

If there‚Äôs something to complain about here, it‚Äôs not what `esModuleInterop`
does with the second import. The changes it makes, both allowing the default
import and preventing callable namespace imports, are exactly in line with
Node.js‚Äôs real ESM/CJS interop strategy, and made migration to real ESM
easier. The problem, if there is one, is that `esModuleInterop` seems to fail
at giving us a seamless migration path for the _first_ import. But this
problem was not introduced by enabling `esModuleInterop`; the first import was
completely unaffected by it. Unfortunately, this problem cannot be solved
without breaking the semantic contract between `main.ts` and `sayHello.ts`,
because the CommonJS output of `sayHello.ts` looks structurally identical to
`transpiled-dependency/index.js`. If `esModuleInterop` changed the way the
transpiled import of `doSomething` works to be identical to the way it would
work in Node.js ESM, it would change the behavior of the `sayHello` import in
the same way, making the input code violate ESM semantics (thus still
preventing the `src` directory from being migrated to ESM without changes).

As we‚Äôve seen, there is no seamless migration path from transpiled modules to
true ESM. But `esModuleInterop` is one step in the right direction. For those
who still prefer to minimize module syntax transformations and the inclusion
of the import helper functions, enabling `verbatimModuleSyntax` is a better
choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that
the `import mod = require("mod")` and `export = ns` syntax be used in
CommonJS-emitting files, avoiding all the kinds of import ambiguity we‚Äôve
discussed, at the cost of ease of migration to true ESM.

### Library code needs special considerations

Libraries that ship as CommonJS should avoid using default exports, since the
way those transpiled exports can be accessed varies between different tools
and runtimes, and some of those ways will look confusing to users. A default
export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the
default property of a default import:

    
    
    js
    
    import pkg from "pkg";
    
    pkg.default();

in most bundlers or transpiled ESM as the default import itself:

    
    
    js
    
    import pkg from "pkg";
    
    pkg();

and in vanilla CommonJS as the default property of a `require` call:

    
    
    js
    
    const pkg = require("pkg");
    
    pkg.default();

Users will detect a misconfigured module smell if they have to access the
`.default` property of a default import, and if they‚Äôre trying to write code
that will run both in Node.js and a bundler, they might be stuck. Some third-
party TypeScript transpilers expose options that change the way default
exports are emitted to mitigate this difference, but they don‚Äôt produce their
own declaration (`.d.ts`) files, so that creates a mismatch between the
runtime behavior and the type checking, further confusing and frustrating
users. Instead of using default exports, libraries that need to ship as
CommonJS should use `export =` for modules that have a single main export, or
named exports for modules that have multiple exports:

    
    
    diff
    
    - export default function doSomething() { /* ... */ }
    
    + export = function doSomething() { /* ... */ }

Libraries (that ship declaration files) should also take extra care to ensure
the types they write are error-free under a wide range of compiler options.
For example, it‚Äôs possible to write one interface that extends another in such
a way that it only compiles successfully when `strictNullChecks` is disabled.
If a library were to publish types like that, it would force all their users
to disable `strictNullChecks` too. `esModuleInterop` can allow type
declarations to contain similarly ‚Äúinfectious‚Äù default imports:

    
    
    ts
    
    // @Filename: /node_modules/dependency/index.d.ts
    
    import express from "express";
    
    declare function doSomething(req: express.Request): any;
    
    export = doSomething;

Suppose this default import _only_ works with `esModuleInterop` enabled, and
causes an error when a user without that option references this file. The user
should _probably_ enable `esModuleInterop` anyway, but it‚Äôs generally seen as
bad form for libraries to make their configurations infectious like this. It
would be much better for the library to ship a declaration file like:

    
    
    ts
    
    import express = require("express");
    
    // ...

Examples like this have led to conventional wisdom that says libraries should
_not_ enable `esModuleInterop`. This advice is a reasonable start, but we‚Äôve
looked at examples where the type of a namespace import changes, potentially
_introducing_ an error, when enabling `esModuleInterop`. So whether libraries
compile with or without `esModuleInterop`, they run the risk of writing syntax
that makes their choice infectious.

Library authors who want to go above and beyond to ensure maximum
compatibility would do well to validate their declaration files against a
matrix of compiler options. But using `verbatimModuleSyntax` completely
sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files
to use CommonJS-style import and export syntax. Additionally, since
`esModuleInterop` only affects CommonJS, as more libraries move to ESM-only
publishing over time, the relevance of this issue will decline.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/appendices/ESM-CJS-Interop.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(8\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

DR![Diego Rodrigues
\(1\)](https://gravatar.com/avatar/03c473a5dfafb916c7573d78f1912fba?s=32&&d=blank)

K![KnorpelSenf
\(1\)](https://gravatar.com/avatar/eea0970bba895552ca02103604d19eb0?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules - Choosing Compiler Options

## I‚Äôm writing an app

A single tsconfig.json can only represent a single environment, both in terms
of what globals are available and in terms of how modules behave. If your app
contains server code, DOM code, web worker code, test code, and code to be
shared by all of those, each of those should have its own tsconfig.json,
connected with [project
references](https://www.typescriptlang.org/docs/handbook/project-
references.html#handbook-content). Then, use this guide once for each
tsconfig.json. For library-like projects within an app, especially ones that
need to run in multiple runtime environments, use the ‚ÄúI‚Äôm writing a library‚Äù
section.

### I‚Äôm using a bundler

In addition to adopting the following settings, it‚Äôs also recommended _not_ to
set `{ "type": "module" }` or use `.mts` files in bundler projects for now.
[Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-
default-exports-for-cjs-modules) adopt different ESM/CJS interop behavior
under these circumstances, which TypeScript cannot currently analyze with
`"moduleResolution": "bundler"`. See [issue
#54102](https://github.com/microsoft/TypeScript/issues/54102) for more
information.

    
    
    json
    
    {
    
      "compilerOptions": {
    
        // This is not a complete template; it only
    
        // shows relevant module-related settings.
    
        // Be sure to set other important options
    
        // like `target`, `lib`, and `strict`.
    
        // Required
    
        "module": "esnext",
    
        "moduleResolution": "bundler",
    
        "esModuleInterop": true,
    
        // Consult your bundler‚Äôs documentation
    
        "customConditions": ["module"],
    
        // Recommended
    
        "noEmit": true, // or `emitDeclarationOnly`
    
        "allowImportingTsExtensions": true,
    
        "allowArbitraryExtensions": true,
    
        "verbatimModuleSyntax": true, // or `isolatedModules`
    
      }
    
    }

### I‚Äôm compiling and running the outputs in Node.js

Remember to set `"type": "module"` or use `.mts` files if you intend to emit
ES modules.

    
    
    json
    
    {
    
      "compilerOptions": {
    
        // This is not a complete template; it only
    
        // shows relevant module-related settings.
    
        // Be sure to set other important options
    
        // like `target`, `lib`, and `strict`.
    
        // Required
    
        "module": "nodenext",
    
        // Implied by `"module": "nodenext"`:
    
        // "moduleResolution": "nodenext",
    
        // "esModuleInterop": true,
    
        // "target": "esnext",
    
        // Recommended
    
        "verbatimModuleSyntax": true,
    
      }
    
    }

### I‚Äôm using ts-node

ts-node attempts to be compatible with the same code and the same
tsconfig.json settings that can be used to compile and run the JS outputs in
Node.js. Refer to [ts-node documentation](https://typestrong.org/ts-node/) for
more details.

### I‚Äôm using tsx

Whereas ts-node makes minimal modifications to Node.js‚Äôs module system by
default, [tsx](https://github.com/esbuild-kit/tsx) behaves more like a
bundler, allowing extensionless/index module specifiers and arbitrary mixing
of ESM and CJS. Use the same settings for tsx as you would for a bundler.

### I‚Äôm writing ES modules for the browser, with no bundler or module compiler

TypeScript does not currently have options dedicated to this scenario, but you
can approximate them by using a combination of the `nodenext` ESM module
resolution algorithm and `paths` as a substitute for URL and import map
support.

    
    
    json
    
    // tsconfig.json
    
    {
    
      "compilerOptions": {
    
        // This is not a complete template; it only
    
        // shows relevant module-related settings.
    
        // Be sure to set other important options
    
        // like `target`, `lib`, and `strict`.
    
        // Combined with `"type": "module"` in a local package.json,
    
        // this enforces including file extensions on relative path imports.
    
        "module": "nodenext",
    
        "paths": {
    
          // Point TS to local types for remote URLs:
    
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"],
    
          // Optional: point bare specifier imports to an empty file
    
          // to prohibit importing from node_modules specifiers not listed here:
    
          "*": ["./empty-file.ts"]
    
        }
    
      }
    
    }

This setup allows explicitly listed HTTPS imports to use locally-installed
type declaration files, while erroring on imports that would normally resolve
in node_modules:

    
    
    ts
    
    import {} from "lodash";
    
    //             ^^^^^^^^
    
    // File '/project/empty-file.ts' is not a module. ts(2306)

Alternatively, you can use [import maps](https://github.com/WICG/import-maps)
to explicitly map a list of bare specifiers to URLs in the browser, while
relying on `nodenext`‚Äôs default node_modules lookups, or on `paths`, to direct
TypeScript to type declaration files for those bare specifier imports:

    
    
    html
    
    <script type="importmap">
    
    {
    
      "imports": {
    
        "lodash": "https://esm.sh/lodash@4.17.21"
    
      }
    
    }
    
    </script>
    
    
    ts
    
    import {} from "lodash";
    
    // Browser: https://esm.sh/lodash@4.17.21
    
    // TypeScript: ./node_modules/@types/lodash/index.d.ts

## I‚Äôm writing a library

Choosing compilation settings as a library author is a fundamentally different
process from choosing settings as an app author. When writing an app, settings
are chosen that reflect the runtime environment or bundler‚Äîtypically a single
entity with known behavior. When writing a library, you would ideally check
your code under _all possible_ library consumer compilation settings. Since
this is impractical, you can instead use the strictest possible settings,
since satisfying those tends to satisfy all others.

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "module": "node16",
    
        "target": "es2020", // set to the *lowest* target you support
    
        "strict": true,
    
        "verbatimModuleSyntax": true,
    
        "declaration": true,
    
        "sourceMap": true,
    
        "declarationMap": true
    
      }
    
    }

Let‚Äôs examine why we picked each of these settings:

  * **`module: "node16"`**. When a codebase is compatible with Node.js‚Äôs module system, it almost always works in bundlers as well. If you‚Äôre using a third-party emitter to emit ESM outputs, ensure that you set `"type": "module"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let‚Äôs look at what would happen if a library were to compile with `"moduleResolution": "bundler"`:
    
        ts
    
    export * from "./utils";

Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine
with this code, so `"moduleResolution": "bundler"` doesn‚Äôt complain. Compiled
with `"module": "esnext"`, the output JavaScript for this export statement
will look exactly the same as the input. If that JavaScript were published to
npm, it would be usable by projects that use a bundler, but it would cause an
error when run in Node.js:

    
        Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js
    
    Did you mean to import ./utils.js?

On the other hand, if we had written:

    
        ts
    
    export * from "./utils.js";

This would produce output that works both in Node.js _and_ in bundlers.

In short, `"moduleResolution": "bundler"` is infectious, allowing code that
only works in bundlers to be produced. Likewise, `"moduleResolution":
"nodenext"` is only checking that the output works in Node.js, but in most
cases, module code that works in Node.js will work in other runtimes and in
bundlers.

  * **`target: "es2020"`**. Setting this value to the _lowest_ ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don‚Äôt access globals that may not be available in older environments.

  * **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:
    
        ts
    
    export interface Super {
    
      foo: string;
    
    }
    
    export interface Sub extends Super {
    
      foo: string | undefined;
    
    }

is only an error under `strictNullChecks`. On the other hand, it‚Äôs very
difficult to write code that errors only when `strict` is _disabled_ , so it‚Äôs
highly recommended for libraries to compile with `strict`.

  * **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user‚Äôs value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it‚Äôs also possible to write imports that only work _without_ `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.1 Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](/docs/handbook/modules/appendices/esm-cjs-interop.html#library-code-needs-special-considerations) for more details.

  * **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.

  * **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it‚Äôs up to you whether to include them.

### Considerations for bundling libraries

If you‚Äôre using a bundler to emit your library, then all your (non-
externalized) imports will be processed by the bundler with known behavior,
not by your users‚Äô unknowable environments. In this case, you can use
`"module": "esnext"` and `"moduleResolution": "bundler"`, but only with two
caveats:

  1. TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it‚Äôs common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user‚Äôs environment. To model this in TypeScript, you would want to process bundled imports with `"moduleResolution": "bundler"` and externalized imports with `"moduleResolution": "nodenext"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `"moduleResolution": "bundler"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `"moduleResolution": "nodenext"` may impose overly strict requirements on bundled imports.

  2. You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](/docs/handbook/modules/theory.html#the-role-of-declaration-files): every declaration file represents exactly one JavaScript file. If you use `"moduleResolution": "bundler"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `"module": "nodenext"`. For example, an input file like:
    
        ts
    
    import { Component } from "./extensionless-relative-import";

will have its import erased by the JS bundler, but produce a declaration file
with an identical import statement. That import statement, however, will
contain an invalid module specifier in Node.js, since it‚Äôs missing a file
extension. For Node.js users, TypeScript will error on the declaration file
and infect types referencing `Component` with `any`, assuming the dependency
will crash at runtime.

If your TypeScript bundler does not produce bundled declaration files, use
`"moduleResolution": "nodenext"` to ensure that the imports preserved in your
declaration files will be compatible with end-users‚Äô TypeScript settings. Even
better, consider not bundling your library.

### Notes on dual-emit solutions

A single TypeScript compilation (whether emitting or just type checking)
assumes that each input file will only produce one output file. Even if `tsc`
isn‚Äôt emitting anything, the type checking it performs on imported names rely
on knowledge about how the output file will behave at runtime, based on the
module- and emit-related options set in the tsconfig.json. While third-party
emitters are generally safe to use in combination with `tsc` type checking as
long as `tsc` can be configured to understand what the other emitter will
emit, any solution that emits two different sets of outputs with different
module formats while only type checking once leaves (at least) one of the
outputs unchecked. Because external dependencies may expose different APIs to
CommonJS and ESM consumers, there‚Äôs no configuration you can use to guarantee
in a single compilation that both outputs will be type-safe. In practice, most
dependencies follow best practices and dual-emit outputs work. Running tests
and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli) against
all output bundles before publishing significantly reduces the chance of a
serious problem going unnoticed.

* * *

  1. `verbatimModuleSyntax` can only work when the JS emitter emits the same module kind as `tsc` would given the tsconfig.json, source file extension, and package.json `"type"`. The option works by enforcing that the `import`/`require` written is identical to the `import`/`require` emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with `verbatimModuleSyntax`, since its whole purpose is to prevent you from writing `import` anywhere that a `require` would be emitted. `verbatimModuleSyntax` can also be defeated by configuring a third-party emitter to emit a different module kind than `tsc` would‚Äîfor example, by setting `"module": "esnext"` in tsconfig.json while configuring Babel to emit CommonJS.‚Ü©

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/guides/Choosing Compiler Options.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules - Introduction

This document is divided into four sections:

  1. The first section develops the [**theory**](/docs/handbook/modules/theory.html) behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.
  2. The [**guides**](/docs/handbook/modules/guides/choosing-compiler-options.html) show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.
  3. The [**reference**](/docs/handbook/modules/reference.html) section provides a more detailed look at the syntaxes and configurations presented in previous sections.
  4. The [**appendices**](/docs/handbook/modules/appendices/esm-cjs-interop.html) cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/Introduction.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules - Reference

## Module syntax

The TypeScript compiler recognizes standard [ECMAScript module
syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
in TypeScript and JavaScript files and many forms of [CommonJS
syntax](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-
files.html#commonjs-modules-are-supported) in JavaScript files.

There are also a few TypeScript-specific syntax extensions that can be used in
TypeScript files and/or JSDoc comments.

### Importing and exporting TypeScript-specific declarations

Type aliases, interfaces, enums, and namespaces can be exported from a module
with an `export` modifier, like any standard JavaScript declaration:

    
    
    ts
    
    // Standard JavaScript syntax...
    
    export function f() {}
    
    // ...extended to type declarations
    
    export type SomeType = /* ... */;
    
    export interface SomeInterface { /* ... */ }

They can also be referenced in named exports, even alongside references to
standard JavaScript declarations:

    
    
    ts
    
    export { f, SomeType, SomeInterface };

Exported types (and other TypeScript-specific declarations) can be imported
with standard ECMAScript imports:

    
    
    ts
    
    import { f, SomeType, SomeInterface } from "./module.js";

When using namespace imports or exports, exported types are available on the
namespace when referenced in a type position:

    
    
    ts
    
    import * as mod from "./module.js";
    
    mod.f();
    
    mod.SomeType; // Property 'SomeType' does not exist on type 'typeof import("./module.js")'
    
    let x: mod.SomeType; // Ok

### Type-only imports and exports

When emitting imports and exports to JavaScript, by default, TypeScript
automatically elides (does not emit) imports that are only used in type
positions and exports that only refer to types. Type-only imports and exports
can be used to force this behavior and make the elision explicit. Import
declarations written with `import type`, export declarations written with
`export type { ... }`, and import or export specifiers prefixed with the
`type` keyword are all guaranteed to be elided from the output JavaScript.

    
    
    ts
    
    // @Filename: main.ts
    
    import { f, type SomeInterface } from "./module.js";
    
    import type { SomeType } from "./module.js";
    
    class C implements SomeInterface {
    
      constructor(p: SomeType) {
    
        f();
    
      }
    
    }
    
    export type { C };
    
    // @Filename: main.js
    
    import { f } from "./module.js";
    
    class C {
    
      constructor(p) {
    
        f();
    
      }
    
    }

Even values can be imported with `import type`, but since they won‚Äôt exist in
the output JavaScript, they can only be used in non-emitting positions:

    
    
    ts
    
    import type { f } from "./module.js";
    
    f(); // 'f' cannot be used as a value because it was imported using 'import type'
    
    let otherFunction: typeof f = () => {}; // Ok

A type-only import declaration may not declare both a default import and named
bindings, since it appears ambiguous whether `type` applies to the default
import or to the entire import declaration. Instead, split the import
declaration into two, or use `default` as a named binding:

    
    
    ts
    
    import type fs, { BigIntOptions } from "fs";
    
    //          ^^^^^^^^^^^^^^^^^^^^^
    
    // Error: A type-only import can specify a default import or named bindings, but not both.
    
    import type { default as fs, BigIntOptions } from "fs"; // Ok

### `import()` types

TypeScript provides a type syntax similar to JavaScript‚Äôs dynamic `import` for
referencing the type of a module without writing an import declaration:

    
    
    ts
    
    // Access an exported type:
    
    type WriteFileOptions = import("fs").WriteFileOptions;
    
    // Access the type of an exported value:
    
    type WriteFileFunction = typeof import("fs").writeFile;

This is especially useful in JSDoc comments in JavaScript files, where it‚Äôs
not possible to import types otherwise:

    
    
    ts
    
    /** @type {import("webpack").Configuration} */
    
    module.exports = {
    
      // ...
    
    }

### `export =` and `import = require()`

When emitting CommonJS modules, TypeScript files can use a direct analog of
`module.exports = ...` and `const mod = require("...")` JavaScript syntax:

    
    
    ts
    
    // @Filename: main.ts
    
    import fs = require("fs");
    
    export = fs.readFileSync("...");
    
    // @Filename: main.js
    
    "use strict";
    
    const fs = require("fs");
    
    module.exports = fs.readFileSync("...");

This syntax was used over its JavaScript counterparts since variable
declarations and property assignments could not refer to TypeScript types,
whereas special TypeScript syntax could:

    
    
    ts
    
    // @Filename: a.ts
    
    interface Options { /* ... */ }
    
    module.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.
    
    export = Options; // Ok
    
    // @Filename: b.ts
    
    const Options = require("./a");
    
    const options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.
    
    // @Filename: c.ts
    
    import Options = require("./a");
    
    const options: Options = { /* ... */ }; // Ok

### Ambient modules

TypeScript supports a syntax in script (non-module) files for declaring a
module that exists in the runtime but has no corresponding file. These
_ambient modules_ usually represent runtime-provided modules, like `"fs"` or
`"path"` in Node.js:

    
    
    ts
    
    declare module "path" {
    
      export function normalize(p: string): string;
    
      export function join(...paths: any[]): string;
    
      export var sep: string;
    
    }

Once an ambient module is loaded into a TypeScript program, TypeScript will
recognize imports of the declared module in other files:

    
    
    ts
    
    // üëá Ensure the ambient module is loaded -
    
    //    may be unnecessary if path.d.ts is included
    
    //    by the project tsconfig.json somehow.
    
    /// <reference path="path.d.ts" />
    
    import { normalize, join } from "path";

Ambient module declarations are easy to confuse with [module
augmentations](https://www.typescriptlang.org/docs/handbook/declaration-
merging.html#module-augmentation) since they use identical syntax. This module
declaration syntax becomes a module augmentation when the file is a module,
meaning it has a top-level `import` or `export` statement (or is affected by
[`--moduleDetection force` or
`auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)):

    
    
    ts
    
    // Not an ambient module declaration anymore!
    
    export {};
    
    declare module "path" {
    
      export function normalize(p: string): string;
    
      export function join(...paths: any[]): string;
    
      export var sep: string;
    
    }

Ambient modules may use imports inside the module declaration body to refer to
other modules without turning the containing file into a module (which would
make the ambient module declaration a module augmentation):

    
    
    ts
    
    declare module "m" {
    
      // Moving this outside "m" would totally change the meaning of the file!
    
      import { SomeType } from "other";
    
      export function f(): SomeType;
    
    }

A _pattern_ ambient module contains a single `*` wildcard character in its
name, matching zero or more characters in import paths. This can be useful for
declaring modules provided by custom loaders:

    
    
    ts
    
    declare module "*.html" {
    
      const content: string;
    
      export default content;
    
    }

## The `module` compiler option

This section discusses the details of each `module` compiler option value. See
the [_Module output format_](/docs/handbook/modules/theory.html#the-module-
output-format) theory section for more background on what the option is and
how it fits into the overall compilation process. In brief, the `module`
compiler option was historically only used to control the output module format
of emitted JavaScript files. The more recent `node16` and `nodenext` values,
however, describe a wide range of characteristics of Node.js‚Äôs module system,
including what module formats are supported, how the module format of each
file is determined, and how different module formats interoperate.

### `node16`, `nodenext`

Node.js supports both CommonJS and ECMAScript modules, with specific rules for
which format each file can be and how the two formats are allowed to
interoperate. `node16` and `nodenext` describe the full range of behavior for
Node.js‚Äôs dual-format module system, and **emit files in either CommonJS or
ESM format**. This is different from every other `module` option, which are
runtime-agnostic and force all output files into a single format, leaving it
to the user to ensure the output is valid for their runtime.

> A common misconception is that `node16` and `nodenext` only emit ES modules.
> In reality, `node16` and `nodenext` describe versions of Node.js that
> _support_ ES modules, not just projects that _use_ ES modules. Both ESM and
> CommonJS emit are supported, based on the detected module format of each
> file. Because `node16` and `nodenext` are the only `module` options that
> reflect the complexities of Node.js‚Äôs dual module system, they are the
> **only correct`module` options** for all apps and libraries that are
> intended to run in Node.js v12 or later, whether they use ES modules or not.

`node16` and `nodenext` are currently identical, with the exception that they
imply different `target` option values. If Node.js makes significant changes
to its module system in the future, `node16` will be frozen while `nodenext`
will be updated to reflect the new behavior.

#### Module format detection

  * `.mts`/`.mjs`/`.d.mts` files are always ES modules.
  * `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.
  * `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `"type": "module"`, otherwise CommonJS modules.

The detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files
determines the module format of the emitted JavaScript files. So, for example,
a project consisting entirely of `.ts` files will emit all CommonJS modules by
default under `--module nodenext`, and can be made to emit all ES modules by
adding `"type": "module"` to the project package.json.

#### Interoperability rules

  * **When an ES module references a CommonJS module:**
    * The `module.exports` of the CommonJS module is available as a default import to the ES module.
    * Properties (other than `default`) of the CommonJS module‚Äôs `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer). TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript‚Äôs ability to catch named imports that may crash at runtime. See [#54018](https://github.com/microsoft/TypeScript/issues/54018) for more details.
  * **When a CommonJS module references an ES module:**
    * `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are detected to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.
    * A dynamic `import()` call may be used to import an ES module. It returns a Promise of the module‚Äôs Module Namespace Object (what you‚Äôd get from `import * as ns from "./module.js"` from another ES module).

#### Emit

The emit format of each file is determined by the detected module format of
each file. ESM emit is similar to `--module esnext`, but has a special
transformation for `import x = require("...")`, which is not allowed in
`--module esnext`:

    
    
    ts
    
    // @Filename: main.ts
    
    import x = require("mod");
    
    
    js
    
    // @Filename: main.js
    
    import { createRequire as _createRequire } from "module";
    
    const __require = _createRequire(import.meta.url);
    
    const x = __require("mod");

CommonJS emit is similar to `--module commonjs`, but dynamic `import()` calls
are not transformed. Emit here is shown with `esModuleInterop` enabled:

    
    
    ts
    
    // @Filename: main.ts
    
    import fs from "fs"; // transformed
    
    const dynamic = import("mod"); // not transformed
    
    
    js
    
    // @Filename: main.js
    
    "use strict";
    
    var __importDefault = (this && this.__importDefault) || function (mod) {
    
        return (mod && mod.__esModule) ? mod : { "default": mod };
    
    };
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const fs_1 = __importDefault(require("fs")); // transformed
    
    const dynamic = import("mod"); // not transformed

#### Implied and enforced options

  * `--module nodenext` or `node16` implies and enforces the `moduleResolution` with the same name.
  * `--module nodenext` implies `--target esnext`.
  * `--module node16` implies `--target es2022`.
  * `--module nodenext` or `node16` implies `--esModuleInterop`.

#### Summary

  * `node16` and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.
  * `node16` and `nodenext` emit files in either CommonJS or ESM format, based on the detected module format of each file.
  * Node.js‚Äôs interoperability rules between ESM and CJS are reflected in type checking.
  * ESM emit transforms `import x = require("...")` to a `require` call constructed from a `createRequire` import.
  * CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.

### `preserve`

In `--module preserve`
([added](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-
bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and
exports written in input files are preserved in the output, and CommonJS-style
`import x = require("...")` and `export = ...` statements are emitted as
CommonJS `require` and `module.exports`. In other words, the format of each
individual import or export statement is preserved, rather than being coerced
into a single format for the whole compilation (or even a whole file).

While it‚Äôs rare to need to mix imports and require calls in the same file,
this `module` mode best reflects the capabilities of most modern bundlers, as
well as the Bun runtime.

> Why care about TypeScript‚Äôs `module` emit with a bundler or with Bun, where
> you‚Äôre likely also setting `noEmit`? TypeScript‚Äôs type checking and module
> resolution behavior are affected by the module format that it _would_ emit.
> Setting `module` gives TypeScript information about how your bundler or
> runtime will process imports and exports, which ensures that the types you
> see on imported values accurately reflect what will happen at runtime or
> after bundling. See `--moduleResolution bundler` for more discussion.

#### Examples

    
    
    ts
    
    import x, { y, z } from "mod";
    
    import mod = require("mod");
    
    const dynamic = import("mod");
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    import x, { y, z } from "mod";
    
    const mod = require("mod");
    
    const dynamic = import("mod");
    
    export const e1 = 0;
    
    export default "default export";

#### Implied and enforced options

  * `--module preserve` implies `--moduleResolution bundler`.
  * `--module preserve` implies `--esModuleInterop`.

> The option `--esModuleInterop` is enabled by default in `--module preserve`
> only for its [type
> checking](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-
> cjs-interop.html#allowsyntheticdefaultimports-and-esmoduleinterop) behavior.
> Since imports never transform into require calls in `--module preserve`,
> `--esModuleInterop` does not affect the emitted JavaScript.

### `es2015`, `es2020`, `es2022`, `esnext`

#### Summary

  * Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.
  * Do not use for Node.js. Use `node16` or `nodenext` with `"type": "module"` in package.json to emit ES modules for Node.js.
  * `import mod = require("mod")` is not allowed in non-declaration files.
  * `es2020` adds support for `import.meta` properties.
  * `es2022` adds support for top-level `await`.
  * `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.
  * Emitted files are ES modules, but dependencies may be any format.

#### Examples

    
    
    ts
    
    // @Filename: main.ts
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    // @Filename: main.js
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";

### `commonjs`

#### Summary

  * You probably shouldn‚Äôt use this. Use `node16` or `nodenext` to emit CommonJS modules for Node.js.
  * Emitted files are CommonJS modules, but dependencies may be any format.
  * Dynamic `import()` is transformed to a Promise of a `require()` call.
  * `esModuleInterop` affects the output code for default and namespace imports.

#### Examples

> Output is shown with `esModuleInterop: false`.
    
    
    ts
    
    // @Filename: main.ts
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    // @Filename: main.js
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.e1 = void 0;
    
    const mod_1 = require("mod");
    
    const mod = require("mod");
    
    const dynamic = Promise.resolve().then(() => require("mod"));
    
    console.log(mod_1.default, mod_1.y, mod_1.z, mod);
    
    exports.e1 = 0;
    
    exports.default = "default export";
    
    
    ts
    
    // @Filename: main.ts
    
    import mod = require("mod");
    
    console.log(mod);
    
    export = {
    
        p1: true,
    
        p2: false
    
    };
    
    
    js
    
    // @Filename: main.js
    
    "use strict";
    
    const mod = require("mod");
    
    console.log(mod);
    
    module.exports = {
    
        p1: true,
    
        p2: false
    
    };

### `system`

#### Summary

  * Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs).

#### Examples

    
    
    ts
    
    // @Filename: main.ts
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    // @Filename: main.js
    
    System.register(["mod"], function (exports_1, context_1) {
    
        "use strict";
    
        var mod_1, mod, dynamic, e1;
    
        var __moduleName = context_1 && context_1.id;
    
        return {
    
            setters: [
    
                function (mod_1_1) {
    
                    mod_1 = mod_1_1;
    
                    mod = mod_1_1;
    
                }
    
            ],
    
            execute: function () {
    
                dynamic = context_1.import("mod");
    
                console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
    
                exports_1("e1", e1 = 0);
    
                exports_1("default", "default export");
    
            }
    
        };
    
    });

### `amd`

#### Summary

  * Designed for AMD loaders like RequireJS.
  * You probably shouldn‚Äôt use this. Use a bundler instead.
  * Emitted files are AMD modules, but dependencies may be any format.
  * Supports `outFile`.

#### Examples

    
    
    ts
    
    // @Filename: main.ts
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    // @Filename: main.js
    
    define(["require", "exports", "mod", "mod"], function (require, exports, mod_1, mod) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.e1 = void 0;
    
        const dynamic = new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });
    
        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
    
        exports.e1 = 0;
    
        exports.default = "default export";
    
    });

### `umd`

#### Summary

  * Designed for AMD or CommonJS loaders.
  * Does not expose a global variable like most other UMD wrappers.
  * You probably shouldn‚Äôt use this. Use a bundler instead.
  * Emitted files are UMD modules, but dependencies may be any format.

#### Examples

    
    
    ts
    
    // @Filename: main.ts
    
    import x, { y, z } from "mod";
    
    import * as mod from "mod";
    
    const dynamic = import("mod");
    
    console.log(x, y, z, mod, dynamic);
    
    export const e1 = 0;
    
    export default "default export";
    
    
    js
    
    // @Filename: main.js
    
    (function (factory) {
    
        if (typeof module === "object" && typeof module.exports === "object") {
    
            var v = factory(require, exports);
    
            if (v !== undefined) module.exports = v;
    
        }
    
        else if (typeof define === "function" && define.amd) {
    
            define(["require", "exports", "mod", "mod"], factory);
    
        }
    
    })(function (require, exports) {
    
        "use strict";
    
        var __syncRequire = typeof module === "object" && typeof module.exports === "object";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.e1 = void 0;
    
        const mod_1 = require("mod");
    
        const mod = require("mod");
    
        const dynamic = __syncRequire ? Promise.resolve().then(() => require("mod")) : new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });
    
        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
    
        exports.e1 = 0;
    
        exports.default = "default export";
    
    });

## The `moduleResolution` compiler option

This section describes module resolution features and processes shared by
multiple `moduleResolution` modes, then specifies the details of each mode.
See the [_Module resolution_](/docs/handbook/modules/theory.html#module-
resolution) theory section for more background on what the option is and how
it fits into the overall compilation process. In brief, `moduleResolution`
controls how TypeScript resolves _module specifiers_ (string literals in
`import`/`export`/`require` statements) to files on disk, and should be set to
match the module resolver used by the target runtime or bundler.

### Common features and processes

#### File extension substitution

TypeScript always wants to resolve internally to a file that can provide type
information, while ensuring that the runtime or bundler can use the same path
to resolve to a file that provides a JavaScript implementation. For any module
specifier that would, according to the `moduleResolution` algorithm specified,
trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript
will first try to find a TypeScript implementation file or type declaration
file with the same name and analagous file extension.

Runtime lookup | TypeScript lookup #1 | TypeScript lookup #2 | TypeScript lookup #3 | TypeScript lookup #4 | TypeScript lookup #5  
---|---|---|---|---|---  
`/mod.js` | `/mod.ts` | `/mod.tsx` | `/mod.d.ts` | `/mod.js` | `./mod.jsx`  
`/mod.mjs` | `/mod.mts` | `/mod.d.mts` | `/mod.mjs` |  |   
`/mod.cjs` | `/mod.cts` | `/mod.d.cts` | `/mod.cjs` |  |   
  
Note that this behavior is independent of the actual module specifier written
in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts`
file even if the module specifier explicitly uses a `.js` file extension:

    
    
    ts
    
    import x from "./mod.js";
    
    // Runtime lookup: "./mod.js"
    
    // TypeScript lookup #1: "./mod.ts"
    
    // TypeScript lookup #2: "./mod.d.ts"
    
    // TypeScript lookup #3: "./mod.js"

See [_TypeScript imitates the host‚Äôs module resolution, but with
types_](/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-
module-resolution-but-with-types) for an explanation of why TypeScript‚Äôs
module resolution works this way.

#### Relative file path resolution

All of TypeScript‚Äôs `moduleResolution` algorithms support referencing a module
by a relative path that includes a file extension (which will be substituted
according to the rules above):

    
    
    ts
    
    // @Filename: a.ts
    
    export {};
    
    // @Filename: b.ts
    
    import {} from "./a.js"; // ‚úÖ Works in every `moduleResolution`

#### Extensionless relative paths

In some cases, the runtime or bundler allows omitting a `.js` file extension
from a relative path. TypeScript supports this behavior where the
`moduleResolution` setting and the context indicate that the runtime or
bundler supports it:

    
    
    ts
    
    // @Filename: a.ts
    
    export {};
    
    // @Filename: b.ts
    
    import {} from "./a";

If TypeScript determines that the runtime will perform a lookup for `./a.js`
given the module specifier `"./a"`, then `./a.js` will undergo extension
substitution, and resolve to the file `a.ts` in this example.

Extensionless relative paths are not supported in `import` paths in Node.js,
and are not always supported in file paths specified in package.json files.
TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts`
file extension, even though some runtimes and bundlers do.

#### Directory modules (index file resolution)

In some cases, a directory, rather than a file, can be referenced as a module.
In the simplest and most common case, this involves the runtime or bundler
looking for an `index.js` file in a directory. TypeScript supports this
behavior where the `moduleResolution` setting and the context indicate that
the runtime or bundler supports it:

    
    
    ts
    
    // @Filename: dir/index.ts
    
    export {};
    
    // @Filename: b.ts
    
    import {} from "./dir";

If TypeScript determines that the runtime will perform a lookup for
`./dir/index.js` given the module specifier `"./dir"`, then `./dir/index.js`
will undergo extension substitution, and resolve to the file `dir/index.ts` in
this example.

Directory modules may also contain a package.json file, where resolution of
the `"main"` and `"types"` fields are supported, and take precedence over
`index.js` lookups. The `"typesVersions"` field is also supported in directory
modules.

Note that directory modules are not the same as `node_modules` packages and
only support a subset of the features available to packages, and are not
supported at all in some contexts. Node.js considers them a [legacy
feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-
as-modules).

#### `paths`

##### Overview

TypeScript offers a way to override the compiler‚Äôs module resolution for bare
specifiers with the `paths` compiler option. While the feature was originally
designed to be used with the AMD module loader (a means of running modules in
the browser before ESM existed or bundlers were widely used), it still has
uses today when a runtime or bundler supports module resolution features that
TypeScript does not model. For example, when running Node.js with
`--experimental-network-imports`, you can manually specify a local type
definition file for a specific `https://` import:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "module": "nodenext",
    
        "paths": {
    
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"]
    
        }
    
      }
    
    }
    
    
    ts
    
    // Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry
    
    import { add } from "https://esm.sh/lodash@4.17.21";

It‚Äôs also common for apps built with bundlers to define convenience path
aliases in their bundler configuration, and then inform TypeScript of those
aliases with `paths`:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "module": "esnext",
    
        "moduleResolution": "bundler",
    
        "paths": {
    
          "@app/*": ["./src/*"]
    
        }
    
      }
    
    }

##### `paths` does not affect emit

The `paths` option does _not_ change the import path in the code emitted by
TypeScript. Consequently, it‚Äôs very easy to create path aliases that appear to
work in TypeScript but will crash at runtime:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "module": "nodenext",
    
        "paths": {
    
          "node-has-no-idea-what-this-is": ["./oops.ts"]
    
        }
    
      }
    
    }
    
    
    ts
    
    // TypeScript: ‚úÖ
    
    // Node.js: üí•
    
    import {} from "node-has-no-idea-what-this-is";

While it‚Äôs ok for bundled apps to set up `paths`, it‚Äôs very important that
published libraries do _not_ , since the emitted JavaScript will not work for
consumers of the library without those users setting up the same aliases for
both TypeScript and their bundler. Both libraries and apps can consider
package.json `"imports"` as a standard replacement for convenience `paths`
aliases.

##### `paths` should not point to monorepo packages or node_modules packages

While module specifiers that match `paths` aliases are bare specifiers, once
the alias is resolved, module resolution proceeds on the resolved path as a
relative path. Consequently, resolution features that happen for
`node_modules` package lookups, including package.json `"exports"` field
support, do not take effect when a `paths` alias is matched. This can lead to
surprising behavior if `paths` is used to point to a `node_modules` package:

    
    
    ts
    
    {
    
      "compilerOptions": {
    
        "paths": {
    
          "pkg": ["./node_modules/pkg/dist/index.d.ts"],
    
          "pkg/*": ["./node_modules/pkg/*"]
    
        }
    
      }
    
    }

While this configuration may simulate some of the behavior of package
resolution, it overrides any `main`, `types`, `exports`, and `typesVersions`
the package‚Äôs `package.json` file defines, and imports from the package may
fail at runtime.

The same caveat applies to packages referencing each other in a monorepo.
Instead of using `paths` to make TypeScript artificially resolve `"@my-
scope/lib"` to a sibling package, it‚Äôs best to use workspaces via
[npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces),
[yarn](https://classic.yarnpkg.com/en/docs/workspaces/), or
[pnpm](https://pnpm.io/workspaces) to symlink your packages into
`node_modules`, so both TypeScript and the runtime or bundler perform real
`node_modules` package lookups. This is especially important if the monorepo
packages will be published to npm‚Äîthe packages will reference each other via
`node_modules` package lookups once installed by users, and using workspaces
allows you to test that behavior during local development.

##### Relationship to `baseUrl`

When `baseUrl` is provided, the values in each `paths` array are resolved
relative to the `baseUrl`. Otherwise, they are resolved relative to the
`tsconfig.json` file that defines them.

##### Wildcard substitutions

`paths` patterns can contain a single `*` wildcard, which matches any string.
The `*` token can then be used in the file path values to substitute the
matched string:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "paths": {
    
          "@app/*": ["./src/*"]
    
        }
    
      }
    
    }

When resolving an import of `"@app/components/Button"`, TypeScript will match
on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve
the path `./src/components/Button` relative to the `tsconfig.json` path. The
remainder of this lookup will follow the same rules as any other relative path
lookup according to the `moduleResolution` setting.

When multiple patterns match a module specifier, the pattern with the longest
matching prefix before any `*` token is used:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "paths": {
    
          "*": ["./src/foo/one.ts"],
    
          "foo/*": ["./src/foo/two.ts"],
    
          "foo/bar": ["./src/foo/three.ts"]
    
        }
    
      }
    
    }

When resolving an import of `"foo/bar"`, all three `paths` patterns match, but
the last is used because `"foo/bar"` is longer than `"foo/"` and `""`.

##### Fallbacks

Multiple file paths can be provided for a path mapping. If resolution fails
for one path, the next one in the array will be attempted until resolution
succeeds or the end of the array is reached.

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "paths": {
    
          "*": ["./vendor/*", "./types/*"]
    
        }
    
      }
    
    }

#### `baseUrl`

> `baseUrl` was designed for use with AMD module loaders. If you aren‚Äôt using
> an AMD module loader, you probably shouldn‚Äôt use `baseUrl`. Since TypeScript
> 4.1, `baseUrl` is no longer required to use `paths` and should not be used
> just to set the directory `paths` values are resolved from.

The `baseUrl` compiler option can be combined with any `moduleResolution` mode
and specifies a directory that bare specifiers (module specifiers that don‚Äôt
begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher
precedence than `node_modules` package lookups in `moduleResolution` modes
that support them.

When performing a `baseUrl` lookup, resolution proceeds with the same rules as
other relative path resolutions. For example, in a `moduleResolution` mode
that supports extensionless relative paths a module specifier `"some-file"`
may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.

Resolution of relative module specifiers are never affected by the `baseUrl`
option.

#### `node_modules` package lookups

Node.js treats module specifiers that aren‚Äôt relative paths, absolute paths,
or URLs as references to packages that it looks up in `node_modules`
subdirectories. Bundlers conveniently adopted this behavior to allow their
users to use the same dependency management system, and often even the same
dependencies, as they would in Node.js. All of TypeScript‚Äôs `moduleResolution`
options except `classic` support `node_modules` lookups. (`classic` supports
lookups in `node_modules/@types` when other means of resolution fail, but
never looks for packages in `node_modules` directly.) Every `node_modules`
package lookup has the following structure (beginning after higher precedence
bare specifier rules, like `paths`, `baseUrl`, self-name imports, and
package.json `"imports"` lookups have been exhausted):

  1. For each ancestor directory of the importing file, if a `node_modules` directory exists within it: 
    1. If a directory with the same name as the package exists within `node_modules`: 
      1. Attempt to resolve types from the package directory.
      2. If a result is found, return it and stop the search.
    2. If a directory with the same name as the package exists within `node_modules/@types`: 
      1. Attempt to resolve types from the `@types` package directory.
      2. If a result is found, return it and stop the search.
  2. Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.

All `moduleResolution` modes (except `classic`) follow this pattern, while the
details of how they resolve from a package directory, once located, differ,
and are explained in the following sections.

#### package.json `"exports"`

When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and
`resolvePackageJsonExports` is not disabled, TypeScript follows Node.js‚Äôs
[package.json `"exports"`
spec](https://nodejs.org/api/packages.html#packages_package_entry_points) when
resolving from a package directory triggered by a bare specifier
`node_modules` package lookup.

TypeScript‚Äôs implementation for resolving a module specifier through
`"exports"` to a file path follows Node.js exactly. Once a file path is
resolved, however, TypeScript will still try multiple file extensions in order
to prioritize finding types.

When resolving through [conditional
`"exports"`](https://nodejs.org/api/packages.html#conditional-exports),
TypeScript always matches the `"types"` and `"default"` conditions if present.
Additionally, TypeScript will match a versioned types condition in the form
`"types@{selector}"` (where `{selector}` is a `"typesVersions"`-compatible
version selector) according to the same version-matching rules implemented in
`"typesVersions"`. Other non-configurable conditions are dependent on the
`moduleResolution` mode and specified in the following sections. Additional
conditions can be configured to match with the `customConditions` compiler
option.

Note that the presence of `"exports"` prevents any subpaths not explicitly
listed or matched by a pattern in `"exports"` from being resolved.

##### Example: subpaths, conditions, and extension substitution

Scenario: `"pkg/subpath"` is requested with conditions `["types", "node",
"require"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "exports": {
    
        ".": {
    
          "import": "./index.mjs",
    
          "require": "./index.cjs"
    
        },
    
        "./subpath": {
    
          "import": "./subpath/index.mjs",
    
          "require": "./subpath/index.cjs"
    
        }
    
      }
    
    }

Resolution process within the package directory:

  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"import"` match this request? **No.**
  5. Does the second condition `"require"` match this request? **Yes.**
  6. Does the path `"./subpath/index.cjs"` have a recognized TypeScript file extension? **No, so use extension substitution.**
  7. Via extension substitution, try the following paths, returning the first one that exists, or `undefined` otherwise: 
    1. `./subpath/index.cts`
    2. `./subpath/index.d.cts`
    3. `./subpath/index.cjs`

If `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete.
Otherwise, resolution searches `node_modules/@types/pkg` and other
`node_modules` directories in an attempt to resolve types, according to the
`node_modules` package lookups rules. If no types are found, a second pass
through all `node_modules` resolves to `./subpath/index.cjs` (assuming it
exists), which counts as a successful resolution, but one that does not
provide types, leading to `any`-typed imports and a `noImplicitAny` error if
enabled.

##### Example: explicit `"types"` condition

Scenario: `"pkg/subpath"` is requested with conditions `["types", "node",
"import"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "exports": {
    
        "./subpath": {
    
          "import": {
    
            "types": "./types/subpath/index.d.mts",
    
            "default": "./es/subpath/index.mjs"
    
          },
    
          "require": {
    
            "types": "./types/subpath/index.d.cts",
    
            "default": "./cjs/subpath/index.cjs"
    
          }
    
        }
    
      }
    
    }

Resolution process within the package directory:

  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"import"` match this request? **Yes.**
  5. The value at `exports["./subpath"].import` is an object‚Äîit must be specifying conditions.
  6. Does the first condition `"types"` match this request? **Yes.**
  7. Does the path `"./types/subpath/index.d.mts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `"./types/subpath/index.d.mts"` if the file exists, `undefined` otherwise.

##### Example: versioned `"types"` condition

Scenario: using TypeScript 4.7.5, `"pkg/subpath"` is requested with conditions
`["types", "node", "import"]` (determined by `moduleResolution` setting and
the context that triggered the module resolution request) in a package
directory with the following package.json:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "exports": {
    
        "./subpath": {
    
          "types@>=5.2": "./ts5.2/subpath/index.d.ts",
    
          "types@>=4.6": "./ts4.6/subpath/index.d.ts",
    
          "types": "./tsold/subpath/index.d.ts",
    
          "default": "./dist/subpath/index.js"
    
        }
    
      }
    
    }

Resolution process within the package directory:

  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"types@>=5.2"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**
  5. Does the second condition `"types@>=4.6"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**
  6. Does the path `"./ts4.6/subpath/index.d.ts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  7. Return the path `"./ts4.6/subpath/index.d.ts"` if the file exists, `undefined` otherwise.

##### Example: subpath patterns

Scenario: `"pkg/wildcard.js"` is requested with conditions `["types", "node",
"import"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "type": "module",
    
      "exports": {
    
        "./*.js": {
    
          "types": "./types/*.d.ts",
    
          "default": "./dist/*.js"
    
        }
    
      }
    
    }

Resolution process within the package directory:

  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./wildcard.js"` entry? **No.**
  3. Does any key with a `*` in it match `"./wildcard.js"`? **Yes,`"./*.js"` matches and sets `wildcard` to be the substitution.**
  4. The value at `exports["./*.js"]` is an object‚Äîit must be specifying conditions.
  5. Does the first condition `"types"` match this request? **Yes.**
  6. In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**
  7. Does the path `"./types/wildcard.d.ts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `"./types/wildcard.d.ts"` if the file exists, `undefined` otherwise.

##### Example: `"exports"` block other subpaths

Scenario: `"pkg/dist/index.js"` is requested in a package directory with the
following package.json:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "main": "./dist/index.js",
    
      "exports": "./dist/index.js"
    
    }

Resolution process within the package directory:

  1. Does `"exports"` exist? **Yes.**
  2. The value at `exports` is a string‚Äîit must be a file path for the package root (`"."`).
  3. Is the request `"pkg/dist/index.js"` for the package root? **No, it has a subpath`dist/index.js`.**
  4. Resolution fails; return `undefined`.

Without `"exports"`, the request could have succeeded, but the presence of
`"exports"` prevents resolving any subpaths that cannot be matched through
`"exports"`.

#### package.json `"typesVersions"`

A `node_modules` package or directory module may specify a `"typesVersions"`
field in its package.json to redirect TypeScript‚Äôs resolution process
according to the TypeScript compiler version, and for `node_modules` packages,
according to the subpath being resolved. This allows package authors to
include new TypeScript syntax in one set of type definitions while providing
another set for backward compatibility with older TypeScript versions (through
a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)).
`"typesVersions"` is supported in all `moduleResolution` modes; however, the
field is not read in situations when package.json `"exports"` are read.

##### Example: redirect all requests to a subdirectory

Scenario: a module imports `"pkg"` using TypeScript 5.2, where
`node_modules/pkg/package.json` is:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "version": "1.0.0",
    
      "types": "./index.d.ts",
    
      "typesVersions": {
    
        ">=3.1": {
    
          "*": ["ts3.1/*"]
    
        }
    
      }
    
    }

Resolution process:

  1. (Depending on compiler options) Does `"exports"` exist? **No.**
  2. Does `"typesVersions"` exist? **Yes.**
  3. Is the TypeScript version `>=3.1`? **Yes. Remember the mapping`"*": ["ts3.1/*"]`.**
  4. Are we resolving a subpath after the package name? **No, just the root`"pkg"`.**
  5. Does `"types"` exist? **Yes.**
  6. Does any key in `"typesVersions"` match `./index.d.ts`? **Yes,`"*"` matches and sets `index.d.ts` to be the substitution.**
  7. In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.
  8. Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  9. Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.

##### Example: redirect requests for a specific file

Scenario: a module imports `"pkg"` using TypeScript 3.9, where
`node_modules/pkg/package.json` is:

    
    
    json
    
    {
    
      "name": "pkg",
    
      "version": "1.0.0",
    
      "types": "./index.d.ts",
    
      "typesVersions": {
    
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
    
      }
    
    }

Resolution process:

  1. (Depending on compiler options) Does `"exports"` exist? **No.**
  2. Does `"typesVersions"` exist? **Yes.**
  3. Is the TypeScript version `<4.0`? **Yes. Remember the mapping`"index.d.ts": ["index.v3.d.ts"]`.**
  4. Are we resolving a subpath after the package name? **No, just the root`"pkg"`.**
  5. Does `"types"` exist? **Yes.**
  6. Does any key in `"typesVersions"` match `./index.d.ts`? **Yes,`"index.d.ts"` matches.**
  7. Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.

#### package.json `"main"` and `"types"`

If a directory‚Äôs package.json `"exports"` field is not read (either due to
compiler options, or because it is not present, or because the directory is
being resolved as a directory module instead of a `node_modules` package) and
the module specifier does not have a subpath after the package name or
package.json-containing directory, TypeScript will attempt to resolve from
these package.json fields, in order, in an attempt to find the main module for
the package or directory:

  * `"types"`
  * `"typings"` (legacy)
  * `"main"`

The declaration file found at `"types"` is assumed to be an accurate
representation of the implementation file found at `"main"`. If `"types"` and
`"typings"` are not present or cannot be resolved, TypeScript will read the
`"main"` field and perform extension substitution to find a declaration file.

When publishing a typed package to npm, it‚Äôs recommended to include a
`"types"` field even if extension substitution or package.json `"exports"`
make it unnecessary, because npm shows a TS icon on the package registry
listing only if the package.json contains a `"types"` field.

#### Package-relative file paths

If neither package.json `"exports"` nor package.json `"typesVersions"` apply,
subpaths of a bare package specifier resolve relative to the package
directory, according to applicable relative path resolution rules. In modes
that respect [package.json `"exports"`], this behavior is blocked by the mere
presence of the `"exports"` field in the package‚Äôs package.json, even if the
import fails to resolve through `"exports"`, as demonstrated in an example
above. On the other hand, if the import fails to resolve through
`"typesVersions"`, a package-relative file path resolution is attempted as a
fallback.

When package-relative paths are supported, they resolve under the same rules
as any other relative path considering the `moduleResolution` mode and
context. For example, in `--moduleResolution nodenext`, directory modules and
extensionless paths are only supported in `require` calls, not in `import`s:

    
    
    ts
    
    // @Filename: module.mts
    
    import "pkg/dist/foo";                // ‚ùå import, needs `.js` extension
    
    import "pkg/dist/foo.js";             // ‚úÖ
    
    import foo = require("pkg/dist/foo"); // ‚úÖ require, no extension needed

#### package.json `"imports"` and self-name imports

When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and
`resolvePackageJsonImports` is not disabled, TypeScript will attempt to
resolve import paths beginning with `#` through the `"imports"` field of the
nearest ancestor package.json of the importing file. Similarly, when
package.json `"exports"` lookups are enabled, TypeScript will attempt to
resolve import paths beginning with the current package name‚Äîthat is, the
value in the `"name"` field of the nearest ancestor package.json of the
importing file‚Äîthrough the `"exports"` field of that package.json. Both of
these features allow files in a package to import other files in the same
package, replacing a relative import path.

TypeScript follows Node.js‚Äôs resolution algorithm for
[`"imports"`](https://nodejs.org/api/packages.html#subpath-imports) and [self
references](https://nodejs.org/api/packages.html#self-referencing-a-package-
using-its-name) exactly up until a file path is resolved. At that point,
TypeScript‚Äôs resolution algorithm forks based on whether the package.json
containing the `"imports"` or `"exports"` being resolved belongs to a
`node_modules` dependency or the local project being compiled (i.e., its
directory contains the tsconfig.json file for the project that contains the
importing file):

  * If the package.json is in `node_modules`, TypeScript will apply extension substitution to the file path if it doesn‚Äôt already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.
  * If the package.json is part of the local project, an additional remapping step is performed in order to find the _input_ TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `"imports"`. Without this step, any compilation that resolves an `"imports"` path would be referencing output files from the _previous compilation_ instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `"imports"` usually requires an explicit `rootDir` to be set.

This variation allows package authors to write `"imports"` and `"exports"`
fields that reference only the compilation outputs that will be published to
npm, while still allowing local development to use the original TypeScript
source files.

##### Example: local project with conditions

Scenario: `"/src/main.mts"` imports `"#utils"` with conditions `["types",
"node", "import"]` (determined by `moduleResolution` setting and the context
that triggered the module resolution request) in a project directory with a
tsconfig.json and package.json:

    
    
    json
    
    // tsconfig.json
    
    {
    
      "compilerOptions": {
    
        "moduleResolution": "node16",
    
        "resolvePackageJsonImports": true,
    
        "rootDir": "./src",
    
        "outDir": "./dist"
    
      }
    
    }
    
    
    json
    
    // package.json
    
    {
    
      "name": "pkg",
    
      "imports": {
    
        "#utils": {
    
          "import": "./dist/utils.d.mts",
    
          "require": "./dist/utils.d.cts"
    
        }
    
      }
    
    }

Resolution process:

  1. Import path starts with `#`, try to resolve through `"imports"`.
  2. Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
  3. Does `"#utils"` exist in the `"imports"` object? **Yes.**
  4. The value at `imports["#utils"]` is an object‚Äîit must be specifying conditions.
  5. Does the first condition `"import"` match this request? **Yes.**
  6. Should we attempt to map the output path to an input path? **Yes, because:**
     * Is the package.json in `node_modules`? **No, it‚Äôs in the local project.**
     * Is the tsconfig.json within the package.json directory? **Yes.**
  7. In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**
  8. Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**
  9. Return the path `"./src/utils.mts"` if the file exists.
  10. Otherwise, return the path `"./dist/utils.d.mts"` if the file exists.

##### Example: `node_modules` dependency with subpath pattern

Scenario: `"/node_modules/pkg/main.mts"` imports `"#internal/utils"` with
conditions `["types", "node", "import"]` (determined by `moduleResolution`
setting and the context that triggered the module resolution request) with the
package.json:

    
    
    json
    
    // /node_modules/pkg/package.json
    
    {
    
      "name": "pkg",
    
      "imports": {
    
        "#internal/*": {
    
          "import": "./dist/internal/*.mjs",
    
          "require": "./dist/internal/*.cjs"
    
        }
    
      }
    
    }

Resolution process:

  1. Import path starts with `#`, try to resolve through `"imports"`.
  2. Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
  3. Does `"#internal/utils"` exist in the `"imports"` object? **No, check for pattern matches.**
  4. Does any key with a `*` match `"#internal/utils"`? **Yes,`"#internal/*"` matches and sets `utils` to be the substitution.**
  5. The value at `imports["#internal/*"]` is an object‚Äîit must be specifying conditions.
  6. Does the first condition `"import"` match this request? **Yes.**
  7. Should we attempt to map the output path to an input path? **No, because the package.json is in`node_modules`.**
  8. In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**
  9. Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**
  10. Via extension substitution, try the following paths, returning the first one that exists, or `undefined` otherwise: 
    1. `./dist/internal/utils.mts`
    2. `./dist/internal/utils.d.mts`
    3. `./dist/internal/utils.mjs`

### `node16`, `nodenext`

These modes reflect the module resolution behavior of Node.js v12 and later.
(`node16` and `nodenext` are currently identical, but if Node.js makes
significant changes to its module system in the future, `node16` will be
frozen while `nodenext` will be updated to reflect the new behavior.) In
Node.js, the resolution algorithm for ECMAScript imports is significantly
different from the algorithm for CommonJS `require` calls. For each module
specifier being resolved, the syntax and the module format of the importing
file are first used to determine whether the module specifier will be in an
`import` or `require` in the emitted JavaScript. That information is then
passed into the module resolver to determine which resolution algorithm to use
(and whether to use the `"import"` or `"require"` condition for package.json
`"exports"` or `"imports"`).

> TypeScript files that are determined to be in CommonJS format may still use
> `import` and `export` syntax by default, but the emitted JavaScript will use
> `require` and `module.exports` instead. This means that it‚Äôs common to see
> `import` statements that are resolved using the `require` algorithm. If this
> causes confusion, the `verbatimModuleSyntax` compiler option can be enabled,
> which prohibits the use of `import` statements that would be emitted as
> `require` calls.

Note that dynamic `import()` calls are always resolved using the `import`
algorithm, according to Node.js‚Äôs behavior. However, `import()` types are
resolved according to the format of the importing file (for backward
compatibility with existing CommonJS-format type declarations):

    
    
    ts
    
    // @Filename: module.mts
    
    import x from "./mod.js";             // `import` algorithm due to file format (emitted as-written)
    
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    
    type Mod = typeof import("./mod.js"); // `import` algorithm due to file format
    
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)
    
    // @Filename: commonjs.cts
    
    import x from "./mod";                // `require` algorithm due to file format (emitted as `require`)
    
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    
    type Mod = typeof import("./mod");    // `require` algorithm due to file format
    
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)

#### Implied and enforced options

  * `--moduleResolution node16` and `nodenext` must be paired with their corresponding `module` value.

#### Supported features

Features are listed in order of precedence.

| `import` | `require`  
---|---|---  
`paths` | ‚úÖ | ‚úÖ  
`baseUrl` | ‚úÖ | ‚úÖ  
`node_modules` package lookups | ‚úÖ | ‚úÖ  
package.json `"exports"` | ‚úÖ matches `types`, `node`, `import` | ‚úÖ matches `types`, `node`, `require`  
package.json `"imports"` and self-name imports | ‚úÖ matches `types`, `node`, `import` | ‚úÖ matches `types`, `node`, `require`  
package.json `"typesVersions"` | ‚úÖ | ‚úÖ  
Package-relative paths | ‚úÖ when `exports` not present | ‚úÖ when `exports` not present  
Full relative paths | ‚úÖ | ‚úÖ  
Extensionless relative paths | ‚ùå | ‚úÖ  
Directory modules | ‚ùå | ‚úÖ  
  
### `bundler`

`--moduleResolution bundler` attempts to model the module resolution behavior
common to most JavaScript bundlers. In short, this means supporting all the
behaviors traditionally associated with Node.js‚Äôs CommonJS `require`
resolution algorithm like `node_modules` lookups, directory modules, and
extensionless paths, while also supporting newer Node.js resolution features
like package.json `"exports"` and package.json `"imports"`.

It‚Äôs instructive to think about the similarities and differences between
`--moduleResolution bundler` and `--moduleResolution nodenext`, particularly
in how they decide what conditions to use when resolving package.json
`"exports"` or `"imports"`. Consider an import statement in a `.ts` file:

    
    
    ts
    
    // index.ts
    
    import { foo } from "pkg";

Recall that in `--module nodenext --moduleResolution nodenext`, the `--module`
setting first determines whether the import will be emitted to the `.js` file
as an `import` or `require` call, then passes that information to TypeScript‚Äôs
module resolver, which decides whether to match `"import"` or `"require"`
conditions in `"pkg"`‚Äôs package.json `"exports"` accordingly. Let‚Äôs assume
that there‚Äôs no package.json in scope of this file. The file extension is
`.ts`, so the output file extension will be `.js`, which Node.js will
interpret as CommonJS, so TypeScript will emit this `import` as a `require`
call. So, the module resolver will use the `require` condition as it resolves
`"exports"` from `"pkg"`.

The same process happens in `--moduleResolution bundler`, but the rules for
deciding whether to emit an `import` or `require` call for this import
statement will be different, since `--moduleResolution bundler` necessitates
using `--module esnext` or `--module preserve`. In both of those modes, ESM
`import` declarations always emit as ESM `import` declarations, so
TypeScript‚Äôs module resolver will receive that information and use the
`"import"` condition as it resolves `"exports"` from `"pkg"`.

This explanation may be somewhat unintuitive, since `--moduleResolution
bundler` is usually used in combination with `--noEmit`‚Äîbundlers typically
process raw `.ts` files and perform module resolution on untransformed
`import`s or `require`s. However, for consistency, TypeScript still uses the
hypothetical emit decided by `module` to inform module resolution and type
checking. This makes `--module preserve` the best choice whenever a runtime or
bundler is operating on raw `.ts` files, since it implies no transformation.
Under `--module preserve --moduleResolution bundler`, you can write imports
and requires in the same file that will resolve with the `import` and
`require` conditions, respectively:

    
    
    ts
    
    // index.ts
    
    import pkg1 from "pkg";       // Resolved with "import" condition
    
    import pkg2 = require("pkg"); // Resolved with "require" condition

#### Implied and enforced options

  * `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.
  * `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.

#### Supported features

  * `paths` ‚úÖ
  * `baseUrl` ‚úÖ
  * `node_modules` package lookups ‚úÖ
  * package.json `"exports"` ‚úÖ matches `types`, `import`/`require` depending on syntax
  * package.json `"imports"` and self-name imports ‚úÖ matches `types`, `import`/`require` depending on syntax
  * package.json `"typesVersions"` ‚úÖ
  * Package-relative paths ‚úÖ when `exports` not present
  * Full relative paths ‚úÖ
  * Extensionless relative paths ‚úÖ
  * Directory modules ‚úÖ

### `node10` (formerly known as `node`)

`--moduleResolution node` was renamed to `node10` (keeping `node` as an alias
for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module
resolution algorithm as it existed in Node.js versions earlier than v12. It
should no longer be used.

#### Supported features

  * `paths` ‚úÖ
  * `baseUrl` ‚úÖ
  * `node_modules` package lookups ‚úÖ
  * package.json `"exports"` ‚ùå
  * package.json `"imports"` and self-name imports ‚ùå
  * package.json `"typesVersions"` ‚úÖ
  * Package-relative paths ‚úÖ
  * Full relative paths ‚úÖ
  * Extensionless relative paths ‚úÖ
  * Directory modules ‚úÖ

### `classic`

Do not use `classic`.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-reference/Reference.md)
‚ù§

Contributors to this page:  

AB![Andrew Branch
\(7\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

SF![Sean Flanigan
\(1\)](https://gravatar.com/avatar/f77ca2a8cac1b10c9ef94c42e1263ac6?s=32&&d=blank)

SF![Shane Fontaine
\(1\)](https://gravatar.com/avatar/a6c75f47b0be46e29a64a0f03e5775b4?s=32&&d=blank)

Z![zhennann
\(1\)](https://gravatar.com/avatar/5486c2c585f67e5d96ae32e6140d74d0?s=32&&d=blank)

HCDC![Henrique Carvalho da Cruz
\(1\)](https://gravatar.com/avatar/45dc36c036a3034db00361897cd500f0?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Modules - Theory

## Scripts and modules in JavaScript

In the early days of JavaScript, when the language only ran in browsers, there
were no modules, but it was still possible to split the JavaScript for a web
page into multiple files by using multiple `script` tags in HTML:

    
    
    html
    
    <html>
    
      <head>
    
        <script src="a.js"></script>
    
        <script src="b.js"></script>
    
      </head>
    
      <body></body>
    
    </html>

This approach had some downsides, especially as web pages grew larger and more
complex. In particular, all scripts loaded onto the same page share the same
scope‚Äîappropriately called the ‚Äúglobal scope‚Äù‚Äîmeaning the scripts had to be
very careful not to overwrite each others‚Äô variables and functions.

Any system that solves this problem by giving files their own scope while
still providing a way to make bits of code available to other files can be
called a ‚Äúmodule system.‚Äù (It may sound obvious to say that each file in a
module system is called a ‚Äúmodule,‚Äù but the term is often used to contrast
with _script_ files, which run outside a module system, in a global scope.)

> There are [many module systems](https://github.com/myshov/history-of-
> javascript/tree/master/4_evolution_of_js_modularity), and TypeScript
> [supports emitting
> several](https://www.typescriptlang.org/tsconfig/#module), but this
> documentation will focus on the two most important systems today: ECMAScript
> modules (ESM) and CommonJS (CJS).
>
> ECMAScript Modules (ESM) is the module system built into the language,
> supported in modern browsers and in Node.js since v12. It uses dedicated
> `import` and `export` syntax:
>  
>  
>     js
>  
>     // a.js
>  
>     export default "Hello from a.js";
>  
>  
>     js
>  
>     // b.js
>  
>     import a from "./a.js";
>  
>     console.log(a); // 'Hello from a.js'
>
> CommonJS (CJS) is the module system that originally shipped in Node.js,
> before ESM was part of the language specification. It‚Äôs still supported in
> Node.js alongside ESM. It uses plain JavaScript objects and functions named
> `exports` and `require`:
>  
>  
>     js
>  
>     // a.js
>  
>     exports.message = "Hello from a.js";
>  
>  
>     js
>  
>     // b.js
>  
>     const a = require("./a");
>  
>     console.log(a.message); // 'Hello from a.js'

Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript
module, it starts by assuming that file will have its own scope. Beyond that,
though, the compiler‚Äôs job gets a little more complicated.

## TypeScript‚Äôs job concerning modules

The TypeScript compiler‚Äôs chief goal is to prevent certain kinds of runtime
errors by catching them at compile time. With or without modules involved, the
compiler needs to know about the code‚Äôs intended runtime environment‚Äîwhat
globals are available, for example. When modules are involved, there are
several additional questions the compiler needs to answer in order to do its
job. Let‚Äôs use a few lines of input code as an example to think about all the
information needed to analyze it:

    
    
    ts
    
    import sayHello from "greetings";
    
    sayHello("world");

To check this file, the compiler needs to know the type of `sayHello` (is it a
function that can accept one string argument?), which opens quite a few
additional questions:

  1. Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?
  2. What _kind_ of module does the module system expect to find, given the file name it will load and its location on disk?
  3. If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?
  4. Where will the module system look to find the module specified by `"greetings"`? Will the lookup succeed?
  5. What kind of module is the file resolved by that lookup?
  6. Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?
  7. Once the `"greetings"` module has been analyzed, what piece of that module is bound to `sayHello`?

Notice that all of these questions depend on characteristics of the _host_
‚Äîthe system that ultimately consumes the output JavaScript (or raw TypeScript,
as the case may be) to direct its module loading behavior, typically either a
runtime (like Node.js) or bundler (like Webpack).

The ECMAScript specification defines how ESM imports and exports link up with
each other, but it doesn‚Äôt specify how the file lookup in (4), known as
_module resolution_ , happens, and it doesn‚Äôt say anything about other module
systems like CommonJS. So runtimes and bundlers, especially those that want to
support both ESM and CJS, have a lot of freedom to design their own rules.
Consequently, the way TypeScript should answer the questions above can vary
dramatically depending on where the code is intended to run. There‚Äôs no single
right answer, so the compiler must be told the rules through configuration
options.

The other key idea to keep in mind is that TypeScript almost always thinks
about these questions in terms of its _output_ JavaScript files, not its
_input_ TypeScript (or JavaScript!) files. Today, some runtimes and bundlers
support loading TypeScript files directly, and in those cases, it doesn‚Äôt make
sense to think about separate input and output files. Most of this document
discusses cases where TypeScript files are compiled to JavaScript files, which
in turn are loaded by the runtime module system. Examining these cases is
essential for building an understanding of the compiler‚Äôs options and
behavior‚Äîit‚Äôs easier to start there and simplify when thinking about esbuild,
Bun, and other TypeScript-first runtimes and bundlers. So for now, we can
summarize TypeScript‚Äôs job when it comes to modules in terms of output files:

Understand the **rules of the host** enough

  1. to compile files into a valid **output module format** ,
  2. to ensure that imports in those **outputs** will **resolve successfully** , and
  3. to know what **type** to assign to **imported names**.

## Who is the host?

Before we move on, it‚Äôs worth making sure we‚Äôre on the same page about the
term _host_ , because it will come up frequently. We defined it before as ‚Äúthe
system that ultimately consumes the output code to direct its module loading
behavior.‚Äù In other words, it‚Äôs the system outside of TypeScript that
TypeScript‚Äôs module analysis tries to model:

  * When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.
  * When there is no ‚Äúoutput code‚Äù because a runtime consumes TypeScript files directly, the runtime is still the host.
  * When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn‚Äôt know about anything that happens post-bundler.)
  * If another transpiler, optimizer, or formatter runs on TypeScript‚Äôs outputs, it‚Äôs _not_ a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.
  * When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser‚Äôs JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.
  * The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.

## The module output format

In any project, the first question about modules we need to answer is what
kinds of modules the host expects, so TypeScript can set its output format for
each file to match. Sometimes, the host only _supports_ one kind of module‚ÄîESM
in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12
and later accepts both CJS and ES modules, but uses file extensions and
`package.json` files to determine what format each file should be, and throws
an error if the file‚Äôs contents don‚Äôt match the expected format.

The `module` compiler option provides this information to the compiler. Its
primary purpose is to control the module format of any JavaScript that gets
emitted during compilation, but it also serves to inform the compiler about
how the module kind of each file should be detected, how different module
kinds are allowed to import each other, and whether features like
`import.meta` and top-level `await` are available. So, even if a TypeScript
project is using `noEmit`, choosing the right setting for `module` still
matters. As we established earlier, the compiler needs an accurate
understanding of the module system so it can type check (and provide
IntelliSense for) imports. See [_Choosing compiler
options_](/docs/handbook/modules/guides/choosing-compiler-options.html) for
guidance on choosing the right `module` setting for your project.

The available `module` settings are

  * [**`node16`**](/docs/handbook/modules/reference.html#node16-nodenext): Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.
  * [**`nodenext`**](/docs/handbook/modules/reference.html#node16-nodenext): Currently identical to `node16`, but will be a moving target reflecting the latest Node.js versions as Node.js‚Äôs module system evolves.
  * [**`es2015`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).
  * [**`es2020`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for `import.meta` and `export * as ns from "mod"` to `es2015`.
  * [**`es2022`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for top-level `await` to `es2020`.
  * [**`esnext`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.
  * **[`commonjs`](/docs/handbook/modules/reference.html#commonjs), [`system`](/docs/handbook/modules/reference.html#system), [`amd`](/docs/handbook/modules/reference.html#amd), and [`umd`](/docs/handbook/modules/reference.html#umd)**: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.

> Node.js‚Äôs rules for module format detection and interoperability make it
> incorrect to specify `module` as `esnext` or `commonjs` for projects that
> run in Node.js, even if all files emitted by `tsc` are ESM or CJS,
> respectively. The only correct `module` settings for projects that intend to
> run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for
> an all-ESM Node.js project might look identical between compilations using
> `esnext` and `nodenext`, the type checking can differ. See the [reference
> section on
> `nodenext`](/docs/handbook/modules/reference.html#node16-nodenext) for more
> details.

### Module format detection

Node.js understands both ES modules and CJS modules, but the format of each
file is determined by its file extension and the `type` field of the first
`package.json` file found in a search of the file‚Äôs directory and all ancestor
directories:

  * `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.
  * `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `"module"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.

If a file is determined to be an ES module by these rules, Node.js will not
inject the CommonJS `module` and `require` objects into the file‚Äôs scope
during evaluation, so a file that tries to use them will cause a crash.
Conversely, if a file is determined to be a CJS module, `import` and `export`
declarations in the file will cause a syntax error crash.

When the `module` compiler option is set to `node16` or `nodenext`, TypeScript
applies this same algorithm to the project‚Äôs _input_ files to determine the
module kind of each corresponding _output_ file. Let‚Äôs look at how module
formats are detected in an example project that uses `--module nodenext`:

Input file name | Contents | Output file name | Module kind | Reason  
---|---|---|---|---  
`/package.json` | `{}` |  |  |   
`/main.mts` |  | `/main.mjs` | ESM | File extension  
`/utils.cts` |  | `/utils.cjs` | CJS | File extension  
`/example.ts` |  | `/example.js` | CJS | No `"type": "module"` in `package.json`  
`/node_modules/pkg/package.json` | `{ "type": "module" }` |  |  |   
`/node_modules/pkg/index.d.ts` |  |  | ESM | `"type": "module"` in `package.json`  
`/node_modules/pkg/index.d.cts` |  |  | CJS | File extension  
  
When the input file extension is `.mts` or `.cts`, TypeScript knows to treat
that file as an ES module or CJS module, respectively, because Node.js will
treat the output `.mjs` file as an ES module or the output `.cjs` file as a
CJS module. When the input file extension is `.ts`, TypeScript has to consult
the nearest `package.json` file to determine the module format, because this
is what Node.js will do when it encounters the output `.js` file. (Notice that
the same rules apply to the `.d.cts` and `.d.ts` declaration files in the
`pkg` dependency: though they will not produce an output file as part of this
compilation, the presence of a `.d.ts` file _implies_ the existence of a
corresponding `.js` file‚Äîperhaps created when the author of the `pkg` library
ran `tsc` on an input `.ts` file of their own‚Äîwhich Node.js must interpret as
an ES module, due to its `.js` extension and the presence of the `"type":
"module"` field in `/node_modules/pkg/package.json`. Declaration files are
covered in more detail in a later section.)

The detected module format of input files is used by TypeScript to ensure it
emits the output syntax that Node.js expects in each output file. If
TypeScript were to emit `/example.js` with `import` and `export` statements in
it, Node.js would crash when parsing the file. If TypeScript were to emit
`/main.mjs` with `require` calls, Node.js would crash during evaluation.
Beyond emit, the module format is also used to determine rules for type
checking and module resolution, which we‚Äôll discuss in the following sections.

It‚Äôs worth mentioning again that TypeScript‚Äôs behavior in `--module node16`
and `--module nodenext` is entirely motivated by Node.js‚Äôs behavior. Since
TypeScript‚Äôs goal is to catch potential runtime errors at compile time, it
needs a very accurate model of what will happen at runtime. This fairly
complex set of rules for module kind detection is _necessary_ for checking
code that will run in Node.js, but may be overly strict or just incorrect if
applied to non-Node.js hosts.

### Input module syntax

It‚Äôs important to note that the _input_ module syntax seen in input source
files is somewhat decoupled from the output module syntax emitted to JS files.
That is, a file with an ESM import:

    
    
    ts
    
    import { sayHello } from "greetings";
    
    sayHello("world");

might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:

    
    
    ts
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const greetings_1 = require("greetings");
    
    (0, greetings_1.sayHello)("world");

depending on the `module` compiler option (and any applicable module format
detection rules, if the `module` option supports more than one kind of
module). In general, this means that looking at the contents of an input file
isn‚Äôt enough to determine whether it‚Äôs an ES module or a CJS module.

> Today, most TypeScript files are authored using ESM syntax (`import` and
> `export` statements) regardless of the output format. This is largely a
> legacy of the long road ESM has taken to widespread support. ECMAScript
> modules were standardized in 2015, were supported in most browsers by 2017,
> and landed in Node.js v12 in 2019. During much of this window, it was clear
> that ESM was the future of JavaScript modules, but very few runtimes could
> consume it. Tools like Babel made it possible for JavaScript to be authored
> in ESM and downleveled to another module format that could be used in
> Node.js or browsers. TypeScript followed suit, adding support for ES module
> syntax and softly discouraging the use of the original CommonJS-inspired
> `import fs = require("fs")` syntax in [the 1.5
> release](https://devblogs.microsoft.com/typescript/announcing-
> typescript-1-5/).
>
> The upside of this ‚Äúauthor ESM, output anything‚Äù strategy was that
> TypeScript could use standard JavaScript syntax, making the authoring
> experience familiar to newcomers, and (theoretically) making it easy for
> projects to start targeting ESM outputs in the future. There are three
> significant downsides, which became fully apparent only after ESM and CJS
> modules were allowed to coexist and interoperate in Node.js:
>
>   1. Early assumptions about how ESM/CJS interoperability would work in
> Node.js turned out to be wrong, and today, interoperability rules differ
> between Node.js and bundlers. Consequently, the configuration space for
> modules in TypeScript is large.
>   2. When the syntax in input files all looks like ESM, it‚Äôs easy for an
> author or code reviewer to lose track of what kind of module a file is at
> runtime. And because of Node.js‚Äôs interoperability rules, what kind of
> module each file is became very important.
>   3. When input files are written in ESM, the syntax in type declaration
> outputs (`.d.ts` files) looks like ESM too. But because the corresponding
> JavaScript files could have been emitted in any module format, TypeScript
> can‚Äôt tell what kind of module a file is just by looking at the contents of
> its type declarations. And again, because of the nature of ESM/CJS
> interoperability, TypeScript _has_ to know what kind of module everything is
> in order to provide correct types and prevent imports that will crash.
>

>
> In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was
> introduced to help TypeScript authors know exactly how their `import` and
> `export` statements will be emitted. When enabled, the flag requires imports
> and exports in input files to be written in the form that will undergo the
> least amount of transformation before emit. So if a file will be emitted as
> ESM, imports and exports must be written in ESM syntax; if a file will be
> emitted as CJS, it must be written in the CommonJS-inspired TypeScript
> syntax (`import fs = require("fs")` and `export = {}`). This setting is
> particularly recommended for Node.js projects that use mostly ESM, but have
> a select few CJS files. It is not recommended for projects that currently
> target CJS, but may want to target ESM in the future.

### ESM and CJS interoperability

Can an ES module `import` a CommonJS module? If so, does a default import link
to `exports` or `exports.default`? Can a CommonJS module `require` an ES
module? CommonJS isn‚Äôt part of the ECMAScript specification, so runtimes,
bundlers, and transpilers have been free to make up their own answers to these
questions since ESM was standardized in 2015, and as such no standard set of
interoperability rules exist. Today, most runtimes and bundlers broadly fall
into one of three categories:

  1. **ESM-only.** Some runtimes, like browser engines, only support what‚Äôs actually a part of the language: ECMAScript Modules.
  2. **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.
  3. **Node.js.** In Node.js, CommonJS modules cannot load ES modules synchronously (with `require`); they can only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)

TypeScript needs to know which of these rule sets to assume in order to
provide correct types on (particularly `default`) imports and to error on
imports that will crash at runtime. When the `module` compiler option is set
to `node16` or `nodenext`, Node.js‚Äôs rules are enforced. All other `module`
settings, combined with the
[`esModuleInterop`](/docs/handbook/modules/reference.html#esModuleInterop)
option, result in bundler-like interop in TypeScript. (While using `--module
esnext` does prevent you from _writing_ CommonJS modules, it does not prevent
you from _importing_ them as dependencies. There‚Äôs currently no TypeScript
setting that can guard against an ES module importing a CommonJS module, as
would be appropriate for direct-to-browser code.)

### Module specifiers are not transformed

While the `module` compiler option can transform imports and exports in input
files to different module formats in output files, the module _specifier_ (the
string `from` which you `import`, or pass to `require`) is always emitted as-
written. For example, an input like:

    
    
    ts
    
    import { add } from "./math.mjs";
    
    add(1, 2);

might be emitted as either:

    
    
    ts
    
    import { add } from "./math.mjs";
    
    add(1, 2);

or:

    
    
    ts
    
    const math_1 = require("./math.mjs");
    
    math_1.add(1, 2);

depending on the `module` compiler option, but the module specifier will
always be `"./math.mjs"`. There is no compiler option that enables
transforming, substituting, or rewriting module specifiers. Consequently,
module specifiers must be written in a way that works for the code‚Äôs target
runtime or bundler, and it‚Äôs TypeScript‚Äôs job to understand those _output_
-relative specifiers. The process of finding the file referenced by a module
specifier is called _module resolution_.

## Module resolution

Let‚Äôs return to our first example and review what we‚Äôve learned about it so
far:

    
    
    ts
    
    import sayHello from "greetings";
    
    sayHello("world");

So far, we‚Äôve discussed how the host‚Äôs module system and TypeScript‚Äôs `module`
compiler option might impact this code. We know that the input syntax looks
like ESM, but the output format depends on the `module` compiler option,
potentially the file extension, and `package.json` `"type"` field. We also
know that what `sayHello` gets bound to, and even whether the import is even
allowed, may vary depending on the module kinds of this file and the target
file. But we haven‚Äôt yet discussed how to _find_ the target file.

### Module resolution is host-defined

While the ECMAScript specification defines how to parse and interpret `import`
and `export` statements, it leaves module resolution up to the host. If you‚Äôre
creating a hot new JavaScript runtime, you‚Äôre free to create a module
resolution scheme like:

    
    
    ts
    
    import monkey from "üêí"; // Looks for './eats/bananas.js'
    
    import cow from "üêÑ";    // Looks for './eats/grass.js'
    
    import lion from "ü¶Å";   // Looks for './eats/you.js'

and still claim to implement ‚Äústandards-compliant ESM.‚Äù Needless to say,
TypeScript would have no idea what types to assign to `monkey`, `cow`, and
`lion` without built-in knowledge of this runtime‚Äôs module resolution
algorithm. Just as `module` informs the compiler about the host‚Äôs expected
module format, `moduleResolution`, along with a few customization options,
specify the algorithm the host uses to resolve module specifiers to files.
This also clarifies why TypeScript doesn‚Äôt modify import specifiers during
emit: the relationship between an import specifier and a file on disk (if one
even exists) is host-defined, and TypeScript is not a host.

The available `moduleResolution` options are:

  * [**`classic`**](/docs/handbook/modules/reference.html#classic): TypeScript‚Äôs oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages) configurations. It should not be used for new projects (or even old projects that don‚Äôt use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.
  * [**`node10`**](/docs/handbook/modules/reference.html#node10-formerly-known-as-node): Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It‚Äôs a pretty good model of Node.js versions older than v12, and sometimes it‚Äôs a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it‚Äôs a very bad model of modern versions of Node.js. It should not be used for new projects.
  * [**`node16`**](/docs/handbook/modules/reference.html#node16-nodenext-1): This is the counterpart of `--module node16` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the module format detection rules instated by `--module node16`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else has unsupported behavior and may be an error in the future.)
  * [**`nodenext`**](/docs/handbook/modules/reference.html#node16-nodenext-1): Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It‚Äôs intended to be a forward-looking mode that will support new Node.js module resolution features as they‚Äôre added.
  * [**`bundler`**](/docs/handbook/modules/reference.html#bundler): Node.js v12 introduced some new module resolution features for importing npm packages‚Äîthe `"exports"` and `"imports"` fields of `package.json`‚Äîand many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `"exports"` and `"imports"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.

### TypeScript imitates the host‚Äôs module resolution, but with types

Remember the three components of TypeScript‚Äôs job concerning modules?

  1. Compile files into a valid **output module format**
  2. Ensure that imports in those **outputs** will **resolve successfully**
  3. Know what **type** to assign to **imported names**.

Module resolution is needed to accomplish last two. But when we spend most of
our time working in input files, it can be easy to forget about (2)‚Äîthat a key
component of module resolution is validating that the imports or `require`
calls in the output files, containing the same module specifiers as the input
files, will actually work at runtime. Let‚Äôs look at a new example with
multiple files:

    
    
    ts
    
    // @Filename: math.ts
    
    export function add(a: number, b: number) {
    
      return a + b;
    
    }
    
    // @Filename: main.ts
    
    import { add } from "./math";
    
    add(1, 2);

When we see the import from `"./math"`, it might be tempting to think, ‚ÄúThis
is how one TypeScript file refers to another. The compiler follows this
(extensionless) path in order to assign a type to `add`.‚Äù

![A simple flowchart diagram. A file \(rectangle node\) main.ts resolves
\(labeled arrow\) through module specifier './math' to another file
math.ts.](/c858b89407a2057ead56516c9a77c783/theory.md-1.svg)

This isn‚Äôt entirely wrong, but the reality is deeper. The resolution of
`"./math"` (and subsequently, the type of `add`) need to reflect the reality
of what happens at runtime to the _output_ files. A more robust way to think
about this process would look like this:

![A flowchart diagram with two groups of files: Input files and Output files.
main.ts \(an input file\) maps to output file main.js, which resolves through
the module specifier "./math" to math.js \(another output file\), which maps
back to the input file
math.ts.](/b1f11e84a45a07707dbe1bb284b2fbff/theory.md-2.svg)

This model makes it clear that for TypeScript, module resolution is mostly a
matter of accurately modeling the host‚Äôs module resolution algorithm between
output files, with a little bit of remapping applied to find type information.
Let‚Äôs look at another example that appears unintuitive through the lens of the
simple model, but makes perfect sense with the robust model:

    
    
    ts
    
    // @moduleResolution: node16
    
    // @rootDir: src
    
    // @outDir: dist
    
    // @Filename: src/math.mts
    
    export function add(a: number, b: number) {
    
      return a + b;
    
    }
    
    // @Filename: src/main.mts
    
    import { add } from "./math.mjs";
    
    add(1, 2);

Node.js ESM `import` declarations use a strict module resolution algorithm
that requires relative paths to include file extensions. When we only think
about input files, it‚Äôs a little strange that `"./math.mjs"` seems to resolve
to `math.mts`. Since we‚Äôre using an `outDir` to put compiled outputs in a
different directory, `math.mjs` doesn‚Äôt even exist next to `main.mts`! Why
should this resolve? With our new mental model, it‚Äôs no problem:

![A flowchart diagram with identical structure to the one above. There are two
groups of files: Input files and Output files. src/main.mts \(an input file\)
maps to output file dist/main.mjs, which resolves through module specifier
"./math.mjs" to dist/math.mjs \(another output file\), which maps back to
input file src/math.mts.](/729e81e79e38af5bf41ddf97aba453d1/theory.md-3.svg)

Understanding this mental model may not immediately eliminate the strangeness
of seeing output file extensions in input files, and it‚Äôs natural to think in
terms of shortcuts: _`"./math.mjs"` refers to the input file `math.mts`. I
have to write the output extension, but the compiler knows to look for `.mts`
when I write `.mjs`._ This shortcut is even how the compiler works internally,
but the more robust mental model explains _why_ module resolution in
TypeScript works this way: given the constraint that the module specifier in
the output file will be the same as the module specifier in the input file,
this is the only process that accomplishes our two goals of validating output
files and assigning types.

### The role of declaration files

In the previous example, we saw the ‚Äúremapping‚Äù part of module resolution
working between input and output files. But what happens when we import
library code? Even if the library was written in TypeScript, it may not have
published its source code. If we can‚Äôt rely on mapping the library‚Äôs
JavaScript files back to a TypeScript file, we can verify that our import
works at runtime, but how do we accomplish our second goal of assigning types?

This is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The
best way to understand how declaration files are interpreted is to understand
where they come from. When you run `tsc --declaration` on an input file, you
get one output JavaScript file and one output declaration file:

![A diagram showing the relationship between different file types. A .ts file
\(top\) has two arrows labeled 'generates' flowing to a .js file \(bottom
left\) and a .d.ts file \(bottom right\). Another arrow labeled 'implies'
points from the .d.ts file to the .js
file.](/fef70ad85e4ea4ef928cc62ddb67407b/declaration-files.svg)

Because of this relationship, the compiler _assumes_ that wherever it sees a
declaration file, there is a corresponding JavaScript file that is perfectly
described by the type information in the declaration file. For performance
reasons, in every module resolution mode, the compiler always looks for
TypeScript and declaration files first, and if it finds one, it doesn‚Äôt
continue looking for the corresponding JavaScript file. If it finds a
TypeScript input file, it knows a JavaScript file _will_ exist after
compilation, and if it finds a declaration file, it knows a compilation
(perhaps someone else‚Äôs) already happened and created a JavaScript file at the
same time as the declaration file.

The declaration file tells the compiler not only that a JavaScript file
exists, but also what its name and extension are:

Declaration file extension | JavaScript file extension | TypeScript file extension  
---|---|---  
`.d.ts` | `.js` | `.ts`  
`.d.ts` | `.js` | `.tsx`  
`.d.mts` | `.mjs` | `.mts`  
`.d.cts` | `.cjs` | `.cts`  
`.d.*.ts` | `.*` |   
  
The last row expresses that non-JS files can be typed with the
`allowArbitraryExtensions` compiler option to support cases where the module
system supports importing non-JS files as JavaScript objects. For example, a
file named `styles.css` can be represented by a declaration file named
`styles.d.css.ts`.

> ‚ÄúBut wait! Plenty of declaration files are written by hand, _not_ generated
> by `tsc`. Ever heard of DefinitelyTyped?‚Äù you might object. And it‚Äôs
> true‚Äîhand-writing declaration files, or even moving/copying/renaming them to
> represent outputs of an external build tool, is a dangerous, error-prone
> venture. DefinitelyTyped contributors and authors of typed libraries not
> using `tsc` to generate both JavaScript and declaration files should ensure
> that every JavaScript file has a sibling declaration file with the same name
> and matching extension. Breaking from this structure can lead to false-
> positive TypeScript errors for end users. The npm package
> [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli)
> can help catch and explain these errors before they‚Äôre published.

### Module resolution for bundlers, TypeScript runtimes, and Node.js loaders

So far, we‚Äôve really emphasized the distinction between _input files_ and
_output files_. Recall that when specifying a file extension on a relative
module specifier, TypeScript typically makes you use the _output_ file
extension:

    
    
    ts
    
    // @Filename: src/math.ts
    
    export function add(a: number, b: number) {
    
      return a + b;
    
    }
    
    // @Filename: src/main.ts
    
    import { add } from "./math.ts";
    
    //                  ^^^^^^^^^^^
    
    // An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.

This restriction applies since TypeScript won‚Äôt rewrite the extension to
`.js`, and if `"./math.ts"` appears in an output JS file, that import won‚Äôt
resolve to another JS file at runtime. TypeScript really wants to prevent you
from generating an unsafe output JS file. But what if there _is_ no output JS
file? What if you‚Äôre in one of these situations:

  * You‚Äôre bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you‚Äôve written to produce a bundle.
  * You‚Äôre running this code directly in a TypeScript runtime like Deno or Bun.
  * You‚Äôre using `ts-node`, `tsx`, or another transpiling loader for Node.

In these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and
`allowImportingTsExtensions` to disable emitting unsafe JavaScript files and
silence the error on `.ts`-extensioned imports.

With or without `allowImportingTsExtensions`, it‚Äôs still important to pick the
most appropriate `moduleResolution` setting for the module resolution host.
For bundlers and the Bun runtime, it‚Äôs `bundler`. These module resolvers were
inspired by Node.js, but didn‚Äôt adopt the strict ESM resolution algorithm that
disables extension searching that Node.js applies to imports. The `bundler`
module resolution setting reflects this, enabling `package.json` `"exports"`
support like `node16` and `nodenext`, while always allowing extensionless
imports. See [_Choosing compiler
options_](/docs/handbook/modules/guides/choosing-compiler-options.html) for
more guidance.

### Module resolution for libraries

When compiling an app, you choose the `moduleResolution` option for a
TypeScript project based on who the module resolution host is. When compiling
a library, you don‚Äôt know where the output code will run, but you‚Äôd like it to
run in as many places as possible. Using `"module": "nodenext"` (along with
the implied [`"moduleResolution":
"nodenext"`](/docs/handbook/modules/reference.html#node16-nodenext)) is the
best bet for maximizing the compatibility of the output JavaScript‚Äôs module
specifiers, since it will force you to comply with Node.js‚Äôs stricter rules
for `import` module resolution. Let‚Äôs look at what would happen if a library
were to compile with `"moduleResolution": "bundler"` (or worse, `"node10"`):

    
    
    ts
    
    export * from "./utils";

Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine
with this code, so `"moduleResolution": "bundler"` doesn‚Äôt complain. Compiled
with `"module": "esnext"`, the output JavaScript for this export statement
will look exactly the same as the input. If that JavaScript were published to
npm, it would be usable by projects that use a bundler, but it would cause an
error when run in Node.js:

    
    
    Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js
    
    Did you mean to import ./utils.js?

On the other hand, if we had written:

    
    
    ts
    
    export * from "./utils.js";

This would produce output that works both in Node.js _and_ in bundlers.

In short, `"moduleResolution": "bundler"` is infectious, allowing code that
only works in bundlers to be produced. Likewise, `"moduleResolution":
"nodenext"` is only checking that the output works in Node.js, but in most
cases, module code that works in Node.js will work in other runtimes and in
bundlers.

Of course, this guidance can only apply in cases where the library ships
outputs from `tsc`. If the library is being bundled _before_ shipping,
`"moduleResolution": "bundler"` may be acceptable. Any build tool that changes
the module format or module specifiers to produce the final build of the
library bears the responsibility of ensuring the safety and compatibility of
the product‚Äôs module code, and `tsc` can no longer contribute to that task,
since it can‚Äôt know what module code will exist at runtime.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-reference/Theory.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Namespaces and Modules

This post outlines the various ways to organize your code using modules and
namespaces in TypeScript. We‚Äôll also go over some advanced topics of how to
use namespaces and modules, and address some common pitfalls when using them
in TypeScript.

See the [Modules](/docs/handbook/modules.html) documentation for more
information about ES Modules. See the
[Namespaces](/docs/handbook/namespaces.html) documentation for more
information about TypeScript namespaces.

Note: In _very_ old versions of TypeScript namespaces were called ‚ÄòInternal
Modules‚Äô, these pre-date JavaScript module systems.

## Using Modules

Modules can contain both code and declarations.

Modules also have a dependency on a module loader (such as
CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide
for better code reuse, stronger isolation and better tooling support for
bundling.

It is also worth noting that, for Node.js applications, modules are the
default and **we recommended modules over namespaces in modern code**.

Starting with ECMAScript 2015, modules are native part of the language, and
should be supported by all compliant engine implementations. Thus, for new
projects modules would be the recommended code organization mechanism.

## Using Namespaces

Namespaces are a TypeScript-specific way to organize code.  
Namespaces are simply named JavaScript objects in the global namespace. This
makes namespaces a very simple construct to use. Unlike modules, they can span
multiple files, and can be concatenated using [`outFile`](/tsconfig#outFile).
Namespaces can be a good way to structure your code in a Web Application, with
all dependencies included as `<script>` tags in your HTML page.

Just like all global namespace pollution, it can be hard to identify component
dependencies, especially in a large application.

## Pitfalls of Namespaces and Modules

In this section we‚Äôll describe various common pitfalls in using namespaces and
modules, and how to avoid them.

### `/// <reference>`-ing a module

A common mistake is to try to use the `/// <reference ... />` syntax to refer
to a module file, rather than using an `import` statement. To understand the
distinction, we first need to understand how the compiler can locate the type
information for a module based on the path of an `import` (e.g. the `...` in
`import x from "...";`, `import x = require("...");`, etc.) path.

The compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the
appropriate path. If a specific file could not be found, then the compiler
will look for an _ambient module declaration_. Recall that these need to be
declared in a `.d.ts` file.

  * `myModules.d.ts`
    
        ts
    
    // In a .d.ts file or .ts file that is not a module:
    
    declare module "SomeModule" {
    
      export function fn(): string;
    
    }

  * `myOtherModule.ts`
    
        ts
    
    /// <reference path="myModules.d.ts" />
    
    import * as m from "SomeModule";

The reference tag here allows us to locate the declaration file that contains
the declaration for the ambient module. This is how the `node.d.ts` file that
several of the TypeScript samples use is consumed.

### Needless Namespacing

If you‚Äôre converting a program from namespaces to modules, it can be easy to
end up with a file that looks like this:

  * `shapes.ts`
    
        ts
    
    export namespace Shapes {
    
      export class Triangle {
    
        /* ... */
    
      }
    
      export class Square {
    
        /* ... */
    
      }
    
    }

The top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no
reason. This is confusing and annoying for consumers of your module:

  * `shapeConsumer.ts`
    
        ts
    
    import * as shapes from "./shapes";
    
    let t = new shapes.Shapes.Triangle(); // shapes.Shapes?

A key feature of modules in TypeScript is that two different modules will
never contribute names to the same scope. Because the consumer of a module
decides what name to assign it, there‚Äôs no need to proactively wrap up the
exported symbols in a namespace.

To reiterate why you shouldn‚Äôt try to namespace your module contents, the
general idea of namespacing is to provide logical grouping of constructs and
to prevent name collisions. Because the module file itself is already a
logical grouping, and its top-level name is defined by the code that imports
it, it‚Äôs unnecessary to use an additional module layer for exported objects.

Here‚Äôs a revised example:

  * `shapes.ts`
    
        ts
    
    export class Triangle {
    
      /* ... */
    
    }
    
    export class Square {
    
      /* ... */
    
    }

  * `shapeConsumer.ts`
    
        ts
    
    import * as shapes from "./shapes";
    
    let t = new shapes.Triangle();

### Trade-offs of Modules

Just as there is a one-to-one correspondence between JS files and modules,
TypeScript has a one-to-one correspondence between module source files and
their emitted JS files. One effect of this is that it‚Äôs not possible to
concatenate multiple module source files depending on the module system you
target. For instance, you can‚Äôt use the [`outFile`](/tsconfig#outFile) option
while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it‚Äôs
possible](./release-notes/typescript-1-8.html#concatenate-amd-and-system-
modules-with---outfile) to use [`outFile`](/tsconfig#outFile) when targeting
`amd` or `system`.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Namespaces and
Modules.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(63\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

OT![Orta Therox
\(19\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MH![Mohamed Hegazy
\(19\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

B![Bohdan
\(2\)](https://gravatar.com/avatar/b92a9f915a77b7c3736efbd744c2a302?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Namespaces

> **A note about terminology:** It‚Äôs important to note that in TypeScript 1.5,
> the nomenclature has changed. ‚ÄúInternal modules‚Äù are now ‚Äúnamespaces‚Äù.
> ‚ÄúExternal modules‚Äù are now simply ‚Äúmodules‚Äù, as to align with [ECMAScript
> 2015](https://www.ecma-international.org/ecma-262/6.0/)‚Äôs terminology,
> (namely that `module X {` is equivalent to the now-preferred `namespace X
> {`).

This post outlines the various ways to organize your code using namespaces
(previously ‚Äúinternal modules‚Äù) in TypeScript. As we alluded in our note about
terminology, ‚Äúinternal modules‚Äù are now referred to as ‚Äúnamespaces‚Äù.
Additionally, anywhere the `module` keyword was used when declaring an
internal module, the `namespace` keyword can and should be used instead. This
avoids confusing new users by overloading them with similarly named terms.

## First steps

Let‚Äôs start with the program we‚Äôll be using as our example throughout this
page. We‚Äôve written a small set of simplistic string validators, as you might
write to check a user‚Äôs input on a form in a webpage or check the format of an
externally-provided data file.

## Validators in a single file

    
    
    ts
    
    interface StringValidator {
    
      isAcceptable(s: string): boolean;
    
    }
    
    let lettersRegexp = /^[A-Za-z]+$/;
    
    let numberRegexp = /^[0-9]+$/;
    
    class LettersOnlyValidator implements StringValidator {
    
      isAcceptable(s: string) {
    
        return lettersRegexp.test(s);
    
      }
    
    }
    
    class ZipCodeValidator implements StringValidator {
    
      isAcceptable(s: string) {
    
        return s.length === 5 && numberRegexp.test(s);
    
      }
    
    }
    
    // Some samples to try
    
    let strings = ["Hello", "98052", "101"];
    
    // Validators to use
    
    let validators: { [s: string]: StringValidator } = {};
    
    validators["ZIP code"] = new ZipCodeValidator();
    
    validators["Letters only"] = new LettersOnlyValidator();
    
    // Show whether each string passed each validator
    
    for (let s of strings) {
    
      for (let name in validators) {
    
        let isMatch = validators[name].isAcceptable(s);
    
        console.log(`'${s}' ${isMatch ? "matches" : "does not match"} '${name}'.`);
    
      }
    
    }

## Namespacing

As we add more validators, we‚Äôre going to want to have some kind of
organization scheme so that we can keep track of our types and not worry about
name collisions with other objects. Instead of putting lots of different names
into the global namespace, let‚Äôs wrap up our objects into a namespace.

In this example, we‚Äôll move all validator-related entities into a namespace
called `Validation`. Because we want the interfaces and classes here to be
visible outside the namespace, we preface them with `export`. Conversely, the
variables `lettersRegexp` and `numberRegexp` are implementation details, so
they are left unexported and will not be visible to code outside the
namespace. In the test code at the bottom of the file, we now need to qualify
the names of the types when used outside the namespace, e.g.
`Validation.LettersOnlyValidator`.

## Namespaced Validators

    
    
    ts
    
    namespace Validation {
    
      export interface StringValidator {
    
        isAcceptable(s: string): boolean;
    
      }
    
      const lettersRegexp = /^[A-Za-z]+$/;
    
      const numberRegexp = /^[0-9]+$/;
    
      export class LettersOnlyValidator implements StringValidator {
    
        isAcceptable(s: string) {
    
          return lettersRegexp.test(s);
    
        }
    
      }
    
      export class ZipCodeValidator implements StringValidator {
    
        isAcceptable(s: string) {
    
          return s.length === 5 && numberRegexp.test(s);
    
        }
    
      }
    
    }
    
    // Some samples to try
    
    let strings = ["Hello", "98052", "101"];
    
    // Validators to use
    
    let validators: { [s: string]: Validation.StringValidator } = {};
    
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    
    validators["Letters only"] = new Validation.LettersOnlyValidator();
    
    // Show whether each string passed each validator
    
    for (let s of strings) {
    
      for (let name in validators) {
    
        console.log(
    
          `"${s}" - ${
    
            validators[name].isAcceptable(s) ? "matches" : "does not match"
    
          } ${name}`
    
        );
    
      }
    
    }

## Splitting Across Files

As our application grows, we‚Äôll want to split the code across multiple files
to make it easier to maintain.

## Multi-file namespaces

Here, we‚Äôll split our `Validation` namespace across many files. Even though
the files are separate, they can each contribute to the same namespace and can
be consumed as if they were all defined in one place. Because there are
dependencies between files, we‚Äôll add reference tags to tell the compiler
about the relationships between the files. Our test code is otherwise
unchanged.

##### Validation.ts

    
    
    ts
    
    namespace Validation {
    
      export interface StringValidator {
    
        isAcceptable(s: string): boolean;
    
      }
    
    }

##### LettersOnlyValidator.ts

    
    
    ts
    
    /// <reference path="Validation.ts" />
    
    namespace Validation {
    
      const lettersRegexp = /^[A-Za-z]+$/;
    
      export class LettersOnlyValidator implements StringValidator {
    
        isAcceptable(s: string) {
    
          return lettersRegexp.test(s);
    
        }
    
      }
    
    }

##### ZipCodeValidator.ts

    
    
    ts
    
    /// <reference path="Validation.ts" />
    
    namespace Validation {
    
      const numberRegexp = /^[0-9]+$/;
    
      export class ZipCodeValidator implements StringValidator {
    
        isAcceptable(s: string) {
    
          return s.length === 5 && numberRegexp.test(s);
    
        }
    
      }
    
    }

##### Test.ts

    
    
    ts
    
    /// <reference path="Validation.ts" />
    
    /// <reference path="LettersOnlyValidator.ts" />
    
    /// <reference path="ZipCodeValidator.ts" />
    
    // Some samples to try
    
    let strings = ["Hello", "98052", "101"];
    
    // Validators to use
    
    let validators: { [s: string]: Validation.StringValidator } = {};
    
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    
    validators["Letters only"] = new Validation.LettersOnlyValidator();
    
    // Show whether each string passed each validator
    
    for (let s of strings) {
    
      for (let name in validators) {
    
        console.log(
    
          `"${s}" - ${
    
            validators[name].isAcceptable(s) ? "matches" : "does not match"
    
          } ${name}`
    
        );
    
      }
    
    }

Once there are multiple files involved, we‚Äôll need to make sure all of the
compiled code gets loaded. There are two ways of doing this.

First, we can use concatenated output using the [`outFile`](/tsconfig#outFile)
option to compile all of the input files into a single JavaScript output file:

    
    
    tsc --outFile sample.js Test.ts

The compiler will automatically order the output file based on the reference
tags present in the files. You can also specify each file individually:

    
    
    tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts

Alternatively, we can use per-file compilation (the default) to emit one
JavaScript file for each input file. If multiple JS files get produced, we‚Äôll
need to use `<script>` tags on our webpage to load each emitted file in the
appropriate order, for example:

##### MyTestPage.html (excerpt)

    
    
    html
    
    <script src="Validation.js" type="text/javascript" />
    
    <script src="LettersOnlyValidator.js" type="text/javascript" />
    
    <script src="ZipCodeValidator.js" type="text/javascript" />
    
    <script src="Test.js" type="text/javascript" />

## Aliases

Another way that you can simplify working with namespaces is to use `import q
= x.y.z` to create shorter names for commonly-used objects. Not to be confused
with the `import x = require("name")` syntax used to load modules, this syntax
simply creates an alias for the specified symbol. You can use these sorts of
imports (commonly referred to as aliases) for any kind of identifier,
including objects created from module imports.

    
    
    ts
    
    namespace Shapes {
    
      export namespace Polygons {
    
        export class Triangle {}
    
        export class Square {}
    
      }
    
    }
    
    import polygons = Shapes.Polygons;
    
    let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'

Notice that we don‚Äôt use the `require` keyword; instead we assign directly
from the qualified name of the symbol we‚Äôre importing. This is similar to
using `var`, but also works on the type and namespace meanings of the imported
symbol. Importantly, for values, `import` is a distinct reference from the
original symbol, so changes to an aliased `var` will not be reflected in the
original variable.

## Working with Other JavaScript Libraries

To describe the shape of libraries not written in TypeScript, we need to
declare the API that the library exposes. Because most JavaScript libraries
expose only a few top-level objects, namespaces are a good way to represent
them.

We call declarations that don‚Äôt define an implementation ‚Äúambient‚Äù. Typically
these are defined in `.d.ts` files. If you‚Äôre familiar with C/C++, you can
think of these as `.h` files. Let‚Äôs look at a few examples.

## Ambient Namespaces

The popular library D3 defines its functionality in a global object called
`d3`. Because this library is loaded through a `<script>` tag (instead of a
module loader), its declaration uses namespaces to define its shape. For the
TypeScript compiler to see this shape, we use an ambient namespace
declaration. For example, we could begin writing it as follows:

##### D3.d.ts (simplified excerpt)

    
    
    ts
    
    declare namespace D3 {
    
      export interface Selectors {
    
        select: {
    
          (selector: string): Selection;
    
          (element: EventTarget): Selection;
    
        };
    
      }
    
      export interface Event {
    
        x: number;
    
        y: number;
    
      }
    
      export interface Base extends Selectors {
    
        event: Event;
    
      }
    
    }
    
    declare var d3: D3.Base;

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Namespaces.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(56\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(3\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

14+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Nightly Builds

A nightly build from the [TypeScript‚Äôs
`main`](https://github.com/Microsoft/TypeScript/tree/main) branch is published
by midnight PST to npm. Here is how you can get it and use it with your tools.

## Using npm

    
    
    shell
    
    npm install -D typescript@next

## Updating your IDE to use the nightly builds

You can also update your editor/IDE to use the nightly drop. You will
typically need to install the package through npm. The rest of this section
mostly assumes `typescript@next` is already installed.

### Visual Studio Code

The VS Code website [has documentation on selecting a workspace version of
TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-
newer-typescript-versions). After installing a nightly version of TypeScript
in your workspace, you can follow directions there, or simply update your
workspace settings in the JSON view. A direct way to do this is to open or
create your workspace‚Äôs `.vscode/settings.json` and add the following
property:

    
    
    json
    
    "typescript.tsdk": "<path to your folder>/node_modules/typescript/lib"

Alternatively, if you simply want to run the nightly editing experience for
JavaScript and TypeScript in Visual Studio Code without changing your
workspace version, you can run the [JavaScript and TypeScript Nightly
Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-
vscode.vscode-typescript-next)

### Sublime Text

Update the `Settings - User` file with the following:

    
    
    json
    
    "typescript_tsdk": "<path to your folder>/node_modules/typescript/lib"

More information is available at the [TypeScript Plugin for Sublime Text
installation documentation](https://github.com/Microsoft/TypeScript-Sublime-
Plugin#installation).

### Visual Studio 2013 and 2015

> Note: Most changes do not require you to install a new version of the VS
> TypeScript plugin.

The nightly build currently does not include the full plugin setup, but we are
working on publishing an installer on a nightly basis as well.

  1. Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1) script.

> Also see our wiki page on [using a custom language service
> file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-
> Studio#using-a-custom-language-service-file).

  2. From a PowerShell command window, run:

For VS 2015:

    
    
    VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib

For VS 2013:

    
    
    VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib

### IntelliJ IDEA (Mac)

Go to `Preferences` > `Languages & Frameworks` > `TypeScript`:

> TypeScript Version: If you installed with npm:
> `/usr/local/lib/node_modules/typescript/lib`

### IntelliJ IDEA (Windows)

Go to `File` > `Settings` > `Languages & Frameworks` > `TypeScript`:

> TypeScript Version: If you installed with npm:
> `C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib`

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/Nightly Builds.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

S![StefanRein
\(2\)](https://gravatar.com/avatar/078daaad2c37d829a53e4db1827c0961?s=32&&d=blank)

DR![Daniel Rosenwasser
\(1\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

NS![Nihaal Sangha
\(1\)](https://gravatar.com/avatar/d63f6ce49de267fe0f4f1e91f764a37a?s=32&&d=blank)

4+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Project References

Project references are a new feature in TypeScript 3.0 that allow you to
structure your TypeScript programs into smaller pieces.

By doing this, you can greatly improve build times, enforce logical separation
between components, and organize your code in new and better ways.

We‚Äôre also introducing a new mode for `tsc`, the `--build` flag, that works
hand in hand with project references to enable faster TypeScript builds.

## An Example Project

Let‚Äôs look at a fairly normal program and see how project references can help
us better organize it. Imagine you have a project with two modules,
`converter` and `units`, and a corresponding test file for each:

    
    
    /
    
    ‚îú‚îÄ‚îÄ src/
    
    ‚îÇ   ‚îú‚îÄ‚îÄ converter.ts
    
    ‚îÇ   ‚îî‚îÄ‚îÄ units.ts
    
    ‚îú‚îÄ‚îÄ test/
    
    ‚îÇ   ‚îú‚îÄ‚îÄ converter-tests.ts
    
    ‚îÇ   ‚îî‚îÄ‚îÄ units-tests.ts
    
    ‚îî‚îÄ‚îÄ tsconfig.json

The test files import the implementation files and do some testing:

    
    
    ts
    
    // converter-tests.ts
    
    import * as converter from "../src/converter";
    
    assert.areEqual(converter.celsiusToFahrenheit(0), 32);

Previously, this structure was rather awkward to work with if you used a
single tsconfig file:

  * It was possible for the implementation files to import the test files
  * It wasn‚Äôt possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don‚Äôt want
  * Changing just the _internals_ in the implementation files required _typechecking_ the tests again, even though this wouldn‚Äôt ever cause new errors
  * Changing just the tests required typechecking the implementation again, even if nothing changed

You could use multiple tsconfig files to solve _some_ of those problems, but
new ones would appear:

  * There‚Äôs no built-in up-to-date checking, so you end up always running `tsc` twice
  * Invoking `tsc` twice incurs more startup time overhead
  * `tsc -w` can‚Äôt run on multiple config files at once

Project references can solve all of these problems and more.

## What is a Project Reference?

`tsconfig.json` files have a new top-level property,
[`references`](/tsconfig#references). It‚Äôs an array of objects that specifies
projects to reference:

    
    
    js
    
    {
    
        "compilerOptions": {
    
            // The usual
    
        },
    
        "references": [
    
            { "path": "../src" }
    
        ]
    
    }

The `path` property of each reference can point to a directory containing a
`tsconfig.json` file, or to the config file itself (which may have any name).

When you reference a project, new things happen:

  * Importing modules from a referenced project will instead load its _output_ declaration file (`.d.ts`)
  * If the referenced project produces an [`outFile`](/tsconfig#outFile), the output file `.d.ts` file‚Äôs declarations will be visible in this project
  * Build mode (see below) will automatically build the referenced project if needed

By separating into multiple projects, you can greatly improve the speed of
typechecking and compiling, reduce memory usage when using an editor, and
improve enforcement of the logical groupings of your program.

## `composite`

Referenced projects must have the new [`composite`](/tsconfig#composite)
setting enabled. This setting is needed to ensure TypeScript can quickly
determine where to find the outputs of the referenced project. Enabling the
[`composite`](/tsconfig#composite) flag changes a few things:

  * The [`rootDir`](/tsconfig#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig` file
  * All implementation files must be matched by an [`include`](/tsconfig#include) pattern or listed in the [`files`](/tsconfig#files) array. If this constraint is violated, `tsc` will inform you which files weren‚Äôt specified
  * [`declaration`](/tsconfig#declaration) must be turned on

## `declarationMap`

We‚Äôve also added support for [declaration source
maps](https://github.com/Microsoft/TypeScript/issues/14479). If you enable
[`declarationMap`](/tsconfig#declarationMap), you‚Äôll be able to use editor
features like ‚ÄúGo to Definition‚Äù and Rename to transparently navigate and edit
code across project boundaries in supported editors.

## `prepend` with `outFile`

You can also enable prepending the output of a dependency using the `prepend`
option in a reference:

    
    
    js
    
       "references": [
    
           { "path": "../utils", "prepend": true }
    
       ]

Prepending a project will include the project‚Äôs output above the output of the
current project. All output files (`.js`, `.d.ts`, `.js.map`, `.d.ts.map`)
will be emitted correctly.

`tsc` will only ever use existing files on disk to do this process, so it‚Äôs
possible to create a project where a correct output file can‚Äôt be generated
because some project‚Äôs output would be present more than once in the resulting
file. For example:

    
    
    txt
    
       A
    
      ^ ^
    
     /   \
    
    B     C
    
     ^   ^
    
      \ /
    
       D

It‚Äôs important in this situation to not prepend at each reference, because
you‚Äôll end up with two copies of `A` in the output of `D` \- this can lead to
unexpected results.

## Caveats for Project References

Project references have a few trade-offs you should be aware of.

Because dependent projects make use of `.d.ts` files that are built from their
dependencies, you‚Äôll either have to check in certain build outputs _or_ build
a project after cloning it before you can navigate the project in an editor
without seeing spurious errors.

When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory
`.d.ts` generation process that should be able to mitigate this, but it has
some perf implications. For very large composite projects you might want to
disable this using [disableSourceOfProjectReferenceRedirect
option](/tsconfig#disableSourceOfProjectReferenceRedirect).

Additionally, to preserve compatibility with existing build workflows, `tsc`
will _not_ automatically build dependencies unless invoked with the `--build`
switch. Let‚Äôs learn more about `--build`.

## Build Mode for TypeScript

A long-awaited feature is smart incremental builds for TypeScript projects. In
3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry
point for `tsc` that behaves more like a build orchestrator than a simple
compiler.

Running `tsc --build` (`tsc -b` for short) will do the following:

  * Find all referenced projects
  * Detect if they are up-to-date
  * Build out-of-date projects in the correct order

You can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src
test`). Just like `tsc -p`, specifying the config file name itself is
unnecessary if it‚Äôs named `tsconfig.json`.

### `tsc -b` Commandline

You can specify any number of config files:

    
    
    shell
    
     > tsc -b                            # Use the tsconfig.json in the current directory
    
     > tsc -b src                        # Use src/tsconfig.json
    
     > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json

Don‚Äôt worry about ordering the files you pass on the commandline - `tsc` will
re-order them if needed so that dependencies are always built first.

There are also some flags specific to `tsc -b`:

  * [`--verbose`](/tsconfig#verbose): Prints out verbose logging to explain what‚Äôs going on (may be combined with any other flag)
  * `--dry`: Shows what would be done but doesn‚Äôt actually build anything
  * `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)
  * [`--force`](/tsconfig#force): Act as if all projects are out of date
  * `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](/tsconfig#verbose))

## Caveats

Normally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of
syntax or type errors, unless [`noEmitOnError`](/tsconfig#noEmitOnError) is
on. Doing this in an incremental build system would be very bad - if one of
your out-of-date dependencies had a new error, you‚Äôd only see it _once_
because a subsequent build would skip building the now up-to-date project. For
this reason, `tsc -b` effectively acts as if
[`noEmitOnError`](/tsconfig#noEmitOnError) is enabled for all projects.

If you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may
need to run a [`--force`](/tsconfig#force) build after certain source control
operations depending on whether your source control tool preserves timestamps
between the local copy and the remote copy.

## MSBuild

If you have an msbuild project, you can enable build mode by adding

    
    
    xml
    
        <TypeScriptBuildMode>true</TypeScriptBuildMode>

to your proj file. This will enable automatic incremental build as well as
cleaning.

Note that as with `tsconfig.json` / `-p`, existing TypeScript project
properties will not be respected - all settings should be managed using your
tsconfig file.

Some teams have set up msbuild-based workflows wherein tsconfig files have the
same _implicit_ graph ordering as the managed projects they are paired with.
If your solution is like this, you can continue to use `msbuild` with `tsc -p`
along with project references; these are fully interoperable.

## Guidance

### Overall Structure

With more `tsconfig.json` files, you‚Äôll usually want to use [Configuration
file inheritance](/docs/handbook/tsconfig-json.html) to centralize your common
compiler options. This way you can change a setting in one file rather than
having to edit multiple files.

Another good practice is to have a ‚Äúsolution‚Äù `tsconfig.json` file that simply
has [`references`](/tsconfig#references) to all of your leaf-node projects and
sets [`files`](/tsconfig#files) to an empty array (otherwise the solution file
will cause double compilation of files). Note that starting with 3.0, it is no
longer an error to have an empty [`files`](/tsconfig#files) array if you have
at least one `reference` in a `tsconfig.json` file.

This presents a simple entry point; e.g. in the TypeScript repo we simply run
`tsc -b src` to build all endpoints because we list all the subprojects in
`src/tsconfig.json`

You can see these patterns in the TypeScript repo - see
`src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as
key examples.

### Structuring for relative modules

In general, not much is needed to transition a repo using relative modules.
Simply place a `tsconfig.json` file in each subdirectory of a given parent
folder, and add `reference`s to these config files to match the intended
layering of the program. You will need to either set the
[`outDir`](/tsconfig#outDir) to an explicit subfolder of the output folder, or
set the [`rootDir`](/tsconfig#rootDir) to the common root of all project
folders.

### Structuring for outFiles

Layout for compilations using [`outFile`](/tsconfig#outFile) is more flexible
because relative paths don‚Äôt matter as much. One thing to keep in mind is that
you‚Äôll generally want to not use `prepend` until the ‚Äúlast‚Äù project - this
will improve build times and reduce the amount of I/O needed in any given
build. The TypeScript repo itself is a good reference here - we have some
‚Äúlibrary‚Äù projects and some ‚Äúendpoint‚Äù projects; ‚Äúendpoint‚Äù projects are kept
as small as possible and pull in only the libraries they need.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Project
References.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(18\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RC![Ryan Cavanaugh
\(3\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

G![GiovanniCaiazzo01
\(1\)](https://gravatar.com/avatar/acd64792e07bde3f07c33056006c7153?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

20+

Last updated: Sep 16, 2024  
  

   Was this page helpful?

# TypeScript 1.1

## Performance Improvements

The 1.1 compiler is typically around 4x faster than any previous release. See
[this blog post for some impressive
charts.](https://web.archive.org/web/20141007020020/http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-
typescript-1-1-ctp.aspx)

## Better Module Visibility Rules

TypeScript now only strictly enforces the visibility of types in modules if
the [`declaration`](/tsconfig#declaration) flag is provided. This is very
useful for Angular scenarios, for example:

    
    
    ts
    
    module MyControllers {
    
      interface ZooScope extends ng.IScope {
    
        animals: Animal[];
    
      }
    
      export class ZooController {
    
        // Used to be an error (cannot expose ZooScope), but now is only
    
        // an error when trying to generate .d.ts files
    
        constructor(public $scope: ZooScope) {}
    
        /* more code */
    
      }
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.1.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MHK![Mohammad Humayun Khan
\(1\)](https://gravatar.com/avatar/91deae6322d5d6c71d451722efc431e1?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.3

## Protected

The new `protected` modifier in classes works like it does in familiar
languages like C++, C#, and Java. A `protected` member of a class is visible
only inside subclasses of the class in which it is declared:

    
    
    ts
    
    class Thing {
    
      protected doSomething() {
    
        /* ... */
    
      }
    
    }
    
    class MyThing extends Thing {
    
      public myMethod() {
    
        // OK, can access protected member from subclass
    
        this.doSomething();
    
      }
    
    }
    
    var t = new MyThing();
    
    t.doSomething(); // Error, cannot call protected member from outside class

## Tuple types

Tuple types express an array where the type of certain elements is known, but
need not be the same. For example, you may want to represent an array with a
`string` at position 0 and a `number` at position 1:

    
    
    ts
    
    // Declare a tuple type
    
    var x: [string, number];
    
    // Initialize it
    
    x = ["hello", 10]; // OK
    
    // Initialize it incorrectly
    
    x = [10, "hello"]; // Error

When accessing an element with a known index, the correct type is retrieved:

    
    
    ts
    
    console.log(x[0].substr(1)); // OK
    
    console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'

Note that in TypeScript 1.4, when accessing an element outside the set of
known indices, a union type is used instead:

    
    
    ts
    
    x[3] = "world"; // OK
    
    console.log(x[5].toString()); // OK, 'string' and 'number' both have toString
    
    x[6] = true; // Error, boolean isn't number or string

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.3.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.4

## Union types

### Overview

Union types are a powerful way to express a value that can be one of several
types. For example, you might have an API for running a program that takes a
commandline as either a `string`, a `string[]` or a function that returns a
`string`. You can now write:

    
    
    ts
    
    interface RunOptions {
    
      program: string;
    
      commandline: string[] | string | (() => string);
    
    }

Assignment to union types works very intuitively ‚Äî anything you could assign
to one of the union type‚Äôs members is assignable to the union:

    
    
    ts
    
    var opts: RunOptions = /* ... */;
    
    opts.commandline = '-hello world'; // OK
    
    opts.commandline = ['-hello', 'world']; // OK
    
    opts.commandline = [42]; // Error, number is not string or string[]

When reading from a union type, you can see any properties that are shared by
them:

    
    
    ts
    
    if (opts.commandline.length === 0) {
    
      // OK, string and string[] both have 'length' property
    
      console.log("it's empty");
    
    }

Using Type Guards, you can easily work with a variable of a union type:

    
    
    ts
    
    function formatCommandline(c: string | string[]) {
    
      if (typeof c === "string") {
    
        return c.trim();
    
      } else {
    
        return c.join(" ");
    
      }
    
    }

### Stricter Generics

With union types able to represent a wide range of type scenarios, we‚Äôve
decided to improve the strictness of certain generic calls. Previously, code
like this would (surprisingly) compile without error:

    
    
    ts
    
    function equal<T>(lhs: T, rhs: T): boolean {
    
      return lhs === rhs;
    
    }
    
    // Previously: No error
    
    // New behavior: Error, no best common type between 'string' and 'number'
    
    var e = equal(42, "hello");

With union types, you can now specify the desired behavior at both the
function declaration site and the call site:

    
    
    ts
    
    // 'choose' function where types must match
    
    function choose1<T>(a: T, b: T): T {
    
      return Math.random() > 0.5 ? a : b;
    
    }
    
    var a = choose1("hello", 42); // Error
    
    var b = choose1<string | number>("hello", 42); // OK
    
    // 'choose' function where types need not match
    
    function choose2<T, U>(a: T, b: U): T | U {
    
      return Math.random() > 0.5 ? a : b;
    
    }
    
    var c = choose2("bar", "foo"); // OK, c: string
    
    var d = choose2("hello", 42); // OK, d: string|number

### Better Type Inference

Union types also allow for better type inference in arrays and other places
where you might have multiple kinds of values in a collection:

    
    
    ts
    
    var x = [1, "hello"]; // x: Array<string|number>
    
    x[0] = "world"; // OK
    
    x[0] = false; // Error, boolean is not string or number

## `let` declarations

In JavaScript, `var` declarations are ‚Äúhoisted‚Äù to the top of their enclosing
scope. This can result in confusing bugs:

    
    
    ts
    
    console.log(x); // meant to write 'y' here
    
    /* later in the same block */
    
    var x = "hello";

The new ES6 keyword `let`, now supported in TypeScript, declares a variable
with more intuitive ‚Äúblock‚Äù semantics. A `let` variable can only be referred
to after its declaration, and is scoped to the syntactic block where it is
defined:

    
    
    ts
    
    if (foo) {
    
      console.log(x); // Error, cannot refer to x before its declaration
    
      let x = "hello";
    
    } else {
    
      console.log(x); // Error, x is not declared in this block
    
    }

`let` is only available when targeting ECMAScript 6 (`--target ES6`).

## `const` declarations

The other new ES6 declaration type supported in TypeScript is `const`. A
`const` variable may not be assigned to, and must be initialized where it is
declared. This is useful for declarations where you don‚Äôt want to change the
value after its initialization:

    
    
    ts
    
    const halfPi = Math.PI / 2;
    
    halfPi = 2; // Error, can't assign to a `const`

`const` is only available when targeting ECMAScript 6 (`--target ES6`).

## Template strings

TypeScript now supports ES6 template strings. These are an easy way to embed
arbitrary expressions in strings:

    
    
    ts
    
    var name = "TypeScript";
    
    var greeting = `Hello, ${name}! Your name has ${name.length} characters`;

When compiling to pre-ES6 targets, the string is decomposed:

    
    
    js
    
    var name = "TypeScript!";
    
    var greeting =
    
      "Hello, " + name + "! Your name has " + name.length + " characters";

## Type Guards

A common pattern in JavaScript is to use `typeof` or `instanceof` to examine
the type of an expression at runtime. TypeScript now understands these
conditions and will change type inference accordingly when used in an `if`
block.

Using `typeof` to test a variable:

    
    
    ts
    
    var x: any = /* ... */;
    
    if(typeof x === 'string') {
    
        console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'
    
    }
    
    // x is still any here
    
    x.unknown(); // OK

Using `typeof` with union types and `else`:

    
    
    ts
    
    var x: string | HTMLElement = /* ... */;
    
    if(typeof x === 'string') {
    
        // x is string here, as shown above
    
    }
    
    else {
    
        // x is HTMLElement here
    
        console.log(x.innerHTML);
    
    }

Using `instanceof` with classes and union types:

    
    
    ts
    
    class Dog { woof() { } }
    
    class Cat { meow() { } }
    
    var pet: Dog|Cat = /* ... */;
    
    if (pet instanceof Dog) {
    
        pet.woof(); // OK
    
    }
    
    else {
    
        pet.woof(); // Error
    
    }

## Type Aliases

You can now define an _alias_ for a type using the `type` keyword:

    
    
    ts
    
    type PrimitiveArray = Array<string | number | boolean>;
    
    type MyNumber = number;
    
    type NgScope = ng.IScope;
    
    type Callback = () => void;

Type aliases are exactly the same as their original types; they are simply
alternative names.

## `const enum` (completely inlined enums)

Enums are very useful, but some programs don‚Äôt actually need the generated
code and would benefit from simply inlining all instances of enum members with
their numeric equivalents. The new `const enum` declaration works just like a
regular `enum` for type safety, but erases completely at compile time.

    
    
    ts
    
    const enum Suit {
    
      Clubs,
    
      Diamonds,
    
      Hearts,
    
      Spades
    
    }
    
    var d = Suit.Diamonds;

Compiles to exactly:

    
    
    js
    
    var d = 1;

TypeScript will also now compute enum values when possible:

    
    
    ts
    
    enum MyFlags {
    
      None = 0,
    
      Neat = 1,
    
      Cool = 2,
    
      Awesome = 4,
    
      Best = Neat | Cool | Awesome
    
    }
    
    var b = MyFlags.Best; // emits var b = 7;

## `-noEmitOnError` commandline option

The default behavior for the TypeScript compiler is to still emit .js files if
there were type errors (for example, an attempt to assign a `string` to a
`number`). This can be undesirable on build servers or other scenarios where
only output from a ‚Äúclean‚Äù build is desired. The new flag
[`noEmitOnError`](/tsconfig#noEmitOnError) prevents the compiler from emitting
.js code if there were any errors.

This is now the default for MSBuild projects; this allows MSBuild incremental
build to work as expected, as outputs are only generated on clean builds.

## AMD Module names

By default AMD modules are generated anonymous. This can lead to problems when
other tools are used to process the resulting modules like a bundlers (e.g.
`r.js`).

The new `amd-module name` tag allows passing an optional module name to the
compiler:

    
    
    ts
    
    //// [amdModule.ts]
    
    ///<amd-module name='NamedModule'/>
    
    export class C {}

Will result in assigning the name `NamedModule` to the module as part of
calling the AMD `define`:

    
    
    js
    
    //// [amdModule.js]
    
    define("NamedModule", ["require", "exports"], function(require, exports) {
    
      var C = (function() {
    
        function C() {}
    
        return C;
    
      })();
    
      exports.C = C;
    
    });

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.4.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

YY![Yue Yang
\(1\)](https://gravatar.com/avatar/92192244766598168d17845861a4ebdb?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.5

## ES6 Modules

TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are
effectively TypeScript external modules with a new syntax: ES6 modules are
separately loaded source files that possibly import other modules and provide
a number of externally accessible exports. ES6 modules feature several new
export and import declarations. It is recommended that TypeScript libraries
and applications be updated to use the new syntax, but this is not a
requirement. The new ES6 module syntax coexists with TypeScript‚Äôs original
internal and external module constructs and the constructs can be mixed and
matched at will.

#### Export Declarations

In addition to the existing TypeScript support for decorating declarations
with `export`, module members can also be exported using separate export
declarations, optionally specifying different names for exports using `as`
clauses.

    
    
    ts
    
    interface Stream { ... }
    
    function writeToStream(stream: Stream, data: string) { ... }
    
    export { Stream, writeToStream as write };  // writeToStream exported as write

Import declarations, as well, can optionally use `as` clauses to specify
different local names for the imports. For example:

    
    
    ts
    
    import { read, write, standardOutput as stdout } from "./inout";
    
    var s = read(stdout);
    
    write(stdout, s);

As an alternative to individual imports, a namespace import can be used to
import an entire module:

    
    
    ts
    
    import * as io from "./inout";
    
    var s = io.read(io.standardOutput);
    
    io.write(io.standardOutput, s);

#### Re-exporting

Using `from` clause a module can copy the exports of a given module to the
current module without introducing local names.

    
    
    ts
    
    export { read, write, standardOutput as stdout } from "./inout";

`export *` can be used to re-export all exports of another module. This is
useful for creating modules that aggregate the exports of several other
modules.

    
    
    ts
    
    export function transform(s: string): string { ... }
    
    export * from "./mod1";
    
    export * from "./mod2";

#### Default Export

An export default declaration specifies an expression that becomes the default
export of a module:

    
    
    ts
    
    export default class Greeter {
    
      sayHello() {
    
        console.log("Greetings!");
    
      }
    
    }

Which in turn can be imported using default imports:

    
    
    ts
    
    import Greeter from "./greeter";
    
    var g = new Greeter();
    
    g.sayHello();

#### Bare Import

A ‚Äúbare import‚Äù can be used to import a module only for its side-effects.

    
    
    ts
    
    import "./polyfills";

For more information about module, please see the [ES6 module support
spec](https://github.com/Microsoft/TypeScript/issues/2242).

## Destructuring in declarations and assignments

TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.

#### Declarations

A destructuring declaration introduces one or more named variables and
initializes them with values extracted from properties of an object or
elements of an array.

For example, the following sample declares variables `x`, `y`, and `z`, and
initializes them to `getSomeObject().x`, `getSomeObject().y` and
`getSomeObject().z` respectively:

    
    
    ts
    
    var { x, y, z } = getSomeObject();

Destructuring declarations also works for extracting values from arrays:

    
    
    ts
    
    var [x, y, z = 10] = getSomeArray();

Similarly, destructuring can be used in function parameter declarations:

    
    
    ts
    
    function drawText({ text = "", location: [x, y] = [0, 0], bold = false }) {
    
      // Draw text
    
    }
    
    // Call drawText with an object literal
    
    var item = { text: "someText", location: [1, 2, 3], style: "italics" };
    
    drawText(item);

#### Assignments

Destructuring patterns can also be used in regular assignment expressions. For
instance, swapping two variables can be written as a single destructuring
assignment:

    
    
    ts
    
    var x = 1;
    
    var y = 2;
    
    [x, y] = [y, x];

## `namespace` keyword

TypeScript used the `module` keyword to define both ‚Äúinternal modules‚Äù and
‚Äúexternal modules‚Äù; this has been a bit of confusion for developers new to
TypeScript. ‚ÄúInternal modules‚Äù are closer to what most people would call a
namespace; likewise, ‚Äúexternal modules‚Äù in JS speak really just are modules
now.

> Note: Previous syntax defining internal modules are still supported.

**Before** :

    
    
    ts
    
    module Math {
    
        export function add(x, y) { ... }
    
    }

**After** :

    
    
    ts
    
    namespace Math {
    
        export function add(x, y) { ... }
    
    }

## `let` and `const` support

ES6 `let` and `const` declarations are now supported when targeting ES3 and
ES5.

#### Const

    
    
    ts
    
    const MAX = 100;
    
    ++MAX; // Error: The operand of an increment or decrement
    
    //        operator cannot be a constant.

#### Block scoped

    
    
    ts
    
    if (true) {
    
      let a = 4;
    
      // use a
    
    } else {
    
      let a = "string";
    
      // use a
    
    }
    
    alert(a); // Error: a is not defined in this scope.

## for..of support

TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well
as full support for Iterator interfaces when targeting ES6.

##### Example

The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5
JavaScript when targeting those versions:

    
    
    ts
    
    for (var v of expr) {
    
    }

will be emitted as:

    
    
    js
    
    for (var _i = 0, _a = expr; _i < _a.length; _i++) {
    
      var v = _a[_i];
    
    }

## Decorators

> TypeScript decorators are based on the [ES7 decorator
> proposal](https://github.com/wycats/javascript-decorators).

A decorator is:

  * an expression
  * that evaluates to a function
  * that takes the target, name, and property descriptor as arguments
  * and optionally returns a property descriptor to install on the target object

> For more information, please see the
> [Decorators](https://github.com/Microsoft/TypeScript/issues/2249) proposal.

##### Example

Decorators `readonly` and `enumerable(false)` will be applied to the property
`method` before it is installed on class `C`. This allows the decorator to
change the implementation, and in this case, augment the descriptor to be
writable: false and enumerable: false.

    
    
    ts
    
    class C {
    
      @readonly
    
      @enumerable(false)
    
      method() { ... }
    
    }
    
    function readonly(target, key, descriptor) {
    
        descriptor.writable = false;
    
    }
    
    function enumerable(value) {
    
        return function (target, key, descriptor) {
    
            descriptor.enumerable = value;
    
        };
    
    }

## Computed properties

Initializing an object with dynamic properties can be a bit of a burden. Take
the following example:

    
    
    ts
    
    type NeighborMap = { [name: string]: Node };
    
    type Node = { name: string; neighbors: NeighborMap };
    
    function makeNode(name: string, initialNeighbor: Node): Node {
    
      var neighbors: NeighborMap = {};
    
      neighbors[initialNeighbor.name] = initialNeighbor;
    
      return { name: name, neighbors: neighbors };
    
    }

Here we need to create a variable to hold on to the neighbor-map so that we
can initialize it. With TypeScript 1.5, we can let the compiler do the heavy
lifting:

    
    
    ts
    
    function makeNode(name: string, initialNeighbor: Node): Node {
    
      return {
    
        name: name,
    
        neighbors: {
    
          [initialNeighbor.name]: initialNeighbor,
    
        },
    
      };
    
    }

## Support for `UMD` and `System` module output

In addition to `AMD` and `CommonJS` module loaders, TypeScript now supports
emitting modules `UMD` ([Universal Module
Definition](https://github.com/umdjs/umd)) and
[`System`](https://github.com/systemjs/systemjs) module formats.

**Usage** :

> tsc ‚Äîmodule umd

and

> tsc ‚Äîmodule system

## Unicode codepoint escapes in strings

ES6 introduces escapes that allow users to represent a Unicode codepoint using
just a single escape.

As an example, consider the need to escape a string that contains the
character ‚Äô†Æ∑‚Äò. In UTF-16/UCS2, ‚Äô†Æ∑‚Äô is represented as a surrogate pair, meaning
that it‚Äôs encoded using a pair of 16-bit code units of values, specifically
`0xD842` and `0xDFB7`. Previously this meant that you‚Äôd have to escape the
codepoint as `"\uD842\uDFB7"`. This has the major downside that it‚Äôs difficult
to discern two independent characters from a surrogate pair.

With ES6‚Äôs codepoint escapes, you can cleanly represent that exact character
in strings and template strings with a single escape: `"\u{20bb7}"`.
TypeScript will emit the string in ES3/ES5 as `"\uD842\uDFB7"`.

## Tagged template strings in ES3/ES5

In TypeScript 1.4, we added support for template strings for all targets, and
tagged templates for just ES6. Thanks to some considerable work done by
[@ivogabe](https://github.com/ivogabe), we bridged the gap for for tagged
templates in ES3 and ES5.

When targeting ES3/ES5, the following code

    
    
    ts
    
    function oddRawStrings(strs: TemplateStringsArray, n1, n2) {
    
      return strs.raw.filter((raw, index) => index % 2 === 1);
    
    }
    
    oddRawStrings`Hello \n${123} \t ${456}\n world`;

will be emitted as

    
    
    js
    
    function oddRawStrings(strs, n1, n2) {
    
      return strs.raw.filter(function (raw, index) {
    
        return index % 2 === 1;
    
      });
    
    }
    
    (_a = ["Hello \n", " \t ", "\n world"]),
    
      (_a.raw = ["Hello \\n", " \\t ", "\\n world"]),
    
      oddRawStrings(_a, 123, 456);
    
    var _a;

## AMD-dependency optional names

`/// <amd-dependency path="x" />` informs the compiler about a non-TS module
dependency that needs to be injected in the resulting module‚Äôs require call;
however, there was no way to consume this module in the TS code.

The new `amd-dependency name` property allows passing an optional name for an
amd-dependency:

    
    
    ts
    
    /// <amd-dependency path="legacy/moduleA" name="moduleA"/>
    
    declare var moduleA: MyType;
    
    moduleA.callStuff();

Generated JS code:

    
    
    js
    
    define(["require", "exports", "legacy/moduleA"], function (
    
      require,
    
      exports,
    
      moduleA
    
    ) {
    
      moduleA.callStuff();
    
    });

## Project support through `tsconfig.json`

Adding a `tsconfig.json` file in a directory indicates that the directory is
the root of a TypeScript project. The tsconfig.json file specifies the root
files and the compiler options required to compile the project. A project is
compiled in one of the following ways:

  * By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.
  * By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.

##### Example

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
    
      }
    
    }

See the [tsconfig.json wiki
page](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json) for more
details.

## `--rootDir` command line option

Option [`outDir`](/tsconfig#outDir) duplicates the input hierarchy in the
output. The compiler computes the root of the input files as the longest
common path of all input files; and then uses that to replicate all its
substructure in the output.

Sometimes this is not desirable, for instance inputs `FolderA\FolderB\1.ts`
and `FolderA\FolderB\2.ts` would result in output structure mirroring
`FolderA\FolderB\`. Now if a new file `FolderA\3.ts` is added to the input,
the output structure will pop out to mirror `FolderA\`.

[`rootDir`](/tsconfig#rootDir) specifies the input directory to be mirrored in
output instead of computing it.

## `--noEmitHelpers` command line option

The TypeScript compiler emits a few helpers like `__extends` when needed. The
helpers are emitted in every file they are referenced in. If you want to
consolidate all helpers in one place, or override the default behavior, use
[`noEmitHelpers`](/tsconfig#noEmitHelpers) to instructs the compiler not to
emit them.

## `--newLine` command line option

By default the output new line character is `\r\n` on Windows based systems
and `\n` on *nix based systems. [`newLine`](/tsconfig#newLine) command line
flag allows overriding this behavior and specifying the new line character to
be used in generated output files.

## `--inlineSourceMap` and `inlineSources` command line options

[`inlineSourceMap`](/tsconfig#inlineSourceMap) causes source map files to be
written inline in the generated `.js` files instead of in a independent
`.js.map` file. [`inlineSources`](/tsconfig#inlineSources) allows for
additionally inlining the source `.ts` file into the `.js` file.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.5.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

SC![Sadistic Compiler
\(1\)](https://gravatar.com/avatar/923d99c62141f91fbc8a6e18ef00abf7?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

SC![Shawn Choi
\(1\)](https://gravatar.com/avatar/6d91293b9dbb67211758818877635560?s=32&&d=blank)

8+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.6

## JSX support

JSX is an embeddable XML-like syntax. It is meant to be transformed into valid
JavaScript, but the semantics of that transformation are implementation-
specific. JSX came to popularity with the React library but has since seen
other applications. TypeScript 1.6 supports embedding, type checking, and
optionally compiling JSX directly into JavaScript.

#### New `.tsx` file extension and `as` operator

TypeScript 1.6 introduces a new `.tsx` file extension. This extension does two
things: it enables JSX inside of TypeScript files, and it makes the new `as`
operator the default way to cast (removing any ambiguity between JSX
expressions and the TypeScript prefix cast operator). For example:

    
    
    ts
    
    var x = <any>foo;
    
    // is equivalent to:
    
    var x = foo as any;

#### Using React

To use JSX-support with React you should use the [React
typings](https://github.com/borisyankov/DefinitelyTyped/tree/master/react).
These typings define the `JSX` namespace so that TypeScript can correctly
check JSX expressions for React. For example:

    
    
    ts
    
    /// <reference path="react.d.ts" />
    
    interface Props {
    
      name: string;
    
    }
    
    class MyComponent extends React.Component<Props, {}> {
    
      render() {
    
        return <span>{this.props.name}</span>;
    
      }
    
    }
    
    <MyComponent name="bar" />; // OK
    
    <MyComponent name={0} />; // error, `name` is not a number

#### Using other JSX frameworks

JSX element names and properties are validated against the `JSX` namespace.
Please see the [[JSX]] wiki page for defining the `JSX` namespace for your
framework.

#### Output generation

TypeScript ships with two JSX modes: `preserve` and `react`.

  * The `preserve` mode will keep JSX expressions as part of the output to be further consumed by another transform step. _Additionally the output will have a`.jsx` file extension._
  * The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension.

See the [[JSX]] wiki page for more information on using JSX in TypeScript.

## Intersection types

TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type `A | B` represents an entity that is either of type `A` or type `B`, whereas an intersection type `A & B` represents an entity that is both of type `A` _and_ type `B`.

##### Example

    
    
    ts
    
    function extend<T, U>(first: T, second: U): T & U {
    
      let result = <T & U>{};
    
      for (let id in first) {
    
        result[id] = first[id];
    
      }
    
      for (let id in second) {
    
        if (!result.hasOwnProperty(id)) {
    
          result[id] = second[id];
    
        }
    
      }
    
      return result;
    
    }
    
    var x = extend({ a: "hello" }, { b: 42 });
    
    var s = x.a;
    
    var n = x.b;
    
    
    ts
    
    type LinkedList<T> = T & { next: LinkedList<T> };
    
    interface Person {
    
      name: string;
    
    }
    
    var people: LinkedList<Person>;
    
    var s = people.name;
    
    var s = people.next.name;
    
    var s = people.next.next.name;
    
    var s = people.next.next.next.name;
    
    
    ts
    
    interface A {
    
      a: string;
    
    }
    
    interface B {
    
      b: string;
    
    }
    
    interface C {
    
      c: string;
    
    }
    
    var abc: A & B & C;
    
    abc.a = "hello";
    
    abc.b = "hello";
    
    abc.c = "hello";

See [issue #1256](https://github.com/Microsoft/TypeScript/issues/1256) for
more information.

## Local type declarations

Local class, interface, enum, and type alias declarations can now appear
inside function declarations. Local types are block scoped, similar to
variables declared with `let` and `const`. For example:

    
    
    ts
    
    function f() {
    
      if (true) {
    
        interface T {
    
          x: number;
    
        }
    
        let v: T;
    
        v.x = 5;
    
      } else {
    
        interface T {
    
          x: string;
    
        }
    
        let v: T;
    
        v.x = "hello";
    
      }
    
    }

The inferred return type of a function may be a type declared locally within
the function. It is not possible for callers of the function to reference such
a local type, but it can of course be matched structurally. For example:

    
    
    ts
    
    interface Point {
    
      x: number;
    
      y: number;
    
    }
    
    function getPointFactory(x: number, y: number) {
    
      class P {
    
        x = x;
    
        y = y;
    
      }
    
      return P;
    
    }
    
    var PointZero = getPointFactory(0, 0);
    
    var PointOne = getPointFactory(1, 1);
    
    var p1 = new PointZero();
    
    var p2 = new PointZero();
    
    var p3 = new PointOne();

Local types may reference enclosing type parameters and local class and
interfaces may themselves be generic. For example:

    
    
    ts
    
    function f3() {
    
      function f<X, Y>(x: X, y: Y) {
    
        class C {
    
          public x = x;
    
          public y = y;
    
        }
    
        return C;
    
      }
    
      let C = f(10, "hello");
    
      let v = new C();
    
      let x = v.x; // number
    
      let y = v.y; // string
    
    }

## Class expressions

TypeScript 1.6 adds support for ES6 class expressions. In a class expression,
the class name is optional and, if specified, is only in scope in the class
expression itself. This is similar to the optional name of a function
expression. It is not possible to refer to the class instance type of a class
expression outside the class expression, but the type can of course be matched
structurally. For example:

    
    
    ts
    
    let Point = class {
    
      constructor(public x: number, public y: number) {}
    
      public length() {
    
        return Math.sqrt(this.x * this.x + this.y * this.y);
    
      }
    
    };
    
    var p = new Point(3, 4); // p has anonymous class type
    
    console.log(p.length());

## Extending expressions

TypeScript 1.6 adds support for classes extending arbitrary expression that
computes a constructor function. This means that built-in types can now be
extended in class declarations.

The `extends` clause of a class previously required a type reference to be
specified. It now accepts an expression optionally followed by a type argument
list. The type of the expression must be a constructor function type with at
least one construct signature that has the same number of type parameters as
the number of type arguments specified in the `extends` clause. The return
type of the matching construct signature(s) is the base type from which the
class instance type inherits. Effectively, this allows both real classes and
‚Äúclass-like‚Äù expressions to be specified in the `extends` clause.

Some examples:

    
    
    ts
    
    // Extend built-in types
    
    class MyArray extends Array<number> {}
    
    class MyError extends Error {}
    
    // Extend computed base class
    
    class ThingA {
    
      getGreeting() {
    
        return "Hello from A";
    
      }
    
    }
    
    class ThingB {
    
      getGreeting() {
    
        return "Hello from B";
    
      }
    
    }
    
    interface Greeter {
    
      getGreeting(): string;
    
    }
    
    interface GreeterConstructor {
    
      new (): Greeter;
    
    }
    
    function getGreeterBase(): GreeterConstructor {
    
      return Math.random() >= 0.5 ? ThingA : ThingB;
    
    }
    
    class Test extends getGreeterBase() {
    
      sayHello() {
    
        console.log(this.getGreeting());
    
      }
    
    }

## `abstract` classes and methods

TypeScript 1.6 adds support for `abstract` keyword for classes and their
methods. An abstract class is allowed to have methods with no implementation,
and cannot be constructed.

##### Examples

    
    
    ts
    
    abstract class Base {
    
      abstract getThing(): string;
    
      getOtherThing() {
    
        return "hello";
    
      }
    
    }
    
    let x = new Base(); // Error, 'Base' is abstract
    
    // Error, must either be 'abstract' or implement concrete 'getThing'
    
    class Derived1 extends Base {}
    
    class Derived2 extends Base {
    
      getThing() {
    
        return "hello";
    
      }
    
      foo() {
    
        super.getThing(); // Error: cannot invoke abstract members through 'super'
    
      }
    
    }
    
    var x = new Derived2(); // OK
    
    var y: Base = new Derived2(); // Also OK
    
    y.getThing(); // OK
    
    y.getOtherThing(); // OK

## Generic type aliases

With TypeScript 1.6, type aliases can be generic. For example:

    
    
    ts
    
    type Lazy<T> = T | (() => T);
    
    var s: Lazy<string>;
    
    s = "eager";
    
    s = () => "lazy";
    
    interface Tuple<A, B> {
    
      a: A;
    
      b: B;
    
    }
    
    type Pair<T> = Tuple<T, T>;

## Stricter object literal assignment checks

TypeScript 1.6 enforces stricter object literal assignment checks for the
purpose of catching excess or misspelled properties. Specifically, when a
fresh object literal is assigned to a variable or passed as an argument for a
non-empty target type, it is an error for the object literal to specify
properties that don‚Äôt exist in the target type.

##### Examples

    
    
    ts
    
    var x: { foo: number };
    
    x = { foo: 1, baz: 2 }; // Error, excess property `baz`
    
    var y: { foo: number; bar?: number };
    
    y = { foo: 1, baz: 2 }; // Error, excess or misspelled property `baz`

A type can include an index signature to explicitly indicate that excess
properties are permitted:

    
    
    ts
    
    var x: { foo: number; [x: string]: any };
    
    x = { foo: 1, baz: 2 }; // Ok, `baz` matched by index signature

## ES6 generators

TypeScript 1.6 adds support for generators when targeting ES6.

A generator function can have a return type annotation, just like a function.
The annotation represents the type of the generator returned by the function.
Here is an example:

    
    
    ts
    
    function* g(): Iterable<string> {
    
      for (var i = 0; i < 100; i++) {
    
        yield ""; // string is assignable to string
    
      }
    
      yield* otherStringGenerator(); // otherStringGenerator must be iterable and element type assignable to string
    
    }

A generator function with no type annotation can have the type annotation
inferred. So in the following case, the type will be inferred from the yield
statements:

    
    
    ts
    
    function* g() {
    
      for (var i = 0; i < 100; i++) {
    
        yield ""; // infer string
    
      }
    
      yield* otherStringGenerator(); // infer element type of otherStringGenerator
    
    }

## Experimental support for `async` functions

TypeScript 1.6 introduces experimental support of `async` functions when
targeting ES6. Async functions are expected to invoke an asynchronous
operation and await its result without blocking normal execution of the
program. This accomplished through the use of an ES6-compatible `Promise`
implementation, and transposition of the function body into a compatible form
to resume execution when the awaited asynchronous operation completes.

An _async function_ is a function or method that has been prefixed with the
`async` modifier. This modifier informs the compiler that function body
transposition is required, and that the keyword `await` should be treated as a
unary expression instead of an identifier. An _Async Function_ must provide a
return type annotation that points to a compatible `Promise` type. Return type
inference can only be used if there is a globally defined, compatible
`Promise` type.

##### Example

    
    
    ts
    
    var p: Promise<number> = /* ... */;
    
    async function fn(): Promise<number> {
    
      var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    
      return 1 + i;
    
    }
    
    var a = async (): Promise<number> => 1 + await p; // suspends execution.
    
    var a = async () => 1 + await p; // suspends execution. return type is inferred as "Promise<number>" when compiling with --target ES6
    
    var fe = async function(): Promise<number> {
    
      var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    
      return 1 + i;
    
    }
    
    class C {
    
      async m(): Promise<number> {
    
        var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    
        return 1 + i;
    
      }
    
      async get p(): Promise<number> {
    
        var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    
        return 1 + i;
    
      }
    
    }

## Nightly builds

While not strictly a language change, nightly builds are now available by
installing with the following command:

    
    
    npm install -g typescript@next

## Adjustments in module resolution logic

Starting from release 1.6 TypeScript compiler will use different set of rules
to resolve module names when targeting ‚Äòcommonjs‚Äô. These
[rules](https://github.com/Microsoft/TypeScript/issues/2338) attempted to
model module lookup procedure used by Node. This effectively mean that node
modules can include information about its typings and TypeScript compiler will
be able to find it. User however can override module resolution rules picked
by the compiler by using [`moduleResolution`](/tsconfig#moduleResolution)
command line option. Possible values are:

  * ‚Äòclassic‚Äô - module resolution rules used by pre 1.6 TypeScript compiler
  * ‚Äònode‚Äô - node-like module resolution

## Merging ambient class and interface declaration

The instance side of an ambient class declaration can be extended using an
interface declaration The class constructor object is unmodified. For example:

    
    
    ts
    
    declare class Foo {
    
      public x: number;
    
    }
    
    interface Foo {
    
      y: string;
    
    }
    
    function bar(foo: Foo) {
    
      foo.x = 1; // OK, declared in the class Foo
    
      foo.y = "1"; // OK, declared in the interface Foo
    
    }

## User-defined type guard functions

TypeScript 1.6 adds a new way to narrow a variable type inside an `if` block,
in addition to `typeof` and `instanceof`. A user-defined type guard functions
is one with a return type annotation of the form `x is T`, where `x` is a
declared parameter in the signature, and `T` is any type. When a user-defined
type guard function is invoked on a variable in an `if` block, the type of the
variable will be narrowed to `T`.

##### Examples

    
    
    ts
    
    function isCat(a: any): a is Cat {
    
      return a.name === "kitty";
    
    }
    
    var x: Cat | Dog;
    
    if (isCat(x)) {
    
      x.meow(); // OK, x is Cat in this block
    
    }

## `exclude` property support in tsconfig.json

A tsconfig.json file that doesn‚Äôt specify a files property (and therefore
implicitly references all *.ts files in all subdirectories) can now contain an
exclude property that specifies a list of files and/or directories to exclude
from the compilation. The exclude property must be an array of strings that
each specify a file or folder name relative to the location of the
tsconfig.json file. For example:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[out](https://www.typescriptlang.org/tsconfig#out)": "test.js"
    
      },
    
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["node_modules", "test.ts", "utils/t2.ts"]
    
    }

The [`exclude`](/tsconfig#exclude) list does not support wildcards. It must
simply be a list of files and/or directories.

## `--init` command line option

Run `tsc --init` in a directory to create an initial `tsconfig.json` in this
directory with preset defaults. Optionally pass command line arguments along
with `--init` to be stored in your initial tsconfig.json on creation.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.6.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

AG![Anton Gilgur
\(1\)](https://gravatar.com/avatar/20827df1809becc22927b5ef5dfcde8d?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.7

## `async`/`await` support in ES6 targets (Node v4+)

TypeScript now supports asynchronous functions for engines that have native
support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are
prefixed with the `async` keyword; `await` suspends the execution until an
asynchronous function return promise is fulfilled and unwraps the value from
the `Promise` returned.

##### Example

In the following example, each input element will be printed out one at a time
with a 400ms delay:

    
    
    ts
    
    "use strict";
    
    // printDelayed is a 'Promise<void>'
    
    async function printDelayed(elements: string[]) {
    
      for (const element of elements) {
    
        await delay(400);
    
        console.log(element);
    
      }
    
    }
    
    async function delay(milliseconds: number) {
    
      return new Promise<void>((resolve) => {
    
        setTimeout(resolve, milliseconds);
    
      });
    
    }
    
    printDelayed(["Hello", "beautiful", "asynchronous", "world"]).then(() => {
    
      console.log();
    
      console.log("Printed every element!");
    
    });

For more information see [async function
reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)
reference.

## Support for `--target ES6` with `--module`

TypeScript 1.7 adds `ES6` to the list of options available for the
[`module`](/tsconfig#module) option and allows you to specify the module
output when targeting `ES6`. This provides more flexibility to target exactly
the features you want in specific runtimes.

##### Example

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "amd",
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es6"
    
      }
    
    }

## `this`-typing

It is a common pattern to return the current object (i.e. `this`) from a
method to create [fluent-style
APIs](https://wikipedia.org/wiki/Fluent_interface). For instance, consider the
following `BasicCalculator` module:

    
    
    ts
    
    export default class BasicCalculator {
    
      public constructor(protected value: number = 0) {}
    
      public currentValue(): number {
    
        return this.value;
    
      }
    
      public add(operand: number) {
    
        this.value += operand;
    
        return this;
    
      }
    
      public subtract(operand: number) {
    
        this.value -= operand;
    
        return this;
    
      }
    
      public multiply(operand: number) {
    
        this.value *= operand;
    
        return this;
    
      }
    
      public divide(operand: number) {
    
        this.value /= operand;
    
        return this;
    
      }
    
    }

A user could express `2 * 5 + 1` as

    
    
    ts
    
    import calc from "./BasicCalculator";
    
    let v = new calc(2).multiply(5).add(1).currentValue();

This often opens up very elegant ways of writing code; however, there was a
problem for classes that wanted to extend from `BasicCalculator`. Imagine a
user wanted to start writing a `ScientificCalculator`:

    
    
    ts
    
    import BasicCalculator from "./BasicCalculator";
    
    export default class ScientificCalculator extends BasicCalculator {
    
      public constructor(value = 0) {
    
        super(value);
    
      }
    
      public square() {
    
        this.value = this.value ** 2;
    
        return this;
    
      }
    
      public sin() {
    
        this.value = Math.sin(this.value);
    
        return this;
    
      }
    
    }

Because TypeScript used to infer the type `BasicCalculator` for each method in
`BasicCalculator` that returned `this`, the type system would forget that it
had `ScientificCalculator` whenever using a `BasicCalculator` method.

For instance:

    
    
    ts
    
    import calc from "./ScientificCalculator";
    
    let v = new calc(0.5)
    
      .square()
    
      .divide(2)
    
      .sin() // Error: 'BasicCalculator' has no 'sin' method.
    
      .currentValue();

This is no longer the case - TypeScript now infers `this` to have a special
type called `this` whenever inside an instance method of a class. The `this`
type is written as so, and basically means ‚Äúthe type of the left side of the
dot in a method call‚Äù.

The `this` type is also useful with intersection types in describing libraries
(e.g. Ember.js) that use mixin-style patterns to describe inheritance:

    
    
    ts
    
    interface MyType {
    
      extend<T>(other: T): this & T;
    
    }

## ES7 exponentiation operator

TypeScript 1.7 supports upcoming [ES7/ES2016 exponentiation
operators](https://github.com/rwaldron/exponentiation-operator): `**` and
`**=`. The operators will be transformed in the output to ES3/ES5 using
`Math.pow`.

##### Example

    
    
    ts
    
    var x = 2 ** 3;
    
    var y = 10;
    
    y **= 2;
    
    var z = -(4 ** 3);

Will generate the following JavaScript output:

    
    
    js
    
    var x = Math.pow(2, 3);
    
    var y = 10;
    
    y = Math.pow(y, 2);
    
    var z = -Math.pow(4, 3);

## Improved checking for destructuring object literal

TypeScript 1.7 makes checking of destructuring patterns with an object literal
or array literal initializers less rigid and more intuitive.

When an object literal is contextually typed by the implied type of an object
binding pattern:

  * Properties with default values in the object binding pattern become optional in the object literal.
  * Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.
  * Properties in the object literal that have no match in the object binding pattern are an error.

When an array literal is contextually typed by the implied type of an array
binding pattern:

  * Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.

##### Example

    
    
    ts
    
    // Type of f1 is (arg?: { x?: number, y?: number }) => void
    
    function f1({ x = 0, y = 0 } = {}) {}
    
    // And can be called as:
    
    f1();
    
    f1({});
    
    f1({ x: 1 });
    
    f1({ y: 1 });
    
    f1({ x: 1, y: 1 });
    
    // Type of f2 is (arg?: (x: number, y?: number) => void
    
    function f2({ x, y = 0 } = { x: 0 }) {}
    
    f2();
    
    f2({}); // Error, x not optional
    
    f2({ x: 1 });
    
    f2({ y: 1 }); // Error, x not optional
    
    f2({ x: 1, y: 1 });

## Support for decorators when targeting ES3

Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the
ES5-specific use of `reduceRight` from the `__decorate` helper. The changes
also inline calls `Object.getOwnPropertyDescriptor` and
`Object.defineProperty` in a backwards-compatible fashion that allows for a to
clean up the emit for ES5 and later by removing various repetitive calls to
the aforementioned `Object` methods.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.7.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

EB![Eli Barzilay
\(1\)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)

TG![Thomas G√ºttler
\(1\)](https://gravatar.com/avatar/94f7c1d49ceb8aff0c77cc96de63d845?s=32&&d=blank)

4+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 1.8

## Type parameters as constraints

With TypeScript 1.8 it becomes possible for a type parameter constraint to
reference type parameters from the same type parameter list. Previously this
was an error. This capability is usually referred to as [F-Bounded
Polymorphism](https://wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification).

##### Example

    
    
    ts
    
    function assign<T extends U, U>(target: T, source: U): T {
    
      for (let id in source) {
    
        target[id] = source[id];
    
      }
    
      return target;
    
    }
    
    let x = { a: 1, b: 2, c: 3, d: 4 };
    
    assign(x, { b: 10, d: 20 });
    
    assign(x, { e: 0 }); // Error

## Control flow analysis errors

TypeScript 1.8 introduces control flow analysis to help catch common errors
that users tend to run into. Read on to get more details, and check out these
errors in action:

![cfa](https://cloud.githubusercontent.com/assets/8052307/5210657/c5ae0f28-7585-11e4-97d8-86169ef2a160.gif)

### Unreachable code

Statements guaranteed to not be executed at run time are now correctly flagged
as unreachable code errors. For instance, statements following unconditional
`return`, `throw`, `break` or `continue` statements are considered
unreachable. Use [`allowUnreachableCode`](/tsconfig#allowUnreachableCode) to
disable unreachable code detection and reporting.

##### Example

Here‚Äôs a simple example of an unreachable code error:

    
    
    ts
    
    function f(x) {
    
      if (x) {
    
        return true;
    
      } else {
    
        return false;
    
      }
    
      x = 0; // Error: Unreachable code detected.
    
    }

A more common error that this feature catches is adding a newline after a
`return` statement:

    
    
    ts
    
    function f() {
    
      return; // Automatic Semicolon Insertion triggered at newline
    
      {
    
        x: "string"; // Error: Unreachable code detected.
    
      }
    
    }

Since JavaScript automatically terminates the `return` statement at the end of
the line, the object literal becomes a block.

### Unused labels

Unused labels are also flagged. Just like unreachable code checks, these are
turned on by default; use [`allowUnusedLabels`](/tsconfig#allowUnusedLabels)
to stop reporting these errors.

##### Example

    
    
    ts
    
    loop: while (x > 0) {
    
      // Error: Unused label.
    
      x++;
    
    }

### Implicit returns

Functions with code paths that do not return a value in JS implicitly return
`undefined`. These can now be flagged by the compiler as implicit returns. The
check is turned _off_ by default; use
[`noImplicitReturns`](/tsconfig#noImplicitReturns) to turn it on.

##### Example

    
    
    ts
    
    function f(x) {
    
      // Error: Not all code paths return a value.
    
      if (x) {
    
        return false;
    
      }
    
      // implicitly returns `undefined`
    
    }

### Case clause fall-throughs

TypeScript can reports errors for fall-through cases in switch statement where
the case clause is non-empty. This check is turned _off_ by default, and can
be enabled using
[`noFallthroughCasesInSwitch`](/tsconfig#noFallthroughCasesInSwitch).

##### Example

With [`noFallthroughCasesInSwitch`](/tsconfig#noFallthroughCasesInSwitch),
this example will trigger an error:

    
    
    ts
    
    switch (x % 2) {
    
      case 0: // Error: Fallthrough case in switch.
    
        console.log("even");
    
      case 1:
    
        console.log("odd");
    
        break;
    
    }

However, in the following example, no error will be reported because the fall-
through case is empty:

    
    
    ts
    
    switch (x % 3) {
    
      case 0:
    
      case 1:
    
        console.log("Acceptable");
    
        break;
    
      case 2:
    
        console.log("This is *two much*!");
    
        break;
    
    }

## Function Components in React

TypeScript now supports [Function
components](https://reactjs.org/docs/components-and-props.html#functional-and-
class-components). These are lightweight components that easily compose other
components:

    
    
    ts
    
    // Use parameter destructuring and defaults for easy definition of 'props' type
    
    const Greeter = ({ name = "world" }) => <div>Hello, {name}!</div>;
    
    // Properties get validated
    
    let example = <Greeter name="TypeScript 1.8" />;

For this feature and simplified props, be sure to be use the [latest version
of
react.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts).

## Simplified `props` type management in React

In TypeScript 1.8 with the latest version of react.d.ts (see above), we‚Äôve
also greatly simplified the declaration of `props` types.

Specifically:

  * You no longer need to either explicitly declare `ref` and `key` or `extend React.Props`
  * The `ref` and `key` properties will appear with correct types on all components
  * The `ref` property is correctly disallowed on instances of Stateless Function components

## Augmenting global/module scope from modules

Users can now declare any augmentations that they want to make, or that any
other consumers already have made, to an existing module. Module augmentations
look like plain old ambient module declarations (i.e. the `declare module
"foo" { }` syntax), and are directly nested either your own modules, or in
another top level ambient external module.

Furthermore, TypeScript also has the notion of _global_ augmentations of the
form `declare global { }`. This allows modules to augment global types such as
`Array` if necessary.

The name of a module augmentation is resolved using the same set of rules as
module specifiers in `import` and `export` declarations. The declarations in a
module augmentation are merged with any existing declarations the same way
they would if they were declared in the same file.

Neither module augmentations nor global augmentations can add new items to the
top level scope - they can only ‚Äúpatch‚Äù existing declarations.

##### Example

Here `map.ts` can declare that it will internally patch the `Observable` type
from `observable.ts` and add the `map` method to it.

    
    
    ts
    
    // observable.ts
    
    export class Observable<T> {
    
      // ...
    
    }
    
    
    ts
    
    // map.ts
    
    import { Observable } from "./observable";
    
    // Create an augmentation for "./observable"
    
    declare module "./observable" {
    
        // Augment the 'Observable' class definition with interface merging
    
        interface Observable<T> {
    
            map<U>(proj: (el: T) => U): Observable<U>;
    
        }
    
    }
    
    Observable.prototype.map = /*...*/;
    
    
    ts
    
    // consumer.ts
    
    import { Observable } from "./observable";
    
    import "./map";
    
    let o: Observable<number>;
    
    o.map((x) => x.toFixed());

Similarly, the global scope can be augmented from modules using a `declare
global` declarations:

##### Example

    
    
    ts
    
    // Ensure this is treated as a module.
    
    export {};
    
    declare global {
    
      interface Array<T> {
    
        mapToNumbers(): number[];
    
      }
    
    }
    
    Array.prototype.mapToNumbers = function () {
    
      /* ... */
    
    };

## String literal types

It‚Äôs not uncommon for an API to expect a specific set of strings for certain
values. For instance, consider a UI library that can move elements across the
screen while controlling the [‚Äúeasing‚Äù of the
animation.](https://wikipedia.org/wiki/Inbetweening)

    
    
    ts
    
    declare class UIElement {
    
      animate(options: AnimationOptions): void;
    
    }
    
    interface AnimationOptions {
    
      deltaX: number;
    
      deltaY: number;
    
      easing: string; // Can be "ease-in", "ease-out", "ease-in-out"
    
    }

However, this is error prone - there is nothing stopping a user from
accidentally misspelling one of the valid easing values:

    
    
    ts
    
    // No errors
    
    new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });

With TypeScript 1.8, we‚Äôve introduced string literal types. These types are
written the same way string literals are, but in type positions.

Users can now ensure that the type system will catch such errors. Here‚Äôs our
new `AnimationOptions` using string literal types:

    
    
    ts
    
    interface AnimationOptions {
    
      deltaX: number;
    
      deltaY: number;
    
      easing: "ease-in" | "ease-out" | "ease-in-out";
    
    }
    
    // Error: Type '"ease-inout"' is not assignable to type '"ease-in" | "ease-out" | "ease-in-out"'
    
    new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });

## Improved union/intersection type inference

TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from `string | string[]` to `string | T`, we reduce the types to `string[]` and `T`, thus inferring `string[]` for `T`.

##### Example

    
    
    ts
    
    type Maybe<T> = T | void;
    
    function isDefined<T>(x: Maybe<T>): x is T {
    
      return x !== undefined && x !== null;
    
    }
    
    function isUndefined<T>(x: Maybe<T>): x is void {
    
      return x === undefined || x === null;
    
    }
    
    function getOrElse<T>(x: Maybe<T>, defaultValue: T): T {
    
      return isDefined(x) ? x : defaultValue;
    
    }
    
    function test1(x: Maybe<string>) {
    
      let x1 = getOrElse(x, "Undefined"); // string
    
      let x2 = isDefined(x) ? x : "Undefined"; // string
    
      let x3 = isUndefined(x) ? "Undefined" : x; // string
    
    }
    
    function test2(x: Maybe<number>) {
    
      let x1 = getOrElse(x, -1); // number
    
      let x2 = isDefined(x) ? x : -1; // number
    
      let x3 = isUndefined(x) ? -1 : x; // number
    
    }

## Concatenate `AMD` and `System` modules with `--outFile`

Specifying [`outFile`](/tsconfig#outFile) in conjunction with `--module amd`
or `--module system` will concatenate all modules in the compilation into a
single output file containing multiple module closures.

A module name will be computed for each module based on its relative location
to [`rootDir`](/tsconfig#rootDir).

##### Example

    
    
    ts
    
    // file src/a.ts
    
    import * as B from "./lib/b";
    
    export function createA() {
    
      return B.createB();
    
    }
    
    
    ts
    
    // file src/lib/b.ts
    
    export function createB() {
    
      return {};
    
    }

Results in:

    
    
    js
    
    define("lib/b", ["require", "exports"], function (require, exports) {
    
      "use strict";
    
      function createB() {
    
        return {};
    
      }
    
      exports.createB = createB;
    
    });
    
    define("a", ["require", "exports", "lib/b"], function (require, exports, B) {
    
      "use strict";
    
      function createA() {
    
        return B.createB();
    
      }
    
      exports.createA = createA;
    
    });

## Support for `default` import interop with SystemJS

Module loaders like SystemJS wrap CommonJS modules and expose then as a
`default` ES6 import. This makes it impossible to share the definition files
between the SystemJS and CommonJS implementation of the module as the module
shape looks different based on the loader.

Setting the new compiler flag
[`allowSyntheticDefaultImports`](/tsconfig#allowSyntheticDefaultImports)
indicates that the module loader performs some kind of synthetic default
import member creation not indicated in the imported .ts or .d.ts. The
compiler will infer the existence of a `default` export that has the shape of
the entire module itself.

System modules have this flag on by default.

## Allow captured `let`/`const` in loops

Previously an error, now supported in TypeScript 1.8. `let`/`const`
declarations within loops and captured in functions are now emitted to
correctly match `let`/`const` freshness semantics.

##### Example

    
    
    ts
    
    let list = [];
    
    for (let i = 0; i < 5; i++) {
    
      list.push(() => i);
    
    }
    
    list.forEach((f) => console.log(f()));

is compiled to:

    
    
    js
    
    var list = [];
    
    var _loop_1 = function (i) {
    
      list.push(function () {
    
        return i;
    
      });
    
    };
    
    for (var i = 0; i < 5; i++) {
    
      _loop_1(i);
    
    }
    
    list.forEach(function (f) {
    
      return console.log(f());
    
    });

And results in

    
    
    cmd
    
    0
    
    1
    
    2
    
    3
    
    4

## Improved checking for `for..in` statements

Previously the type of a `for..in` variable is inferred to `any`; that allowed
the compiler to ignore invalid uses within the `for..in` body.

Starting with TypeScript 1.8:

  * The type of a variable declared in a `for..in` statement is implicitly `string`.
  * When an object with a numeric index signature of type `T` (such as an array) is indexed by a `for..in` variable of a containing `for..in` statement for an object _with_ a numeric index signature and _without_ a string index signature (again such as an array), the value produced is of type `T`.

##### Example

    
    
    ts
    
    var a: MyObject[];
    
    for (var x in a) {
    
      // Type of x is implicitly string
    
      var obj = a[x]; // Type of obj is MyObject
    
    }

## Modules are now emitted with a `"use strict";` prologue

Modules were always parsed in strict mode as per ES6, but for non-ES6 targets
this was not respected in the generated code. Starting with TypeScript 1.8,
emitted modules are always in strict mode. This shouldn‚Äôt have any visible
changes in most code as TS considers most strict mode errors as errors at
compile time, but it means that some things which used to silently fail at
runtime in your TS code, like assigning to `NaN`, will now loudly fail. You
can reference the [MDN
Article](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode)
on strict mode for a detailed list of the differences between strict mode and
non-strict mode.

## Including `.js` files with `--allowJs`

Often there are external source files in your project that may not be authored
in TypeScript. Alternatively, you might be in the middle of converting a JS
code base into TS, but still want to bundle all your JS code into a single
file with the output of your new TS code.

`.js` files are now allowed as input to `tsc`. The TypeScript compiler checks
the input `.js` files for syntax errors, and emits valid output based on the
[`target`](/tsconfig#target) and [`module`](/tsconfig#module) flags. The
output can be combined with other `.ts` files as well. Source maps are still
generated for `.js` files just like with `.ts` files.

## Custom JSX factories using `--reactNamespace`

Passing `--reactNamespace <JSX factory Name>` along with `--jsx react` allows
for using a different JSX factory from the default `React`.

The new factory name will be used to call `createElement` and `__spread`
functions.

##### Example

    
    
    ts
    
    import { jsxFactory } from "jsxFactory";
    
    var div = <div>Hello JSX!</div>;

Compiled with:

    
    
    shell
    
    tsc --jsx react --reactNamespace jsxFactory --m commonJS

Results in:

    
    
    js
    
    "use strict";
    
    var jsxFactory_1 = require("jsxFactory");
    
    var div = jsxFactory_1.jsxFactory.createElement("div", null, "Hello JSX!");

## `this`-based type guards

TypeScript 1.8 extends [user-defined type guard
functions](./typescript-1.6.html#user-defined-type-guard-functions) to class
and interface methods.

`this is T` is now valid return type annotation for methods in classes and
interfaces. When used in a type narrowing position (e.g. `if` statement), the
type of the call expression target object would be narrowed to `T`.

##### Example

    
    
    ts
    
    class FileSystemObject {
    
      isFile(): this is File {
    
        return this instanceof File;
    
      }
    
      isDirectory(): this is Directory {
    
        return this instanceof Directory;
    
      }
    
      isNetworked(): this is Networked & this {
    
        return this.networked;
    
      }
    
      constructor(public path: string, private networked: boolean) {}
    
    }
    
    class File extends FileSystemObject {
    
      constructor(path: string, public content: string) {
    
        super(path, false);
    
      }
    
    }
    
    class Directory extends FileSystemObject {
    
      children: FileSystemObject[];
    
    }
    
    interface Networked {
    
      host: string;
    
    }
    
    let fso: FileSystemObject = new File("foo/bar.txt", "foo");
    
    if (fso.isFile()) {
    
      fso.content; // fso is File
    
    } else if (fso.isDirectory()) {
    
      fso.children; // fso is Directory
    
    } else if (fso.isNetworked()) {
    
      fso.host; // fso is networked
    
    }

## Official TypeScript NuGet package

Starting with TypeScript 1.8, official NuGet packages are available for the
TypeScript Compiler (`tsc.exe`) as well as the MSBuild integration
(`Microsoft.TypeScript.targets` and `Microsoft.TypeScript.Tasks.dll`).

Stable packages are available here:

  * [Microsoft.TypeScript.Compiler](https://www.nuget.org/packages/Microsoft.TypeScript.Compiler/)
  * [Microsoft.TypeScript.MSBuild](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/)

Also, a nightly NuGet package to match the [nightly npm
package](http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-
typescript-nightlies.aspx) is available on [myget](https://myget.org):

  * [TypeScript-Preview](https://www.myget.org/gallery/typescript-preview)

## Prettier error messages from `tsc`

We understand that a ton of monochrome output can be a little difficult on the
eyes. Colors can help discern where a message starts and ends, and these
visual clues are important when error output gets overwhelming.

By just passing the [`pretty`](/tsconfig#pretty) command line option,
TypeScript gives more colorful output with context about where things are
going wrong.

![Showing off pretty error messages in
ConEmu](https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-
in-typescript/pretty01.png)

## Colorization of JSX code in VS 2015

With TypeScript 1.8, JSX tags are now classified and colorized in Visual
Studio 2015.

![jsx](https://cloud.githubusercontent.com/assets/8052307/12271404/b875c502-b90f-11e5-93d8-c6740be354d1.png)

The classification can be further customized by changing the font and color
settings for the `VB XML` color and font settings through
`Tools`->`Options`->`Environment`->`Fonts and Colors` page.

## The `--project` (`-p`) flag can now take any file path

The `--project` command line option originally could only take paths to a
folder containing a `tsconfig.json`. Given the different scenarios for build
configurations, it made sense to allow `--project` to point to any other
compatible JSON file. For instance, a user might want to target ES2015 with
CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With
this new work, users can easily manage two separate build targets using `tsc`
alone without having to perform hacky workarounds like placing `tsconfig.json`
files in separate directories.

The old behavior still remains the same if given a directory - the compiler
will try to find a file in the directory named `tsconfig.json`.

## Allow comments in tsconfig.json

It‚Äôs always nice to be able to document your configuration! `tsconfig.json`
now accepts single and multi-line comments.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "ES2015", // running on node v5, yaay!
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true // makes debugging easier
    
      },
    
      /*
    
       * Excluded files
    
       */
    
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["file.d.ts"]
    
    }

## Support output to IPC-driven files

TypeScript 1.8 allows users to use the [`outFile`](/tsconfig#outFile) argument
with special file system entities like named pipes, devices, etc.

As an example, on many Unix-like systems, the standard output stream is
accessible by the file `/dev/stdout`.

    
    
    shell
    
    tsc foo.ts --outFile /dev/stdout

This can be used to pipe output between commands as well.

As an example, we can pipe our emitted JavaScript into a pretty printer like
[pretty-js](https://www.npmjs.com/package/pretty-js):

    
    
    shell
    
    tsc foo.ts --outFile /dev/stdout | pretty-js

## Improved support for `tsconfig.json` in Visual Studio 2015

TypeScript 1.8 allows `tsconfig.json` files in all project types. This
includes ASP.NET v4 projects, _Console Application_ , and the _Html
Application with TypeScript_ project types. Further, you are no longer limited
to a single `tsconfig.json` file but can add multiple, and each will be built
as part of the project. This allows you to separate the configuration for
different parts of your application without having to use multiple different
projects.

![Showing off tsconfig.json in Visual
Studio](https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-
in-typescript/tsconfig-in-vs.png)

We also disable the project properties page when you add a `tsconfig.json`
file. This means that all configuration changes have to be made in the
`tsconfig.json` file itself.

### A couple of limitations

  * If you add a `tsconfig.json` file, TypeScript files that are not considered part of that context are not compiled.
  * Apache Cordova Apps still have the existing limitation of a single `tsconfig.json` file, which must be in either the root or the `scripts` folder.
  * There is no template for `tsconfig.json` in most project types.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
1.8.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

M![MAKSS
\(1\)](https://gravatar.com/avatar/4db25e35f71ba7a814a6e95ba477702d?s=32&&d=blank)

7+

Last updated: Sep 16, 2024  
  

  Was this page helpful?

# TypeScript 2.0

## Null- and undefined-aware types

TypeScript has two special types, Null and Undefined, that have the values
`null` and `undefined` respectively. Previously it was not possible to
explicitly name these types, but `null` and `undefined` may now be used as
type names regardless of type checking mode.

The type checker previously considered `null` and `undefined` assignable to
anything. Effectively, `null` and `undefined` were valid values of _every_
type and it wasn‚Äôt possible to specifically exclude them (and therefore not
possible to detect erroneous use of them).

## `--strictNullChecks`

[`strictNullChecks`](/tsconfig#strictNullChecks) switches to a new strict null
checking mode.

In strict null checking mode, the `null` and `undefined` values are _not_ in the domain of every type and are only assignable to themselves and `any` (the one exception being that `undefined` is also assignable to `void`). So, whereas `T` and `T | undefined` are considered synonymous in regular type checking mode (because `undefined` is considered a subtype of any `T`), they are different types in strict type checking mode, and only `T | undefined` permits `undefined` values. The same is true for the relationship of `T` to `T | null`.

##### Example

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    let x: number;
    
    let y: number | undefined;
    
    let z: number | null | undefined;
    
    x = 1; // Ok
    
    y = 1; // Ok
    
    z = 1; // Ok
    
    x = undefined; // Error
    
    y = undefined; // Ok
    
    z = undefined; // Ok
    
    x = null; // Error
    
    y = null; // Error
    
    z = null; // Ok
    
    x = y; // Error
    
    x = z; // Error
    
    y = x; // Ok
    
    y = z; // Error
    
    z = x; // Ok
    
    z = y; // Ok

## Assigned-before-use checking

In strict null checking mode the compiler requires every reference to a local
variable of a type that doesn‚Äôt include `undefined` to be preceded by an
assignment to that variable in every possible preceding code path.

##### Example

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    let x: number;
    
    let y: number | null;
    
    let z: number | undefined;
    
    x; // Error, reference not preceded by assignment
    
    y; // Error, reference not preceded by assignment
    
    z; // Ok
    
    x = 1;
    
    y = null;
    
    x; // Ok
    
    y; // Ok

The compiler checks that variables are definitely assigned by performing
_control flow based type analysis_. See later for further details on this
topic.

## Optional parameters and properties

Optional parameters and properties automatically have `undefined` added to
their types, even when their type annotations don‚Äôt specifically include
`undefined`. For example, the following two types are identical:

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    type T1 = (x?: number) => string; // x has type number | undefined
    
    type T2 = (x?: number | undefined) => string; // x has type number | undefined

## Non-null and non-undefined type guards

A property access or a function call produces a compile-time error if the
object or function is of a type that includes `null` or `undefined`. However,
type guards are extended to support non-null and non-undefined checks.

##### Example

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    declare function f(x: number): string;
    
    let x: number | null | undefined;
    
    if (x) {
    
      f(x); // Ok, type of x is number here
    
    } else {
    
      f(x); // Error, type of x is number? here
    
    }
    
    let a = x != null ? f(x) : ""; // Type of a is string
    
    let b = x && f(x); // Type of b is string | 0 | null | undefined

Non-null and non-undefined type guards may use the `==`, `!=`, `===`, or `!==`
operator to compare to `null` or `undefined`, as in `x != null` or `x ===
undefined`. The effects on subject variable types accurately reflect
JavaScript semantics (e.g. double-equals operators check for both values no
matter which one is specified whereas triple-equals only checks for the
specified value).

## Dotted names in type guards

Type guards previously only supported checking local variables and parameters.
Type guards now support checking ‚Äúdotted names‚Äù consisting of a variable or
parameter name followed one or more property accesses.

##### Example

    
    
    ts
    
    interface Options {
    
      location?: {
    
        x?: number;
    
        y?: number;
    
      };
    
    }
    
    function foo(options?: Options) {
    
      if (options && options.location && options.location.x) {
    
        const x = options.location.x; // Type of x is number
    
      }
    
    }

Type guards for dotted names also work with user defined type guard functions
and the `typeof` and `instanceof` operators and do not depend on the
[`strictNullChecks`](/tsconfig#strictNullChecks) compiler option.

A type guard for a dotted name has no effect following an assignment to any
part of the dotted name. For example, a type guard for `x.y.z` will have no
effect following an assignment to `x`, `x.y`, or `x.y.z`.

## Expression operators

Expression operators permit operand types to include `null` and/or `undefined`
but always produce values of non-null and non-undefined types.

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    function sum(a: number | null, b: number | null) {
    
      return a + b; // Produces value of type number
    
    }

The `&&` operator adds `null` and/or `undefined` to the type of the right
operand depending on which are present in the type of the left operand, and
the `||` operator removes both `null` and `undefined` from the type of the
left operand in the resulting union type.

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    interface Entity {
    
      name: string;
    
    }
    
    let x: Entity | null;
    
    let s = x && x.name; // s is of type string | null
    
    let y = x || { name: "test" }; // y is of type Entity

## Type widening

The `null` and `undefined` types are _not_ widened to `any` in strict null
checking mode.

    
    
    ts
    
    let z = null; // Type of z is null

In regular type checking mode the inferred type of `z` is `any` because of
widening, but in strict null checking mode the inferred type of `z` is `null`
(and therefore, absent a type annotation, `null` is the only possible value
for `z`).

## Non-null assertion operator

A new `!` post-fix expression operator may be used to assert that its operand
is non-null and non-undefined in contexts where the type checker is unable to
conclude that fact. Specifically, the operation `x!` produces a value of the
type of `x` with `null` and `undefined` excluded. Similar to type assertions
of the forms `<T>x` and `x as T`, the `!` non-null assertion operator is
simply removed in the emitted JavaScript code.

    
    
    ts
    
    // Compiled with --strictNullChecks
    
    function validateEntity(e?: Entity) {
    
      // Throw exception if e is null or invalid entity
    
    }
    
    function processEntity(e?: Entity) {
    
      validateEntity(e);
    
      let s = e!.name; // Assert that e is non-null and access name
    
    }

## Compatibility

The new features are designed such that they can be used in both strict null
checking mode and regular type checking mode. In particular, the `null` and
`undefined` types are automatically erased from union types in regular type
checking mode (because they are subtypes of all other types), and the `!` non-
null assertion expression operator is permitted but has no effect in regular
type checking mode. Thus, declaration files that are updated to use null- and
undefined-aware types can still be used in regular type checking mode for
backwards compatibility.

In practical terms, strict null checking mode requires that all files in a
compilation are null- and undefined-aware.

## Control flow based type analysis

TypeScript 2.0 implements a control flow-based type analysis for local
variables and parameters. Previously, the type analysis performed for type
guards was limited to `if` statements and `?:` conditional expressions and
didn‚Äôt include effects of assignments and control flow constructs such as
`return` and `break` statements. With TypeScript 2.0, the type checker
analyses all possible flows of control in statements and expressions to
produce the most specific type possible (the _narrowed type_) at any given
location for a local variable or parameter that is declared to have a union
type.

##### Example

    
    
    ts
    
    function foo(x: string | number | boolean) {
    
      if (typeof x === "string") {
    
        x; // type of x is string here
    
        x = 1;
    
        x; // type of x is number here
    
      }
    
      x; // type of x is number | boolean here
    
    }
    
    function bar(x: string | number) {
    
      if (typeof x === "number") {
    
        return;
    
      }
    
      x; // type of x is string here
    
    }

Control flow based type analysis is particularly relevant in
[`strictNullChecks`](/tsconfig#strictNullChecks) mode because nullable types
are represented using union types:

    
    
    ts
    
    function test(x: string | null) {
    
      if (x === null) {
    
        return;
    
      }
    
      x; // type of x is string in remainder of function
    
    }

Furthermore, in [`strictNullChecks`](/tsconfig#strictNullChecks) mode, control
flow based type analysis includes _definite assignment analysis_ for local
variables of types that don‚Äôt permit the value `undefined`.

    
    
    ts
    
    function mumble(check: boolean) {
    
      let x: number; // Type doesn't permit undefined
    
      x; // Error, x is undefined
    
      if (check) {
    
        x = 1;
    
        x; // Ok
    
      }
    
      x; // Error, x is possibly undefined
    
      x = 2;
    
      x; // Ok
    
    }

## Tagged union types

TypeScript 2.0 implements support for tagged (or discriminated) union types.
Specifically, the TS compiler now support type guards that narrow union types
based on tests of a discriminant property and furthermore extend that
capability to `switch` statements.

##### Example

    
    
    ts
    
    interface Square {
    
      kind: "square";
    
      size: number;
    
    }
    
    interface Rectangle {
    
      kind: "rectangle";
    
      width: number;
    
      height: number;
    
    }
    
    interface Circle {
    
      kind: "circle";
    
      radius: number;
    
    }
    
    type Shape = Square | Rectangle | Circle;
    
    function area(s: Shape) {
    
      // In the following switch statement, the type of s is narrowed in each case clause
    
      // according to the value of the discriminant property, thus allowing the other properties
    
      // of that variant to be accessed without a type assertion.
    
      switch (s.kind) {
    
        case "square":
    
          return s.size * s.size;
    
        case "rectangle":
    
          return s.width * s.height;
    
        case "circle":
    
          return Math.PI * s.radius * s.radius;
    
      }
    
    }
    
    function test1(s: Shape) {
    
      if (s.kind === "square") {
    
        s; // Square
    
      } else {
    
        s; // Rectangle | Circle
    
      }
    
    }
    
    function test2(s: Shape) {
    
      if (s.kind === "square" || s.kind === "rectangle") {
    
        return;
    
      }
    
      s; // Circle
    
    }

A _discriminant property type guard_ is an expression of the form `x.p == v`,
`x.p === v`, `x.p != v`, or `x.p !== v`, where `p` and `v` are a property and
an expression of a string literal type or a union of string literal types. The
discriminant property type guard narrows the type of `x` to those constituent
types of `x` that have a discriminant property `p` with one of the possible
values of `v`.

Note that we currently only support discriminant properties of string literal
types. We intend to later add support for boolean and numeric literal types.

## The `never` type

TypeScript 2.0 introduces a new primitive type `never`. The `never` type
represents the type of values that never occur. Specifically, `never` is the
return type for functions that never return and `never` is the type of
variables under type guards that are never true.

The `never` type has the following characteristics:

  * `never` is a subtype of and assignable to every type.
  * No type is a subtype of or assignable to `never` (except `never` itself).
  * In a function expression or arrow function with no return type annotation, if the function has no `return` statements, or only `return` statements with expressions of type `never`, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is `never`.
  * In a function with an explicit `never` return type annotation, all `return` statements (if any) must have expressions of type `never` and the end point of the function must not be reachable.

Because `never` is a subtype of every type, it is always omitted from union
types and it is ignored in function return type inference as long as there are
other types being returned.

Some examples of functions returning `never`:

    
    
    ts
    
    // Function returning never must have unreachable end point
    
    function error(message: string): never {
    
      throw new Error(message);
    
    }
    
    // Inferred return type is never
    
    function fail() {
    
      return error("Something failed");
    
    }
    
    // Function returning never must have unreachable end point
    
    function infiniteLoop(): never {
    
      while (true) {}
    
    }

Some examples of use of functions returning `never`:

    
    
    ts
    
    // Inferred return type is number
    
    function move1(direction: "up" | "down") {
    
      switch (direction) {
    
        case "up":
    
          return 1;
    
        case "down":
    
          return -1;
    
      }
    
      return error("Should never get here");
    
    }
    
    // Inferred return type is number
    
    function move2(direction: "up" | "down") {
    
      return direction === "up"
    
        ? 1
    
        : direction === "down"
    
        ? -1
    
        : error("Should never get here");
    
    }
    
    // Inferred return type is T
    
    function check<T>(x: T | undefined) {
    
      return x || error("Undefined value");
    
    }

Because `never` is assignable to every type, a function returning `never` can
be used when a callback returning a more specific type is required:

    
    
    ts
    
    function test(cb: () => string) {
    
      let s = cb();
    
      return s;
    
    }
    
    test(() => "hello");
    
    test(() => fail());
    
    test(() => {
    
      throw new Error();
    
    });

## Read-only properties and index signatures

A property or index signature can now be declared with the `readonly`
modifier.

Read-only properties may have initializers and may be assigned to in
constructors within the same class declaration, but otherwise assignments to
read-only properties are disallowed.

In addition, entities are _implicitly_ read-only in several situations:

  * A property declared with a `get` accessor and no `set` accessor is considered read-only.
  * In the type of an enum object, enum members are considered read-only properties.
  * In the type of a module object, exported `const` variables are considered read-only properties.
  * An entity declared in an `import` statement is considered read-only.
  * An entity accessed through an ES2015 namespace import is considered read-only (e.g. `foo.x` is read-only when `foo` is declared as `import * as foo from "foo"`).

##### Example

    
    
    ts
    
    interface Point {
    
      readonly x: number;
    
      readonly y: number;
    
    }
    
    var p1: Point = { x: 10, y: 20 };
    
    p1.x = 5; // Error, p1.x is read-only
    
    var p2 = { x: 1, y: 1 };
    
    var p3: Point = p2; // Ok, read-only alias for p2
    
    p3.x = 5; // Error, p3.x is read-only
    
    p2.x = 5; // Ok, but also changes p3.x because of aliasing
    
    
    ts
    
    class Foo {
    
      readonly a = 1;
    
      readonly b: string;
    
      constructor() {
    
        this.b = "hello"; // Assignment permitted in constructor
    
      }
    
    }
    
    
    ts
    
    let a: Array<number> = [0, 1, 2, 3, 4];
    
    let b: ReadonlyArray<number> = a;
    
    b[5] = 5; // Error, elements are read-only
    
    b.push(5); // Error, no push method (because it mutates array)
    
    b.length = 3; // Error, length is read-only
    
    a = b; // Error, mutating methods are missing

## Specifying the type of `this` for functions

Following up on specifying the type of `this` in a class or an interface,
functions and methods can now declare the type of `this` they expect.

By default the type of `this` inside a function is `any`. Starting with
TypeScript 2.0, you can provide an explicit `this` parameter. `this`
parameters are fake parameters that come first in the parameter list of a
function:

    
    
    ts
    
    function f(this: void) {
    
      // make sure `this` is unusable in this standalone function
    
    }

## `this` parameters in callbacks

Libraries can also use `this` parameters to declare how callbacks will be
invoked.

##### Example

    
    
    ts
    
    interface UIElement {
    
      addClickListener(onclick: (this: void, e: Event) => void): void;
    
    }

`this: void` means that `addClickListener` expects `onclick` to be a function
that does not require a `this` type.

Now if you annotate calling code with `this`:

    
    
    ts
    
    class Handler {
    
      info: string;
    
      onClickBad(this: Handler, e: Event) {
    
        // oops, used this here. using this callback would crash at runtime
    
        this.info = e.message;
    
      }
    
    }
    
    let h = new Handler();
    
    uiElement.addClickListener(h.onClickBad); // error!

## `--noImplicitThis`

A new flag is also added in TypeScript 2.0 to flag all uses of `this` in
functions without an explicit type annotation.

## Glob support in `tsconfig.json`

Glob support is here!! Glob support has been [one of the most requested
features](https://github.com/Microsoft/TypeScript/issues/1927).

Glob-like file patterns are supported two properties
[`include`](/tsconfig#include) and [`exclude`](/tsconfig#exclude).

##### Example

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[removeComments](https://www.typescriptlang.org/tsconfig#removeComments)": true,
    
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true,
    
        "[outFile](https://www.typescriptlang.org/tsconfig#outFile)": "../../built/local/tsc.js",
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
    
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["node_modules", "**/*.spec.ts"]
    
    }

The supported glob wildcards are:

  * `*` matches zero or more characters (excluding directory separators)
  * `?` matches any one character (excluding directory separators)
  * `**/` recursively matches any subdirectory

If a segment of a glob pattern includes only `*` or `.*`, then only files with
supported extensions are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default
with `.js` and `.jsx` if [`allowJs`](/tsconfig#allowJs) is set to true).

If the [`files`](/tsconfig#files) and [`include`](/tsconfig#include) are both
left unspecified, the compiler defaults to including all TypeScript (`.ts`,
`.d.ts` and `.tsx`) files in the containing directory and subdirectories
except those excluded using the [`exclude`](/tsconfig#exclude) property. JS
files (`.js` and `.jsx`) are also included if [`allowJs`](/tsconfig#allowJs)
is set to true.

If the [`files`](/tsconfig#files) or [`include`](/tsconfig#include) properties
are specified, the compiler will instead include the union of the files
included by those two properties. Files in the directory specified using the
[`outDir`](/tsconfig#outDir) compiler option are always excluded unless
explicitly included via the [`files`](/tsconfig#files) property (even when the
[`exclude`](/tsconfig#exclude) property is specified).

Files included using [`include`](/tsconfig#include) can be filtered using the
[`exclude`](/tsconfig#exclude) property. However, files included explicitly
using the [`files`](/tsconfig#files) property are always included regardless
of [`exclude`](/tsconfig#exclude). The [`exclude`](/tsconfig#exclude) property
defaults to excluding the `node_modules`, `bower_components`, and
`jspm_packages` directories when not specified.

## Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing

TypeScript 2.0 provides a set of additional module resolution knops to
_inform_ the compiler where to find declarations for a given module.

See [Module Resolution](http://www.typescriptlang.org/docs/handbook/module-
resolution.html) documentation for more details.

## Base URL

Using a [`baseUrl`](/tsconfig#baseUrl) is a common practice in applications
using AMD module loaders where modules are ‚Äúdeployed‚Äù to a single folder at
run-time. All module imports with bare specifier names are assumed to be
relative to the [`baseUrl`](/tsconfig#baseUrl).

##### Example

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[baseUrl](https://www.typescriptlang.org/tsconfig#baseUrl)": "./modules"
    
      }
    
    }

Now imports to `"moduleA"` would be looked up in `./modules/moduleA`

    
    
    ts
    
    import A from "moduleA";

## Path mapping

Sometimes modules are not directly located under _baseUrl_. Loaders use a
mapping configuration to map module names to files at run-time, see [RequireJs
documentation](http://requirejs.org/docs/api.html#config-paths) and [SystemJS
documentation](https://github.com/systemjs/systemjs/blob/main/docs/import-
maps.md).

The TypeScript compiler supports the declaration of such mappings using
[`paths`](/tsconfig#paths) property in `tsconfig.json` files.

##### Example

For instance, an import to a module `"jquery"` would be translated at runtime
to `"node_modules/jquery/dist/jquery.slim.min.js"`.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[baseUrl](https://www.typescriptlang.org/tsconfig#baseUrl)": "./node_modules",
    
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
    
          "jquery": ["jquery/dist/jquery.slim.min"]
    
        }
    
    }

Using [`paths`](/tsconfig#paths) also allow for more sophisticated mappings
including multiple fall back locations. Consider a project configuration where
only some modules are available in one location, and the rest are in another.

## Virtual Directories with `rootDirs`

Using ‚ÄòrootDirs‚Äô, you can inform the compiler of the _roots_ making up this
‚Äúvirtual‚Äù directory; and thus the compiler can resolve relative modules
imports within these ‚Äúvirtual‚Äù directories _as if_ they were merged together
in one directory.

##### Example

Given this project structure:

    
    
     src
     ‚îî‚îÄ‚îÄ views
         ‚îî‚îÄ‚îÄ view1.ts (imports './template1')
         ‚îî‚îÄ‚îÄ view2.ts
    
     generated
     ‚îî‚îÄ‚îÄ templates
             ‚îî‚îÄ‚îÄ views
                 ‚îî‚îÄ‚îÄ template1.ts (imports './view2')

A build step will copy the files in `/src/views` and
`/generated/templates/views` to the same directory in the output. At run-time,
a view can expect its template to exist next to it, and thus should import it
using a relative name as `"./template"`.

[`rootDirs`](/tsconfig#rootDirs) specify a list of _roots_ whose contents are
expected to merge at run-time. So following our example, the `tsconfig.json`
file should look like:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src/views", "generated/templates/views"]
    
      }
    
    }

## Tracing module resolution

[`traceResolution`](/tsconfig#traceResolution) offers a handy way to
understand how modules have been resolved by the compiler.

    
    
    shell
    
    tsc --traceResolution

## Shorthand ambient module declarations

If you don‚Äôt want to take the time to write out declarations before using a
new module, you can now just use a shorthand declaration to get started
quickly.

##### declarations.d.ts

    
    
    ts
    
    declare module "hot-new-module";

All imports from a shorthand module will have the any type.

    
    
    ts
    
    import x, { y } from "hot-new-module";
    
    x(y);

## Wildcard character in module names

Importing none-code resources using module loaders extension (e.g.
[AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md) or
[SystemJS](https://github.com/systemjs/systemjs/blob/main/docs/module-
types.md)) has not been easy before; previously an ambient module declaration
had to be defined for each resource.

TypeScript 2.0 supports the use of the wildcard character (`*`) to declare a
‚Äúfamily‚Äù of module names; this way, a declaration is only required once for an
extension, and not for every resource.

##### Example

    
    
    ts
    
    declare module "*!text" {
    
      const content: string;
    
      export default content;
    
    }
    
    // Some do it the other way around.
    
    declare module "json!*" {
    
      const value: any;
    
      export default value;
    
    }

Now you can import things that match `"*!text"` or `"json!*"`.

    
    
    ts
    
    import fileContent from "./xyz.txt!text";
    
    import data from "json!http://example.com/data.json";
    
    console.log(data, fileContent);

Wildcard module names can be even more useful when migrating from an un-typed
code base. Combined with Shorthand ambient module declarations, a set of
modules can be easily declared as `any`.

##### Example

    
    
    ts
    
    declare module "myLibrary/*";

All imports to any module under `myLibrary` would be considered to have the
type `any` by the compiler; thus, shutting down any checking on the shapes or
types of these modules.

    
    
    ts
    
    import { readFile } from "myLibrary/fileSystem/readFile`;
    
    readFile(); // readFile is 'any'

## Support for UMD module definitions

Some libraries are designed to be used in many module loaders, or with no
module loading (global variables). These are known as
[UMD](https://github.com/umdjs/umd) or [Isomorphic](http://isomorphic.net)
modules. These libraries can be accessed through either an import or a global
variable.

For example:

##### math-lib.d.ts

    
    
    ts
    
    export const isPrime(x: number): boolean;
    
    export as namespace mathLib;

The library can then be used as an import within modules:

    
    
    ts
    
    import { isPrime } from "math-lib";
    
    isPrime(2);
    
    mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module

It can also be used as a global variable, but only inside of a script. (A
script is a file with no imports or exports.)

    
    
    ts
    
    mathLib.isPrime(2);

## Optional class properties

Optional properties and methods can now be declared in classes, similar to
what is already permitted in interfaces.

##### Example

    
    
    ts
    
    class Bar {
    
      a: number;
    
      b?: number;
    
      f() {
    
        return 1;
    
      }
    
      g?(): number; // Body of optional method can be omitted
    
      h?() {
    
        return 2;
    
      }
    
    }

When compiled in [`strictNullChecks`](/tsconfig#strictNullChecks) mode, optional properties and methods automatically have `undefined` included in their type. Thus, the `b` property above is of type `number | undefined` and the `g` method above is of type `(() => number) | undefined`. Type guards can be used to strip away the `undefined` part of the type:
    
    
    ts
    
    function test(x: Bar) {
    
      x.a; // number
    
      x.b; // number | undefined
    
      x.f; // () => number
    
      x.g; // (() => number) | undefined
    
      let f1 = x.f(); // number
    
      let g1 = x.g && x.g(); // number | undefined
    
      let g2 = x.g ? x.g() : 0; // number
    
    }

## Private and Protected Constructors

A class constructor may be marked `private` or `protected`. A class with
private constructor cannot be instantiated outside the class body, and cannot
be extended. A class with protected constructor cannot be instantiated outside
the class body, but can be extended.

##### Example

    
    
    ts
    
    class Singleton {
    
      private static instance: Singleton;
    
      private constructor() {}
    
      static getInstance() {
    
        if (!Singleton.instance) {
    
          Singleton.instance = new Singleton();
    
        }
    
        return Singleton.instance;
    
      }
    
    }
    
    let e = new Singleton(); // Error: constructor of 'Singleton' is private.
    
    let v = Singleton.getInstance();

## Abstract properties and accessors

An abstract class can declare abstract properties and/or accessors. Any sub
class will need to declare the abstract properties or be marked as abstract.
Abstract properties cannot have an initializer. Abstract accessors cannot have
bodies.

##### Example

    
    
    ts
    
    abstract class Base {
    
      abstract name: string;
    
      abstract get value();
    
      abstract set value(v: number);
    
    }
    
    class Derived extends Base {
    
      name = "derived";
    
      value = 1;
    
    }

## Implicit index signatures

An object literal type is now assignable to a type with an index signature if
all known properties in the object literal are assignable to that index
signature. This makes it possible to pass a variable that was initialized with
an object literal as parameter to a function that expects a map or dictionary:

    
    
    ts
    
    function httpService(path: string, headers: { [x: string]: string }) {}
    
    const headers = {
    
      "Content-Type": "application/x-www-form-urlencoded",
    
    };
    
    httpService("", { "Content-Type": "application/x-www-form-urlencoded" }); // Ok
    
    httpService("", headers); // Now ok, previously wasn't

## Including built-in type declarations with `--lib`

Getting to ES6/ES2015 built-in API declarations were only limited to `target:
ES6`. Enter [`lib`](/tsconfig#lib); with [`lib`](/tsconfig#lib) you can
specify a list of built-in API declaration groups that you can choose to
include in your project. For instance, if you expect your runtime to have
support for `Map`, `Set` and `Promise` (e.g. most evergreen browsers today),
just include `--lib es2015.collection,es2015.promise`. Similarly you can
exclude declarations you do not want to include in your project, e.g. DOM if
you are working on a node project using `--lib es5,es6`.

Here is a list of available API groups:

  * dom
  * webworker
  * es5
  * es6 / es2015
  * es2015.core
  * es2015.collection
  * es2015.iterable
  * es2015.promise
  * es2015.proxy
  * es2015.reflect
  * es2015.generator
  * es2015.symbol
  * es2015.symbol.wellknown
  * es2016
  * es2016.array.include
  * es2017
  * es2017.object
  * es2017.sharedmemory
  * scripthost

##### Example

    
    
    bash
    
    tsc --target es5 --lib es5,es2015.promise
    
    
    "compilerOptions": {
    
        "[lib](https://www.typescriptlang.org/tsconfig#lib)": ["es5", "es2015.promise"]
    
    }

## Flag unused declarations with `--noUnusedParameters` and `--noUnusedLocals`

TypeScript 2.0 has two new flags to help you maintain a clean code base.
[`noUnusedParameters`](/tsconfig#noUnusedParameters) flags any unused function
or method parameters errors. [`noUnusedLocals`](/tsconfig#noUnusedLocals)
flags any unused local (un-exported) declaration like variables, functions,
classes, imports, etc‚Ä¶ Also, unused private members of a class would be
flagged as errors under [`noUnusedLocals`](/tsconfig#noUnusedLocals).

##### Example

    
    
    ts
    
    import B, { readFile } from "./b";
    
    //     ^ Error: `B` declared but never used
    
    readFile();
    
    export function write(message: string, args: string[]) {
    
      //                                 ^^^^  Error: 'arg' declared but never used.
    
      console.log(message);
    
    }

Parameters declaration with names starting with `_` are exempt from the unused
parameter checking. e.g.:

    
    
    ts
    
    function returnNull(_a) {
    
      // OK
    
      return null;
    
    }

## Module identifiers allow for `.js` extension

Before TypeScript 2.0, a module identifier was always assumed to be extension-
less; for instance, given an import as `import d from "./moduleA.js"`, the
compiler looked up the definition of `"moduleA.js"` in `./moduleA.js.ts` or
`./moduleA.js.d.ts`. This made it hard to use bundling/loading tools like
[SystemJS](https://github.com/systemjs/systemjs) that expect URI‚Äôs in their
module identifier.

With TypeScript 2.0, the compiler will look up definition of `"moduleA.js"` in
`./moduleA.ts` or `./moduleA.d.t`.

## Support ‚Äòtarget : es5‚Äô with ‚Äòmodule: es6‚Äô

Previously flagged as an invalid flag combination, `target: es5` and ‚Äòmodule:
es6‚Äô is now supported. This should facilitate using ES2015-based tree shakers
like [rollup](https://github.com/rollup/rollup).

## Trailing commas in function parameter and argument lists

Trailing comma in function parameter and argument lists are now allowed. This
is an implementation for a [Stage-3 ECMAScript
proposal](https://jeffmo.github.io/es-trailing-function-commas/) that emits
down to valid ES3/ES5/ES6.

##### Example

    
    
    ts
    
    function foo(
    
      bar: Bar,
    
      baz: Baz // trailing commas are OK in parameter lists
    
    ) {
    
      // Implementation...
    
    }
    
    foo(
    
      bar,
    
      baz // and in argument lists
    
    );

## New `--skipLibCheck`

TypeScript 2.0 adds a new [`skipLibCheck`](/tsconfig#skipLibCheck) compiler
option that causes type checking of declaration files (files with extension
`.d.ts`) to be skipped. When a program includes large declaration files, the
compiler spends a lot of time type checking declarations that are already
known to not contain errors, and compile times may be significantly shortened
by skipping declaration file type checks.

Since declarations in one file can affect type checking in other files, some
errors may not be detected when [`skipLibCheck`](/tsconfig#skipLibCheck) is
specified. For example, if a non-declaration file augments a type declared in
a declaration file, errors may result that are only reported when the
declaration file is checked. However, in practice such situations are rare.

## Allow duplicate identifiers across declarations

This has been one common source of duplicate definition errors. Multiple
declaration files defining the same members on interfaces.

TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across
blocks, as long as they have _identical_ types.

Within the same block duplicate definitions are still disallowed.

##### Example

    
    
    ts
    
    interface Error {
    
      stack?: string;
    
    }
    
    interface Error {
    
      code?: string;
    
      path?: string;
    
      stack?: string; // OK
    
    }

## New `--declarationDir`

[`declarationDir`](/tsconfig#declarationDir) allows for generating declaration
files in a different location than JavaScript files.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.0.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AB![Andrew Branch
\(1\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

EC![Errol Cleary
\(1\)](https://gravatar.com/avatar/33aa2c7b4128aead4ad5ec2d03583c54?s=32&&d=blank)

K![KarelVerschraegen
\(1\)](https://gravatar.com/avatar/b0336c8acdada91186a9c87bf1574f5e?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.1

## `keyof` and Lookup Types

In JavaScript it is fairly common to have APIs that expect property names as
parameters, but so far it hasn‚Äôt been possible to express the type
relationships that occur in those APIs.

Enter Index Type Query or `keyof`; An indexed type query `keyof T` yields the
type of permitted property names for `T`. A `keyof T` type is considered a
subtype of `string`.

##### Example

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
      location: string;
    
    }
    
    type K1 = keyof Person; // "name" | "age" | "location"
    
    type K2 = keyof Person[]; // "length" | "push" | "pop" | "concat" | ...
    
    type K3 = keyof { [x: string]: Person }; // string

The dual of this is _indexed access types_ , also called _lookup types_.
Syntactically, they look exactly like an element access, but are written as
types:

##### Example

    
    
    ts
    
    type P1 = Person["name"]; // string
    
    type P2 = Person["name" | "age"]; // string | number
    
    type P3 = string["charAt"]; // (pos: number) => string
    
    type P4 = string[]["push"]; // (...items: string[]) => number
    
    type P5 = string[][0]; // string

You can use this pattern with other parts of the type system to get type-safe
lookups.

    
    
    ts
    
    function getProperty<T, K extends keyof T>(obj: T, key: K) {
    
      return obj[key]; // Inferred type is T[K]
    
    }
    
    function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {
    
      obj[key] = value;
    
    }
    
    let x = { foo: 10, bar: "hello!" };
    
    let foo = getProperty(x, "foo"); // number
    
    let bar = getProperty(x, "bar"); // string
    
    let oops = getProperty(x, "wargarbl"); // Error! "wargarbl" is not "foo" | "bar"
    
    setProperty(x, "foo", "string"); // Error!, string expected number

## Mapped Types

One common task is to take an existing type and make each of its properties
entirely optional. Let‚Äôs say we have a `Person`:

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
      location: string;
    
    }

A partial version of it would be:

    
    
    ts
    
    interface PartialPerson {
    
      name?: string;
    
      age?: number;
    
      location?: string;
    
    }

with Mapped types, `PartialPerson` can be written as a generalized
transformation on the type `Person` as:

    
    
    ts
    
    type Partial<T> = {
    
      [P in keyof T]?: T[P];
    
    };
    
    type PartialPerson = Partial<Person>;

Mapped types are produced by taking a union of literal types, and computing a
set of properties for a new object type. They‚Äôre like [list comprehensions in
Python](https://docs.python.org/2/tutorial/datastructures.html#nested-list-
comprehensions), but instead of producing new elements in a list, they produce
new properties in a type.

In addition to `Partial`, Mapped Types can express many useful transformations
on types:

    
    
    ts
    
    // Keep types the same, but make each property to be read-only.
    
    type Readonly<T> = {
    
      readonly [P in keyof T]: T[P];
    
    };
    
    // Same property names, but make the value a promise instead of a concrete one
    
    type Deferred<T> = {
    
      [P in keyof T]: Promise<T[P]>;
    
    };
    
    // Wrap proxies around properties of T
    
    type Proxify<T> = {
    
      [P in keyof T]: { get(): T[P]; set(v: T[P]): void };
    
    };

## `Partial`, `Readonly`, `Record`, and `Pick`

`Partial` and `Readonly`, as described earlier, are very useful constructs.
You can use them to describe some common JS routines like:

    
    
    ts
    
    function assign<T>(obj: T, props: Partial<T>): void;
    
    function freeze<T>(obj: T): Readonly<T>;

Because of that, they are now included by default in the standard library.

We‚Äôre also including two other utility types as well: `Record` and `Pick`.

    
    
    ts
    
    // From T pick a set of properties K
    
    declare function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;
    
    const nameAndAgeOnly = pick(person, "name", "age"); // { name: string, age: number }
    
    
    ts
    
    // For every properties K of type T, transform it to U
    
    function mapObject<K extends string, T, U>(
    
      obj: Record<K, T>,
    
      f: (x: T) => U
    
    ): Record<K, U>;
    
    const names = { foo: "hello", bar: "world", baz: "bye" };
    
    const lengths = mapObject(names, s => s.length); // { foo: number, bar: number, baz: number }

## Object Spread and Rest

TypeScript 2.1 brings support for [ESnext Spread and
Rest](https://github.com/sebmarkbage/ecmascript-rest-spread).

Similar to array spread, spreading an object can be handy to get a shallow
copy:

    
    
    ts
    
    let copy = { ...original };

Similarly, you can merge several different objects. In the following example,
`merged` will have properties from `foo`, `bar`, and `baz`.

    
    
    ts
    
    let merged = { ...foo, ...bar, ...baz };

You can also override existing properties and add new ones:

    
    
    ts
    
    let obj = { x: 1, y: "string" };
    
    var newObj = { ...obj, z: 3, y: 4 }; // { x: number, y: number, z: number }

The order of specifying spread operations determines what properties end up in
the resulting object; properties in later spreads ‚Äúwin out‚Äù over previously
created properties.

Object rests are the dual of object spreads, in that they can extract any
extra properties that don‚Äôt get picked up when destructuring an element:

    
    
    ts
    
    let obj = { x: 1, y: 1, z: 1 };
    
    let { z, ...obj1 } = obj;
    
    obj1; // {x: number, y:number};

## Downlevel Async Functions

This feature was supported before TypeScript 2.1, but only when targeting
ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times,
meaning you‚Äôll be free to take advantage of it no matter what environment
you‚Äôre using.

> Note: first, we need to make sure our run-time has an ECMAScript-compliant
> `Promise` available globally. That might involve grabbing [a
> polyfill](https://github.com/stefanpenner/es6-promise) for `Promise`, or
> relying on one that you might have in the run-time that you‚Äôre targeting. We
> also need to make sure that TypeScript knows `Promise` exists by setting
> your [`lib`](/tsconfig#lib) option to something like `"dom", "es2015"` or
> `"dom", "es2015.promise", "es5"`

##### Example

##### tsconfig.json

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[lib](https://www.typescriptlang.org/tsconfig#lib)": ["dom", "es2015.promise", "es5"]
    
      }
    
    }

##### dramaticWelcome.ts

    
    
    ts
    
    function delay(milliseconds: number) {
    
      return new Promise<void>(resolve => {
    
        setTimeout(resolve, milliseconds);
    
      });
    
    }
    
    async function dramaticWelcome() {
    
      console.log("Hello");
    
      for (let i = 0; i < 3; i++) {
    
        await delay(500);
    
        console.log(".");
    
      }
    
      console.log("World!");
    
    }
    
    dramaticWelcome();

Compiling and running the output should result in the correct behavior on an
ES3/ES5 engine.

## Support for external helpers library (`tslib`)

TypeScript injects a handful of helper functions such as `__extends` for
inheritance, `__assign` for spread operator in object literals and JSX
elements, and `__awaiter` for async functions.

Previously there were two options:

  1. inject helpers in _every_ file that needs them, or
  2. no helpers at all with [`noEmitHelpers`](/tsconfig#noEmitHelpers).

The two options left more to be desired; bundling the helpers in every file
was a pain point for customers trying to keep their package size small. And
not including helpers, meant customers had to maintain their own helpers
library.

TypeScript 2.1 allows for including these files in your project once in a
separate module, and the compiler will emit imports to them as needed.

First, install the [`tslib`](https://github.com/Microsoft/tslib) utility
library:

    
    
    sh
    
    npm install tslib

Second, compile your files using [`importHelpers`](/tsconfig#importHelpers):

    
    
    sh
    
    tsc --module commonjs --importHelpers a.ts

So given the following input, the resulting `.js` file will include an import
to `tslib` and use the `__assign` helper from it instead of inlining it.

    
    
    ts
    
    export const o = { a: 1, name: "o" };
    
    export const copy = { ...o };
    
    
    js
    
    "use strict";
    
    var tslib_1 = require("tslib");
    
    exports.o = { a: 1, name: "o" };
    
    exports.copy = tslib_1.__assign({}, exports.o);

## Untyped imports

TypeScript has traditionally been overly strict about how you can import
modules. This was to avoid typos and prevent users from using modules
incorrectly.

However, a lot of the time, you might just want to import an existing module
that may not have its own `.d.ts` file. Previously this was an error. Starting
with TypeScript 2.1 this is now much easier.

With TypeScript 2.1, you can import a JavaScript module without needing a type
declaration. A type declaration (such as `declare module "foo" { ... }` or
`node_modules/@types/foo`) still takes priority if it exists.

An import to a module with no declaration file will still be flagged as an
error under [`noImplicitAny`](/tsconfig#noImplicitAny).

##### Example

    
    
    ts
    
    // Succeeds if `node_modules/asdf/index.js` exists
    
    import { x } from "asdf";

## Support for `--target ES2016`, `--target ES2017` and `--target ESNext`

TypeScript 2.1 supports three new target values `--target ES2016`, `--target
ES2017` and `--target ESNext`.

Using target `--target ES2016` will instruct the compiler not to transform
ES2016-specific features, e.g. `**` operator.

Similarly, `--target ES2017` will instruct the compiler not to transform
ES2017-specific features like `async`/`await`.

`--target ESNext` targets latest supported [ES proposed
features](https://github.com/tc39/proposals).

## Improved `any` Inference

Previously, if TypeScript couldn‚Äôt figure out the type of a variable, it would
choose the `any` type.

    
    
    ts
    
    let x; // implicitly 'any'
    
    let y = []; // implicitly 'any[]'
    
    let z: any; // explicitly 'any'.

With TypeScript 2.1, instead of just choosing `any`, TypeScript will infer
types based on what you end up assigning later on.

This is only enabled if [`noImplicitAny`](/tsconfig#noImplicitAny) is set.

##### Example

    
    
    ts
    
    let x;
    
    // You can still assign anything you want to 'x'.
    
    x = () => 42;
    
    // After that last assignment, TypeScript 2.1 knows that 'x' has type '() => number'.
    
    let y = x();
    
    // Thanks to that, it will now tell you that you can't add a number to a function!
    
    console.log(x + y);
    
    //          ~~~~~
    
    // Error! Operator '+' cannot be applied to types '() => number' and 'number'.
    
    // TypeScript still allows you to assign anything you want to 'x'.
    
    x = "Hello world!";
    
    // But now it also knows that 'x' is a 'string'!
    
    x.toLowerCase();

The same sort of tracking is now also done for empty arrays.

A variable declared with no type annotation and an initial value of `[]` is
considered an implicit `any[]` variable. However, each subsequent
`x.push(value)`, `x.unshift(value)` or `x[n] = value` operation _evolves_ the
type of the variable in accordance with what elements are added to it.

    
    
    ts
    
    function f1() {
    
      let x = [];
    
      x.push(5);
    
      x[1] = "hello";
    
      x.unshift(true);
    
      return x; // (string | number | boolean)[]
    
    }
    
    function f2() {
    
      let x = null;
    
      if (cond()) {
    
        x = [];
    
        while (cond()) {
    
          x.push("hello");
    
        }
    
      }
    
      return x; // string[] | null
    
    }

## Implicit any errors

One great benefit of this is that you‚Äôll see _way fewer_ implicit `any` errors
when running with [`noImplicitAny`](/tsconfig#noImplicitAny). Implicit `any`
errors are only reported when the compiler is unable to know the type of a
variable without a type annotation.

##### Example

    
    
    ts
    
    function f3() {
    
      let x = []; // Error: Variable 'x' implicitly has type 'any[]' in some locations where its type cannot be determined.
    
      x.push(5);
    
      function g() {
    
        x; // Error: Variable 'x' implicitly has an 'any[]' type.
    
      }
    
    }

## Better inference for literal types

String, numeric and boolean literal types (e.g. `"abc"`, `1`, and `true`) were
previously inferred only in the presence of an explicit type annotation.
Starting with TypeScript 2.1, literal types are _always_ inferred for `const`
variables and `readonly` properties.

The type inferred for a `const` variable or `readonly` property without a type
annotation is the type of the literal initializer. The type inferred for a
`let` variable, `var` variable, parameter, or non-`readonly` property with an
initializer and no type annotation is the widened literal type of the
initializer. Where the widened type for a string literal type is `string`,
`number` for numeric literal types, `boolean` for `true` or `false` and the
containing enum for enum literal types.

##### Example

    
    
    ts
    
    const c1 = 1; // Type 1
    
    const c2 = c1; // Type 1
    
    const c3 = "abc"; // Type "abc"
    
    const c4 = true; // Type true
    
    const c5 = cond ? 1 : "abc"; // Type 1 | "abc"
    
    let v1 = 1; // Type number
    
    let v2 = c2; // Type number
    
    let v3 = c3; // Type string
    
    let v4 = c4; // Type boolean
    
    let v5 = c5; // Type number | string

Literal type widening can be controlled through explicit type annotations.
Specifically, when an expression of a literal type is inferred for a const
location without a type annotation, that `const` variable gets a widening
literal type inferred. But when a `const` location has an explicit literal
type annotation, the `const` variable gets a non-widening literal type.

##### Example

    
    
    ts
    
    const c1 = "hello"; // Widening type "hello"
    
    let v1 = c1; // Type string
    
    const c2: "hello" = "hello"; // Type "hello"
    
    let v2 = c2; // Type "hello"

## Use returned values from super calls as ‚Äòthis‚Äô

In ES2015, constructors which return an object implicitly substitute the value
of `this` for any callers of `super()`. As a result, it is necessary to
capture any potential return value of `super()` and replace it with `this`.
This change enables working with [Custom
Elements](https://www.w3.org/TR/custom-elements/), which takes advantage of
this to initialize browser-allocated elements with user-written constructors.

##### Example

    
    
    ts
    
    class Base {
    
      x: number;
    
      constructor() {
    
        // return a new object other than `this`
    
        return {
    
          x: 1
    
        };
    
      }
    
    }
    
    class Derived extends Base {
    
      constructor() {
    
        super();
    
        this.x = 2;
    
      }
    
    }

Generates:

    
    
    js
    
    var Derived = (function(_super) {
    
      __extends(Derived, _super);
    
      function Derived() {
    
        var _this = _super.call(this) || this;
    
        _this.x = 2;
    
        return _this;
    
      }
    
      return Derived;
    
    })(Base);

> This change entails a break in the behavior of extending built-in classes
> like `Error`, `Array`, `Map`, etc.. Please see the [extending built-ins
> breaking change documentation](https://github.com/Microsoft/TypeScript-
> wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-
> and-map-may-no-longer-work) for more details.

## Configuration inheritance

Often a project has multiple output targets, e.g. `ES5` and `ES2015`, debug
and production or `CommonJS` and `System`; Just a few configuration options
change between these two targets, and maintaining multiple `tsconfig.json`
files can be a hassle.

TypeScript 2.1 supports inheriting configuration using `extends`, where:

  * `extends` is a new top-level property in `tsconfig.json` (alongside `compilerOptions`, [`files`](/tsconfig#files), [`include`](/tsconfig#include), and [`exclude`](/tsconfig#exclude)).
  * The value of `extends` must be a string containing a path to another configuration file to inherit from.
  * The configuration from the base file are loaded first, then overridden by those in the inheriting config file.
  * Circularity between configuration files is not allowed.
  * [`files`](/tsconfig#files), [`include`](/tsconfig#include), and [`exclude`](/tsconfig#exclude) from the inheriting config file _overwrite_ those from the base config file.
  * All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.

##### Example

`configs/base.json`:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": true
    
      }
    
    }

`tsconfig.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./configs/base",
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["main.ts", "supplemental.ts"]
    
    }

`tsconfig.nostrictnull.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./tsconfig",
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": false
    
      }
    
    }

## New `--alwaysStrict`

Invoking the compiler with [`alwaysStrict`](/tsconfig#alwaysStrict) causes:

  1. Parses all the code in strict mode.
  2. Writes `"use strict";` directive atop every generated file.

Modules are parsed automatically in strict mode. The new flag is recommended
for non-module code.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.1.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(58\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AG![Anton Gilgur
\(1\)](https://gravatar.com/avatar/20827df1809becc22927b5ef5dfcde8d?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

M![MAKSS
\(1\)](https://gravatar.com/avatar/4db25e35f71ba7a814a6e95ba477702d?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.2

## Support for Mix-in classes

TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see
[MDN Mixin
description](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Classes#Mix-
ins) and [‚ÄúReal‚Äù Mixins with JavaScript
Classes](http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-
classes/) for more details) as well as rules for combining mixin construct
signatures with regular construct signatures in intersection types.

##### First some terminology

A **mixin constructor type** refers to a type that has a single construct
signature with a single rest argument of type `any[]` and an object-like
return type. For example, given an object-like type `X`, `new (...args: any[])
=> X` is a mixin constructor type with an instance type `X`.

A **mixin class** is a class declaration or expression that `extends` an
expression of a type parameter type. The following rules apply to mixin class
declarations:

  * The type parameter type of the `extends` expression must be constrained to a mixin constructor type.
  * The constructor of a mixin class (if any) must have a single rest parameter of type `any[]` and must use the spread operator to pass those parameters as arguments in a `super(...args)` call.

Given an expression `Base` of a parametric type `T` with a constraint `X`, a
mixin class `class C extends Base {...}` is processed as if `Base` had type
`X` and the resulting type is the intersection `typeof C & T`. In other words,
a mixin class is represented as an intersection between the mixin class
constructor type and the parametric base class constructor type.

When obtaining the construct signatures of an intersection type that contains
mixin constructor types, the mixin construct signatures are discarded and
their instance types are mixed into the return types of the other construct
signatures in the intersection type. For example, the intersection type `{
new(...args: any[]) => A } & { new(s: string) => B }` has a single construct
signature `new(s: string) => A & B`.

##### Putting all of the above rules together in an example

    
    
    ts
    
    class Point {
    
      constructor(public x: number, public y: number) {}
    
    }
    
    class Person {
    
      constructor(public name: string) {}
    
    }
    
    type Constructor<T> = new (...args: any[]) => T;
    
    function Tagged<T extends Constructor<{}>>(Base: T) {
    
      return class extends Base {
    
        _tag: string;
    
        constructor(...args: any[]) {
    
          super(...args);
    
          this._tag = "";
    
        }
    
      };
    
    }
    
    const TaggedPoint = Tagged(Point);
    
    let point = new TaggedPoint(10, 20);
    
    point._tag = "hello";
    
    class Customer extends Tagged(Person) {
    
      accountBalance: number;
    
    }
    
    let customer = new Customer("Joe");
    
    customer._tag = "test";
    
    customer.accountBalance = 0;

Mixin classes can constrain the types of classes they can mix into by
specifying a construct signature return type in the constraint for the type
parameter. For example, the following `WithLocation` function implements a
subclass factory that adds a `getLocation` method to any class that satisfies
the `Point` interface (i.e. that has `x` and `y` properties of type `number`).

    
    
    ts
    
    interface Point {
    
      x: number;
    
      y: number;
    
    }
    
    const WithLocation = <T extends Constructor<Point>>(Base: T) =>
    
      class extends Base {
    
        getLocation(): [number, number] {
    
          return [this.x, this.y];
    
        }
    
      };

## `object` type

TypeScript did not have a type that represents the non-primitive type, i.e.
any thing that is not `number`, `string`, `boolean`, `symbol`, `null`, or
`undefined`. Enter the new `object` type.

With `object` type, APIs like `Object.create` can be better represented. For
example:

    
    
    ts
    
    declare function create(o: object | null): void;
    
    create({ prop: 0 }); // OK
    
    create(null); // OK
    
    create(42); // Error
    
    create("string"); // Error
    
    create(false); // Error
    
    create(undefined); // Error

## Support for `new.target`

The `new.target` meta-property is new syntax introduced in ES2015. When an
instance of a constructor is created via `new`, the value of `new.target` is
set to be a reference to the constructor function initially used to allocate
the instance. If a function is called rather than constructed via `new`,
`new.target` is set to `undefined`.

`new.target` comes in handy when `Object.setPrototypeOf` or `__proto__` needs
to be set in a class constructor. One such use case is inheriting from `Error`
in NodeJS v4 and higher.

##### Example

    
    
    ts
    
    class CustomError extends Error {
    
      constructor(message?: string) {
    
        super(message); // 'Error' breaks prototype chain here
    
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    
      }
    
    }

This results in the generated JS

    
    
    js
    
    var CustomError = (function(_super) {
    
      __extends(CustomError, _super);
    
      function CustomError() {
    
        var _newTarget = this.constructor;
    
        var _this = _super.apply(this, arguments); // 'Error' breaks prototype chain here
    
        _this.__proto__ = _newTarget.prototype; // restore prototype chain
    
        return _this;
    
      }
    
      return CustomError;
    
    })(Error);

`new.target` also comes in handy for writing constructable functions, for
example:

    
    
    ts
    
    function f() {
    
      if (new.target) {
    
        /* called via 'new' */
    
      }
    
    }

Which translates to:

    
    
    js
    
    function f() {
    
      var _newTarget = this && this instanceof f ? this.constructor : void 0;
    
      if (_newTarget) {
    
        /* called via 'new' */
    
      }
    
    }

## Better checking for `null`/`undefined` in operands of expressions

TypeScript 2.2 improves checking of nullable operands in expressions.
Specifically, these are now flagged as errors:

  * If either operand of a `+` operator is nullable, and neither operand is of type `any` or `string`.
  * If either operand of a `-`, `*`, `**`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, or `^` operator is nullable.
  * If either operand of a `<`, `>`, `<=`, `>=`, or `in` operator is nullable.
  * If the right operand of an `instanceof` operator is nullable.
  * If the operand of a `+`, `-`, `~`, `++`, or `--` unary operator is nullable.

An operand is considered nullable if the type of the operand is `null` or
`undefined` or a union type that includes `null` or `undefined`. Note that the
union type case only only occurs in
[`strictNullChecks`](/tsconfig#strictNullChecks) mode because `null` and
`undefined` disappear from unions in classic type checking mode.

## Dotted property for types with string index signatures

Types with a string index signature can be indexed using the `[]` notation,
but were not allowed to use the `.`. Starting with TypeScript 2.2 using either
should be allowed.

    
    
    ts
    
    interface StringMap<T> {
    
      [x: string]: T;
    
    }
    
    const map: StringMap<number>;
    
    map["prop1"] = 1;
    
    map.prop2 = 2;

This only apply to types with an _explicit_ string index signature. It is
still an error to access unknown properties on a type using `.` notation.

## Support for spread operator on JSX element children

TypeScript 2.2 adds support for using spread on a JSX element children. Please
see [facebook/jsx#57](https://github.com/facebook/jsx/issues/57) for more
details.

##### Example

    
    
    ts
    
    function Todo(prop: { key: number; todo: string }) {
    
      return <div>{prop.key.toString() + prop.todo}</div>;
    
    }
    
    function TodoList({ todos }: TodoListProps) {
    
      return (
    
        <div>{...todos.map(todo => <Todo key={todo.id} todo={todo.todo} />)}</div>
    
      );
    
    }
    
    let x: TodoListProps;
    
    <TodoList {...x} />;

## New `jsx: react-native`

React-native build pipeline expects all files to have a `.js` extensions even
if the file contains JSX syntax. The new [`jsx`](/tsconfig#jsx) value `react-
native` will persevere the JSX syntax in the output file, but give it a `.js`
extension.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.2.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

EB![Eli Barzilay
\(1\)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.3

## Generators and Iteration for ES5/ES3

_First some ES2016 terminology:_

##### Iterators

[ES2015 introduced `Iterator`](http://www.ecma-
international.org/ecma-262/6.0/#sec-iteration), which is an object that
exposes three methods, `next`, `return`, and `throw`, as per the following
interface:

    
    
    ts
    
    interface Iterator<T> {
    
      next(value?: any): IteratorResult<T>;
    
      return?(value?: any): IteratorResult<T>;
    
      throw?(e?: any): IteratorResult<T>;
    
    }

This kind of iterator is useful for iterating over synchronously available
values, such as the elements of an Array or the keys of a Map. An object that
supports iteration is said to be ‚Äúiterable‚Äù if it has a `Symbol.iterator`
method that returns an `Iterator` object.

The Iterator protocol also defines the target of some of the ES2015 features
like `for..of` and spread operator and the array rest in destructuring
assignments.

##### Generators

[ES2015 also introduced ‚ÄúGenerators‚Äù](http://www.ecma-
international.org/ecma-262/6.0/#sec-generatorfunction-objects), which are
functions that can be used to yield partial computation results via the
`Iterator` interface and the `yield` keyword. Generators can also internally
delegate calls to another iterable through `yield *`. For example:

    
    
    ts
    
    function* f() {
    
      yield 1;
    
      yield* [2, 3];
    
    }

##### New `--downlevelIteration`

Previously generators were only supported if the target is ES6/ES2015 or
later. Moreover, constructs that operate on the Iterator protocol, e.g.
`for..of` were only supported if they operate on arrays for targets below
ES6/ES2015.

TypeScript 2.3 adds full support for generators and the Iterator protocol for
ES3 and ES5 targets with [`downlevelIteration`](/tsconfig#downlevelIteration)
flag.

With [`downlevelIteration`](/tsconfig#downlevelIteration), the compiler uses
new type check and emit behavior that attempts to call a `[Symbol.iterator]()`
method on the iterated object if it is found, and creates a synthetic array
iterator over the object if it is not.

> Please note that this requires a native `Symbol.iterator` or
> `Symbol.iterator` shim at runtime for any non-array values.

`for..of` statements, Array Destructuring, and Spread elements in Array, Call,
and New expressions support `Symbol.iterator` in ES5/E3 if available when
using [`downlevelIteration`](/tsconfig#downlevelIteration), but can be used on
an Array even if it does not define `Symbol.iterator` at run time or design
time.

## Async Iteration

TypeScript 2.3 adds support for the async iterators and generators as
described by the current [TC39 proposal](https://github.com/tc39/proposal-
async-iteration).

##### Async iterators

The Async Iteration introduces an `AsyncIterator`, which is similar to
`Iterator`. The difference lies in the fact that the `next`, `return`, and
`throw` methods of an `AsyncIterator` return a `Promise` for the iteration
result, rather than the result itself. This allows the caller to enlist in an
asynchronous notification for the time at which the `AsyncIterator` has
advanced to the point of yielding a value. An `AsyncIterator` has the
following shape:

    
    
    ts
    
    interface AsyncIterator<T> {
    
      next(value?: any): Promise<IteratorResult<T>>;
    
      return?(value?: any): Promise<IteratorResult<T>>;
    
      throw?(e?: any): Promise<IteratorResult<T>>;
    
    }

An object that supports async iteration is said to be ‚Äúiterable‚Äù if it has a
`Symbol.asyncIterator` method that returns an `AsyncIterator` object.

##### Async Generators

The [Async Iteration proposal](https://github.com/tc39/proposal-async-
iteration) introduces ‚ÄúAsync Generators‚Äù, which are async functions that also
can be used to yield partial computation results. Async Generators can also
delegate calls via `yield*` to either an iterable or async iterable:

    
    
    ts
    
    async function* g() {
    
      yield 1;
    
      await sleep(100);
    
      yield* [2, 3];
    
      yield* (async function*() {
    
        await sleep(100);
    
        yield 4;
    
      })();
    
    }

As with Generators, Async Generators can only be function declarations,
function expressions, or methods of classes or object literals. Arrow
functions cannot be Async Generators. Async Generators require a valid, global
`Promise` implementation (either native or an ES2015-compatible polyfill), in
addition to a valid `Symbol.asyncIterator` reference (either a native symbol
or a shim).

##### The `for-await-of` Statement

Finally, ES2015 introduced the `for..of` statement as a means of iterating
over an iterable. Similarly, the Async Iteration proposal introduces the
`for..await..of` statement to iterate over an async iterable:

    
    
    ts
    
    async function f() {
    
      for await (const x of g()) {
    
        console.log(x);
    
      }
    
    }

The `for..await..of` statement is only legal within an Async Function or Async
Generator.

##### Caveats

  * Keep in mind that our support for async iterators relies on support for `Symbol.asyncIterator` to exist at runtime. You may need to polyfill `Symbol.asyncIterator`, which for simple purposes can be as simple as: `(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");`
  * You also need to include `esnext` in your [`lib`](/tsconfig#lib) option, to get the `AsyncIterator` declaration if you do not already have it.
  * Finally, if your target is ES5 or ES3, you‚Äôll also need to set the `--downlevelIterators` flag.

## Generic parameter defaults

TypeScript 2.3 adds support for declaring defaults for generic type
parameters.

##### Example

Consider a function that creates a new `HTMLElement`, calling it with no
arguments generates a `Div`; you can optionally pass a list of children as
well. Previously you would have to define it as:

    
    
    ts
    
    declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;
    
    declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;
    
    declare function create<T extends HTMLElement, U extends HTMLElement>(
    
      element: T,
    
      children: U[]
    
    ): Container<T, U[]>;

With generic parameter defaults we can reduce it to:

    
    
    ts
    
    declare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(
    
      element?: T,
    
      children?: U
    
    ): Container<T, U>;

A generic parameter default follows the following rules:

  * A type parameter is deemed optional if it has a default.
  * Required type parameters must not follow optional type parameters.
  * Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.
  * When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.
  * If a default type is specified and inference cannot choose a candidate, the default type is inferred.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.

## New `--strict` master option

New checks added to TypeScript are often off by default to avoid breaking
existing projects. While avoiding breakage is a good thing, this strategy has
the drawback of making it increasingly complex to choose the highest level of
type safety, and doing so requires explicit opt-in action on every TypeScript
release. With the [`strict`](/tsconfig#strict) option it becomes possible to
choose maximum type safety with the understanding that additional errors might
be reported by newer versions of the compiler as improved type checking
features are added.

The new [`strict`](/tsconfig#strict) compiler option represents the
recommended setting of a number of type checking options. Specifically,
specifying [`strict`](/tsconfig#strict) corresponds to specifying all of the
following options (and may in the future include more options):

  * [`strictNullChecks`](/tsconfig#strictNullChecks)
  * [`noImplicitAny`](/tsconfig#noImplicitAny)
  * [`noImplicitThis`](/tsconfig#noImplicitThis)
  * [`alwaysStrict`](/tsconfig#alwaysStrict)

In exact terms, the [`strict`](/tsconfig#strict) option sets the _default_
value for the compiler options listed above. This means it is still possible
to individually control the options. For example,

    
    
    sh
    
    --strict --noImplicitThis false

has the effect of turning on all strict options _except_ the
[`noImplicitThis`](/tsconfig#noImplicitThis) option. Using this scheme it is
possible to express configurations consisting of _all_ strict options except
some explicitly listed options. In other words, it is now possible to default
to the highest level of type safety but opt out of certain checks.

Starting with TypeScript 2.3, the default `tsconfig.json` generated by `tsc
--init` includes a `"strict": true` setting in the `"compilerOptions"`
section. Thus, new projects started with `tsc --init` will by default have the
highest level of type safety enabled.

## Enhanced `--init` output

Along with setting [`strict`](/tsconfig#strict) on by default, `tsc --init`
has an enhanced output. Default `tsconfig.json` files generated by `tsc
--init` now include a set of the common compiler options along with their
descriptions commented out. Just un-comment the configuration you like to set
to get the desired behavior; we hope the new output simplifies the setting up
new projects and keeps configuration files readable as projects grow.

## Errors in .js files with `--checkJs`

By default the TypeScript compiler does not report any errors in .js files
including using [`allowJs`](/tsconfig#allowJs). With TypeScript 2.3 type-
checking errors can also be reported in `.js` files with
[`checkJs`](/tsconfig#checkJs).

You can skip checking some files by adding `// @ts-nocheck` comment to them;
conversely you can choose to check only a few `.js` files by adding `// @ts-
check` comment to them without setting [`checkJs`](/tsconfig#checkJs). You can
also ignore errors on specific lines by adding `// @ts-ignore` on the
preceding line.

`.js` files are still checked to ensure that they only include standard
ECMAScript features; type annotations are only allowed in `.ts` files and are
flagged as errors in `.js` files. JSDoc comments can be used to add some type
information to your JavaScript code, see [JSDoc Support
documentation](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-
JavaScript) for more details about the supported JSDoc constructs.

See [Type checking JavaScript Files
documentation](https://github.com/Microsoft/TypeScript/wiki/Type-Checking-
JavaScript-Files) for more details.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.3.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(51\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

LR![Lars Reimann
\(1\)](https://gravatar.com/avatar/d75b9305d0763a19dc0305a8c4f49546?s=32&&d=blank)

7+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.4

## Dynamic Import Expressions

Dynamic `import` expressions are a new feature and part of ECMAScript that
allows users to asynchronously request a module at any arbitrary point in your
program.

This means that you can conditionally and lazily import other modules and
libraries. For example, here‚Äôs an `async` function that only imports a utility
library when it‚Äôs needed:

    
    
    ts
    
    async function getZipFile(name: string, files: File[]): Promise<File> {
    
      const zipUtil = await import("./utils/create-zip-file");
    
      const zipContents = await zipUtil.getContentAsBlob(files);
    
      return new File(zipContents, name);
    
    }

Many bundlers have support for automatically splitting output bundles based on
these `import` expressions, so consider using this new feature with the
`esnext` module target.

## String Enums

TypeScript 2.4 now allows enum members to contain string initializers.

    
    
    ts
    
    enum Colors {
    
      Red = "RED",
    
      Green = "GREEN",
    
      Blue = "BLUE"
    
    }

The caveat is that string-initialized enums can‚Äôt be reverse-mapped to get the
original enum member name. In other words, you can‚Äôt write `Colors["RED"]` to
get the string `"Red"`.

## Improved inference for generics

TypeScript 2.4 introduces a few wonderful changes around the way generics are
inferred.

### Return types as inference targets

For one, TypeScript can now make inferences for the return type of a call.
This can improve your experience and catch errors. Something that now works:

    
    
    ts
    
    function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[] {
    
      return a => a.map(f);
    
    }
    
    const lengths: (a: string[]) => number[] = arrayMap(s => s.length);

As an example of new errors you might spot as a result:

    
    
    ts
    
    let x: Promise<string> = new Promise(resolve => {
    
      resolve(10);
    
      //      ~~ Error!
    
    });

### Type parameter inference from contextual types

Prior to TypeScript 2.4, in the following example

    
    
    ts
    
    let f: <T>(x: T) => T = y => y;

`y` would have the type `any`. This meant the program would type-check, but
you could technically do anything with `y`, such as the following:

    
    
    ts
    
    let f: <T>(x: T) => T = y => y() + y.foo.bar;

That last example isn‚Äôt actually type-safe.

In TypeScript 2.4, the function on the right side implicitly _gains_ type
parameters, and `y` is inferred to have the type of that type-parameter.

If you use `y` in a way that the type parameter‚Äôs constraint doesn‚Äôt support,
you‚Äôll correctly get an error. In this case, the constraint of `T` was
(implicitly) `{}`, so the last example will appropriately fail.

### Stricter checking for generic functions

TypeScript now tries to unify type parameters when comparing two single-
signature types. As a result, you‚Äôll get stricter checks when relating two
generic signatures, and may catch some bugs.

    
    
    ts
    
    type A = <T, U>(x: T, y: U) => [T, U];
    
    type B = <S>(x: S, y: S) => [S, S];
    
    function f(a: A, b: B) {
    
      a = b; // Error
    
      b = a; // Ok
    
    }

## Strict contravariance for callback parameters

TypeScript has always compared parameters in a bivariant way. There are a
number of reasons for this, but by-and-large this was not been a huge issue
for our users until we saw some of the adverse effects it had with `Promise`s
and `Observable`s.

TypeScript 2.4 introduces tightens this up when relating two callback types.
For example:

    
    
    ts
    
    interface Mappable<T> {
    
      map<U>(f: (x: T) => U): Mappable<U>;
    
    }
    
    declare let a: Mappable<number>;
    
    declare let b: Mappable<string | number>;
    
    a = b;
    
    b = a;

Prior to TypeScript 2.4, this example would succeed. When relating the types
of `map`, TypeScript would bidirectionally relate their parameters (i.e. the
type of `f`). When relating each `f`, TypeScript would also bidirectionally
relate the type of _those_ parameters.

When relating the type of `map` in TS 2.4, the language will check whether
each parameter is a callback type, and if so, it will ensure that those
parameters are checked in a contravariant manner with respect to the current
relation.

In other words, TypeScript now catches the above bug, which may be a breaking
change for some users, but will largely be helpful.

## Weak Type Detection

TypeScript 2.4 introduces the concept of ‚Äúweak types‚Äù. Any type that contains
nothing but a set of all-optional properties is considered to be _weak_. For
example, this `Options` type is a weak type:

    
    
    ts
    
    interface Options {
    
      data?: string;
    
      timeout?: number;
    
      maxRetries?: number;
    
    }

In TypeScript 2.4, it‚Äôs now an error to assign anything to a weak type when
there‚Äôs no overlap in properties. For example:

    
    
    ts
    
    function sendMessage(options: Options) {
    
      // ...
    
    }
    
    const opts = {
    
      payload: "hello world!",
    
      retryOnFail: true
    
    };
    
    // Error!
    
    sendMessage(opts);
    
    // No overlap between the type of 'opts' and 'Options' itself.
    
    // Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.

You can think of this as TypeScript ‚Äútoughening up‚Äù the weak guarantees of
these types to catch what would otherwise be silent bugs.

Since this is a breaking change, you may need to know about the workarounds
which are the same as those for strict object literal checks:

  1. Declare the properties if they really do exist.
  2. Add an index signature to the weak type (i.e. `[propName: string]: {}`).
  3. Use a type assertion (i.e. `opts as Options`).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.4.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(52\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.5

## Optional `catch` clause variables

Thanks to work done by [@tinganho](https://github.com/tinganho), TypeScript
2.5 implements a new ECMAScript feature that allows users to omit the variable
in `catch` clauses. For example, when using `JSON.parse` you may need to wrap
calls to the function with a `try`/`catch`, but you may not end up using the
`SyntaxError` that gets thrown when input is erroneous.

    
    
    ts
    
    let input = "...";
    
    try {
    
      JSON.parse(input);
    
    } catch {
    
      // ^ Notice that our `catch` clause doesn't declare a variable.
    
      console.log("Invalid JSON given\n\n" + input);
    
    }

## Type assertion/cast syntax in `checkJs`/`@ts-check` mode

TypeScript 2.5 introduces the ability to [assert the type of expressions when
using plain JavaScript in your
projects](https://github.com/Microsoft/TypeScript/issues/5158). The syntax is
an `/** @type {...} */` annotation comment followed by a parenthesized
expression whose type needs to be re-evaluated. For example:

    
    
    ts
    
    var x = /** @type {SomeType} */ AnyParenthesizedExpression;

## Deduplicated and redirected packages

When importing using the `Node` module resolution strategy in TypeScript 2.5,
the compiler will now check whether files originate from ‚Äúidentical‚Äù packages.
If a file originates from a package with a `package.json` containing the same
`name` and `version` fields as a previously encountered package, then
TypeScript will redirect itself to the top-most package. This helps resolve
problems where two packages might contain identical declarations of classes,
but which contain `private` members that cause them to be structurally
incompatible.

As a nice bonus, this can also reduce the memory and runtime footprint of the
compiler and language service by avoiding loading `.d.ts` files from duplicate
packages.

## The `--preserveSymlinks` compiler flag

TypeScript 2.5 brings the [`preserveSymlinks`](/tsconfig#preserveSymlinks)
flag, which parallels the behavior of [the `--preserve-symlinks` flag in
Node.js](https://nodejs.org/api/cli.html#cli_preserve_symlinks). This flag
also exhibits the opposite behavior to Webpack‚Äôs `resolve.symlinks` option
(i.e. setting TypeScript‚Äôs [`preserveSymlinks`](/tsconfig#preserveSymlinks) to
`true` parallels setting Webpack‚Äôs `resolve.symlinks` to `false`, and vice-
versa).

In this mode, references to modules and packages (e.g. `import`s and `///
<reference type="..." />` directives) are all resolved relative to the
location of the symbolic link file, rather than relative to the path that the
symbolic link resolves to. For a more concrete example, we‚Äôll defer to [the
documentation on the Node.js
website](https://nodejs.org/api/cli.html#cli_preserve_symlinks).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.5.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(51\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.6

## Strict function types

TypeScript 2.6 introduces a new strict checking flag,
[`strictFunctionTypes`](/tsconfig#strictFunctionTypes). The
[`strictFunctionTypes`](/tsconfig#strictFunctionTypes) switch is part of the
[`strict`](/tsconfig#strict) family of switches, meaning that it defaults to
on in [`strict`](/tsconfig#strict) mode. You can opt-out by setting
`--strictFunctionTypes false` on your command line or in your tsconfig.json.

Under [`strictFunctionTypes`](/tsconfig#strictFunctionTypes) function type
parameter positions are checked _contravariantly_ instead of _bivariantly_.
For some background on what variance means for function types check out [What
are covariance and
contravariance?](https://web.archive.org/web/20220823104433/https://www.stephanboyer.com/post/132/what-
are-covariance-and-contravariance).

The stricter checking applies to all function types, _except_ those
originating in method or constructor declarations. Methods are excluded
specifically to ensure generic classes and interfaces (such as `Array<T>`)
continue to mostly relate covariantly.

Consider the following example in which `Animal` is the supertype of `Dog` and
`Cat`:

    
    
    ts
    
    declare let f1: (x: Animal) => void;
    
    declare let f2: (x: Dog) => void;
    
    declare let f3: (x: Cat) => void;
    
    f1 = f2; // Error with --strictFunctionTypes
    
    f2 = f1; // Ok
    
    f2 = f3; // Error

The first assignment is permitted in default type checking mode, but flagged
as an error in strict function types mode. Intuitively, the default mode
permits the assignment because it is _possibly_ sound, whereas strict function
types mode makes it an error because it isn‚Äôt _provably_ sound. In either mode
the third assignment is an error because it is _never_ sound.

Another way to describe the example is that the type `(x: T) => void` is
_bivariant_ (i.e. covariant _or_ contravariant) for `T` in default type
checking mode, but _contravariant_ for `T` in strict function types mode.

##### Example

    
    
    ts
    
    interface Comparer<T> {
    
      compare: (a: T, b: T) => number;
    
    }
    
    declare let animalComparer: Comparer<Animal>;
    
    declare let dogComparer: Comparer<Dog>;
    
    animalComparer = dogComparer; // Error
    
    dogComparer = animalComparer; // Ok

The first assignment is now an error. Effectively, `T` is contravariant in
`Comparer<T>` because it is used only in function type parameter positions.

By the way, note that whereas some languages (e.g. C# and Scala) require
variance annotations (`out`/`in` or `+`/`-`), variance emerges naturally from
the actual use of a type parameter within a generic type due to TypeScript‚Äôs
structural type system.

##### Note

Under [`strictFunctionTypes`](/tsconfig#strictFunctionTypes) the first
assignment is still permitted if `compare` was declared as a method.
Effectively, `T` is bivariant in `Comparer<T>` because it is used only in
method parameter positions.

    
    
    ts
    
    interface Comparer<T> {
    
      compare(a: T, b: T): number;
    
    }
    
    declare let animalComparer: Comparer<Animal>;
    
    declare let dogComparer: Comparer<Dog>;
    
    animalComparer = dogComparer; // Ok because of bivariance
    
    dogComparer = animalComparer; // Ok

TypeScript 2.6 also improves type inference involving contravariant positions:

    
    
    ts
    
    function combine<T>(...funcs: ((x: T) => void)[]): (x: T) => void {
    
      return x => {
    
        for (const f of funcs) f(x);
    
      };
    
    }
    
    function animalFunc(x: Animal) {}
    
    function dogFunc(x: Dog) {}
    
    let combined = combine(animalFunc, dogFunc); // (x: Dog) => void

Above, all inferences for `T` originate in contravariant positions, and we
therefore infer the _best common subtype_ for `T`. This contrasts with
inferences from covariant positions, where we infer the _best common
supertype_.

## Cache tagged template objects in modules

TypeScript 2.6 fixes the tagged string template emit to align better with the
ECMAScript spec. As per the [ECMAScript
spec](https://tc39.github.io/ecma262/#sec-gettemplateobject), every time a
template tag is evaluated, the _same_ template strings object (the same
`TemplateStringsArray`) should be passed as the first argument. Before
TypeScript 2.6, the generated output was a completely new template object each
time. Though the string contents are the same, this emit affects libraries
that use the identity of the string for cache invalidation purposes, e.g.
[lit-html](https://github.com/PolymerLabs/lit-html/issues/58).

##### Example

    
    
    ts
    
    export function id(x: TemplateStringsArray) {
    
      return x;
    
    }
    
    export function templateObjectFactory() {
    
      return id`hello world`;
    
    }
    
    let result = templateObjectFactory() === templateObjectFactory(); // true in TS 2.6

Results in the following generated code:

    
    
    js
    
    "use strict";
    
    var __makeTemplateObject =
    
      (this && this.__makeTemplateObject) ||
    
      function(cooked, raw) {
    
        if (Object.defineProperty) {
    
          Object.defineProperty(cooked, "raw", { value: raw });
    
        } else {
    
          cooked.raw = raw;
    
        }
    
        return cooked;
    
      };
    
    function id(x) {
    
      return x;
    
    }
    
    var _a;
    
    function templateObjectFactory() {
    
      return id(
    
        _a || (_a = __makeTemplateObject(["hello world"], ["hello world"]))
    
      );
    
    }
    
    var result = templateObjectFactory() === templateObjectFactory();

> Note: This change brings a new emit helper, `__makeTemplateObject`; if you
> are using [`importHelpers`](/tsconfig#importHelpers) with
> [`tslib`](https://github.com/Microsoft/tslib), an updated to version 1.8 or
> later.

## Localized diagnostics on the command line

TypeScript 2.6 npm package ships with localized versions of diagnostic
messages for 13 languages. The localized messages are available when using
`--locale` flag on the command line.

##### Example

Error messages in Russian:

    
    
    sh
    
    c:\ts>tsc --v
    
    Version 2.6.0-dev.20171003
    
    c:\ts>tsc --locale ru --pretty c:\test\a.ts
    
    ../test/a.ts(1,5): error TS2322: –¢–∏–ø ""string"" –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è —Ç–∏–ø–∞ "number".
    
    1 var x: number = "string";
    
          ~

And help in Japanese:

    
    
    sh
    
    PS C:\ts> tsc --v
    
    Version 2.6.0-dev.20171003
    
    PS C:\ts> tsc --locale ja-jp
    
    „Éê„Éº„Ç∏„Éß„É≥ 2.6.0-dev.20171003
    
    ÊßãÊñá: tsc [„Ç™„Éó„Ç∑„Éß„É≥] [„Éï„Ç°„Ç§„É´ ...]
    
    ‰æã:  tsc hello.ts
    
        tsc --outFile file.js file.ts
    
        tsc @args.txt
    
    „Ç™„Éó„Ç∑„Éß„É≥:
    
     -h, --help                                 „Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
    
     --all                                      „Ç≥„É≥„Éë„Ç§„É© „Ç™„Éó„Ç∑„Éß„É≥„Çí„Åô„Åπ„Å¶Ë°®Á§∫„Åó„Åæ„Åô„ÄÇ
    
     -v, --version                              „Ç≥„É≥„Éë„Ç§„É©„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
    
     --init                                     TypeScript „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÂàùÊúüÂåñ„Åó„Å¶„ÄÅtsconfig.json „Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ
    
     -p „Éï„Ç°„Ç§„É´„Åæ„Åü„ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™, --project „Éï„Ç°„Ç§„É´„Åæ„Åü„ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™  ÊßãÊàê„Éï„Ç°„Ç§„É´„Åã„ÄÅ'tsconfig.json' „ÇíÂê´„ÇÄ„Éï„Ç©„É´„ÉÄ„Éº„Å´„Éë„Çπ„ÅåÊåáÂÆö„Åï„Çå„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çí„Ç≥
    
    „É≥„Éë„Ç§„É´„Åó„Åæ„Åô„ÄÇ
    
     --pretty                                   Ëâ≤„Å®„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩøÁî®„Åó„Å¶„Ç®„É©„Éº„Å®„É°„ÉÉ„Çª„Éº„Ç∏„Å´„Çπ„Çø„Ç§„É´„ÇíÈÅ©Áî®„Åó„Åæ„Åô (Ë©¶È®ìÁöÑ)„ÄÇ
    
     -w, --watch                                ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„ÇíÁõ£Ë¶ñ„Åó„Åæ„Åô„ÄÇ
    
     -t „Éê„Éº„Ç∏„Éß„É≥, --target „Éê„Éº„Ç∏„Éß„É≥                   ECMAScript „ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà „Éê„Éº„Ç∏„Éß„É≥„ÇíÊåáÂÆö„Åó„Åæ„Åô: 'ES3' (Êó¢ÂÆö)„ÄÅ'ES5'„ÄÅ'ES2015'„ÄÅ'ES2016'„ÄÅ'ES2017'„ÄÅ'ES
    
    NEXT'„ÄÇ
    
     -m Á®ÆÈ°û, --module Á®ÆÈ°û                         „É¢„Ç∏„É•„Éº„É´ „Ç≥„Éº„ÉâÁîüÊàê„ÇíÊåáÂÆö„Åó„Åæ„Åô: 'none'„ÄÅ'commonjs'„ÄÅ'amd'„ÄÅ'system'„ÄÅ'umd'„ÄÅ'es2015'„ÄÅ'ESNext'„ÄÇ
    
     --lib                                      „Ç≥„É≥„Éë„Ç§„É´„Å´Âê´„ÇÅ„Çã„É©„Ç§„Éñ„É©„É™ „Éï„Ç°„Ç§„É´„ÇíÊåáÂÆö„Åó„Åæ„Åô:
    
                                                  'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es201
    
    5.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellkno
    
    wn' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable'
    
     --allowJs                                  javascript „Éï„Ç°„Ç§„É´„ÅÆ„Ç≥„É≥„Éë„Ç§„É´„ÇíË®±ÂèØ„Åó„Åæ„Åô„ÄÇ
    
     --jsx Á®ÆÈ°û                                   JSX „Ç≥„Éº„ÉâÁîüÊàê„ÇíÊåáÂÆö„Åó„Åæ„Åô: 'preserve'„ÄÅ'react-native'„ÄÅ'react'„ÄÇ
    
     -d, --declaration                          ÂØæÂøú„Åô„Çã '.d.ts' „Éï„Ç°„Ç§„É´„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
    
     --sourceMap                                ÂØæÂøú„Åô„Çã '.map' „Éï„Ç°„Ç§„É´„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
    
     --outFile „Éï„Ç°„Ç§„É´                             Âá∫Âäõ„ÇíÈÄ£Áµê„Åó„Å¶ 1 „Å§„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
    
     --outDir „Éá„Ç£„É¨„ÇØ„Éà„É™                            „Éá„Ç£„É¨„ÇØ„Éà„É™„Å∏Âá∫ÂäõÊßãÈÄ†„Çí„É™„ÉÄ„Ç§„É¨„ÇØ„Éà„Åó„Åæ„Åô„ÄÇ
    
     --removeComments                           „Ç≥„É°„É≥„Éà„ÇíÂá∫Âäõ„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
    
     --noEmit                                   Âá∫Âäõ„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
    
     --strict                                   strict Âûã„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Çí„Åô„Åπ„Å¶ÊúâÂäπ„Å´„Åó„Åæ„Åô„ÄÇ
    
     --noImplicitAny                            ÊöóÈªôÁöÑ„Å™ 'any' Âûã„ÇíÂê´„ÇÄÂºè„Å®ÂÆ£Ë®Ä„Å´Èñ¢„Åô„Çã„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„Åæ„Åô„ÄÇ
    
     --strictNullChecks                         Âé≥Ê†º„Å™ null „ÉÅ„Çß„ÉÉ„ÇØ„ÇíÊúâÂäπ„Å´„Åó„Åæ„Åô„ÄÇ
    
     --noImplicitThis                           ÊöóÈªôÁöÑ„Å™ 'any' Âûã„ÇíÊåÅ„Å§ 'this' Âºè„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åô„ÄÇ
    
     --alwaysStrict                             Âé≥Ê†º„É¢„Éº„Éâ„ÅßËß£Êûê„Åó„Å¶„ÇΩ„Éº„Çπ „Éï„Ç°„Ç§„É´„Åî„Å®„Å´ "use strict" „ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
    
     --noUnusedLocals                           ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„É≠„Éº„Ç´„É´„Å´Èñ¢„Åô„Çã„Ç®„É©„Éº„ÇíÂ†±Âëä„Åó„Åæ„Åô„ÄÇ
    
     --noUnusedParameters                       ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éë„É©„É°„Éº„Çø„Éº„Å´Èñ¢„Åô„Çã„Ç®„É©„Éº„ÇíÂ†±Âëä„Åó„Åæ„Åô„ÄÇ
    
     --noImplicitReturns                        Èñ¢Êï∞„ÅÆ‰∏ÄÈÉ®„ÅÆ„Ç≥„Éº„Éâ „Éë„Çπ„ÅåÂÄ§„ÇíËøî„Åï„Å™„ÅÑÂ†¥Âêà„Å´„Ç®„É©„Éº„ÇíÂ†±Âëä„Åó„Åæ„Åô„ÄÇ
    
     --noFallthroughCasesInSwitch               switch „Çπ„ÉÜ„Éº„Éà„É°„É≥„Éà„Å´ case „ÅÆ„Éï„Ç©„Éº„É´„Çπ„É´„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„Å´„Ç®„É©„Éº„ÇíÂ†±Âëä„Åó„Åæ„Åô„ÄÇ
    
     --types                                    „Ç≥„É≥„Éë„Ç§„É´„Å´Âê´„ÇÄÂûãÂÆ£Ë®Ä„Éï„Ç°„Ç§„É´„ÄÇ
    
     @<„Éï„Ç°„Ç§„É´>

## Suppress errors in .ts files using ‚Äô// @ts-ignore‚Äô comments

TypeScript 2.6 support suppressing errors in .ts files using `// @ts-ignore`
comments placed above the offending lines.

##### Example

    
    
    ts
    
    if (false) {
    
      // @ts-ignore: Unreachable code error
    
      console.log("hello");
    
    }

A `// @ts-ignore` comment suppresses all errors that originate on the
following line. It is recommended practice to have the remainder of the
comment following `@ts-ignore` explain which error is being suppressed.

Please note that this comment only suppresses the error reporting, and we
recommend you use this comments _very sparingly_.

## Faster `tsc --watch`

TypeScript 2.6 brings a faster `--watch` implementation. The new version
optimizes code generation and checking for code bases using ES modules.
Changes detected in a module file will result in _only_ regenerating the
changed module, and files that depend on it, instead of the whole project.
Projects with large number of files should reap the most benefit from this
change.

The new implementation also brings performance enhancements to watching in
tsserver. The watcher logic has been completely rewritten to respond faster to
change events.

## Write-only references now flagged as unused

TypeScript 2.6 adds revised implementation the
[`noUnusedLocals`](/tsconfig#noUnusedLocals) and
[`noUnusedParameters`](/tsconfig#noUnusedParameters) [compiler
options](/docs/handbook/compiler-options.html). Declarations are only written
to but never read from are now flagged as unused.

##### Example

Bellow both `n` and `m` will be marked as unused, because their values are
never _read_. Previously TypeScript would only check whether their values were
_referenced_.

    
    
    ts
    
    function f(n: number) {
    
      n = 0;
    
    }
    
    class C {
    
      private m: number;
    
      constructor() {
    
        this.m = 0;
    
      }
    
    }

Also functions that are only called within their own bodies are considered
unused.

##### Example

    
    
    ts
    
    function f() {
    
      f(); // Error: 'f' is declared but its value is never read
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.6.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(51\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

TS![TAKAHASHI Shuuji
\(1\)](https://gravatar.com/avatar/7efb8935d734ad05a38da5682afb36a6?s=32&&d=blank)

MC![Mert Ciflikli
\(1\)](https://gravatar.com/avatar/bded54cc6ae46eb022b14476eaff4196?s=32&&d=blank)

MZ![Micah Zoltu
\(1\)](https://gravatar.com/avatar/c0b2bfa28a2c809735b4209cbfcd357d?s=32&&d=blank)

4+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.7

## Constant-named properties

TypeScript 2.7 adds support for declaring const-named properties on types
including ECMAScript symbols.

##### Example

    
    
    ts
    
    // Lib
    
    export const SERIALIZE = Symbol("serialize-method-key");
    
    export interface Serializable {
    
      [SERIALIZE](obj: {}): string;
    
    }
    
    
    ts
    
    // consumer
    
    import { SERIALIZE, Serializable } from "lib";
    
    class JSONSerializableItem implements Serializable {
    
      [SERIALIZE](obj: {}) {
    
        return JSON.stringify(obj);
    
      }
    
    }

This also applies to numeric and string literals.

##### Example

    
    
    ts
    
    const Foo = "Foo";
    
    const Bar = "Bar";
    
    let x = {
    
      [Foo]: 100,
    
      [Bar]: "hello"
    
    };
    
    let a = x[Foo]; // has type 'number'
    
    let b = x[Bar]; // has type 'string'

## `unique symbol`

To enable treating symbols as unique literals a new type `unique symbol` is
available. `unique symbol` is a subtype of `symbol`, and are produced only
from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations.
The new type is only allowed on `const` declarations and `readonly static`
properties, and in order to reference a specific unique symbol, you‚Äôll have to
use the `typeof` operator. Each reference to a `unique symbol` implies a
completely unique identity that‚Äôs tied to a given declaration.

##### Example

    
    
    ts
    
    // Works
    
    declare const Foo: unique symbol;
    
    // Error! 'Bar' isn't a constant.
    
    let Bar: unique symbol = Symbol();
    
    // Works - refers to a unique symbol, but its identity is tied to 'Foo'.
    
    let Baz: typeof Foo = Foo;
    
    // Also works.
    
    class C {
    
      static readonly StaticSymbol: unique symbol = Symbol();
    
    }

Because each `unique symbol` has a completely separate identity, no two
`unique symbol` types are assignable or comparable to each other.

##### Example

    
    
    ts
    
    const Foo = Symbol();
    
    const Bar = Symbol();
    
    // Error: can't compare two unique symbols.
    
    if (Foo === Bar) {
    
      // ...
    
    }

## Strict Class Initialization

TypeScript 2.7 introduces a new flag called
[`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization). This
flag performs checks to ensure that each instance property of a class gets
initialized in the constructor body, or by a property initializer. For example

    
    
    ts
    
    class C {
    
      foo: number;
    
      bar = "hello";
    
      baz: boolean;
    
      //  ~~~
    
      //  Error! Property 'baz' has no initializer and is not definitely assigned in the
    
      //         constructor.
    
      constructor() {
    
        this.foo = 42;
    
      }
    
    }

In the above, if we truly meant for `baz` to potentially be `undefined`, we should have declared it with the type `boolean | undefined`.

There are certain scenarios where properties can be initialized indirectly
(perhaps by a helper method or dependency injection library), in which case
you can use the new _definite assignment assertion modifiers_ for your
properties (discussed below).

    
    
    ts
    
    class C {
    
      foo!: number;
    
      // ^
    
      // Notice this '!' modifier.
    
      // This is the "definite assignment assertion"
    
      constructor() {
    
        this.initialize();
    
      }
    
      initialize() {
    
        this.foo = 0;
    
      }
    
    }

Keep in mind that
[`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization) will
be turned on along with other [`strict`](/tsconfig#strict) mode flags, which
can impact your project. You can set the
[`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization)
setting to `false` in your `tsconfig.json`‚Äôs `compilerOptions`, or
`--strictPropertyInitialization false` on the command line to turn off this
checking.

## Definite Assignment Assertions

The definite assignment assertion is a feature that allows a `!` to be placed
after instance property and variable declarations to relay to TypeScript that
a variable is indeed assigned for all intents and purposes, even if
TypeScript‚Äôs analyses cannot detect so.

##### Example

    
    
    ts
    
    let x: number;
    
    initialize();
    
    console.log(x + x);
    
    //          ~   ~
    
    // Error! Variable 'x' is used before being assigned.
    
    function initialize() {
    
      x = 10;
    
    }

With definite assignment assertions, we can assert that `x` is really assigned
by appending an `!` to its declaration:

    
    
    ts
    
    // Notice the '!'
    
    let x!: number;
    
    initialize();
    
    // No error!
    
    console.log(x + x);
    
    function initialize() {
    
      x = 10;
    
    }

In a sense, the definite assignment assertion operator is the dual of the non-
null assertion operator (in which _expressions_ are post-fixed with a `!`),
which we could also have used in the example.

    
    
    ts
    
    let x: number;
    
    initialize();
    
    // No error!
    
    console.log(x! + x!);
    
    function initialize() {
    
        x = 10;
    
    }

In our example, we knew that all uses of `x` would be initialized so it makes
more sense to use definite assignment assertions than non-null assertions.

## Fixed Length Tuples

In TypeScript 2.6 and earlier, `[number, string, string]` was considered a
subtype of `[number, string]`. This was motivated by TypeScript‚Äôs structural
nature; the first and second elements of a `[number, string, string]` are
respectively subtypes of the first and second elements of `[number, string]`.
However, after examining real world usage of tuples, we noticed that most
situations in which this was permitted was typically undesirable.

In TypeScript 2.7, tuples of different arities are no longer assignable to
each other. Thanks to a pull request from [Kiara
Grouwstra](https://github.com/KiaraGrouwstra), tuple types now encode their
arity into the type of their respective `length` property. This is
accomplished by leveraging numeric literal types, which now allow tuples to be
distinct from tuples of different arities.

Conceptually, you might consider the type `[number, string]` to be equivalent
to the following declaration of `NumStrTuple`:

    
    
    ts
    
    interface NumStrTuple extends Array<number | string> {
    
      0: number;
    
      1: string;
    
      length: 2; // using the numeric literal type '2'
    
    }

Note that this is a breaking change for some code. If you need to resort to
the original behavior in which tuples only enforce a minimum length, you can
use a similar declaration that does not explicitly define a `length` property,
falling back to `number`.

    
    
    ts
    
    interface MinimumNumStrTuple extends Array<number | string> {
    
      0: number;
    
      1: string;
    
    }

Note that this does not imply tuples represent immutable arrays, but it is an
implied convention.

## Improved type inference for object literals

TypeScript 2.7 improves type inference for multiple object literals occurring
in the same context. When multiple object literal types contribute to a union
type, we now _normalize_ the object literal types such that all properties are
present in each constituent of the union type.

Consider:

    
    
    ts
    
    const obj = test ? { text: "hello" } : {}; // { text: string } | { text?: undefined }
    
    const s = obj.text; // string | undefined

Previously type `{}` was inferred for `obj` and the second line subsequently
caused an error because `obj` would appear to have no properties. That
obviously wasn‚Äôt ideal.

##### Example

    
    
    ts
    
    // let obj: { a: number, b: number } |
    
    //     { a: string, b?: undefined } |
    
    //     { a?: undefined, b?: undefined }
    
    let obj = [{ a: 1, b: 2 }, { a: "abc" }, {}][0];
    
    obj.a; // string | number | undefined
    
    obj.b; // number | undefined

Multiple object literal type inferences for the same type parameter are
similarly collapsed into a single normalized union type:

    
    
    ts
    
    declare function f<T>(...items: T[]): T;
    
    // let obj: { a: number, b: number } |
    
    //     { a: string, b?: undefined } |
    
    //     { a?: undefined, b?: undefined }
    
    let obj = f({ a: 1, b: 2 }, { a: "abc" }, {});
    
    obj.a; // string | number | undefined
    
    obj.b; // number | undefined

## Improved handling of structurally identical classes and `instanceof`
expressions

TypeScript 2.7 improves the handling of structurally identical classes in
union types and `instanceof` expressions:

  * Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).
  * Union type subtype reduction only removes a class type if it is a subclass of _and_ derives from another class type in the union.
  * Type checking of the `instanceof` operator is now based on whether the type of the left operand _derives from_ the type indicated by the right operand (as opposed to a structural subtype check).

This means that union types and `instanceof` properly distinguish between
structurally identical classes.

##### Example

    
    
    ts
    
    class A {}
    
    class B extends A {}
    
    class C extends A {}
    
    class D extends A {
    
      c: string;
    
    }
    
    class E extends D {}
    
    let x1 = !true ? new A() : new B(); // A
    
    let x2 = !true ? new B() : new C(); // B | C (previously B)
    
    let x3 = !true ? new C() : new D(); // C | D (previously C)
    
    let a1 = [new A(), new B(), new C(), new D(), new E()]; // A[]
    
    let a2 = [new B(), new C(), new D(), new E()]; // (B | C | D)[] (previously B[])
    
    function f1(x: B | C | D) {
    
      if (x instanceof B) {
    
        x; // B (previously B | D)
    
      } else if (x instanceof C) {
    
        x; // C
    
      } else {
    
        x; // D (previously never)
    
      }
    
    }

## Type guards inferred from `in` operator

The `in` operator now acts as a narrowing expression for types.

For a `n in x` expression, where `n` is a string literal or string literal
type and `x` is a union type, the ‚Äútrue‚Äù branch narrows to types which have an
optional or required property `n`, and the ‚Äúfalse‚Äù branch narrows to types
which have an optional or missing property `n`.

##### Example

    
    
    ts
    
    interface A {
    
      a: number;
    
    }
    
    interface B {
    
      b: string;
    
    }
    
    function foo(x: A | B) {
    
      if ("a" in x) {
    
        return x.a;
    
      }
    
      return x.b;
    
    }

## Support for `import d from "cjs"` from CommonJS modules with
`--esModuleInterop`

TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace
records based on the presence of an `__esModule` indicator under
[`esModuleInterop`](/tsconfig#esModuleInterop). The change brings the
generated output from TypeScript closer to that generated by Babel.

Previously CommonJS/AMD/UMD modules were treated in the same way as ES6
modules, resulting in a couple of problems. Namely:

  * TypeScript treats a namespace import (i.e. `import * as foo from "foo"`) for a CommonJS/AMD/UMD module as equivalent to `const foo = require("foo")`.Things are simple here, but they don‚Äôt work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (`foo` in the example above) is not callable, though allowed by TypeScript
  * Similarly a default import (i.e. `import d from "foo"`) for a CommonJS/AMD/UMD module as equivalent to `const d = require("foo").default`.Most of the CommonJS/AMD/UMD modules available today do not have a `default` export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance `import fs from "fs"` or `import express from "express"` are not allowed.

Under the new [`esModuleInterop`](/tsconfig#esModuleInterop) these two issues
should be addressed:

  * A namespace import (i.e. `import * as foo from "foo"`) is now correctly flagged as uncallable. Calling it will result in an error.
  * Default imports to CommonJS/AMD/UMD are now allowed (e.g. `import fs from "fs"`), and should work as expected.

> Note: The new behavior is added under a flag to avoid unwarranted breaks to
> existing code bases. **We highly recommend applying it both to new and
> existing projects.** For existing projects, namespace imports (`import * as
> express from "express"; express();`) will need to be converted to default
> imports (`import express from "express"; express();`).

##### Example

With [`esModuleInterop`](/tsconfig#esModuleInterop) two new helpers are
generated `__importStar` and `__importDefault` for import `*` and import
`default` respectively. For instance input like:

    
    
    ts
    
    import * as foo from "foo";
    
    import b from "bar";

Will generate:

    
    
    js
    
    "use strict";
    
    var __importStar =
    
      (this && this.__importStar) ||
    
      function(mod) {
    
        if (mod && mod.__esModule) return mod;
    
        var result = {};
    
        if (mod != null)
    
          for (var k in mod)
    
            if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    
        result["default"] = mod;
    
        return result;
    
      };
    
    var __importDefault =
    
      (this && this.__importDefault) ||
    
      function(mod) {
    
        return mod && mod.__esModule ? mod : { default: mod };
    
      };
    
    exports.__esModule = true;
    
    var foo = __importStar(require("foo"));
    
    var bar_1 = __importDefault(require("bar"));

## Numeric separators

TypeScript 2.7 brings support for [ES Numeric
Separators](https://github.com/tc39/proposal-numeric-separator). Numeric
literals can now be separated into segments using `_`.

##### Example

    
    
    ts
    
    const million = 1_000_000;
    
    const phone = 555_734_2231;
    
    const bytes = 0xff_0c_00_ff;
    
    const word = 0b1100_0011_1101_0001;

## Cleaner output in `--watch` mode

TypeScript‚Äôs `--watch` mode now clears the screen after a re-compilation is
requested.

## Prettier `--pretty` output

TypeScript‚Äôs [`pretty`](/tsconfig#pretty) flag can make error messages easier
to read and manage. [`pretty`](/tsconfig#pretty) now uses colors for file
names, diagnostic codes, and line numbers. File names and positions are now
also formatted to allow navigation in common terminals (e.g. Visual Studio
Code terminal).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.7.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

S![shiina
\(1\)](https://gravatar.com/avatar/ddc95caa15d48c35f63ea8660a9e503a?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

CT![Cameron Tacklind
\(1\)](https://gravatar.com/avatar/719f14270bfe54a8a9cf6e831fde6aa2?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.8

## Conditional Types

TypeScript 2.8 introduces _conditional types_ which add the ability to express
non-uniform type mappings. A conditional type selects one of two possible
types based on a condition expressed as a type relationship test:

    
    
    ts
    
    T extends U ? X : Y

The type above means when `T` is assignable to `U` the type is `X`, otherwise
the type is `Y`.

A conditional type `T extends U ? X : Y` is either _resolved_ to `X` or `Y`,
or _deferred_ because the condition depends on one or more type variables.
Whether to resolve or defer is determined as follows:

  * First, given types `T'` and `U'` that are instantiations of `T` and `U` where all occurrences of type parameters are replaced with `any`, if `T'` is not assignable to `U'`, the conditional type is resolved to `Y`. Intuitively, if the most permissive instantiation of `T` is not assignable to the most permissive instantiation of `U`, we know that no instantiation will be and we can just resolve to `Y`.
  * Next, for each type variable introduced by an `infer` (more later) declaration within `U` collect a set of candidate types by inferring from `T` to `U` (using the same inference algorithm as type inference for generic functions). For a given `infer` type variable `V`, if any candidates were inferred from co-variant positions, the type inferred for `V` is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for `V` is an intersection of those candidates. Otherwise, the type inferred for `V` is `never`.
  * Then, given a type `T''` that is an instantiation of `T` where all `infer` type variables are replaced with the types inferred in the previous step, if `T''` is _definitely assignable_ to `U`, the conditional type is resolved to `X`. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for _all instantiations_ of those types.
  * Otherwise, the condition depends on one or more type variables and the conditional type is deferred.

##### Example

    
    
    ts
    
    type TypeName<T> = T extends string
    
      ? "string"
    
      : T extends number
    
      ? "number"
    
      : T extends boolean
    
      ? "boolean"
    
      : T extends undefined
    
      ? "undefined"
    
      : T extends Function
    
      ? "function"
    
      : "object";
    
    type T0 = TypeName<string>; // "string"
    
    type T1 = TypeName<"a">; // "string"
    
    type T2 = TypeName<true>; // "boolean"
    
    type T3 = TypeName<() => void>; // "function"
    
    type T4 = TypeName<string[]>; // "object"

## Distributive conditional types

Conditional types in which the checked type is a naked type parameter are called _distributive conditional types_. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of `T extends U ? X : Y` with the type argument `A | B | C` for `T` is resolved as `(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`.

##### Example

    
    
    ts
    
    type T10 = TypeName<string | (() => void)>; // "string" | "function"
    
    type T12 = TypeName<string | string[] | undefined>; // "string" | "object" | "undefined"
    
    type T11 = TypeName<string[] | number[]>; // "object"

In instantiations of a distributive conditional type `T extends U ? X : Y`,
references to `T` within the conditional type are resolved to individual
constituents of the union type (i.e. `T` refers to the individual constituents
_after_ the conditional type is distributed over the union type). Furthermore,
references to `T` within `X` have an additional type parameter constraint `U`
(i.e. `T` is considered assignable to `U` within `X`).

##### Example

    
    
    ts
    
    type BoxedValue<T> = { value: T };
    
    type BoxedArray<T> = { array: T[] };
    
    type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;
    
    type T20 = Boxed<string>; // BoxedValue<string>;
    
    type T21 = Boxed<number[]>; // BoxedArray<number>;
    
    type T22 = Boxed<string | number[]>; // BoxedValue<string> | BoxedArray<number>;

Notice that `T` has the additional constraint `any[]` within the true branch
of `Boxed<T>` and it is therefore possible to refer to the element type of the
array as `T[number]`. Also, notice how the conditional type is distributed
over the union type in the last example.

The distributive property of conditional types can conveniently be used to
_filter_ union types:

    
    
    ts
    
    type Diff<T, U> = T extends U ? never : T; // Remove types from T that are assignable to U
    
    type Filter<T, U> = T extends U ? T : never; // Remove types from T that are not assignable to U
    
    type T30 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">; // "b" | "d"
    
    type T31 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">; // "a" | "c"
    
    type T32 = Diff<string | number | (() => void), Function>; // string | number
    
    type T33 = Filter<string | number | (() => void), Function>; // () => void
    
    type NonNullable<T> = Diff<T, null | undefined>; // Remove null and undefined from T
    
    type T34 = NonNullable<string | number | undefined>; // string | number
    
    type T35 = NonNullable<string | string[] | null | undefined>; // string | string[]
    
    function f1<T>(x: T, y: NonNullable<T>) {
    
      x = y; // Ok
    
      y = x; // Error
    
    }
    
    function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {
    
      x = y; // Ok
    
      y = x; // Error
    
      let s1: string = x; // Error
    
      let s2: string = y; // Ok
    
    }

Conditional types are particularly useful when combined with mapped types:

    
    
    ts
    
    type FunctionPropertyNames<T> = {
    
      [K in keyof T]: T[K] extends Function ? K : never;
    
    }[keyof T];
    
    type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
    
    type NonFunctionPropertyNames<T> = {
    
      [K in keyof T]: T[K] extends Function ? never : K;
    
    }[keyof T];
    
    type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
    
    interface Part {
    
      id: number;
    
      name: string;
    
      subparts: Part[];
    
      updatePart(newName: string): void;
    
    }
    
    type T40 = FunctionPropertyNames<Part>; // "updatePart"
    
    type T41 = NonFunctionPropertyNames<Part>; // "id" | "name" | "subparts"
    
    type T42 = FunctionProperties<Part>; // { updatePart(newName: string): void }
    
    type T43 = NonFunctionProperties<Part>; // { id: number, name: string, subparts: Part[] }

Similar to union and intersection types, conditional types are not permitted
to reference themselves recursively. For example the following is an error.

##### Example

    
    
    ts
    
    type ElementType<T> = T extends any[] ? ElementType<T[number]> : T; // Error

## Type inference in conditional types

Within the `extends` clause of a conditional type, it is now possible to have
`infer` declarations that introduce a type variable to be inferred. Such
inferred type variables may be referenced in the true branch of the
conditional type. It is possible to have multiple `infer` locations for the
same type variable.

For example, the following extracts the return type of a function type:

    
    
    ts
    
    type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

Conditional types can be nested to form a sequence of pattern matches that are
evaluated in order:

    
    
    ts
    
    type Unpacked<T> = T extends (infer U)[]
    
      ? U
    
      : T extends (...args: any[]) => infer U
    
      ? U
    
      : T extends Promise<infer U>
    
      ? U
    
      : T;
    
    type T0 = Unpacked<string>; // string
    
    type T1 = Unpacked<string[]>; // string
    
    type T2 = Unpacked<() => string>; // string
    
    type T3 = Unpacked<Promise<string>>; // string
    
    type T4 = Unpacked<Promise<string>[]>; // Promise<string>
    
    type T5 = Unpacked<Unpacked<Promise<string>[]>>; // string

The following example demonstrates how multiple candidates for the same type
variable in co-variant positions causes a union type to be inferred:

    
    
    ts
    
    type Foo<T> = T extends { a: infer U; b: infer U } ? U : never;
    
    type T10 = Foo<{ a: string; b: string }>; // string
    
    type T11 = Foo<{ a: string; b: number }>; // string | number

Likewise, multiple candidates for the same type variable in contra-variant
positions causes an intersection type to be inferred:

    
    
    ts
    
    type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }
    
      ? U
    
      : never;
    
    type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string
    
    type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number

When inferring from a type with multiple call signatures (such as the type of
an overloaded function), inferences are made from the _last_ signature (which,
presumably, is the most permissive catch-all case). It is not possible to
perform overload resolution based on a list of argument types.

    
    
    ts
    
    declare function foo(x: string): number;
    
    declare function foo(x: number): string;
    
    declare function foo(x: string | number): string | number;
    
    type T30 = ReturnType<typeof foo>; // string | number

It is not possible to use `infer` declarations in constraint clauses for
regular type parameters:

    
    
    ts
    
    type ReturnType<T extends (...args: any[]) => infer R> = R; // Error, not supported

However, much the same effect can be obtained by erasing the type variables in
the constraint and instead specifying a conditional type:

    
    
    ts
    
    type AnyFunction = (...args: any[]) => any;
    
    type ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R
    
      ? R
    
      : any;

## Predefined conditional types

TypeScript 2.8 adds several predefined conditional types to `lib.d.ts`:

  * `Exclude<T, U>` ‚Äî Exclude from `T` those types that are assignable to `U`.
  * `Extract<T, U>` ‚Äî Extract from `T` those types that are assignable to `U`.
  * `NonNullable<T>` ‚Äî Exclude `null` and `undefined` from `T`.
  * `ReturnType<T>` ‚Äî Obtain the return type of a function type.
  * `InstanceType<T>` ‚Äî Obtain the instance type of a constructor function type.

##### Example

    
    
    ts
    
    type T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">; // "b" | "d"
    
    type T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">; // "a" | "c"
    
    type T02 = Exclude<string | number | (() => void), Function>; // string | number
    
    type T03 = Extract<string | number | (() => void), Function>; // () => void
    
    type T04 = NonNullable<string | number | undefined>; // string | number
    
    type T05 = NonNullable<(() => string) | string[] | null | undefined>; // (() => string) | string[]
    
    function f1(s: string) {
    
      return { a: 1, b: s };
    
    }
    
    class C {
    
      x = 0;
    
      y = 0;
    
    }
    
    type T10 = ReturnType<() => string>; // string
    
    type T11 = ReturnType<(s: string) => void>; // void
    
    type T12 = ReturnType<<T>() => T>; // {}
    
    type T13 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
    
    type T14 = ReturnType<typeof f1>; // { a: number, b: string }
    
    type T15 = ReturnType<any>; // any
    
    type T16 = ReturnType<never>; // any
    
    type T17 = ReturnType<string>; // Error
    
    type T18 = ReturnType<Function>; // Error
    
    type T20 = InstanceType<typeof C>; // C
    
    type T21 = InstanceType<any>; // any
    
    type T22 = InstanceType<never>; // any
    
    type T23 = InstanceType<string>; // Error
    
    type T24 = InstanceType<Function>; // Error

> Note: The `Exclude` type is a proper implementation of the `Diff` type
> suggested
> [here](https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458).
> We‚Äôve used the name `Exclude` to avoid breaking existing code that defines a
> `Diff`, plus we feel that name better conveys the semantics of the type. We
> did not include the `Omit<T, K>` type because it is trivially written as
> `Pick<T, Exclude<keyof T, K>>`.

## Improved control over mapped type modifiers

Mapped types support adding a `readonly` or `?` modifier to a mapped property,
but they did not provide support the ability to _remove_ modifiers. This
matters in [_homomorphic mapped
types_](https://github.com/Microsoft/TypeScript/pull/12563) which by default
preserve the modifiers of the underlying type.

TypeScript 2.8 adds the ability for a mapped type to either add or remove a
particular modifier. Specifically, a `readonly` or `?` property modifier in a
mapped type can now be prefixed with either `+` or `-` to indicate that the
modifier should be added or removed.

#### Example

    
    
    ts
    
    type MutableRequired<T> = { -readonly [P in keyof T]-?: T[P] }; // Remove readonly and ?
    
    type ReadonlyPartial<T> = { +readonly [P in keyof T]+?: T[P] }; // Add readonly and ?

A modifier with no `+` or `-` prefix is the same as a modifier with a `+`
prefix. So, the `ReadonlyPartial<T>` type above corresponds to

    
    
    ts
    
    type ReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] }; // Add readonly and ?

Using this ability, `lib.d.ts` now has a new `Required<T>` type. This type
strips `?` modifiers from all properties of `T`, thus making all properties
required.

##### Example

    
    
    ts
    
    type Required<T> = { [P in keyof T]-?: T[P] };

Note that in [`strictNullChecks`](/tsconfig#strictNullChecks) mode, when a
homomorphic mapped type removes a `?` modifier from a property in the
underlying type it also removes `undefined` from the type of that property:

##### Example

    
    
    ts
    
    type Foo = { a?: string }; // Same as { a?: string | undefined }
    
    type Bar = Required<Foo>; // Same as { a: string }

## Improved `keyof` with intersection types

With TypeScript 2.8 `keyof` applied to an intersection type is transformed to a union of `keyof` applied to each intersection constituent. In other words, types of the form `keyof (A & B)` are transformed to be `keyof A | keyof B`. This change should address inconsistencies with inference from `keyof` expressions.

##### Example

    
    
    ts
    
    type A = { a: string };
    
    type B = { b: string };
    
    type T1 = keyof (A & B); // "a" | "b"
    
    type T2<T> = keyof (T & B); // keyof T | "b"
    
    type T3<U> = keyof (A & U); // "a" | keyof U
    
    type T4<T, U> = keyof (T & U); // keyof T | keyof U
    
    type T5 = T2<A>; // "a" | "b"
    
    type T6 = T3<B>; // "a" | "b"
    
    type T7 = T4<A, B>; // "a" | "b"

## Better handling for namespace patterns in `.js` files

TypeScript 2.8 adds support for understanding more namespace patterns in `.js`
files. Empty object literals declarations on top level, just like functions
and classes, are now recognized as namespace declarations in JavaScript.

    
    
    js
    
    var ns = {}; // recognized as a declaration for a namespace `ns`
    
    ns.constant = 1; // recognized as a declaration for var `constant`

Assignments at the top-level should behave the same way; in other words, a
`var` or `const` declaration is not required.

    
    
    js
    
    app = {}; // does NOT need to be `var app = {}`
    
    app.C = class {};
    
    app.f = function() {};
    
    app.prop = 1;

## IIFEs as namespace declarations

An IIFE returning a function, class or empty object literal, is also
recognized as a namespace:

    
    
    js
    
    var C = (function() {
    
      function C(n) {
    
        this.p = n;
    
      }
    
      return C;
    
    })();
    
    C.staticProperty = 1;

## Defaulted declarations

‚ÄúDefaulted declarations‚Äù allow initializers that reference the declared name
in the left side of a logical or:

    
    
    js
    
    my = window.my || {};
    
    my.app = my.app || {};

## Prototype assignment

You can assign an object literal directly to the prototype property.
Individual prototype assignments still work too:

    
    
    ts
    
    var C = function(p) {
    
      this.p = p;
    
    };
    
    C.prototype = {
    
      m() {
    
        console.log(this.p);
    
      }
    
    };
    
    C.prototype.q = function(r) {
    
      return this.p === r;
    
    };

## Nested and merged declarations

Nesting works to any level now, and merges correctly across files. Previously
neither was the case.

    
    
    js
    
    var app = window.app || {};
    
    app.C = class {};

## Per-file JSX factories

TypeScript 2.8 adds support for a per-file configurable JSX factory name using
`@jsx dom` pragma. JSX factory can be configured for a compilation using
[`jsxFactory`](/tsconfig#jsxFactory) (default is `React.createElement`). With
TypeScript 2.8 you can override this on a per-file-basis by adding a comment
to the beginning of the file.

##### Example

    
    
    ts
    
    /** @jsx dom */
    
    import { dom } from "./renderer";
    
    <h></h>;

Generates:

    
    
    js
    
    var renderer_1 = require("./renderer");
    
    renderer_1.dom("h", null);

## Locally scoped JSX namespaces

JSX type checking is driven by definitions in a JSX namespace, for instance
`JSX.Element` for the type of a JSX element, and `JSX.IntrinsicElements` for
built-in elements. Before TypeScript 2.8 the `JSX` namespace was expected to
be in the global namespace, and thus only allowing one to be defined in a
project. Starting with TypeScript 2.8 the `JSX` namespace will be looked under
the `jsxNamespace` (e.g. `React`) allowing for multiple jsx factories in one
compilation. For backward compatibility the global `JSX` namespace is used as
a fallback if none was defined on the factory function. Combined with the per-
file `@jsx` pragma, each file can have a different JSX factory.

## New `--emitDeclarationOnly`

[`emitDeclarationOnly`](/tsconfig#emitDeclarationOnly) allows for _only_
generating declaration files; `.js`/`.jsx` output generation will be skipped
with this flag. The flag is useful when the `.js` output generation is handled
by a different transpiler like Babel.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.8.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(55\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DK![Dongho Kim
\(1\)](https://gravatar.com/avatar/c25a3cf91cee8b9eb7860757b845ecf0?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

DR![Daniel Rosenwasser
\(1\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

5+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 2.9

## Support `number` and `symbol` named properties with `keyof` and mapped
types

TypeScript 2.9 adds support for `number` and `symbol` named properties in
index types and mapped types. Previously, the `keyof` operator and mapped
types only supported `string` named properties.

Changes include:

  * An index type `keyof T` for some type `T` is a subtype of `string | number | symbol`.
  * A mapped type `{ [P in K]: XXX }` permits any `K` assignable to `string | number | symbol`.
  * In a `for...in` statement for an object of a generic type `T`, the inferred type of the iteration variable was previously `keyof T` but is now `Extract<keyof T, string>`. (In other words, the subset of `keyof T` that includes only string-like values.)

Given an object type `X`, `keyof X` is resolved as follows:

  * If `X` contains a string index signature, `keyof X` is a union of `string`, `number`, and the literal types representing symbol-like properties, otherwise
  * If `X` contains a numeric index signature, `keyof X` is a union of `number` and the literal types representing string-like and symbol-like properties, otherwise
  * `keyof X` is a union of the literal types representing string-like, number-like, and symbol-like properties.

Where:

  * String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.
  * Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.
  * Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.

In a mapped type `{ [P in K]: XXX }`, each string literal type in `K`
introduces a property with a string name, each numeric literal type in `K`
introduces a property with a numeric name, and each unique symbol type in `K`
introduces a property with a unique symbol name. Furthermore, if `K` includes
type `string`, a string index signature is introduced, and if `K` includes
type `number`, a numeric index signature is introduced.

##### Example

    
    
    ts
    
    const c = "c";
    
    const d = 10;
    
    const e = Symbol();
    
    const enum E1 {
    
      A,
    
      B,
    
      C,
    
    }
    
    const enum E2 {
    
      A = "A",
    
      B = "B",
    
      C = "C",
    
    }
    
    type Foo = {
    
      a: string; // String-like name
    
      5: string; // Number-like name
    
      [c]: string; // String-like name
    
      [d]: string; // Number-like name
    
      [e]: string; // Symbol-like name
    
      [E1.A]: string; // Number-like name
    
      [E2.A]: string; // String-like name
    
    };
    
    type K1 = keyof Foo; // "a" | 5 | "c" | 10 | typeof e | E1.A | E2.A
    
    type K2 = Extract<keyof Foo, string>; // "a" | "c" | E2.A
    
    type K3 = Extract<keyof Foo, number>; // 5 | 10 | E1.A
    
    type K4 = Extract<keyof Foo, symbol>; // typeof e

Since `keyof` now reflects the presence of a numeric index signature by
including type `number` in the key type, mapped types such as `Partial<T>` and
`Readonly<T>` work correctly when applied to object types with numeric index
signatures:

    
    
    ts
    
    type Arrayish<T> = {
    
      length: number;
    
      [x: number]: T;
    
    };
    
    type ReadonlyArrayish<T> = Readonly<Arrayish<T>>;
    
    declare const map: ReadonlyArrayish<string>;
    
    let n = map.length;
    
    let x = map[123]; // Previously of type any (or an error with --noImplicitAny)

Furthermore, with the `keyof` operator‚Äôs support for `number` and `symbol`
named keys, it is now possible to abstract over access to properties of
objects that are indexed by numeric literals (such as numeric enum types) and
unique symbols.

    
    
    ts
    
    const enum Enum {
    
      A,
    
      B,
    
      C,
    
    }
    
    const enumToStringMap = {
    
      [Enum.A]: "Name A",
    
      [Enum.B]: "Name B",
    
      [Enum.C]: "Name C",
    
    };
    
    const sym1 = Symbol();
    
    const sym2 = Symbol();
    
    const sym3 = Symbol();
    
    const symbolToNumberMap = {
    
      [sym1]: 1,
    
      [sym2]: 2,
    
      [sym3]: 3,
    
    };
    
    type KE = keyof typeof enumToStringMap; // Enum (i.e. Enum.A | Enum.B | Enum.C)
    
    type KS = keyof typeof symbolToNumberMap; // typeof sym1 | typeof sym2 | typeof sym3
    
    function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
    
      return obj[key];
    
    }
    
    let x1 = getValue(enumToStringMap, Enum.C); // Returns "Name C"
    
    let x2 = getValue(symbolToNumberMap, sym3); // Returns 3

This is a breaking change; previously, the `keyof` operator and mapped types
only supported `string` named properties. Code that assumed values typed with
`keyof T` were always `string`s, will now be flagged as error.

##### Example

    
    
    ts
    
    function useKey<T, K extends keyof T>(o: T, k: K) {
    
      var name: string = k; // Error: keyof T is not assignable to string
    
    }

#### Recommendations

  * If your functions are only able to handle string named property keys, use `Extract<keyof T, string>` in the declaration:
    
        ts
    
    function useKey<T, K extends Extract<keyof T, string>>(o: T, k: K) {
    
      var name: string = k; // OK
    
    }

  * If your functions are open to handling all property keys, then the changes should be done down-stream:
    
        ts
    
    function useKey<T, K extends keyof T>(o: T, k: K) {
    
      var name: string | number | symbol = k;
    
    }

  * Otherwise use [`keyofStringsOnly`](/tsconfig#keyofStringsOnly) compiler option to disable the new behavior.

## Generic type arguments in JSX elements

JSX elements now allow passing type arguments to generic components.

##### Example

    
    
    ts
    
    class GenericComponent<P> extends React.Component<P> {
    
      internalProp: P;
    
    }
    
    type Props = { a: number; b: string };
    
    const x = <GenericComponent<Props> a={10} b="hi" />; // OK
    
    const y = <GenericComponent<Props> a={10} b={20} />; // Error

## Generic type arguments in generic tagged templates

Tagged templates are a form of invocation introduced in ECMAScript 2015. Like
call expressions, generic functions may be used in a tagged template and
TypeScript will infer the type arguments utilized.

TypeScript 2.9 allows passing generic type arguments to tagged template
strings.

##### Example

    
    
    ts
    
    declare function styledComponent<Props>(
    
      strs: TemplateStringsArray
    
    ): Component<Props>;
    
    interface MyProps {
    
      name: string;
    
      age: number;
    
    }
    
    styledComponent<MyProps>`
    
      font-size: 1.5em;
    
      text-align: center;
    
      color: palevioletred;
    
    `;
    
    declare function tag<T>(strs: TemplateStringsArray, ...args: T[]): T;
    
    // inference fails because 'number' and 'string' are both candidates that conflict
    
    let a = tag<string | number>`${100} ${"hello"}`;

## `import` types

Modules can import types declared in other modules. But non-module global
scripts cannot access types declared in modules. Enter `import` types.

Using `import("mod")` in a type annotation allows for reaching in a module and
accessing its exported declaration without importing it.

##### Example

Given a declaration of a class `Pet` in a module file:

    
    
    ts
    
    // module.d.ts
    
    export declare class Pet {
    
      name: string;
    
    }

Can be used in a non-module file `global-script.ts`:

    
    
    ts
    
    // global-script.ts
    
    function adopt(p: import("./module").Pet) {
    
      console.log(`Adopting ${p.name}...`);
    
    }

This also works in JSDoc comments to refer to types from other modules in
`.js`:

    
    
    js
    
    // a.js
    
    /**
    
     * @param p { import("./module").Pet }
    
     */
    
    function walk(p) {
    
      console.log(`Walking ${p.name}...`);
    
    }

## Relaxing declaration emit visibility rules

With `import` types available, many of the visibility errors reported during
declaration file generation can be handled by the compiler without the need to
change the input.

For instance:

    
    
    ts
    
    import { createHash } from "crypto";
    
    export const hash = createHash("sha256");
    
    //           ^^^^
    
    // Exported variable 'hash' has or is using name 'Hash' from external module "crypto" but cannot be named.

With TypeScript 2.9, no errors are reported, and now the generated file looks
like:

    
    
    ts
    
    export declare const hash: import("crypto").Hash;

## Support for `import.meta`

TypeScript 2.9 introduces support for `import.meta`, a new meta-property as
described by the current [TC39 proposal](https://github.com/tc39/proposal-
import-meta).

The type of `import.meta` is the global `ImportMeta` type which is defined in
`lib.es5.d.ts`. This interface is extremely limited. Adding well-known
properties for Node or browsers requires interface merging and possibly a
global augmentation depending on the context.

##### Example

Assuming that `__dirname` is always available on `import.meta`, the
declaration would be done through reopening `ImportMeta` interface:

    
    
    ts
    
    // node.d.ts
    
    interface ImportMeta {
    
      __dirname: string;
    
    }

And usage would be:

    
    
    ts
    
    import.meta.__dirname; // Has type 'string'

`import.meta` is only allowed when targeting `ESNext` modules and ECMAScript
targets.

## New `--resolveJsonModule`

Often in Node.js applications a `.json` is needed. With TypeScript 2.9,
[`resolveJsonModule`](/tsconfig#resolveJsonModule) allows for importing,
extracting types from and generating `.json` files.

##### Example

    
    
    ts
    
    // settings.json
    
    {
    
        "repo": "TypeScript",
    
        "dry": false,
    
        "debug": false
    
    }
    
    
    ts
    
    // a.ts
    
    import settings from "./settings.json";
    
    settings.debug === true; // OK
    
    settings.dry === 2; // Error: Operator '===' cannot be applied boolean and number
    
    
    // tsconfig.json
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[resolveJsonModule](https://www.typescriptlang.org/tsconfig#resolveJsonModule)": true,
    
        "[esModuleInterop](https://www.typescriptlang.org/tsconfig#esModuleInterop)": true
    
      }
    
    }

## `--pretty` output by default

Starting TypeScript 2.9 errors are displayed under
[`pretty`](/tsconfig#pretty) by default if the output device is applicable for
colorful text. TypeScript will check if the output stream has
[`isTty`](https://nodejs.org/api/tty.html) property set.

Use `--pretty false` on the command line or set `"pretty": false` in your
`tsconfig.json` to disable [`pretty`](/tsconfig#pretty) output.

## New `--declarationMap`

Enabling [`declarationMap`](/tsconfig#declarationMap) alongside
[`declaration`](/tsconfig#declaration) causes the compiler to emit `.d.ts.map`
files alongside the output `.d.ts` files. Language Services can also now
understand these map files, and uses them to map declaration-file based
definition locations to their original source, when available.

In other words, hitting go-to-definition on a declaration from a `.d.ts` file
generated with [`declarationMap`](/tsconfig#declarationMap) will take you to
the source file (`.ts`) location where that declaration was defined, and not
to the `.d.ts`.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
2.9.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(51\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

BH![Bj√∏rnar Hvidsten
\(1\)](https://gravatar.com/avatar/0cb9c60ebb348aed7f8fd55df196a331?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.0

## Project References

TypeScript 3.0 introduces a new concept of project references. Project
references allow TypeScript projects to depend on other TypeScript projects -
specifically, allowing `tsconfig.json` files to reference other
`tsconfig.json` files. Specifying these dependencies makes it easier to split
your code into smaller projects, since it gives TypeScript (and tools around
it) a way to understand build ordering and output structure.

TypeScript 3.0 also introduces a new mode for tsc, the `--build` flag, that
works hand-in-hand with project references to enable faster TypeScript builds.

See [Project References handbook page](/docs/handbook/project-references.html)
for more documentation.

## Tuples in rest parameters and spread expressions

TypeScript 3.0 adds support to multiple new capabilities to interact with
function parameter lists as tuple types. TypeScript 3.0 adds support for:

  * Expansion of rest parameters with tuple types into discrete parameters.
  * Expansion of spread expressions with tuple types into discrete arguments.
  * Generic rest parameters and corresponding inference of tuple types.
  * Optional elements in tuple types.
  * Rest elements in tuple types.

With these features it becomes possible to strongly type a number of higher-
order functions that transform functions and their parameter lists.

## Rest parameters with tuple types

When a rest parameter has a tuple type, the tuple type is expanded into a
sequence of discrete parameters. For example the following two declarations
are equivalent:

    
    
    ts
    
    declare function foo(...args: [number, string, boolean]): void;
    
    
    ts
    
    declare function foo(args_0: number, args_1: string, args_2: boolean): void;

## Spread expressions with tuple types

When a function call includes a spread expression of a tuple type as the last
argument, the spread expression corresponds to a sequence of discrete
arguments of the tuple element types.

Thus, the following calls are equivalent:

    
    
    ts
    
    const args: [number, string, boolean] = [42, "hello", true];
    
    foo(42, "hello", true);
    
    foo(args[0], args[1], args[2]);
    
    foo(...args);

## Generic rest parameters

A rest parameter is permitted to have a generic type that is constrained to an
array type, and type inference can infer tuple types for such generic rest
parameters. This enables higher-order capturing and spreading of partial
parameter lists:

##### Example

    
    
    ts
    
    declare function bind<T, U extends any[], V>(
    
      f: (x: T, ...args: U) => V,
    
      x: T
    
    ): (...args: U) => V;
    
    declare function f3(x: number, y: string, z: boolean): void;
    
    const f2 = bind(f3, 42); // (y: string, z: boolean) => void
    
    const f1 = bind(f2, "hello"); // (z: boolean) => void
    
    const f0 = bind(f1, true); // () => void
    
    f3(42, "hello", true);
    
    f2("hello", true);
    
    f1(true);
    
    f0();

In the declaration of `f2` above, type inference infers types `number`,
`[string, boolean]` and `void` for `T`, `U` and `V` respectively.

Note that when a tuple type is inferred from a sequence of parameters and
later expanded into a parameter list, as is the case for `U`, the original
parameter names are used in the expansion (however, the names have no semantic
meaning and are not otherwise observable).

## Optional elements in tuple types

Tuple types now permit a `?` postfix on element types to indicate that the
element is optional:

##### Example

    
    
    ts
    
    let t: [number, string?, boolean?];
    
    t = [42, "hello", true];
    
    t = [42, "hello"];
    
    t = [42];

In [`strictNullChecks`](/tsconfig#strictNullChecks) mode, a `?` modifier
automatically includes `undefined` in the element type, similar to optional
parameters.

A tuple type permits an element to be omitted if it has a postfix `?` modifier
on its type and all elements to the right of it also have `?` modifiers.

When tuple types are inferred for rest parameters, optional parameters in the
source become optional tuple elements in the inferred type.

The `length` property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the `length` property in the tuple type `[number, string?, boolean?]` is `1 | 2 | 3`.

### Rest elements in tuple types

The last element of a tuple type can be a rest element of the form `...X`,
where `X` is an array type. A rest element indicates that the tuple type is
open-ended and may have zero or more additional elements of the array element
type. For example, `[number, ...string[]]` means tuples with a `number`
element followed by any number of `string` elements.

##### Example

    
    
    ts
    
    function tuple<T extends any[]>(...args: T): T {
    
      return args;
    
    }
    
    const numbers: number[] = getArrayOfNumbers();
    
    const t1 = tuple("foo", 1, true); // [string, number, boolean]
    
    const t2 = tuple("bar", ...numbers); // [string, ...number[]]

The type of the `length` property of a tuple type with a rest element is
`number`.

## New `unknown` top type

TypeScript 3.0 introduces a new top type `unknown`. `unknown` is the type-safe
counterpart of `any`. Anything is assignable to `unknown`, but `unknown` isn‚Äôt
assignable to anything but itself and `any` without a type assertion or a
control flow based narrowing. Likewise, no operations are permitted on an
`unknown` without first asserting or narrowing to a more specific type.

##### Example

    
    
    ts
    
    // In an intersection everything absorbs unknown
    
    type T00 = unknown & null; // null
    
    type T01 = unknown & undefined; // undefined
    
    type T02 = unknown & null & undefined; // null & undefined (which becomes never)
    
    type T03 = unknown & string; // string
    
    type T04 = unknown & string[]; // string[]
    
    type T05 = unknown & unknown; // unknown
    
    type T06 = unknown & any; // any
    
    // In a union an unknown absorbs everything
    
    type T10 = unknown | null; // unknown
    
    type T11 = unknown | undefined; // unknown
    
    type T12 = unknown | null | undefined; // unknown
    
    type T13 = unknown | string; // unknown
    
    type T14 = unknown | string[]; // unknown
    
    type T15 = unknown | unknown; // unknown
    
    type T16 = unknown | any; // any
    
    // Type variable and unknown in union and intersection
    
    type T20<T> = T & {}; // T & {}
    
    type T21<T> = T | {}; // T | {}
    
    type T22<T> = T & unknown; // T
    
    type T23<T> = T | unknown; // unknown
    
    // unknown in conditional types
    
    type T30<T> = unknown extends T ? true : false; // Deferred
    
    type T31<T> = T extends unknown ? true : false; // Deferred (so it distributes)
    
    type T32<T> = never extends T ? true : false; // true
    
    type T33<T> = T extends never ? true : false; // Deferred
    
    // keyof unknown
    
    type T40 = keyof any; // string | number | symbol
    
    type T41 = keyof unknown; // never
    
    // Only equality operators are allowed with unknown
    
    function f10(x: unknown) {
    
      x == 5;
    
      x !== 10;
    
      x >= 0; // Error
    
      x + 1; // Error
    
      x * 2; // Error
    
      -x; // Error
    
      +x; // Error
    
    }
    
    // No property accesses, element accesses, or function calls
    
    function f11(x: unknown) {
    
      x.foo; // Error
    
      x[5]; // Error
    
      x(); // Error
    
      new x(); // Error
    
    }
    
    // typeof, instanceof, and user defined type predicates
    
    declare function isFunction(x: unknown): x is Function;
    
    function f20(x: unknown) {
    
      if (typeof x === "string" || typeof x === "number") {
    
        x; // string | number
    
      }
    
      if (x instanceof Error) {
    
        x; // Error
    
      }
    
      if (isFunction(x)) {
    
        x; // Function
    
      }
    
    }
    
    // Homomorphic mapped type over unknown
    
    type T50<T> = { [P in keyof T]: number };
    
    type T51 = T50<any>; // { [x: string]: number }
    
    type T52 = T50<unknown>; // {}
    
    // Anything is assignable to unknown
    
    function f21<T>(pAny: any, pNever: never, pT: T) {
    
      let x: unknown;
    
      x = 123;
    
      x = "hello";
    
      x = [1, 2, 3];
    
      x = new Error();
    
      x = x;
    
      x = pAny;
    
      x = pNever;
    
      x = pT;
    
    }
    
    // unknown assignable only to itself and any
    
    function f22(x: unknown) {
    
      let v1: any = x;
    
      let v2: unknown = x;
    
      let v3: object = x; // Error
    
      let v4: string = x; // Error
    
      let v5: string[] = x; // Error
    
      let v6: {} = x; // Error
    
      let v7: {} | null | undefined = x; // Error
    
    }
    
    // Type parameter 'T extends unknown' not related to object
    
    function f23<T extends unknown>(x: T) {
    
      let y: object = x; // Error
    
    }
    
    // Anything but primitive assignable to { [x: string]: unknown }
    
    function f24(x: { [x: string]: unknown }) {
    
      x = {};
    
      x = { a: 5 };
    
      x = [1, 2, 3];
    
      x = 123; // Error
    
    }
    
    // Locals of type unknown always considered initialized
    
    function f25() {
    
      let x: unknown;
    
      let y = x;
    
    }
    
    // Spread of unknown causes result to be unknown
    
    function f26(x: {}, y: unknown, z: any) {
    
      let o1 = { a: 42, ...x }; // { a: number }
    
      let o2 = { a: 42, ...x, ...y }; // unknown
    
      let o3 = { a: 42, ...x, ...y, ...z }; // any
    
    }
    
    // Functions with unknown return type don't need return expressions
    
    function f27(): unknown {}
    
    // Rest type cannot be created from unknown
    
    function f28(x: unknown) {
    
      let { ...a } = x; // Error
    
    }
    
    // Class properties of type unknown don't need definite assignment
    
    class C1 {
    
      a: string; // Error
    
      b: unknown;
    
      c: any;
    
    }

## Support for `defaultProps` in JSX

TypeScript 2.9 and earlier didn‚Äôt leverage [React
`defaultProps`](https://reactjs.org/docs/typechecking-with-
proptypes.html#default-prop-values) declarations inside JSX components. Users
would often have to declare properties optional and use non-null assertions
inside of `render`, or they‚Äôd use type-assertions to fix up the type of the
component before exporting it.

TypeScript 3.0 adds support for a new type alias in the `JSX` namespace called
`LibraryManagedAttributes`. This helper type defines a transformation on the
component‚Äôs `Props` type, before using to check a JSX expression targeting it;
thus allowing customization like: how conflicts between provided props and
inferred props are handled, how inferences are mapped, how optionality is
handled, and how inferences from differing places should be combined.

In short using this general type, we can model React‚Äôs specific behavior for
things like `defaultProps` and, to some extent, `propTypes`.

    
    
    tsx
    
    export interface Props {
    
      name: string;
    
    }
    
    export class Greet extends React.Component<Props> {
    
      render() {
    
        const { name } = this.props;
    
        return <div>Hello {name.toUpperCase()}!</div>;
    
      }
    
      static defaultProps = { name: "world" };
    
    }
    
    // Type-checks! No type assertions needed!
    
    let el = <Greet />;

## Caveats

### Explicit types on `defaultProps`

The default-ed properties are inferred from the `defaultProps` property type.
If an explicit type annotation is added, e.g. `static defaultProps:
Partial<Props>;` the compiler will not be able to identify which properties
have defaults (since the type of `defaultProps` include all properties of
`Props`).

Use `static defaultProps: Pick<Props, "name">;` as an explicit type annotation
instead, or do not add a type annotation as done in the example above.

For function components (formerly known as SFCs) use ES2015 default
initializers:

    
    
    tsx
    
    function Greet({ name = "world" }: Props) {
    
      return <div>Hello {name.toUpperCase()}!</div>;
    
    }

#### Changes to `@types/React`

Corresponding changes to add `LibraryManagedAttributes` definition to the
`JSX` namespace in `@types/React` are still needed. Keep in mind that there
are some limitations.

## `/// <reference lib="..." />` reference directives

TypeScript adds a new triple-slash-reference directive (`/// <reference
lib="name" />`), allowing a file to explicitly include an existing built-in
_lib_ file.

Built-in _lib_ files are referenced in the same fashion as the
[`lib`](/tsconfig#lib) compiler option in _tsconfig.json_ (e.g. use
`lib="es2015"` and not `lib="lib.es2015.d.ts"`, etc.).

For declaration file authors who relay on built-in types, e.g. DOM APIs or
built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-
reference lib directives are the recommended. Previously these .d.ts files had
to add forward/duplicate declarations of such types.

##### Example

Using `/// <reference lib="es2017.string" />` to one of the files in a
compilation is equivalent to compiling with `--lib es2017.string`.

    
    
    ts
    
    /// <reference lib="es2017.string" />
    
    "foo".padStart(4);

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.0.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(53\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RC![Ryan Cavanaugh
\(2\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

RI![Ruslan Iusupov
\(2\)](https://gravatar.com/avatar/e4eb89fda2c3d3f54efa810a9ba9b0da?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

10+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.1

## Mapped types on tuples and arrays

In TypeScript 3.1, mapped object types[1] over tuples and arrays now produce
new tuples/arrays, rather than creating a new type where members like
`push()`, `pop()`, and `length` are converted. For example:

    
    
    ts
    
    type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };
    
    type Coordinate = [number, number];
    
    type PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]

`MapToPromise` takes a type `T`, and when that type is a tuple like
`Coordinate`, only the numeric properties are converted. In `[number,
number]`, there are two numerically named properties: `0` and `1`. When given
a tuple like that, `MapToPromise` will create a new tuple where the `0` and
`1` properties are `Promise`s of the original type. So the resulting type
`PromiseCoordinate` ends up with the type `[Promise<number>,
Promise<number>]`.

## Properties declarations on functions

TypeScript 3.1 brings the ability to define properties on function
declarations and `const`-declared functions, simply by assigning to properties
on these functions in the same scope. This allows us to write canonical
JavaScript code without resorting to `namespace` hacks. For example:

    
    
    ts
    
    function readImage(path: string, callback: (err: any, image: Image) => void) {
    
      // ...
    
    }
    
    readImage.sync = (path: string) => {
    
      const contents = fs.readFileSync(path);
    
      return decodeImageSync(contents);
    
    };

Here, we have a function `readImage` which reads an image in a non-blocking
asynchronous way. In addition to `readImage`, we‚Äôve provided a convenience
function on `readImage` itself called `readImage.sync`.

While ECMAScript exports are often a better way of providing this
functionality, this new support allows code written in this style to ‚Äújust
work‚Äù in TypeScript. Additionally, this approach for property declarations
allows us to express common patterns like `defaultProps` and `propTypes` on
React function components (formerly known as SFCs).

    
    
    ts
    
    export const FooComponent = ({ name }) => <div>Hello! I am {name}</div>;
    
    FooComponent.defaultProps = {
    
      name: "(anonymous)",
    
    };

* * *

[1] More specifically, homomorphic mapped types like in the above form.

## Version selection with `typesVersions`

Feedback from our community, as well as our own experience, has shown us that
leveraging the newest TypeScript features while also accommodating users on
the older versions are difficult. TypeScript introduces a new feature called
`typesVersions` to help accommodate these scenarios.

You can read [about it in the Publishing section of the declaration files
section](https://www.typescriptlang.org/docs/handbook/declaration-
files/publishing.html#version-selection-with-typesversions)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.1.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(18\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

CF![Cory Forsyth
\(1\)](https://gravatar.com/avatar/6751f4a7eaba73279ee0dabafe3caccf?s=32&&d=blank)

MU![Masato Urai
\(1\)](https://gravatar.com/avatar/6b10b84436915f5e96900a8b1d2452d9?s=32&&d=blank)

SS![Sebastian Silbermann
\(1\)](https://gravatar.com/avatar/8909c1e1d9b64fd5db83ca8e0d7e16a5?s=32&&d=blank)

10+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.2

## `strictBindCallApply`

TypeScript 3.2 introduces a new
[`strictBindCallApply`](/tsconfig#strictBindCallApply) compiler option (in the
[`strict`](/tsconfig#strict) family of options) with which the `bind`, `call`,
and `apply` methods on function objects are strongly typed and strictly
checked.

    
    
    ts
    
    function foo(a: number, b: string): string {
    
      return a + b;
    
    }
    
    let a = foo.apply(undefined, [10]); // error: too few arguments
    
    let b = foo.apply(undefined, [10, 20]); // error: 2nd argument is a number
    
    let c = foo.apply(undefined, [10, "hello", 30]); // error: too many arguments
    
    let d = foo.apply(undefined, [10, "hello"]); // okay! returns a string

This is achieved by introducing two new types, `CallableFunction` and
`NewableFunction`, in `lib.d.ts`. These types contain specialized generic
method declarations for `bind`, `call`, and `apply` for regular functions and
constructor functions, respectively. The declarations use generic rest
parameters (see #24897) to capture and reflect parameter lists in a strongly
typed manner. In [`strictBindCallApply`](/tsconfig#strictBindCallApply) mode
these declarations are used in place of the (very permissive) declarations
provided by type `Function`.

## Caveats

Since the stricter checks may uncover previously unreported errors, this is a
breaking change in [`strict`](/tsconfig#strict) mode.

Additionally, [another
caveat](https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450)
of this new functionality is that due to certain limitations, `bind`, `call`,
and `apply` can‚Äôt yet fully model generic functions or functions that have
overloads. When using these methods on a generic function, type parameters
will be substituted with the empty object type (`{}`), and when used on a
function with overloads, only the last overload will ever be modeled.

## Generic spread expressions in object literals

In TypeScript 3.2, object literals now allow generic spread expressions which
now produce intersection types, similar to the `Object.assign` function and
JSX literals. For example:

    
    
    ts
    
    function taggedObject<T, U extends string>(obj: T, tag: U) {
    
      return { ...obj, tag }; // T & { tag: U }
    
    }
    
    let x = taggedObject({ x: 10, y: 20 }, "point"); // { x: number, y: number } & { tag: "point" }

Property assignments and non-generic spread expressions are merged to the
greatest extent possible on either side of a generic spread expression. For
example:

    
    
    ts
    
    function foo1<T>(t: T, obj1: { a: string }, obj2: { b: string }) {
    
      return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } & T & { b: string, y: number }
    
    }

Non-generic spread expressions continue to be processed as before: Call and
construct signatures are stripped, only non-method properties are preserved,
and for properties with the same name, the type of the rightmost property is
used. This contrasts with intersection types which concatenate call and
construct signatures, preserve all properties, and intersect the types of
properties with the same name. Thus, spreads of the same types may produce
different results when they are created through instantiation of generic
types:

    
    
    ts
    
    function spread<T, U>(t: T, u: U) {
    
      return { ...t, ...u }; // T & U
    
    }
    
    declare let x: { a: string; b: number };
    
    declare let y: { b: string; c: boolean };
    
    let s1 = { ...x, ...y }; // { a: string, b: string, c: boolean }
    
    let s2 = spread(x, y); // { a: string, b: number } & { b: string, c: boolean }
    
    let b1 = s1.b; // string
    
    let b2 = s2.b; // number & string

## Generic object rest variables and parameters

TypeScript 3.2 also allows destructuring a rest binding from a generic
variable. This is achieved by using the predefined `Pick` and `Exclude` helper
types from `lib.d.ts`, and using the generic type in question as well as the
names of the other bindings in the destructuring pattern.

    
    
    ts
    
    function excludeTag<T extends { tag: string }>(obj: T) {
    
      let { tag, ...rest } = obj;
    
      return rest; // Pick<T, Exclude<keyof T, "tag">>
    
    }
    
    const taggedPoint = { x: 10, y: 20, tag: "point" };
    
    const point = excludeTag(taggedPoint); // { x: number, y: number }

## BigInt

BigInts are part of an upcoming proposal in ECMAScript that allow us to model
theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking
for BigInts, as well as support for emitting BigInt literals when targeting
`esnext`.

BigInt support in TypeScript introduces a new primitive type called the
`bigint` (all lowercase). You can get a `bigint` by calling the `BigInt()`
function or by writing out a BigInt literal by adding an `n` to the end of any
integer numeric literal:

    
    
    ts
    
    let foo: bigint = BigInt(100); // the BigInt function
    
    let bar: bigint = 100n; // a BigInt literal
    
    // *Slaps roof of fibonacci function*
    
    // This bad boy returns ints that can get *so* big!
    
    function fibonacci(n: bigint) {
    
      let result = 1n;
    
      for (let last = 0n, i = 0n; i < n; i++) {
    
        const current = result;
    
        result += last;
    
        last = current;
    
      }
    
      return result;
    
    }
    
    fibonacci(10000n);

While you might imagine close interaction between `number` and `bigint`, the
two are separate domains.

    
    
    ts
    
    declare let foo: number;
    
    declare let bar: bigint;
    
    foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
    
    bar = foo; // error: Type 'number' is not assignable to type 'bigint'.

As specified in ECMAScript, mixing `number`s and `bigint`s in arithmetic
operations is an error. You‚Äôll have to explicitly convert values to `BigInt`s.

    
    
    ts
    
    console.log(3.141592 * 10000n); // error
    
    console.log(3145 * 10n); // error
    
    console.log(BigInt(3145) * 10n); // okay!

Also important to note is that `bigint`s produce a new string when using the
`typeof` operator: the string `"bigint"`. Thus, TypeScript correctly narrows
using `typeof` as you‚Äôd expect.

    
    
    ts
    
    function whatKindOfNumberIsIt(x: number | bigint) {
    
      if (typeof x === "bigint") {
    
        console.log("'x' is a bigint!");
    
      } else {
    
        console.log("'x' is a floating-point number");
    
      }
    
    }

We‚Äôd like to extend a huge thanks to [Caleb
Sander](https://github.com/calebsander) for all the work on this feature.
We‚Äôre grateful for the contribution, and we‚Äôre sure our users are too!

## Caveats

As we mentioned, BigInt support is only available for the `esnext` target. It
may not be obvious, but because BigInts have different behavior for
mathematical operators like `+`, `-`, `*`, etc., providing functionality for
older targets where the feature doesn‚Äôt exist (like `es2017` and below) would
involve rewriting each of these operations. TypeScript would need to dispatch
to the correct behavior depending on the type, and so every addition, string
concatenation, multiplication, etc. would involve a function call.

For that reason, we have no immediate plans to provide downleveling support.
On the bright side, Node 11 and newer versions of Chrome already support this
feature, so you‚Äôll be able to use BigInts there when targeting `esnext`.

Certain targets may include a polyfill or BigInt-like runtime object. For
those purposes you may want to add `esnext.bigint` to the
[`lib`](/tsconfig#lib) setting in your compiler options.

## Non-unit types as union discriminants

TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers
a discriminant property. Common properties of unions are now considered
discriminants as long as they contain _some_ singleton type (e.g. a string
literal, `null`, or `undefined`), and they contain no generics.

As a result, TypeScript 3.2 considers the `error` property in the following
example to be a discriminant, whereas before it wouldn‚Äôt since `Error` isn‚Äôt a
singleton type. Thanks to this, narrowing works correctly in the body of the
`unwrap` function.

    
    
    ts
    
    type Result<T> = { error: Error; data: null } | { error: null; data: T };
    
    function unwrap<T>(result: Result<T>) {
    
      if (result.error) {
    
        // Here 'error' is non-null
    
        throw result.error;
    
      }
    
      // Now 'data' is non-null
    
      return result.data;
    
    }

## `tsconfig.json` inheritance via Node.js packages

TypeScript 3.2 now resolves `tsconfig.json`s from `node_modules`. When using a
bare path for the `extends` field in `tsconfig.json`, TypeScript will dive
into `node_modules` packages for us.

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "@my-team/tsconfig-base",
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["./**/*"],
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        // Override certain options on a project-by-project basis.
    
        "[strictBindCallApply](https://www.typescriptlang.org/tsconfig#strictBindCallApply)": false
    
      }
    
    }

Here, TypeScript will climb up `node_modules` folders looking for a `@my-
team/tsconfig-base` package. For each of those packages, TypeScript will first
check whether `package.json` contains a `"tsconfig"` field, and if it does,
TypeScript will try to load a configuration file from that field. If neither
exists, TypeScript will try to read from a `tsconfig.json` at the root. This
is similar to the lookup process for `.js` files in packages that Node uses,
and the `.d.ts` lookup process that TypeScript already uses.

This feature can be extremely useful for bigger organizations, or projects
with lots of distributed dependencies.

## The new `--showConfig` flag

`tsc`, the TypeScript compiler, supports a new flag called `--showConfig`.
When running `tsc --showConfig`, TypeScript will calculate the effective
`tsconfig.json` (after calculating options inherited from the `extends` field)
and print that out. This can be useful for diagnosing configuration issues in
general.

## `Object.defineProperty` declarations in JavaScript

When writing in JavaScript files (using [`allowJs`](/tsconfig#allowJs)),
TypeScript now recognizes declarations that use `Object.defineProperty`. This
means you‚Äôll get better completions, and stronger type-checking when enabling
type-checking in JavaScript files (by turning on the
[`checkJs`](/tsconfig#checkJs) option or adding a `// @ts-check` comment to
the top of your file).

    
    
    js
    
    // @ts-check
    
    let obj = {};
    
    Object.defineProperty(obj, "x", { value: "hello", writable: false });
    
    obj.x.toLowercase();
    
    //    ~~~~~~~~~~~
    
    //    error:
    
    //     Property 'toLowercase' does not exist on type 'string'.
    
    //     Did you mean 'toLowerCase'?
    
    obj.x = "world";
    
    //  ~
    
    //  error:
    
    //   Cannot assign to 'x' because it is a read-only property.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.2.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(52\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

MU![Masato Urai
\(1\)](https://gravatar.com/avatar/6b10b84436915f5e96900a8b1d2452d9?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.3

## Improved behavior for calling union types

In prior versions of TypeScript, unions of callable types could _only_ be
invoked if they had identical parameter lists.

    
    
    ts
    
    type Fruit = "apple" | "orange";
    
    type Color = "red" | "orange";
    
    type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit
    
    type ColorConsumer = (color: Color) => string; // consumes and describes the colors
    
    declare let f: FruitEater | ColorConsumer;
    
    // Cannot invoke an expression whose type lacks a call signature.
    
    //   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)
    
    f("orange");

However, in the above example, both `FruitEater`s and `ColorConsumer`s should
be able to take the string `"orange"`, and return either a `number` or a
`string`.

In TypeScript 3.3, this is no longer an error.

    
    
    ts
    
    type Fruit = "apple" | "orange";
    
    type Color = "red" | "orange";
    
    type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit
    
    type ColorConsumer = (color: Color) => string; // consumes and describes the colors
    
    declare let f: FruitEater | ColorConsumer;
    
    f("orange"); // It works! Returns a 'number | string'.
    
    f("apple"); // error - Argument of type '"apple"' is not assignable to parameter of type '"orange"'.
    
    f("red"); // error - Argument of type '"red"' is not assignable to parameter of type '"orange"'.

In TypeScript 3.3, the parameters of these signatures are _intersected_
together to create a new signature.

In the example above, the parameters `fruit` and `color` are intersected together to a new parameter of type `Fruit & Color`. `Fruit & Color` is really the same as `("apple" | "orange") & ("red" | "orange")` which is equivalent to `("apple" & "red") | ("apple" & "orange") | ("orange" & "red") | ("orange" & "orange")`. Each of those impossible intersections reduces to `never`, and we‚Äôre left with `"orange" & "orange"` which is just `"orange"`.

## Caveats

This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on `number[] | string[]` like `map` (which is generic) still won‚Äôt be callable.

On the other hand, methods like `forEach` will now be callable, but under
[`noImplicitAny`](/tsconfig#noImplicitAny) there may be some issues.

    
    
    ts
    
    interface Dog {
    
      kind: "dog";
    
      dogProp: any;
    
    }
    
    interface Cat {
    
      kind: "cat";
    
      catProp: any;
    
    }
    
    const catOrDogArray: Dog[] | Cat[] = [];
    
    catOrDogArray.forEach(animal => {
    
      //                ~~~~~~ error!
    
      // Parameter 'animal' implicitly has an 'any' type.
    
    });

This is still strictly more capable in TypeScript 3.3, and adding an explicit
type annotation will work.

    
    
    ts
    
    interface Dog {
    
      kind: "dog";
    
      dogProp: any;
    
    }
    
    interface Cat {
    
      kind: "cat";
    
      catProp: any;
    
    }
    
    const catOrDogArray: Dog[] | Cat[] = [];
    
    catOrDogArray.forEach((animal: Dog | Cat) => {
    
      if (animal.kind === "dog") {
    
        animal.dogProp;
    
        // ...
    
      } else if (animal.kind === "cat") {
    
        animal.catProp;
    
        // ...
    
      }
    
    });

## Incremental file watching for composite projects in `--build --watch`

TypeScript 3.0 introduced a new feature for structuring builds called
‚Äúcomposite projects‚Äù. Part of the goal here was to ensure users could break up
large projects into smaller parts that build quickly and preserve project
structure, without compromising the existing TypeScript experience. Thanks to
composite projects, TypeScript can use `--build` mode to recompile only the
set of projects and dependencies. You can think of this as optimizing _inter_
-project builds.

TypeScript 2.7 also introduced `--watch` mode builds via a new incremental
‚Äúbuilder‚Äù API. In a similar vein, the entire idea is that this mode only re-
checks and re-emits changed files or files whose dependencies might impact
type-checking. You can think of this as optimizing _intra_ -project builds.

Prior to 3.3, building composite projects using `--build --watch` actually
didn‚Äôt use this incremental file watching infrastructure. An update in one
project under `--build --watch` mode would force a full build of that project,
rather than determining which files within that project were affected.

In TypeScript 3.3, `--build` mode‚Äôs `--watch` flag _does_ leverage incremental
file watching as well. That can mean significantly faster builds under
`--build --watch`. In our testing, this functionality has resulted in **a
reduction of 50% to 75% in build times** of the original `--build --watch`
times. [You can read more on the original pull request for the
change](https://github.com/Microsoft/TypeScript/pull/29161) to see specific
numbers, but we believe most composite project users will see significant wins
here.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.3.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

RA![Riley Avron
\(1\)](https://gravatar.com/avatar/ed9a8af14efbb5b912454280c1419fc3?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.4

## Faster subsequent builds with the `--incremental` flag

TypeScript 3.4 introduces a new flag called
[`incremental`](/tsconfig#incremental) which tells TypeScript to save
information about the project graph from the last compilation. The next time
TypeScript is invoked with [`incremental`](/tsconfig#incremental), it will use
that information to detect the least costly way to type-check and emit changes
to your project.

    
    
    // tsconfig.json
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[incremental](https://www.typescriptlang.org/tsconfig#incremental)": true,
    
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "./lib"
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["./src"]
    
    }

By default with these settings, when we run `tsc`, TypeScript will look for a
file called `.tsbuildinfo` in the output directory (`./lib`). If
`./lib/.tsbuildinfo` doesn‚Äôt exist, it‚Äôll be generated. But if it does, `tsc`
will try to use that file to incrementally type-check and update our output
files.

These `.tsbuildinfo` files can be safely deleted and don‚Äôt have any impact on
our code at runtime - they‚Äôre purely used to make compilations faster. We can
also name them anything that we want, and place them anywhere we want using
the [`tsBuildInfoFile`](/tsconfig#tsBuildInfoFile) option.

    
    
    // front-end.tsconfig.json
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[incremental](https://www.typescriptlang.org/tsconfig#incremental)": true,
    
        "[tsBuildInfoFile](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile)": "./buildcache/front-end",
    
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "./lib"
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["./src"]
    
    }

### Composite projects

Part of the intent with composite projects (`tsconfig.json`s with
[`composite`](/tsconfig#composite) set to `true`) is that references between
different projects can be built incrementally. As such, composite projects
will **always** produce `.tsbuildinfo` files.

### `outFile`

When [`outFile`](/tsconfig#outFile) is used, the build information file‚Äôs name
will be based on the output file‚Äôs name. As an example, if our output
JavaScript file is `./output/foo.js`, then under the
[`incremental`](/tsconfig#incremental) flag, TypeScript will generate the file
`./output/foo.tsbuildinfo`. As above, this can be controlled with the
[`tsBuildInfoFile`](/tsconfig#tsBuildInfoFile) option.

## Higher order type inference from generic functions

TypeScript 3.4 can now produce generic function types when inference from
other generic functions produces free type variables for inferences. This
means many function composition patterns now work better in 3.4.

To get more specific, let‚Äôs build up some motivation and consider the
following `compose` function:

    
    
    ts
    
    function compose<A, B, C>(f: (arg: A) => B, g: (arg: B) => C): (arg: A) => C {
    
      return (x) => g(f(x));
    
    }

`compose` takes two other functions:

  * `f` which takes some argument (of type `A`) and returns a value of type `B`
  * `g` which takes an argument of type `B` (the type `f` returned), and returns a value of type `C`

`compose` then returns a function which feeds its argument through `f` and
then `g`.

When calling this function, TypeScript will try to figure out the types of
`A`, `B`, and `C` through a process called _type argument inference_. This
inference process usually works pretty well:

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
    }
    
    function getDisplayName(p: Person) {
    
      return p.name.toLowerCase();
    
    }
    
    function getLength(s: string) {
    
      return s.length;
    
    }
    
    // has type '(p: Person) => number'
    
    const getDisplayNameLength = compose(getDisplayName, getLength);
    
    // works and returns the type 'number'
    
    getDisplayNameLength({ name: "Person McPersonface", age: 42 });

The inference process is fairly straightforward here because `getDisplayName`
and `getLength` use types that can easily be referenced. However, in
TypeScript 3.3 and earlier, generic functions like `compose` didn‚Äôt work so
well when passed other generic functions.

    
    
    ts
    
    interface Box<T> {
    
      value: T;
    
    }
    
    function makeArray<T>(x: T): T[] {
    
      return [x];
    
    }
    
    function makeBox<U>(value: U): Box<U> {
    
      return { value };
    
    }
    
    // has type '(arg: {}) => Box<{}[]>'
    
    const makeBoxedArray = compose(makeArray, makeBox);
    
    makeBoxedArray("hello!").value[0].toUpperCase();
    
    //                                ~~~~~~~~~~~
    
    // error: Property 'toUpperCase' does not exist on type '{}'.

In older versions, TypeScript would infer the empty object type (`{}`) when
inferring from other type variables like `T` and `U`.

During type argument inference in TypeScript 3.4, for a call to a generic
function that returns a function type, TypeScript _will_ , as appropriate,
propagate type parameters from generic function arguments onto the resulting
function type.

In other words, instead of producing the type

    
    
    ts
    
    (arg: {}) => Box<{}[]>

TypeScript 3.4 produces the type

    
    
    ts
    
    <T>(arg: T) => Box<T[]>

Notice that `T` has been propagated from `makeArray` into the resulting type‚Äôs
type parameter list. This means that genericity from `compose`‚Äôs arguments has
been preserved and our `makeBoxedArray` sample will just work!

    
    
    ts
    
    interface Box<T> {
    
      value: T;
    
    }
    
    function makeArray<T>(x: T): T[] {
    
      return [x];
    
    }
    
    function makeBox<U>(value: U): Box<U> {
    
      return { value };
    
    }
    
    // has type '<T>(arg: T) => Box<T[]>'
    
    const makeBoxedArray = compose(makeArray, makeBox);
    
    // works with no problem!
    
    makeBoxedArray("hello!").value[0].toUpperCase();

For more details, you can [read more at the original
change](https://github.com/Microsoft/TypeScript/pull/30215).

## Improvements for `ReadonlyArray` and `readonly` tuples

TypeScript 3.4 makes it a little bit easier to use read-only array-like types.

### A new syntax for `ReadonlyArray`

The `ReadonlyArray` type describes `Array`s that can only be read from. Any
variable with a reference to a `ReadonlyArray` can‚Äôt add, remove, or replace
any elements of the array.

    
    
    ts
    
    function foo(arr: ReadonlyArray<string>) {
    
      arr.slice(); // okay
    
      arr.push("hello!"); // error!
    
    }

While it‚Äôs good practice to use `ReadonlyArray` over `Array` when no mutation
is intended, it‚Äôs often been a pain given that arrays have a nicer syntax.
Specifically, `number[]` is a shorthand version of `Array<number>`, just as
`Date[]` is a shorthand for `Array<Date>`.

TypeScript 3.4 introduces a new syntax for `ReadonlyArray` using a new
`readonly` modifier for array types.

    
    
    ts
    
    function foo(arr: readonly string[]) {
    
      arr.slice(); // okay
    
      arr.push("hello!"); // error!
    
    }

### `readonly` tuples

TypeScript 3.4 also introduces new support for `readonly` tuples. We can
prefix any tuple type with the `readonly` keyword to make it a `readonly`
tuple, much like we now can with array shorthand syntax. As you might expect,
unlike ordinary tuples whose slots could be written to, `readonly` tuples only
permit reading from those positions.

    
    
    ts
    
    function foo(pair: readonly [string, string]) {
    
      console.log(pair[0]); // okay
    
      pair[1] = "hello!"; // error
    
    }

The same way that ordinary tuples are types that extend from `Array` \- a tuple with elements of type `T1`, `T2`, ‚Ä¶ `Tn` extends from `Array< T1 | T2 | ‚Ä¶ Tn >` \- `readonly` tuples are types that extend from `ReadonlyArray`. So a `readonly` tuple with elements `T1`, `T2`, ‚Ä¶ `Tn` extends from `ReadonlyArray< T1 | T2 | ‚Ä¶ Tn`.

### `readonly` mapped type modifiers and `readonly` arrays

In earlier versions of TypeScript, we generalized mapped types to operate
differently on array-like types. This meant that a mapped type like `Boxify`
could work on arrays and tuples alike.

    
    
    ts
    
    interface Box<T> {
    
      value: T;
    
    }
    
    type Boxify<T> = {
    
      [K in keyof T]: Box<T[K]>;
    
    };
    
    // { a: Box<string>, b: Box<number> }
    
    type A = Boxify<{ a: string; b: number }>;
    
    // Array<Box<number>>
    
    type B = Boxify<number[]>;
    
    // [Box<string>, Box<number>]
    
    type C = Boxify<[string, boolean]>;

Unfortunately, mapped types like the `Readonly` utility type were effectively
no-ops on array and tuple types.

    
    
    ts
    
    // lib.d.ts
    
    type Readonly<T> = {
    
      readonly [K in keyof T]: T[K];
    
    };
    
    // How code acted *before* TypeScript 3.4
    
    // { readonly a: string, readonly b: number }
    
    type A = Readonly<{ a: string; b: number }>;
    
    // number[]
    
    type B = Readonly<number[]>;
    
    // [string, boolean]
    
    type C = Readonly<[string, boolean]>;

In TypeScript 3.4, the `readonly` modifier in a mapped type will automatically
convert array-like types to their corresponding `readonly` counterparts.

    
    
    ts
    
    // How code acts now *with* TypeScript 3.4
    
    // { readonly a: string, readonly b: number }
    
    type A = Readonly<{ a: string; b: number }>;
    
    // readonly number[]
    
    type B = Readonly<number[]>;
    
    // readonly [string, boolean]
    
    type C = Readonly<[string, boolean]>;

Similarly, you could write a utility type like `Writable` mapped type that
strips away `readonly`-ness, and that would convert `readonly` array
containers back to their mutable equivalents.

    
    
    ts
    
    type Writable<T> = {
    
      -readonly [K in keyof T]: T[K];
    
    };
    
    // { a: string, b: number }
    
    type A = Writable<{
    
      readonly a: string;
    
      readonly b: number;
    
    }>;
    
    // number[]
    
    type B = Writable<readonly number[]>;
    
    // [string, boolean]
    
    type C = Writable<readonly [string, boolean]>;

### Caveats

Despite its appearance, the `readonly` type modifier can only be used for
syntax on array types and tuple types. It is not a general-purpose type
operator.

    
    
    ts
    
    let err1: readonly Set<number>; // error!
    
    let err2: readonly Array<boolean>; // error!
    
    let okay: readonly boolean[]; // works fine

You can [see more details in the pull
request](https://github.com/Microsoft/TypeScript/pull/29435).

## `const` assertions

TypeScript 3.4 introduces a new construct for literal values called _`const`_
assertions. Its syntax is a type assertion with `const` in place of the type
name (e.g. `123 as const`). When we construct new literal expressions with
`const` assertions, we can signal to the language that

  * no literal types in that expression should be widened (e.g. no going from `"hello"` to `string`)
  * object literals get `readonly` properties
  * array literals become `readonly` tuples

    
    
    ts
    
    // Type '"hello"'
    
    let x = "hello" as const;
    
    // Type 'readonly [10, 20]'
    
    let y = [10, 20] as const;
    
    // Type '{ readonly text: "hello" }'
    
    let z = { text: "hello" } as const;

Outside of `.tsx` files, the angle bracket assertion syntax can also be used.

    
    
    ts
    
    // Type '"hello"'
    
    let x = <const>"hello";
    
    // Type 'readonly [10, 20]'
    
    let y = <const>[10, 20];
    
    // Type '{ readonly text: "hello" }'
    
    let z = <const>{ text: "hello" };

This feature means that types that would otherwise be used just to hint
immutability to the compiler can often be omitted.

    
    
    ts
    
    // Works with no types referenced or declared.
    
    // We only needed a single const assertion.
    
    function getShapes() {
    
      let result = [
    
        { kind: "circle", radius: 100 },
    
        { kind: "square", sideLength: 50 },
    
      ] as const;
    
      return result;
    
    }
    
    for (const shape of getShapes()) {
    
      // Narrows perfectly!
    
      if (shape.kind === "circle") {
    
        console.log("Circle radius", shape.radius);
    
      } else {
    
        console.log("Square side length", shape.sideLength);
    
      }
    
    }

Notice the above needed no type annotations. The `const` assertion allowed
TypeScript to take the most specific type of the expression.

This can even be used to enable `enum`-like patterns in plain JavaScript code
if you choose not to use TypeScript‚Äôs `enum` construct.

    
    
    ts
    
    export const Colors = {
    
      red: "RED",
    
      blue: "BLUE",
    
      green: "GREEN",
    
    } as const;
    
    // or use an 'export default'
    
    export default {
    
      red: "RED",
    
      blue: "BLUE",
    
      green: "GREEN",
    
    } as const;

### Caveats

One thing to note is that `const` assertions can only be applied immediately
on simple literal expressions.

    
    
    ts
    
    // Error! A 'const' assertion can only be applied to a
    
    // to a string, number, boolean, array, or object literal.
    
    let a = (Math.random() < 0.5 ? 0 : 1) as const;
    
    let b = (60 * 60 * 1000) as const;
    
    // Works!
    
    let c = Math.random() < 0.5 ? (0 as const) : (1 as const);
    
    let d = 3_600_000 as const;

Another thing to keep in mind is that `const` contexts don‚Äôt immediately
convert an expression to be fully immutable.

    
    
    ts
    
    let arr = [1, 2, 3, 4];
    
    let foo = {
    
      name: "foo",
    
      contents: arr,
    
    } as const;
    
    foo.name = "bar"; // error!
    
    foo.contents = []; // error!
    
    foo.contents.push(5); // ...works!

For more details, you can [check out the respective pull
request](https://github.com/Microsoft/TypeScript/pull/29510).

## Type-checking for `globalThis`

TypeScript 3.4 introduces support for type-checking ECMAScript‚Äôs new
`globalThis` \- a global variable that, well, refers to the global scope.
Unlike the above solutions, `globalThis` provides a standard way for accessing
the global scope which can be used across different environments.

    
    
    ts
    
    // in a global file:
    
    var abc = 100;
    
    // Refers to 'abc' from above.
    
    globalThis.abc = 200;

Note that global variables declared with `let` and `const` don‚Äôt show up on
`globalThis`.

    
    
    ts
    
    let answer = 42;
    
    // error! Property 'answer' does not exist on 'typeof globalThis'.
    
    globalThis.answer = 333333;

It‚Äôs also important to note that TypeScript doesn‚Äôt transform references to
`globalThis` when compiling to older versions of ECMAScript. As such, unless
you‚Äôre targeting evergreen browsers (which already support `globalThis`), you
may want to [use an appropriate
polyfill](https://github.com/ljharb/globalThis) instead.

For more details on the implementation, see [the feature‚Äôs pull
request](https://github.com/Microsoft/TypeScript/pull/29332).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.4.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

MU![Masato Urai
\(1\)](https://gravatar.com/avatar/6b10b84436915f5e96900a8b1d2452d9?s=32&&d=blank)

MC![Max Coplan
\(1\)](https://gravatar.com/avatar/2145a04dd309caa59b2c170e03566076?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.5

## Speed improvements

TypeScript 3.5 introduces several optimizations around type-checking and
incremental builds.

### Type-checking speed-ups

TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-
checking more efficiently. These improvements are significantly more
pronounced in editor scenarios where type-checking drives operations like code
completion lists.

### `--incremental` improvements

TypeScript 3.5 improves on 3.4‚Äôs [`incremental`](/tsconfig#incremental) build
mode, by saving information about how the state of the world was calculated -
compiler settings, why files were looked up, where files were found, etc. In
scenarios involving hundreds of projects using TypeScript‚Äôs project references
in `--build` mode, [we‚Äôve found that the amount of time rebuilding can be
reduced by as much as 68% compared to TypeScript
3.4](https://github.com/Microsoft/TypeScript/pull/31101)!

For more details, you can see the pull requests to

  * [cache module resolution](https://github.com/Microsoft/TypeScript/pull/31100)
  * [cache settings calculated from `tsconfig.json`](https://github.com/Microsoft/TypeScript/pull/31101)

## The `Omit` helper type

TypeScript 3.5 introduces the new `Omit` helper type, which creates a new type
with some properties dropped from the original.

    
    
    ts
    
    type Person = {
    
      name: string;
    
      age: number;
    
      location: string;
    
    };
    
    type QuantumPerson = Omit<Person, "location">;
    
    // equivalent to
    
    type QuantumPerson = {
    
      name: string;
    
      age: number;
    
    };

Here we were able to copy over all the properties of `Person` except for
`location` using the `Omit` helper.

For more details, [see the pull request on GitHub to add
`Omit`](https://github.com/Microsoft/TypeScript/pull/30552), as well as [the
change to use `Omit` for object
rest](https://github.com/microsoft/TypeScript/pull/31134).

### Improved excess property checks in union types

In TypeScript 3.4 and earlier, certain excess properties were allowed in
situations where they really shouldn‚Äôt have been. For instance, TypeScript 3.4
permitted the incorrect `name` property in the object literal even though its
types don‚Äôt match between `Point` and `Label`.

    
    
    ts
    
    type Point = {
    
      x: number;
    
      y: number;
    
    };
    
    type Label = {
    
      name: string;
    
    };
    
    const thing: Point | Label = {
    
      x: 0,
    
      y: 0,
    
      name: true // uh-oh!
    
    };

Previously, a non-disciminated union wouldn‚Äôt have _any_ excess property
checking done on its members, and as a result, the incorrectly typed `name`
property slipped by.

In TypeScript 3.5, the type-checker at least verifies that all the provided
properties belong to _some_ union member and have the appropriate type,
meaning that the sample above correctly issues an error.

Note that partial overlap is still permitted as long as the property types are
valid.

    
    
    ts
    
    const pl: Point | Label = {
    
      x: 0,
    
      y: 0,
    
      name: "origin" // okay
    
    };

## The `--allowUmdGlobalAccess` flag

In TypeScript 3.5, you can now reference UMD global declarations like

    
    
    export as namespace foo;

from anywhere - even modules - using the new
[`allowUmdGlobalAccess`](/tsconfig#allowUmdGlobalAccess) flag.

This mode adds flexibility for mixing and matching the way 3rd party
libraries, where globals that libraries declare can always be consumed, even
from within modules.

For more details, [see the pull request on
GitHub](https://github.com/Microsoft/TypeScript/pull/30776/files).

## Smarter union type checking

In TypeScript 3.4 and prior, the following example would fail:

    
    
    ts
    
    type S = { done: boolean; value: number };
    
    type T = { done: false; value: number } | { done: true; value: number };
    
    declare let source: S;
    
    declare let target: T;
    
    target = source;

That‚Äôs because `S` isn‚Äôt assignable to `{ done: false, value: number }` nor `{
done: true, value: number }`. Why? Because the `done` property in `S` isn‚Äôt
specific enough - it‚Äôs `boolean` whereas each constituent of `T` has a `done`
property that‚Äôs specifically `true` or `false`. That‚Äôs what we meant by each
constituent type being checked in isolation: TypeScript doesn‚Äôt just union
each property together and see if `S` is assignable to that. If it did, some
bad code could get through like the following:

    
    
    ts
    
    interface Foo {
    
      kind: "foo";
    
      value: string;
    
    }
    
    interface Bar {
    
      kind: "bar";
    
      value: number;
    
    }
    
    function doSomething(x: Foo | Bar) {
    
      if (x.kind === "foo") {
    
        x.value.toLowerCase();
    
      }
    
    }
    
    // uh-oh - luckily TypeScript errors here!
    
    doSomething({
    
      kind: "foo",
    
      value: 123
    
    });

However, this was a bit overly strict for the original example. If you figure
out the precise type of any possible value of `S`, you can actually see that
it matches the types in `T` exactly.

In TypeScript 3.5, when assigning to types with discriminant properties like
in `T`, the language actually _will_ go further and decompose types like `S`
into a union of every possible inhabitant type. In this case, since `boolean`
is a union of `true` and `false`, `S` will be viewed as a union of `{ done:
false, value: number }` and `{ done: true, value: number }`.

For more details, you can [see the original pull request on
GitHub](https://github.com/microsoft/TypeScript/pull/30779).

## Higher order type inference from generic constructors

In TypeScript 3.4, we improved inference for when generic functions that
return functions like so:

    
    
    ts
    
    function compose<T, U, V>(f: (x: T) => U, g: (y: U) => V): (x: T) => V {
    
      return x => g(f(x));
    
    }

took other generic functions as arguments, like so:

    
    
    ts
    
    function arrayify<T>(x: T): T[] {
    
      return [x];
    
    }
    
    type Box<U> = { value: U };
    
    function boxify<U>(y: U): Box<U> {
    
      return { value: y };
    
    }
    
    let newFn = compose(arrayify, boxify);

Instead of a relatively useless type like `(x: {}) => Box<{}[]>`, which older
versions of the language would infer, TypeScript 3.4‚Äôs inference allows
`newFn` to be generic. Its new type is `<T>(x: T) => Box<T[]>`.

TypeScript 3.5 generalizes this behavior to work on constructor functions as
well.

    
    
    ts
    
    class Box<T> {
    
      kind: "box";
    
      value: T;
    
      constructor(value: T) {
    
        this.value = value;
    
      }
    
    }
    
    class Bag<U> {
    
      kind: "bag";
    
      value: U;
    
      constructor(value: U) {
    
        this.value = value;
    
      }
    
    }
    
    function composeCtor<T, U, V>(
    
      F: new (x: T) => U,
    
      G: new (y: U) => V
    
    ): (x: T) => V {
    
      return x => new G(new F(x));
    
    }
    
    let f = composeCtor(Box, Bag); // has type '<T>(x: T) => Bag<Box<T>>'
    
    let a = f(1024); // has type 'Bag<Box<number>>'

In addition to compositional patterns like the above, this new inference on
generic constructors means that functions that operate on class components in
certain UI libraries like React can more correctly operate on generic class
components.

    
    
    ts
    
    type ComponentClass<P> = new (props: P) => Component<P>;
    
    declare class Component<P> {
    
      props: P;
    
      constructor(props: P);
    
    }
    
    declare function myHoc<P>(C: ComponentClass<P>): ComponentClass<P>;
    
    type NestedProps<T> = { foo: number; stuff: T };
    
    declare class GenericComponent<T> extends Component<NestedProps<T>> {}
    
    // type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>'
    
    const GenericComponent2 = myHoc(GenericComponent);

To learn more, [check out the original pull request on
GitHub](https://github.com/microsoft/TypeScript/pull/31116).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.5.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

OT![Orta Therox
\(11\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.6

## Stricter Generators

TypeScript 3.6 introduces stricter checking for iterators and generator
functions. In earlier versions, users of generators had no way to
differentiate whether a value was yielded or returned from a generator.

    
    
    ts
    
    function* foo() {
    
      if (Math.random() < 0.5) yield 100;
    
      return "Finished!";
    
    }
    
    let iter = foo();
    
    let curr = iter.next();
    
    if (curr.done) {
    
      // TypeScript 3.5 and prior thought this was a 'string | number'.
    
      // It should know it's 'string' since 'done' was 'true'!
    
      curr.value;
    
    }

Additionally, generators just assumed the type of `yield` was always `any`.

    
    
    ts
    
    function* bar() {
    
      let x: { hello(): void } = yield;
    
      x.hello();
    
    }
    
    let iter = bar();
    
    iter.next();
    
    iter.next(123); // oops! runtime error!

In TypeScript 3.6, the checker now knows that the correct type for
`curr.value` should be `string` in our first example, and will correctly error
on our call to `next()` in our last example. This is thanks to some changes in
the `Iterator` and `IteratorResult` type declarations to include a few new
type parameters, and to a new type that TypeScript uses to represent
generators called the `Generator` type.

The `Iterator` type now allows users to specify the yielded type, the returned
type, and the type that `next` can accept.

    
    
    ts
    
    interface Iterator<T, TReturn = any, TNext = undefined> {
    
      // Takes either 0 or 1 arguments - doesn't accept 'undefined'
    
      next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    
      return?(value?: TReturn): IteratorResult<T, TReturn>;
    
      throw?(e?: any): IteratorResult<T, TReturn>;
    
    }

Building on that work, the new `Generator` type is an `Iterator` that always
has both the `return` and `throw` methods present, and is also iterable.

    
    
    ts
    
    interface Generator<T = unknown, TReturn = any, TNext = unknown>
    
      extends Iterator<T, TReturn, TNext> {
    
      next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    
      return(value: TReturn): IteratorResult<T, TReturn>;
    
      throw(e: any): IteratorResult<T, TReturn>;
    
      [Symbol.iterator](): Generator<T, TReturn, TNext>;
    
    }

To allow differentiation between returned values and yielded values,
TypeScript 3.6 converts the `IteratorResult` type to a discriminated union
type:

    
    
    ts
    
    type IteratorResult<T, TReturn = any> =
    
      | IteratorYieldResult<T>
    
      | IteratorReturnResult<TReturn>;
    
    interface IteratorYieldResult<TYield> {
    
      done?: false;
    
      value: TYield;
    
    }
    
    interface IteratorReturnResult<TReturn> {
    
      done: true;
    
      value: TReturn;
    
    }

In short, what this means is that you‚Äôll be able to appropriately narrow down
values from iterators when dealing with them directly.

To correctly represent the types that can be passed in to a generator from
calls to `next()`, TypeScript 3.6 also infers certain uses of `yield` within
the body of a generator function.

    
    
    ts
    
    function* foo() {
    
      let x: string = yield;
    
      console.log(x.toUpperCase());
    
    }
    
    let x = foo();
    
    x.next(); // first call to 'next' is always ignored
    
    x.next(42); // error! 'number' is not assignable to 'string'

If you‚Äôd prefer to be explicit, you can also enforce the type of values that
can be returned, yielded, and evaluated from `yield` expressions using an
explicit return type. Below, `next()` can only be called with `boolean`s, and
depending on the value of `done`, `value` is either a `string` or a `number`.

    
    
    ts
    
    /**
    
     * - yields numbers
    
     * - returns strings
    
     * - can be passed in booleans
    
     */
    
    function* counter(): Generator<number, string, boolean> {
    
      let i = 0;
    
      while (true) {
    
        if (yield i++) {
    
          break;
    
        }
    
      }
    
      return "done!";
    
    }
    
    var iter = counter();
    
    var curr = iter.next();
    
    while (!curr.done) {
    
      console.log(curr.value);
    
      curr = iter.next(curr.value === 5);
    
    }
    
    console.log(curr.value.toUpperCase());
    
    // prints:
    
    //
    
    // 0
    
    // 1
    
    // 2
    
    // 3
    
    // 4
    
    // 5
    
    // DONE!

For more details on the change, [see the pull request
here](https://github.com/Microsoft/TypeScript/issues/2983).

## More Accurate Array Spread

In pre-ES2015 targets, the most faithful emit for constructs like `for`/`of`
loops and array spreads can be a bit heavy. For this reason, TypeScript uses a
simpler emit by default that only supports array types, and supports iterating
on other types using the [`downlevelIteration`](/tsconfig#downlevelIteration)
flag. The looser default without
[`downlevelIteration`](/tsconfig#downlevelIteration) works fairly well;
however, there were some common cases where the transformation of array
spreads had observable differences. For example, the following array
containing a spread

    
    
    ts
    
    [...Array(5)];

can be rewritten as the following array literal

    
    
    js
    
    [undefined, undefined, undefined, undefined, undefined];

However, TypeScript would instead transform the original code into this code:

    
    
    ts
    
    Array(5).slice();

which is slightly different. `Array(5)` produces an array with a length of 5,
but with no defined property slots.

TypeScript 3.6 introduces a new `__spreadArrays` helper to accurately model
what happens in ECMAScript 2015 in older targets outside of
[`downlevelIteration`](/tsconfig#downlevelIteration). `__spreadArrays` is also
available in [tslib](https://github.com/Microsoft/tslib/).

For more information, [see the relevant pull
request](https://github.com/microsoft/TypeScript/pull/31166).

## Improved UX Around Promises

TypeScript 3.6 introduces some improvements for when `Promise`s are mis-
handled.

For example, it‚Äôs often very common to forget to `.then()` or `await` the
contents of a `Promise` before passing it to another function. TypeScript‚Äôs
error messages are now specialized, and inform the user that perhaps they
should consider using the `await` keyword.

    
    
    ts
    
    interface User {
    
      name: string;
    
      age: number;
    
      location: string;
    
    }
    
    declare function getUserData(): Promise<User>;
    
    declare function displayUser(user: User): void;
    
    async function f() {
    
      displayUser(getUserData());
    
      //              ~~~~~~~~~~~~~
    
      // Argument of type 'Promise<User>' is not assignable to parameter of type 'User'.
    
      //   ...
    
      // Did you forget to use 'await'?
    
    }

It‚Äôs also common to try to access a method before `await`-ing or `.then()`-ing
a `Promise`. This is another example, among many others, where we‚Äôre able to
do better.

    
    
    ts
    
    async function getCuteAnimals() {
    
      fetch("https://reddit.com/r/aww.json").json();
    
      //   ~~~~
    
      // Property 'json' does not exist on type 'Promise<Response>'.
    
      //
    
      // Did you forget to use 'await'?
    
    }

For more details, [see the originating
issue](https://github.com/microsoft/TypeScript/issues/30646), as well as the
pull requests that link back to it.

## Better Unicode Support for Identifiers

TypeScript 3.6 contains better support for Unicode characters in identifiers
when emitting to ES2015 and later targets.

    
    
    ts
    
    const ùì±ùìÆùìµùìµùì∏ = "world"; // previously disallowed, now allowed in '--target es2015'

## `import.meta` Support in SystemJS

TypeScript 3.6 supports transforming `import.meta` to `context.meta` when your
`module` target is set to `system`.

    
    
    ts
    
    // This module:
    
    console.log(import.meta.url);
    
    // gets turned into the following:
    
    System.register([], function (exports, context) {
    
      return {
    
        setters: [],
    
        execute: function () {
    
          console.log(context.meta.url);
    
        },
    
      };
    
    });

## `get` and `set` Accessors Are Allowed in Ambient Contexts

In previous versions of TypeScript, the language didn‚Äôt allow `get` and `set`
accessors in ambient contexts (like in `declare`-d classes, or in `.d.ts`
files in general). The rationale was that accessors weren‚Äôt distinct from
properties as far as writing and reading to these properties; however,
[because ECMAScript‚Äôs class fields proposal may have differing behavior from
in existing versions of TypeScript](https://github.com/tc39/proposal-class-
fields/issues/248), we realized we needed a way to communicate this different
behavior to provide appropriate errors in subclasses.

As a result, users can write getters and setters in ambient contexts in
TypeScript 3.6.

    
    
    ts
    
    declare class Foo {
    
      // Allowed in 3.6+.
    
      get x(): number;
    
      set x(val: number);
    
    }

In TypeScript 3.7, the compiler itself will take advantage of this feature so
that generated `.d.ts` files will also emit `get`/`set` accessors.

## Ambient Classes and Functions Can Merge

In previous versions of TypeScript, it was an error to merge classes and
functions under any circumstances. Now, ambient classes and functions
(classes/functions with the `declare` modifier, or in `.d.ts` files) can
merge. This means that now you can write the following:

    
    
    ts
    
    export declare function Point2D(x: number, y: number): Point2D;
    
    export declare class Point2D {
    
      x: number;
    
      y: number;
    
      constructor(x: number, y: number);
    
    }

instead of needing to use

    
    
    ts
    
    export interface Point2D {
    
      x: number;
    
      y: number;
    
    }
    
    export declare var Point2D: {
    
      (x: number, y: number): Point2D;
    
      new (x: number, y: number): Point2D;
    
    };

One advantage of this is that the callable constructor pattern can be easily
expressed while also allowing namespaces to merge with these declarations
(since `var` declarations can‚Äôt merge with `namespace`s).

In TypeScript 3.7, the compiler will take advantage of this feature so that
`.d.ts` files generated from `.js` files can appropriately capture both the
callability and constructability of a class-like function.

For more details, [see the original PR on
GitHub](https://github.com/microsoft/TypeScript/pull/32584).

## APIs to Support `--build` and `--incremental`

TypeScript 3.0 introduced support for referencing other projects and building
them incrementally using the `--build` flag. Additionally, TypeScript 3.4
introduced the [`incremental`](/tsconfig#incremental) flag for saving
information about previous compilations to only rebuild certain files. These
flags were incredibly useful for structuring projects more flexibly and
speeding builds up. Unfortunately, using these flags didn‚Äôt work with 3rd
party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets
of APIs to operate on project references and incremental program building.

For creating [`incremental`](/tsconfig#incremental) builds, users can leverage
the `createIncrementalProgram` and `createIncrementalCompilerHost` APIs. Users
can also re-hydrate old program instances from `.tsbuildinfo` files generated
by this API using the newly exposed `readBuilderProgram` function, which is
only meant to be used as for creating new programs (i.e. you can‚Äôt modify the
returned instance - it‚Äôs only meant to be used for the `oldProgram` parameter
in other `create*Program` functions).

For leveraging project references, a new `createSolutionBuilder` function has
been exposed, which returns an instance of the new type `SolutionBuilder`.

For more details on these APIs, you can [see the original pull
request](https://github.com/microsoft/TypeScript/pull/31432).

## Semicolon-Aware Code Edits

Editors like Visual Studio and Visual Studio Code can automatically apply
quick fixes, refactorings, and other transformations like automatically
importing values from other modules. These transformations are powered by
TypeScript, and older versions of TypeScript unconditionally added semicolons
to the end of every statement; unfortunately, this disagreed with many users‚Äô
style guidelines, and many users were displeased with the editor inserting
semicolons.

TypeScript is now smart enough to detect whether your file uses semicolons
when applying these sorts of edits. If your file generally lacks semicolons,
TypeScript won‚Äôt add one.

For more details, [see the corresponding pull
request](https://github.com/microsoft/TypeScript/pull/31801).

## Smarter Auto-Import Syntax

JavaScript has a lot of different module syntaxes or conventions: the one in
the ECMAScript standard, the one Node already supports (CommonJS), AMD,
System.js, and more! For the most part, TypeScript would default to auto-
importing using ECMAScript module syntax, which was often inappropriate in
certain TypeScript projects with different compiler settings, or in Node
projects with plain JavaScript and `require` calls.

TypeScript 3.6 is now a bit smarter about looking at your existing imports
before deciding on how to auto-import other modules. You can [see more details
in the original pull request
here](https://github.com/microsoft/TypeScript/pull/32684).

## New TypeScript Playground

The TypeScript playground has received a much-needed refresh with handy new
functionality! The new playground is largely a fork of [Artem
Tyurin](https://github.com/agentcooper)‚Äôs [TypeScript
playground](https://github.com/agentcooper/typescript-play) which community
members have been using more and more. We owe Artem a big thanks for helping
out here!

The new playground now supports many new options including:

  * The [`target`](/tsconfig#target) option (allowing users to switch out of `es5` to `es3`, `es2015`, `esnext`, etc.)
  * All the strictness flags (including just [`strict`](/tsconfig#strict))
  * Support for plain JavaScript files (using `allowJS` and optionally [`checkJs`](/tsconfig#checkJs))

These options also persist when sharing links to playground samples, allowing
users to more reliably share examples without having to tell the recipient
‚Äúoh, don‚Äôt forget to turn on the [`noImplicitAny`](/tsconfig#noImplicitAny)
option!‚Äú.

In the near future, we‚Äôre going to be refreshing the playground samples,
adding JSX support, and polishing automatic type acquisition, meaning that
you‚Äôll be able to see the same experience on the playground as you‚Äôd get in
your personal editor.

As we improve the playground and the website, [we welcome feedback and pull
requests on GitHub](https://github.com/microsoft/TypeScript-Website/)!

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.6.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

EL![Eliran Levi
\(1\)](https://gravatar.com/avatar/8a81d3dd6957e01e288d05ebdd66466d?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

JRU![John Ralph Umandal
\(1\)](https://gravatar.com/avatar/74d1b762883897d4c0ad32b9dcb3adf7?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.7

## Optional Chaining

[Playground](/play/#example/optional-chaining)

Optional chaining is [issue
#16](https://github.com/microsoft/TypeScript/issues/16) on our issue tracker.
For context, there have been over 23,000 issues on the TypeScript issue
tracker since then.

At its core, optional chaining lets us write code where TypeScript can
immediately stop running some expressions if we run into a `null` or
`undefined`. The star of the show in optional chaining is the new `?.`
operator for _optional property accesses_. When we write code like

    
    
    ts
    
    let x = foo?.bar.baz();

this is a way of saying that when `foo` is defined, `foo.bar.baz()` will be
computed; but when `foo` is `null` or `undefined`, stop what we‚Äôre doing and
just return `undefined`.‚Äù

More plainly, that code snippet is the same as writing the following.

    
    
    ts
    
    let x = foo === null || foo === undefined ? undefined : foo.bar.baz();

Note that if `bar` is `null` or `undefined`, our code will still hit an error
accessing `baz`. Likewise, if `baz` is `null` or `undefined`, we‚Äôll hit an
error at the call site. `?.` only checks for whether the value on the _left_
of it is `null` or `undefined` \- not any of the subsequent properties.

You might find yourself using `?.` to replace a lot of code that performs
repetitive nullish checks using the `&&` operator.

    
    
    ts
    
    // Before
    
    if (foo && foo.bar && foo.bar.baz) {
    
      // ...
    
    }
    
    // After-ish
    
    if (foo?.bar?.baz) {
    
      // ...
    
    }

Keep in mind that `?.` acts differently than those `&&` operations since `&&`
will act specially on ‚Äúfalsy‚Äù values (e.g. the empty string, `0`, `NaN`, and,
well, `false`), but this is an intentional feature of the construct. It
doesn‚Äôt short-circuit on valid data like `0` or empty strings.

Optional chaining also includes two other operations. First there‚Äôs the
_optional element access_ which acts similarly to optional property accesses,
but allows us to access non-identifier properties (e.g. arbitrary strings,
numbers, and symbols):

    
    
    ts
    
    /**
    
     * Get the first element of the array if we have an array.
    
     * Otherwise return undefined.
    
     */
    
    function tryGetFirstElement<T>(arr?: T[]) {
    
      return arr?.[0];
    
      // equivalent to
    
      //   return (arr === null || arr === undefined) ?
    
      //       undefined :
    
      //       arr[0];
    
    }

There‚Äôs also _optional call_ , which allows us to conditionally call
expressions if they‚Äôre not `null` or `undefined`.

    
    
    ts
    
    async function makeRequest(url: string, log?: (msg: string) => void) {
    
      log?.(`Request started at ${new Date().toISOString()}`);
    
      // roughly equivalent to
    
      //   if (log != null) {
    
      //       log(`Request started at ${new Date().toISOString()}`);
    
      //   }
    
      const result = (await fetch(url)).json();
    
      log?.(`Request finished at ${new Date().toISOString()}`);
    
      return result;
    
    }

The ‚Äúshort-circuiting‚Äù behavior that optional chains have is limited property
accesses, calls, element accesses - it doesn‚Äôt expand any further out from
these expressions. In other words,

    
    
    ts
    
    let result = foo?.bar / someComputation();

doesn‚Äôt stop the division or `someComputation()` call from occurring. It‚Äôs
equivalent to

    
    
    ts
    
    let temp = foo === null || foo === undefined ? undefined : foo.bar;
    
    let result = temp / someComputation();

That might result in dividing `undefined`, which is why in
[`strictNullChecks`](/tsconfig#strictNullChecks), the following is an error.

    
    
    ts
    
    function barPercentage(foo?: { bar: number }) {
    
      return foo?.bar / 100;
    
      //     ~~~~~~~~
    
      // Error: Object is possibly undefined.
    
    }

More more details, you can [read up on the
proposal](https://github.com/tc39/proposal-optional-chaining/) and [view the
original pull request](https://github.com/microsoft/TypeScript/pull/33294).

## Nullish Coalescing

[Playground](/play/#example/nullish-coalescing)

The _nullish coalescing operator_ is another upcoming ECMAScript feature that
goes hand-in-hand with optional chaining, and which our team has been involved
with championing in TC39.

You can think of this feature - the `??` operator - as a way to ‚Äúfall back‚Äù to
a default value when dealing with `null` or `undefined`. When we write code
like

    
    
    ts
    
    let x = foo ?? bar();

this is a new way to say that the value `foo` will be used when it‚Äôs
‚Äúpresent‚Äù; but when it‚Äôs `null` or `undefined`, calculate `bar()` in its
place.

Again, the above code is equivalent to the following.

    
    
    ts
    
    let x = foo !== null && foo !== undefined ? foo : bar();

The `??` operator can replace uses of `||` when trying to use a default value.
For example, the following code snippet tries to fetch the volume that was
last saved in
[`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage)
(if it ever was); however, it has a bug because it uses `||`.

    
    
    ts
    
    function initializeAudio() {
    
      let volume = localStorage.volume || 0.5;
    
      // ...
    
    }

When `localStorage.volume` is set to `0`, the page will set the volume to
`0.5` which is unintended. `??` avoids some unintended behavior from `0`,
`NaN` and `""` being treated as falsy values.

We owe a large thanks to community members [Wenlu
Wang](https://github.com/Kingwl) and [Titian Cernicova
Dragomir](https://github.com/dragomirtitian) for implementing this feature!
For more details, [check out their pull
request](https://github.com/microsoft/TypeScript/pull/32883) and [the nullish
coalescing proposal repository](https://github.com/tc39/proposal-nullish-
coalescing/).

## Assertion Functions

[Playground](/play/#example/assertion-functions)

There‚Äôs a specific set of functions that `throw` an error if something
unexpected happened. They‚Äôre called ‚Äúassertion‚Äù functions. As an example,
Node.js has a dedicated function for this called `assert`.

    
    
    js
    
    assert(someValue === 42);

In this example if `someValue` isn‚Äôt equal to `42`, then `assert` will throw
an `AssertionError`.

Assertions in JavaScript are often used to guard against improper types being
passed in. For example,

    
    
    js
    
    function multiply(x, y) {
    
      assert(typeof x === "number");
    
      assert(typeof y === "number");
    
      return x * y;
    
    }

Unfortunately in TypeScript these checks could never be properly encoded. For
loosely-typed code this meant TypeScript was checking less, and for slightly
conservative code it often forced users to use type assertions.

    
    
    ts
    
    function yell(str) {
    
      assert(typeof str === "string");
    
      return str.toUppercase();
    
      // Oops! We misspelled 'toUpperCase'.
    
      // Would be great if TypeScript still caught this!
    
    }

The alternative was to instead rewrite the code so that the language could
analyze it, but this isn‚Äôt convenient.

    
    
    ts
    
    function yell(str) {
    
      if (typeof str !== "string") {
    
        throw new TypeError("str should have been a string.");
    
      }
    
      // Error caught!
    
      return str.toUppercase();
    
    }

Ultimately the goal of TypeScript is to type existing JavaScript constructs in
the least disruptive way. For that reason, TypeScript 3.7 introduces a new
concept called ‚Äúassertion signatures‚Äù which model these assertion functions.

The first type of assertion signature models the way that Node‚Äôs `assert`
function works. It ensures that whatever condition is being checked must be
true for the remainder of the containing scope.

    
    
    ts
    
    function assert(condition: any, msg?: string): asserts condition {
    
      if (!condition) {
    
        throw new AssertionError(msg);
    
      }
    
    }

`asserts condition` says that whatever gets passed into the `condition`
parameter must be true if the `assert` returns (because otherwise it would
throw an error). That means that for the rest of the scope, that condition
must be truthy. As an example, using this assertion function means we _do_
catch our original `yell` example.

    
    
    ts
    
    function yell(str) {
    
      assert(typeof str === "string");
    
      return str.toUppercase();
    
      //         ~~~~~~~~~~~
    
      // error: Property 'toUppercase' does not exist on type 'string'.
    
      //        Did you mean 'toUpperCase'?
    
    }
    
    function assert(condition: any, msg?: string): asserts condition {
    
      if (!condition) {
    
        throw new AssertionError(msg);
    
      }
    
    }

The other type of assertion signature doesn‚Äôt check for a condition, but
instead tells TypeScript that a specific variable or property has a different
type.

    
    
    ts
    
    function assertIsString(val: any): asserts val is string {
    
      if (typeof val !== "string") {
    
        throw new AssertionError("Not a string!");
    
      }
    
    }

Here `asserts val is string` ensures that after any call to `assertIsString`,
any variable passed in will be known to be a `string`.

    
    
    ts
    
    function yell(str: any) {
    
      assertIsString(str);
    
      // Now TypeScript knows that 'str' is a 'string'.
    
      return str.toUppercase();
    
      //         ~~~~~~~~~~~
    
      // error: Property 'toUppercase' does not exist on type 'string'.
    
      //        Did you mean 'toUpperCase'?
    
    }

These assertion signatures are very similar to writing type predicate
signatures:

    
    
    ts
    
    function isString(val: any): val is string {
    
      return typeof val === "string";
    
    }
    
    function yell(str: any) {
    
      if (isString(str)) {
    
        return str.toUppercase();
    
      }
    
      throw "Oops!";
    
    }

And just like type predicate signatures, these assertion signatures are
incredibly expressive. We can express some fairly sophisticated ideas with
these.

    
    
    ts
    
    function assertIsDefined<T>(val: T): asserts val is NonNullable<T> {
    
      if (val === undefined || val === null) {
    
        throw new AssertionError(
    
          `Expected 'val' to be defined, but received ${val}`
    
        );
    
      }
    
    }

To read up more about assertion signatures, [check out the original pull
request](https://github.com/microsoft/TypeScript/pull/32695).

## Better Support for `never`-Returning Functions

As part of the work for assertion signatures, TypeScript needed to encode more
about where and which functions were being called. This gave us the
opportunity to expand support for another class of functions: functions that
return `never`.

The intent of any function that returns `never` is that it never returns. It
indicates that an exception was thrown, a halting error condition occurred, or
that the program exited. For example, [`process.exit(...)` in
`@types/node`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874)
is specified to return `never`.

In order to ensure that a function never potentially returned `undefined` or
effectively returned from all code paths, TypeScript needed some syntactic
signal - either a `return` or `throw` at the end of a function. So users found
themselves `return`-ing their failure functions.

    
    
    ts
    
    function dispatch(x: string | number): SomeType {
    
      if (typeof x === "string") {
    
        return doThingWithString(x);
    
      } else if (typeof x === "number") {
    
        return doThingWithNumber(x);
    
      }
    
      return process.exit(1);
    
    }

Now when these `never`-returning functions are called, TypeScript recognizes
that they affect the control flow graph and accounts for them.

    
    
    ts
    
    function dispatch(x: string | number): SomeType {
    
      if (typeof x === "string") {
    
        return doThingWithString(x);
    
      } else if (typeof x === "number") {
    
        return doThingWithNumber(x);
    
      }
    
      process.exit(1);
    
    }

As with assertion functions, you can [read up more at the same pull
request](https://github.com/microsoft/TypeScript/pull/32695).

## (More) Recursive Type Aliases

[Playground](/play/#example/recursive-type-references)

Type aliases have always had a limitation in how they could be ‚Äúrecursively‚Äù
referenced. The reason is that any use of a type alias needs to be able to
substitute itself with whatever it aliases. In some cases, that‚Äôs not
possible, so the compiler rejects certain recursive aliases like the
following:

    
    
    ts
    
    type Foo = Foo;

This is a reasonable restriction because any use of `Foo` would need to be
replaced with `Foo` which would need to be replaced with `Foo` which would
need to be replaced with `Foo` which‚Ä¶ well, hopefully you get the idea! In the
end, there isn‚Äôt a type that makes sense in place of `Foo`.

This is fairly [consistent with how other languages treat type
aliases](https://wikipedia.org/w/index.php?title=Recursive_data_type&oldid=913091335#in_type_synonyms),
but it does give rise to some slightly surprising scenarios for how users
leverage the feature. For example, in TypeScript 3.6 and prior, the following
causes an error.

    
    
    ts
    
    type ValueOrArray<T> = T | Array<ValueOrArray<T>>;
    
    //   ~~~~~~~~~~~~
    
    // error: Type alias 'ValueOrArray' circularly references itself.

This is strange because there is technically nothing wrong with any use users
could always write what was effectively the same code by introducing an
interface.

    
    
    ts
    
    type ValueOrArray<T> = T | ArrayOfValueOrArray<T>;
    
    interface ArrayOfValueOrArray<T> extends Array<ValueOrArray<T>> {}

Because interfaces (and other object types) introduce a level of indirection
and their full structure doesn‚Äôt need to be eagerly built out, TypeScript has
no problem working with this structure.

But workaround of introducing the interface wasn‚Äôt intuitive for users. And in
principle there really wasn‚Äôt anything wrong with the original version of
`ValueOrArray` that used `Array` directly. If the compiler was a little bit
‚Äúlazier‚Äù and only calculated the type arguments to `Array` when necessary,
then TypeScript could express these correctly.

That‚Äôs exactly what TypeScript 3.7 introduces. At the ‚Äútop level‚Äù of a type
alias, TypeScript will defer resolving type arguments to permit these
patterns.

This means that code like the following that was trying to represent JSON‚Ä¶

    
    
    ts
    
    type Json = string | number | boolean | null | JsonObject | JsonArray;
    
    interface JsonObject {
    
      [property: string]: Json;
    
    }
    
    interface JsonArray extends Array<Json> {}

can finally be rewritten without helper interfaces.

    
    
    ts
    
    type Json =
    
      | string
    
      | number
    
      | boolean
    
      | null
    
      | { [property: string]: Json }
    
      | Json[];

This new relaxation also lets us recursively reference type aliases in tuples
as well. The following code which used to error is now valid TypeScript code.

    
    
    ts
    
    type VirtualNode = string | [string, { [key: string]: any }, ...VirtualNode[]];
    
    const myNode: VirtualNode = [
    
      "div",
    
      { id: "parent" },
    
      ["div", { id: "first-child" }, "I'm the first child"],
    
      ["div", { id: "second-child" }, "I'm the second child"],
    
    ];

For more information, you can [read up on the original pull
request](https://github.com/microsoft/TypeScript/pull/33050).

## `--declaration` and `--allowJs`

The [`declaration`](/tsconfig#declaration) flag in TypeScript allows us to
generate `.d.ts` files (declaration files) from TypeScript source files (i.e.
`.ts` and `.tsx` files). These `.d.ts` files are important for a couple of
reasons.

First of all, they‚Äôre important because they allow TypeScript to type-check
against other projects without re-checking the original source code. They‚Äôre
also important because they allow TypeScript to interoperate with existing
JavaScript libraries that weren‚Äôt built with TypeScript in mind. Finally, a
benefit that is often underappreciated: both TypeScript _and_ JavaScript users
can benefit from these files when using editors powered by TypeScript to get
things like better auto-completion.

Unfortunately, [`declaration`](/tsconfig#declaration) didn‚Äôt work with the
[`allowJs`](/tsconfig#allowJs) flag which allows mixing TypeScript and
JavaScript input files. This was a frustrating limitation because it meant
users couldn‚Äôt use the [`declaration`](/tsconfig#declaration) flag when
migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes
that, and allows the two options to be used together!

The most impactful outcome of this feature might a bit subtle: with TypeScript
3.7, users can write libraries in JSDoc annotated JavaScript and support
TypeScript users.

The way that this works is that when using [`allowJs`](/tsconfig#allowJs),
TypeScript has some best-effort analyses to understand common JavaScript
patterns; however, the way that some patterns are expressed in JavaScript
don‚Äôt necessarily look like their equivalents in TypeScript. When
[`declaration`](/tsconfig#declaration) emit is turned on, TypeScript figures
out the best way to transform JSDoc comments and CommonJS exports into valid
type declarations and the like in the output `.d.ts` files.

As an example, the following code snippet

    
    
    js
    
    const assert = require("assert");
    
    module.exports.blurImage = blurImage;
    
    /**
    
     * Produces a blurred image from an input buffer.
    
     *
    
     * @param input {Uint8Array}
    
     * @param width {number}
    
     * @param height {number}
    
     */
    
    function blurImage(input, width, height) {
    
      const numPixels = width * height * 4;
    
      assert(input.length === numPixels);
    
      const result = new Uint8Array(numPixels);
    
      // TODO
    
      return result;
    
    }

Will produce a `.d.ts` file like

    
    
    ts
    
    /**
    
     * Produces a blurred image from an input buffer.
    
     *
    
     * @param input {Uint8Array}
    
     * @param width {number}
    
     * @param height {number}
    
     */
    
    export function blurImage(
    
      input: Uint8Array,
    
      width: number,
    
      height: number
    
    ): Uint8Array;

This can go beyond basic functions with `@param` tags too, where the following
example:

    
    
    js
    
    /**
    
     * @callback Job
    
     * @returns {void}
    
     */
    
    /** Queues work */
    
    export class Worker {
    
      constructor(maxDepth = 10) {
    
        this.started = false;
    
        this.depthLimit = maxDepth;
    
        /**
    
         * NOTE: queued jobs may add more items to queue
    
         * @type {Job[]}
    
         */
    
        this.queue = [];
    
      }
    
      /**
    
       * Adds a work item to the queue
    
       * @param {Job} work
    
       */
    
      push(work) {
    
        if (this.queue.length + 1 > this.depthLimit) throw new Error("Queue full!");
    
        this.queue.push(work);
    
      }
    
      /**
    
       * Starts the queue if it has not yet started
    
       */
    
      start() {
    
        if (this.started) return false;
    
        this.started = true;
    
        while (this.queue.length) {
    
          /** @type {Job} */ (this.queue.shift())();
    
        }
    
        return true;
    
      }
    
    }

will be transformed into the following `.d.ts` file:

    
    
    ts
    
    /**
    
     * @callback Job
    
     * @returns {void}
    
     */
    
    /** Queues work */
    
    export class Worker {
    
      constructor(maxDepth?: number);
    
      started: boolean;
    
      depthLimit: number;
    
      /**
    
       * NOTE: queued jobs may add more items to queue
    
       * @type {Job[]}
    
       */
    
      queue: Job[];
    
      /**
    
       * Adds a work item to the queue
    
       * @param {Job} work
    
       */
    
      push(work: Job): void;
    
      /**
    
       * Starts the queue if it has not yet started
    
       */
    
      start(): boolean;
    
    }
    
    export type Job = () => void;

Note that when using these flags together, TypeScript doesn‚Äôt necessarily have
to downlevel `.js` files. If you simply want TypeScript to create `.d.ts`
files, you can use the [`emitDeclarationOnly`](/tsconfig#emitDeclarationOnly)
compiler option.

For more details, you can [check out the original pull
request](https://github.com/microsoft/TypeScript/pull/32372).

## The `useDefineForClassFields` Flag and The `declare` Property Modifier

Back when TypeScript implemented public class fields, we assumed to the best
of our abilities that the following code

    
    
    ts
    
    class C {
    
      foo = 100;
    
      bar: string;
    
    }

would be equivalent to a similar assignment within a constructor body.

    
    
    ts
    
    class C {
    
      constructor() {
    
        this.foo = 100;
    
      }
    
    }

Unfortunately, while this seemed to be the direction that the proposal moved
towards in its earlier days, there is an extremely strong chance that public
class fields will be standardized differently. Instead, the original code
sample might need to de-sugar to something closer to the following:

    
    
    ts
    
    class C {
    
      constructor() {
    
        Object.defineProperty(this, "foo", {
    
          enumerable: true,
    
          configurable: true,
    
          writable: true,
    
          value: 100,
    
        });
    
        Object.defineProperty(this, "bar", {
    
          enumerable: true,
    
          configurable: true,
    
          writable: true,
    
          value: void 0,
    
        });
    
      }
    
    }

While TypeScript 3.7 isn‚Äôt changing any existing emit by default, we‚Äôve been
rolling out changes incrementally to help users mitigate potential future
breakage. We‚Äôve provided a new flag called
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields) to enable this
emit mode with some new checking logic.

The two biggest changes are the following:

  * Declarations are initialized with `Object.defineProperty`.
  * Declarations are _always_ initialized to `undefined`, even if they have no initializer.

This can cause quite a bit of fallout for existing code that use inheritance.
First of all, `set` accessors from base classes won‚Äôt get triggered - they‚Äôll
be completely overwritten.

    
    
    ts
    
    class Base {
    
      set data(value: string) {
    
        console.log("data changed to " + value);
    
      }
    
    }
    
    class Derived extends Base {
    
      // No longer triggers a 'console.log'
    
      // when using 'useDefineForClassFields'.
    
      data = 10;
    
    }

Secondly, using class fields to specialize properties from base classes also
won‚Äôt work.

    
    
    ts
    
    interface Animal {
    
      animalStuff: any;
    
    }
    
    interface Dog extends Animal {
    
      dogStuff: any;
    
    }
    
    class AnimalHouse {
    
      resident: Animal;
    
      constructor(animal: Animal) {
    
        this.resident = animal;
    
      }
    
    }
    
    class DogHouse extends AnimalHouse {
    
      // Initializes 'resident' to 'undefined'
    
      // after the call to 'super()' when
    
      // using 'useDefineForClassFields'!
    
      resident: Dog;
    
      constructor(dog: Dog) {
    
        super(dog);
    
      }
    
    }

What these two boil down to is that mixing properties with accessors is going
to cause issues, and so will re-declaring properties with no initializers.

To detect the issue around accessors, TypeScript 3.7 will now emit `get`/`set`
accessors in `.d.ts` files so that in TypeScript can check for overridden
accessors.

Code that‚Äôs impacted by the class fields change can get around the issue by
converting field initializers to assignments in constructor bodies.

    
    
    ts
    
    class Base {
    
      set data(value: string) {
    
        console.log("data changed to " + value);
    
      }
    
    }
    
    class Derived extends Base {
    
      constructor() {
    
        this.data = 10;
    
      }
    
    }

To help mitigate the second issue, you can either add an explicit initializer
or add a `declare` modifier to indicate that a property should have no emit.

    
    
    ts
    
    interface Animal {
    
      animalStuff: any;
    
    }
    
    interface Dog extends Animal {
    
      dogStuff: any;
    
    }
    
    class AnimalHouse {
    
      resident: Animal;
    
      constructor(animal: Animal) {
    
        this.resident = animal;
    
      }
    
    }
    
    class DogHouse extends AnimalHouse {
    
      declare resident: Dog;
    
      //  ^^^^^^^
    
      // 'resident' now has a 'declare' modifier,
    
      // and won't produce any output code.
    
      constructor(dog: Dog) {
    
        super(dog);
    
      }
    
    }

Currently [`useDefineForClassFields`](/tsconfig#useDefineForClassFields) is
only available when targeting ES5 and upwards, since `Object.defineProperty`
doesn‚Äôt exist in ES3. To achieve similar checking for issues, you can create a
separate project that targets ES5 and uses [`noEmit`](/tsconfig#noEmit) to
avoid a full build.

For more information, you can [take a look at the original pull request for
these changes](https://github.com/microsoft/TypeScript/pull/33509).

We strongly encourage users to try the
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields) flag and report
back on our issue tracker or in the comments below. This includes feedback on
difficulty of adopting the flag so we can understand how we can make migration
easier.

## Build-Free Editing with Project References

TypeScript‚Äôs project references provide us with an easy way to break codebases
up to give us faster compiles. Unfortunately, editing a project whose
dependencies hadn‚Äôt been built (or whose output was out of date) meant that
the editing experience wouldn‚Äôt work well.

In TypeScript 3.7, when opening a project with dependencies, TypeScript will
automatically use the source `.ts`/`.tsx` files instead. This means projects
using project references will now see an improved editing experience where
semantic operations are up-to-date and ‚Äújust work‚Äù. You can disable this
behavior with the compiler option
[`disableSourceOfProjectReferenceRedirect`](/tsconfig#disableSourceOfProjectReferenceRedirect)
which may be appropriate when working in very large projects where this change
may impact editing performance.

You can [read up more about this change by reading up on its pull
request](https://github.com/microsoft/TypeScript/pull/32028).

## Uncalled Function Checks

A common and dangerous error is to forget to invoke a function, especially if
the function has zero arguments or is named in a way that implies it might be
a property rather than a function.

    
    
    ts
    
    interface User {
    
      isAdministrator(): boolean;
    
      notify(): void;
    
      doNotDisturb?(): boolean;
    
    }
    
    // later...
    
    // Broken code, do not use!
    
    function doAdminThing(user: User) {
    
      // oops!
    
      if (user.isAdministrator) {
    
        sudo();
    
        editTheConfiguration();
    
      } else {
    
        throw new AccessDeniedError("User is not an admin");
    
      }
    
    }

Here, we forgot to call `isAdministrator`, and the code incorrectly allows
non-administrator users to edit the configuration!

In TypeScript 3.7, this is identified as a likely error:

    
    
    ts
    
    function doAdminThing(user: User) {
    
        if (user.isAdministrator) {
    
        //  ~~~~~~~~~~~~~~~~~~~~
    
        // error! This condition will always return true since the function is always defined.
    
        //        Did you mean to call it instead?

This check is a breaking change, but for that reason the checks are very
conservative. This error is only issued in `if` conditions, and it is not
issued on optional properties, if
[`strictNullChecks`](/tsconfig#strictNullChecks) is off, or if the function is
later called within the body of the `if`:

    
    
    ts
    
    interface User {
    
      isAdministrator(): boolean;
    
      notify(): void;
    
      doNotDisturb?(): boolean;
    
    }
    
    function issueNotification(user: User) {
    
      if (user.doNotDisturb) {
    
        // OK, property is optional
    
      }
    
      if (user.notify) {
    
        // OK, called the function
    
        user.notify();
    
      }
    
    }

If you intended to test the function without calling it, you can correct the
definition of it to include `undefined`/`null`, or use `!!` to write something
like `if (!!user.isAdministrator)` to indicate that the coercion is
intentional.

We owe a big thanks to GitHub user [@jwbay](https://github.com/jwbay) who took
the initiative to create a [proof-of-
concept](https://github.com/microsoft/TypeScript/pull/32802) and iterated to
provide us with [the current
version](https://github.com/microsoft/TypeScript/pull/33178).

## `// @ts-nocheck` in TypeScript Files

TypeScript 3.7 allows us to add `// @ts-nocheck` comments to the top of
TypeScript files to disable semantic checks. Historically this comment was
only respected in JavaScript source files in the presence of
[`checkJs`](/tsconfig#checkJs), but we‚Äôve expanded support to TypeScript files
to make migrations easier for all users.

## Semicolon Formatter Option

TypeScript‚Äôs built-in formatter now supports semicolon insertion and removal
at locations where a trailing semicolon is optional due to JavaScript‚Äôs
automatic semicolon insertion (ASI) rules. The setting is available now in
[Visual Studio Code Insiders](https://code.visualstudio.com/insiders/), and
will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.

![New semicolon formatter option in VS Code](https://user-
images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png)

Choosing a value of ‚Äúinsert‚Äù or ‚Äúremove‚Äù also affects the format of auto-
imports, extracted types, and other generated code provided by TypeScript
services. Leaving the setting on its default value of ‚Äúignore‚Äù makes generated
code match the semicolon preference detected in the current file.

## 3.7 Breaking Changes

### DOM Changes

[Types in `lib.dom.d.ts` have been
updated](https://github.com/microsoft/TypeScript/pull/33627). These changes
are largely correctness changes related to nullability, but impact will
ultimately depend on your codebase.

### Class Field Mitigations

As mentioned above, TypeScript 3.7 emits `get`/`set` accessors in `.d.ts`
files which can cause breaking changes for consumers on older versions of
TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted,
since that version was future-proofed for this feature.

While not a breakage per se, opting in to the
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields) flag can cause
breakage when:

  * overriding an accessor in a derived class with a property declaration
  * re-declaring a property declaration with no initializer

To understand the full impact, read the section above on the
`useDefineForClassFields` flag.

### Function Truthy Checks

As mentioned above, TypeScript now errors when functions appear to be uncalled
within `if` statement conditions. An error is issued when a function type is
checked in `if` conditions unless any of the following apply:

  * the checked value comes from an optional property
  * [`strictNullChecks`](/tsconfig#strictNullChecks) is disabled
  * the function is later called within the body of the `if`

### Local and Imported Type Declarations Now Conflict

Due to a bug, the following construct was previously allowed in TypeScript:

    
    
    ts
    
    // ./someOtherModule.ts
    
    interface SomeType {
    
      y: string;
    
    }
    
    // ./myModule.ts
    
    import { SomeType } from "./someOtherModule";
    
    export interface SomeType {
    
      x: number;
    
    }
    
    function fn(arg: SomeType) {
    
      console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'
    
    }

Here, `SomeType` appears to originate in both the `import` declaration and the
local `interface` declaration. Perhaps surprisingly, inside the module,
`SomeType` refers exclusively to the `import`ed definition, and the local
declaration `SomeType` is only usable when imported from another file. This is
very confusing and our review of the very small number of cases of code like
this in the wild showed that developers usually thought something different
was happening.

In TypeScript 3.7, [this is now correctly identified as a duplicate identifier
error](https://github.com/microsoft/TypeScript/pull/31231). The correct fix
depends on the original intent of the author and should be addressed on a
case-by-case basis. Usually, the naming conflict is unintentional and the best
fix is to rename the imported type. If the intent was to augment the imported
type, a proper module augmentation should be written instead.

### 3.7 API Changes

To enable the recursive type alias patterns described above, the
`typeArguments` property has been removed from the `TypeReference` interface.
Users should instead use the `getTypeArguments` function on `TypeChecker`
instances.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.7.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(67\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

J![Jake
\(3\)](https://gravatar.com/avatar/31e55836947e29445f1d7bc9588268c7?s=32&&d=blank)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

GL![Giuliano Lauro
\(1\)](https://gravatar.com/avatar/0eed24f97858159290b3489702492d2e?s=32&&d=blank)

12+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.8

## Type-Only Imports and Export

This feature is something most users may never have to think about; however,
if you‚Äôve hit issues under [`isolatedModules`](/tsconfig#isolatedModules),
TypeScript‚Äôs `transpileModule` API, or Babel, this feature might be relevant.

TypeScript 3.8 adds a new syntax for type-only imports and exports.

    
    
    ts
    
    import type { SomeThing } from "./some-module.js";
    
    export type { SomeThing };

`import type` only imports declarations to be used for type annotations and
declarations. It _always_ gets fully erased, so there‚Äôs no remnant of it at
runtime. Similarly, `export type` only provides an export that can be used for
type contexts, and is also erased from TypeScript‚Äôs output.

It‚Äôs important to note that classes have a value at runtime and a type at
design-time, and the use is context-sensitive. When using `import type` to
import a class, you can‚Äôt do things like extend from it.

    
    
    ts
    
    import type { Component } from "react";
    
    interface ButtonProps {
    
      // ...
    
    }
    
    class Button extends Component<ButtonProps> {
    
      //               ~~~~~~~~~
    
      // error! 'Component' only refers to a type, but is being used as a value here.
    
      // ...
    
    }

If you‚Äôve used Flow before, the syntax is fairly similar. One difference is
that we‚Äôve added a few restrictions to avoid code that might appear ambiguous.

    
    
    ts
    
    // Is only 'Foo' a type? Or every declaration in the import?
    
    // We just give an error because it's not clear.
    
    import type Foo, { Bar, Baz } from "some-module";
    
    //     ~~~~~~~~~~~~~~~~~~~~~~
    
    // error! A type-only import can specify a default import or named bindings, but not both.

In conjunction with `import type`, TypeScript 3.8 also adds a new compiler
flag to control what happens with imports that won‚Äôt be utilized at runtime:
[`importsNotUsedAsValues`](/tsconfig#importsNotUsedAsValues). This flag takes
3 different values:

  * `remove`: this is today‚Äôs behavior of dropping these imports. It‚Äôs going to continue to be the default, and is a non-breaking change.
  * `preserve`: this _preserves_ all imports whose values are never used. This can cause imports/side-effects to be preserved.
  * `error`: this preserves all imports (the same as the `preserve` option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.

For more information about the feature, you can [take a look at the pull
request](https://github.com/microsoft/TypeScript/pull/35200), and [relevant
changes](https://github.com/microsoft/TypeScript/pull/36092/) around
broadening where imports from an `import type` declaration can be used.

## ECMAScript Private Fields

TypeScript 3.8 brings support for ECMAScript‚Äôs private fields, part of the
[stage-3 class fields proposal](https://github.com/tc39/proposal-class-
fields/).

    
    
    ts
    
    class Person {
    
      #name: string;
    
      constructor(name: string) {
    
        this.#name = name;
    
      }
    
      greet() {
    
        console.log(`Hello, my name is ${this.#name}!`);
    
      }
    
    }
    
    let jeremy = new Person("Jeremy Bearimy");
    
    jeremy.#name;
    
    //     ~~~~~
    
    // Property '#name' is not accessible outside class 'Person'
    
    // because it has a private identifier.

Unlike regular properties (even ones declared with the `private` modifier),
private fields have a few rules to keep in mind. Some of them are:

  * Private fields start with a `#` character. Sometimes we call these _private names_.
  * Every private field name is uniquely scoped to its containing class.
  * TypeScript accessibility modifiers like `public` or `private` can‚Äôt be used on private fields.
  * Private fields can‚Äôt be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this _hard privacy_.

Apart from ‚Äúhard‚Äù privacy, another benefit of private fields is that
uniqueness we just mentioned. For example, regular property declarations are
prone to being overwritten in subclasses.

    
    
    ts
    
    class C {
    
      foo = 10;
    
      cHelper() {
    
        return this.foo;
    
      }
    
    }
    
    class D extends C {
    
      foo = 20;
    
      dHelper() {
    
        return this.foo;
    
      }
    
    }
    
    let instance = new D();
    
    // 'this.foo' refers to the same property on each instance.
    
    console.log(instance.cHelper()); // prints '20'
    
    console.log(instance.dHelper()); // prints '20'

With private fields, you‚Äôll never have to worry about this, since each field
name is unique to the containing class.

    
    
    ts
    
    class C {
    
      #foo = 10;
    
      cHelper() {
    
        return this.#foo;
    
      }
    
    }
    
    class D extends C {
    
      #foo = 20;
    
      dHelper() {
    
        return this.#foo;
    
      }
    
    }
    
    let instance = new D();
    
    // 'this.#foo' refers to a different field within each class.
    
    console.log(instance.cHelper()); // prints '10'
    
    console.log(instance.dHelper()); // prints '20'

Another thing worth noting is that accessing a private field on any other type
will result in a `TypeError`!

    
    
    ts
    
    class Square {
    
      #sideLength: number;
    
      constructor(sideLength: number) {
    
        this.#sideLength = sideLength;
    
      }
    
      equals(other: any) {
    
        return this.#sideLength === other.#sideLength;
    
      }
    
    }
    
    const a = new Square(100);
    
    const b = { sideLength: 100 };
    
    // Boom!
    
    // TypeError: attempted to get private field on non-instance
    
    // This fails because 'b' is not an instance of 'Square'.
    
    console.log(a.equals(b));

Finally, for any plain `.js` file users, private fields _always_ have to be
declared before they‚Äôre assigned to.

    
    
    js
    
    class C {
    
      // No declaration for '#foo'
    
      // :(
    
      constructor(foo: number) {
    
        // SyntaxError!
    
        // '#foo' needs to be declared before writing to it.
    
        this.#foo = foo;
    
      }
    
    }

JavaScript has always allowed users to access undeclared properties, whereas
TypeScript has always required declarations for class properties. With private
fields, declarations are always needed regardless of whether we‚Äôre working in
`.js` or `.ts` files.

    
    
    js
    
    class C {
    
      /** @type {number} */
    
      #foo;
    
      constructor(foo: number) {
    
        // This works.
    
        this.#foo = foo;
    
      }
    
    }

For more information about the implementation, you can [check out the original
pull request](https://github.com/Microsoft/TypeScript/pull/30829)

### Which should I use?

We‚Äôve already received many questions on which type of privates you should use
as a TypeScript user: most commonly, ‚Äúshould I use the `private` keyword, or
ECMAScript‚Äôs hash/pound (`#`) private fields?‚Äù It depends!

When it comes to properties, TypeScript‚Äôs `private` modifiers are fully erased
- that means that at runtime, it acts entirely like a normal property and
there‚Äôs no way to tell that it was declared with a `private` modifier. When
using the `private` keyword, privacy is only enforced at compile-time/design-
time, and for JavaScript consumers it‚Äôs entirely intent-based.

    
    
    ts
    
    class C {
    
      private foo = 10;
    
    }
    
    // This is an error at compile time,
    
    // but when TypeScript outputs .js files,
    
    // it'll run fine and print '10'.
    
    console.log(new C().foo); // prints '10'
    
    //                  ~~~
    
    // error! Property 'foo' is private and only accessible within class 'C'.
    
    // TypeScript allows this at compile-time
    
    // as a "work-around" to avoid the error.
    
    console.log(new C()["foo"]); // prints '10'

The upside is that this sort of ‚Äúsoft privacy‚Äù can help your consumers
temporarily work around not having access to some API, and also works in any
runtime.

On the other hand, ECMAScript‚Äôs `#` privates are completely inaccessible
outside of the class.

    
    
    ts
    
    class C {
    
      #foo = 10;
    
    }
    
    console.log(new C().#foo); // SyntaxError
    
    //                  ~~~~
    
    // TypeScript reports an error *and*
    
    // this won't work at runtime!
    
    console.log(new C()["#foo"]); // prints undefined
    
    //          ~~~~~~~~~~~~~~~
    
    // TypeScript reports an error under 'noImplicitAny',
    
    // and this prints 'undefined'.

This hard privacy is really useful for strictly ensuring that nobody can take
use of any of your internals. If you‚Äôre a library author, removing or renaming
a private field should never cause a breaking change.

As we mentioned, another benefit is that subclassing can be easier with
ECMAScript‚Äôs `#` privates because they _really_ are private. When using
ECMAScript `#` private fields, no subclass ever has to worry about collisions
in field naming. When it comes to TypeScript‚Äôs `private` property
declarations, users still have to be careful not to trample over properties
declared in superclasses.

One more thing to think about is where you intend for your code to run.
TypeScript currently can‚Äôt support this feature unless targeting ECMAScript
2015 (ES6) targets or higher. This is because our downleveled implementation
uses `WeakMap`s to enforce privacy, and `WeakMap`s can‚Äôt be polyfilled in a
way that doesn‚Äôt cause memory leaks. In contrast, TypeScript‚Äôs
`private`-declared properties work with all targets - even ECMAScript 3!

A final consideration might be speed: `private` properties are no different
from any other property, so accessing them is as fast as any other property
access no matter which runtime you target. In contrast, because `#` private
fields are downleveled using `WeakMap`s, they may be slower to use. While some
runtimes might optimize their actual implementations of `#` private fields,
and even have speedy `WeakMap` implementations, that might not be the case in
all runtimes.

## `export * as ns` Syntax

It‚Äôs often common to have a single entry-point that exposes all the members of
another module as a single member.

    
    
    ts
    
    import * as utilities from "./utilities.js";
    
    export { utilities };

This is so common that ECMAScript 2020 recently added a new syntax to support
this pattern!

    
    
    ts
    
    export * as utilities from "./utilities.js";

This is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8
implements this syntax. When your module target is earlier than `es2020`,
TypeScript will output something along the lines of the first code snippet.

## Top-Level `await`

TypeScript 3.8 provides support for a handy upcoming ECMAScript feature called
‚Äútop-level `await`‚Äú.

JavaScript users often introduce an `async` function in order to use `await`,
and then immediately called the function after defining it.

    
    
    js
    
    async function main() {
    
      const response = await fetch("...");
    
      const greeting = await response.text();
    
      console.log(greeting);
    
    }
    
    main().catch((e) => console.error(e));

This is because previously in JavaScript (along with most other languages with
a similar feature), `await` was only allowed within the body of an `async`
function. However, with top-level `await`, we can use `await` at the top level
of a module.

    
    
    ts
    
    const response = await fetch("...");
    
    const greeting = await response.text();
    
    console.log(greeting);
    
    // Make sure we're a module
    
    export {};

Note there‚Äôs a subtlety: top-level `await` only works at the top level of a
_module_ , and files are only considered modules when TypeScript finds an
`import` or an `export`. In some basic cases, you might need to write out
`export {}` as some boilerplate to make sure of this.

Top level `await` may not work in all environments where you might expect at
this point. Currently, you can only use top level `await` when the
[`target`](/tsconfig#target) compiler option is `es2017` or above, and
`module` is `esnext` or `system`. Support within several environments and
bundlers may be limited or may require enabling experimental support.

For more information on our implementation, you can [check out the original
pull request](https://github.com/microsoft/TypeScript/pull/35813).

## `es2020` for `target` and `module`

TypeScript 3.8 supports `es2020` as an option for `module` and
[`target`](/tsconfig#target). This will preserve newer ECMAScript 2020
features like optional chaining, nullish coalescing, `export * as ns`, and
dynamic `import(...)` syntax. It also means `bigint` literals now have a
stable [`target`](/tsconfig#target) below `esnext`.

## JSDoc Property Modifiers

TypeScript 3.8 supports JavaScript files by turning on the
[`allowJs`](/tsconfig#allowJs) flag, and also supports _type-checking_ those
JavaScript files via the [`checkJs`](/tsconfig#checkJs) option or by adding a
`// @ts-check` comment to the top of your `.js` files.

Because JavaScript files don‚Äôt have dedicated syntax for type-checking,
TypeScript leverages JSDoc. TypeScript 3.8 understands a few new JSDoc tags
for properties.

First are the accessibility modifiers: `@public`, `@private`, and
`@protected`. These tags work exactly like `public`, `private`, and
`protected` respectively work in TypeScript.

    
    
    js
    
    // @ts-check
    
    class Foo {
    
      constructor() {
    
        /** @private */
    
        this.stuff = 100;
    
      }
    
      printStuff() {
    
        console.log(this.stuff);
    
      }
    
    }
    
    new Foo().stuff;
    
    //        ~~~~~
    
    // error! Property 'stuff' is private and only accessible within class 'Foo'.

  * `@public` is always implied and can be left off, but means that a property can be reached from anywhere.
  * `@private` means that a property can only be used within the containing class.
  * `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.

Next, we‚Äôve also added the `@readonly` modifier to ensure that a property is
only ever written to during initialization.

    
    
    js
    
    // @ts-check
    
    class Foo {
    
      constructor() {
    
        /** @readonly */
    
        this.stuff = 100;
    
      }
    
      writeToStuff() {
    
        this.stuff = 200;
    
        //   ~~~~~
    
        // Cannot assign to 'stuff' because it is a read-only property.
    
      }
    
    }
    
    new Foo().stuff++;
    
    //        ~~~~~
    
    // Cannot assign to 'stuff' because it is a read-only property.

## Better Directory Watching on Linux and `watchOptions`

TypeScript 3.8 ships a new strategy for watching directories, which is crucial
for efficiently picking up changes to `node_modules`.

For some context, on operating systems like Linux, TypeScript installs
directory watchers (as opposed to file watchers) on `node_modules` and many of
its subdirectories to detect changes in dependencies. This is because the
number of available file watchers is often eclipsed by the number of files in
`node_modules`, whereas there are way fewer directories to track.

Older versions of TypeScript would _immediately_ install directory watchers on
folders, and at startup that would be fine; however, during an npm install, a
lot of activity will take place within `node_modules` and that can overwhelm
TypeScript, often slowing editor sessions to a crawl. To prevent this,
TypeScript 3.8 waits slightly before installing directory watchers to give
these highly volatile directories some time to stabilize.

Because every project might work better under different strategies, and this
new approach might not work well for your workflows, TypeScript 3.8 introduces
a new `watchOptions` field in `tsconfig.json` and `jsconfig.json` which allows
users to tell the compiler/language service which watching strategies should
be used to keep track of files and directories.

    
    
    {
    
      // Some typical compiler options
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2020",
    
        "[moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution)": "node"
    
        // ...
    
      },
    
      // NEW: Options for file/directory watching
    
      "watchOptions": {
    
        // Use native file system events for files and directories
    
        "[watchFile](https://www.typescriptlang.org/tsconfig#watchFile)": "useFsEvents",
    
        "[watchDirectory](https://www.typescriptlang.org/tsconfig#watchDirectory)": "useFsEvents",
    
        // Poll files for updates more frequently
    
        // when they're updated a lot.
    
        "[fallbackPolling](https://www.typescriptlang.org/tsconfig#fallbackPolling)": "dynamicPriority"
    
      }
    
    }

`watchOptions` contains 4 new options that can be configured:

  * [`watchFile`](/tsconfig#watchFile): the strategy for how individual files are watched. This can be set to

    * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
    * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
    * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
    * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for file changes.
    * `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system‚Äôs native events to listen for changes on a file‚Äôs containing directories. This can use fewer file watchers, but might be less accurate.
  * [`watchDirectory`](/tsconfig#watchDirectory): the strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality. This can be set to:

    * `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
    * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
    * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for directory changes.
  * [`fallbackPolling`](/tsconfig#fallbackPolling): when using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn‚Äôt support native file watchers. This can be set to

    * `fixedPollingInterval`: _(See above.)_
    * `priorityPollingInterval`: _(See above.)_
    * `dynamicPriorityPolling`: _(See above.)_
    * `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.

For more information on these changes, [head over to GitHub to see the pull
request](https://github.com/microsoft/TypeScript/pull/35615) to read more.

## ‚ÄúFast and Loose‚Äù Incremental Checking

TypeScript 3.8 introduces a new compiler option called
[`assumeChangesOnlyAffectDirectDependencies`](/tsconfig#assumeChangesOnlyAffectDirectDependencies).
When this option is enabled, TypeScript will avoid rechecking/rebuilding all
truly possibly-affected files, and only recheck/rebuild files that have
changed as well as files that directly import them.

For example, consider a file `fileD.ts` that imports `fileC.ts` that imports
`fileB.ts` that imports `fileA.ts` as follows:

    
    
    fileA.ts <- fileB.ts <- fileC.ts <- fileD.ts

In `--watch` mode, a change in `fileA.ts` would typically mean that TypeScript
would need to at least re-check `fileB.ts`, `fileC.ts`, and `fileD.ts`. Under
[`assumeChangesOnlyAffectDirectDependencies`](/tsconfig#assumeChangesOnlyAffectDirectDependencies),
a change in `fileA.ts` means that only `fileA.ts` and `fileB.ts` need to be
re-checked.

In a codebase like Visual Studio Code, this reduced rebuild times for changes
in certain files from about 14 seconds to about 1 second. While we don‚Äôt
necessarily recommend this option for all codebases, you might be interested
if you have an extremely large codebase and are willing to defer full project
errors until later (e.g. a dedicated build via a `tsconfig.fullbuild.json` or
in CI).

For more details, you can [see the original pull
request](https://github.com/microsoft/TypeScript/pull/35711).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.8.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(51\)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AB![Adam Boyce
\(1\)](https://gravatar.com/avatar/87f5f7572e0668eb5c8fbb64a94c95cd?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

MU![Masato Urai
\(1\)](https://gravatar.com/avatar/6b10b84436915f5e96900a8b1d2452d9?s=32&&d=blank)

2+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 3.9

## Improvements in Inference and `Promise.all`

Recent versions of TypeScript (around 3.7) have had updates to the
declarations of functions like `Promise.all` and `Promise.race`.
Unfortunately, that introduced a few regressions, especially when mixing in
values with `null` or `undefined`.

    
    
    ts
    
    interface Lion {
    
      roar(): void;
    
    }
    
    interface Seal {
    
      singKissFromARose(): void;
    
    }
    
    async function visitZoo(
    
      lionExhibit: Promise<Lion>,
    
      sealExhibit: Promise<Seal | undefined>
    
    ) {
    
      let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);
    
      lion.roar(); // uh oh
    
      //  ~~~~
    
      // Object is possibly 'undefined'.
    
    }

This is strange behavior! The fact that `sealExhibit` contained an `undefined`
somehow poisoned type of `lion` to include `undefined`.

Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/34501)
from [Jack Bates](https://github.com/jablko), this has been fixed with
improvements in our inference process in TypeScript 3.9. The above no longer
errors. If you‚Äôve been stuck on older versions of TypeScript due to issues
around `Promise`s, we encourage you to give 3.9 a shot!

### What About the `awaited` Type?

If you‚Äôve been following our issue tracker and design meeting notes, you might
be aware of some work around [a new type operator called
`awaited`](https://github.com/microsoft/TypeScript/pull/35998). This goal of
this type operator is to accurately model the way that `Promise` unwrapping
works in JavaScript.

We initially anticipated shipping `awaited` in TypeScript 3.9, but as we‚Äôve
run early TypeScript builds with existing codebases, we‚Äôve realized that the
feature needs more design work before we can roll it out to everyone smoothly.
As a result, we‚Äôve decided to pull the feature out of our main branch until we
feel more confident. We‚Äôll be experimenting more with the feature, but we
won‚Äôt be shipping it as part of this release.

## Speed Improvements

TypeScript 3.9 ships with many new speed improvements. Our team has been
focusing on performance after observing extremely poor editing/compilation
speed with packages like material-ui and styled-components. We‚Äôve dived deep
here, with a series of different pull requests that optimize certain
pathological cases involving large unions, intersections, conditional types,
and mapped types.

  * <https://github.com/microsoft/TypeScript/pull/36576>
  * <https://github.com/microsoft/TypeScript/pull/36590>
  * <https://github.com/microsoft/TypeScript/pull/36607>
  * <https://github.com/microsoft/TypeScript/pull/36622>
  * <https://github.com/microsoft/TypeScript/pull/36754>
  * <https://github.com/microsoft/TypeScript/pull/36696>

Each of these pull requests gains about a 5-10% reduction in compile times on
certain codebases. In total, we believe we‚Äôve achieved around a 40% reduction
in material-ui‚Äôs compile time!

We also have some changes to file renaming functionality in editor scenarios.
We heard from the Visual Studio Code team that when renaming a file, just
figuring out which import statements needed to be updated could take between 5
to 10 seconds. TypeScript 3.9 addresses this issue by [changing the internals
of how the compiler and language service caches file
lookups](https://github.com/microsoft/TypeScript/pull/37055).

While there‚Äôs still room for improvement, we hope this work translates to a
snappier experience for everyone!

## `// @ts-expect-error` Comments

Imagine that we‚Äôre writing a library in TypeScript and we‚Äôre exporting some
function called `doStuff` as part of our public API. The function‚Äôs types
declare that it takes two `string`s so that other TypeScript users can get
type-checking errors, but it also does a runtime check (maybe only in
development builds) to give JavaScript users a helpful error.

    
    
    ts
    
    function doStuff(abc: string, xyz: string) {
    
      assert(typeof abc === "string");
    
      assert(typeof xyz === "string");
    
      // do some stuff
    
    }

So TypeScript users will get a helpful red squiggle and an error message when
they misuse this function, and JavaScript users will get an assertion error.
We‚Äôd like to test this behavior, so we‚Äôll write a unit test.

    
    
    ts
    
    expect(() => {
    
      doStuff(123, 456);
    
    }).toThrow();

Unfortunately if our tests are written in TypeScript, TypeScript will give us
an error!

    
    
    ts
    
    doStuff(123, 456);
    
    //          ~~~
    
    // error: Type 'number' is not assignable to type 'string'.

That‚Äôs why TypeScript 3.9 brings a new feature: `// @ts-expect-error`
comments. When a line is preceded by a `// @ts-expect-error` comment,
TypeScript will suppress that error from being reported; but if there‚Äôs no
error, TypeScript will report that `// @ts-expect-error` wasn‚Äôt necessary.

As a quick example, the following code is okay

    
    
    ts
    
    // @ts-expect-error
    
    console.log(47 * "octopus");

while the following code

    
    
    ts
    
    // @ts-expect-error
    
    console.log(1 + 1);

results in the error

    
    
    Unused '@ts-expect-error' directive.

We‚Äôd like to extend a big thanks to [Josh
Goldberg](https://github.com/JoshuaKGoldberg), the contributor who implemented
this feature. For more information, you can take a look at [the `ts-expect-
error` pull request](https://github.com/microsoft/TypeScript/pull/36014).

### `ts-ignore` or `ts-expect-error`?

In some ways `// @ts-expect-error` can act as a suppression comment, similar
to `// @ts-ignore`. The difference is that `// @ts-ignore` will do nothing if
the following line is error-free.

You might be tempted to switch existing `// @ts-ignore` comments over to `//
@ts-expect-error`, and you might be wondering which is appropriate for future
code. While it‚Äôs entirely up to you and your team, we have some ideas of which
to pick in certain situations.

Pick `ts-expect-error` if:

  * you‚Äôre writing test code where you actually want the type system to error on an operation
  * you expect a fix to be coming in fairly quickly and you just need a quick workaround
  * you‚Äôre in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again

Pick `ts-ignore` if:

  * you have a larger project and new errors have appeared in code with no clear owner
  * you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.
  * you honestly don‚Äôt have the time to decide which of these options is better.

## Uncalled Function Checks in Conditional Expressions

In TypeScript 3.7 we introduced _uncalled function checks_ to report an error
when you‚Äôve forgotten to call a function.

    
    
    ts
    
    function hasImportantPermissions(): boolean {
    
      // ...
    
    }
    
    // Oops!
    
    if (hasImportantPermissions) {
    
      //  ~~~~~~~~~~~~~~~~~~~~~~~
    
      // This condition will always return true since the function is always defined.
    
      // Did you mean to call it instead?
    
      deleteAllTheImportantFiles();
    
    }

However, this error only applied to conditions in `if` statements. Thanks to
[a pull request](https://github.com/microsoft/TypeScript/pull/36402) from
[Alexander Tarasyuk](https://github.com/a-tarasyuk), this feature is also now
supported in ternary conditionals (i.e. the `cond ? trueExpr : falseExpr`
syntax).

    
    
    ts
    
    declare function listFilesOfDirectory(dirPath: string): string[];
    
    declare function isDirectory(): boolean;
    
    function getAllFiles(startFileName: string) {
    
      const result: string[] = [];
    
      traverse(startFileName);
    
      return result;
    
      function traverse(currentPath: string) {
    
        return isDirectory
    
          ? //     ~~~~~~~~~~~
    
            // This condition will always return true
    
            // since the function is always defined.
    
            // Did you mean to call it instead?
    
            listFilesOfDirectory(currentPath).forEach(traverse)
    
          : result.push(currentPath);
    
      }
    
    }

<https://github.com/microsoft/TypeScript/issues/36048>

## Editor Improvements

The TypeScript compiler not only powers the TypeScript editing experience in
most major editors, it also powers the JavaScript experience in the Visual
Studio family of editors and more. Using new TypeScript/JavaScript
functionality in your editor will differ depending on your editor, but

  * Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript). Alternatively, there‚Äôs the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) to stay on the bleeding edge (which is typically very stable).
  * Visual Studio 2017/2019 have [the SDK installers above] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild).
  * Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)

### CommonJS Auto-Imports in JavaScript

One great new improvement is in auto-imports in JavaScript files using
CommonJS modules.

In older versions, TypeScript always assumed that regardless of your file, you
wanted an ECMAScript-style import like

    
    
    js
    
    import * as fs from "fs";

However, not everyone is targeting ECMAScript-style modules when writing
JavaScript files. Plenty of users still use CommonJS-style `require(...)`
imports like so

    
    
    js
    
    const fs = require("fs");

TypeScript now automatically detects the types of imports you‚Äôre using to keep
your file‚Äôs style clean and consistent.

For more details on the change, see [the corresponding pull
request](https://github.com/microsoft/TypeScript/pull/37027).

### Code Actions Preserve Newlines

TypeScript‚Äôs refactorings and quick fixes often didn‚Äôt do a great job of
preserving newlines. As a really basic example, take the following code.

    
    
    ts
    
    const maxValue = 100;
    
    /*start*/
    
    for (let i = 0; i <= maxValue; i++) {
    
      // First get the squared value.
    
      let square = i ** 2;
    
      // Now print the squared value.
    
      console.log(square);
    
    }
    
    /*end*/

If we highlighted the range from `/*start*/` to `/*end*/` in our editor to
extract to a new function, we‚Äôd end up with code like the following.

    
    
    ts
    
    const maxValue = 100;
    
    printSquares();
    
    function printSquares() {
    
      for (let i = 0; i <= maxValue; i++) {
    
        // First get the squared value.
    
        let square = i ** 2;
    
        // Now print the squared value.
    
        console.log(square);
    
      }
    
    }

![Extracting the for loop to a function in older versions of TypeScript. A
newline is not preserved.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/03/printSquaresWithoutNewlines-3.9.gif.gif)

That‚Äôs not ideal - we had a blank line between each statement in our `for`
loop, but the refactoring got rid of it! TypeScript 3.9 does a little more
work to preserve what we write.

    
    
    ts
    
    const maxValue = 100;
    
    printSquares();
    
    function printSquares() {
    
      for (let i = 0; i <= maxValue; i++) {
    
        // First get the squared value.
    
        let square = i ** 2;
    
        // Now print the squared value.
    
        console.log(square);
    
      }
    
    }

![Extracting the for loop to a function in TypeScript 3.9. A newline is
preserved.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/03/printSquaresWithNewlines-3.9.gif.gif)

You can see more about the implementation [in this pull
request](https://github.com/microsoft/TypeScript/pull/36688)

### Quick Fixes for Missing Return Expressions

There are occasions where we might forget to return the value of the last
statement in a function, especially when adding curly braces to arrow
functions.

    
    
    ts
    
    // before
    
    let f1 = () => 42;
    
    // oops - not the same!
    
    let f2 = () => {
    
      42;
    
    };

Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/26434)
from community member [Wenlu Wang](https://github.com/Kingwl), TypeScript can
provide a quick-fix to add missing `return` statements, remove curly braces,
or add parentheses to arrow function bodies that look suspiciously like object
literals.

![TypeScript fixing an error where no expression is returned by adding a
return statement or removing curly
braces.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/04/missingReturnValue-3-9.gif)

### Support for ‚ÄúSolution Style‚Äù `tsconfig.json` Files

Editors need to figure out which configuration file a file belongs to so that
it can apply the appropriate options and figure out which other files are
included in the current ‚Äúproject‚Äù. By default, editors powered by TypeScript‚Äôs
language server do this by walking up each parent directory to find a
`tsconfig.json`.

One case where this slightly fell over is when a `tsconfig.json` simply
existed to reference other `tsconfig.json` files.

    
    
    // tsconfig.json
    
    {
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": [],
    
      "[references](https://www.typescriptlang.org/tsconfig#references)": [
    
        { "path": "./tsconfig.shared.json" },
    
        { "path": "./tsconfig.frontend.json" },
    
        { "path": "./tsconfig.backend.json" }
    
      ]
    
    }

This file that really does nothing but manage other project files is often
called a ‚Äúsolution‚Äù in some environments. Here, none of these
`tsconfig.*.json` files get picked up by the server, but we‚Äôd really like the
language server to understand that the current `.ts` file probably belongs to
one of the mentioned projects in this root `tsconfig.json`.

TypeScript 3.9 adds support to editing scenarios for this configuration. For
more details, take a look at [the pull request that added this
functionality](https://github.com/microsoft/TypeScript/pull/37239).

## Breaking Changes

### Parsing Differences in Optional Chaining and Non-Null Assertions

TypeScript recently implemented the optional chaining operator, but we‚Äôve
received user feedback that the behavior of optional chaining (`?.`) with the
non-null assertion operator (`!`) is extremely counter-intuitive.

Specifically, in previous versions, the code

    
    
    ts
    
    foo?.bar!.baz;

was interpreted to be equivalent to the following JavaScript.

    
    
    js
    
    (foo?.bar).baz;

In the above code the parentheses stop the ‚Äúshort-circuiting‚Äù behavior of
optional chaining, so if `foo` is `undefined`, accessing `baz` will cause a
runtime error.

The Babel team who pointed this behavior out, and most users who provided
feedback to us, believe that this behavior is wrong. We do too! The thing we
heard the most was that the `!` operator should just ‚Äúdisappear‚Äù since the
intent was to remove `null` and `undefined` from the type of `bar`.

In other words, most people felt that the original snippet should be
interpreted as

    
    
    js
    
    foo?.bar.baz;

which just evaluates to `undefined` when `foo` is `undefined`.

This is a breaking change, but we believe most code was written with the new
interpretation in mind. Users who want to revert to the old behavior can add
explicit parentheses around the left side of the `!` operator.

    
    
    ts
    
    foo?.bar!.baz;

### `}` and `>` are Now Invalid JSX Text Characters

The JSX Specification forbids the use of the `}` and `>` characters in text
positions. TypeScript and Babel have both decided to enforce this rule to be
more conformant. The new way to insert these characters is to use an HTML
escape code (e.g. `<span> 2 &gt 1 </span>`) or insert an expression with a
string literal (e.g. `<span> 2 {">"} 1 </span>`).

Luckily, thanks to the [pull
request](https://github.com/microsoft/TypeScript/pull/36636) enforcing this
from [Brad Zacher](https://github.com/bradzacher), you‚Äôll get an error message
along the lines of

    
    
    Unexpected token. Did you mean `{'>'}` or `>`?
    
    Unexpected token. Did you mean `{'}'}` or `}`?

For example:

    
    
    tsx
    
    let directions = <span>Navigate to: Menu Bar > Tools > Options</span>;
    
    //                                           ~       ~
    
    // Unexpected token. Did you mean `{'>'}` or `>`?

That error message came with a handy quick fix, and thanks to [Alexander
Tarasyuk](https://github.com/a-tarasyuk), [you can apply these changes in
bulk](https://github.com/microsoft/TypeScript/pull/37436) if you have a lot of
errors.

### Stricter Checks on Intersections and Optional Properties

Generally, an intersection type like `A & B` is assignable to `C` if either
`A` or `B` is assignable to `C`; however, sometimes that has problems with
optional properties. For example, take the following:

    
    
    ts
    
    interface A {
    
      a: number; // notice this is 'number'
    
    }
    
    interface B {
    
      b: string;
    
    }
    
    interface C {
    
      a?: boolean; // notice this is 'boolean'
    
      b: string;
    
    }
    
    declare let x: A & B;
    
    declare let y: C;
    
    y = x;

In previous versions of TypeScript, this was allowed because while `A` was
totally incompatible with `C`, `B` _was_ compatible with `C`.

In TypeScript 3.9, so long as every type in an intersection is a concrete
object type, the type system will consider all of the properties at once. As a
result, TypeScript will see that the `a` property of `A & B` is incompatible
with that of `C`:

    
    
    Type 'A & B' is not assignable to type 'C'.
    
      Types of property 'a' are incompatible.
    
        Type 'number' is not assignable to type 'boolean | undefined'.

For more information on this change, [see the corresponding pull
request](https://github.com/microsoft/TypeScript/pull/37195).

### Intersections Reduced By Discriminant Properties

There are a few cases where you might end up with types that describe values
that just don‚Äôt exist. For example

    
    
    ts
    
    declare function smushObjects<T, U>(x: T, y: U): T & U;
    
    interface Circle {
    
      kind: "circle";
    
      radius: number;
    
    }
    
    interface Square {
    
      kind: "square";
    
      sideLength: number;
    
    }
    
    declare let x: Circle;
    
    declare let y: Square;
    
    let z = smushObjects(x, y);
    
    console.log(z.kind);

This code is slightly weird because there‚Äôs really no way to create an
intersection of a `Circle` and a `Square` \- they have two incompatible `kind`
fields. In previous versions of TypeScript, this code was allowed and the type
of `kind` itself was `never` because `"circle" & "square"` described a set of
values that could `never` exist.

In TypeScript 3.9, the type system is more aggressive here - it notices that
it‚Äôs impossible to intersect `Circle` and `Square` because of their `kind`
properties. So instead of collapsing the type of `z.kind` to `never`, it
collapses the type of `z` itself (`Circle & Square`) to `never`. That means
the above code now errors with:

    
    
    Property 'kind' does not exist on type 'never'.

Most of the breaks we observed seem to correspond with slightly incorrect type
declarations. For more details, [see the original pull
request](https://github.com/microsoft/TypeScript/pull/36696).

### Getters/Setters are No Longer Enumerable

In older versions of TypeScript, `get` and `set` accessors in classes were
emitted in a way that made them enumerable; however, this wasn‚Äôt compliant
with the ECMAScript specification which states that they must be non-
enumerable. As a result, TypeScript code that targeted ES5 and ES2015 could
differ in behavior.

Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/32264)
from GitHub user [pathurs](https://github.com/pathurs), TypeScript 3.9 now
conforms more closely with ECMAScript in this regard.

### Type Parameters That Extend `any` No Longer Act as `any`

In previous versions of TypeScript, a type parameter constrained to `any`
could be treated as `any`.

    
    
    ts
    
    function foo<T extends any>(arg: T) {
    
      arg.spfjgerijghoied; // no error!
    
    }

This was an oversight, so TypeScript 3.9 takes a more conservative approach
and issues an error on these questionable operations.

    
    
    ts
    
    function foo<T extends any>(arg: T) {
    
      arg.spfjgerijghoied;
    
      //  ~~~~~~~~~~~~~~~
    
      // Property 'spfjgerijghoied' does not exist on type 'T'.
    
    }

### `export *` is Always Retained

In previous TypeScript versions, declarations like `export * from "foo"` would
be dropped in our JavaScript output if `foo` didn‚Äôt export any values. This
sort of emit is problematic because it‚Äôs type-directed and can‚Äôt be emulated
by Babel. TypeScript 3.9 will always emit these `export *` declarations. In
practice, we don‚Äôt expect this to break much existing code.

### More libdom.d.ts refinements

We are continuing to move more of TypeScript‚Äôs built-in .d.ts library
(lib.d.ts and family) to be generated from Web IDL files directly from the DOM
specification. As a result some vendor-specific types related to media access
have been removed.

Adding this file to an ambient `*.d.ts` to your project will bring them back:

    
    
    ts
    
    interface AudioTrackList {
    
         [Symbol.iterator](): IterableIterator<AudioTrack>;
    
     }
    
    interface HTMLVideoElement {
    
      readonly audioTracks: AudioTrackList
    
      msFrameStep(forward: boolean): void;
    
      msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;
    
      msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;
    
      webkitEnterFullScreen(): void;
    
      webkitEnterFullscreen(): void;
    
      webkitExitFullScreen(): void;
    
      webkitExitFullscreen(): void;
    
      msHorizontalMirror: boolean;
    
      readonly msIsLayoutOptimalForPlayback: boolean;
    
      readonly msIsStereo3D: boolean;
    
      msStereo3DPackingMode: string;
    
      msStereo3DRenderMode: string;
    
      msZoom: boolean;
    
      onMSVideoFormatChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;
    
      onMSVideoFrameStepCompleted: ((this: HTMLVideoElement, ev: Event) => any) | null;
    
      onMSVideoOptimalLayoutChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;
    
      webkitDisplayingFullscreen: boolean;
    
      webkitSupportsFullscreen: boolean;
    
    }
    
    interface MediaError {
    
      readonly msExtendedCode: number;
    
      readonly MS_MEDIA_ERR_ENCRYPTED: number;
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
3.9.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(12\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

MU![Masato Urai
\(1\)](https://gravatar.com/avatar/6b10b84436915f5e96900a8b1d2452d9?s=32&&d=blank)

HK![Homyee King
\(1\)](https://gravatar.com/avatar/2ccc06ad048660b67369414950adb851?s=32&&d=blank)

JV![Jakub Vr√°na
\(1\)](https://gravatar.com/avatar/613ad8d6613aeab5d2f6f72babae8402?s=32&&d=blank)

1+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.0

## Variadic Tuple Types

Consider a function in JavaScript called `concat` that takes two array or
tuple types and concatenates them together to make a new array.

    
    
    js
    
    function concat(arr1, arr2) {
    
      return [...arr1, ...arr2];
    
    }

Also consider `tail`, that takes an array or tuple, and returns all elements
but the first.

    
    
    js
    
    function tail(arg) {
    
      const [_, ...result] = arg;
    
      return result;
    
    }

How would we type either of these in TypeScript?

For `concat`, the only valid thing we could do in older versions of the
language was to try and write some overloads.

    
    
    ts
    
    function concat(arr1: [], arr2: []): [];
    
    function concat<A>(arr1: [A], arr2: []): [A];
    
    function concat<A, B>(arr1: [A, B], arr2: []): [A, B];
    
    function concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];
    
    function concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];
    
    function concat<A, B, C, D, E>(arr1: [A, B, C, D, E], arr2: []): [A, B, C, D, E];
    
    function concat<A, B, C, D, E, F>(arr1: [A, B, C, D, E, F], arr2: []): [A, B, C, D, E, F];

Uh‚Ä¶okay, that‚Äôs‚Ä¶seven overloads for when the second array is always empty.
Let‚Äôs add some for when `arr2` has one argument.

    
    
    ts
    
    function concat<A2>(arr1: [], arr2: [A2]): [A2];
    
    function concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];
    
    function concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];
    
    function concat<A1, B1, C1, A2>(arr1: [A1, B1, C1], arr2: [A2]): [A1, B1, C1, A2];
    
    function concat<A1, B1, C1, D1, A2>(arr1: [A1, B1, C1, D1], arr2: [A2]): [A1, B1, C1, D1, A2];
    
    function concat<A1, B1, C1, D1, E1, A2>(arr1: [A1, B1, C1, D1, E1], arr2: [A2]): [A1, B1, C1, D1, E1, A2];
    
    function concat<A1, B1, C1, D1, E1, F1, A2>(arr1: [A1, B1, C1, D1, E1, F1], arr2: [A2]): [A1, B1, C1, D1, E1, F1, A2];

We hope it‚Äôs clear that this is getting unreasonable. Unfortunately, you‚Äôd
also end up with the same sorts of issues typing a function like `tail`.

This is another case of what we like to call ‚Äúdeath by a thousand overloads‚Äù,
and it doesn‚Äôt even solve the problem generally. It only gives correct types
for as many overloads as we care to write. If we wanted to make a catch-all
case, we‚Äôd need an overload like the following:

    
    
    ts
    
    function concat<T, U>(arr1: T[], arr2: U[]): Array<T | U>;

But that signature doesn‚Äôt encode anything about the lengths of the input, or
the order of the elements, when using tuples.

TypeScript 4.0 brings two fundamental changes, along with inference
improvements, to make typing these possible.

The first change is that spreads in tuple type syntax can now be generic. This
means that we can represent higher-order operations on tuples and arrays even
when we don‚Äôt know the actual types we‚Äôre operating over. When generic spreads
are instantiated (or, replaced with a real type) in these tuple types, they
can produce other sets of array and tuple types.

For example, that means we can type function like `tail`, without our ‚Äúdeath
by a thousand overloads‚Äù issue.

    
    
    ts
    
    function tail<T extends any[]>(arr: readonly [any, ...T]) {
    
      const [_ignored, ...rest] = arr;
    
      return rest;
    
    }
    
    ¬†
    
    const myTuple = [1, 2, 3, 4] as const;
    
    const myArray = ["hello", "world"];
    
    ¬†
    
    const r1 = tail(myTuple);
    
          
    
    const r1: [2, 3, 4]
    
    ¬†
    
    const r2 = tail([...myTuple, ...myArray] as const);
    
          
    
    const r2: [2, 3, 4, ...string[]]
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFAhjANgHgCqIKYAeUeYAJgM6IpgCeA2gLoB8AFCgE7sBci7eKpBOhqI61GgBpEAOlnYGASkQBvAFCJEEBOSiiA+jADmYOH1JTZ0vjoaIAvFU4BudbzxQQ7JNaguAvqqqWmA6iAC2NNggAA7oePaiAIxSAExSAMxSACy2KJTBOi4FuhEAgpwoIg50AEQAFnjo6HA1UjUA7qbopDUMLkHauuyJCagYLBFRsXgKLgD0cxoaAHoA-IHFvCmjaOgsdJaTMXEWsmUVNLn5g7OqC0uIa0A)

The second change is that rest elements can occur anywhere in a tuple - not
just at the end!

    
    
    ts
    
    type Strings = [string, string];
    
    type Numbers = [number, number];
    
    type StrStrNumNumBool = [...Strings, ...Numbers, boolean];

Previously, TypeScript would issue an error like the following:

    
    
    A rest element must be last in a tuple type.

But with TypeScript 4.0, this restriction is relaxed.

Note that in cases when we spread in a type without a known length, the
resulting type becomes unbounded as well, and all the following elements
factor into the resulting rest element type.

    
    
    ts
    
    type Strings = [string, string];
    
    type Numbers = number[];
    
    type Unbounded = [...Strings, ...Numbers, boolean];

By combining both of these behaviors together, we can write a single well-
typed signature for `concat`:

    
    
    ts
    
    type Arr = readonly any[];
    
    ¬†
    
    function concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {
    
      return [...arr1, ...arr2];
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCnVxAG0BdAbgCgaAzAV1wGNgBLPKFvF9YADwAVKBAAewCLkwBnWAgA0UAKqiJU2fLgA+ABToEARgBcUIUoNwATKeUBKU2QB0L81BdPlFKAG8aUVAhgRjhcKGcXS0MlD0srahoAXyA)

While that one signature is still a bit lengthy, it‚Äôs just one signature that
doesn‚Äôt have to be repeated, and it gives predictable behavior on all arrays
and tuples.

This functionality on its own is great, but it shines in more sophisticated
scenarios too. For example, consider a function to [partially apply
arguments](https://en.wikipedia.org/wiki/Partial_application) called
`partialCall`. `partialCall` takes a function - let‚Äôs call it `f` \- along
with the initial few arguments that `f` expects. It then returns a new
function that takes any other arguments that `f` still needs, and calls `f`
when it receives them.

    
    
    js
    
    function partialCall(f, ...headArgs) {
    
      return (...tailArgs) => f(...headArgs, ...tailArgs);
    
    }

TypeScript 4.0 improves the inference process for rest parameters and rest
tuple elements so that we can type this and have it ‚Äújust work‚Äù.

    
    
    ts
    
    type Arr = readonly unknown[];
    
    ¬†
    
    function partialCall<T extends Arr, U extends Arr, R>(
    
      f: (...args: [...T, ...U]) => R,
    
      ...headArgs: T
    
    ) {
    
      return (...tailArgs: U) => f(...headArgs, ...tailArgs);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCgFdcBrXbAd1wG0BdAbgChmAzUgY2AEs8ow6OL3T4AwqPwAeACpQIAD2ARcmAM6wEAGigBVeUpXrNcHQCUAfAApmUKGwBcUKwDo3QgOZqntNy5k6frr0AJTIFlBmWrZQfgAWGJjwXk4yzGEA3jFowMRwuM5+wOg8+MneemFIEWyubglY5YFuxaXlISwAvkA)

In this case, `partialCall` understands which parameters it can and can‚Äôt
initially take, and returns functions that appropriately accept and reject
anything left over.

    
    
    ts
    
    const foo = (x: string, y: number, z: boolean) => {};
    
    ¬†
    
    const f1 = partialCall(foo, 100);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    
    ¬†
    
    const f2 = partialCall(foo, "hello", 100, true, "oops");
    
    Expected 4 arguments, but got 5.2554Expected 4 arguments, but got 5.
    
    ¬†
    
    // This works!
    
    const f3 = partialCall(foo, "hello");
    
          
    
    const f3: (y: number, z: boolean) => void
    
    ¬†
    
    // What can we do with f3 now?
    
    ¬†
    
    // Works!
    
    f3(123, true);
    
    ¬†
    
    f3();
    
    Expected 2 arguments, but got 0.2554Expected 2 arguments, but got 0.
    
    ¬†
    
    f3(123, "hello");
    
    Argument of type 'string' is not assignable to parameter of type 'boolean'.2345Argument of type 'string' is not assignable to parameter of type 'boolean'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdOct9D1scAoAFwE8AHSUAQVlAF5RpIBDAEzgDsANtVABXfgGt+cAO78A2gF0A3OXIAzcQGNKASwGhaXaHq6CAwmcEAeACqhIAD0qR+PRE1gAaUAFUHzq7untA+AEoAfAAU5KCg6qhRAHQpxgDmKKDyKUm2Pjm+igCUbBGgYV6xoDkAFtw8zBmotuQlAN5VnJSi0PygySmUXLqCjZm+Jaxl6gNJdbxj+YPDo9AZRaoAvuQgoAC0B1qilAd75FoCiJTxcHBs-Y6oV9C6-Gk+1Kj8ogC2AEYwHwAL1Qf1ugm4-EmZTam1U50u13UAEZ7kYTLozJZBIIoupbj5kQAGIkbNQXfhXeJoNHGUwWKx4gmgABEdRxcBZhJJPko0FEkB8LNutEQLLJOzAthqug8MgQEkQAEIEZSkRhaRisYz8XAhezBJyybs4qAAHoAfjUuwA6jUuNctFw+jIGHxQDJdJQavENdIZFbJaAbQrlRoMFFkZhefzIBL1BH4xGoxh9ZAOeLlEA)

Variadic tuple types enable a lot of new exciting patterns, especially around
function composition. We expect we may be able to leverage it to do a better
job type-checking JavaScript‚Äôs built-in `bind` method. A handful of other
inference improvements and patterns also went into this, and if you‚Äôre
interested in learning more, you can take a look at [the pull
request](https://github.com/microsoft/TypeScript/pull/39094) for variadic
tuples.

## Labeled Tuple Elements

Improving the experience around tuple types and parameter lists is important
because it allows us to get strongly typed validation around common JavaScript
idioms - really just slicing and dicing argument lists and passing them to
other functions. The idea that we can use tuple types for rest parameters is
one place where this is crucial.

For example, the following function that uses a tuple type as a rest
parameter‚Ä¶

    
    
    ts
    
    function foo(...args: [string, number]): void {
    
      // ...
    
    }

‚Ä¶should appear no different from the following function‚Ä¶

    
    
    ts
    
    function foo(arg0: string, arg1: number): void {
    
      // ...
    
    }

‚Ä¶for any caller of `foo`.

    
    
    ts
    
    foo("hello", 42);
    
    ¬†
    
    foo("hello", 42, true);
    
    Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.
    
    foo("hello");
    
    Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jR844AKAQ2gHMAGVRc6S4tgBpQrNgEZUxQgFsARjACUqAG5xKAE1ABvXKFAhQAOmO4AvrgMBaa6ULlrlgg0YAiABaQANp7gvh2NAUAblwnJncvHz9QAOFeQkhgsNcPb19goA)

There is one place where the differences begin to become observable though:
readability. In the first example, we have no parameter names for the first
and second elements. While these have no impact on type-checking, the lack of
labels on tuple positions can make them harder to use - harder to communicate
our intent.

That‚Äôs why in TypeScript 4.0, tuples types can now provide labels.

    
    
    ts
    
    type Range = [start: number, end: number];

To deepen the connection between parameter lists and tuple types, the syntax
for rest elements and optional elements mirrors the syntax for parameter
lists.

    
    
    ts
    
    type Foo = [first: number, second?: string, ...rest: any[]];

There are a few rules when using labeled tuples. For one, when labeling a
tuple element, all other elements in the tuple must also be labeled.

    
    
    ts
    
    type Bar = [first: string, number];
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygKwAYAcAWAUAC4CeADpKAEICG0oAvKANoBmAlkgaogdKwHYBzADSg+AVwC2AIxgBdANxA)

It‚Äôs worth noting - labels don‚Äôt require us to name our variables differently
when destructuring. They‚Äôre purely there for documentation and tooling.

    
    
    ts
    
    function foo(x: [first: string, second: number]) {
    
        // ...
    
    ¬†
    
        // note: we didn't need to name these 'first' and 'second'
    
        const [a, b] = x;
    
        a
    
       
    
    const a: string
    
        b
    
       
    
    const b: number
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUAPAXIg2sGAJwGcodTCYwBzAGkWIFMIEATHMEAWwCNHCAugEpEAbwBQiKYgD0MxADol4ydLmIwcKIxwB3RolYxWYAORQNjRq0RQ4GgIZcDUABaMmiUwRJRTiBzAbUyYWINNVKTDSPAd6HgFEAF5EDABuSIDxdUQAPQB+TJ5s+TzCgF8gA)

Overall, labeled tuples are handy when taking advantage of patterns around
tuples and argument lists, along with implementing overloads in a type-safe
way. In fact, TypeScript‚Äôs editor support will try to display them as
overloads when possible.

![Signature help displaying a union of labeled tuples as in a parameter list
as two signatures](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/08/signatureHelpLabeledTuples.gif)

To learn more, check out [the pull
request](https://github.com/microsoft/TypeScript/pull/38234) for labeled tuple
elements.

## Class Property Inference from Constructors

TypeScript 4.0 can now use control flow analysis to determine the types of
properties in classes when [`noImplicitAny`](/tsconfig#noImplicitAny) is
enabled.

    
    
    ts
    
    class Square {
    
      // Previously both of these were any
    
      area;
    
       
    
    (property) Square.area: number
    
      sideLength;
    
          
    
    (property) Square.sideLength: number
    
      constructor(sideLength: number) {
    
        this.sideLength = sideLength;
    
        this.area = sideLength ** 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtAAroBuAlgPaIQgCe0ARlQC4AW0VAZtB2hAwB3NOmhgAdvVzj0YANzZC0AHoB+GRAoATNABk0EgOYdFy9TOBUJEVikTBWVFAAotug8Y4AuaBMQAtkyiAJRYMngcFBAAdO76hiacALzQ8Z5JiniR7NExqGhg0KnpiRzQAFQV0ABMWdAAvtgNQA)

In cases where not all paths of a constructor assign to an instance member,
the property is considered to potentially be `undefined`.

    
    
    ts
    
    class Square {
    
      sideLength;
    
          
    
    (property) Square.sideLength: number | undefined
    
    ¬†
    
      constructor(sideLength: number) {
    
        if (Math.random()) {
    
          this.sideLength = sideLength;
    
        }
    
      }
    
    ¬†
    
      get area() {
    
        return this.sideLength ** 2;
    
    Object is possibly 'undefined'.2532Object is possibly 'undefined'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoAYwBsBDRRUAZQEcBXW6SUAb3NFCIAlgBNIAGUgA7AOYAXABYBuciFAA9APzl+oSnCmI50NpTkIAFMLGTZi1FLYBbAEYwAlL10ChAM1AWALK0igB00LRSInBOFu6efAJJoIpCiKHWEtLyCqAAvIKiWXbK3qAAvrqVujKQcqCckLRxXslccmzQUikKaRlFtjmgAFTD6CoCleVAA)

In cases where you know better (e.g. you have an `initialize` method of some
sort), you‚Äôll still need an explicit type annotation along with a definite
assignment assertion (`!`) if you‚Äôre in
[`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization).

    
    
    ts
    
    class Square {
    
      // definite assignment assertion
    
      //        v
    
      sideLength!: number;
    
      // type annotation
    
    ¬†
    
      constructor(sideLength: number) {
    
        this.initialize(sideLength);
    
      }
    
    ¬†
    
      initialize(sideLength: number) {
    
        this.sideLength = sideLength;
    
      }
    
    ¬†
    
      get area() {
    
        return this.sideLength ** 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtACZoBmAlgHYUAuGkEFA5lQLZpW3SNoq0UA9lVwEieCXgBuopqQAynZrQAWAQgBc0KojYAjPgG5RhSWYB6lq5ZNFaATwAODKlUG0wA4dlHBhEWhREYFpBFAAKOTRFKmUVLR19PgBKLFE8VQoIADpqOgowEAoALzRIigUlVWTjPABfHzw8gUKSsqiYuITdAxRUnElMnI6qlWgAXmgR2NVa6AbRZjRuVDQwcP706HRaRBQqaCHs6bjoACoz6AAmOYa6oA)

For more details, [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/37920).

## Short-Circuiting Assignment Operators

JavaScript, and a lot of other languages, support a set of operators called
_compound assignment_ operators. Compound assignment operators apply an
operator to two arguments, and then assign the result to the left side. You
may have seen these before:

    
    
    ts
    
    // Addition
    
    // a = a + b
    
    a += b;
    
    // Subtraction
    
    // a = a - b
    
    a -= b;
    
    // Multiplication
    
    // a = a * b
    
    a *= b;
    
    // Division
    
    // a = a / b
    
    a /= b;
    
    // Exponentiation
    
    // a = a ** b
    
    a **= b;
    
    // Left Bit Shift
    
    // a = a << b
    
    a <<= b;

So many operators in JavaScript have a corresponding assignment operator! Up
until recently, however, there were three notable exceptions: logical _and_
(`&&`), logical _or_ (`||`), and nullish coalescing (`??`).

That‚Äôs why TypeScript 4.0 supports a new ECMAScript feature to add three new
assignment operators: `&&=`, `||=`, and `??=`.

These operators are great for substituting any example where a user might
write code like the following:

    
    
    ts
    
    a = a && b;
    
    a = a || b;
    
    a = a ?? b;

Or a similar `if` block like

    
    
    ts
    
    // could be 'a ||= b'
    
    if (!a) {
    
      a = b;
    
    }

There are even some patterns we‚Äôve seen (or, uh, written ourselves) to lazily
initialize values, only if they‚Äôll be needed.

    
    
    ts
    
    let values: string[];
    
    (values ?? (values = [])).push("hello");
    
    // After
    
    (values ??= []).push("hello");

(look, we‚Äôre not proud of _all_ the code we write‚Ä¶)

On the rare case that you use getters or setters with side-effects, it‚Äôs worth
noting that these operators only perform assignments if necessary. In that
sense, not only is the right side of the operator ‚Äúshort-circuited‚Äù - the
assignment itself is too.

    
    
    ts
    
    obj.prop ||= foo();
    
    // roughly equivalent to either of the following
    
    obj.prop || (obj.prop = foo());
    
    if (!obj.prop) {
    
        obj.prop = foo();
    
    }

[Try running the following
example](https://www.typescriptlang.org/play?ts=next#code/MYewdgzgLgBCBGArGBeGBvAsAKBnmA5gKawAOATiKQBQCUGO+TMokIANkQHTsgHUAiYlChFyMABYBDCDHIBXMANoBuHI2Z4A9FpgAlIqXZTgRGAFsiAQg2byJeeTAwAslKgSu5KWAAmIczoYAB4YAAYuAFY1XHwAXwAaWxgIEhgKKmoAfQA3KXYALhh4EA4iH3osWM1WCDKePkFUkTFJGTlFZRimOJw4mJwAM0VgKABLcBhB0qCqplr63n4BcjGCCVgIMd8zIjz2eXciXy7k+yhHZygFIhje7BwFzgblgBUJMdlwM3yAdykAJ6yBSQGAeMzNUTkU7YBCILgZUioOBIBGUJEAHwxUxmqnU2Ce3CWgnenzgYDMACo6pZxpYIJSOqDwSkSFCYXC0VQYFi0NMQHQVEA)
to see how that differs from _always_ performing the assignment.

    
    
    ts
    
    const obj = {
    
        get prop() {
    
            console.log("getter has run");
    
    ¬†
    
            // Replace me!
    
            return Math.random() < 0.5;
    
        },
    
        set prop(_val: boolean) {
    
            console.log("setter has run");
    
        }
    
    };
    
    ¬†
    
    function foo() {
    
        console.log("right side evaluated");
    
        return true;
    
    }
    
    ¬†
    
    console.log("This one always runs the setter");
    
    obj.prop = obj.prop || foo();
    
    ¬†
    
    console.log("This one *sometimes* runs the setter");
    
    obj.prop ||= foo();
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBCBGArGBeGBvAUDHMDmAprAA4BOIxAFAJQba4OiQgA2BAdCyHpQESFQoBUjAAWAQwgxSAVzC9qAbkz0GOAPTqYAJQLEW44ARgBbAgEJVa0kRmkwMALLioo9qXFgAJiBM0YADwwAAzsAKzKDAC+ADRWEEQwZBSUAPoAbuIsAFww8CCsBJ60WGq4TBCFnNx8CYLCYpLScgqRuFGYUcqYAGZywFAAluAwPQX+peXglWzVPLykg3iisBCDXsYEmSwyLgRerVY2UHYOULIEyh2YFVVc8wAqooNS4MZZAO7iAJ5SspAwVzGOpCUiHBCIdjJYioOBIKHkGEAHyRo3GShUt1m9z4TxecDAxgAVJUzEMzBAic0AUCYCDhOD4dCYCi0GMQDRFEA)

We‚Äôd like to extend a big thanks to community member [Wenlu
Wang](https://github.com/Kingwl) for this contribution!

For more details, you can [take a look at the pull request
here](https://github.com/microsoft/TypeScript/pull/37727). You can also [check
out TC39‚Äôs proposal repository for this
feature](https://github.com/tc39/proposal-logical-assignment/).

## `unknown` on `catch` Clause Bindings

Since the beginning days of TypeScript, `catch` clause variables have always
been typed as `any`. This meant that TypeScript allowed you to do anything you
wanted with them.

    
    
    ts
    
    try {
    
      // Do some work
    
    } catch (x) {
    
      // x has type 'any' - have fun!
    
      console.log(x.message);
    
      console.log(x.toUpperCase());
    
      x++;
    
      x.yadda.yadda.yadda();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFygBmBTcAUEWoBPUAG8+oUCFAARNKGhoAtrFAY01ZHwC+oEsXKgAFAA8AlGIlSwJ0GQLRQRIQAdVAcgKIh70AFo7AgA3VU5IRABCKxI0REUWADomNABzUwSVaGgCFNgzAG5o2PjYJNT0ojR4FzdqQjgjMwKrEwBqVsLJEwShAgATPoIe-sHhgYJGwu0gA)

The above has some undesirable behavior if we‚Äôre trying to prevent _more_
errors from happening in our error-handling code! Because these variables have
the type `any` by default, they lack any type-safety which could have errored
on invalid operations.

That‚Äôs why TypeScript 4.0 now lets you specify the type of `catch` clause
variables as `unknown` instead. `unknown` is safer than `any` because it
reminds us that we need to perform some sorts of type-checks before operating
on our values.

    
    
    ts
    
    try {
    
      // ...
    
    } catch (e: unknown) {
    
      // Can't access values on unknowns
    
      console.log(e.toUpperCase());
    
    'e' is of type 'unknown'.18046'e' is of type 'unknown'.
    
    ¬†
    
      if (typeof e === "string") {
    
        // We've narrowed 'e' down to the type 'string'.
    
        console.log(e.toUpperCase());
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABdoBPUAbwtFBFADpOKBfUAYwCGVPgAtQACkioArgDsA1rLgB3WQEpGzVmADCA2QHIqoAXz6REiUADcBAG2kXQcWaDmKVsxFr4vEcO0h2OzgAc0l2KjgAVQAHWJg9REhxNTUAbgotAEsAMwkqWgS4fMhQAF5K0AAiRBps2VDqjSYWFjYAdUgDazLZAVgVSAATUANu0GHPUCiZkTLChLG66AbQg3YtFl8vAKCQ8KCouIToJJS0zJZuHiA)

While the types of `catch` variables won‚Äôt change by default, we might
consider a new [`strict`](/tsconfig#strict) mode flag in the future so that
users can opt in to this behavior. In the meantime, it should be possible to
write a lint rule to force `catch` variables to have an explicit annotation of
either `: any` or `: unknown`.

For more details you can [peek at the changes for this
feature](https://github.com/microsoft/TypeScript/pull/39015).

## Custom JSX Factories

When using JSX, a [_fragment_](https://reactjs.org/docs/fragments.html) is a
type of JSX element that allows us to return multiple child elements. When we
first implemented fragments in TypeScript, we didn‚Äôt have a great idea about
how other libraries would utilize them. Nowadays most other libraries that
encourage using JSX and support fragments have a similar API shape.

In TypeScript 4.0, users can customize the fragment factory through the new
[`jsxFragmentFactory`](/tsconfig#jsxFragmentFactory) option.

As an example, the following `tsconfig.json` file tells TypeScript to
transform JSX in a way compatible with React, but switches each factory
invocation to `h` instead of `React.createElement`, and uses `Fragment`
instead of `React.Fragment`.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react",
    
        "[jsxFactory](https://www.typescriptlang.org/tsconfig#jsxFactory)": "h",
    
        "[jsxFragmentFactory](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)": "Fragment"
    
      }
    
    }

In cases where you need to have a different JSX factory on a per-file basis,
you can take advantage of the new `/** @jsxFrag */` pragma comment. For
example, the following‚Ä¶

    
    
    tsx
    
    // Note: these pragma comments need to be written
    
    // with a JSDoc-style multiline syntax to take effect.
    
    ¬†
    
    /** @jsx h */
    
    /** @jsxFrag Fragment */
    
    ¬†
    
    import { h, Fragment } from "preact";
    
    ¬†
    
    export const Header = (
    
      <>
    
        <h1>Welcome</h1>
    
      </>
    
    );
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzgA5CDCQAuODAAWSAUjhgoKAOYgUcNLhBIOMAXA5IkAExkQ4AIyUB3KMBgSOwu09lwtAKQDKAEQg0agEYAE8AGyUQegiYYAjgEzgBMIMUAA9LGRQAayUkTEwkDAA6UgoAKkq4NgArASzPSvIqmvrGgDFVNThu9T0DOBaK0EhYOABvOFkAGj6ewfgAXzhsXDgAIhViGE2AbgqkDPH4HQ5QuAAJVDMkKDgAXjgAClI4OAAeAD53j6-ZABGb4AdSQER0ek+5CBvw+0N+AEp9kA)

‚Ä¶will get transformed to this output JavaScript‚Ä¶

    
    
    tsx
    
    import React from 'react';
    
    export const Header = (React.createElement(React.Fragment, null,
    
        React.createElement("h1", null, "Welcome")));
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzhsBACwgB3biGAxhAOQgwkALjgwxSAUjhgoKAOYgUcNLhBIOMAXA5IkAEw0Q4AI12SoclR2GS5MThTACkAZQARCDRqARgATwAbXRB6RJhgROB7OAF46xQADxcNFABrXSRMTCQMADpSCgAqJpEAKwFioKbyZta2DsKAMQNDOBGjS2s4HsbQSFg4AG84MQAacdGp+ABfOGxcOAAifWIYI4BuRqRChfhzDji4AAlURyQoOABeOAAKUjgcAAPAA+AGA4FiACMIIA6khEuZLEDyNCwYCUWCAJQXIA)

We‚Äôd like to extend a big thanks to community member [Noj
Vek](https://github.com/nojvek) for sending this pull request and patiently
working with our team on it.

You can see that [the pull
request](https://github.com/microsoft/TypeScript/pull/38720) for more details!

## Speed Improvements in `build` mode with `--noEmitOnError`

Previously, compiling a program after a previous compile with errors under
[`incremental`](/tsconfig#incremental) would be extremely slow when using the
[`noEmitOnError`](/tsconfig#noEmitOnError) flag. This is because none of the
information from the last compilation would be cached in a `.tsbuildinfo` file
based on the [`noEmitOnError`](/tsconfig#noEmitOnError) flag.

TypeScript 4.0 changes this which gives a great speed boost in these
scenarios, and in turn improves `--build` mode scenarios (which imply both
[`incremental`](/tsconfig#incremental) and
[`noEmitOnError`](/tsconfig#noEmitOnError)).

For details, [read up more on the pull
request](https://github.com/microsoft/TypeScript/pull/38853).

## `--incremental` with `--noEmit`

TypeScript 4.0 allows us to use the [`noEmit`](/tsconfig#noEmit) flag when
while still leveraging [`incremental`](/tsconfig#incremental) compiles. This
was previously not allowed, as [`incremental`](/tsconfig#incremental) needs to
emit a `.tsbuildinfo` files; however, the use-case to enable faster
incremental builds is important enough to enable for all users.

For more details, you can [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/39122).

## Editor Improvements

The TypeScript compiler doesn‚Äôt only power the editing experience for
TypeScript itself in most major editors - it also powers the JavaScript
experience in the Visual Studio family of editors and more. For that reason,
much of our work focuses on improving editor scenarios - the place you spend
most of your time as a developer.

Using new TypeScript/JavaScript functionality in your editor will differ
depending on your editor, but

  * Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript). Alternatively, there‚Äôs the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) to stay on the bleeding edge (which is typically very stable).
  * Visual Studio 2017/2019 have [the SDK installers above] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild).
  * Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)

You can check out a partial [list of editors that have support for
TypeScript](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-
Support) to learn more about whether your favorite editor has support to use
new versions.

### Convert to Optional Chaining

Optional chaining is a recent feature that‚Äôs received a lot of love. That‚Äôs
why TypeScript 4.0 brings a new refactoring to convert common patterns to take
advantage of [optional
chaining](https://devblogs.microsoft.com/typescript/announcing-
typescript-3-7/#optional-chaining) and [nullish
coalescing](https://devblogs.microsoft.com/typescript/announcing-
typescript-3-7/#nullish-coalescing)!

![Converting a && a.b.c && a.b.c.d.e.f\(\) to
a?.b.c?.d.e.f.\(\)](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/08/convertToOptionalChain-4-0.gif)

Keep in mind that while this refactoring doesn‚Äôt _perfectly_ capture the same
behavior due to subtleties with truthiness/falsiness in JavaScript, we believe
it should capture the intent for most use-cases, especially when TypeScript
has more precise knowledge of your types.

For more details, [check out the pull request for this
feature](https://github.com/microsoft/TypeScript/pull/39135).

### `/** @deprecated */` Support

TypeScript‚Äôs editing support now recognizes when a declaration has been marked
with a `/** @deprecated */` JSDoc comment. That information is surfaced in
completion lists and as a suggestion diagnostic that editors can handle
specially. In an editor like VS Code, deprecated values are typically
displayed a strike-though style ~~like this~~.

![Some examples of deprecated declarations with strikethrough text in the
editor](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/06/deprecated_4-0.png)

This new functionality is available thanks to [Wenlu
Wang](https://github.com/Kingwl). See [the pull
request](https://github.com/microsoft/TypeScript/pull/38523) for more details.

### Partial Semantic Mode at Startup

We‚Äôve heard a lot from users suffering from long startup times, especially on
bigger projects. The culprit is usually a process called _program
construction_. This is the process of starting with an initial set of root
files, parsing them, finding their dependencies, parsing those dependencies,
finding those dependencies‚Äô dependencies, and so on. The bigger your project
is, the longer you‚Äôll have to wait before you can get basic editor operations
like go-to-definition or quick info.

That‚Äôs why we‚Äôve been working on a new mode for editors to provide a _partial_
experience until the full language service experience has loaded up. The core
idea is that editors can run a lightweight partial server that only looks at
the current files that the editor has open.

It‚Äôs hard to say precisely what sorts of improvements you‚Äôll see, but
anecdotally, it used to take anywhere between _20 seconds to a minute_ before
TypeScript would become fully responsive on the Visual Studio Code codebase.
In contrast, **our new partial semantic mode seems to bring that delay down to
just a few seconds**. As an example, in the following video, you can see two
side-by-side editors with TypeScript 3.9 running on the left and TypeScript
4.0 running on the right.

When restarting both editors on a particularly large codebase, the one with
TypeScript 3.9 can‚Äôt provide completions or quick info at all. On the other
hand, the editor with TypeScript 4.0 can _immediately_ give us a rich
experience in the current file we‚Äôre editing, despite loading the full project
in the background.

Currently the only editor that supports this mode is [Visual Studio
Code](http://code.visualstudio.com/) which has some UX improvements coming up
in [Visual Studio Code Insiders](http://code.visualstudio.com/insiders). We
recognize that this experience may still have room for polish in UX and
functionality, and we have [a list of
improvements](https://github.com/microsoft/TypeScript/issues/39035) in mind.
We‚Äôre looking for more feedback on what you think might be useful.

For more information, you can [see the original
proposal](https://github.com/microsoft/TypeScript/issues/37713), [the
implementing pull
request](https://github.com/microsoft/TypeScript/pull/38561), along with [the
follow-up meta issue](https://github.com/microsoft/TypeScript/issues/39035).

### Smarter Auto-Imports

Auto-import is a fantastic feature that makes coding a lot easier; however,
every time auto-import doesn‚Äôt seem to work, it can throw users off a lot. One
specific issue that we heard from users was that auto-imports didn‚Äôt work on
dependencies that were written in TypeScript - that is, until they wrote at
least one explicit import somewhere else in their project.

Why would auto-imports work for `@types` packages, but not for packages that
ship their own types? It turns out that auto-imports only work on packages
your project _already_ includes. Because TypeScript has some quirky defaults
that automatically add packages in `node_modules/@types` to your project,
_those_ packages would be auto-imported. On the other hand, other packages
were excluded because crawling through all your `node_modules` packages can be
_really_ expensive.

All of this leads to a pretty lousy getting started experience for when you‚Äôre
trying to auto-import something that you‚Äôve just installed but haven‚Äôt used
yet.

TypeScript 4.0 now does a little extra work in editor scenarios to include the
packages you‚Äôve listed in your `package.json`‚Äôs `dependencies` (and
`peerDependencies`) fields. The information from these packages is only used
to improve auto-imports, and doesn‚Äôt change anything else like type-checking.
This allows us to provide auto-imports for all of your dependencies that have
types, without incurring the cost of a complete `node_modules` search.

In the rare cases when your `package.json` lists more than ten typed
dependencies that haven‚Äôt been imported yet, this feature automatically
disables itself to prevent slow project loading. To force the feature to work,
or to disable it entirely, you should be able to configure your editor. For
Visual Studio Code, this is the ‚ÄúInclude Package JSON Auto Imports‚Äù (or
`typescript.preferences.includePackageJsonAutoImports`) setting.

![Configuring 'include package JSON auto
imports'](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/08/configurePackageJsonAutoImports4-0.png) For
more details, you can see the [proposal
issue](https://github.com/microsoft/TypeScript/issues/37812) along with [the
implementing pull
request](https://github.com/microsoft/TypeScript/pull/38923).

## Our New Website!

[The TypeScript website](https://www.typescriptlang.org/) has recently been
rewritten from the ground up and rolled out!

![A screenshot of the new TypeScript
website](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2020/08/ts-web.png)

[We already wrote a bit about our new
site](https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-
website/), so you can read up more there; but it‚Äôs worth mentioning that we‚Äôre
still looking to hear what you think! If you have questions, comments, or
suggestions, you can [file them over on the website‚Äôs issue
tracker](https://github.com/microsoft/TypeScript-Website).

## Breaking Changes

### `lib.d.ts` Changes

Our `lib.d.ts` declarations have changed - most specifically, types for the
DOM have changed. The most notable change may be the removal of
[`document.origin`](https://developer.mozilla.org/en-
US/docs/Web/API/Document/origin) which only worked in old versions of IE and
Safari MDN recommends moving to
[`self.origin`](https://developer.mozilla.org/en-
US/docs/Web/API/WindowOrWorkerGlobalScope/origin).

### Properties Overriding Accessors (and vice versa) is an Error

Previously, it was only an error for properties to override accessors, or
accessors to override properties, when using
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields); however,
TypeScript now always issues an error when declaring a property in a derived
class that would override a getter or setter in the base class.

    
    
    ts
    
    class Base {
    
      get foo() {
    
        return 100;
    
      }
    
      set foo(value) {
    
        // ...
    
      }
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      foo = 10;
    
    'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.2610'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYAsBOUAmANkwCgBjAGwENFFQAhGyUAbxNFAHNIAXUAMzhwAFAEpW7DqGi8ArtAB26DBgDckgL6TEvAUOEA3KhVmRxbKaBCgAdHc0kt5arVAARGAEsDkACahIAA8eSAVfOkYdCQ5BOFAAXmV1DSA)
    
    
    ts
    
    class Base {
    
      prop = 10;
    
    }
    
    ¬†
    
    class Derived extends Base {
    
      get prop() {
    
    'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.2611'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.
    
        return 100;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCMWBQBjAGwENFFQAhUyUAb11FAAd4nQBeULABgG5cAvrgIkyoACIwAlgDdIAE1CQAHgBdIAO3nkqiGvUYBzSKuasAFAEo6DRqGgmArtA1dufW0IFA)

See more details on [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/37894).

### Operands for `delete` must be optional.

When using the `delete` operator in
[`strictNullChecks`](/tsconfig#strictNullChecks), the operand must now be
`any`, `unknown`, `never`, or be optional (in that it contains `undefined` in
the type). Otherwise, use of the `delete` operator is an error.

    
    
    ts
    
    interface Thing {
    
      prop: string;
    
    }
    
    ¬†
    
    function f(x: Thing) {
    
      delete x.prop;
    
    The operand of a 'delete' operator must be optional.2790The operand of a 'delete' operator must be optional.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYCcAGAUAJYB2ALjAGYCGAxpKACoAWxA5qAN56igAO8PqRCWisA3HgC+ePOQCuRaiQJwiocgAoAHqiasAlBy6gAJpAA2kMqE0A6PnB7iJQA)

See more details on [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/37921).

### Usage of TypeScript‚Äôs Node Factory is Deprecated

Today TypeScript provides a set of ‚Äúfactory‚Äù functions for producing AST
Nodes; however, TypeScript 4.0 provides a new node factory API. As a result,
for TypeScript 4.0 we‚Äôve made the decision to deprecate these older functions
in favor of the new ones.

For more details, [read up on the relevant pull request for this
change](https://github.com/microsoft/TypeScript/pull/35282).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.0.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(6\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

AB![Andrew Branch
\(2\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

DR![Dan Rose
\(1\)](https://gravatar.com/avatar/d8b62493d4dbc661c91ade7bbd1a7b7f?s=32&&d=blank)

A![any86
\(1\)](https://gravatar.com/avatar/3e46f64abcce62f255b55a54eb67a6dc?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.1

## Template Literal Types

String literal types in TypeScript allow us to model functions and APIs that
expect a set of specific strings.

    
    
    ts
    
    function setVerticalAlignment(location: "top" | "middle" | "bottom") {
    
      // ...
    
    }
    
    ¬†
    
    setVerticalAlignment("middel");
    
    Argument of type '"middel"' is not assignable to parameter of type '"top" | "middle" | "bottom"'.2345Argument of type '"middel"' is not assignable to parameter of type '"top" | "middle" | "bottom"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaIpBQGozVkCGANgIKdUDmJALaQSFABSc4HarVQAiCnAAO80AB9Q8oVQAmuzpDWb5AIzgUlQ+QEpQAbzyhQIUADoPeAL548DZqxUHDx8giJi4tp6upCctgDcQA)

This is pretty nice because string literal types can basically spell-check our
string values.

We also like that string literals can be used as property names in mapped
types. In this sense, they‚Äôre also usable as building blocks:

    
    
    ts
    
    type Options = {
    
      [K in "noImplicitAny" | "strictNullChecks" | "strictFunctionTypes"]?: boolean;
    
    };
    
    // same as
    
    //   type Options = {
    
    //       noImplicitAny?: boolean,
    
    //       strictNullChecks?: boolean,
    
    //       strictFunctionTypes?: boolean
    
    //   };

But there‚Äôs another place that that string literal types could be used as
building blocks: building other string literal types.

That‚Äôs why TypeScript 4.1 brings the template literal string type. It has the
same syntax as [template literal strings in
JavaScript](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Template_literals), but is used in type
positions. When you use it with concrete literal types, it produces a new
string literal type by concatenating the contents.

    
    
    ts
    
    type World = "world";
    
    ¬†
    
    type Greeting = `hello ${World}`;
    
            
    
    type Greeting = "hello world"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)

What happens when you have unions in substitution positions? It produces the
set of every possible string literal that could be represented by each union
member.

    
    
    ts
    
    type Color = "red" | "blue";
    
    type Quantity = "one" | "two";
    
    ¬†
    
    type SeussFish = `${Quantity | Color} fish`;
    
    type SeussFish = "one fish" | "two fish" | "red fish" | "blue fish"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gGzgJygXigImRAJpqAHywCMEBXCTAbgChRIoBFcgQwDtgBLUdLOdlSJZgAdzg1a9cNADKEcgGdFAMS6KAFnwAGAEgDeLDt17F4SZAF8oAM3UbtdAPROobgHoB+IA)

This can be used beyond cute examples in release notes. For example, several
libraries for UI components have a way to specify both vertical and horizontal
alignment in their APIs, often with both at once using a single string like
`"bottom-right"`. Between vertically aligning with `"top"`, `"middle"`, and
`"bottom"`, and horizontally aligning with `"left"`, `"center"`, and
`"right"`, there are 9 possible strings where each of the former strings is
connected with each of the latter strings using a dash.

    
    
    ts
    
    type VerticalAlignment = "top" | "middle" | "bottom";
    
    type HorizontalAlignment = "left" | "center" | "right";
    
    ¬†
    
    // Takes
    
    //   | "top-left"    | "top-center"    | "top-right"
    
    //   | "middle-left" | "middle-center" | "middle-right"
    
    //   | "bottom-left" | "bottom-center" | "bottom-right"
    
    ¬†
    
    declare function setAlignment(value: `${VerticalAlignment}-${HorizontalAlignment}`): void;
    
    ¬†
    
    setAlignment("top-left");   // works!
    
    setAlignment("top-middel"); // error!
    
    Argument of type '"top-middel"' is not assignable to parameter of type '"top-left" | "top-center" | "top-right" | "middle-left" | "middle-center" | "middle-right" | "bottom-left" | "bottom-center" | "bottom-right"'.2345Argument of type '"top-middel"' is not assignable to parameter of type '"top-left" | "top-center" | "top-right" | "middle-left" | "middle-center" | "middle-right" | "bottom-left" | "bottom-center" | "bottom-right"'.
    
    setAlignment("top-pot");    // error! but good doughnuts if you're ever in Seattle
    
    Argument of type '"top-pot"' is not assignable to parameter of type '"top-left" | "top-center" | "top-right" | "middle-left" | "middle-center" | "middle-right" | "bottom-left" | "bottom-center" | "bottom-right"'.2345Argument of type '"top-pot"' is not assignable to parameter of type '"top-left" | "top-center" | "top-right" | "middle-left" | "middle-center" | "middle-right" | "bottom-left" | "bottom-center" | "bottom-right"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAGowECWAxgIYA2AgkzQOYB2AtpFwVABeUACICcEqNAAfMTxoATRU0jS5ogEZwCEnqIDchUuQASCGgC84A5m069+gkaNUAzAurF0nML6OhOAAtPIzwQUAAVBgBrSERwsFBZMQkSAFp3T2TkjTT0nwE-HJTxSXTAjhDRRJyNBWVVTMgPfwaVSALfaDalDorgz1rcsW1dOB5m1tKxvS6inpmdOcrqvDxFSDomBmhyNwBXLjpaG1BESAJ7bj4BAAoAN2YDyFQAAwASAG8qaFpGVjsG5OAC+6W+5kC1lsgIctwIILeAEpUA84EowhcrkDHPcyhksqIkQYchEAO4IGKIACEeCx11xBDu+PS7UgTCJJIiMHg0Fp9Jx8OZ+RIOk5JW5sAQ1NAmgOgg4cDgilAijgByqXHliFANDcoCI6oA5HtQJAHjBdVxQABlSAMXSqIA)

While there are **lots** of examples of this sort of API in the wild, this is
still a bit of a toy example since we could write these out manually. In fact,
for 9 strings, this is likely fine; but when you need a ton of strings, you
should consider automatically generating them ahead of time to save work on
every type-check (or just use `string`, which will be much simpler to
comprehend).

Some of the real value comes from dynamically creating new string literals.
For example, imagine a `makeWatchedObject` API that takes an object and
produces a mostly identical object, but with a new `on` method to detect for
changes to the properties.

    
    
    ts
    
    let person = makeWatchedObject({
    
      firstName: "Homer",
    
      age: 42, // give-or-take
    
      location: "Springfield",
    
    });
    
    person.on("firstNameChanged", () => {
    
      console.log(`firstName was changed!`);
    
    });

Notice that `on` listens on the event `"firstNameChanged"`, not just
`"firstName"`. How would we type this?

    
    
    ts
    
    type PropEventSource<T> = {
    
        on(eventName: `${string & keyof T}Changed`, callback: () => void): void;
    
    };
    
    /// Create a "watched object" with an 'on' method
    
    /// so that you can watch for changes to properties.
    
    declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;

With this, we can build something that errors when we give the wrong property!

    
    
    ts
    
    // error!
    
    person.on("firstName", () => {});
    
    Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "ageChanged" | "locationChanged"'.2345Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "ageChanged" | "locationChanged"'.
    
    ¬†
    
    // error!
    
    person.on("frstNameChanged", () => {});
    
    Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "ageChanged" | "locationChanged"'.2345Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "ageChanged" | "locationChanged"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKgD5QAXlABvPKGmg4jABSQGzAHIBDALaRUAAwAk4xAWgBLRgHNQAMlABrSETgAzUPwC+AYQAWai5AAmOgA0oFxqADbhAEZqXLao8gCUosJ0cCb+iahpGQDceG75-pBc4WrQ5E7sjFwEJnKgGmr2AOpqBFxeAQDyUQBWJQQCgvJw-aj8Wa7WlNT0TKwc3HxC+eGQBKBkSA1iTa3tnT39g-KS0k4mSATqWqgARAAScFrQ90FSoGrm2qBYaCEQKBzCYGABaBBggjNSCfcJwMJ1OQPFgkUwWS6QcL+d4FRL5PBAsHErjsAjEsGEsAweDQACEeG2iDkADo5PJ7pdrrdIO9QEkUhI3Pi8FTQDSEAymaz2ZzuZpIN5fD8cSEBSJhOJhbkgA)

We can also do something special in template literal types: we can _infer_
from substitution positions. We can make our last example generic to infer
from parts of the `eventName` string to figure out the associated property.

    
    
    ts
    
    type PropEventSource<T> = {
    
        on<K extends string & keyof T>
    
            (eventName: `${K}Changed`, callback: (newValue: T[K]) => void ): void;
    
    };
    
    ¬†
    
    declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;
    
    ¬†
    
    let person = makeWatchedObject({
    
        firstName: "Homer",
    
        age: 42,
    
        location: "Springfield",
    
    });
    
    ¬†
    
    // works! 'newName' is typed as 'string'
    
    person.on("firstNameChanged", newName => {
    
        // 'newName' has the type of 'firstName'
    
        console.log(`new name is ${newName.toUpperCase()}`);
    
    });
    
    ¬†
    
    // works! 'newAge' is typed as 'number'
    
    person.on("ageChanged", newAge => {
    
        if (newAge < 0) {
    
            console.log("warning! negative age");
    
        }
    
    })
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACoB8UAvFAN4BQUzUCGJA0lBAB7CYATAM5QhwOAEsMAcygAyKAGsIIBADMolJix0AKCOiwA5AIYBbCAC4oAAwAkdDgF8AwgAsTMiAJsAaKIQmADZBAEYmhIrWuhgQAO4AasF4VpoA2hwAugCUNFSoCBICUNnWBUUA3AxOVQwCEIRBJnDQangYhMASbFBmJsoA6ibAhG7eAPKhAFYNwOQUugjT1mSlmvKwiCiGOPhEpJS1QRDAUJBwQj20fYPDoxPTs7qMOmoSF8CmFtYARAASCAscB+vm0zBM0lSABYAEygnRBBCBLpsX7YMCSGRvCBBAQg6rZWoAeiJUDiCDgiiEAEIoAByWJxL4QOlQCQiUCQYomER0sSY6R0hjnS4YAB0bF0PzeH2Z7k8kLx-kZzLy9DBUBJ9JV5hZUA8HLGUE50HU9JlYmZQp0hDYl2OYsR0l0NkZUAwurZIgcOosYuACAAqmBzi4eRBdNknDZCQTiaTyZSadr4gBBSGs9nG8DeKA87V4MyhCBwIUitgSjBSiEQeVeJXutOQtUvFgSDQxJvQEhQAAMuVbOmYtow9ogjoQzp+cWaGCk0lpsWkwwk6DzkJ+sZ0TgJQA)

Here we made `on` into a generic method. When a user calls with the string
`"firstNameChanged'`, TypeScript will try to infer the right type for `K`. To
do that, it will match `K` against the content prior to `"Changed"` and infer
the string `"firstName"`. Once TypeScript figures that out, the `on` method
can fetch the type of `firstName` on the original object, which is `string` in
this case. Similarly, when we call with `"ageChanged"`, it finds the type for
the property `age` which is `number`).

Inference can be combined in different ways, often to deconstruct strings, and
reconstruct them in different ways. In fact, to help with modifying these
string literal types, we‚Äôve added a few new utility type aliases for modifying
casing in letters (i.e. converting to lowercase and uppercase characters).

    
    
    ts
    
    type EnthusiasticGreeting<T extends string> = `${Uppercase<T>}`
    
    ¬†
    
    type HELLO = EnthusiasticGreeting<"hello">;
    
          
    
    type HELLO = "HELLO"
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogdsAFgVwM4EsCGrjoMYDiAThBLnAOYA8AKlBAB7ARwAmqUOR6lAfFAF4oAAwAkAbwCqYSETzYItXgF9hAKDWhIUABIwAMvoDyg2AhQZsuQiTI9qAIkQQANi4D2D3gG41Aej8oIIA9AH4gA)

The new type aliases are `Uppercase`, `Lowercase`, `Capitalize` and
`Uncapitalize`. The first two transform every character in a string, and the
latter two transform only the first character in a string.

For more details, [see the original pull
request](https://github.com/microsoft/TypeScript/pull/40336) and [the in-
progress pull request to switch to type alias
helpers](https://github.com/microsoft/TypeScript/pull/40580).

## Key Remapping in Mapped Types

Just as a refresher, a mapped type can create new object types based on
arbitrary keys

    
    
    ts
    
    type Options = {
    
      [K in "noImplicitAny" | "strictNullChecks" | "strictFunctionTypes"]?: boolean;
    
    };
    
    // same as
    
    //   type Options = {
    
    //       noImplicitAny?: boolean,
    
    //       strictNullChecks?: boolean,
    
    //       strictFunctionTypes?: boolean
    
    //   };

or new object types based on other object types.

    
    
    ts
    
    /// 'Partial<T>' is the same as 'T', but with each property marked optional.
    
    type Partial<T> = {
    
      [K in keyof T]?: T[K];
    
    };

Until now, mapped types could only produce new object types with keys that you
provided them; however, lots of the time you want to be able to create new
keys, or filter out keys, based on the inputs.

That‚Äôs why TypeScript 4.1 allows you to re-map keys in mapped types with a new
`as` clause.

    
    
    ts
    
    type MappedTypeWithNewKeys<T> = {
    
        [K in keyof T as NewKeyType]: T[K]
    
        //            ^^^^^^^^^^^^^
    
        //            This is the new syntax!
    
    }

With this new `as` clause, you can leverage features like template literal
types to easily create property names based off of old ones.

    
    
    ts
    
    type Getters<T> = {
    
        [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
    
    };
    
    ¬†
    
    interface Person {
    
        name: string;
    
        age: number;
    
        location: string;
    
    }
    
    ¬†
    
    type LazyPerson = Getters<Person>;
    
             
    
    type LazyPerson = {
        getName: () => string;
        getAge: () => number;
        getLocation: () => string;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4AqA+KBeKA3gFBSlQDaA0lAJYB2UA1hCAPYBmUGUAhilAAMA5vAAkBAMI8wNYDwA2NAF4Q0KYEnpCoAMiiUsAXwEBdAFxQAFAEo8ODFRNFDAbiJF6iJOx4BjaAAKyCisDMRkUHQ8ALYQFuqadEJuETwiFnQArtEARsgpZPKsvjzANKHxGlpuhu6gkFAAMjxKIEGooXiw8F7o7SF0WG4A9MNkAHoA-EA)

and you can even filter out keys by producing `never`. That means you don‚Äôt
have to use an extra `Omit` helper type in some cases.

    
    
    ts
    
    // Remove the 'kind' property
    
    type RemoveKindField<T> = {
    
        [K in keyof T as Exclude<K, "kind">]: T[K]
    
    };
    
    ¬†
    
    interface Circle {
    
        kind: "circle";
    
        radius: number;
    
    }
    
    ¬†
    
    type KindlessCircle = RemoveKindField<Circle>;
    
               
    
    type KindlessCircle = {
        radius: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVAHygAvKADe9UAtABtdqHygskWrABmoEaACGAZ1ABRAB4BjfgFcCkIewA0oAES5CbsQF0AXPoqPvQAvgDc9PT4yNQ6hlZIAMI4ZDZIcooaXAFuVilpbhGZZIYEOLbGAXi20ABG1BEhkUxInIT8kMbGyakdUixwiG08fIJCPWliESCKAHoA-EA)

For more information, take a look at [the original pull request over on
GitHub](https://github.com/microsoft/TypeScript/pull/40336).

## Recursive Conditional Types

In JavaScript it‚Äôs fairly common to see functions that can flatten and build
up container types at arbitrary levels. For example, consider the `.then()`
method on instances of `Promise`. `.then(...)` unwraps each promise until it
finds a value that‚Äôs not ‚Äúpromise-like‚Äù, and passes that value to a callback.
There‚Äôs also a relatively new `flat` method on `Array`s that can take a depth
of how deep to flatten.

Expressing this in TypeScript‚Äôs type system was, for all practical intents and
purposes, not possible. While there were hacks to achieve this, the types
ended up looking very unreasonable.

That‚Äôs why TypeScript 4.1 eases some restrictions on conditional types - so
that they can model these patterns. In TypeScript 4.1, conditional types can
now immediately reference themselves within their branches, making it easier
to write recursive type aliases.

For example, if we wanted to write a type to get the element types of nested
arrays, we could write the following `deepFlatten` type.

    
    
    ts
    
    type ElementType<T> = T extends ReadonlyArray<infer U> ? ElementType<U> : T;
    
    function deepFlatten<T extends readonly unknown[]>(x: T): ElementType<T>[] {
    
      throw "not implemented";
    
    }
    
    // All of these return the type 'number[]':
    
    deepFlatten([1, 2, 3]);
    
    deepFlatten([[1], [2, 3]]);
    
    deepFlatten([[1], [[2]], [[[3]]]]);

Similarly, in TypeScript 4.1 we can write an `Awaited` type to deeply unwrap
`Promise`s.

    
    
    ts
    
    type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;
    
    /// Like `promise.then(...)`, but more accurate in types.
    
    declare function customThen<T, U>(
    
      p: Promise<T>,
    
      onFulfilled: (value: Awaited<T>) => U
    
    ): Promise<Awaited<U>>;

Keep in mind that while these recursive types are powerful, but they should be
used responsibly and sparingly.

First off, these types can do a lot of work which means that they can increase
type-checking time. Trying to model numbers in the Collatz conjecture or
Fibonacci sequence might be fun, but don‚Äôt ship that in `.d.ts` files on npm.

But apart from being computationally intensive, these types can hit an
internal recursion depth limit on sufficiently-complex inputs. When that
recursion limit is hit, that results in a compile-time error. In general, it‚Äôs
better not to use these types at all than to write something that fails on
more realistic examples.

See more [at the
implementation](https://github.com/microsoft/TypeScript/pull/40002).

## Checked Indexed Accesses (`--noUncheckedIndexedAccess`)

TypeScript has a feature called _index signatures_. These signatures are a way
to signal to the type system that users can access arbitrarily-named
properties.

    
    
    ts
    
    interface Options {
    
      path: string;
    
      permissions: number;
    
    ¬†
    
      // Extra properties are caught by this index signature.
    
      [propName: string]: string | number;
    
    }
    
    ¬†
    
    function checkOptions(opts: Options) {
    
      opts.path; // string
    
      opts.permissions; // number
    
    ¬†
    
      // These are all allowed too!
    
      // They have the type 'string | number'.
    
      opts.yadda.toString();
    
      opts["foo bar baz"].toString();
    
      opts[Math.random()].toString();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsunGABYBcyeYUoA5gNynnQC2weeO+OiACuXAEbR2HAPTTkAUQAejOOSjZ00LBAJwoKBHGHMqYZGICeyar2SgAJhEX1gzEJWH6AdBwDa6dXQAOTguCDoGJhBmAF0IxhZkAB9kEXFJYgBfYmIYYRAELFxkBCoIBABrDCL8AAoNMDw6aoE8AEoiDga8LwpqVmRZegTorswezSgePlaBobSJKByyIYAVMrwUPS2AGx3kOD3sAHcIe2tsbABCGTl1iCsqOAA3FGo3i01kAHJIxJSFtBvj4yN0vBY4PZ7HAvGBsABlEbMWptdig8a+ABEMEu5j0eIAXpiYrCEUiUWjkN1fABZShULxQOAgezYLgoklwxFRZGorJAA)

In the above example, `Options` has an index signature that says any accessed property that‚Äôs not already listed should have the type `string | number`. This is often convenient for optimistic code that assumes you know what you‚Äôre doing, but the truth is that most values in JavaScript do not support every potential property name. Most types will not, for example, have a value for a property key created by `Math.random()` like in the previous example. For many users, this behavior was undesirable, and felt like it wasn‚Äôt leveraging the full strict-checking of [`strictNullChecks`](/tsconfig#strictNullChecks).

That‚Äôs why TypeScript 4.1 ships with a new flag called [`noUncheckedIndexedAccess`](/tsconfig#noUncheckedIndexedAccess). Under this new mode, every property access (like `foo.bar`) or indexed access (like `foo["bar"]`) is considered potentially undefined. That means that in our last example, `opts.yadda` will have the type `string | number | undefined` as opposed to just `string | number`. If you need to access that property, you‚Äôll either have to check for its existence first or use a non-null assertion operator (the postfix `!` character).
    
    
    ts
    
    function checkOptions(opts: Options) {
    
      opts.path; // string
    
      opts.permissions; // number
    
    ¬†
    
      // These are not allowed with noUncheckedIndexedAccess
    
      opts.yadda.toString();
    
    'opts.yadda' is possibly 'undefined'.18048'opts.yadda' is possibly 'undefined'.
    
      opts["foo bar baz"].toString();
    
    Object is possibly 'undefined'.2532Object is possibly 'undefined'.
    
      opts[Math.random()].toString();
    
    Object is possibly 'undefined'.2532Object is possibly 'undefined'.
    
    ¬†
    
      // Checking if it's really there first.
    
      if (opts.yadda) {
    
        console.log(opts.yadda.toString());
    
      }
    
    ¬†
    
      // Basically saying "trust me I know what I'm doing"
    
      // with the '!' non-null assertion operator.
    
      opts.yadda!.toString();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAltQAuMAGYBDCaADyAB3ky41RKADe5UKC0r5zVInnQ5AcwDcp8zAC2MqXoOpqAV3cAIxgXVyoAUUE7FXN4LRhdSVAVaEhQRhV-B2Z5UCCAT1ArL1A5AUFQRBkHakt-NIA6VwBtLXiAORV3SBs7RwBdPvtqB1AAH1AA4NDyAF9KMABaFcZ-eRWl8iV-Jl19DNYObX2DAAo4HRRNHR9EAEpjV0v5REaLKydQKlsRh2eru8PF5qvpEF8qNMQtByOEwAAVViIdKpdK0PIqAA2mLgAHduKBcTIrFN6EwjpxePwhKJxJJpGYXm8CiouFwVI15HAAMr9UZne4uRlXFoAIiUcDg+VS0oAXqKBpyeXyHAKhaAmS0ALKWZiNaAqfhwdwCxVc3l-NWwsxUADCFMcZSUZXkAHJDGksZiilYYOklDIkPJmmYZM6LoCWWyVI8TGYzIwwXBMZBGjjVUzGlH2UqLY4BYLXAs4aAAEIqaqZbFFRAqAqO0V2fy2UA9UA8UDsWi4wnMSzt13uUBcOCOUUlokk32gV0AQldpOoSwC2JSUkSPg1CQNXOgIa3ryzrPZs9zKqtcyAA)

One consequence of using
[`noUncheckedIndexedAccess`](/tsconfig#noUncheckedIndexedAccess) is that
indexing into an array is also more strictly checked, even in a bounds-checked
loop.

    
    
    ts
    
    function screamLines(strs: string[]) {
    
      // This will have issues
    
      for (let i = 0; i < strs.length; i++) {
    
        console.log(strs[i].toUpperCase());
    
    Object is possibly 'undefined'.2532Object is possibly 'undefined'.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAZgFcmAFwCWcaqESNokAIYBbADLLqkgBSJFSVBejGA5gG0AugEpQAb3KhQVACrNlRFAAd2UAGzDQZh0AN0hQQMQ5SS9QGQRQUzDIRQTQAF5QIgBuPIAeDUtEADps6jtFZlLlAGoWt09vb0Y1RDhs2rg7cyqHZSdqxXoAB2mYAGEdREhTFxdi1IBfck2gA)

If you don‚Äôt need the indexes, you can iterate over individual elements by
using a `for`-`of` loop or a `forEach` call.

    
    
    ts
    
    function screamLines(strs: string[]) {
    
      // This works fine
    
      for (const str of strs) {
    
        console.log(str.toUpperCase());
    
      }
    
    ¬†
    
      // This works fine
    
      strs.forEach((str) => {
    
        console.log(str.toUpperCase());
    
      });
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIMYAsCmCDWKAmBJSWUAPbAQQQRQGdKAoAMwFdEAXAS2klEoQCcUBDALYAZVpCoAKSsx6UAXFxliA5gG0AugEpQAbxqhQIUABUkrSqADu0Hugt0xKfaDo3QEhB2mKeoaHR9KbT0DA09ISmgAGxQAOijoZSkZWOY4AAd0lB4AYX5KFAlNTQBuZwBfGmcjU3MrGzsXR2dpWVjXHgBRfmQJZJ5tAF4APl1nMK9ouISk1tSMrNz8wuKyg3LSmnKgA)

This flag can be handy for catching out-of-bounds errors, but it might be
noisy for a lot of code, so it is not automatically enabled by the
[`strict`](/tsconfig#strict) flag; however, if this feature is interesting to
you, you should feel free to try it and determine whether it makes sense for
your team‚Äôs codebase!

You can learn more [at the implementing pull
request](https://github.com/microsoft/TypeScript/pull/39560).

## `paths` without `baseUrl`

Using path-mapping is fairly common - often it‚Äôs to have nicer imports, often
it‚Äôs to simulate monorepo linking behavior.

Unfortunately, specifying [`paths`](/tsconfig#paths) to enable path-mapping
required also specifying an option called [`baseUrl`](/tsconfig#baseUrl),
which allows bare specifier paths to be reached relative to the
[`baseUrl`](/tsconfig#baseUrl) too. This also often caused poor paths to be
used by auto-imports.

In TypeScript 4.1, the [`paths`](/tsconfig#paths) option can be used without
[`baseUrl`](/tsconfig#baseUrl). This helps avoid some of these issues.

## `checkJs` Implies `allowJs`

Previously if you were starting a checked JavaScript project, you had to set
both [`allowJs`](/tsconfig#allowJs) and [`checkJs`](/tsconfig#checkJs). This
was a slightly annoying bit of friction in the experience, so
[`checkJs`](/tsconfig#checkJs) now implies [`allowJs`](/tsconfig#allowJs) by
default.

[See more details at the pull
request](https://github.com/microsoft/TypeScript/pull/40275).

## React 17 JSX Factories

TypeScript 4.1 supports React 17‚Äôs upcoming `jsx` and `jsxs` factory functions
through two new options for the [`jsx`](/tsconfig#jsx) compiler option:

  * `react-jsx`
  * `react-jsxdev`

These options are intended for production and development compiles
respectively. Often, the options from one can extend from the other. For
example, a `tsconfig.json` for production builds might look like the
following:

    
    
    // ./src/tsconfig.json
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "esnext",
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2015",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx",
    
        "[strict](https://www.typescriptlang.org/tsconfig#strict)": true
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["./**/*"]
    
    }

and one for development builds might look like the following:

    
    
    // ./src/tsconfig.dev.json
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./tsconfig.json",
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsxdev"
    
      }
    
    }

For more information, [check out the corresponding
PR](https://github.com/microsoft/TypeScript/pull/39199).

## Editor Support for the JSDoc `@see` Tag

The JSDoc tag `@see` tag now has better support in editors for TypeScript and
JavaScript. This allows you to use functionality like go-to-definition in a
dotted name following the tag. For example, going to definition on `first` or
`C` in the JSDoc comment just works in the following example:

    
    
    ts
    
    // @filename: first.ts
    
    export class C {}
    
    // @filename: main.ts
    
    import * as first from "./first";
    
    /**
    
     * @see first.C
    
     */
    
    function related() {}

Thanks to frequent contributor [Wenlu Wang](https://github.com/Kingwl) [for
implementing this](https://github.com/microsoft/TypeScript/pull/39760)!

## Breaking Changes

### `lib.d.ts` Changes

`lib.d.ts` may have a set of changed APIs, potentially in part due to how the
DOM types are automatically generated. One specific change is that
`Reflect.enumerate` has been removed, as it was removed from ES2016.

### `abstract` Members Can‚Äôt Be Marked `async`

Members marked as `abstract` can no longer be marked as `async`. The fix here
is to remove the `async` keyword, since callers are only concerned with the
return type.

### `any`/`unknown` Are Propagated in Falsy Positions

Previously, for an expression like `foo && somethingElse`, the type of `foo`
was `any` or `unknown`, the type of the whole that expression would be the
type of `somethingElse`.

For example, previously the type for `x` here was `{ someProp: string }`.

    
    
    ts
    
    declare let foo: unknown;
    
    declare let somethingElse: { someProp: string };
    
    let x = foo && somethingElse;

However, in TypeScript 4.1, we are more careful about how we determine this
type. Since nothing is known about the type on the left side of the `&&`, we
propagate `any` and `unknown` outward instead of the type on the right side.

The most common pattern we saw of this tended to be when checking
compatibility with `boolean`s, especially in predicate functions.

    
    
    ts
    
    function isThing(x: any): boolean {
    
      return x && typeof x === "object" && x.blah === "foo";
    
    }

Often the appropriate fix is to switch from `foo && someExpression` to `!!foo
&& someExpression`.

### `resolve`‚Äôs Parameters Are No Longer Optional in `Promise`s

When writing code like the following

    
    
    ts
    
    new Promise((resolve) => {
    
      doSomethingAsync(() => {
    
        doSomething();
    
        resolve();
    
      });
    
    });

You may get an error like the following:

    
    
      resolve()
    
      ~~~~~~~~~
    
    error TS2554: Expected 1 arguments, but got 0.
    
      An argument for 'value' was not provided.

This is because `resolve` no longer has an optional parameter, so by default,
it must now be passed a value. Often this catches legitimate bugs with using
`Promise`s. The typical fix is to pass it the correct argument, and sometimes
to add an explicit type argument.

    
    
    ts
    
    new Promise<number>((resolve) => {
    
      //     ^^^^^^^^
    
      doSomethingAsync((value) => {
    
        doSomething();
    
        resolve(value);
    
        //      ^^^^^
    
      });
    
    });

However, sometimes `resolve()` really does need to be called without an
argument. In these cases, we can give `Promise` an explicit `void` generic
type argument (i.e. write it out as `Promise<void>`). This leverages new
functionality in TypeScript 4.1 where a potentially-`void` trailing parameter
can become optional.

    
    
    ts
    
    new Promise<void>((resolve) => {
    
      //     ^^^^^^
    
      doSomethingAsync(() => {
    
        doSomething();
    
        resolve();
    
      });
    
    });

TypeScript 4.1 ships with a quick fix to help fix this break.

### Conditional Spreads Create Optional Properties

In JavaScript, object spreads (like `{ ...foo }`) don‚Äôt operate over falsy
values. So in code like `{ ...foo }`, `foo` will be skipped over if it‚Äôs
`null` or `undefined`.

Many users take advantage of this to spread in properties ‚Äúconditionally‚Äù.

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age: number;
    
      location: string;
    
    }
    
    interface Animal {
    
      name: string;
    
      owner: Person;
    
    }
    
    function copyOwner(pet?: Animal) {
    
      return {
    
        ...(pet && pet.owner),
    
        otherStuff: 123,
    
      };
    
    }
    
    // We could also use optional chaining here:
    
    function copyOwner(pet?: Animal) {
    
      return {
    
        ...pet?.owner,
    
        otherStuff: 123,
    
      };
    
    }

Here, if `pet` is defined, the properties of `pet.owner` will be spread in -
otherwise, no properties will be spread into the returned object.

The return type of `copyOwner` was previously a union type based on each
spread:

    
    
    { x: number } | { x: number, name: string, age: number, location: string }

This modeled exactly how the operation would occur: if `pet` was defined, all
the properties from `Person` would be present; otherwise, none of them would
be defined on the result. It was an all-or-nothing operation.

However, we‚Äôve seen this pattern taken to the extreme, with hundreds of
spreads in a single object, each spread potentially adding in hundreds or
thousands of properties. It turns out that for various reasons, this ends up
being extremely expensive, and usually for not much benefit.

In TypeScript 4.1, the returned type sometimes uses all-optional properties.

    
    
    {
    
        x: number;
    
        name?: string;
    
        age?: number;
    
        location?: string;
    
    }

This ends up performing better and generally displaying better too.

For more details, [see the original
change](https://github.com/microsoft/TypeScript/pull/40778). While this
behavior is not entirely consistent right now, we expect a future release will
produce cleaner and more predictable results.

### Unmatched parameters are no longer related

TypeScript would previously relate parameters that didn‚Äôt correspond to each
other by relating them to the type `any`. With [changes in TypeScript
4.1](https://github.com/microsoft/TypeScript/pull/41308), the language now
skips this process entirely. This means that some cases of assignability will
now fail, but it also means that some cases of overload resolution can fail as
well. For example, overload resolution on `util.promisify` in Node.js may
select a different overload in TypeScript 4.1, sometimes causing new or
different errors downstream.

As a workaround, you may be best using a type assertion to squelch errors.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.1.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(1\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

H![HumanEquivalentUnit
\(1\)](https://gravatar.com/avatar/c5030db4ea03531507e55b57faa74838?s=32&&d=blank)

OT![Orta Therox
\(1\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.2

## Smarter Type Alias Preservation

TypeScript has a way to declare new names for types called type aliases. If you‚Äôre writing a set of functions that all work on `string | number | boolean`, you can write a type alias to avoid repeating yourself over and over again.
    
    
    ts
    
    type BasicPrimitive = number | string | boolean;

TypeScript has always used a set of rules and guesses for when to reuse type
aliases when printing out types. For example, take the following code snippet.

    
    
    ts
    
    export type BasicPrimitive = number | string | boolean;
    
    export function doStuff(value: BasicPrimitive) {
    
      let x = value;
    
      return x;
    
    }

If we hover our mouse over `x` in an editor like Visual Studio, Visual Studio
Code, or [the TypeScript
Playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuAFBzQkWHABmjengoR6cACYQAyjEarVACkoZxjYAC502fEVLkqwAJRwA3nLj+4SXgQODorG2B5ALgoYBMoXRB5AF8gA),
we‚Äôll get a quick info panel that shows the type `BasicPrimitive`. Likewise,
if we get the declaration file output (`.d.ts` output) for this file,
TypeScript will say that `doStuff` returns `BasicPrimitive`.

However, what happens if we return a `BasicPrimitive` or `undefined`?

    
    
    ts
    
    export type BasicPrimitive = number | string | boolean;
    
    export function doStuff(value: BasicPrimitive) {
    
      if (Math.random() < 0.5) {
    
        return undefined;
    
      }
    
      return value;
    
    }

We can see what happens [in the TypeScript 4.1 playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuALAAoRQHplcABIRqHCPTgByACYQAyjEYAzC-pHBxEAO4IIPYKgcALDPAAqyYCZ4xGDwhjhYYOIYiFhwFtAIHqhQwOZQekgoAHQqagDqqGQCHvBe1HCgKHgwwIZw5M5wYPzw2Lm5cJ2YuITEZBTl3Iz0hsAWOPS1HR0sjPBs9k5+KIHB8AAsWQBMADT18BO8UnVhEVExcG0Kqh2dTKzswrz8QtyiElJ6QyNjE1PXykUlWg8Asw2qOF0cGMZksFgAFJQMOJGMAAFzobD4IikchUYAASjgAG9FJ1yTgLHB4QBZbweLJQaTGEjwokAHjgAAYsgBWImkhTk4WdFJpPTDUbjSaGeRC4UAX0UZOFYsY6TgSJRwDlcAVQA). While we might want TypeScript to display the return type of `doStuff` as `BasicPrimitive | undefined`, it instead displays `string | number | boolean | undefined`! What gives?

Well this has to do with how TypeScript represents types internally. When creating a union type out of one or more union types, it will always _normalize_ those types into a new flattened union type - but doing that loses information. The type-checker would have to find every combination of types from `string | number | boolean | undefined` to see what type aliases could have been used, and even then, there might be multiple type aliases to `string | number | boolean`.

In TypeScript 4.2, our internals are a little smarter. We keep track of how
types were constructed by keeping around parts of how they were originally
written and constructed over time. We also keep track of, and differentiate,
type aliases to instances of other aliases!

Being able to print back the types based on how you used them in your code
means that as a TypeScript user, you can avoid some unfortunately humongous
types getting displayed, and that often translates to getting better `.d.ts`
file output, error messages, and in-editor type displays in quick info and
signature help. This can help TypeScript feel a little bit more approachable
for newcomers.

For more information, check out [the first pull request that improves various
cases around preserving union type
aliases](https://github.com/microsoft/TypeScript/pull/42149), along with [a
second pull request that preserves indirect
aliases](https://github.com/microsoft/TypeScript/pull/42284).

## Leading/Middle Rest Elements in Tuple Types

In TypeScript, tuple types are meant to model arrays with specific lengths and
element types.

    
    
    ts
    
    // A tuple that stores a pair of numbers
    
    let a: [number, number] = [1, 2];
    
    // A tuple that stores a string, a number, and a boolean
    
    let b: [string, number, boolean] = ["hello", 42, true];

Over time, TypeScript‚Äôs tuple types have become more and more sophisticated,
since they‚Äôre also used to model things like parameter lists in JavaScript. As
a result, they can have optional elements and rest elements, and can even have
labels for tooling and readability.

    
    
    ts
    
    // A tuple that has either one or two strings.
    
    let c: [string, string?] = ["hello"];
    
    c = ["hello", "world"];
    
    ¬†
    
    // A labeled tuple that has either one or two strings.
    
    let d: [first: string, second?: string] = ["hello"];
    
    d = ["hello", "world"];
    
    ¬†
    
    // A tuple with a *rest element* - holds at least 2 strings at the front,
    
    // and any number of booleans at the back.
    
    let e: [string, string, ...boolean[]];
    
    ¬†
    
    e = ["hello", "world"];
    
    e = ["hello", "world", false];
    
    e = ["hello", "world", true, false, true];
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEEFQFwVwBwDYFNoAsCGVQYM6iQJZSpIBOoA9gHYoXlQDuFoOUpBVA5jgHQBQyLAGMAXKADardlwA0LNh04B+ALqgAvBIBEJBAgpaVAbj5CN23fq1ytTUggAmhk3xARQCdACMkyB9HhkNExsdDxCYjJKGkp6Jnlpbn5BUAcxcQAzAlJWMSlFORwkIWoHJTyFLjVNcR1fK2M+fxq6vQMbO0dnPlcwSFhEFAYiVFB0UAAqUiRWfGQAWyQqKAnQAFpsCkc8EOQwrAAmBMUdrEjQDNJqKBlesap-dCoAT1AqGHmfcgoM0C8KLZIJ6nNAoLzoIQAa2SSCwSHS+VkxyRPFR-0BT3EKkafBQLUs7VAtjoXUaeIs9UJxPsTjkGXQCCKZPMtQJ1iJnVp0FIMCQdIZRTkbF5xiAA)

In TypeScript 4.2, rest elements specifically been expanded in how they can be
used. In prior versions, TypeScript only allowed `...rest` elements at the
very last position of a tuple type.

However, now rest elements can occur _anywhere_ within a tuple - with only a
few restrictions.

    
    
    ts
    
    let foo: [...string[], number];
    
    ¬†
    
    foo = [123];
    
    foo = ["hello", 123];
    
    foo = ["hello!", "hello!", "hello!", 123];
    
    ¬†
    
    let bar: [boolean, ...string[], boolean];
    
    ¬†
    
    bar = [true, false];
    
    bar = [true, "some text", false];
    
    bar = [true, "some", "separated", "text", false];
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZg9jBcEDaA6NBnMAnAlgOwHMkBdAGgjwFcBbAIxC2IG4AoF2GCAXmQEYAmAMzN2cbsgBEACxDBgMCeQHDWHcUmmz5AQkURNcmLvIGde5SJahItAIZZESWnFC285NCky5CJcs5hXPEs7LHVsShByKFtgdBARUPCsSJN0GGoQCDAQAA8wPRi4hNYkniQIqP10zL0JeIAHe1scgBM6nPzC2PjmIA)

The only restriction is that a rest element can be placed anywhere in a tuple,
so long as it‚Äôs not followed by another optional element or rest element. In
other words, only one rest element per tuple, and no optional elements after
rest elements.

    
    
    ts
    
    interface Clown {
    
      /*...*/
    
    }
    
    interface Joker {
    
      /*...*/
    
    }
    
    ¬†
    
    let StealersWheel: [...Clown[], "me", ...Joker[]];
    
    A rest element cannot follow another rest element.1265A rest element cannot follow another rest element.
    
    ¬†
    
    let StringsAndMaybeBoolean: [...string[], boolean?];
    
    An optional element cannot follow a rest element.1266An optional element cannot follow a rest element.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYBsBWd2sAoASwDsAXGAMwEMBjSUAYQBs4B3U0Ab0NFGAAqAHSjBwQgF8SFavUYApOAGsYPPgJFiJ0wi0jlQAZUo19SAOoALSJBaoA2qOGsOpBwF0ANKABEAW0hfH2clVWhPDwBuQj0DY3JoMgBzRABBUgATAFkaAE8AI0gAITg4fRpSR2dERJTPHwKyitIAfmigA)

These non-trailing rest elements can be used to model functions that take any
number of leading arguments, followed by a few fixed ones.

    
    
    ts
    
    declare function doStuff(...args: [...names: string[], shouldCapitalize: boolean]): void;
    
    ¬†
    
    doStuff(/*shouldCapitalize:*/ false)
    
    doStuff("fee", "fi", "fo", "fum", /*shouldCapitalize:*/ true);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtX2BwGUNlFEAKAOhtgHMBnALngG0arUoBbEZ+BhhhZUdVgF0ANAIAWOZBGABhKAAcsGKBCwAvECwBGOHBBBRU4gJQsAbjizAA3AChnhEmUoB6AFQM5CspqGlq6+j5eSFoMIJZuxKTkFABEiCAgydKpWJnwqTi5qcjcub7+8ooq6praekwR8ELIsY5AA)

Even though JavaScript doesn‚Äôt have any syntax to model leading rest
parameters, we were still able to declare `doStuff` as a function that takes
leading arguments by declaring the `...args` rest parameter with _a tuple type
that uses a leading rest element_. This can help model lots of existing
JavaScript out there!

For more details, [see the original pull
request](https://github.com/microsoft/TypeScript/pull/41544).

## Stricter Checks For The `in` Operator

In JavaScript, it is a runtime error to use a non-object type on the right
side of the `in` operator. TypeScript 4.2 ensures this can be caught at
design-time.

    
    
    ts
    
    "foo" in 42;
    
    Type 'number' is not assignable to type 'object'.2322Type 'number' is not assignable to type 'object'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsBGdG00AoAIgDM44TQBLAO1ABY0BuIA)

This check is fairly conservative for the most part, so if you have received
an error about this, it is likely an issue in the code.

A big thanks to our external contributor [Jonas
H√ºbotter](https://github.com/jonhue) for [their pull
request](https://github.com/microsoft/TypeScript/pull/41928)!

## `--noPropertyAccessFromIndexSignature`

Back when TypeScript first introduced index signatures, you could only get
properties declared by them with ‚Äúbracketed‚Äù element access syntax like
`person["name"]`.

    
    
    ts
    
    interface SomeType {
    
      /** This is an index signature. */
    
      [propName: string]: any;
    
    }
    
    ¬†
    
    function doStuff(value: SomeType) {
    
      let x = value["someProperty"];
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoHsC2EAqBPABxQG8AoZZAegCprkcALYAZ2ReThDZABMIAPZM2ABzEHDABXKBAB0yapXLIA2gSjoCAOTjYAXELBRQIgLoHOeANykAvqVIxJIBGGDouPdKikwYACgA3OAAbSQgDDGx8IgBKZDIKEIgwZEEAXmRgsIgVACJmLAgABQ0iKDA8PNMbWyA)

This ended up being cumbersome in situations where we need to work with
objects that have arbitrary properties. For example, imagine an API where it‚Äôs
common to misspell a property name by adding an extra `s` character at the
end.

    
    
    ts
    
    interface Options {
    
      /** File patterns to be excluded. */
    
      exclude?: string[];
    
    ¬†
    
      /**
    
       * It handles any extra properties that we haven't declared as type 'any'.
    
       */
    
      [x: string]: any;
    
    }
    
    ¬†
    
    function processOptions(opts: Options) {
    
      // Notice we're *intentionally* accessing `excludes`, not `exclude`
    
      if (opts.excludes) {
    
        console.error(
    
          "The option `excludes` is not valid. Did you mean `exclude`?"
    
        );
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF8LGFEQBCxcQOCkPDwMHvwAChCwPC1hnHwASiJLcmQAOWwsJGQ4lOy5UEhwWbgGBi8aRAG8A2QAA2UxSTwbgBpkEHXb+9UbxWAYZHGmDw0i+jwWJDIZAQuDw2CYIKgwSgoxskIARAAVJwoCazT7CB4RG7IYAEd6OBLHYAyZAAEWpyC82FEyAAthBXPiVJIbmo0ai5uYyG0WkA)

To make these types of situations easier, a while back, TypeScript made it
possible to use ‚Äúdotted‚Äù property access syntax like `person.name` when a type
had a string index signature. This also made it easier to transition existing
JavaScript code over to TypeScript.

However, loosening the restriction also meant that misspelling an explicitly
declared property became much easier.

    
    
    ts
    
    function processOptions(opts: Options) {
    
      // ...
    
    ¬†
    
      // Notice we're *accidentally* accessing `excludes` this time.
    
      // Oops! Totally valid.
    
      for (const excludePattern of opts.excludes) {
    
        // ...
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF9icnJkAFoehFEwHq7iGFEQBCxcQOCkPDwMCfwAChCwPC15nHwASiJLTukDizIO5AA5bCwkZDiU7LlEBGBJcDgGBi8aB4i8A2QAA2UYkkeD+XCcwEiwAAthAysdOqgQngAITIAAqF1e72QCVeTzhyBg2CgyEWCFwOl8KkkAAVWOwQMhsDAmZg8NJAao8DsSGR4cgDgS2i0gA)

In some cases, users would prefer to explicitly opt into the index signature -
they would prefer to get an error message when a dotted property access
doesn‚Äôt correspond to a specific property declaration.

That‚Äôs why TypeScript introduces a new flag called
[`noPropertyAccessFromIndexSignature`](/tsconfig#noPropertyAccessFromIndexSignature).
Under this mode, you‚Äôll be opted in to TypeScript‚Äôs older behavior that issues
an error. This new setting is not under the [`strict`](/tsconfig#strict)
family of flags, since we believe users will find it more useful on certain
codebases than others.

You can understand this feature in more detail by reading up on the
corresponding [pull
request](https://github.com/microsoft/TypeScript/pull/40171/). We‚Äôd also like
to extend a big thanks to [Wenlu Wang](https://github.com/Kingwl) who sent us
this pull request!

## `abstract` Construct Signatures

TypeScript allows us to mark a class as _abstract_. This tells TypeScript that
the class is only meant to be extended from, and that certain members need to
be filled in by any subclass to actually create an instance.

    
    
    ts
    
    abstract class Shape {
    
      abstract getArea(): number;
    
    }
    
    ¬†
    
    new Shape();
    
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.
    
    ¬†
    
    class Square extends Shape {
    
      #sideLength: number;
    
    ¬†
    
      constructor(sideLength: number) {
    
        super();
    
        this.#sideLength = sideLength;
    
      }
    
    ¬†
    
      getArea() {
    
        return this.#sideLength ** 2;
    
      }
    
    }
    
    ¬†
    
    // Works fine.
    
    new Square(42);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cuFZADuLdlyV7cdBk2YBHNflmhIADxKQVAEweW3HwCAMSIAJa+kAAyPmIkrKqa2tA2AhRwKsJqVAjyEVGxKvGJoOpaMIq8-AKgiGpc0NY1AgnhiAB0YZExcQmgALx1PUUlegKGNRLSsgpVwbWyJGrQKqBtnd2FfaygAFR76OOghpMgoADqCADWTABm4SYdxmYszq6Q8gAsaIo6QA)

To make sure this restriction in `new`-ing up `abstract` classes is
consistently applied, you can‚Äôt assign an `abstract` class to anything that
expects a construct signature.

    
    
    ts
    
    interface HasArea {
    
      getArea(): number;
    
    }
    
    ¬†
    
    let Ctor: new () => HasArea = Shape;
    
    Type 'typeof Shape' is not assignable to type 'new () => HasArea'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.2322Type 'typeof Shape' is not assignable to type 'new () => HasArea'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEMAjRAF2jwGNjRyAbPRRUAZQAs8AHSUAbx1FEIkylUAHNIxAILRIeABQBKVADsArgFsCMANw4AvjhCgAtKfKrip4zgCWy4jABmFLgAl602Tz5iJn+Uqgapo6+jg4NBKgAMLECCqQAO6giqAAvAB8oO6I-unMbJzaQA)

This does the right thing in case we intend to run code like `new Ctor`, but
it‚Äôs overly-restrictive in case we want to write a subclass of `Ctor`.

    
    
    ts
    
    abstract class Shape {
    
      abstract getArea(): number;
    
    }
    
    ¬†
    
    interface HasArea {
    
      getArea(): number;
    
    }
    
    ¬†
    
    function makeSubclassWithArea(Ctor: new () => HasArea) {
    
      return class extends Ctor {
    
        getArea() {
    
          return 42
    
        }
    
      };
    
    }
    
    ¬†
    
    let MyShape = makeSubclassWithArea(Shape);
    
    Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAIYBGiALtAQMamiUA2BiioAygBYEAOkoA3nqFDEyFaqADmkUgEFokAgAoAlKgB2AVwC2RGAG48AXzx4AlqtIwAZlR4AJRrPl8BEqY8UrQG7XsPHL6qrUJnCqoJoEANaQLOpE9IyIAOompGzuCgDCpAhqkADuoMqgALwAfKD2iO5KzoJypOrQYQlMoJAAHhaqACbM2Qh1gq4ych5Dw6ANTWFYaC6CRov6Rnh0UqAAsgCe7Fw8JeFRMXGtyanpYwp73Eq6QA)

It also doesn‚Äôt work well with built-in helper types like `InstanceType`.

    
    
    ts
    
    type MyInstance = InstanceType<typeof Shape>;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cIUAFozFNSTMncJAJ5dQAWTsBJFaXwqK3ALyh3T29IABUHSAAeey44ADMWdi4APh0gA)

That‚Äôs why TypeScript 4.2 allows you to specify an `abstract` modifier on
constructor signatures.

    
    
    ts
    
    interface HasArea {
    
        getArea(): number;
    
    }
    
    ¬†
    
    // Works!
    
    let Ctor: abstract new () => HasArea = Shape;
    
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygC2ABwFMEBvAKAQVEhngQHMCIBBKA4ACgEoAuBAOwCuAWxAEoAblIBfUgHpZCALTLYAiMsWkAlnwhiAZnCIAJNCzYlyFeo3Mce-YaInTSchQHUA9lADWYAEJSZEYEAGEIH14qaDhEPgIAdwQuBABeAD4EUzA7dKxcQnEgA)

Adding the `abstract` modifier to a construct signature signals that you can
pass in `abstract` constructors. It doesn‚Äôt stop you from passing in other
classes/constructor functions that are ‚Äúconcrete‚Äù - it really just signals
that there‚Äôs no intent to run the constructor directly, so it‚Äôs safe to pass
in either class type.

This feature allows us to write _mixin factories_ in a way that supports
abstract classes. For example, in the following code snippet, we‚Äôre able to
use the mixin function `withStyles` with the `abstract` class `SuperClass`.

    
    
    ts
    
    abstract class SuperClass {
    
        abstract someMethod(): void;
    
        badda() {}
    
    }
    
    ¬†
    
    type AbstractConstructor<T> = abstract new (...args: any[]) => T
    
    ¬†
    
    function withStyles<T extends AbstractConstructor<object>>(Ctor: T) {
    
        abstract class StyledClass extends Ctor {
    
            getStyles() {
    
                // ...
    
            }
    
        }
    
        return StyledClass;
    
    }
    
    ¬†
    
    class SubClass extends withStyles(SuperClass) {
    
        someMethod() {
    
            this.someMethod()
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygVwA4FMoBhVdBAbwCgEaFRIZ4EwB7AW3wFl8IALFgCYAKAJQAuBADcWASwEBuarRDABA4KIoBfSjsoQAngQQBBcNDgQiLAHYNs8FlAA8AFQB8CALx1zjRDb4AO4IQgB0EcBQAOZgEsA2BgDaALoi3p6ulJQAZtg28DK2CEEyfJiGyPhgbgj4AB4Q+DYCGGYMltZ20A4QTs4sIABW+PDu7kJEfVASrulUtL4dTChoGBUGVQIka3WNza0IU04USos00TwbVWCaC+cPAPSPCBFhZ+c6i1+0UDzYUBsWEq+G2pDAij0qzIOBAOzIDSaLQwpXKINuOAIxHB8w+rA43D4gjuH0WfBkYDC+K4PH4whEHx0WiAA)

Note that `withStyles` is demonstrating a specific rule, where a class (like
`StyledClass`) that extends a value that‚Äôs generic and bounded by an abstract
constructor (like `Ctor`) has to also be declared `abstract`. This is because
there‚Äôs no way to know if a class with _more_ abstract members was passed in,
and so it‚Äôs impossible to know whether the subclass implements all the
abstract members.

You can read up more on abstract construct signatures [on its pull
request](https://github.com/microsoft/TypeScript/pull/36392).

## Understanding Your Project Structure With `--explainFiles`

A surprisingly common scenario for TypeScript users is to ask ‚Äúwhy is
TypeScript including this file?‚Äú. Inferring the files of your program turns
out to be a complicated process, and so there are lots of reasons why a
specific combination of `lib.d.ts` got used, why certain files in
`node_modules` are getting included, and why certain files are being included
even though we thought specifying [`exclude`](/tsconfig#exclude) would keep
them out.

That‚Äôs why TypeScript now provides an [`explainFiles`](/tsconfig#explainFiles)
flag.

    
    
    sh
    
    tsc --explainFiles

When using this option, the TypeScript compiler will give some very verbose
output about why a file ended up in your program. To read it more easily, you
can forward the output to a file, or pipe it to a program that can easily view
it.

    
    
    sh
    
    # Forward output to a text file
    
    tsc --explainFiles > explanation.txt
    
    # Pipe output to a utility program like `less`, or an editor like VS Code
    
    tsc --explainFiles | less
    
    tsc --explainFiles | code -

Typically, the output will start out by listing out reasons for including
`lib.d.ts` files, then for local files, and then `node_modules` files.

    
    
    TS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts
    
      Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts
    
      Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts
    
      Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts
    
      Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts
    
      Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts
    
      Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts
    
      Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'
    
    TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts
    
      Library 'lib.esnext.d.ts' specified in compilerOptions
    
    ... More Library References...
    
    foo.ts
    
      Matched by include pattern '**/*' in 'tsconfig.json'

Right now, we make no guarantees about the output format - it might change
over time. On that note, we‚Äôre interested in improving this format if you have
any suggestions!

For more information, [check out the original pull
request](https://github.com/microsoft/TypeScript/pull/40011)!

## Improved Uncalled Function Checks in Logical Expressions

Thanks to further improvements from [Alex
Tarasyuk](https://github.com/a-tarasyuk), TypeScript‚Äôs uncalled function
checks now apply within `&&` and `||` expressions.

Under [`strictNullChecks`](/tsconfig#strictNullChecks), the following code
will now error.

    
    
    ts
    
    function shouldDisplayElement(element: Element) {
    
      // ...
    
      return true;
    
    }
    
    function getVisibleItems(elements: Element[]) {
    
      return elements.filter((e) => shouldDisplayElement && e.children.length);
    
      //                          ~~~~~~~~~~~~~~~~~~~~
    
      // This condition will always return true since the function is always defined.
    
      // Did you mean to call it instead.
    
    }

For more details, [check out the pull request
here](https://github.com/microsoft/TypeScript/issues/40197).

## Destructured Variables Can Be Explicitly Marked as Unused

Thanks to another pull request from [Alex
Tarasyuk](https://github.com/a-tarasyuk), you can now mark destructured
variables as unused by prefixing them with an underscore (the `_` character).

    
    
    ts
    
    let [_first, second] = getValues();

Previously, if `_first` was never used later on, TypeScript would issue an
error under [`noUnusedLocals`](/tsconfig#noUnusedLocals). Now, TypeScript will
recognize that `_first` was intentionally named with an underscore because
there was no intent to use it.

For more details, take a look at [the full
change](https://github.com/microsoft/TypeScript/pull/41378).

## Relaxed Rules Between Optional Properties and String Index Signatures

String index signatures are a way of typing dictionary-like objects, where you
want to allow access with arbitrary keys:

    
    
    ts
    
    const movieWatchCount: { [key: string]: number } = {};
    
    ¬†
    
    function watchMovie(title: string) {
    
      movieWatchCount[title] = (movieWatchCount[title] ?? 0) + 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtiAbgSwKYHUCGVgAsDCIArmFAFwwDeMA2gNaoCeF0ATsmAOYC6FYRcAEapWMAL4wAvFTEBuAFDyAZiWBRk4GAHdseALJI0ACnVQANqhZR2XAJRV5MeIYy6CxUjVMXuUmEYQUVxx3EigvZHNUXwB+GJgABnsAahgARgUxIA)

Of course, for any movie title not yet in the dictionary,
`movieWatchCount[title]` will be `undefined` (TypeScript 4.1 added the option
[`noUncheckedIndexedAccess`](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-4-1.html#checked-indexed-accesses---nouncheckedindexedaccess)
to include `undefined` when reading from an index signature like this). Even
though it‚Äôs clear that there must be some strings not present in
`movieWatchCount`, previous versions of TypeScript treated optional object
properties as unassignable to otherwise compatible index signatures, due to
the presence of `undefined`.

    
    
    ts
    
    type WesAndersonWatchCount = {
    
      "Fantastic Mr. Fox"?: number;
    
      "The Royal Tenenbaums"?: number;
    
      "Moonrise Kingdom"?: number;
    
      "The Grand Budapest Hotel"?: number;
    
    };
    
    ¬†
    
    declare const wesAndersonWatchCount: WesAndersonWatchCount;
    
    const movieWatchCount: { [key: string]: number } = wesAndersonWatchCount;
    
    //    ~~~~~~~~~~~~~~~ error!
    
    // Type 'WesAndersonWatchCount' is not assignable to type '{ [key: string]: number; }'.
    
    //    Property '"Fantastic Mr. Fox"' is incompatible with index signature.
    
    //      Type 'number | undefined' is not assignable to type 'number'.
    
    //        Type 'undefined' is not assignable to type 'number'. (2322)
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6hDOBBAdgEwgJ3ge2TAhsAMYAWAwtgK7LBQC8UA3gFBRQBEAYvjfvMAEsiUALIYAdFE7YAHuwD8ALijJKAWwBGmANysOAFRLQASthD4ANlH0RktjfnXwFy1Zp172I7LgwD40ADSAsgA5qjYai4q6loYumzshtAA4hg8qFAAQpSo+JD8UAAS2MAQFtFucboAvrrM6EQW+BjQRLiFAO4IKOhYuATE5FQ0ynBIaJg4eISkFNTAuu3IhWrYAG4CEINzI8DKjFAA2gDWECDK-H5hALqusZhQNfRQ3RN90zvDC7oA9L9sNgAPxBoLB4KgmAw2AwAEJmP9rOBoAByca9KYDWbfGgoqD+FSlKB8eACULIfAaCzQYDYKCgSBQFGHU7nS7Aa6hO4xdzxJ4o8QIgGAgAK0MgGFATK4PGAfEEwjEkmkcjxBJC7TUYEIAip0E6AmAJHxkxkUFJ5MIlFagsRgLY+mRTKqjwAPlBqOgAGYhCCoNXwQm0Elkil6+l0hmol0YAVC+32x2MlGeiA+uz+-GB5BEkOW8O0+lOlExgVQAAUACYAMyVysASiAA)

TypeScript 4.2 allows this assignment. However, it does _not_ allow the
assignment of non-optional properties with `undefined` in their types, nor
does it allow writing `undefined` to a specific key:

    
    
    ts
    
    type BatmanWatchCount = {
    
      "Batman Begins": number | undefined;
    
      "The Dark Knight": number | undefined;
    
      "The Dark Knight Rises": number | undefined;
    
    };
    
    ¬†
    
    declare const batmanWatchCount: BatmanWatchCount;
    
    ¬†
    
    // Still an error in TypeScript 4.2.
    
    const movieWatchCount: { [key: string]: number } = batmanWatchCount;
    
    Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.
      Property '"Batman Begins"' is incompatible with index signature.
        Type 'number | undefined' is not assignable to type 'number'.
          Type 'undefined' is not assignable to type 'number'.2322Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.
      Property '"Batman Begins"' is incompatible with index signature.
        Type 'number | undefined' is not assignable to type 'number'.
          Type 'undefined' is not assignable to type 'number'.
    
    ¬†
    
    // Still an error in TypeScript 4.2.
    
    // Index signatures don't implicitly allow explicit `undefined`.
    
    movieWatchCount["It's the Great Pumpkin, Charlie Brown"] = undefined;
    
    Type 'undefined' is not assignable to type 'number'.2322Type 'undefined' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lACEBDPAWwoDsB1KgYwAsBhOAVzr1AF5QAbxyhQAIko165SAHMAlnUTjUdLtQBGMUAB9QPACaQAZksiGA3KIkAVVqQAiFaAGtQAaToK5rPKtB1LR19I1NzKxtxeycXdy8fP1AAJQVESBU1DW1oPQM6YzM6C2sAX2scY2YAGxdSZjhlPk0qWkYWDm5eVCk2pjw2Th48CpBQAGU8BWrq0BkYeFylUFtiSHHmaAUiPgAWADo0fZwGptBqOAA3BUh+wa68VCFQAG1XSAJURDwtujkAXSywVypQEoBa0naA06w1GYEm01m81gCFAy1WJA2Wx2oAORxwYwAkgVIAAPUCIHx0KhcaAZUCGRoAcj4CmoRGqCmYCjw1QIcxmcAA7qAyRyuTzQAADMJFCxS44Xa63DpDXgvcSEvBMxCgPAOUAAcTpVFAAAUNERXEoADSgdisFyc0hkeBCujif5g2URSxAA)

The new rule also does not apply to number index signatures, since they are
assumed to be array-like and dense:

    
    
    ts
    
    declare let sortOfArrayish: { [key: number]: string };
    
    declare let numberKeys: { 42?: string };
    
    ¬†
    
    sortOfArrayish = numberKeys;
    
    Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.
      Property '42' is incompatible with index signature.
        Type 'string | undefined' is not assignable to type 'string'.
          Type 'undefined' is not assignable to type 'string'.2322Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.
      Property '42' is incompatible with index signature.
        Type 'string | undefined' is not assignable to type 'string'.
          Type 'undefined' is not assignable to type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABNIBjAGwENpJRjIAXURBGgeQDMBBWUgTwEtEALVAG9QAbQDWkLqgB2AVwC2AIxgBdVIhrQeMgOagAvgG58RMhSq1Q85TADSUlKBEAWNAH4NWnfuM4cDNDM7Jy8AqAAvNaKKtAOXIhGQA)

You can get a better sense of this change [by reading up on the original
PR](https://github.com/microsoft/TypeScript/pull/41921).

## Declare Missing Helper Function

Thanks to [a community pull
request](https://github.com/microsoft/TypeScript/pull/41215) from [Alexander
Tarasyuk](https://github.com/a-tarasyuk), we now have a quick fix for
declaring new functions and methods based on the call-site!

![An un-declared function foo being called, with a quick fix scaffolding out
the new contents of the file](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/01/addMissingFunction-4.2.gif)

## Breaking Changes

We always strive to minimize breaking changes in a release. TypeScript 4.2
contains some breaking changes, but we believe they should be manageable in an
upgrade.

### `lib.d.ts` Updates

As with every TypeScript version, declarations for `lib.d.ts` (especially the
declarations generated for web contexts), have changed. There are various
changes, though `Intl` and `ResizeObserver`‚Äôs may end up being the most
disruptive.

### `noImplicitAny` Errors Apply to Loose `yield` Expressions

When the value of a `yield` expression is captured, but TypeScript can‚Äôt
immediately figure out what type you intend for it to receive (i.e. the
`yield` expression isn‚Äôt contextually typed), TypeScript will now issue an
implicit `any` error.

    
    
    ts
    
    function* g1() {
    
      const value = yield 1;
    
    'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.7057'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.
    
    }
    
    ¬†
    
    function* g2() {
    
      // No error.
    
      // The result of `yield 1` is unused.
    
      yield 1;
    
    }
    
    ¬†
    
    function* g3() {
    
      // No error.
    
      // `yield 1` is contextually typed by 'string'.
    
      const value: string = yield 1;
    
    }
    
    ¬†
    
    function* g4(): Generator<number, void, string> {
    
      // No error.
    
      // TypeScript can figure out the type of `yield 1`
    
      // from the explicit return type of `g4`.
    
      const value = yield 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYCsaBQAzAVwDsBjAFwEs5iAqUAcwEYAKASlAG9dRRSbE5UADcAhgBtCkUAF5QAT0qRxAE1BMA3LgC+uAiQrU6jAEzsuPUCFAA5OKBjxoAOkvWAKgAtp0SIkLiQnD4oAAGispqTKGglIigJISIkCquvBGq6lq6+mRUNPQMAMzm3LzWdg6wCGlWYOFKmdGx8fzE5JAAHuSEEuLyoOTyAA4poABGAwDkgtCUxAxTtW2CIhJSqLPzDLIKjVHZekR5RoUALOyoAOKQxDCi5AgAPMSEALbjMAA0InCUKj8tgsAHwWcpgSqOGpuMDuEaQADKpDmwyEpFExFA+EoDEIvlAcEIQnI3kG8IJIQakXUoRhWPgb0GpK6w3ElFIlCEvh60ExQ1GFLCDDOoWWAiEYkk0jkGQOOiAA)

See more details in [the corresponding
changes](https://github.com/microsoft/TypeScript/pull/41348).

### Expanded Uncalled Function Checks

As described above, uncalled function checks will now operate consistently
within `&&` and `||` expressions when using
[`strictNullChecks`](/tsconfig#strictNullChecks). This can be a source of new
breaks, but is typically an indication of a logic error in existing code.

### Type Arguments in JavaScript Are Not Parsed as Type Arguments

Type arguments were already not allowed in JavaScript, but in TypeScript 4.2,
the parser will parse them in a more spec-compliant way. So when writing the
following code in a JavaScript file:

    
    
    ts
    
    f<T>(100);

TypeScript will parse it as the following JavaScript:

    
    
    js
    
    f < T > 100;

This may impact you if you were leveraging TypeScript‚Äôs API to parse type
constructs in JavaScript files, which may have occurred when trying to parse
Flow files.

See [the pull request](https://github.com/microsoft/TypeScript/pull/41928) for
more details on what‚Äôs checked.

### Tuple size limits for spreads

Tuple types can be made by using any sort of spread syntax (`...`) in
TypeScript.

    
    
    ts
    
    // Tuple types with spread elements
    
    type NumStr = [number, string];
    
    type NumStrNumStr = [...NumStr, ...NumStr];
    
    // Array spread expressions
    
    const numStr = [123, "hello"] as const;
    
    const numStrNumStr = [...numStr, ...numStr] as const;

Sometimes these tuple types can accidentally grow to be huge, and that can
make type-checking take a long time. Instead of letting the type-checking
process hang (which is especially bad in editor scenarios), TypeScript has a
limiter in place to avoid doing all that work.

You can [see this pull
request](https://github.com/microsoft/TypeScript/pull/42448) for more details.

### `.d.ts` Extensions Cannot Be Used In Import Paths

In TypeScript 4.2, it is now an error for your import paths to contain `.d.ts`
in the extension.

    
    
    ts
    
    // must be changed to something like
    
    //   - "./foo"
    
    //   - "./foo.js"
    
    import { Foo } from "./foo.d.ts";

Instead, your import paths should reflect whatever your loader will do at
runtime. Any of the following imports might be usable instead.

    
    
    ts
    
    import { Foo } from "./foo";
    
    import { Foo } from "./foo.js";
    
    import { Foo } from "./foo/index.js";

### Reverting Template Literal Inference

This change removed a feature from TypeScript 4.2 beta. If you haven‚Äôt yet
upgraded past our last stable release, you won‚Äôt be affected, but you may
still be interested in the change.

The beta version of TypeScript 4.2 included a change in inference to template
strings. In this change, template string literals would either be given
template string types or simplify to multiple string literal types. These
types would then _widen_ to `string` when assigning to mutable variables.

    
    
    ts
    
    declare const yourName: string;
    
    // 'bar' is constant.
    
    // It has type '`hello ${string}`'.
    
    const bar = `hello ${yourName}`;
    
    // 'baz' is mutable.
    
    // It has type 'string'.
    
    let baz = `hello ${yourName}`;

This is similar to how string literal inference works.

    
    
    ts
    
    // 'bar' has type '"hello"'.
    
    const bar = "hello";
    
    // 'baz' has type 'string'.
    
    let baz = "hello";

For that reason, we believed that making template string expressions have
template string types would be ‚Äúconsistent‚Äù; however, from what we‚Äôve seen and
heard, that isn‚Äôt always desirable.

In response, we‚Äôve reverted this feature (and potential breaking change). If
you _do_ want a template string expression to be given a literal-like type,
you can always add `as const` to the end of it.

    
    
    ts
    
    declare const yourName: string;
    
    // 'bar' has type '`hello ${string}`'.
    
    const bar = `hello ${yourName}` as const;
    
    //                              ^^^^^^^^
    
    // 'baz' has type 'string'.
    
    const baz = `hello ${yourName}`;

### TypeScript‚Äôs `lift` Callback in `visitNode` Uses a Different Type

TypeScript has a `visitNode` function that takes a `lift` function. `lift` now
expects a `readonly Node[]` instead of a `NodeArray<Node>`. This is
technically an API breaking change which you can read more on
[here](https://github.com/microsoft/TypeScript/pull/42000).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.2.md) ‚ù§

Contributors to this page:  

EL![Eliran Levi
\(1\)](https://gravatar.com/avatar/8a81d3dd6957e01e288d05ebdd66466d?s=32&&d=blank)

AG![Anton Gilgur
\(1\)](https://gravatar.com/avatar/20827df1809becc22927b5ef5dfcde8d?s=32&&d=blank)

AB![Andrew Branch
\(1\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

GG![Gabriel Goller
\(1\)](https://gravatar.com/avatar/a5613220666ab3d7f6986c45f8476f6b?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.3

## Separate Write Types on Properties

In JavaScript, it‚Äôs pretty common for APIs to convert values that are passed
in before storing them. This often happens with getters and setters too. For
example, let‚Äôs imagine we‚Äôve got a class with a setter that always converts a
value into a `number` before saving it in a private field.

    
    
    js
    
    class Thing {
    
      #size = 0;
    
    ¬†
    
      get size() {
    
        return this.#size;
    
      }
    
      set size(value) {
    
        let num = Number(value);
    
    ¬†
    
        // Don't allow NaN and stuff.
    
        if (!Number.isFinite(num)) {
    
          this.#size = 0;
    
          return;
    
        }
    
    ¬†
    
        this.#size = num;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKTB3AJxYBXfsmjMkEAHQFiJOrgC+DCCzZyOANzAghJHtly4Qa5EIC2FaADkLAIxL8tOvVzp9oAek-QAIgHtkAHJWHRB-AHcbMGtoMGQAEzZmIQAzVKkPRFToDgBCW3MHfilECAAxFERmEg4zcy4DD1wJMpl2MkpaZuhBFNEFI2UPVulZUit6weVFIA)

How would we type this JavaScript code in TypeScript? Well, technically we
don‚Äôt have to do anything special here - TypeScript can look at this with no
explicit types and can figure out that `size` is a number.

The problem is that `size` allows you to assign more than just `number`s to
it. We could get around this by saying that `size` has the type `unknown` or
`any` like in this snippet:

    
    
    ts
    
    class Thing {
    
      // ...
    
      get size(): unknown {
    
        return this.#size;
    
      }
    
    }

But that‚Äôs no good - `unknown` forces people reading `size` to do a type
assertion, and `any` won‚Äôt catch any mistakes. If we really want to model APIs
that convert values, previous versions of TypeScript forced us to pick between
being precise (which makes reading values easier, and writing harder) and
being permissive (which makes writing values easier, and reading harder).

That‚Äôs why TypeScript 4.3 allows you to specify types for reading and writing
to properties.

    
    
    ts
    
    class Thing {
    
      #size = 0;
    
    ¬†
    
      get size(): number {
    
        return this.#size;
    
      }
    
    ¬†
    
      set size(value: string | number | boolean) {
    
        let num = Number(value);
    
    ¬†
    
        // Don't allow NaN and stuff.
    
        if (!Number.isFinite(num)) {
    
          this.#size = 0;
    
          return;
    
        }
    
    ¬†
    
        this.#size = num;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6OkA)

In the above example, our `set` accessor takes a broader set of types
(`string`s, `boolean`s, and `number`s), but our `get` accessor always
guarantees it will be a `number`. Now we can finally assign other types to
these properties with no errors!

    
    
    ts
    
    let thing = new Thing();
    
    ¬†
    
    // Assigning other types to `thing.size` works!
    
    thing.size = "hello";
    
    thing.size = true;
    
    thing.size = 42;
    
    ¬†
    
    // Reading `thing.size` always produces a number!
    
    let mySize: number = thing.size;
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6eunQALSXwALMl+dYoUpIaIckpQgO3MlnAIJQiKhkA5oJ5lBIlABPAAOJBgzE80AABnM0KpFojoMVPOIANYQDpYFGoNGaSIAIngJBARTJdCJJIOlDsVjpz2Ji0iABYAEzfDIAJT8VWByLZDJIGIsxTAEJgUPEniqAmAsMqLh64gJjyEEIAypo+OE3JF6YsaEA)

When considering how two properties with the same name relate to each other,
TypeScript will only use the ‚Äúreading‚Äù type (e.g. the type on the `get`
accessor above). ‚ÄúWriting‚Äù types are only considered when directly writing to
a property.

Keep in mind, this isn‚Äôt a pattern that‚Äôs limited to classes. You can write
getters and setters with different types in object literals.

    
    
    ts
    
    function makeThing(): Thing {
    
      let size = 0;
    
      return {
    
        get size(): number {
    
          return size;
    
        },
    
        set size(value: string | number | boolean) {
    
          let num = Number(value);
    
          // Don't allow NaN and stuff.
    
          if (!Number.isFinite(num)) {
    
            size = 0;
    
            return;
    
          }
    
          size = num;
    
        },
    
      };
    
    }

In fact, we‚Äôve added syntax to interfaces/object types to support different
reading/writing types on properties.

    
    
    ts
    
    // Now valid!
    
    interface Thing {
    
        get size(): number
    
        set size(value: number | string | boolean);
    
    }

One limitation of using different types for reading and writing properties is
that the type for reading a property has to be assignable to the type that
you‚Äôre writing. In other words, the getter type has to be assignable to the
setter. This ensures some level of consistency, so that a property is always
assignable to itself.

For more information on this feature, take a look at [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/42425).

## `override` and the `--noImplicitOverride` Flag

When extending classes in JavaScript, the language makes it super easy (pun
intended) to override methods - but unfortunately, there are some mistakes
that you can run into.

One big one is missing renames. For example, take the following classes:

    
    
    ts
    
    class SomeComponent {
    
      show() {
    
        // ...
    
      }
    
      hide() {
    
        // ...
    
      }
    
    }
    
    class SpecializedComponent extends SomeComponent {
    
      show() {
    
        // ...
    
      }
    
      hide() {
    
        // ...
    
      }
    
    }

`SpecializedComponent` subclasses `SomeComponent`, and overrides the `show`
and `hide` methods. What happens if someone decides to rip out `show` and
`hide` and replace them with a single method?

    
    
    diff
    
     class SomeComponent {
    
    -    show() {
    
    -        // ...
    
    -    }
    
    -    hide() {
    
    -        // ...
    
    -    }
    
    +    setVisible(value: boolean) {
    
    +        // ...
    
    +    }
    
     }
    
     class SpecializedComponent extends SomeComponent {
    
         show() {
    
             // ...
    
         }
    
         hide() {
    
             // ...
    
         }
    
     }

_Oh no!_ Our `SpecializedComponent` didn‚Äôt get updated. Now it‚Äôs just adding
these two useless `show` and `hide` methods that probably won‚Äôt get called.

Part of the issue here is that a user can‚Äôt make it clear whether they meant
to add a new method, or to override an existing one. That‚Äôs why TypeScript 4.3
adds the `override` keyword.

    
    
    ts
    
    class SpecializedComponent extends SomeComponent {
    
        override show() {
    
            // ...
    
        }
    
        override hide() {
    
            // ...
    
        }
    
    }

When a method is marked with `override`, TypeScript will always make sure that
a method with the same name exists in a the base class.

    
    
    ts
    
    class SomeComponent {
    
        setVisible(value: boolean) {
    
            // ...
    
        }
    
    }
    
    class SpecializedComponent extends SomeComponent {
    
        override show() {
    
    This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.4113This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.
    
    ¬†
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg4GZL1kAho0agAytHgEAwhMTRIBSFlABvSqA2hGBLADVUjVACNkBABR4ByAK4FWR6NFMDIASlXrNXmgDo-njQBfSmD+IRFRRAJMK1QALwIyGSR5RWUCAA8sRTIIiWlZVKUPL2hCEnICLQALaAB3M3c1ANBgwKA)

This is a big improvement, but it doesn‚Äôt help if you _forget_ to write
`override` on a method - and that‚Äôs a big mistake users can run into also.

For example, you might accidentally ‚Äútrample over‚Äù a method that exists in a
base class without realizing it.

    
    
    ts
    
    class Base {
    
      someHelperMethod() {
    
        // ...
    
      }
    
    }
    
    class Derived extends Base {
    
      // Oops! We weren't trying to override here,
    
      // we just needed to write a local helper method.
    
      someHelperMethod() {
    
        // ...
    
      }
    
    }

That‚Äôs why TypeScript 4.3 _also_ provides a new
[`noImplicitOverride`](/tsconfig#noImplicitOverride) flag. When this option is
turned on, it becomes an error to override any method from a superclass unless
you explicitly use an `override` keyword. In that last example, TypeScript
would error under [`noImplicitOverride`](/tsconfig#noImplicitOverride), and
give us a clue that we probably need to rename our method inside of `Derived`.

We‚Äôd like to extend our thanks to our community for the implementation here.
The work for these items was implemented in [a pull
request](https://github.com/microsoft/TypeScript/pull/39669) by [Wenlu
Wang](https://github.com/Kingwl), though an earlier pull request implementing
only the `override` keyword by [Paul Cody Johnston](https://github.com/pcj)
served as a basis for direction and discussion. We extend our gratitude for
putting in the time for these features.

## Template String Type Improvements

In recent versions, TypeScript introduced a new type construct: template
string types. These are types that either construct new string-like types by
concatenating‚Ä¶

    
    
    ts
    
    type Color = "red" | "blue";
    
    type Quantity = "one" | "two";
    
    type SeussFish = `${Quantity | Color} fish`;
    
    // same as
    
    //   type SeussFish = "one fish" | "two fish"
    
    //                  | "red fish" | "blue fish";

‚Ä¶or match patterns of other string-like types.

    
    
    ts
    
    declare let s1: `${number}-${number}-${number}`;
    
    declare let s2: `1-2-3`;
    
    // Works!
    
    s1 = s2;

The first change we made is just in when TypeScript will infer a template
string type. When a template string is _contextually typed_ by a string-
literal-like type (i.e. when TypeScript sees we‚Äôre passing a template string
to something that takes a literal type) it will try to give that expression a
template type.

    
    
    ts
    
    function bar(s: string): `hello ${string}` {
    
        // Previously an error, now works!
    
        return `hello ${s}`;
    
    }

This also kicks in when inferring types, and the type parameter `extends
string`

    
    
    ts
    
    declare let s: string;
    
    declare function f<T extends string>(x: T): T;
    
    // Previously: string
    
    // Now       : `hello ${string}`
    
    let x2 = f(`hello ${s}`);

The second major change here is that TypeScript can now better-relate, and
_infer between_ , different template string types.

To see this, take the following example code:

    
    
    ts
    
    declare let s1: `${number}-${number}-${number}`;
    
    declare let s2: `1-2-3`;
    
    declare let s3: `${number}-2-3`;
    
    s1 = s2;
    
    s1 = s3;

When checking against a string literal type like on `s2`, TypeScript could
match against the string contents and figure out that `s2` was compatible with
`s1` in the first assignment; however, as soon as it saw another template
string, it just gave up. As a result, assignments like `s3` to `s1` just
didn‚Äôt work.

TypeScript now actually does the work to prove whether or not each part of a
template string can successfully match. You can now mix and match template
strings with different substitutions and TypeScript will do a good job to
figure out whether they‚Äôre really compatible.

    
    
    ts
    
    declare let s1: `${number}-${number}-${number}`;
    
    declare let s2: `1-2-3`;
    
    declare let s3: `${number}-2-3`;
    
    declare let s4: `1-${number}-3`;
    
    declare let s5: `1-2-${number}`;
    
    declare let s6: `${number}-2-${number}`;
    
    // Now *all of these* work!
    
    s1 = s2;
    
    s1 = s3;
    
    s1 = s4;
    
    s1 = s5;
    
    s1 = s6;

In doing this work, we were also sure to add better inference capabilities.
You can see an example of these in action:

    
    
    ts
    
    declare function foo<V extends string>(arg: `*${V}*`): V;
    
    function test<T extends string>(s: string, n: number, b: boolean, t: T) {
    
        let x1 = foo("*hello*");            // "hello"
    
        let x2 = foo("**hello**");          // "*hello*"
    
        let x3 = foo(`*${s}*` as const);    // string
    
        let x4 = foo(`*${n}*` as const);    // `${number}`
    
        let x5 = foo(`*${b}*` as const);    // "true" | "false"
    
        let x6 = foo(`*${t}*` as const);    // `${T}`
    
        let x7 = foo(`**${s}**` as const);  // `*${string}*`
    
    }

For more information, see [the original pull request on leveraging contextual
types](https://github.com/microsoft/TypeScript/pull/43376), along with [the
pull request that improved inference and checking between template
types](https://github.com/microsoft/TypeScript/pull/43361).

## ECMAScript `#private` Class Elements

TypeScript 4.3 expands which elements in a class can be given `#private`
`#names` to make them truly private at run-time. In addition to properties,
methods and accessors can also be given private names.

    
    
    ts
    
    class Foo {
    
      #someMethod() {
    
        //...
    
      }
    
      get #someValue() {
    
        return 100;
    
      }
    
      publicMethod() {
    
        // These work.
    
        // We can access private-named members inside this class.
    
        this.#someMethod();
    
        return this.#someValue;
    
      }
    
    }
    
    new Foo().#someMethod();
    
    //        ~~~~~~~~~~~
    
    // error!
    
    // Property '#someMethod' is not accessible
    
    // outside class 'Foo' because it has a private identifier.
    
    new Foo().#someValue;
    
    //        ~~~~~~~~~~
    
    // error!
    
    // Property '#someValue' is not accessible
    
    // outside class 'Foo' because it has a private identifier.

Even more broadly, static members can now also have private names.

    
    
    ts
    
    class Foo {
    
      static #someMethod() {
    
        // ...
    
      }
    
    }
    
    Foo.#someMethod();
    
    //  ~~~~~~~~~~~
    
    // error!
    
    // Property '#someMethod' is not accessible
    
    // outside class 'Foo' because it has a private identifier.

This feature was authored [in a pull
request](https://github.com/microsoft/TypeScript/pull/42458) from our friends
at Bloomberg - written by [Titian Cernicova-
Dragomir](https://github.com/dragomirtitian)and [Kubilay
Kahveci](https://github.com/mkubilayk), with support and expertise from [Joey
Watts](https://github.com/joeywatts), [Rob
Palmer](https://github.com/robpalme), and [Tim
McClure](https://github.com/tim-mc). We‚Äôd like to extend our thanks to all of
them!

## `ConstructorParameters` Works on Abstract Classes

In TypeScript 4.3, the `ConstructorParameters` type helper now works on
`abstract` classes.

    
    
    ts
    
    abstract class C {
    
      constructor(a: string, b: number) {
    
        // ...
    
      }
    
    }
    
    // Has the type '[a: string, b: number]'.
    
    type CParams = ConstructorParameters<typeof C>;

This is thanks to work done in TypeScript 4.2, where construct signatures can
be marked as abstract:

    
    
    ts
    
    type MyConstructorOf<T> = {
    
        abstract new(...args: any[]): T;
    
    }
    
    // or using the shorthand syntax:
    
    type MyConstructorOf<T> = abstract new (...args: any[]) => T;

You can [see the change in more detail on
GitHub](https://github.com/microsoft/TypeScript/pull/43380).

## Contextual Narrowing for Generics

TypeScript 4.3 now includes some slightly smarter type-narrowing logic on
generic values. This allows TypeScript to accept more patterns, and sometimes
even catch mistakes.

For some motivation, let‚Äôs say we‚Äôre trying to write a function called
`makeUnique`. It‚Äôll take a `Set` or an `Array` of elements, and if it‚Äôs given
an `Array`, it‚Äôll sort that `Array` remove duplicates according to some
comparison function. After all that, it will return the original collection.

    
    
    ts
    
    function makeUnique<T>(
    
      collection: Set<T> | T[],
    
      comparer: (x: T, y: T) => number
    
    ): Set<T> | T[] {
    
      // Early bail-out if we have a Set.
    
      // We assume the elements are already unique.
    
      if (collection instanceof Set) {
    
        return collection;
    
      }
    
      // Sort the array, then remove consecutive duplicates.
    
      collection.sort(comparer);
    
      for (let i = 0; i < collection.length; i++) {
    
        let j = i;
    
        while (
    
          j < collection.length &&
    
          comparer(collection[i], collection[j + 1]) === 0
    
        ) {
    
          j++;
    
        }
    
        collection.splice(i + 1, j - i);
    
      }
    
      return collection;
    
    }

Let‚Äôs leave questions about this function‚Äôs implementation aside, and assume it arose from the requirements of a broader application. Something that you might notice is that the signature doesn‚Äôt capture the original type of `collection`. We can do that by adding a type parameter called `C` in place of where we‚Äôve written `Set<T> | T[]`.
    
    
    diff
    
    - function makeUnique<T>(collection: Set<T> | T[], comparer: (x: T, y: T) => number): Set<T> | T[]
    
    + function makeUnique<T, C extends Set<T> | T[]>(collection: C, comparer: (x: T, y: T) => number): C

In TypeScript 4.2 and earlier, you‚Äôd end up with a bunch of errors as soon as
you tried this.

    
    
    ts
    
    function makeUnique<T, C extends Set<T> | T[]>(
    
      collection: C,
    
      comparer: (x: T, y: T) => number
    
    ): C {
    
      // Early bail-out if we have a Set.
    
      // We assume the elements are already unique.
    
      if (collection instanceof Set) {
    
        return collection;
    
      }
    
      // Sort the array, then remove consecutive duplicates.
    
      collection.sort(comparer);
    
      //         ~~~~
    
      // error: Property 'sort' does not exist on type 'C'.
    
      for (let i = 0; i < collection.length; i++) {
    
        //                             ~~~~~~
    
        // error: Property 'length' does not exist on type 'C'.
    
        let j = i;
    
        while (
    
          j < collection.length &&
    
          comparer(collection[i], collection[j + 1]) === 0
    
        ) {
    
          //                    ~~~~~~
    
          // error: Property 'length' does not exist on type 'C'.
    
          //                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~
    
          // error: Element implicitly has an 'any' type because expression of type 'number'
    
          //        can't be used to index type 'Set<T> | T[]'.
    
          j++;
    
        }
    
        collection.splice(i + 1, j - i);
    
        //         ~~~~~~
    
        // error: Property 'splice' does not exist on type 'C'.
    
      }
    
      return collection;
    
    }

Ew, errors! Why is TypeScript being so mean to us?

The issue is that when we perform our `collection instanceof Set` check, we‚Äôre expecting that to act as a type guard that narrows the type from `Set<T> | T[]` to `Set<T>` and `T[]` depending on the branch we‚Äôre in; however, we‚Äôre not dealing with a `Set<T> | T[]`, we‚Äôre trying to narrow the generic value `collection`, whose type is `C`.

It‚Äôs a very subtle distinction, but it makes a difference. TypeScript can‚Äôt just grab the constraint of `C` (which is `Set<T> | T[]`) and narrow that. If TypeScript _did_ try to narrow from `Set<T> | T[]`, it would forget that `collection` is also a `C` in each branch because there‚Äôs no easy way to preserve that information. If hypothetically TypeScript tried that approach, it would break the above example in a different way. At the return positions, where the function expects values with the type `C`, we would instead get a `Set<T>` and a `T[]` in each branch, which TypeScript would reject.
    
    
    ts
    
    function makeUnique<T>(
    
      collection: Set<T> | T[],
    
      comparer: (x: T, y: T) => number
    
    ): Set<T> | T[] {
    
      // Early bail-out if we have a Set.
    
      // We assume the elements are already unique.
    
      if (collection instanceof Set) {
    
        return collection;
    
        //     ~~~~~~~~~~
    
        // error: Type 'Set<T>' is not assignable to type 'C'.
    
        //          'Set<T>' is assignable to the constraint of type 'C', but
    
        //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.
    
      }
    
      // ...
    
      return collection;
    
      //     ~~~~~~~~~~
    
      // error: Type 'T[]' is not assignable to type 'C'.
    
      //          'T[]' is assignable to the constraint of type 'C', but
    
      //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.
    
    }

So how does TypeScript 4.3 change things? Well, basically in a few key places when writing code, all the type system really cares about is the constraint of a type. For example, when we write `collection.length`, TypeScript doesn‚Äôt care about the fact that `collection` has the type `C`, it only cares about the properties available, which are determined by the constraint `T[] | Set<T>`.

In cases like this, TypeScript will grab the narrowed type of the constraint
because that will give you the data you care about; however, in any other
case, we‚Äôll just try to narrow the original generic type (and often end up
with the original generic type).

In other words, based on how you use a generic value, TypeScript will narrow
it a little differently. The end result is that the entire above example
compiles with no type-checking errors.

For more details, you can [look at the original pull request on
GitHub](https://github.com/microsoft/TypeScript/pull/43183).

## Always-Truthy Promise Checks

Under [`strictNullChecks`](/tsconfig#strictNullChecks), checking whether a
`Promise` is ‚Äútruthy‚Äù in a conditional will trigger an error.

    
    
    ts
    
    async function foo(): Promise<boolean> {
    
      return false;
    
    }
    
    async function bar(): Promise<string> {
    
      if (foo()) {
    
        //  ~~~~~
    
        // Error!
    
        // This condition will always return true since
    
        // this 'Promise<boolean>' appears to always be defined.
    
        // Did you forget to use 'await'?
    
        return "true";
    
      }
    
      return "false";
    
    }

[This change](https://github.com/microsoft/TypeScript/pull/39175) was
contributed by [Jack Works](https://github.com/Jack-Works), and we extend our
thanks to them!

## `static` Index Signatures

Index signatures allow us to set more properties on a value than a type
explicitly declares.

    
    
    ts
    
    class Foo {
    
      hello = "hello";
    
      world = 1234;
    
      // This is an index signature:
    
      [propName: string]: string | number | undefined;
    
    }
    
    let instance = new Foo();
    
    // Valid assignment
    
    instance["whatever"] = 42;
    
    // Has type 'string | number | undefined'.
    
    let x = instance["something"];

Up until now, an index signature could only be declared on the instance side
of a class. Thanks to [a pull
request](https://github.com/microsoft/TypeScript/pull/37797) from [Wenlu
Wang](https://github.com/microsoft/TypeScript/pull/37797), index signatures
can now be declared as `static`.

    
    
    ts
    
    class Foo {
    
      static hello = "hello";
    
      static world = 1234;
    
      static [propName: string]: string | number | undefined;
    
    }
    
    // Valid.
    
    Foo["whatever"] = 42;
    
    // Has type 'string | number | undefined'
    
    let x = Foo["something"];

The same sorts of rules apply for index signatures on the static side of a
class as they do for the instance side - namely, that every other static
property has to be compatible with the index signature.

    
    
    ts
    
    class Foo {
    
      static prop = true;
    
      //     ~~~~
    
      // Error! Property 'prop' of type 'boolean'
    
      // is not assignable to string index type
    
      // 'string | number | undefined'.
    
      static [propName: string]: string | number | undefined;
    
    }

## `.tsbuildinfo` Size Improvements

In TypeScript 4.3, `.tsbuildinfo` files that are generated as part of
[`incremental`](/tsconfig#incremental) builds should be significantly smaller.
This is thanks to several optimizations in the internal format, creating
tables with numeric identifiers to be used throughout the file instead of
repeating full paths and similar information. This work was spear-headed by
[Tobias Koppers](https://github.com/sokra) in [their pull
request](https://github.com/microsoft/TypeScript/pull/43079), serving as
inspiration for [the ensuing pull
request](https://github.com/microsoft/TypeScript/pull/43155) and [further
optimizations](https://github.com/microsoft/TypeScript/pull/43695).

We have seen significant reductions of `.tsbuildinfo` file sizes including

  * 1MB to 411 KB
  * 14.9MB to 1MB
  * 1345MB to 467MB

Needless to say, these sorts of savings in size translate to slightly faster
build times as well.

## Lazier Calculations in `--incremental` and `--watch` Compilations

One of the issues with [`incremental`](/tsconfig#incremental) and `--watch`
modes are that while they make later compilations go faster, the initial
compilation can be a bit slower - in some cases, significantly slower. This is
because these modes have to perform a bunch of book-keeping, computing
information about the current project, and sometimes saving that data in a
`.tsbuildinfo` file for later builds.

That‚Äôs why on top of `.tsbuildinfo` size improvements, TypeScript 4.3 also
ships some changes to [`incremental`](/tsconfig#incremental) and `--watch`
modes that make the first build of a project with these flags just as fast as
an ordinary build! To do this, much of the information that would ordinarily
be computed up-front is instead done on an on-demand basis for later builds.
While this can add some overhead to a subsequent build, TypeScript‚Äôs
[`incremental`](/tsconfig#incremental) and `--watch` functionality will still
typically operate on a much smaller set of files, and any needed information
will be saved afterwards. In a sense, [`incremental`](/tsconfig#incremental)
and `--watch` builds will ‚Äúwarm up‚Äù and get faster at compiling files once
you‚Äôve updated them a few times.

In a repository with 3000 files, **this reduced initial build times to almost
a third**!

[This work was started](https://github.com/microsoft/TypeScript/pull/42960) by
[Tobias Koppers](https://github.com/sokra), whose work ensued in [the
resulting final change](https://github.com/microsoft/TypeScript/pull/43314)
for this functionality. We‚Äôd like to extend a great thanks to Tobias for
helping us find these opportunities for improvements!

## Import Statement Completions

One of the biggest pain-points users run into with import and export
statements in JavaScript is the order - specifically that imports are written
as

    
    
    ts
    
    import { func } from "./module.js";

instead of

    
    
    ts
    
    from "./module.js" import { func };

This causes some pain when writing out a full import statement from scratch
because auto-complete wasn‚Äôt able to work correctly. For example, if you start
writing something like `import {`, TypeScript has no idea what module you‚Äôre
planning on importing from, so it couldn‚Äôt provide any scoped-down
completions.

To alleviate this, we‚Äôve leveraged the power of auto-imports! Auto-imports
already deal with the issue of not being able to narrow down completions from
a specific module - their whole point is to provide every possible export and
automatically insert an import statement at the top of your file.

So when you now start writing an `import` statement that doesn‚Äôt have a path,
we‚Äôll provide you with a list of possible imports. When you commit a
completion, we‚Äôll complete the full import statement, including the path that
you were going to write.

![Import statement completions](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/05/auto-import-statement-4-3.gif)

This work requires editors that specifically support the feature. You‚Äôll be
able to try this out by using the latest [Insiders versions of Visual Studio
Code](https://code.visualstudio.com/insiders/).

For more information, take a look at [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/43149)!

## Editor Support for `@link` Tags

TypeScript can now understand `@link` tags, and will try to resolve
declarations that they link to. What this means is that you‚Äôll be able to
hover over names within `@link` tags and get quick information, or use
commands like go-to-definition or find-all-references.

For example, you‚Äôll be able to go-to-definition on `plantCarrot` in `@link
plantCarrot` in the example below and a TypeScript-supported editor will jump
to `plantCarrot`‚Äôs function declaration.

    
    
    ts
    
    /**
    
     * To be called 70 to 80 days after {@link plantCarrot}.
    
     */
    
    function harvestCarrot(carrot: Carrot) {}
    
    /**
    
     * Call early in spring for best results. Added in v2.1.0.
    
     * @param seed Make sure it's a carrot seed!
    
     */
    
    function plantCarrot(seed: Seed) {
    
      // TODO: some gardening
    
    }

![Jumping to definition and requesting quick info on a @link tag for
](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/05/link-tag-4-3.gif)

For more information, see [the pull request on
GitHub](https://github.com/microsoft/TypeScript/pull/41877)!

## Go-to-Definition on Non-JavaScript File Paths

Many loaders allow users to include assets in their applications using
JavaScript imports. They‚Äôll typically be written as something like `import
"./styles.css"` or the like.

Up until now, TypeScript‚Äôs editor functionality wouldn‚Äôt even attempt to read
this file, so go-to-definition would typically fail. At best, go-to-definition
would jump to a declaration like `declare module "*.css"` if it could find
something along those lines.

TypeScript‚Äôs language service now tries to jump to the correct file when you
perform a go-to-definition on relative file paths, even if they‚Äôre not
JavaScript or TypeScript files! Try it out with imports to CSS, SVGs, PNGs,
font files, Vue files, and more.

For more information, you can check out [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/42539).

## Breaking Changes

### `lib.d.ts` Changes

As with every TypeScript version, declarations for `lib.d.ts` (especially the
declarations generated for web contexts), have changed. In this release, we
leveraged [Mozilla‚Äôs browser-compat-data](https://github.com/mdn/browser-
compat-data) to remove APIs that no browser implements. While it is unlike
that you are using them, APIs such as `Account`, `AssertionOptions`,
`RTCStatsEventInit`, `MSGestureEvent`, `DeviceLightEvent`, `MSPointerEvent`,
`ServiceWorkerMessageEvent`, and `WebAuthentication` have all been removed
from `lib.d.ts`. This is discussed [in some detail
here](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991).

<https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991>

### `useDefineForClassFields` now defaults to true on `esnext` and eventually
on `es2022`

In 2021 the class fields feature was added into the JavaScript specification
with behavior which differed from how TypeScript had implemented it. In
preparation for this, in TypeScript 3.7, a flag was added
([`useDefineForClassFields`](/tsconfig#useDefineForClassFields)) to migrate to
emitted JavaScript to match the JavaScript standard behavior.

Now that the feature is in JavaScript we are changing the default to `true`
for ES2022 and above, including ESNext.

### Errors on Always-Truthy Promise Checks

Under [`strictNullChecks`](/tsconfig#strictNullChecks), using a `Promise` that
always appears to be defined within a condition check is now considered an
error.

    
    
    ts
    
    declare var p: Promise<number>;
    
    if (p) {
    
      //  ~
    
      // Error!
    
      // This condition will always return true since
    
      // this 'Promise<number>' appears to always be defined.
    
      //
    
      // Did you forget to use 'await'?
    
    }

For more details, [see the original
change](https://github.com/microsoft/TypeScript/pull/39175).

### Union Enums Cannot Be Compared to Arbitrary Numbers

Certain `enum`s are considered _union`enum`s_ when their members are either
automatically filled in, or trivially written. In those cases, an enum can
recall each value that it potentially represents.

In TypeScript 4.3, if a value with a union `enum` type is compared with a
numeric literal that it could never be equal to, then the type-checker will
issue an error.

    
    
    ts
    
    enum E {
    
      A = 0,
    
      B = 1,
    
    }
    
    function doSomething(x: E) {
    
      // Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.
    
      if (x === -1) {
    
        // ...
    
      }
    
    }

As a workaround, you can re-write an annotation to include the appropriate
literal type.

    
    
    ts
    
    enum E {
    
      A = 0,
    
      B = 1,
    
    }
    
    // Include -1 in the type, if we're really certain that -1 can come through.
    
    function doSomething(x: E | -1) {
    
      if (x === -1) {
    
        // ...
    
      }
    
    }

You can also use a type-assertion on the value.

    
    
    ts
    
    enum E {
    
      A = 0,
    
      B = 1,
    
    }
    
    function doSomething(x: E) {
    
      // Use a type assertion on 'x' because we know we're not actually just dealing with values from 'E'.
    
      if ((x as number) === -1) {
    
        // ...
    
      }
    
    }

Alternatively, you can re-declare your enum to have a non-trivial initializer
so that any number is both assignable and comparable to that enum. This may be
useful if the intent is for the enum to specify a few well-known values.

    
    
    ts
    
    enum E {
    
      // the leading + on 0 opts TypeScript out of inferring a union enum.
    
      A = +0,
    
      B = 1,
    
    }

For more details, [see the original
change](https://github.com/microsoft/TypeScript/pull/42472)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.3.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(3\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

EL![Eliran Levi
\(1\)](https://gravatar.com/avatar/8a81d3dd6957e01e288d05ebdd66466d?s=32&&d=blank)

NT![N√©meth Tam√°s
\(1\)](https://gravatar.com/avatar/dacfdcffb8f4a94c46651a0dc87d28e6?s=32&&d=blank)

MS![Max Str√ºbing
\(1\)](https://gravatar.com/avatar/21eaa3ed4674e22d54aee1cb77108291?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.4

## Control Flow Analysis of Aliased Conditions and Discriminants

In JavaScript, we often have to probe a value in different ways, and do
something different once we know more about its type. TypeScript understands
these checks and calls them _type guards_. Instead of having to convince
TypeScript of a variable‚Äôs type whenever we use it, the type-checker leverages
something called _control flow analysis_ to see if we‚Äôve used a type guard
before a given piece of code.

For example, we can write something like

    
    
    ts
    
    function foo(arg: unknown) {
    
      if (typeof arg === "string") {
    
        console.log(arg.toUpperCase());
    
                    
    
    (parameter) arg: string
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUBDATgcwFyLgDWYcA7mAJSIDeAUIojMImlAJ4AOApnC9jkQBeEYgBEAZyhYYYHGOr1GjCAglwANtwB0GuDky5tUOAFVOPLAGEME7mkqUA3A2UB6N8q9eAegH5XAF86QKA)

In this example, we checked whether `arg` was a `string`. TypeScript
recognized the `typeof arg === "string"` check, which it considered a type
guard, and knew that `arg` was a `string` inside the body of the `if` block.
That let us access `string` methods like `toUpperCase()` without getting an
error.

However, what would happen if we moved the condition out to a constant called
`argIsString`?

    
    
    ts
    
    // In TS 4.3 and below
    
    function foo(arg: unknown) {
    
      const argIsString = typeof arg === "string";
    
      if (argIsString) {
    
        console.log(arg.toUpperCase());
    
        //              ~~~~~~~~~~~
    
        // Error! Property 'toUpperCase' does not exist on type 'unknown'.
    
      }
    
    }

In previous versions of TypeScript, this would be an error - even though
`argIsString` was assigned the value of a type guard, TypeScript simply lost
that information. That‚Äôs unfortunate since we might want to re-use the same
check in several places. To get around that, users often have to repeat
themselves or use type assertions (a.k.a. casts).

In TypeScript 4.4, that is no longer the case. The above example works with no
errors! When TypeScript sees that we are testing a constant value, it will do
a little bit of extra work to see if it contains a type guard. If that type
guard operates on a `const`, a `readonly` property, or an un-modified
parameter, then TypeScript is able to narrow that value appropriately.

Different sorts of type guard conditions are preserved - not just `typeof`
checks. For example, checks on discriminated unions work like a charm.

    
    
    ts
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; sideLength: number };
    
    ¬†
    
    function area(shape: Shape): number {
    
      const isCircle = shape.kind === "circle";
    
      if (isCircle) {
    
        // We know we have a circle here!
    
        return Math.PI * shape.radius ** 2;
    
      } else {
    
        // We know we're left with a square here!
    
        return shape.sideLength ** 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjytF4CwFBEAgDCjCzQKFBB4QB0xOSoKDl0mawc8kSOUP6pGUysEXGYmAD07VAA6tAEJB4A7lCD0IgAbtAIUPRNY1IQAITymNrAfAzeALIIFvkACgCSUABUucEQ+dy8gqdnAEz2mDJQEMwC0LgrUJ09fQPDUYAcm0UFYjmSgyIFh8uQ0vigcAWyzaXAg6025wKegMxjMMJODyesjQMiAA)

Analysis on discriminants in 4.4 also goes a little bit deeper - we can now
extract out discriminants and TypeScript can narrow the original object.

    
    
    ts
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; sideLength: number };
    
    ¬†
    
    function area(shape: Shape): number {
    
      // Extract out the 'kind' field first.
    
      const { kind } = shape;
    
    ¬†
    
      if (kind === "circle") {
    
        // We know we have a circle here!
    
        return Math.PI * shape.radius ** 2;
    
      } else {
    
        // We know we're left with a square here!
    
        return shape.sideLength ** 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjyAPTxUACiAB7A3G5QHnzAUBbQAOTE5IVQjkQQzGTljALAAHTytF71iiU1MqhQQeH28kSOUP4dqCgoNPRMrNQRcZiYiVAA6tAEJB4A7lCb0IgAbtAIUFMse1IQAITymNrAfAzeALIIFg0ACgCSUABUPcEQBrcXiCX5-ABM9kwXSqAmguBuUCWq0IG22u0K2igrEceU2RAsPh6Gl8UDgF2uCy4EHuj3+4QaegMxjMhJ+EKhsjQMiAA)

As another example, here‚Äôs a function that checks whether two of its inputs
have contents.

    
    
    ts
    
    function doSomeChecks(
    
      inputA: string | undefined,
    
      inputB: string | undefined,
    
      shouldDoExtraWork: boolean
    
    ) {
    
      const mustDoWork = inputA && inputB && shouldDoExtraWork;
    
      if (mustDoWork) {
    
        // We can access 'string' properties on both 'inputA' and 'inputB'!
    
        const upperA = inputA.toUpperCase();
    
        const upperB = inputB.toUpperCase();
    
        // ...
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKYGEAW2EA1gM4AUAUIojGAA4hQCCAXIqVAE50DmiAH0Thk2YHWzIANNVoMmAIXaceYfkJFiJ02aXxwQAG2QAROAFEAHtwCGAdThdi7AEZw4h7DbCUAlIgBvWQgETkRMEE4zBydEAF45RhZEADIUxMVU9L0DYzMrWxjiAG5ZGGBEcgiouCL-IJoaAHomxDtsRAhvRBsICGxSUkQAchU+YcR6Ljh6bC5YAcQERDcofBG6JOYJ72QN+SgFYYBCWRoQsDCQelmuZniMlgA6KDgAVRu53BtSbHJfUqNTqhKDCT5cBQPTaKF7vcHfX7-QGNFqIJ7o2QAX0omKAA)

TypeScript can understand that both `inputA` and `inputB` are both present if
`mustDoWork` is `true`. That means we don‚Äôt have to write a non-null assertion
like `inputA!` to convince TypeScript that `inputA` isn‚Äôt `undefined`.

One neat feature here is that this analysis works transitively. TypeScript
will hop through constants to understand what sorts of checks you‚Äôve already
performed.

    
    
    ts
    
    function f(x: string | number | boolean) {
    
      const isString = typeof x === "string";
    
      const isNumber = typeof x === "number";
    
      const isStringOrNumber = isString || isNumber;
    
      if (isStringOrNumber) {
    
        x;
    
       
    
    (parameter) x: string | number
    
      } else {
    
        x;
    
       
    
    (parameter) x: boolean
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwFyIM5QE4xgDmiAPomCALYBGApnmYjXHADZ0CGYAlIgN4AoRIggJciGNgDK+QiQC8iKAE8ADnTjBEaRAv2IARLgLFDAbmGjxUSdgBy1eoyWqNWnXoOHKtBhasxMAkpWVMiAHk8Rz8XOzD5MnIpGOdLERhtFFC5YijUhj4hERE0SwB6cpEAPQB+KwBfRDo2bDoBK1KKqsQ6xsEGoA)

Note that there‚Äôs a cutoff - TypeScript doesn‚Äôt go arbitrarily deep when
checking these conditions, but its analysis is deep enough for most checks.

This feature should make a lot of intuitive JavaScript code ‚Äújust work‚Äù in
TypeScript without it getting in your way. For more details, [check out the
implementation on GitHub](https://github.com/microsoft/TypeScript/pull/44730)!

## Symbol and Template String Pattern Index Signatures

TypeScript lets us describe objects where every property has to have a certain
type using _index signatures_. This allows us to use these objects as
dictionary-like types, where we can use string keys to index into them with
square brackets.

For example, we can write a type with an index signature that takes `string`
keys and maps to `boolean` values. If we try to assign anything other than a
`boolean` value, we‚Äôll get an error.

    
    
    ts
    
    interface BooleanDictionary {
    
      [key: string]: boolean;
    
    }
    
    ¬†
    
    declare let myDict: BooleanDictionary;
    
    ¬†
    
    // Valid to assign boolean values
    
    myDict["foo"] = true;
    
    myDict["bar"] = false;
    
    ¬†
    
    // Error, "oops" isn't a boolean
    
    myDict["baz"] = "oops";
    
    Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAQnHADaS1kAiJ9FEnDK1oAT1ABvIqFABtANaQxqRBWjkA5gF1UAIzaduAbiIBfIkQAmkeu1FNOFUAFsxfAalYcuvfoOFRMVMiEFAANVp2EitQCjhQWkREEk0yUAMfblAANyiAV0hEIjcPCjkAImo2Cu1QAF446ELTUv9KvVFahtA6dkRIELCAUVgEABpQCrYAB0QK0BJEMgByZ1oMw18S93aKzoAvbsbpuDmK4yA)

While [a `Map` might be a better data structure
here](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Map) (specifically, a
`Map<string, boolean>`), JavaScript objects are often more convenient to use
or just happen to be what we‚Äôre given to work with.

Similarly, `Array<T>` already defines a `number` index signature that lets us
insert/retrieve values of type `T`.

    
    
    ts
    
    // @errors: 2322 2375
    
    // This is part of TypeScript's definition of the built-in Array type.
    
    interface Array<T> {
    
      [index: number]: T;
    
      // ...
    
    }
    
    let arr = new Array<string>();
    
    // Valid
    
    arr[0] = "hello!";
    
    // Error, expecting a 'string' value here
    
    arr[1] = 123;

Index signatures are very useful to express lots of code out in the wild;
however, until now they‚Äôve been limited to `string` and `number` keys (and
`string` index signatures have an intentional quirk where they can accept
`number` keys since they‚Äôll be coerced to strings anyway). That means that
TypeScript didn‚Äôt allow indexing objects with `symbol` keys. TypeScript also
couldn‚Äôt model an index signature of some _subset_ of `string` keys - for
example, an index signature which describes just properties whose names start
with the text `data-`.

TypeScript 4.4 addresses these limitations, and allows index signatures for
`symbol`s and template string patterns.

For example, TypeScript now allows us to declare a type that can be keyed on
arbitrary `symbol`s.

    
    
    ts
    
    interface Colors {
    
      [sym: symbol]: number;
    
    }
    
    ¬†
    
    const red = Symbol("red");
    
    const green = Symbol("green");
    
    const blue = Symbol("blue");
    
    ¬†
    
    let colors: Colors = {};
    
    ¬†
    
    // Assignment of a number is allowed
    
    colors[red] = 255;
    
    let redVal = colors[red];
    
          
    
    let redVal: number
    
    ¬†
    
    colors[blue] = "da ba dee";
    
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAwnADYKKgDeRooAbUQBPALaoRogEbsAuqjIBXaTADcRAL5Ei9OGUQVQ0SABNQAXlABlMTLYAKAETGTjgJTrd+wwHNjkMgtrW3YnP0gA9089A1ApNkUmSxtpUMd4xKjtNkhDXQ4kVFYCrktuDXUiEFAAQUREEh8yUQDDOGpQWlAlFWhQEi5aNg4Ad1Mddk4BF1kgtAICdRzDFwA1IaD8qZn1atAAPQB+bS2kAQzIWctHEy6pLpMIx1UgA)

Similarly, we can write an index signature with template string pattern type.
One use of this might be to exempt properties starting with `data-` from
TypeScript‚Äôs excess property checking. When we pass an object literal to
something with an expected type, TypeScript will look for excess properties
that weren‚Äôt declared in the expected type.

    
    
    ts
    
    // @errors: 2322 2375
    
    interface Options {
    
        width?: number;
    
        height?: number;
    
    }
    
    let a: Options = {
    
        width: 100,
    
        height: 100,
    
        "data-blah": true,
    
    };
    
    interface OptionsWithDataProps extends Options {
    
        // Permit any property starting with 'data-'.
    
        [optName: `data-${string}`]: unknown;
    
    }
    
    let b: OptionsWithDataProps = {
    
        width: 100,
    
        height: 100,
    
        "data-blah": true,
    
        // Fails for a property which is not known, nor
    
        // starts with 'data-'
    
        "unknown-property": true,
    
    };

A final note on index signatures is that they now permit union types, as long
as they‚Äôre a union of infinite-domain primitive types - specifically:

  * `string`
  * `number`
  * `symbol`
  * template string patterns (e.g. ``hello-${string}``)

An index signature whose argument is a union of these types will de-sugar into
several different index signatures.

    
    
    ts
    
    interface Data {
    
      [optName: string | symbol]: any;
    
    }
    
    // Equivalent to
    
    interface Data {
    
      [optName: string]: any;
    
      [optName: symbol]: any;
    
    }

For more details, [read up on the pull
request](https://github.com/microsoft/TypeScript/pull/44512)

## Defaulting to the `unknown` Type in Catch Variables
(`--useUnknownInCatchVariables`)

In JavaScript, any type of value can be thrown with `throw` and caught in a
`catch` clause. Because of this, TypeScript historically typed catch clause
variables as `any`, and would not allow any other type annotation:

    
    
    ts
    
    try {
    
      // Who knows what this might throw...
    
      executeSomeThirdPartyCode();
    
    } catch (err) {
    
      // err: any
    
      console.error(err.message); // Allowed, because 'any'
    
      err.thisWillProbablyFail(); // Allowed, because 'any' :(
    
    }

Once TypeScript added the `unknown` type, it became clear that `unknown` was a
better choice than `any` in `catch` clause variables for users who want the
highest degree of correctness and type-safety, since it narrows better and
forces us to test against arbitrary values. Eventually TypeScript 4.0 allowed
users to specify an explicit type annotation of `unknown` (or `any`) on each
`catch` clause variable so that we could opt into stricter types on a case-by-
case basis; however, for some, manually specifying `: unknown` on every
`catch` clause was a chore.

That‚Äôs why TypeScript 4.4 introduces a new flag called
[`useUnknownInCatchVariables`](/tsconfig#useUnknownInCatchVariables). This
flag changes the default type of `catch` clause variables from `any` to
`unknown`.

    
    
    ts
    
    try {
    
      executeSomeThirdPartyCode();
    
    } catch (err) {
    
      // err: unknown
    
    ¬†
    
      // Error! Property 'message' does not exist on type 'unknown'.
    
      console.error(err.message);
    
    'err' is of type 'unknown'.18046'err' is of type 'unknown'.
    
    ¬†
    
      // Works! We can narrow 'err' from 'unknown' to 'Error'.
    
      if (err instanceof Error) {
    
        console.error(err.message);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABNIBjAGwENpJQAzAVwDtaAXASzhdQkAB50OvSAGU4AW0gAVABb9oVAArNeATwDCcGgAoAlKgBucflQDcFEKAC0z2pOeOKvaDtABvCqAi4q5Ssgoqapra+oaQpnYAvqC0jLy0yqBGMNAmfgGgDtmo3ADWXHAA7lwU+Q4AorAIAISgGvAADjC6oADkCoiIjADmkD2gVHCQiKDlvEH8iHNCoLqdvaXlVT0AdPm0Qohw9JDb2QhZsNv9gyMmdrVgAOoIJYgtj6wpwlzM8BW92TGbHgcnWXDKlS4Y14cF6DXg0B2+X4bEy2VA-C4i0YPEgcFR8IQuX8gUC+yxRxOZ2gF2gVymN0gd3yCQoCSAA)

This flag is enabled under the [`strict`](/tsconfig#strict) family of options.
That means that if you check your code using [`strict`](/tsconfig#strict),
this option will automatically be turned on. You may end up with errors in
TypeScript 4.4 such as

    
    
    Property 'message' does not exist on type 'unknown'.
    
    Property 'name' does not exist on type 'unknown'.
    
    Property 'stack' does not exist on type 'unknown'.

In cases where we don‚Äôt want to deal with an `unknown` variable in a `catch`
clause, we can always add an explicit `: any` annotation so that we can opt
_out_ of stricter types.

    
    
    ts
    
    try {
    
      executeSomeThirdPartyCode();
    
    } catch (err: any) {
    
      console.error(err.message); // Works again!
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxAA9xkMQBlHAWxABUALLGYABVgwE8BhHUACgCUALngA3HFmABuAFAB6OfAC0KsKRVKZGGB3gBvGfALE1ZSjQZNW7brxCDZAX3hgoGMPXh8QMGCKioHAL6hi54AM44ECAAdD4wODDevjE04eFQAOYgAlLwCvAA6okA1uHwWVBYqACEMo5AA)

For more information, take a look at [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/41013).

## Exact Optional Property Types (`--exactOptionalPropertyTypes`)

In JavaScript, reading a _missing_ property on an object produces the value
`undefined`. It‚Äôs also possible to _have_ an actual property with the value
`undefined`. A lot of code in JavaScript tends to treat these situations the
same way, and so initially TypeScript just interpreted every optional property
as if a user had written `undefined` in the type. For example,

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age?: number;
    
    }

was considered equivalent to

    
    
    ts
    
    interface Person {
    
      name: string;
    
      age?: number | undefined;
    
    }

What this meant is that a user could explicitly write `undefined` in place of
`age`.

    
    
    ts
    
    const p: Person = {
    
      name: "Daniel",
    
      age: undefined, // This is okay by default.
    
    };

So by default, TypeScript doesn‚Äôt distinguish between a present property with
the value `undefined` and a missing property. While this works most of the
time, not all code in JavaScript makes the same assumptions. Functions and
operators like `Object.assign`, `Object.keys`, object spread (`{ ...obj }`),
and `for`-`in` loops behave differently depending on whether or not a property
actually exists on an object. In the case of our `Person` example, this could
potentially lead to runtime errors if the `age` property was observed in a
context where its presence was important.

In TypeScript 4.4, the new flag
[`exactOptionalPropertyTypes`](/tsconfig#exactOptionalPropertyTypes) specifies
that optional property types should be interpreted exactly as written, meaning
that `| undefined` is not added to the type:

    
    
    ts
    
    // With 'exactOptionalPropertyTypes' on:
    
    const p: Person = {
    
    Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.
      Types of property 'age' are incompatible.
        Type 'undefined' is not assignable to type 'number'.2375Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.
      Types of property 'age' are incompatible.
        Type 'undefined' is not assignable to type 'number'.
    
      name: "Daniel",
    
      age: undefined, // Error! undefined isn't a number
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9effgHYArEww5EFAGYJIoQhQa5QAbyahQeALaQeDRMWkBzANzbQsM5AD8PHAFc9AIwpWAvizABaAPhnRAC-X1AAdQxEAAtQAHIYBBR0bDwiUnJKWnpIBnjQXC4meFxjUFQeFU51AF5Na31DUAAiABFYHAxIfBaAGmtbZuccABNIOWlIUb7QVgBRYg4AQlAR8cmcadAMBhx4xBtdVw9iJi8LIA)

This flag is **not** part of the [`strict`](/tsconfig#strict) family and needs
to be turned on explicitly if you‚Äôd like this behavior. It also requires
[`strictNullChecks`](/tsconfig#strictNullChecks) to be enabled as well. We‚Äôve
been making updates to DefinitelyTyped and other definitions to try to make
the transition as straightforward as possible, but you may encounter some
friction with this depending on how your code is structured.

For more information, you can [take a look at the implementing pull request
here](https://github.com/microsoft/TypeScript/pull/43947).

## `static` Blocks in Classes

TypeScript 4.4 brings support for [`static` blocks in
classes](https://github.com/tc39/proposal-class-static-block#ecmascript-class-
static-initialization-blocks), an upcoming ECMAScript feature that can help
you write more-complex initialization code for static members.

    
    
    ts
    
    class Foo {
    
        static count = 0;
    
    ¬†
    
        // This is a static block:
    
        static {
    
            if (someCondition()) {
    
                Foo.count++;
    
            }
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGccBbEAYT2C2zwAoBKALngCMccIQpUAoAej7wAtCLDIMIoT0hQCBeADF28AN494GwhijYw8MDjQZ4AXngAGANw91mgfAAqACyzzX8KFp1Y9LCDjAAa0ZbDQJtXVVQzQ0sRHhaIlIKVCoaVAZ6KJiczSUcADoDIwBqEutcjQBfaJqqoA)

These static blocks allow you to write a sequence of statements with their own
scope that can access private fields within the containing class. That means
that we can write initialization code with all the capabilities of writing
statements, no leakage of variables, and full access to our class‚Äôs internals.

    
    
    ts
    
    class Foo {
    
        static #count = 0;
    
    ¬†
    
        get count() {
    
            return Foo.#count;
    
        }
    
    ¬†
    
        static {
    
            try {
    
                const lastInstances = loadLastInstances();
    
                Foo.#count += lastInstances.length;
    
            }
    
            catch {}
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQBQAeiHwAtBLDIMEsQMgVy8AGI4c8AN4D4O+HWxh4AYjA40GeAF54ABgDcA7boDmIC6fOtNT3brgZkGHxVHAA6EzNUDAdfAF9HX30sQy1fXwwYLm80nPhTWgtoSho6BiVrQmIyYoL6MEZWGNzfEPCPKPgAagqKalqy0IgQVGcMAAsmnPjmsCgMMDHNad142KA)

Without `static` blocks, writing the code above was possible, but often
involved several different types of hacks that had to compromise in some way.

Note that a class can have multiple `static` blocks, and they‚Äôre run in the
same order in which they‚Äôre written.

    
    
    ts
    
    // Prints:
    
    //    1
    
    //    2
    
    //    3
    
    class Foo {
    
        static prop = 1
    
        static {
    
            console.log(Foo.prop++);
    
        }
    
        static {
    
            console.log(Foo.prop++);
    
        }
    
        static {
    
            console.log(Foo.prop++);
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOAuAUCUnQEZ1iwEx5agDMqAxgDYCGiioAYgPbOgDeqJi8N80FUAAdIzIaAC8OLlh58BHGSUwVmsRMyoBTAHRVmAcwAULZjpFiA1JYCUAbiWgAvo7n9BnZVlXrNu-cam5qJC1vaOLty87opeKmoa2nqGJqzBVrYOJC5OQA)

We‚Äôd like to extend our thanks to [Wenlu Wang](https://github.com/Kingwl) for
TypeScript‚Äôs implementation of this feature. For more details, you can [see
that pull request here](https://github.com/microsoft/TypeScript/pull/43370).

## `tsc --help` Updates and Improvements

TypeScript‚Äôs `--help` option has gotten a refresh! Thanks to work in part by
[Song Gao](https://github.com/ShuiRuTian), we‚Äôve brought in changes to [update
the descriptions of our compiler
options](https://github.com/microsoft/TypeScript/pull/44409) and [restyle the
`--help` menu](https://github.com/microsoft/TypeScript/pull/44157) with colors
and other visual separation.

![The new TypeScript --help menu where the output is bucketed into several
different areas](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/08/tsc-help-ps-wt-4-4.png)

You can read more on [the original proposal
thread](https://github.com/microsoft/TypeScript/issues/44074).

## Performance Improvements

### Faster Declaration Emit

TypeScript now caches whether internal symbols are accessible in different
contexts, along with how specific types should be printed. These changes can
improve TypeScript‚Äôs general performance in code with fairly complex types,
and is especially observed when emitting `.d.ts` files under the
[`declaration`](/tsconfig#declaration) flag.

[See more details here](https://github.com/microsoft/TypeScript/pull/43973).

### Faster Path Normalization

TypeScript often has to do several types of ‚Äúnormalization‚Äù on file paths to
get them into a consistent format that the compiler can use everywhere. This
involves things like replacing backslashes with slashes, or removing
intermediate `/./` and `/../` segments of paths. When TypeScript has to
operate over millions of these paths, these operations end up being a bit
slow. In TypeScript 4.4, paths first undergo quick checks to see whether they
need any normalization in the first place. These improvements together reduce
project load time by 5-10% on bigger projects, and significantly more in
massive projects that we‚Äôve tested internally.

For more details, you can [view the PR for path segment
normalization](https://github.com/microsoft/TypeScript/pull/44173) along with
[the PR for slash
normalization](https://github.com/microsoft/TypeScript/pull/44100).

### Faster Path Mapping

TypeScript now caches the way it constructs path-mappings (using the
[`paths`](/tsconfig#paths) option in `tsconfig.json`). For projects with
several hundred mappings, the reduction is significant. You can see more [on
the change itself](https://github.com/microsoft/TypeScript/pull/44078).

### Faster Incremental Builds with `--strict`

In what was effectively a bug, TypeScript would end up redoing type-checking
work under [`incremental`](/tsconfig#incremental) compilations if
[`strict`](/tsconfig#strict) was on. This led to many builds being just as
slow as if [`incremental`](/tsconfig#incremental) was turned off. TypeScript
4.4 fixes this, though the change has also been back-ported to TypeScript 4.3.

See more [here](https://github.com/microsoft/TypeScript/pull/44394).

### Faster Source Map Generation for Big Outputs

TypeScript 4.4 adds an optimization for source map generation on extremely
large output files. When building an older version of the TypeScript compiler,
this results in around an 8% reduction in emit time.

We‚Äôd like to extend our thanks to [David Michon](https://github.com/dmichon-
msft) who provided a [simple and clean
change](https://github.com/microsoft/TypeScript/pull/44031) to enable this
performance win.

### Faster `--force` Builds

When using `--build` mode on project references, TypeScript has to perform up-
to-date checks to determine which files need to be rebuilt. When performing a
[`--force`](/tsconfig#force) build, however, that information is irrelevant
since every project dependency will be rebuilt from scratch. In TypeScript
4.4, [`--force`](/tsconfig#force) builds avoid those unnecessary steps and
start a full build. See more about the change
[here](https://github.com/microsoft/TypeScript/pull/43666).

## Spelling Suggestions for JavaScript

TypeScript powers the JavaScript editing experience in editors like Visual
Studio and Visual Studio Code. Most of the time, TypeScript tries to stay out
of the way in JavaScript files; however, TypeScript often has a lot of
information to make confident suggestions, and ways of surfacing suggestions
that aren‚Äôt _too_ invasive.

That‚Äôs why TypeScript now issues spelling suggestions in plain JavaScript
files - ones without `// @ts-check` or in a project with
[`checkJs`](/tsconfig#checkJs) turned off. These are the same _‚ÄúDid you
mean‚Ä¶?‚Äù_ suggestions that TypeScript files already have, and now they‚Äôre
available in _all_ JavaScript files in some form.

These spelling suggestions can provide a subtle clue that your code is wrong.
We managed to find a few bugs in existing code while testing this feature!

For more details on this new feature, [take a look at the pull
request](https://github.com/microsoft/TypeScript/pull/44271)!

## Inlay Hints

TypeScript 4.4 provides support for _inlay hints_ which can help display
useful information like parameter names and return types in your code. You can
think of it as a sort of friendly ‚Äúghost text‚Äù.

![A preview of inlay hints in Visual Studio
Code](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/08/inlayHints-4.4-rc-ghd.png)

This feature was built by [Wenlu Wang](https://github.com/Kingwl) whose [pull
request](https://github.com/microsoft/TypeScript/pull/42089) has more details.

Wenlu also contributed [the integration for inlay hints in Visual Studio
Code](https://github.com/microsoft/vscode/pull/113412) which has shipped as
[part of the July 2021 (1.59)
release](https://code.visualstudio.com/updates/v1_59#_typescript-44). If you‚Äôd
like to try inlay hints out, make sure you‚Äôre using a recent
[stable](https://code.visualstudio.com/updates/v1_59) or
[insiders](https://code.visualstudio.com/insiders/) version of the editor. You
can also modify when and where inlay hints get displayed in Visual Studio
Code‚Äôs settings.

## Auto-Imports Show True Paths in Completion Lists

When editors like Visual Studio Code show a completion list, completions which
include auto-imports are displayed with a path to the given module; however,
this path usually isn‚Äôt what TypeScript ends up placing in a module specifier.
The path is usually something relative to the _workspace_ , meaning that if
you‚Äôre importing from a package like `moment`, you‚Äôll often see a path like
`node_modules/moment`.

![A completion list containing unwieldy paths containing 'node_modules'. For
example, the label for 'calendarFormat' is 'node_modules/moment/moment'
instead of 'moment'.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/08/completion-import-labels-pre-4-4.png)

These paths end up being unwieldy and often misleading, especially given that
the path that actually gets inserted into your file needs to consider Node‚Äôs
`node_modules` resolution, path mappings, symlinks, and re-exports.

That‚Äôs why with TypeScript 4.4, the completion item label now shows the
_actual_ module path that will be used for the import!

![A completion list containing clean paths with no intermediate
'node_modules'. For example, the label for 'calendarFormat' is 'moment'
instead of
'node_modules/moment/moment'.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/08/completion-import-labels-4-4.png)

Since this calculation can be expensive, completion lists containing many
auto-imports may fill in the final module specifiers in batches as you type
more characters. It‚Äôs possible that you‚Äôll still sometimes see the old
workspace-relative path labels; however, as your editing experience ‚Äúwarms
up‚Äù, they should get replaced with the actual path after another keystroke or
two.

## Breaking Changes

### `lib.d.ts` Changes for TypeScript 4.4

As with every TypeScript version, declarations for `lib.d.ts` (especially the
declarations generated for web contexts), have changed. You can consult [our
list of known `lib.dom.d.ts` changes](https://github.com/microsoft/TypeScript-
DOM-lib-generator/issues/1029#issuecomment-869224737) to understand what is
impacted.

### More-Compliant Indirect Calls for Imported Functions

In earlier versions of TypeScript, calling an import from CommonJS, AMD, and
other non-ES module systems would set the `this` value of the called function.
Specifically, in the following example, when calling `fooModule.foo()`, the
`foo()` method will have `fooModule` set as the value of `this`.

    
    
    ts
    
    // Imagine this is our imported module, and it has an export named 'foo'.
    
    let fooModule = {
    
      foo() {
    
        console.log(this);
    
      },
    
    };
    
    fooModule.foo();

This is not the way exported functions in ECMAScript are supposed to work when
we call them. That‚Äôs why TypeScript 4.4 intentionally discards the `this`
value when calling imported functions, by using the following emit.

    
    
    ts
    
    // Imagine this is our imported module, and it has an export named 'foo'.
    
    let fooModule = {
    
      foo() {
    
        console.log(this);
    
      },
    
    };
    
    // Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.
    
    (0, fooModule.foo)();

You can [read up more about the changes
here](https://github.com/microsoft/TypeScript/pull/44624).

### Using `unknown` in Catch Variables

Users running with the [`strict`](/tsconfig#strict) flag may see new errors
around `catch` variables being `unknown`, especially if the existing code
assumes only `Error` values have been caught. This often results in error
messages such as:

    
    
    Property 'message' does not exist on type 'unknown'.
    
    Property 'name' does not exist on type 'unknown'.
    
    Property 'stack' does not exist on type 'unknown'.

To get around this, you can specifically add runtime checks to ensure that the
thrown type matches your expected type. Otherwise, you can just use a type
assertion, add an explicit `: any` to your catch variable, or turn off
[`useUnknownInCatchVariables`](/tsconfig#useUnknownInCatchVariables).

### Broader Always-Truthy Promise Checks

In prior versions, TypeScript introduced ‚ÄúAlways Truthy Promise checks‚Äù to
catch code where an `await` may have been forgotten; however, the checks only
applied to named declarations. That meant that while this code would correctly
receive an error‚Ä¶

    
    
    ts
    
    async function foo(): Promise<boolean> {
    
      return false;
    
    }
    
    async function bar(): Promise<string> {
    
      const fooResult = foo();
    
      if (fooResult) {
    
        // <- error! :D
    
        return "true";
    
      }
    
      return "false";
    
    }

‚Ä¶the following code would not.

    
    
    ts
    
    async function foo(): Promise<boolean> {
    
      return false;
    
    }
    
    async function bar(): Promise<string> {
    
      if (foo()) {
    
        // <- no error :(
    
        return "true";
    
      }
    
      return "false";
    
    }

TypeScript 4.4 now flags both. For more information, [read up on the original
change](https://github.com/microsoft/TypeScript/pull/44491).

### Abstract Properties Do Not Allow Initializers

The following code is now an error because abstract properties may not have
initializers:

    
    
    ts
    
    abstract class C {
    
      abstract prop = 1;
    
      //       ~~~~
    
      // Property 'prop' cannot have an initializer because it is marked abstract.
    
    }

Instead, you may only specify a type for the property:

    
    
    ts
    
    abstract class C {
    
      abstract prop: number;
    
    }

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.4.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(2\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

EL![Eliran Levi
\(1\)](https://gravatar.com/avatar/8a81d3dd6957e01e288d05ebdd66466d?s=32&&d=blank)

AB![Andrew Branch
\(1\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.5

## Supporting `lib` from `node_modules`

To ensure that TypeScript and JavaScript support works well out of the box,
TypeScript bundles a series of declaration files (`.d.ts` files). These
declaration files represent the available APIs in the JavaScript language, and
the standard browser DOM APIs. While there are some reasonable defaults based
on your [`target`](/tsconfig#target), you can pick and choose which
declaration files your program uses by configuring the
[`lib`](https://www.typescriptlang.org/tsconfig#lib) setting in the
`tsconfig.json`.

There are two occasional downsides to including these declaration files with
TypeScript though:

  * When you upgrade TypeScript, you‚Äôre also forced to handle changes to TypeScript‚Äôs built-in declaration files, and this can be a challenge when the DOM APIs change as frequently as they do.
  * It is hard to customize these files to match your needs with the needs of your project‚Äôs dependencies (e.g. if your dependencies declare that they use the DOM APIs, you might also be forced into using the DOM APIs).

TypeScript 4.5 introduces a way to override a specific built-in `lib` in a
manner similar to how `@types/` support works. When deciding which `lib` files
TypeScript should include, it will first look for a scoped `@typescript/lib-*`
package in `node_modules`. For example, when including `dom` as an option in
`lib`, TypeScript will use the types in `node_modules/@typescript/lib-dom` if
available.

You can then use your package manager to install a specific package to take
over for a given `lib` For example, today TypeScript publishes versions of the
DOM APIs on `@types/web`. If you wanted to lock your project to a specific
version of the DOM APIs, you could add this to your `package.json`:

    
    
    json
    
    {
    
      "dependencies": {
    
        "@typescript/lib-dom": "npm:@types/web"
    
      }
    
    }

Then from 4.5 onwards, you can update TypeScript and your dependency manager‚Äôs
lockfile will ensure that it uses the exact same version of the DOM types.
That means you get to update your types on your own terms.

We‚Äôd like to give a shout-out to [saschanaz](https://github.com/saschanaz) who
has been extremely helpful and patient as we‚Äôve been building out and
experimenting with this feature.

For more information, you can [see the implementation of this
change](https://github.com/microsoft/TypeScript/pull/45771).

## The `Awaited` Type and `Promise` Improvements

TypeScript 4.5 introduces a new utility type called the `Awaited` type. This
type is meant to model operations like `await` in `async` functions, or the
`.then()` method on `Promise`s - specifically, the way that they recursively
unwrap `Promise`s.

    
    
    ts
    
    // A = string
    
    type A = Awaited<Promise<string>>;
    
    // B = number
    
    type B = Awaited<Promise<Promise<number>>>;
    
    // C = boolean | number
    
    type C = Awaited<boolean | Promise<number>>;

The `Awaited` type can be helpful for modeling existing APIs, including
JavaScript built-ins like `Promise.all`, `Promise.race`, etc. In fact, some of
the problems around inference with `Promise.all` served as motivations for
`Awaited`. Here‚Äôs an example that fails in TypeScript 4.4 and earlier.

    
    
    ts
    
    declare function MaybePromise<T>(value: T): T | Promise<T> | PromiseLike<T>;
    
    async function doSomething(): Promise<[number, number]> {
    
      const result = await Promise.all([MaybePromise(100), MaybePromise(200)]);
    
      // Error!
    
      //
    
      //    [number | Promise<100>, number | Promise<200>]
    
      //
    
      // is not assignable to type
    
      //
    
      //    [number, number]
    
      return result;
    
    }

Now `Promise.all` leverages the combination of certain features with `Awaited`
to give much better inference results, and the above example works.

For more information, you [can read about this change on
GitHub](https://github.com/microsoft/TypeScript/pull/45350).

## Template String Types as Discriminants

TypeScript 4.5 now can narrow values that have template string types, and also
recognizes template string types as discriminants.

As an example, the following used to fail, but now successfully type-checks in
TypeScript 4.5.

    
    
    ts
    
    export interface Success {
    
        type: `${string}Success`;
    
        body: string;
    
    }
    
    ¬†
    
    export interface Error {
    
        type: `${string}Error`;
    
        message: string
    
    }
    
    ¬†
    
    export function handler(r: Success | Error) {
    
        if (r.type === "HttpSuccess") {
    
            const token = r.body;
    
                         
    
    (parameter) r: Success
    
        }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgZQFdtcBnUuAbwCg464YBPMYALjgAMASS0mKZAHMAvkRLByHANy16AIwgATRuz4CkgmcOrVQkWIhRosuOAFEoUaFVl0mLdt178hwi1ajTbcALYTSmIJscGpC1Nq64NDw6IRI2DAIEEhwABaYSIoANmgAFFDsYmQUAD7mltAAlDb0iOhw+QB09ngAvO1wAEQAEjAwYEX+ndU0tbXYyXwMEADWwCmtcFCNCsoyY-QA9JsbGwB6APze2sJAA)

For more information, [see the change that enables this
feature](https://github.com/microsoft/TypeScript/pull/46137).

## `module es2022`

Thanks to [Kagami S. Rosylight](https://github.com/saschanaz), TypeScript now
supports a new `module` setting: `es2022`. The main feature in [`module
es2022`](/tsconfig#module) is top-level `await`, meaning you can use `await`
outside of `async` functions. This was already supported in `--module esnext`
(and now [`--module nodenext`](/tsconfig#target)), but `es2022` is the first
stable target for this feature.

You can [read up more on this change
here](https://github.com/microsoft/TypeScript/pull/44656).

## Tail-Recursion Elimination on Conditional Types

TypeScript often needs to gracefully fail when it detects possibly infinite
recursion, or any type expansions that can take a long time and affect your
editor experience. As a result, TypeScript has heuristics to make sure it
doesn‚Äôt go off the rails when trying to pick apart an infinitely-deep type, or
working with types that generate a lot of intermediate results.

    
    
    ts
    
    type InfiniteBox<T> = { item: InfiniteBox<T> };
    
    type Unpack<T> = T extends { item: infer U } ? Unpack<U> : T;
    
    // error: Type instantiation is excessively deep and possibly infinite.
    
    type Test = Unpack<InfiniteBox<number>>;

The above example is intentionally simple and useless, but there are plenty of
types that are actually useful, and unfortunately trigger our heuristics. As
an example, the following `TrimLeft` type removes spaces from the beginning of
a string-like type. If given a string type that has a space at the beginning,
it immediately feeds the remainder of the string back into `TrimLeft`.

    
    
    ts
    
    type TrimLeft<T extends string> =
    
        T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;
    
    // Test = "hello" | "world"
    
    type Test = TrimLeft<"   hello" | " world">;

This type can be useful, but if a string has 50 leading spaces, you‚Äôll get an
error.

    
    
    ts
    
    type TrimLeft<T extends string> =
    
        T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;
    
    // error: Type instantiation is excessively deep and possibly infinite.
    
    type Test = TrimLeft<"                                                oops">;

That‚Äôs unfortunate, because these kinds of types tend to be extremely useful
in modeling operations on strings - for example, parsers for URL routers. To
make matters worse, a more useful type typically creates more type
instantiations, and in turn has even more limitations on input length.

But there‚Äôs a saving grace: `TrimLeft` is written in a way that is _tail-
recursive_ in one branch. When it calls itself again, it immediately returns
the result and doesn‚Äôt do anything with it. Because these types don‚Äôt need to
create any intermediate results, they can be implemented more quickly and in a
way that avoids triggering many of type recursion heuristics that are built
into TypeScript.

That‚Äôs why TypeScript 4.5 performs some tail-recursion elimination on
conditional types. As long as one branch of a conditional type is simply
another conditional type, TypeScript can avoid intermediate instantiations.
There are still heuristics to ensure that these types don‚Äôt go off the rails,
but they are much more generous.

Keep in mind, the following type _won‚Äôt_ be optimized, since it uses the
result of a conditional type by adding it to a union.

    
    
    ts
    
    type GetChars<S> =
    
        S extends `${infer Char}${infer Rest}` ? Char | GetChars<Rest> : never;

If you would like to make it tail-recursive, you can introduce a helper that
takes an ‚Äúaccumulator‚Äù type parameter, just like with tail-recursive
functions.

    
    
    ts
    
    type GetChars<S> = GetCharsHelper<S, never>;
    
    type GetCharsHelper<S, Acc> =
    
        S extends `${infer Char}${infer Rest}` ? GetCharsHelper<Rest, Char | Acc> : Acc;

You can read up more on the implementation
[here](https://github.com/microsoft/TypeScript/pull/45711).

## Disabling Import Elision

There are some cases where TypeScript can‚Äôt detect that you‚Äôre using an
import. For example, take the following code:

    
    
    ts
    
    import { Animal } from "./animal.js";
    
    eval("console.log(new Animal().isDangerous())");

By default, TypeScript always removes this import because it appears to be
unused. In TypeScript 4.5, you can enable a new flag called
[`preserveValueImports`](/tsconfig#preserveValueImports) to prevent TypeScript
from stripping out any imported values from your JavaScript outputs. Good
reasons to use `eval` are few and far between, but something very similar to
this happens in Svelte:

    
    
    html
    
    <!-- A .svelte File -->
    
    <script>
    
      import { someFunc } from "./some-module.js";
    
    </script>
    
    <button on:click="{someFunc}">Click me!</button>

along with in Vue.js, using its `<script setup>` feature:

    
    
    html
    
    <!-- A .vue File -->
    
    <script setup>
    
      import { someFunc } from "./some-module.js";
    
    </script>
    
    <button @click="someFunc">Click me!</button>

These frameworks generate some code based on markup outside of their
`<script>` tags, but TypeScript _only_ sees code within the `<script>` tags.
That means TypeScript will automatically drop the import of `someFunc`, and
the above code won‚Äôt be runnable! With TypeScript 4.5, you can use
[`preserveValueImports`](/tsconfig#preserveValueImports) to avoid these
situations.

Note that this flag has a special requirement when combined with
[‚ÄîisolatedModules`](/tsconfig#isolatedModules): imported types _must_ be
marked as type-only because compilers that process single files at a time have
no way of knowing whether imports are values that appear unused, or a type
that must be removed in order to avoid a runtime crash.

    
    
    ts
    
    // Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,
    
    // ts-loader, esbuild, etc. don't, so `isolatedModules` gives an error.
    
    import { someFunc, BaseType } from "./some-module.js";
    
    //                 ^^^^^^^^
    
    // Error: 'BaseType' is a type and must be imported using a type-only import
    
    // when 'preserveValueImports' and 'isolatedModules' are both enabled.

That makes another TypeScript 4.5 feature, `type` modifiers on import names,
especially important.

For more information, [see the pull request
here](https://github.com/microsoft/TypeScript/pull/44619).

## `type` Modifiers on Import Names

As mentioned above, [`preserveValueImports`](/tsconfig#preserveValueImports)
and [`isolatedModules`](/tsconfig#isolatedModules) have special requirements
so that there‚Äôs no ambiguity for build tools whether it‚Äôs safe to drop type
imports.

    
    
    ts
    
    // Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,
    
    // ts-loader, esbuild, etc. don't, so `isolatedModules` issues an error.
    
    import { someFunc, BaseType } from "./some-module.js";
    
    //                 ^^^^^^^^
    
    // Error: 'BaseType' is a type and must be imported using a type-only import
    
    // when 'preserveValueImports' and 'isolatedModules' are both enabled.

When these options are combined, we need a way to signal when an import can be
legitimately dropped. TypeScript already has something for this with `import
type`:

    
    
    ts
    
    import type { BaseType } from "./some-module.js";
    
    import { someFunc } from "./some-module.js";
    
    export class Thing implements BaseType {
    
      // ...
    
    }

This works, but it would be nice to avoid two import statements for the same
module. That‚Äôs part of why TypeScript 4.5 allows a `type` modifier on
individual named imports, so that you can mix and match as needed.

    
    
    ts
    
    import { someFunc, type BaseType } from "./some-module.js";
    
    export class Thing implements BaseType {
    
        someMethod() {
    
            someFunc();
    
        }
    
    }

In the above example, `BaseType` is always guaranteed to be erased and
`someFunc` will be preserved under
[`preserveValueImports`](/tsconfig#preserveValueImports), leaving us with the
following code:

    
    
    js
    
    import { someFunc } from "./some-module.js";
    
    export class Thing {
    
      someMethod() {
    
        someFunc();
    
      }
    
    }

For more information, see [the changes on
GitHub](https://github.com/microsoft/TypeScript/pull/45998).

## Private Field Presence Checks

TypeScript 4.5 supports an ECMAScript proposal for checking whether an object
has a private field on it. You can now write a class with a `#private` field
member and see whether another object has the same field by using the `in`
operator.

    
    
    ts
    
    class Person {
    
        #name: string;
    
        constructor(name: string) {
    
            this.#name = name;
    
        }
    
        equals(other: unknown) {
    
            return other &&
    
                typeof other === "object" &&
    
                #name in other && // <- this is new!
    
                this.#name === other.#name;
    
        }
    
    }

One interesting aspect of this feature is that the check `#name in other`
implies that `other` must have been constructed as a `Person`, since there‚Äôs
no other way that field could be present. This is actually one of the key
features of the proposal, and it‚Äôs why the proposal is named ‚Äúergonomic brand
checks‚Äù - because private fields often act as a ‚Äúbrand‚Äù to guard against
objects that aren‚Äôt instances of their class. As such, TypeScript is able to
appropriately narrow the type of `other` on each check, until it ends up with
the type `Person`.

We‚Äôd like to extend a big thanks to our friends at Bloomberg [who contributed
this pull request](https://github.com/microsoft/TypeScript/pull/44648):
[Ashley Claymore](https://github.com/acutmore), [Titian Cernicova-
Dragomir](https://github.com/dragomirtitian), [Kubilay
Kahveci](https://github.com/mkubilayk), and [Rob
Palmer](https://github.com/robpalme)!

## Import Assertions

TypeScript 4.5 supports an ECMAScript proposal for _import assertions_. This
is a syntax used by runtimes to make sure that an import has an expected
format.

    
    
    ts
    
    import obj from "./something.json" assert { type: "json" };

The contents of these assertions are not checked by TypeScript since they‚Äôre
host-specific, and are simply left alone so that browsers and runtimes can
handle them (and possibly error).

    
    
    ts
    
    // TypeScript is fine with this.
    
    // But your browser? Probably not.
    
    import obj from "./something.json" assert {
    
        type: "fluffy bunny"
    
    };

Dynamic `import()` calls can also use import assertions through a second
argument.

    
    
    ts
    
    const obj = await import("./something.json", {
    
      assert: { type: "json" },
    
    });

The expected type of that second argument is defined by a new type called
`ImportCallOptions`, and currently only accepts an `assert` property.

We‚Äôd like to thank [Wenlu Wang](https://github.com/Kingwl/) for [implementing
this feature](https://github.com/microsoft/TypeScript/pull/40698)!

## Const Assertions and Default Type Arguments in JSDoc

TypeScript 4.5 brings some extra expressivity to our JSDoc support.

One example of this is with `const` assertions. In TypeScript, you can get a
more precise and immutable type by writing `as const` after a literal.

    
    
    ts
    
    // type is { prop: string }
    
    let a = { prop: "hello" };
    
    // type is { readonly prop: "hello" }
    
    let b = { prop: "hello" } as const;

In JavaScript files, you can now use JSDoc type assertions to achieve the same
thing.

    
    
    ts
    
    // type is { prop: string }
    
    let a = { prop: "hello" };
    
    // type is { readonly prop: "hello" }
    
    let b = /** @type {const} */ ({ prop: "hello" });

As a reminder, JSDoc type assertions comments start with `/** @type
{TheTypeWeWant} */` and are followed by a parenthesized expression:

    
    
    js
    
    /** @type {TheTypeWeWant} */` (someExpression)

TypeScript 4.5 also adds default type arguments to JSDoc, which means the
following `type` declaration in TypeScript:

    
    
    ts
    
    type Foo<T extends string | number = number> = { prop: T };

can be rewritten as the following `@typedef` declaration in JavaScript:

    
    
    js
    
    /**
    
     * @template {string | number} [T=number]
    
     * @typedef Foo
    
     * @property prop {T}
    
     */
    
    // or
    
    /**
    
     * @template {string | number} [T=number]
    
     * @typedef {{ prop: T }} Foo
    
     */

For more information, see [the pull request for const
assertions](https://github.com/microsoft/TypeScript/pull/45464) along with
[the changes for type argument
defaults](https://github.com/microsoft/TypeScript/pull/45483).

## Faster Load Time with `realPathSync.native`

TypeScript now leverages a system-native implementation of the Node.js
`realPathSync` function on all operating systems.

Previously this function was only used on Linux, but in TypeScript 4.5 it has
been adopted to operating systems that are typically case-insensitive, like
Windows and MacOS. On certain codebases, this change sped up project loading
by 5-13% (depending on the host operating system).

For more information, see [the original change
here](https://github.com/microsoft/TypeScript/pull/44966), along with [the
4.5-specific changes
here](https://github.com/microsoft/TypeScript/pull/44966).

## Snippet Completions for JSX Attributes

TypeScript 4.5 brings _snippet completions_ for JSX attributes. When writing
out an attribute in a JSX tag, TypeScript will already provide suggestions for
those attributes; but with snippet completions, they can remove a little bit
of extra typing by adding an initializer and putting your cursor in the right
place.

![Snippet completions for JSX attributes. For a string property, quotes are
automatically added. For a numeric properties, braces are
added.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/10/jsx-attributes-snippets-4-5.gif)

TypeScript will typically use the type of an attribute to figure out what kind
of initializer to insert, but you can customize this behavior in Visual Studio
Code.

![Settings in VS Code for JSX attribute
completions](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/10/jsx-snippet-settings-4-5.png)

Keep in mind, this feature will only work in newer versions of Visual Studio
Code, so you might have to use an Insiders build to get this working. For more
information, [read up on the original pull
request](https://github.com/microsoft/TypeScript/pull/45903)

## Better Editor Support for Unresolved Types

In some cases, editors will leverage a lightweight ‚Äúpartial‚Äù semantic mode -
either while the editor is waiting for the full project to load, or in
contexts like [GitHub‚Äôs web-based
editor](https://docs.github.com/en/codespaces/developing-in-codespaces/web-
based-editor).

In older versions of TypeScript, if the language service couldn‚Äôt find a type,
it would just print `any`.

![Hovering over a signature where Buffer isn't found, TypeScript replaces it
with any.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/10/quick-info-unresolved-4-4.png)

In the above example, `Buffer` wasn‚Äôt found, so TypeScript replaced it with
`any` in _quick info_. In TypeScript 4.5, TypeScript will try its best to
preserve what you wrote.

![Hovering over a signature where Buffer isn't found, it continues to use the
name Buffer.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/10/quick-info-unresolved-4-5.png)

However, if you hover over `Buffer` itself, you‚Äôll get a hint that TypeScript
couldn‚Äôt find `Buffer`.

![TypeScript displays type Buffer = /* unresolved */
any;](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2021/10/quick-info-unresolved-on-type-4-5.png)

Altogether, this provides a smoother experience when TypeScript doesn‚Äôt have
the full program available. Keep in mind, you‚Äôll always get an error in
regular scenarios to tell you when a type isn‚Äôt found.

For more information, [see the implementation
here](https://github.com/microsoft/TypeScript/pull/45976).

## Breaking Changes

### `lib.d.ts` Changes

TypeScript 4.5 contains changes to its built-in declaration files which may
affect your compilation; however, [these changes were fairly
minimal](https://github.com/microsoft/TypeScript-DOM-lib-
generator/issues/1143), and we expect most code will be unaffected.

### Inference Changes from `Awaited`

Because `Awaited` is now used in `lib.d.ts` and as a result of `await`, you
may see certain generic types change that might cause incompatibilities;
however, given many intentional design decisions around `Awaited` to avoid
breakage, we expect most code will be unaffected.

### Compiler Options Checking at the Root of `tsconfig.json`

It‚Äôs an easy mistake to accidentally forget about the `compilerOptions`
section in a `tsconfig.json`. To help catch this mistake, in TypeScript 4.5,
it is an error to add a top-level field which matches any of the available
options in `compilerOptions` _without_ having also defined `compilerOptions`
in that `tsconfig.json`.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.5.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(4\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

E![escudero89
\(1\)](https://gravatar.com/avatar/c691dffbb7116aa7b20dec8ba43fe0c4?s=32&&d=blank)

R![Retsam
\(1\)](https://gravatar.com/avatar/ab898171600ea13d4b6404b2e98d3eec?s=32&&d=blank)

N![navya9singh
\(1\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

HG![Holger Grosse-Plankermann
\(1\)](https://gravatar.com/avatar/5c22334f26c9523bc360ed5a68c25757?s=32&&d=blank)

4+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.6

## Allowing Code in Constructors Before `super()`

In JavaScript classes it‚Äôs mandatory to call `super()` before referring to
`this`. TypeScript enforces this as well, though it was a bit too strict in
_how_ it ensured this. In TypeScript, it was previously an error to contain
_any_ code at the beginning of a constructor if its containing class had any
property initializers.

    
    
    ts
    
    class Base {
    
      // ...
    
    }
    
    class Derived extends Base {
    
      someProperty = true;
    
      constructor() {
    
        // error!
    
        // have to call 'super()' first because it needs to initialize 'someProperty'.
    
        doSomeStuff();
    
        super();
    
      }
    
    }

This made it cheap to check that `super()` gets called before `this` is
referenced, but it ended up rejecting a lot of valid code. TypeScript 4.6 is
now much more lenient in that check and permits other code to run before
`super()`., all while still ensuring that `super()` occurs at the top-level
before any references to `this`.

We‚Äôd like to extend our thanks to [Joshua
Goldberg](https://github.com/JoshuaKGoldberg) for [patiently working with us
to land this change](https://github.com/microsoft/TypeScript/pull/29374)!

## Control Flow Analysis for Destructured Discriminated Unions

TypeScript is able to narrow types based on what‚Äôs called a discriminant
property. For example, in the following code snippet, TypeScript is able to
narrow the type of `action` based on every time we check against the value of
`kind`.

    
    
    ts
    
    type Action =
    
      | { kind: "NumberContents"; payload: number }
    
      | { kind: "StringContents"; payload: string };
    
    function processAction(action: Action) {
    
      if (action.kind === "NumberContents") {
    
        // `action.payload` is a number here.
    
        let num = action.payload * 2;
    
        // ...
    
      } else if (action.kind === "StringContents") {
    
        // `action.payload` is a string here.
    
        const str = action.payload.trim();
    
        // ...
    
      }
    
    }

This lets us work with objects that can hold different data, but a common
field tells us _which_ data those objects have.

This is very common in TypeScript; however, depending on your preferences, you
might have wanted to destructure `kind` and `payload` in the example above.
Perhaps something like the following:

    
    
    ts
    
    type Action =
    
      | { kind: "NumberContents"; payload: number }
    
      | { kind: "StringContents"; payload: string };
    
    function processAction(action: Action) {
    
      const { kind, payload } = action;
    
      if (kind === "NumberContents") {
    
        let num = payload * 2;
    
        // ...
    
      } else if (kind === "StringContents") {
    
        const str = payload.trim();
    
        // ...
    
      }
    
    }

Previously TypeScript would error on these - once `kind` and `payload` were
extracted from the same object into variables, they were considered totally
independent.

In TypeScript 4.6, this just works!

When destructuring individual properties into a `const` declaration, or when
destructuring a parameter into variables that are never assigned to,
TypeScript will check for if the destructured type is a discriminated union.
If it is, TypeScript can now narrow the types of variables depending on checks
of other variables So in our example, a check on `kind` narrows the type of
`payload`.

For more information, [see the pull request that implemented this
analysis](https://github.com/microsoft/TypeScript/pull/46266).

## Improved Recursion Depth Checks

TypeScript has some interesting challenges due to the fact that it‚Äôs built on
a structural type system that also provides generics.

In a structural type system, object types are compatible based on the members
they have.

    
    
    ts
    
    interface Source {
    
      prop: string;
    
    }
    
    interface Target {
    
      prop: number;
    
    }
    
    function check(source: Source, target: Target) {
    
      target = source;
    
      // error!
    
      // Type 'Source' is not assignable to type 'Target'.
    
      //   Types of property 'prop' are incompatible.
    
      //     Type 'string' is not assignable to type 'number'.
    
    }

Notice that whether or not `Source` is compatible with `Target` has to do with
whether their _properties_ are assignable. In this case, that‚Äôs just `prop`.

When you introduce generics into this, there are some harder questions to
answer. For instance, is a `Source<string>` assignable to a `Target<number>`
in the following case?

    
    
    ts
    
    interface Source<T> {
    
      prop: Source<Source<T>>;
    
    }
    
    interface Target<T> {
    
      prop: Target<Target<T>>;
    
    }
    
    function check(source: Source<string>, target: Target<number>) {
    
      target = source;
    
    }

In order to answer that, TypeScript needs to check whether the types of `prop`
are compatible. That leads to the another question: is a
`Source<Source<string>>` assignable to a `Target<Target<number>>`? To answer
that, TypeScript checks whether `prop` is compatible for _those_ types, and
ends up checking whether `Source<Source<Source<string>>>` is assignable to
`Target<Target<Target<number>>>`. Keep going for a bit, and you might notice
that the type infinitely expands the more you dig in.

TypeScript has a few heuristics here - if a type _appears_ to be infinitely
expanding after encountering a certain depth check, then it considers that the
types _could_ be compatible. This is usually enough, but embarrassingly there
were some false-negatives that this wouldn‚Äôt catch.

    
    
    ts
    
    interface Foo<T> {
    
      prop: T;
    
    }
    
    declare let x: Foo<Foo<Foo<Foo<Foo<Foo<string>>>>>>;
    
    declare let y: Foo<Foo<Foo<Foo<Foo<string>>>>>;
    
    x = y;

A human reader can see that `x` and `y` should be incompatible in the above
example. While the types are deeply nested, that‚Äôs just a consequence of how
they were declared. The heuristic was meant to capture cases where deeply-
nested types were generated through exploring the types, not from when a
developer wrote that type out themselves.

TypeScript 4.6 is now able to distinguish these cases, and correctly errors on
the last example. Additionally, because the language is no longer concerned
with false-positives from explicitly-written types, TypeScript can conclude
that a type is infinitely expanding much earlier, and save a bunch of work in
checking for type compatibility. As a result, libraries on DefinitelyTyped
like `redux-immutable`, `react-lazylog`, and `yup` saw a 50% reduction in
check-time.

You may already have this change because it was cherry-picked into TypeScript
4.5.3, but it is a notable feature of TypeScript 4.6 which you can read up
more about [here](https://github.com/microsoft/TypeScript/pull/46599).

## Indexed Access Inference Improvements

TypeScript now can correctly infer to indexed access types which immediately
index into a mapped object type.

    
    
    ts
    
    interface TypeMap {
    
      number: number;
    
      string: string;
    
      boolean: boolean;
    
    }
    
    type UnionRecord<P extends keyof TypeMap> = {
    
      [K in P]: {
    
        kind: K;
    
        v: TypeMap[K];
    
        f: (p: TypeMap[K]) => void;
    
      };
    
    }[P];
    
    function processRecord<K extends keyof TypeMap>(record: UnionRecord<K>) {
    
      record.f(record.v);
    
    }
    
    // This call used to have issues - now works!
    
    processRecord({
    
      kind: "string",
    
      v: "hello!",
    
      // 'val' used to implicitly have the type 'string | number | boolean',
    
      // but now is correctly inferred to just 'string'.
    
      f: (val) => {
    
        console.log(val.toUpperCase());
    
      },
    
    });

This pattern was already supported and allowed TypeScript to understand that
the call to `record.f(record.v)` is valid, but previously the call to
`processRecord` would give poor inference results for `val`

TypeScript 4.6 improves this so that no type assertions are necessary within
the call to `processRecord`.

For more information, you can [read up on the pull
request](https://github.com/microsoft/TypeScript/pull/47109).

## Control Flow Analysis for Dependent Parameters

A signature can be declared with a rest parameter whose type is a
discriminated union of tuples.

    
    
    ts
    
    function func(...args: ["str", string] | ["num", number]) {
    
      // ...
    
    }

What this says is that the arguments to `func` depends entirely on the first
argument. When the first argument is the string `"str"`, then its second
argument has to be a `string`. When its first argument is the string `"num"`,
its second argument has to be a `number`.

In cases where TypeScript infers the type of a function from a signature like
this, TypeScript can now narrow parameters that depend on each other.

    
    
    ts
    
    type Func = (...args: ["a", number] | ["b", string]) => void;
    
    const f1: Func = (kind, payload) => {
    
      if (kind === "a") {
    
        payload.toFixed(); // 'payload' narrowed to 'number'
    
      }
    
      if (kind === "b") {
    
        payload.toUpperCase(); // 'payload' narrowed to 'string'
    
      }
    
    };
    
    f1("a", 42);
    
    f1("b", "hello");

For more information, [see the change on
GitHub](https://github.com/microsoft/TypeScript/pull/47190).

## `--target es2022`

TypeScript‚Äôs `--target` option now supports `es2022`. This means features like
class fields now have a stable output target where they can be preserved. It
also means that new built-in functionality like the [`at()` method on
`Array`s](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Array/at),
[`Object.hasOwn`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn), or [the
`cause` option on `new Error`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error#rethrowing_an_error_with_a_cause)
can be used either with this new `--target` setting, or with `--lib es2022`.

This functionality was
[implemented](https://github.com/microsoft/TypeScript/pull/46291) by [Kagami
Sascha Rosylight (saschanaz)](https://github.com/saschanaz) over several PRs,
and we‚Äôre grateful for that contribution!

## Removed Unnecessary Arguments in `react-jsx`

Previously, when compiling code like the following in `--jsx react-jsx`

    
    
    tsx
    
    export const el = <div>foo</div>;

TypeScript would produce the following JavaScript code:

    
    
    jsx
    
    import { jsx as _jsx } from "react/jsx-runtime";
    
    export const el = _jsx("div", { children: "foo" }, void 0);

That last `void 0` argument is unnecessary in this emit mode, and removing it
can improve bundle sizes.

    
    
    diff
    
    - export const el = _jsx("div", { children: "foo" }, void 0);
    
    + export const el = _jsx("div", { children: "foo" });

Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/47467)
from [Alexander Tarasyuk](https://github.com/a-tarasyuk), TypeScript 4.6 now
drops the `void 0` argument.

## JSDoc Name Suggestions

In JSDoc, you can document parameters using an `@param` tag.

    
    
    js
    
    /**
    
     * @param x The first operand
    
     * @param y The second operand
    
     */
    
    function add(x, y) {
    
      return x + y;
    
    }

But what happens when these comments fall out of date? What if we rename `x`
and `y` to `a` and `b`?

    
    
    js
    
    /**
    
     * @param x {number} The first operand
    
     * @param y {number} The second operand
    
     */
    
    function add(a, b) {
    
      return a + b;
    
    }

Previously TypeScript would only tell you about this when performing type-
checking on JavaScript files - when using either the `checkJs` option, or
adding a `// @ts-check` comment to the top of your file.

You can now get similar information for TypeScript files in your editor!
TypeScript now provides suggestions for when parameter names don‚Äôt match
between your function and its JSDoc comment.

![Suggestion diagnostics being shown in the editor for parameter names in
JSDoc comments that don't match an actual parameter
name.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2022/02/jsdoc-comment-suggestions-4-6.png)

[This change](https://github.com/microsoft/TypeScript/pull/47257) was provided
courtesy of [Alexander Tarasyuk](https://github.com/a-tarasyuk)!

## More Syntax and Binding Errors in JavaScript

TypeScript has expanded its set of syntax and binding errors in JavaScript
files. You‚Äôll see these new errors if you open JavaScript files in an editor
like Visual Studio or Visual Studio Code, or if you run JavaScript code
through the TypeScript compiler - even if you don‚Äôt turn on `checkJs` or add a
`// @ts-check` comment to the top of your files.

As one example, if you have two declarations of a `const` in the same scope of
a JavaScript file, TypeScript will now issue an error on those declarations.

    
    
    ts
    
    const foo = 1234;
    
    //    ~~~
    
    // error: Cannot redeclare block-scoped variable 'foo'.
    
    // ...
    
    const foo = 5678;
    
    //    ~~~
    
    // error: Cannot redeclare block-scoped variable 'foo'.

As another example, TypeScript will let you know if a modifier is being
incorrectly used.

    
    
    ts
    
    function container() {
    
        export function foo() {
    
    //  ~~~~~~
    
    // error: Modifiers cannot appear here.
    
        }
    
    }

These errors can be disabled by adding a `// @ts-nocheck` at the top of your
file, but we‚Äôre interested in hearing some early feedback about how it works
for your JavaScript workflow. You can easily try it out for Visual Studio Code
by installing the [TypeScript and JavaScript Nightly
Extension](https://marketplace.visualstudio.com/items?itemName=ms-
vscode.vscode-typescript-next), and read up more on the
[first](https://github.com/microsoft/TypeScript/pull/47067) and
[second](https://github.com/microsoft/TypeScript/pull/47075) pull requests.

## TypeScript Trace Analyzer

Occasionally, teams may encounter types that are computationally expensive to
create and compare against other types. [TypeScript has a `--generateTrace`
flag](https://github.com/microsoft/TypeScript/wiki/Performance#performance-
tracing) to help identify some of those expensive types, or sometimes help
diagnose issues in the TypeScript compiler. While the information generated by
`--generateTrace` can be useful (especially with some information added in
TypeScript 4.6), it can often be hard to read in existing trace visualizers.

We recently published a tool called [@typescript/analyze-
trace](https://www.npmjs.com/package/@typescript/analyze-trace) to get a more
digestible view of this information. While we don‚Äôt expect everyone to need
`analyze-trace`, we think it can come in handy for any team that is running
into [build performance issues with
TypeScript](https://github.com/microsoft/TypeScript/wiki/Performance).

For more information, [see the `analyze-trace` tool‚Äôs
repo](https://github.com/microsoft/typescript-analyze-trace).

## Breaking Changes

### Object Rests Drop Unspreadable Members from Generic Objects

Object rest expressions now drop members that appear to be unspreadable on
generic objects. In the following example‚Ä¶

    
    
    ts
    
    class Thing {
    
      someProperty = 42;
    
      someMethod() {
    
        // ...
    
      }
    
    }
    
    function foo<T extends Thing>(x: T) {
    
      let { someProperty, ...rest } = x;
    
      // Used to work, is now an error!
    
      // Property 'someMethod' does not exist on type 'Omit<T, "someProperty" | "someMethod">'.
    
      rest.someMethod();
    
    }

the variable `rest` used to have the type `Omit<T, "someProperty">` because TypeScript would strictly analyze which other properties were destructured. This doesn‚Äôt model how `...rest` would work in a destructuring from a non-generic type because `someMethod` would typically be dropped as well. In TypeScript 4.6, the type of `rest` is `Omit<T, "someProperty" | "someMethod">`.

This can also come up in cases when destructuring from `this`. When
destructuring `this` using a `...rest` element, unspreadable and non-public
members are now dropped, which is consistent with destructuring instances of a
class in other places.

    
    
    ts
    
    class Thing {
    
      someProperty = 42;
    
      someMethod() {
    
        // ...
    
      }
    
      someOtherMethod() {
    
        let { someProperty, ...rest } = this;
    
        // Used to work, is now an error!
    
        // Property 'someMethod' does not exist on type 'Omit<T, "someProperty" | "someMethod">'.
    
        rest.someMethod();
    
      }
    
    }

For more details, [see the corresponding change
here](https://github.com/microsoft/TypeScript/pull/47078).

### JavaScript Files Always Receive Grammar and Binding Errors

Previously, TypeScript would ignore most grammar errors in JavaScript apart
from accidentally using TypeScript syntax in a JavaScript file. TypeScript now
shows JavaScript syntax and binding errors in your file, such as using
incorrect modifiers, duplicate declarations, and more. These will typically be
most apparent in Visual Studio Code or Visual Studio, but can also occur when
running JavaScript code through the TypeScript compiler.

You can explicitly turn these errors off by inserting a `// @ts-nocheck`
comment at the top of your file.

For more information, see the
[first](https://github.com/microsoft/TypeScript/pull/47067) and
[second](https://github.com/microsoft/TypeScript/pull/47075) implementing pull
requests for these features.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.6.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(6\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

AB![Andrew Branch
\(3\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

DP![Dimitri POSTOLOV
\(1\)](https://gravatar.com/avatar/368c461fad5615c8e8e7fd82fe6e7134?s=32&&d=blank)

N![navya9singh
\(1\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.7

## ECMAScript Module Support in Node.js

For the last few years, Node.js has been working to support ECMAScript modules
(ESM). This has been a very difficult feature, since the Node.js ecosystem is
built on a different module system called CommonJS (CJS). Interoperating
between the two brings large challenges, with many new features to juggle;
however, support for ESM in Node.js was largely implemented in Node.js 12 and
later. Around TypeScript 4.5 we rolled out nightly-only support for ESM in
Node.js to get some feedback from users and let library authors ready
themselves for broader support.

TypeScript 4.7 adds this functionality with two new `module` settings:
`node16` and `nodenext`.

    
    
    jsonc
    
    {
    
        "compilerOptions": {
    
            "module": "node16",
    
        }
    
    }

These new modes bring a few high-level features which we‚Äôll explore here.

### `type` in `package.json` and New Extensions

Node.js supports [a new setting in
`package.json`](https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions)
called `type`. `"type"` can be set to either `"module"` or `"commonjs"`.

    
    
    jsonc
    
    {
    
        "name": "my-package",
    
        "type": "module",
    
        "//": "...",
    
        "dependencies": {
    
        }
    
    }

This setting controls whether `.js` and `.d.ts` files are interpreted as ES
modules or CommonJS modules, and defaults to CommonJS when not set. When a
file is considered an ES module, a few different rules come into play compared
to CommonJS:

  * `import`/`export` statements can be used.
  * Top-level `await` can be used
  * Relative import paths need full extensions (we have to write `import "./foo.js"` instead of `import "./foo"`).
  * Imports might resolve differently from dependencies in `node_modules`.
  * Certain global-like values like `require` and `module` cannot be used directly.
  * CommonJS modules get imported under certain special rules.

We‚Äôll come back to some of these.

To overlay the way TypeScript works in this system, `.ts` and `.tsx` files now
work the same way. When TypeScript finds a `.ts`, `.tsx`, `.js`, or `.jsx`
file, it will walk up looking for a `package.json` to see whether that file is
an ES module, and use that to determine:

  * how to find other modules which that file imports
  * and how to transform that file if producing outputs

When a `.ts` file is compiled as an ES module, ECMAScript `import`/`export`
statements are left alone in the `.js` output; when it‚Äôs compiled as a
CommonJS module, it will produce the same output you get today under `--module
commonjs`.

This also means paths resolve differently between `.ts` files that are ES
modules and ones that are CJS modules. For example, let‚Äôs say you have the
following code today:

    
    
    ts
    
    // ./foo.ts
    
    export function helper() {
    
        // ...
    
    }
    
    // ./bar.ts
    
    import { helper } from "./foo"; // only works in CJS
    
    helper();

This code works in CommonJS modules, but will fail in ES modules because
relative import paths need to use extensions. As a result, it will have to be
rewritten to use the extension of the _output_ of `foo.ts` \- so `bar.ts` will
instead have to import from `./foo.js`.

    
    
    ts
    
    // ./bar.ts
    
    import { helper } from "./foo.js"; // works in ESM & CJS
    
    helper();

This might feel a bit cumbersome at first, but TypeScript tooling like auto-
imports and path completion will typically just do this for you.

One other thing to mention is the fact that this applies to `.d.ts` files too.
When TypeScript finds a `.d.ts` file in a package, it is interpreted based on
the containing package.

### New File Extensions

The `type` field in `package.json` is nice because it allows us to continue
using the `.ts` and `.js` file extensions which can be convenient; however,
you will occasionally need to write a file that differs from what `type`
specifies. You might also just prefer to always be explicit.

Node.js supports two extensions to help with this: `.mjs` and `.cjs`. `.mjs`
files are always ES modules, and `.cjs` files are always CommonJS modules, and
there‚Äôs no way to override these.

In turn, TypeScript supports two new source file extensions: `.mts` and
`.cts`. When TypeScript emits these to JavaScript files, it will emit them to
`.mjs` and `.cjs` respectively.

Furthermore, TypeScript also supports two new declaration file extensions:
`.d.mts` and `.d.cts`. When TypeScript generates declaration files for `.mts`
and `.cts`, their corresponding extensions will be `.d.mts` and `.d.cts`.

Using these extensions is entirely optional, but will often be useful even if
you choose not to use them as part of your primary workflow.

### CommonJS Interoperability

Node.js allows ES modules to import CommonJS modules as if they were ES
modules with a default export.

    
    
    ts
    
    // ./foo.cts
    
    export function helper() {
    
        console.log("hello world!");
    
    }
    
    // ./bar.mts
    
    import foo from "./foo.cjs";
    
    // prints "hello world!"
    
    foo.helper();

In some cases, Node.js also synthesizes named exports from CommonJS modules,
which can be more convenient. In these cases, ES modules can use a ‚Äúnamespace-
style‚Äù import (i.e. `import * as foo from "..."`), or named imports (i.e.
`import { helper } from "..."`).

    
    
    ts
    
    // ./foo.cts
    
    export function helper() {
    
        console.log("hello world!");
    
    }
    
    // ./bar.mts
    
    import { helper } from "./foo.cjs";
    
    // prints "hello world!"
    
    helper();

There isn‚Äôt always a way for TypeScript to know whether these named imports
will be synthesized, but TypeScript will err on being permissive and use some
heuristics when importing from a file that is definitely a CommonJS module.

One TypeScript-specific note about interop is the following syntax:

    
    
    ts
    
    import foo = require("foo");

In a CommonJS module, this just boils down to a `require()` call, and in an ES
module, this imports
[`createRequire`](https://nodejs.org/api/module.html#module_module_createrequire_filename)
to achieve the same thing. This will make code less portable on runtimes like
the browser (which don‚Äôt support `require()`), but will often be useful for
interoperability. In turn, you can write the above example using this syntax
as follows:

    
    
    ts
    
    // ./foo.cts
    
    export function helper() {
    
        console.log("hello world!");
    
    }
    
    // ./bar.mts
    
    import foo = require("./foo.cjs");
    
    foo.helper()

Finally, it‚Äôs worth noting that the only way to import ESM files from a CJS
module is using dynamic `import()` calls. This can present challenges, but is
the behavior in Node.js today.

You can [read more about ESM/CommonJS interop in Node.js
here](https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs).

### `package.json` Exports, Imports, and Self-Referencing

Node.js supports [a new field for defining entry points in `package.json`
called `"exports"`](https://nodejs.org/api/packages.html#packages_exports).
This field is a more powerful alternative to defining `"main"` in
`package.json`, and can control what parts of your package are exposed to
consumers.

Here‚Äôs a `package.json` that supports separate entry-points for CommonJS and
ESM:

    
    
    jsonc
    
    // package.json
    
    {
    
        "name": "my-package",
    
        "type": "module",
    
        "exports": {
    
            ".": {
    
                // Entry-point for `import "my-package"` in ESM
    
                "import": "./esm/index.js",
    
                // Entry-point for `require("my-package") in CJS
    
                "require": "./commonjs/index.cjs",
    
            },
    
        },
    
        // CJS fall-back for older versions of Node.js
    
        "main": "./commonjs/index.cjs",
    
    }

There‚Äôs a lot to this feature, [which you can read more about on the Node.js
documentation](https://nodejs.org/api/packages.html). Here we‚Äôll try to focus
on how TypeScript supports it.

With TypeScript‚Äôs original Node support, it would look for a `"main"` field,
and then look for declaration files that corresponded to that entry. For
example, if `"main"` pointed to `./lib/index.js`, TypeScript would look for a
file called `./lib/index.d.ts`. A package author could override this by
specifying a separate field called `"types"` (e.g. `"types":
"./types/index.d.ts"`).

The new support works similarly with [import
conditions](https://nodejs.org/api/packages.html). By default, TypeScript
overlays the same rules with import conditions - if you write an `import` from
an ES module, it will look up the `import` field, and from a CommonJS module,
it will look at the `require` field. If it finds them, it will look for a
corresponding declaration file. If you need to point to a different location
for your type declarations, you can add a `"types"` import condition.

    
    
    jsonc
    
    // package.json
    
    {
    
        "name": "my-package",
    
        "type": "module",
    
        "exports": {
    
            ".": {
    
                // Entry-point for `import "my-package"` in ESM
    
                "import": {
    
                    // Where TypeScript will look.
    
                    "types": "./types/esm/index.d.ts",
    
                    // Where Node.js will look.
    
                    "default": "./esm/index.js"
    
                },
    
                // Entry-point for `require("my-package") in CJS
    
                "require": {
    
                    // Where TypeScript will look.
    
                    "types": "./types/commonjs/index.d.cts",
    
                    // Where Node.js will look.
    
                    "default": "./commonjs/index.cjs"
    
                },
    
            }
    
        },
    
        // Fall-back for older versions of TypeScript
    
        "types": "./types/index.d.ts",
    
        // CJS fall-back for older versions of Node.js
    
        "main": "./commonjs/index.cjs"
    
    }

> The `"types"` condition should always come first in `"exports"`.

It‚Äôs important to note that the CommonJS entrypoint and the ES module
entrypoint each needs its own declaration file, even if the contents are the
same between them. Every declaration file is interpreted either as a CommonJS
module or as an ES module, based on its file extension and the `"type"` field
of the `package.json`, and this detected module kind must match the module
kind that Node will detect for the corresponding JavaScript file for type
checking to be correct. Attempting to use a single `.d.ts` file to type both
an ES module entrypoint and a CommonJS entrypoint will cause TypeScript to
think only one of those entrypoints exists, causing compiler errors for users
of the package.

TypeScript also supports [the `"imports"` field of
`package.json`](https://nodejs.org/api/packages.html#packages_imports) in a
similar manner by looking for declaration files alongside corresponding files,
and supports [packages self-referencing
themselves](https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name).
These features are generally not as involved to set up, but are supported.

### Your Feedback Wanted!

As we continue working on TypeScript 4.7, we expect to see more documentation
and polish go into this functionality. Supporting these new features has been
an ambitious under-taking, and that‚Äôs why we‚Äôre looking for early feedback on
it! Please try it out and let us know how it works for you.

For more information, [you can see the implementing PR
here](https://github.com/microsoft/TypeScript/pull/44501).

## Control over Module Detection

One issue with the introduction of modules to JavaScript was the ambiguity
between existing ‚Äúscript‚Äù code and the new module code. JavaScript code in a
module runs slightly differently, and has different scoping rules, so tools
have to make decisions as to how each file runs. For example, Node.js requires
module entry-points to be written in a `.mjs`, or have a nearby `package.json`
with `"type": "module"`. TypeScript treats a file as a module whenever it
finds any `import` or `export` statement in a file, but otherwise, will assume
a `.ts` or `.js` file is a script file acting on the global scope.

This doesn‚Äôt quite match up with the behavior of Node.js where the
`package.json` can change the format of a file, or the `--jsx` setting `react-
jsx`, where any JSX file contains an implicit import to a JSX factory. It also
doesn‚Äôt match modern expectations where most new TypeScript code is written
with modules in mind.

That‚Äôs why TypeScript 4.7 introduces a new option called `moduleDetection`.
`moduleDetection` can take on 3 values: `"auto"` (the default), `"legacy"`
(the same behavior as 4.6 and prior), and `"force"`.

Under the mode `"auto"`, TypeScript will not only look for `import` and
`export` statements, but it will also check whether

  * the `"type"` field in `package.json` is set to `"module"` when running under `--module nodenext`/`--module node16`, and
  * check whether the current file is a JSX file when running under `--jsx react-jsx`

In cases where you want every file to be treated as a module, the `"force"`
setting ensures that every non-declaration file is treated as a module. This
will be true regardless of how `module`, `moduleResolution`, and `jsx` are
configured.

Meanwhile, the `"legacy"` option simply goes back to the old behavior of only
seeking out `import` and `export` statements to determine whether a file is a
module.

You can [read up more about this change on the pull
request](https://github.com/microsoft/TypeScript/pull/47495).

## Control-Flow Analysis for Bracketed Element Access

TypeScript 4.7 now narrows the types of element accesses when the indexed keys
are literal types and unique symbols. For example, take the following code:

    
    
    ts
    
    const key = Symbol();
    
    const numberOrString = Math.random() < 0.5 ? 42 : "hello";
    
    const obj = {
    
        [key]: numberOrString,
    
    };
    
    if (typeof obj[key] === "string") {
    
        let str = obj[key].toUpperCase();
    
    }

Previously, TypeScript would not consider any type guards on `obj[key]`, and would have no idea that `obj[key]` was really a `string`. Instead, it would think that `obj[key]` was still a `string | number` and accessing `toUpperCase()` would trigger an error.

TypeScript 4.7 now knows that `obj[key]` is a string.

This also means that under `--strictPropertyInitialization`, TypeScript can
correctly check that computed properties are initialized by the end of a
constructor body.

    
    
    ts
    
    // 'key' has type 'unique symbol'
    
    const key = Symbol();
    
    class C {
    
        [key]: string;
    
        constructor(str: string) {
    
            // oops, forgot to set 'this[key]'
    
        }
    
        screamString() {
    
            return this[key].toUpperCase();
    
        }
    
    }

Under TypeScript 4.7, `--strictPropertyInitialization` reports an error
telling us that the `[key]` property wasn‚Äôt definitely assigned by the end of
the constructor.

We‚Äôd like to extend our gratitude to [Oleksandr
Tarasiuk](https://github.com/a-tarasyuk) who provided [this
change](https://github.com/microsoft/TypeScript/pull/45974)!

## Improved Function Inference in Objects and Methods

TypeScript 4.7 can now perform more granular inferences from functions within
objects and arrays. This allows the types of these functions to consistently
flow in a left-to-right manner just like for plain arguments.

    
    
    ts
    
    declare function f<T>(arg: {
    
        produce: (n: string) => T,
    
        consume: (x: T) => void }
    
    ): void;
    
    // Works
    
    f({
    
        produce: () => "hello",
    
        consume: x => x.toLowerCase()
    
    });
    
    // Works
    
    f({
    
        produce: (n: string) => n,
    
        consume: x => x.toLowerCase(),
    
    });
    
    // Was an error, now works.
    
    f({
    
        produce: n => n,
    
        consume: x => x.toLowerCase(),
    
    });
    
    // Was an error, now works.
    
    f({
    
        produce: function () { return "hello"; },
    
        consume: x => x.toLowerCase(),
    
    });
    
    // Was an error, now works.
    
    f({
    
        produce() { return "hello" },
    
        consume: x => x.toLowerCase(),
    
    });

Inference failed in some of these examples because knowing the type of their
`produce` functions would indirectly request the type of `arg` before finding
a good type for `T`. TypeScript now gathers functions that could contribute to
the inferred type of `T` and infers from them lazily.

For more information, you can [take a look at the specific modifications to
our inference process](https://github.com/microsoft/TypeScript/pull/48538).

## Instantiation Expressions

Occasionally functions can be a bit more general than we want. For example,
let‚Äôs say we had a `makeBox` function.

    
    
    ts
    
    interface Box<T> {
    
        value: T;
    
    }
    
    function makeBox<T>(value: T) {
    
        return { value };
    
    }

Maybe we want to create a more specialized set of functions for making `Box`es
of `Wrench`es and `Hammer`s. To do that today, we‚Äôd have to wrap `makeBox` in
other functions, or use an explicit type for an alias of `makeBox`.

    
    
    ts
    
    function makeHammerBox(hammer: Hammer) {
    
        return makeBox(hammer);
    
    }
    
    // or...
    
    const makeWrenchBox: (wrench: Wrench) => Box<Wrench> = makeBox;

These work, but wrapping a call to `makeBox` is a bit wasteful, and writing
the full signature of `makeWrenchBox` could get unwieldy. Ideally, we would be
able to say that we just want to alias `makeBox` while replacing all of the
generics in its signature.

TypeScript 4.7 allows exactly that! We can now take functions and constructors
and feed them type arguments directly.

    
    
    ts
    
    const makeHammerBox = makeBox<Hammer>;
    
    const makeWrenchBox = makeBox<Wrench>;

So with this, we can specialize `makeBox` to accept more specific types and
reject anything else.

    
    
    ts
    
    const makeStringBox = makeBox<string>;
    
    // TypeScript correctly rejects this.
    
    makeStringBox(42);

This logic also works for constructor functions such as `Array`, `Map`, and
`Set`.

    
    
    ts
    
    // Has type `new () => Map<string, Error>`
    
    const ErrorMap = Map<string, Error>;
    
    // Has type `// Map<string, Error>`
    
    const errorMap = new ErrorMap();

When a function or constructor is given type arguments, it will produce a new
type that keeps all signatures with compatible type parameter lists, and
replaces the corresponding type parameters with the given type arguments. Any
other signatures are dropped, as TypeScript will assume that they aren‚Äôt meant
to be used.

For more information on this feature, [check out the pull
request](https://github.com/microsoft/TypeScript/pull/47607).

## `extends` Constraints on `infer` Type Variables

Conditional types are a bit of a power-user feature. They allow us to match
and infer against the shape of types, and make decisions based on them. For
example, we can write a conditional type that returns the first element of a
tuple type if it‚Äôs a `string`-like type.

    
    
    ts
    
    type FirstIfString<T> =
    
        T extends [infer S, ...unknown[]]
    
            ? S extends string ? S : never
    
            : never;
    
     // string
    
    type A = FirstIfString<[string, number, number]>;
    
    // "hello"
    
    type B = FirstIfString<["hello", number, number]>;
    
    // "hello" | "world"
    
    type C = FirstIfString<["hello" | "world", boolean]>;
    
    // never
    
    type D = FirstIfString<[boolean, number, string]>;

`FirstIfString` matches against any tuple with at least one element and grabs
the type of the first element as `S`. Then it checks if `S` is compatible with
`string` and returns that type if it is.

Note that we had to use two conditional types to write this. We could have
written `FirstIfString` as follows:

    
    
    ts
    
    type FirstIfString<T> =
    
        T extends [string, ...unknown[]]
    
            // Grab the first type out of `T`
    
            ? T[0]
    
            : never;

This works, but it‚Äôs slightly more ‚Äúmanual‚Äù and less declarative. Instead of
just pattern-matching on the type and giving the first element a name, we have
to fetch out the `0`th element of `T` with `T[0]`. If we were dealing with
types more complex than tuples, this could get a lot trickier, so `infer` can
simplify things.

Using nested conditionals to infer a type and then match against that inferred
type is pretty common. To avoid that second level of nesting, TypeScript 4.7
now allows you to place a constraint on any `infer` type.

    
    
    ts
    
    type FirstIfString<T> =
    
        T extends [infer S extends string, ...unknown[]]
    
            ? S
    
            : never;

This way, when TypeScript matches against `S`, it also ensures that `S` has to
be a `string`. If `S` isn‚Äôt a `string`, it takes the false path, which in
these cases is `never`.

For more details, you can [read up on the change on
GitHub](https://github.com/microsoft/TypeScript/pull/48112).

## Optional Variance Annotations for Type Parameters

Let‚Äôs take the following types.

    
    
    ts
    
    interface Animal {
    
        animalStuff: any;
    
    }
    
    interface Dog extends Animal {
    
        dogStuff: any;
    
    }
    
    // ...
    
    type Getter<T> = () => T;
    
    type Setter<T> = (value: T) => void;

Imagine we had two different instances of `Getter`s. Figuring out whether any
two different `Getter`s are substitutable for one another depends entirely on
`T`. In the case of whether an assignment of `Getter<Dog>` ‚Üí `Getter<Animal>`
is valid, we have to check whether `Dog` ‚Üí `Animal` is valid. Because each
type for `T` just gets related in the same ‚Äúdirection‚Äù, we say that the
`Getter` type is _covariant_ on `T`. On the other hand, checking whether
`Setter<Dog>` ‚Üí `Setter<Animal>` is valid involves checking whether `Animal` ‚Üí
`Dog` is valid. That ‚Äúflip‚Äù in direction is kind of like how in math, checking
whether ‚àí _x_ <  _‚àíy_ is the same as checking whether _y_ <  _x_. When we have
to flip directions like this to compare `T`, we say that `Setter` is
_contravariant_ on `T`.

With TypeScript 4.7, we‚Äôre now able to _explicitly_ specify variance on type
parameters.

So now, if we want to make it explicit that `Getter` is covariant on `T`, we
can now give it an `out` modifier.

    
    
    ts
    
    type Getter<out T> = () => T;

And similarly, if we also want to make it explicit that `Setter` is
contravariant on `T`, we can give it an `in` modifier.

    
    
    ts
    
    type Setter<in T> = (value: T) => void;

`out` and `in` are used here because a type parameter‚Äôs variance depends on
whether it‚Äôs used in an _output_ or an _input_. Instead of thinking about
variance, you can just think about if `T` is used in output and input
positions.

There are also cases for using both `in` and `out`.

    
    
    ts
    
    interface State<in out T> {
    
        get: () => T;
    
        set: (value: T) => void;
    
    }

When a `T` is used in both an output and input position, it becomes
_invariant_. Two different `State<T>`s can‚Äôt be interchanged unless their `T`s
are the same. In other words, `State<Dog>` and `State<Animal>` aren‚Äôt
substitutable for the other.

Now technically speaking, in a purely structural type system, type parameters
and their variance don‚Äôt really matter - you can just plug in types in place
of each type parameter and check whether each matching member is structurally
compatible. So if TypeScript uses a structural type system, why are we
interested in the variance of type parameters? And why might we ever want to
annotate them?

One reason is that it can be useful for a reader to explicitly see how a type
parameter is used at a glance. For much more complex types, it can be
difficult to tell whether a type is meant to be read, written, or both.
TypeScript will also help us out if we forget to mention how that type
parameter is used. As an example, if we forgot to specify both `in` and `out`
on `State`, we‚Äôd get an error.

    
    
    ts
    
    interface State<out T> {
    
        //          ~~~~~
    
        // error!
    
        // Type 'State<sub-T>' is not assignable to type 'State<super-T>' as implied by variance annotation.
    
        //   Types of property 'set' are incompatible.
    
        //     Type '(value: sub-T) => void' is not assignable to type '(value: super-T) => void'.
    
        //       Types of parameters 'value' and 'value' are incompatible.
    
        //         Type 'super-T' is not assignable to type 'sub-T'.
    
        get: () => T;
    
        set: (value: T) => void;
    
    }

Another reason is precision and speed! TypeScript already tries to infer the
variance of type parameters as an optimization. By doing this, it can type-
check larger structural types in a reasonable amount of time. Calculating
variance ahead of time allows the type-checker to skip deeper comparisons and
just compare type arguments which can be _much_ faster than comparing the full
structure of a type over and over again. But often there are cases where this
calculation is still fairly expensive, and the calculation may find
circularities that can‚Äôt be accurately resolved, meaning there‚Äôs no clear
answer for the variance of a type.

    
    
    ts
    
    type Foo<T> = {
    
        x: T;
    
        f: Bar<T>;
    
    }
    
    type Bar<U> = (x: Baz<U[]>) => void;
    
    type Baz<V> = {
    
        value: Foo<V[]>;
    
    }
    
    declare let foo1: Foo<unknown>;
    
    declare let foo2: Foo<string>;
    
    foo1 = foo2;  // Should be an error but isn't ‚ùå
    
    foo2 = foo1;  // Error - correct ‚úÖ

Providing an explicit annotation can speed up type-checking at these
circularities and provide better accuracy. For instance, marking `T` as
invariant in the above example can help stop the problematic assignment.

    
    
    diff
    
    - type Foo<T> = {
    
    + type Foo<in out T> = {
    
          x: T;
    
          f: Bar<T>;
    
      }

We don‚Äôt necessarily recommend annotating every type parameter with its
variance; For example, it‚Äôs possible (but not recommended) to make variance a
little stricter than is necessary, so TypeScript won‚Äôt stop you from marking
something as invariant if it‚Äôs really just covariant, contravariant, or even
independent. So if you do choose to add explicit variance markers, we would
encourage thoughtful and precise use of them.

But if you‚Äôre working with deeply recursive types, especially if you‚Äôre a
library author, you may be interested in using these annotations to the
benefit of your users. Those annotations can provide wins in both accuracy and
type-checking speed, which can even affect their code editing experience.
Determining when variance calculation is a bottleneck on type-checking time
can be done experimentally, and determined using tooling like our [analyze-
trace](https://github.com/microsoft/typescript-analyze-trace) utility.

For more details on this feature, you can [read up on the pull
request](https://github.com/microsoft/TypeScript/pull/48240).

## Resolution Customization with `moduleSuffixes`

TypeScript 4.7 now supports a `moduleSuffixes` option to customize how module
specifiers are looked up.

    
    
    jsonc
    
    {
    
        "compilerOptions": {
    
            "moduleSuffixes": [".ios", ".native", ""]
    
        }
    
    }

Given the above configuration, an import like the following‚Ä¶

    
    
    ts
    
    import * as foo from "./foo";

will try to look at the relative files `./foo.ios.ts`, `./foo.native.ts`, and
finally `./foo.ts`.

This feature can be useful for React Native projects where each target
platform can use a separate `tsconfig.json` with differing `moduleSuffixes`.

[The `moduleSuffixes`
option](https://github.com/microsoft/TypeScript/pull/48189) was contributed
thanks to [Adam Foxman](https://github.com/afoxman)!

## resolution-mode

With Node‚Äôs ECMAScript resolution, the mode of the containing file and the
syntax you use determines how imports are resolved; however it would be useful
to reference the types of a CommonJS module from an ECMAScript module, or
vice-versa.

TypeScript now allows `/// <reference types="..." />` directives.

    
    
    ts
    
    /// <reference types="pkg" resolution-mode="require" />
    
    // or
    
    /// <reference types="pkg" resolution-mode="import" />

Additionally, in nightly versions of TypeScript, `import type` can specify an
import assertion to achieve something similar.

    
    
    ts
    
    // Resolve `pkg` as if we were importing with a `require()`
    
    import type { TypeFromRequire } from "pkg" assert {
    
        "resolution-mode": "require"
    
    };
    
    // Resolve `pkg` as if we were importing with an `import`
    
    import type { TypeFromImport } from "pkg" assert {
    
        "resolution-mode": "import"
    
    };
    
    export interface MergedType extends TypeFromRequire, TypeFromImport {}

These import assertions can also be used on `import()` types.

    
    
    ts
    
    export type TypeFromRequire =
    
        import("pkg", { assert: { "resolution-mode": "require" } }).TypeFromRequire;
    
    export type TypeFromImport =
    
        import("pkg", { assert: { "resolution-mode": "import" } }).TypeFromImport;
    
    export interface MergedType extends TypeFromRequire, TypeFromImport {}

The `import type` and `import()` syntaxes only support `resolution-mode` in
[nightly builds of
TypeScript](https://www.typescriptlang.org/docs/handbook/nightly-builds.html).
You‚Äôll likely get an error like

    
    
    Resolution mode assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.

If you do find yourself using this feature in nightly versions of TypeScript,
[consider providing feedback on this
issue](https://github.com/microsoft/TypeScript/issues/49055).

You can see the respective changes [for reference
directives](https://github.com/microsoft/TypeScript/pull/47732) and [for type
import assertions](https://github.com/microsoft/TypeScript/pull/47807).

## Go to Source Definition

TypeScript 4.7 contains support for a new experimental editor command called
_Go To Source Definition_. It‚Äôs similar to _Go To Definition_ , but it never
returns results inside declaration files. Instead, it tries to find
corresponding _implementation_ files (like `.js` or `.ts` files), and find
definitions there ‚Äî even if those files are normally shadowed by `.d.ts`
files.

This comes in handy most often when you need to peek at the implementation of
a function you‚Äôre importing from a library instead of its type declaration in
a `.d.ts` file.

![The "Go to Source Definition" command on a use of the yargs package jumps
the editor to an index.cjs file in
yargs.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2022/05/go-to-source-definition-4-7-v1.gif)

You can try this new command in the latest versions of Visual Studio Code.
Note, though, that this functionality is still in preview, and there are some
known limitations. In some cases TypeScript uses heuristics to guess which
`.js` file corresponds to the given result of a definition, so these results
might be inaccurate. Visual Studio Code also doesn‚Äôt yet indicate whether a
result was a guess, but it‚Äôs something we‚Äôre collaborating on.

You can leave feedback about the feature, read about known limitations, or
learn more at [our dedicated feedback
issue](https://github.com/microsoft/TypeScript/issues/49003).

## Group-Aware Organize Imports

TypeScript has an _Organize Imports_ editor feature for both JavaScript and
TypeScript. Unfortunately, it could be a bit of a blunt instrument, and would
often naively sort your import statements.

For instance, if you ran Organize Imports on the following file‚Ä¶

    
    
    ts
    
    // local code
    
    import * as bbb from "./bbb";
    
    import * as ccc from "./ccc";
    
    import * as aaa from "./aaa";
    
    // built-ins
    
    import * as path from "path";
    
    import * as child_process from "child_process"
    
    import * as fs from "fs";
    
    // some code...

You would get something like the following

    
    
    ts
    
    // local code
    
    import * as child_process from "child_process";
    
    import * as fs from "fs";
    
    // built-ins
    
    import * as path from "path";
    
    import * as aaa from "./aaa";
    
    import * as bbb from "./bbb";
    
    import * as ccc from "./ccc";
    
    // some code...

This is‚Ä¶ not ideal. Sure, our imports are sorted by their paths, and our
comments and newlines are preserved, but not in a way we expected. Much of the
time, if we have our imports grouped in a specific way, then we want to keep
them that way.

TypeScript 4.7 performs Organize Imports in a group-aware manner. Running it
on the above code looks a little bit more like what you‚Äôd expect:

    
    
    ts
    
    // local code
    
    import * as aaa from "./aaa";
    
    import * as bbb from "./bbb";
    
    import * as ccc from "./ccc";
    
    // built-ins
    
    import * as child_process from "child_process";
    
    import * as fs from "fs";
    
    import * as path from "path";
    
    // some code...

We‚Äôd like to extend our thanks to [Minh Quy](https://github.com/MQuy) who
provided [this feature](https://github.com/microsoft/TypeScript/pull/48330).

## Object Method Snippet Completions

TypeScript now provides snippet completions for object literal methods. When
completing members in an object, TypeScript will provide a typical completion
entry for just the name of a method, along with a separate completion entry
for the full method definition!

![Completion a full method signature from an
object](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2022/05/object-method-completions-4-7-v2.gif)

For more details, [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/48168).

## Breaking Changes

### `lib.d.ts` Updates

While TypeScript strives to avoid major breaks, even small changes in the
built-in libraries can cause issues. We don‚Äôt expect major breaks as a result
of DOM and `lib.d.ts` updates, but there may be some small ones.

### Stricter Spread Checks in JSX

When writing a `...spread` in JSX, TypeScript now enforces stricter checks
that the given type is actually an object. As a result, values with the types
`unknown` and `never` (and more rarely, just bare `null` and `undefined`) can
no longer be spread into JSX elements.

So for the following example:

    
    
    tsx
    
    import * as React from "react";
    
    interface Props {
    
        stuff?: string;
    
    }
    
    function MyComponent(props: unknown) {
    
        return <div {...props} />;
    
    }

you‚Äôll now receive an error like the following:

    
    
    Spread types may only be created from object types.

This makes this behavior more consistent with spreads in object literals.

For more details, [see the change on
GitHub](https://github.com/microsoft/TypeScript/pull/48570).

### Stricter Checks with Template String Expressions

When a `symbol` value is used in a template string, it will trigger a runtime
error in JavaScript.

    
    
    js
    
    let str = `hello ${Symbol()}`;
    
    // TypeError: Cannot convert a Symbol value to a string

As a result, TypeScript will issue an error as well; however, TypeScript now
also checks if a generic value that is constrained to a symbol in some way is
used in a template string.

    
    
    ts
    
    function logKey<S extends string | symbol>(key: S): S {
    
        // Now an error.
    
        console.log(`${key} is the key`);
    
        return key;
    
    }
    
    function get<T, K extends keyof T>(obj: T, key: K) {
    
        // Now an error.
    
        console.log(`Grabbing property '${key}'.`);
    
        return obj[key];
    
    }

TypeScript will now issue the following error:

    
    
    Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.

In some cases, you can get around this by wrapping the expression in a call to
`String`, just like the error message suggests.

    
    
    ts
    
    function logKey<S extends string | symbol>(key: S): S {
    
        // No longer an error.
    
        console.log(`${String(key)} is the key`);
    
        return key;
    
    }

In others, this error is too pedantic, and you might not ever care to even
allow `symbol` keys when using `keyof`. In such cases, you can switch to
`string & keyof ...`:

    
    
    ts
    
    function get<T, K extends string & keyof T>(obj: T, key: K) {
    
        // No longer an error.
    
        console.log(`Grabbing property '${key}'.`);
    
        return obj[key];
    
    }

For more information, you can [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/44578).

### `readFile` Method is No Longer Optional on `LanguageServiceHost`

If you‚Äôre creating `LanguageService` instances, then provided
`LanguageServiceHost`s will need to provide a `readFile` method. This change
was necessary to support the new `moduleDetection` compiler option.

You can [read more on the change
here](https://github.com/microsoft/TypeScript/pull/47495).

### `readonly` Tuples Have a `readonly` `length` Property

A `readonly` tuple will now treat its `length` property as `readonly`. This
was almost never witnessable for fixed-length tuples, but was an oversight
which could be observed for tuples with trailing optional and rest element
types.

As a result, the following code will now fail:

    
    
    ts
    
    function overwriteLength(tuple: readonly [string, string, string]) {
    
        // Now errors.
    
        tuple.length = 7;
    
    }

You can [read more on this change
here](https://github.com/microsoft/TypeScript/pull/47717).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.7.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(9\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

NT![N√©meth Tam√°s
\(1\)](https://gravatar.com/avatar/dacfdcffb8f4a94c46651a0dc87d28e6?s=32&&d=blank)

PADPB![Pedro Augusto de Paula Barbosa
\(1\)](https://gravatar.com/avatar/2bdf75e80ee06d182d7e7c5870c163c6?s=32&&d=blank)

HC![Hyunyoung Cho
\(1\)](https://gravatar.com/avatar/e0634b35bf2e1305464d65a95a6473b6?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.8

## Improved Intersection Reduction, Union Compatibility, and Narrowing

TypeScript 4.8 brings a series of correctness and consistency improvements
under `--strictNullChecks`. These changes affect how intersection and union
types work, and are leveraged in how TypeScript narrows types.

For example, `unknown` is close in spirit to the union type `{} | null | undefined` because it accepts `null`, `undefined`, and any other type. TypeScript now recognizes this, and allows assignments from `unknown` to `{} | null | undefined`.
    
    
    ts
    
    function f(x: unknown, y: {} | null | undefined) {
    
        x = y; // always worked
    
        y = x; // used to error, now works
    
    }

Another change is that `{}` intersected with any other object type simplifies
right down to that object type. That meant that we were able to rewrite
`NonNullable` to just use an intersection with `{}`, because `{} & null` and
`{} & undefined` just get tossed away.

    
    
    diff
    
    - type NonNullable<T> = T extends null | undefined ? never : T;
    
    + type NonNullable<T> = T & {};

This is an improvement because intersection types like this can be reduced and
assigned to, while conditional types currently cannot. So
`NonNullable<NonNullable<T>>` now simplifies at least to `NonNullable<T>`,
whereas it didn‚Äôt before.

    
    
    ts
    
    function foo<T>(x: NonNullable<T>, y: NonNullable<NonNullable<T>>) {
    
        x = y; // always worked
    
        y = x; // used to error, now works
    
    }

These changes also allowed us to bring in sensible improvements in control flow analysis and type narrowing. For example, `unknown` is now narrowed just like `{} | null | undefined` in truthy branches.
    
    
    ts
    
    function narrowUnknownishUnion(x: {} | null | undefined) {
    
        if (x) {
    
            x;  // {}
    
        }
    
        else {
    
            x;  // {} | null | undefined
    
        }
    
    }
    
    function narrowUnknown(x: unknown) {
    
        if (x) {
    
            x;  // used to be 'unknown', now '{}'
    
        }
    
        else {
    
            x;  // unknown
    
        }
    
    }

Generic values also get narrowed similarly. When checking that a value isn‚Äôt
`null` or `undefined`, TypeScript now just intersects it with `{}` \- which
again, is the same as saying it‚Äôs `NonNullable`. Putting many of the changes
here together, we can now define the following function without any type
assertions.

    
    
    ts
    
    function throwIfNullable<T>(value: T): NonNullable<T> {
    
        if (value === undefined || value === null) {
    
            throw Error("Nullable value!");
    
        }
    
        // Used to fail because 'T' was not assignable to 'NonNullable<T>'.
    
        // Now narrows to 'T & {}' and succeeds because that's just 'NonNullable<T>'.
    
        return value;
    
    }

`value` now gets narrowed to `T & {}`, and is now identical with
`NonNullable<T>` \- so the body of the function just works with no TypeScript-
specific syntax.

On their own, these changes may appear small - but they represent fixes for
many many paper cuts that have been reported over several years.

For more specifics on these improvements, you can [read more
here](https://github.com/microsoft/TypeScript/pull/49119).

## Improved Inference for `infer` Types in Template String Types

TypeScript recently introduced a way to add `extends` constraints to `infer`
type variables in conditional types.

    
    
    ts
    
    // Grabs the first element of a tuple if it's assignable to 'number',
    
    // and returns 'never' if it can't find one.
    
    type TryGetNumberIfFirst<T> =
    
        T extends [infer U extends number, ...unknown[]] ? U : never;

If these `infer` types appear in a template string type and are constrained to
a primitive type, TypeScript will now try to parse out a literal type.

    
    
    ts
    
    // SomeNum used to be 'number'; now it's '100'.
    
    type SomeNum = "100" extends `${infer U extends number}` ? U : never;
    
    // SomeBigInt used to be 'bigint'; now it's '100n'.
    
    type SomeBigInt = "100" extends `${infer U extends bigint}` ? U : never;
    
    // SomeBool used to be 'boolean'; now it's 'true'.
    
    type SomeBool = "true" extends `${infer U extends boolean}` ? U : never;

This can now better convey what a library will do at runtime, and give more
precise types.

One note on this is that when TypeScript parses these literal types out it
will greedily try to parse out as much of what looks like of the appropriate
primitive type; however it then checks to see if the print-back of that
primitive matches up with the string contents. In other words, TypeScript
checks whether the going from the string, to the primitive, and back matches.
If it doesn‚Äôt see that the string can be ‚Äúround-tripped‚Äù, then it will fall
back to the base primitive type.

    
    
    ts
    
    // JustNumber is `number` here because TypeScript parses out `"1.0"`, but `String(Number("1.0"))` is `"1"` and doesn't match.
    
    type JustNumber = "1.0" extends `${infer T extends number}` ? T : never; 

You can [see more about this feature
here](https://github.com/microsoft/TypeScript/pull/48094).

## `--build`, `--watch`, and `--incremental` Performance Improvements

TypeScript 4.8 introduces several optimizations that should speed up scenarios
around `--watch` and `--incremental`, along with project references builds
using `--build`. For example, TypeScript is now able to avoid spending time
updating timestamps during no-op changes in `--watch` mode, which makes
rebuilds faster and avoids messing with other build tools that might be
watching for TypeScript‚Äôs output. Many other optimizations where we‚Äôre able to
reuse information across `--build`, `--watch`, and `--incremental` have been
introduced as well.

How big are these improvements? Well, on a fairly large internal codebase,
we‚Äôve seen time reductions on the order of 10%-25% on many simple common
operations, with around 40% time reductions in no-change scenarios. We‚Äôve seen
similar results on the TypeScript codebase as well.

You can see [the changes, along with the performance results on
GitHub](https://github.com/microsoft/TypeScript/pull/48784).

## Errors When Comparing Object and Array Literals

In many languages, operators like `==` perform what‚Äôs called ‚Äúvalue‚Äù equality
on objects. For example, in Python it‚Äôs valid to check whether a list is empty
by checking whether a value is equal to the empty list using `==`.

    
    
    py
    
    if people_at_home == []:
    
        print("here's where I lie, broken inside. </3")
    
        adopt_animals()

This is not the case in JavaScript, where `==` and `===` between objects (and
therefore, arrays) check whether both references point to the same value. We
believe that similar code in JavaScript is at best an early foot-gun for
JavaScript developers, and at worst a bug in production code. That‚Äôs why
TypeScript now disallows code like the following.

    
    
    ts
    
    if (peopleAtHome === []) {
    
    //  ~~~~~~~~~~~~~~~~~~~
    
    // This condition will always return 'false' since JavaScript compares objects by reference, not value.
    
        console.log("here's where I lie, broken inside. </3")
    
        adoptAnimals();
    
    }

We‚Äôd like to extend our gratitude to [Jack Works](https://github.com/Jack-
Works) who contributed this check. You can [view the changes involved
here](https://github.com/microsoft/TypeScript/pull/45978).

## Improved Inference from Binding Patterns

In some cases, TypeScript will pick up a type from a binding pattern to make
better inferences.

    
    
    ts
    
    declare function chooseRandomly<T>(x: T, y: T): T;
    
    let [a, b, c] = chooseRandomly([42, true, "hi!"], [0, false, "bye!"]);
    
    //   ^  ^  ^
    
    //   |  |  |
    
    //   |  |  string
    
    //   |  |
    
    //   |  boolean
    
    //   |
    
    //   number

When `chooseRandomly` needs to figure out a type for `T`, it will primarily look at `[42, true, "hi!"]` and `[0, false, "bye!"]`; but TypeScript needs to figure out whether those two types should be `Array<number | boolean | string>` or the tuple type `[number, boolean, string]`. To do that, it will look for existing candidates as a hint to see whether there are any tuple types. When TypeScript sees the binding pattern `[a, b, c]`, it creates the type `[any, any, any]`, and that type gets picked up as a low-priority candidate for `T` which also gets used as a hint for the types of `[42, true, "hi!"]` and `[0, false, "bye!"]`.

You can see how this was good for `chooseRandomly`, but it fell short in other
cases. For example, take the following code

    
    
    ts
    
    declare function f<T>(x?: T): T;
    
    let [x, y, z] = f();

The binding pattern `[x, y, z]` hinted that `f` should produce an `[any, any,
any]` tuple; but `f` really shouldn‚Äôt change its type argument based on a
binding pattern. It can‚Äôt suddenly conjure up a new array-like value based on
what it‚Äôs being assigned to, so the binding pattern type has way too much
influence on the produced type. On top of that, because the binding pattern
type is full of `any`s, we‚Äôre left with `x`, `y`, and `z` being typed as
`any`.

In TypeScript 4.8, these binding patterns are never used as candidates for
type arguments. Instead, they‚Äôre just consulted in case a parameter needs a
more specific type like in our `chooseRandomly` example. If you need to revert
to the old behavior, you can always provide explicit type arguments.

You can [look at the change on
GitHub](https://github.com/microsoft/TypeScript/pull/49086) if you‚Äôre curious
to learn more.

## File-Watching Fixes (Especially Across `git checkout`s)

We‚Äôve had a long-standing bug where TypeScript has a very hard time with
certain file changes in `--watch` mode and editor scenarios. Sometimes the
symptoms are stale or inaccurate errors that might show up that require
restarting `tsc` or VS Code. Frequently these occur on Unix systems, and you
might have seen these after saving a file with vim or swapping branches in
git.

This was caused by assumptions of how Node.js handles rename events across
file systems. File systems used by Linux and macOS utilize
[inodes](https://en.wikipedia.org/wiki/Inode), and [Node.js will attach file
watchers to inodes rather than file
paths](https://nodejs.org/api/fs.html#inodes). So when Node.js returns [a
watcher object](https://nodejs.org/api/fs.html#class-fsfswatcher), it might be
watching a path or an inode depending on the platform and file system.

To be a bit more efficient, TypeScript tries to reuse the same watcher objects
if it detects a path still exists on disk. This is where things went wrong,
because even if a file still exists at that path, a distinct file might have
been created, and that file will have a different inode. So TypeScript would
end up reusing the watcher object instead of installing a new watcher at the
original location, and watch for changes at what might be a totally irrelevant
file. So TypeScript 4.8 now handles these cases on inode systems and properly
installs a new watcher and fixes this.

We‚Äôd like to extend our thanks to [Marc Celani](https://github.com/MarcCelani-
at) and his team at Airtable who invested lots of time in investigating the
issues they were experiencing and pointing out the root cause. You can view
[the specific fixes around file-watching
here](https://github.com/microsoft/TypeScript/pull/48997).

## Find-All-References Performance Improvements

When running find-all-references in your editor, TypeScript is now able to act
a little smarter as it aggregates references. This reduced the amount of time
TypeScript took to search a widely-used identifier in its own codebase by
about 20%.

[You can read up more on the improvement
here](https://github.com/microsoft/TypeScript/pull/49581).

## Exclude Specific Files from Auto-Imports

TypeScript 4.8 introduces an editor preference for excluding files from auto-
imports. In Visual Studio Code, file names or globs can be added under ‚ÄúAuto
Import File Exclude Patterns‚Äù in the Settings UI, or in a
`.vscode/settings.json` file:

    
    
    jsonc
    
    {
    
        // Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.
    
        "typescript.preferences.autoImportFileExcludePatterns": [
    
          "**/node_modules/@types/node"
    
        ]
    
    }

This can be useful in cases where you can‚Äôt avoid having certain modules or
libraries in your compilation but you rarely want to import from them. These
modules might have lots of exports that can pollute the auto-imports list and
make it harder to navigate, and this option can help in those situations.

You can [see more specifics about the implementation
here](https://github.com/microsoft/TypeScript/pull/49578).

## Correctness Fixes and Breaking Changes

Due to the nature of type system changes, there are very few changes that can
be made that don‚Äôt affect _some_ code; however, there are a few changes that
are more likely to require adapting existing code.

### `lib.d.ts` Updates

While TypeScript strives to avoid major breaks, even small changes in the
built-in libraries can cause issues. We don‚Äôt expect major breaks as a result
of DOM and `lib.d.ts` updates, but one notable change is that the `cause`
property on `Error`s now has the type `unknown` instead of `Error`.

### Unconstrained Generics No Longer Assignable to `{}`

In TypeScript 4.8, for projects with `strictNullChecks` enabled, TypeScript
will now correctly issue an error when an unconstrained type parameter is used
in a position where `null` or `undefined` are not legal values. That will
include any type that expects `{}`, `object`, or an object type with all-
optional properties.

A simple example can be seen in the following.

    
    
    ts
    
    // Accepts any non-null non-undefined value
    
    function bar(value: {}) {
    
      Object.keys(value); // This call throws on null/undefined at runtime.
    
    }
    
    // Unconstrained type parameter T...
    
    function foo<T>(x: T) {
    
        bar(x); // Used to be allowed, now is an error in 4.8.
    
        //  ~
    
        // error: Argument of type 'T' is not assignable to parameter of type '{}'.
    
    }
    
    foo(undefined);

As demonstrated above, code like this has a potential bug - the values `null`
and `undefined` can be indirectly passed through these unconstrained type
parameters to code that is not supposed to observe those values.

This behavior will also be visible in type positions. One example would be:

    
    
    ts
    
    interface Foo<T> {
    
      x: Bar<T>;
    
    }
    
    interface Bar<T extends {}> { }

Existing code that didn‚Äôt want to handle `null` and `undefined` can be fixed
by propagating the appropriate constraints through.

    
    
    diff
    
    - function foo<T>(x: T) {
    
    + function foo<T extends {}>(x: T) {

Another work-around would be to check for `null` and `undefined` at runtime.

    
    
    diff
    
      function foo<T>(x: T) {
    
    +     if (x !== null && x !== undefined) {
    
              bar(x);
    
    +     }
    
      }

And if you know that for some reason, your generic value can‚Äôt be `null` or
`undefined`, you can just use a non-null assertion.

    
    
    diff
    
      function foo<T>(x: T) {
    
    -     bar(x);
    
    +     bar(x!);
    
      }

When it comes to types, you‚Äôll often either need to propagate constraints, or
intersect your types with `{}`.

For more information, you can [see the change that introduced
this](https://github.com/microsoft/TypeScript/pull/49119) along with [the
specific discussion issue regarding how unconstrained generics now
work](https://github.com/microsoft/TypeScript/issues/49489).

### Decorators are placed on `modifiers` on TypeScript‚Äôs Syntax Trees

The current direction of decorators in TC39 means that TypeScript will have to
handle a break in terms of placement of decorators. Previously, TypeScript
assumed decorators would always be placed prior to all keywords/modifiers. For
example

    
    
    ts
    
    @decorator
    
    export class Foo {
    
      // ...
    
    }

Decorators as currently proposed do not support this syntax. Instead, the
`export` keyword must precede the decorator.

    
    
    ts
    
    export @decorator class Foo {
    
      // ...
    
    }

Unfortunately, TypeScript‚Äôs trees are _concrete_ rather than _abstract_ , and
our architecture expects syntax tree node fields to be entirely ordered before
or after each other. To support both legacy decorators and decorators as
proposed, TypeScript will have to gracefully parse, and intersperse, modifiers
and decorators.

To do this, it exposes a new type alias called `ModifierLike` which is a
`Modifier` or a `Decorator`.

    
    
    ts
    
    export type ModifierLike = Modifier | Decorator;

Decorators are now placed in the same field as `modifiers` which is now a
`NodeArray<ModifierLike>` when set, and the entire field is deprecated.

    
    
    diff
    
    - readonly modifiers?: NodeArray<Modifier> | undefined;
    
    + /**
    
    +  * @deprecated ...
    
    +  * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
    
    +  * Use `ts.getModifiers()` to get the modifiers of a `Node`.
    
    +  * ...
    
    +  */
    
    + readonly modifiers?: NodeArray<ModifierLike> | undefined;

All existing `decorators` properties have been marked as deprecated and will
always be `undefined` if read. The type has also been changed to `undefined`
so that existing tools know to handle them correctly.

    
    
    diff
    
    - readonly decorators?: NodeArray<Decorator> | undefined;
    
    + /**
    
    +  * @deprecated ...
    
    +  * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
    
    +  * Use `ts.getDecorators()` to get the decorators of a `Node`.
    
    +  * ...
    
    +  */
    
    + readonly decorators?: undefined;

To avoid new deprecation warnings and other issues, TypeScript now exposes
four new functions to use in place of the `decorators` and `modifiers`
properties. There are individual predicates for testing whether a node has
support modifiers and decorators, along with respective accessor functions for
grabbing them.

    
    
    ts
    
    function canHaveModifiers(node: Node): node is HasModifiers;
    
    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
    
    function canHaveDecorators(node: Node): node is HasDecorators;
    
    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;

As an example of how to access modifiers off of a node, you can write

    
    
    ts
    
    const modifiers = canHaveModifiers(myNode) ? getModifiers(myNode) : undefined;

With the note that each call to `getModifiers` and `getDecorators` may
allocate a new array.

For more information, see changes around

  * [the restructuring of our tree nodes](https://github.com/microsoft/TypeScript/pull/49089)
  * [the deprecations](https://github.com/microsoft/TypeScript/pull/50343)
  * [exposing the predicate functions](https://github.com/microsoft/TypeScript/pull/50399)

### Types Cannot Be Imported/Exported in JavaScript Files

TypeScript previously allowed JavaScript files to import and export entities
declared with a type, but no value, in `import` and `export` statements. This
behavior was incorrect, because named imports and exports for values that
don‚Äôt exist will cause a runtime error under ECMAScript modules. When a
JavaScript file is type-checked under `--checkJs` or through a `// @ts-check`
comment, TypeScript will now issue an error.

    
    
    ts
    
    // @ts-check
    
    // Will fail at runtime because 'SomeType' is not a value.
    
    import { someValue, SomeType } from "some-module";
    
    /**
    
     * @type {SomeType}
    
     */
    
    export const myValue = someValue;
    
    /**
    
     * @typedef {string | number} MyType
    
     */
    
    // Will fail at runtime because 'MyType' is not a value.
    
    export { MyType as MyExportedType };

To reference a type from another module, you can instead directly qualify the
import.

    
    
    diff
    
    - import { someValue, SomeType } from "some-module";
    
    + import { someValue } from "some-module";
    
      
    
      /**
    
    -  * @type {SomeType}
    
    +  * @type {import("some-module").SomeType}
    
       */
    
      export const myValue = someValue;

To export a type, you can just use a `/** @typedef */` comment in JSDoc.
`@typedef` comments already automatically export types from their containing
modules.

    
    
    diff
    
      /**
    
       * @typedef {string | number} MyType
    
       */
    
    + /**
    
    +  * @typedef {MyType} MyExportedType
    
    +  */
    
    - export { MyType as MyExportedType };

You can [read more about the change
here](https://github.com/microsoft/TypeScript/pull/49580).

### Binding Patterns Do Not Directly Contribute to Inference Candidates

As mentioned above, binding patterns no longer change the type of inference
results in function calls. You can [read more about the original change
here](https://github.com/microsoft/TypeScript/pull/49086).

### Unused Renames in Binding Patterns are Now Errors in Type Signatures

TypeScript‚Äôs type annotation syntax often looks like it can be used when
destructuring values. For example, take the following function.

    
    
    ts
    
    declare function makePerson({ name: string, age: number }): Person;

You might read this signature and think that `makePerson` obviously takes an
object with a `name` property with the type `string` and an `age` property
with the type `number`; however, JavaScript‚Äôs destructuring syntax is actually
taking precedence here. `makePerson` does say that it‚Äôs going to take an
object with a `name` and an `age` property, but instead of specifying a type
for them, it‚Äôs just saying that it renames `name` and `age` to `string` and
`number` respectively.

In a pure type construct, writing code like this is useless, and typically a
mistake since developers usually assume they‚Äôre writing a type annotation.

TypeScript 4.8 makes these an error unless they‚Äôre referenced later in the
signature. The correct way to write the above signature would be as follows:

    
    
    ts
    
    declare function makePerson(options: { name: string, age: number }): Person;
    
    // or
    
    declare function makePerson({ name, age }: { name: string, age: number }): Person;

This change can catch bugs in declarations, and has been helpful for improving
existing code. We‚Äôd like to extend our thanks to [GitHub user
uhyo](https://github.com/uhyo) for providing this check. [You can read up on
the change here](https://github.com/microsoft/TypeScript/pull/41044).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.8.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 4.9

## The `satisfies` Operator

TypeScript developers are often faced with a dilemma: we want to ensure that
some expression _matches_ some type, but also want to keep the _most specific_
type of that expression for inference purposes.

For example:

    
    
    ts
    
    // Each property can be a string or an RGB tuple.
    
    const palette = {
    
        red: [255, 0, 0],
    
        green: "#00ff00",
    
        bleu: [0, 0, 255]
    
    //  ^^^^ sacrebleu - we've made a typo!
    
    };
    
    // We want to be able to use string methods on 'green'...
    
    const greenNormalized = palette.green.toUpperCase();

Notice that we‚Äôve written `bleu`, whereas we probably should have written
`blue`. We could try to catch that `bleu` typo by using a type annotation on
`palette`, but we‚Äôd lose the information about each property.

    
    
    ts
    
    type Colors = "red" | "green" | "blue";
    
    type RGB = [red: number, green: number, blue: number];
    
    const palette: Record<Colors, string | RGB> = {
    
        red: [255, 0, 0],
    
        green: "#00ff00",
    
        bleu: [0, 0, 255]
    
    //  ~~~~ The typo is now correctly detected
    
    };
    
    // But we now have an undesirable error here - 'palette.green' "could" be of type RGB and
    
    // property 'toUpperCase' does not exist on type 'string | RGB'.
    
    const greenNormalized = palette.green.toUpperCase();

The new `satisfies` operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression. As an example, we could use `satisfies` to validate that all the properties of `palette` are compatible with `string | number[]`:
    
    
    ts
    
    type Colors = "red" | "green" | "blue";
    
    type RGB = [red: number, green: number, blue: number];
    
    const palette = {
    
        red: [255, 0, 0],
    
        green: "#00ff00",
    
        bleu: [0, 0, 255]
    
    //  ~~~~ The typo is now caught!
    
    } satisfies Record<Colors, string | RGB>;
    
    // toUpperCase() method is still accessible!
    
    const greenNormalized = palette.green.toUpperCase();

`satisfies` can be used to catch lots of possible errors. For example, we
could ensure that an object has _all_ the keys of some type, but no more:

    
    
    ts
    
    type Colors = "red" | "green" | "blue";
    
    // Ensure that we have exactly the keys from 'Colors'.
    
    const favoriteColors = {
    
        "red": "yes",
    
        "green": false,
    
        "blue": "kinda",
    
        "platypus": false
    
    //  ~~~~~~~~~~ error - "platypus" was never listed in 'Colors'.
    
    } satisfies Record<Colors, unknown>;
    
    // All the information about the 'red', 'green', and 'blue' properties are retained.
    
    const g: boolean = favoriteColors.green;

Maybe we don‚Äôt care about if the property names match up somehow, but we do
care about the types of each property. In that case, we can also ensure that
all of an object‚Äôs property values conform to some type.

    
    
    ts
    
    type RGB = [red: number, green: number, blue: number];
    
    const palette = {
    
        red: [255, 0, 0],
    
        green: "#00ff00",
    
        blue: [0, 0]
    
        //    ~~~~~~ error!
    
    } satisfies Record<string, string | RGB>;
    
    // Information about each property is still maintained.
    
    const redComponent = palette.red.at(0);
    
    const greenNormalized = palette.green.toUpperCase();

For more examples, you can see the [issue proposing
this](https://github.com/microsoft/TypeScript/issues/47920) and [the
implementing pull
request](https://github.com/microsoft/TypeScript/pull/46827). We‚Äôd like to
thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) who implemented and
iterated on this feature with us.

## Unlisted Property Narrowing with the `in` Operator

As developers, we often need to deal with values that aren‚Äôt fully known at
runtime. In fact, we often don‚Äôt know if properties exist, whether we‚Äôre
getting a response from a server or reading a configuration file. JavaScript‚Äôs
`in` operator can check whether a property exists on an object.

Previously, TypeScript allowed us to narrow away any types that don‚Äôt
explicitly list a property.

    
    
    ts
    
    interface RGB {
    
        red: number;
    
        green: number;
    
        blue: number;
    
    }
    
    interface HSV {
    
        hue: number;
    
        saturation: number;
    
        value: number;
    
    }
    
    function setColor(color: RGB | HSV) {
    
        if ("hue" in color) {
    
            // 'color' now has the type HSV
    
        }
    
        // ...
    
    }

Here, the type `RGB` didn‚Äôt list the `hue` and got narrowed away, and leaving
us with the type `HSV`.

But what about examples where no type listed a given property? In those cases,
the language didn‚Äôt help us much. Let‚Äôs take the following example in
JavaScript:

    
    
    js
    
    function tryGetPackageName(context) {
    
        const packageJSON = context.packageJSON;
    
        // Check to see if we have an object.
    
        if (packageJSON && typeof packageJSON === "object") {
    
            // Check to see if it has a string name property.
    
            if ("name" in packageJSON && typeof packageJSON.name === "string") {
    
                return packageJSON.name;
    
            }
    
        }
    
        return undefined;
    
    }

Rewriting this to canonical TypeScript would just be a matter of defining and
using a type for `context`; however, picking a safe type like `unknown` for
the `packageJSON` property would cause issues in older versions of TypeScript.

    
    
    ts
    
    interface Context {
    
        packageJSON: unknown;
    
    }
    
    function tryGetPackageName(context: Context) {
    
        const packageJSON = context.packageJSON;
    
        // Check to see if we have an object.
    
        if (packageJSON && typeof packageJSON === "object") {
    
            // Check to see if it has a string name property.
    
            if ("name" in packageJSON && typeof packageJSON.name === "string") {
    
            //                                              ~~~~
    
            // error! Property 'name' does not exist on type 'object.
    
                return packageJSON.name;
    
            //                     ~~~~
    
            // error! Property 'name' does not exist on type 'object.
    
            }
    
        }
    
        return undefined;
    
    }

This is because while the type of `packageJSON` was narrowed from `unknown` to
`object`, the `in` operator strictly narrowed to types that actually defined
the property being checked. As a result, the type of `packageJSON` remained
`object`.

TypeScript 4.9 makes the `in` operator a little bit more powerful when
narrowing types that _don‚Äôt_ list the property at all. Instead of leaving them
as-is, the language will intersect their types with `Record<"property-key-
being-checked", unknown>`.

So in our example, `packageJSON` will have its type narrowed from `unknown` to
`object` to `object & Record<"name", unknown>` That allows us to access
`packageJSON.name` directly and narrow that independently.

    
    
    ts
    
    interface Context {
    
        packageJSON: unknown;
    
    }
    
    function tryGetPackageName(context: Context): string | undefined {
    
        const packageJSON = context.packageJSON;
    
        // Check to see if we have an object.
    
        if (packageJSON && typeof packageJSON === "object") {
    
            // Check to see if it has a string name property.
    
            if ("name" in packageJSON && typeof packageJSON.name === "string") {
    
                // Just works!
    
                return packageJSON.name;
    
            }
    
        }
    
        return undefined;
    
    }

TypeScript 4.9 also tightens up a few checks around how `in` is used, ensuring that the left side is assignable to the type `string | number | symbol`, and the right side is assignable to `object`. This helps check that we‚Äôre using valid property keys, and not accidentally checking primitives.

For more information, [read the implementing pull
request](https://github.com/microsoft/TypeScript/pull/50666)

## Auto-Accessors in Classes

TypeScript 4.9 supports an upcoming feature in ECMAScript called auto-
accessors. Auto-accessors are declared just like properties on classes, except
that they‚Äôre declared with the `accessor` keyword.

    
    
    ts
    
    class Person {
    
        accessor name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
    }

Under the covers, these auto-accessors ‚Äúde-sugar‚Äù to a `get` and `set`
accessor with an unreachable private property.

    
    
    ts
    
    class Person {
    
        #__name: string;
    
        get name() {
    
            return this.#__name;
    
        }
    
        set name(value: string) {
    
            this.#__name = value;
    
        }
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
    }

You can [read up more about the auto-accessors pull request on the original
PR](https://github.com/microsoft/TypeScript/pull/49705).

## Checks For Equality on `NaN`

A major gotcha for JavaScript developers is checking against the value `NaN`
using the built-in equality operators.

For some background, `NaN` is a special numeric value that stands for ‚ÄúNot a
Number‚Äù. Nothing is ever equal to `NaN` \- even `NaN`!

    
    
    js
    
    console.log(NaN == 0)  // false
    
    console.log(NaN === 0) // false
    
    console.log(NaN == NaN)  // false
    
    console.log(NaN === NaN) // false

But at least symmetrically _everything_ is always not-equal to `NaN`.

    
    
    js
    
    console.log(NaN != 0)  // true
    
    console.log(NaN !== 0) // true
    
    console.log(NaN != NaN)  // true
    
    console.log(NaN !== NaN) // true

This technically isn‚Äôt a JavaScript-specific problem, since any language that
contains IEEE-754 floats has the same behavior; but JavaScript‚Äôs primary
numeric type is a floating point number, and number parsing in JavaScript can
often result in `NaN`. In turn, checking against `NaN` ends up being fairly
common, and the correct way to do so is to use
[`Number.isNaN`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN) \- _but_ as we
mentioned, lots of people accidentally end up checking with `someValue ===
NaN` instead.

TypeScript now errors on direct comparisons against `NaN`, and will suggest
using some variation of `Number.isNaN` instead.

    
    
    ts
    
    function validate(someValue: number) {
    
        return someValue !== NaN;
    
        //     ~~~~~~~~~~~~~~~~~
    
        // error: This condition will always return 'true'.
    
        //        Did you mean '!Number.isNaN(someValue)'?
    
    }

We believe that this change should strictly help catch beginner errors,
similar to how TypeScript currently issues errors on comparisons against
object and array literals.

We‚Äôd like to extend our thanks to [Oleksandr
Tarasiuk](https://github.com/a-tarasyuk) who [contributed this
check](https://github.com/microsoft/TypeScript/pull/50626).

## File-Watching Now Uses File System Events

In earlier versions, TypeScript leaned heavily on _polling_ for watching
individual files. Using a polling strategy meant checking the state of a file
periodically for updates. On Node.js,
[`fs.watchFile`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilefilename-
options-listener) is the built-in way to get a polling file-watcher. While
polling tends to be more predictable across platforms and file systems, it
means that your CPU has to periodically get interrupted and check for updates
to the file, even when nothing‚Äôs changed. For a few dozen files, this might
not be noticeable; but on a bigger project with lots of files - or lots of
files in `node_modules` \- this can become a resource hog.

Generally speaking, a better approach is to use file system events. Instead of
polling, we can announce that we‚Äôre interested in updates of specific files
and provide a callback for when those files _actually do_ change. Most modern
platforms in use provide facilities and APIs like `CreateIoCompletionPort`,
`kqueue`, `epoll`, and `inotify`. Node.js mostly abstracts these away by
providing
[`fs.watch`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilename-
options-listener). File system events usually work great, but there are [lots
of caveats](https://nodejs.org/docs/latest-v18.x/api/fs.html#caveats) to using
them, and in turn, to using the `fs.watch` API. A watcher needs to be careful
to consider [inode
watching](https://nodejs.org/docs/latest-v18.x/api/fs.html#inodes),
[unavailability on certain file
systems](https://nodejs.org/docs/latest-v18.x/api/fs.html#availability)
(e.g.networked file systems), whether recursive file watching is available,
whether directory renames trigger events, and even file watcher exhaustion! In
other words, it‚Äôs not quite a free lunch, especially if you‚Äôre looking for
something cross-platform.

As a result, our default was to pick the lowest common denominator: polling.
Not always, but most of the time.

Over time, we‚Äôve provided the means to [choose other file-watching
strategies](https://www.typescriptlang.org/docs/handbook/configuring-
watch.html). This allowed us to get feedback and harden our file-watching
implementation against most of these platform-specific gotchas. As TypeScript
has needed to scale to larger codebases, and has improved in this area, we
felt swapping to file system events as the default would be a worthwhile
investment.

In TypeScript 4.9, file watching is powered by file system events by default,
only falling back to polling if we fail to set up event-based watchers. For
most developers, this should provide a much less resource-intensive experience
when running in `--watch` mode, or running with a TypeScript-powered editor
like Visual Studio or VS Code.

[The way file-watching works can still be
configured](https://www.typescriptlang.org/docs/handbook/configuring-
watch.html) through environment variables and `watchOptions` \- and [some
editors like VS Code can support `watchOptions`
independently](https://code.visualstudio.com/docs/getstarted/settings#:~:text=typescript%2etsserver%2ewatchOptions).
Developers using more exotic set-ups where source code resides on a networked
file systems (like NFS and SMB) may need to opt back into the older behavior;
though if a server has reasonable processing power, it might just be better to
enable SSH and run TypeScript remotely so that it has direct local file
access. VS Code has plenty of [remote
extensions](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All%20categories&sortBy=Relevance)
to make this easier.

You can [read up more on this change on
GitHub](https://github.com/microsoft/TypeScript/pull/50366).

## ‚ÄúRemove Unused Imports‚Äù and ‚ÄúSort Imports‚Äù Commands for Editors

Previously, TypeScript only supported two editor commands to manage imports.
For our examples, take the following code:

    
    
    ts
    
    import { Zebra, Moose, HoneyBadger } from "./zoo";
    
    import { foo, bar } from "./helper";
    
    let x: Moose | HoneyBadger = foo();

The first was called ‚ÄúOrganize Imports‚Äù which would remove unused imports, and
then sort the remaining ones. It would rewrite that file to look like this
one:

    
    
    ts
    
    import { foo } from "./helper";
    
    import { HoneyBadger, Moose } from "./zoo";
    
    let x: Moose | HoneyBadger = foo();

In TypeScript 4.3, we introduced a command called ‚ÄúSort Imports‚Äù which would
_only_ sort imports in the file, but not remove them - and would rewrite the
file like this.

    
    
    ts
    
    import { bar, foo } from "./helper";
    
    import { HoneyBadger, Moose, Zebra } from "./zoo";
    
    let x: Moose | HoneyBadger = foo();

The caveat with ‚ÄúSort Imports‚Äù was that in Visual Studio Code, this feature
was only available as an on-save command - not as a manually triggerable
command.

TypeScript 4.9 adds the other half, and now provides ‚ÄúRemove Unused Imports‚Äù.
TypeScript will now remove unused import names and statements, but will
otherwise leave the relative ordering alone.

    
    
    ts
    
    import { Moose, HoneyBadger } from "./zoo";
    
    import { foo } from "./helper";
    
    let x: Moose | HoneyBadger = foo();

This feature is available to all editors that wish to use either command; but
notably, Visual Studio Code (1.73 and later) will have support built in _and_
will surface these commands via its Command Palette. Users who prefer to use
the more granular ‚ÄúRemove Unused Imports‚Äù or ‚ÄúSort Imports‚Äù commands should be
able to reassign the ‚ÄúOrganize Imports‚Äù key combination to them if desired.

You can [view specifics of the feature
here](https://github.com/microsoft/TypeScript/pull/50931).

## Go-to-Definition on `return` Keywords

In the editor, when running a go-to-definition on the `return` keyword,
TypeScript will now jump you to the top of the corresponding function. This
can be helpful to get a quick sense of which function a `return` belongs to.

We expect TypeScript will expand this functionality to more keywords [such as
`await` and `yield`](https://github.com/microsoft/TypeScript/issues/51223) or
[`switch`, `case`, and
`default`](https://github.com/microsoft/TypeScript/issues/51225).

[This feature was
implemented](https://github.com/microsoft/TypeScript/pull/51227) thanks to
[Oleksandr Tarasiuk](https://github.com/a-tarasyuk).

## Performance Improvements

TypeScript has a few small, but notable, performance improvements.

First, TypeScript‚Äôs `forEachChild` function has been rewritten to use a
function table lookup instead of a `switch` statement across all syntax nodes.
`forEachChild` is a workhorse for traversing syntax nodes in the compiler, and
is used heavily in the binding stage of our compiler, along with parts of the
language service. The refactoring of `forEachChild` yielded up to a 20%
reduction of time spent in our binding phase and across language service
operations.

Once we discovered this performance win for `forEachChild`, we tried it out on
`visitEachChild`, a function we use for transforming nodes in the compiler and
language service. The same refactoring yielded up to a 3% reduction in time
spent in generating project output.

The initial exploration in `forEachChild` was [inspired by a blog
post](https://artemis.sh/2022/08/07/emulating-calculators-fast-in-js.html) by
[Artemis Everfree](https://artemis.sh/). While we have some reason to believe
the root cause of our speed-up might have more to do with function
size/complexity than the issues described in the blog post, we‚Äôre grateful
that we were able to learn from the experience and try out a relatively quick
refactoring that made TypeScript faster.

Finally, the way TypeScript preserves the information about a type in the true
branch of a conditional type has been optimized. In a type like

    
    
    ts
    
    interface Zoo<T extends Animal> {
    
        // ...
    
    }
    
    type MakeZoo<A> = A extends Animal ? Zoo<A> : never;

TypeScript has to ‚Äúremember‚Äù that `A` must also be an `Animal` when checking
if `Zoo<A>` is valid. This is basically done by creating a special type that
used to hold the intersection of `A` with `Animal`; however, TypeScript
previously did this eagerly which isn‚Äôt always necessary. Furthermore, some
faulty code in our type-checker prevented these special types from being
simplified. TypeScript now defers intersecting these types until it‚Äôs
necessary. For codebases with heavy use of conditional types, you might
witness significant speed-ups with TypeScript, but in our performance testing
suite, we saw a more modest 3% reduction in type-checking time.

You can read up more on these optimizations on their respective pull requests:

  * [`forEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50225)
  * [`visitEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50266)
  * [Optimize substitition types](https://github.com/microsoft/TypeScript/pull/50397)

## Correctness Fixes and Breaking Changes

### `lib.d.ts` Updates

While TypeScript strives to avoid major breaks, even small changes in the
built-in libraries can cause issues. We don‚Äôt expect major breaks as a result
of DOM and `lib.d.ts` updates, but there may be some small ones.

### Better Types for `Promise.resolve`

`Promise.resolve` now uses the `Awaited` type to unwrap Promise-like types
passed to it. This means that it more often returns the right `Promise` type,
but that improved type can break existing code if it was expecting `any` or
`unknown` instead of a `Promise`. For more information, [see the original
change](https://github.com/microsoft/TypeScript/pull/33074).

### JavaScript Emit No Longer Elides Imports

When TypeScript first supported type-checking and compilation for JavaScript,
it accidentally supported a feature called import elision. In short, if an
import is not used as a value, or the compiler can detect that the import
doesn‚Äôt refer to a value at runtime, the compiler will drop the import during
emit.

This behavior was questionable, especially the detection of whether the import
doesn‚Äôt refer to a value, since it means that TypeScript has to trust
sometimes-inaccurate declaration files. In turn, TypeScript now preserves
imports in JavaScript files.

    
    
    js
    
    // Input:
    
    import { someValue, SomeClass } from "some-module";
    
    /** @type {SomeClass} */
    
    let val = someValue;
    
    // Previous Output:
    
    import { someValue } from "some-module";
    
    /** @type {SomeClass} */
    
    let val = someValue;
    
    // Current Output:
    
    import { someValue, SomeClass } from "some-module";
    
    /** @type {SomeClass} */
    
    let val = someValue;

More information is available at [the implementing
change](https://github.com/microsoft/TypeScript/pull/50404).

### `exports` is Prioritized Over `typesVersions`

Previously, TypeScript incorrectly prioritized the `typesVersions` field over
the `exports` field when resolving through a `package.json` under
`--moduleResolution node16`. If this change impacts your library, you may need
to add `types@` version selectors in your `package.json`‚Äôs `exports` field.

    
    
    diff
    
      {
    
          "type": "module",
    
          "main": "./dist/main.js"
    
          "typesVersions": {
    
              "<4.8": { ".": ["4.8-types/main.d.ts"] },
    
              "*": { ".": ["modern-types/main.d.ts"] }
    
          },
    
          "exports": {
    
              ".": {
    
    +             "types@<4.8": "4.8-types/main.d.ts",
    
    +             "types": "modern-types/main.d.ts",
    
                  "import": "./dist/main.js"
    
              }
    
          }
    
      }

For more information, [see this pull
request](https://github.com/microsoft/TypeScript/pull/50890).

## `substitute` Replaced With `constraint` on `SubstitutionType`s

As part of an optimization on substitution types, `SubstitutionType` objects
no longer contain the `substitute` property representing the effective
substitution (usually an intersection of the base type and the implicit
constraint) - instead, they just contain the `constraint` property.

For more details, [read more on the original pull
request](https://github.com/microsoft/TypeScript/pull/50397).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
4.9.md) ‚ù§

Contributors to this page:  

N![navya9singh
\(6\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

B![Brennan
\(1\)](https://gravatar.com/avatar/d95a2957c002792f1a7036923a7a29d8?s=32&&d=blank)

M![Marius
\(1\)](https://gravatar.com/avatar/6eeb203f64f5b8d2148cdeceb6a82b37?s=32&&d=blank)

Ï†ú![Ï†úÏä§
\(1\)](https://gravatar.com/avatar/13b93af083039c2a26388f1fcbd4b5bb?s=32&&d=blank)

N![N0N1m3
\(1\)](https://gravatar.com/avatar/bb7254333c8a5329b1784b520f942596?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.0

## Decorators

Decorators are an upcoming ECMAScript feature that allow us to customize
classes and their members in a reusable way.

Let‚Äôs consider the following code:

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }
    
    }
    
    const p = new Person("Ray");
    
    p.greet();

`greet` is pretty simple here, but let‚Äôs imagine it‚Äôs something way more
complicated - maybe it does some async logic, it‚Äôs recursive, it has side
effects, etc. Regardless of what kind of ball-of-mud you‚Äôre imagining, let‚Äôs
say you throw in some `console.log` calls to help debug `greet`.

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        greet() {
    
            console.log("LOG: Entering method.");
    
            console.log(`Hello, my name is ${this.name}.`);
    
            console.log("LOG: Exiting method.")
    
        }
    
    }

This pattern is fairly common. It sure would be nice if there was a way we
could do this for every method!

This is where decorators come in. We can write a function called
`loggedMethod` that looks like the following:

    
    
    ts
    
    function loggedMethod(originalMethod: any, _context: any) {
    
        function replacementMethod(this: any, ...args: any[]) {
    
            console.log("LOG: Entering method.")
    
            const result = originalMethod.call(this, ...args);
    
            console.log("LOG: Exiting method.")
    
            return result;
    
        }
    
        return replacementMethod;
    
    }

‚ÄúWhat‚Äôs the deal with all of these `any`s? What is this, `any`Script!?‚Äù

Just be patient - we‚Äôre keeping things simple for now so that we can focus on
what this function is doing. Notice that `loggedMethod` takes the original
method (`originalMethod`) and returns a function that

  1. logs an ‚ÄúEntering‚Ä¶‚Äù message
  2. passes along `this` and all of its arguments to the original method
  3. logs an ‚ÄúExiting‚Ä¶‚Äù message, and
  4. returns whatever the original method returned.

Now we can use `loggedMethod` to _decorate_ the method `greet`:

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        @loggedMethod
    
        greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }
    
    }
    
    const p = new Person("Ray");
    
    p.greet();
    
    // Output:
    
    //
    
    //   LOG: Entering method.
    
    //   Hello, my name is Ray.
    
    //   LOG: Exiting method.

We just used `loggedMethod` as a decorator above `greet` \- and notice that we
wrote it as `@loggedMethod`. When we did that, it got called with the method
_target_ and a _context object_. Because `loggedMethod` returned a new
function, that function replaced the original definition of `greet`.

We didn‚Äôt mention it yet, but `loggedMethod` was defined with a second
parameter. It‚Äôs called a ‚Äúcontext object‚Äù, and it has some useful information
about how the decorated method was declared - like whether it was a `#private`
member, or `static`, or what the name of the method was. Let‚Äôs rewrite
`loggedMethod` to take advantage of that and print out the name of the method
that was decorated.

    
    
    ts
    
    function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {
    
        const methodName = String(context.name);
    
        function replacementMethod(this: any, ...args: any[]) {
    
            console.log(`LOG: Entering method '${methodName}'.`)
    
            const result = originalMethod.call(this, ...args);
    
            console.log(`LOG: Exiting method '${methodName}'.`)
    
            return result;
    
        }
    
        return replacementMethod;
    
    }

We‚Äôre now using the context parameter - and that it‚Äôs the first thing in
`loggedMethod` that has a type stricter than `any` and `any[]`. TypeScript
provides a type called `ClassMethodDecoratorContext` that models the context
object that method decorators take.

Apart from metadata, the context object for methods also has a useful function
called `addInitializer`. It‚Äôs a way to hook into the beginning of the
constructor (or the initialization of the class itself if we‚Äôre working with
`static`s).

As an example - in JavaScript, it‚Äôs common to write something like the
following pattern:

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
            this.greet = this.greet.bind(this);
    
        }
    
        greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }
    
    }

Alternatively, `greet` might be declared as a property initialized to an arrow
function.

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        greet = () => {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        };
    
    }

This code is written to ensure that `this` isn‚Äôt re-bound if `greet` is called
as a stand-alone function or passed as a callback.

    
    
    ts
    
    const greet = new Person("Ray").greet;
    
    // We don't want this to fail!
    
    greet();

We can write a decorator that uses `addInitializer` to call `bind` in the
constructor for us.

    
    
    ts
    
    function bound(originalMethod: any, context: ClassMethodDecoratorContext) {
    
        const methodName = context.name;
    
        if (context.private) {
    
            throw new Error(`'bound' cannot decorate private properties like ${methodName as string}.`);
    
        }
    
        context.addInitializer(function () {
    
            this[methodName] = this[methodName].bind(this);
    
        });
    
    }

`bound` isn‚Äôt returning anything - so when it decorates a method, it leaves
the original alone. Instead, it will add logic before any other fields are
initialized.

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        @bound
    
        @loggedMethod
    
        greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }
    
    }
    
    const p = new Person("Ray");
    
    const greet = p.greet;
    
    // Works!
    
    greet();

Notice that we stacked two decorators - `@bound` and `@loggedMethod`. These
decorations run in ‚Äúreverse order‚Äù. That is, `@loggedMethod` decorates the
original method `greet`, and `@bound` decorates the result of `@loggedMethod`.
In this example, it doesn‚Äôt matter - but it could if your decorators have
side-effects or expect a certain order.

Also worth noting - if you‚Äôd prefer stylistically, you can put these
decorators on the same line.

    
    
    ts
    
        @bound @loggedMethod greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }

Something that might not be obvious is that we can even make functions that
_return_ decorator functions. That makes it possible to customize the final
decorator just a little. If we wanted, we could have made `loggedMethod`
return a decorator and customize how it logs its messages.

    
    
    ts
    
    function loggedMethod(headMessage = "LOG:") {
    
        return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {
    
            const methodName = String(context.name);
    
            function replacementMethod(this: any, ...args: any[]) {
    
                console.log(`${headMessage} Entering method '${methodName}'.`)
    
                const result = originalMethod.call(this, ...args);
    
                console.log(`${headMessage} Exiting method '${methodName}'.`)
    
                return result;
    
            }
    
            return replacementMethod;
    
        }
    
    }

If we did that, we‚Äôd have to call `loggedMethod` before using it as a
decorator. We could then pass in any string as the prefix for messages that
get logged to the console.

    
    
    ts
    
    class Person {
    
        name: string;
    
        constructor(name: string) {
    
            this.name = name;
    
        }
    
        @loggedMethod("‚ö†Ô∏è")
    
        greet() {
    
            console.log(`Hello, my name is ${this.name}.`);
    
        }
    
    }
    
    const p = new Person("Ray");
    
    p.greet();
    
    // Output:
    
    //
    
    //   ‚ö†Ô∏è Entering method 'greet'.
    
    //   Hello, my name is Ray.
    
    //   ‚ö†Ô∏è Exiting method 'greet'.

Decorators can be used on more than just methods! They can be used on
properties/fields, getters, setters, and auto-accessors. Even classes
themselves can be decorated for things like subclassing and registration.

To learn more about decorators in-depth, you can read up on [Axel
Rauschmayer‚Äôs extensive summary](https://2ality.com/2022/10/javascript-
decorators.html).

For more information about the changes involved, you can [view the original
pull request](https://github.com/microsoft/TypeScript/pull/50820).

### Differences with Experimental Legacy Decorators

If you‚Äôve been using TypeScript for a while, you might be aware of the fact
that it‚Äôs had support for ‚Äúexperimental‚Äù decorators for years. While these
experimental decorators have been incredibly useful, they modeled a much older
version of the decorators proposal, and always required an opt-in compiler
flag called `--experimentalDecorators`. Any attempt to use decorators in
TypeScript without this flag used to prompt an error message.

`--experimentalDecorators` will continue to exist for the foreseeable future;
however, without the flag, decorators will now be valid syntax for all new
code. Outside of `--experimentalDecorators`, they will be type-checked and
emitted differently. The type-checking rules and emit are sufficiently
different that while decorators _can_ be written to support both the old and
new decorators behavior, any existing decorator functions are not likely to do
so.

This new decorators proposal is not compatible with `--emitDecoratorMetadata`,
and it does not allow decorating parameters. Future ECMAScript proposals may
be able to help bridge that gap.

On a final note: in addition to allowing decorators to be placed before the
`export` keyword, the proposal for decorators now provides the option of
placing decorators after `export` or `export default`. The only exception is
that mixing the two styles is not allowed.

    
    
    js
    
    // ‚úÖ allowed
    
    @register export default class Foo {
    
        // ...
    
    }
    
    // ‚úÖ also allowed
    
    export default @register class Bar {
    
        // ...
    
    }
    
    // ‚ùå error - before *and* after is not allowed
    
    @before export @after class Bar {
    
        // ...
    
    }

### Writing Well-Typed Decorators

The `loggedMethod` and `bound` decorator examples above are intentionally
simple and omit lots of details about types.

Typing decorators can be fairly complex. For example, a well-typed version of
`loggedMethod` from above might look something like this:

    
    
    ts
    
    function loggedMethod<This, Args extends any[], Return>(
    
        target: (this: This, ...args: Args) => Return,
    
        context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>
    
    ) {
    
        const methodName = String(context.name);
    
        function replacementMethod(this: This, ...args: Args): Return {
    
            console.log(`LOG: Entering method '${methodName}'.`)
    
            const result = target.call(this, ...args);
    
            console.log(`LOG: Exiting method '${methodName}'.`)
    
            return result;
    
        }
    
        return replacementMethod;
    
    }

We had to separately model out the type of `this`, the parameters, and the
return type of the original method, using the type parameters `This`, `Args`,
and `Return`.

Exactly how complex your decorators functions are defined depends on what you
want to guarantee. Just keep in mind, your decorators will be used more than
they‚Äôre written, so a well-typed version will usually be preferable - but
there‚Äôs clearly a trade-off with readability, so try to keep things simple.

More documentation on writing decorators will be available in the future - but
[this post](https://2ality.com/2022/10/javascript-decorators.html) should have
a good amount of detail for the mechanics of decorators.

## `const` Type Parameters

When inferring the type of an object, TypeScript will usually choose a type
that‚Äôs meant to be general. For example, in this case, the inferred type of
`names` is `string[]`:

    
    
    ts
    
    type HasNames = { names: readonly string[] };
    
    function getNamesExactly<T extends HasNames>(arg: T): T["names"] {
    
        return arg.names;
    
    }
    
    // Inferred type: string[]
    
    const names = getNamesExactly({ names: ["Alice", "Bob", "Eve"]});

Usually the intent of this is to enable mutation down the line.

However, depending on what exactly `getNamesExactly` does and how it‚Äôs
intended to be used, it can often be the case that a more-specific type is
desired.

Up until now, API authors have typically had to recommend adding `as const` in
certain places to achieve the desired inference:

    
    
    ts
    
    // The type we wanted:
    
    //    readonly ["Alice", "Bob", "Eve"]
    
    // The type we got:
    
    //    string[]
    
    const names1 = getNamesExactly({ names: ["Alice", "Bob", "Eve"]});
    
    // Correctly gets what we wanted:
    
    //    readonly ["Alice", "Bob", "Eve"]
    
    const names2 = getNamesExactly({ names: ["Alice", "Bob", "Eve"]} as const);

This can be cumbersome and easy to forget. In TypeScript 5.0, you can now add
a `const` modifier to a type parameter declaration to cause `const`-like
inference to be the default:

    
    
    ts
    
    type HasNames = { names: readonly string[] };
    
    function getNamesExactly<const T extends HasNames>(arg: T): T["names"] {
    
    //                       ^^^^^
    
        return arg.names;
    
    }
    
    // Inferred type: readonly ["Alice", "Bob", "Eve"]
    
    // Note: Didn't need to write 'as const' here
    
    const names = getNamesExactly({ names: ["Alice", "Bob", "Eve"] });

Note that the `const` modifier doesn‚Äôt _reject_ mutable values, and doesn‚Äôt
require immutable constraints. Using a mutable type constraint might give
surprising results. For example:

    
    
    ts
    
    declare function fnBad<const T extends string[]>(args: T): void;
    
    // 'T' is still 'string[]' since 'readonly ["a", "b", "c"]' is not assignable to 'string[]'
    
    fnBad(["a", "b" ,"c"]);

Here, the inferred candidate for `T` is `readonly ["a", "b", "c"]`, and a
`readonly` array can‚Äôt be used where a mutable one is needed. In this case,
inference falls back to the constraint, the array is treated as `string[]`,
and the call still proceeds successfully.

A better definition of this function should use `readonly string[]`:

    
    
    ts
    
    declare function fnGood<const T extends readonly string[]>(args: T): void;
    
    // T is readonly ["a", "b", "c"]
    
    fnGood(["a", "b" ,"c"]);

Similarly, remember to keep in mind that the `const` modifier only affects
inference of object, array and primitive expressions that were written within
the call, so arguments which wouldn‚Äôt (or couldn‚Äôt) be modified with `as
const` won‚Äôt see any change in behavior:

    
    
    ts
    
    declare function fnGood<const T extends readonly string[]>(args: T): void;
    
    const arr = ["a", "b" ,"c"];
    
    // 'T' is still 'string[]'-- the 'const' modifier has no effect here
    
    fnGood(arr);

[See the pull request](https://github.com/microsoft/TypeScript/pull/51865) and
the ([first](https://github.com/microsoft/TypeScript/issues/30680) and second
[second](https://github.com/microsoft/TypeScript/issues/41114)) motivating
issues for more details.

## Supporting Multiple Configuration Files in `extends`

When managing multiple projects, it can be helpful to have a ‚Äúbase‚Äù
configuration file that other `tsconfig.json` files can extend from. That‚Äôs
why TypeScript supports an `extends` field for copying over fields from
`compilerOptions`.

    
    
    jsonc
    
    // packages/front-end/src/tsconfig.json
    
    {
    
        "extends": "../../../tsconfig.base.json",
    
        "compilerOptions": {
    
            "outDir": "../lib",
    
            // ...
    
        }
    
    }

However, there are scenarios where you might want to extend from multiple
configuration files. For example, imagine using [a TypeScript base
configuration file shipped to npm](https://github.com/tsconfig/bases). If you
want all your projects to also use the options from the `@tsconfig/strictest`
package on npm, then there‚Äôs a simple solution: have `tsconfig.base.json`
extend from `@tsconfig/strictest`:

    
    
    jsonc
    
    // tsconfig.base.json
    
    {
    
        "extends": "@tsconfig/strictest/tsconfig.json",
    
        "compilerOptions": {
    
            // ...
    
        }
    
    }

This works to a point. If you have any projects that _don‚Äôt_ want to use
`@tsconfig/strictest`, they have to either manually disable the options, or
create a separate version of `tsconfig.base.json` that _doesn‚Äôt_ extend from
`@tsconfig/strictest`.

To give some more flexibility here, Typescript 5.0 now allows the `extends`
field to take multiple entries. For example, in this configuration file:

    
    
    jsonc
    
    {
    
        "extends": ["a", "b", "c"],
    
        "compilerOptions": {
    
            // ...
    
        }
    
    }

Writing this is kind of like extending `c` directly, where `c` extends `b`,
and `b` extends `a`. If any fields ‚Äúconflict‚Äù, the latter entry wins.

So in the following example, both `strictNullChecks` and `noImplicitAny` are
enabled in the final `tsconfig.json`.

    
    
    jsonc
    
    // tsconfig1.json
    
    {
    
        "compilerOptions": {
    
            "strictNullChecks": true
    
        }
    
    }
    
    // tsconfig2.json
    
    {
    
        "compilerOptions": {
    
            "noImplicitAny": true
    
        }
    
    }
    
    // tsconfig.json
    
    {
    
        "extends": ["./tsconfig1.json", "./tsconfig2.json"],
    
        "files": ["./index.ts"]
    
    }

As another example, we can rewrite our original example in the following way.

    
    
    jsonc
    
    // packages/front-end/src/tsconfig.json
    
    {
    
        "extends": ["@tsconfig/strictest/tsconfig.json", "../../../tsconfig.base.json"],
    
        "compilerOptions": {
    
            "outDir": "../lib",
    
            // ...
    
        }
    
    }

For more details, [read more on the original pull
request](https://github.com/microsoft/TypeScript/pull/50403).

## All `enum`s Are Union `enum`s

When TypeScript originally introduced enums, they were nothing more than a set
of numeric constants with the same type.

    
    
    ts
    
    enum E {
    
        Foo = 10,
    
        Bar = 20,
    
    }

The only thing special about `E.Foo` and `E.Bar` was that they were assignable
to anything expecting the type `E`. Other than that, they were pretty much
just `number`s.

    
    
    ts
    
    function takeValue(e: E) {}
    
    takeValue(E.Foo); // works
    
    takeValue(123); // error!

It wasn‚Äôt until TypeScript 2.0 introduced enum literal types that enums got a
bit more special. Enum literal types gave each enum member its own type, and
turned the enum itself into a _union_ of each member type. They also allowed
us to refer to only a subset of the types of an enum, and to narrow away those
types.

    
    
    ts
    
    // Color is like a union of Red | Orange | Yellow | Green | Blue | Violet
    
    enum Color {
    
        Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet
    
    }
    
    // Each enum member has its own type that we can refer to!
    
    type PrimaryColor = Color.Red | Color.Green | Color.Blue;
    
    function isPrimaryColor(c: Color): c is PrimaryColor {
    
        // Narrowing literal types can catch bugs.
    
        // TypeScript will error here because
    
        // we'll end up comparing 'Color.Red' to 'Color.Green'.
    
        // We meant to use ||, but accidentally wrote &&.
    
        return c === Color.Red && c === Color.Green && c === Color.Blue;
    
    }

One issue with giving each enum member its own type was that those types were
in some part associated with the actual value of the member. In some cases
it‚Äôs not possible to compute that value - for instance, an enum member could
be initialized by a function call.

    
    
    ts
    
    enum E {
    
        Blah = Math.random()
    
    }

Whenever TypeScript ran into these issues, it would quietly back out and use
the old enum strategy. That meant giving up all the advantages of unions and
literal types.

TypeScript 5.0 manages to make all enums into union enums by creating a unique
type for each computed member. That means that all enums can now be narrowed
and have their members referenced as types as well.

For more details on this change, you can [read the specifics on
GitHub](https://github.com/microsoft/TypeScript/pull/50528).

## `--moduleResolution bundler`

TypeScript 4.7 introduced the `node16` and `nodenext` options for its
`--module` and `--moduleResolution` settings. The intent of these options was
to better model the precise lookup rules for ECMAScript modules in Node.js;
however, this mode has many restrictions that other tools don‚Äôt really
enforce.

For example, in an ECMAScript module in Node.js, any relative import needs to
include a file extension.

    
    
    js
    
    // entry.mjs
    
    import * as utils from "./utils";     // ‚ùå wrong - we need to include the file extension.
    
    import * as utils from "./utils.mjs"; // ‚úÖ works

There are certain reasons for this in Node.js and the browser - it makes file
lookups faster and works better for naive file servers. But for many
developers using tools like bundlers, the `node16`/`nodenext` settings were
cumbersome because bundlers don‚Äôt have most of these restrictions. In some
ways, the `node` resolution mode was better for anyone using a bundler.

But in some ways, the original `node` resolution mode was already out of date.
Most modern bundlers use a fusion of the ECMAScript module and CommonJS lookup
rules in Node.js. For example, extensionless imports work just fine just like
in CommonJS, but when looking through the [`export`
conditions](https://nodejs.org/api/packages.html#nested-conditions) of a
package, they‚Äôll prefer an `import` condition just like in an ECMAScript file.

To model how bundlers work, TypeScript now introduces a new strategy:
`--moduleResolution bundler`.

    
    
    jsonc
    
    {
    
        "compilerOptions": {
    
            "target": "esnext",
    
            "moduleResolution": "bundler"
    
        }
    
    }

If you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel,
and others that implement a hybrid lookup strategy, the new `bundler` option
should be a good fit for you.

On the other hand, if you‚Äôre writing a library that‚Äôs meant to be published on
npm, using the `bundler` option can hide compatibility issues that may arise
for your users who _aren‚Äôt_ using a bundler. So in these cases, using the
`node16` or `nodenext` resolution options is likely to be a better path.

To read more on `--moduleResolution bundler`, [take a look at the implementing
pull request](https://github.com/microsoft/TypeScript/pull/51669).

## Resolution Customization Flags

JavaScript tooling may now model ‚Äúhybrid‚Äù resolution rules, like in the
`bundler` mode we described above. Because tools may differ in their support
slightly, TypeScript 5.0 provides ways to enable or disable a few features
that may or may not work with your configuration.

### `allowImportingTsExtensions`

`--allowImportingTsExtensions` allows TypeScript files to import each other
with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.

This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is
enabled, since these import paths would not be resolvable at runtime in
JavaScript output files. The expectation here is that your resolver (e.g. your
bundler, a runtime, or some other tool) is going to make these imports between
`.ts` files work.

### `resolvePackageJsonExports`

`--resolvePackageJsonExports` forces TypeScript to consult [the `exports`
field of `package.json` files](https://nodejs.org/api/packages.html#exports)
if it ever reads from a package in `node_modules`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

### `resolvePackageJsonImports`

`--resolvePackageJsonImports` forces TypeScript to consult [the `imports`
field of `package.json` files](https://nodejs.org/api/packages.html#imports)
when performing a lookup that starts with `#` from a file whose ancestor
directory contains a `package.json`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

### `allowArbitraryExtensions`

In TypeScript 5.0, when an import path ends in an extension that isn‚Äôt a known
JavaScript or TypeScript file extension, the compiler will look for a
declaration file for that path in the form of `{file
basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a
bundler project, you might want to write (or generate) declaration files for
those stylesheets:

    
    
    css
    
    /* app.css */
    
    .cookie-banner {
    
      display: none;
    
    }
    
    
    ts
    
    // app.d.css.ts
    
    declare const css: {
    
      cookieBanner: string;
    
    };
    
    export default css;
    
    
    ts
    
    // App.tsx
    
    import styles from "./app.css";
    
    styles.cookieBanner; // string

By default, this import will raise an error to let you know that TypeScript
doesn‚Äôt understand this file type and your runtime might not support importing
it. But if you‚Äôve configured your runtime or bundler to handle it, you can
suppress the error with the new `--allowArbitraryExtensions` compiler option.

Note that historically, a similar effect has often been achievable by adding a
declaration file named `app.css.d.ts` instead of `app.d.css.ts` \- however,
this just worked through Node‚Äôs `require` resolution rules for CommonJS.
Strictly speaking, the former is interpreted as a declaration file for a
JavaScript file named `app.css.js`. Because relative files imports need to
include extensions in Node‚Äôs ESM support, TypeScript would error on our
example in an ESM file under `--moduleResolution node16` or `nodenext`.

For more information, read up [the proposalfor this
feature](https://github.com/microsoft/TypeScript/issues/50133) and [its
corresponding pull
request](https://github.com/microsoft/TypeScript/pull/51435).

### `customConditions`

`--customConditions` takes a list of additional
[conditions](https://nodejs.org/api/packages.html#nested-conditions) that
should succeed when TypeScript resolves from an
[`exports`](https://nodejs.org/api/packages.html#exports) or
[`imports`](https://nodejs.org/api/packages.html#imports) field of a
`package.json`. These conditions are added to whatever existing conditions a
resolver will use by default.

For example, when this field is set in a `tsconfig.json` as so:

    
    
    jsonc
    
    {
    
        "compilerOptions": {
    
            "target": "es2022",
    
            "moduleResolution": "bundler",
    
            "customConditions": ["my-condition"]
    
        }
    
    }

Any time an `exports` or `imports` field is referenced in `package.json`,
TypeScript will consider conditions called `my-condition`.

So when importing from a package with the following `package.json`

    
    
    jsonc
    
    {
    
        // ...
    
        "exports": {
    
            ".": {
    
                "my-condition": "./foo.mjs",
    
                "node": "./bar.mjs",
    
                "import": "./baz.mjs",
    
                "require": "./biz.mjs"
    
            }
    
        }
    
    }

TypeScript will try to look for files corresponding to `foo.mjs`.

This field is only valid under the `node16`, `nodenext`, and `bundler` options
for `--moduleResolution`

## `--verbatimModuleSyntax`

By default, TypeScript does something called _import elision_. Basically, if
you write something like

    
    
    ts
    
    import { Car } from "./car";
    
    export function drive(car: Car) {
    
        // ...
    
    }

TypeScript detects that you‚Äôre only using an import for types and drops the
import entirely. Your output JavaScript might look something like this:

    
    
    js
    
    export function drive(car) {
    
        // ...
    
    }

Most of the time this is good, because if `Car` isn‚Äôt a value that‚Äôs exported
from `./car`, we‚Äôll get a runtime error.

But it does add a layer of complexity for certain edge cases. For example,
notice there‚Äôs no statement like `import "./car";` \- the import was dropped
entirely. That actually makes a difference for modules that have side-effects
or not.

TypeScript‚Äôs emit strategy for JavaScript also has another few layers of
complexity - import elision isn‚Äôt always just driven by how an import is used
- it often consults how a value is declared as well. So it‚Äôs not always clear
whether code like the following

    
    
    ts
    
    export { Car } from "./car";

should be preserved or dropped. If `Car` is declared with something like a
`class`, then it can be preserved in the resulting JavaScript file. But if
`Car` is only declared as a `type` alias or `interface`, then the JavaScript
file shouldn‚Äôt export `Car` at all.

While TypeScript might be able to make these emit decisions based on
information from across files, not every compiler can.

The `type` modifier on imports and exports helps with these situations a bit.
We can make it explicit whether an import or export is only being used for
type analysis, and can be dropped entirely in JavaScript files by using the
`type` modifier.

    
    
    ts
    
    // This statement can be dropped entirely in JS output
    
    import type * as car from "./car";
    
    // The named import/export 'Car' can be dropped in JS output
    
    import { type Car } from "./car";
    
    export { type Car } from "./car";

`type` modifiers are not quite useful on their own - by default, module
elision will still drop imports, and nothing forces you to make the
distinction between `type` and plain imports and exports. So TypeScript has
the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier,
`--preserveValueImports` to prevent _some_ module elision behavior, and
`--isolatedModules` to make sure that your TypeScript code works across
different compilers. Unfortunately, understanding the fine details of those 3
flags is hard, and there are still some edge cases with unexpected behavior.

TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to
simplify the situation. The rules are much simpler - any imports or exports
without a `type` modifier are left around. Anything that uses the `type`
modifier is dropped entirely.

    
    
    ts
    
    // Erased away entirely.
    
    import type { A } from "a";
    
    // Rewritten to 'import { b } from "bcd";'
    
    import { b, type c, type d } from "bcd";
    
    // Rewritten to 'import {} from "xyz";'
    
    import { type xyz } from "xyz";

With this new option, what you see is what you get.

That does have some implications when it comes to module interop though. Under
this flag, ECMAScript `import`s and `export`s won‚Äôt be rewritten to `require`
calls when your settings or file extension implied a different module system.
Instead, you‚Äôll get an error. If you need to emit code that uses `require` and
`module.exports`, you‚Äôll have to use TypeScript‚Äôs module syntax that predates
ES2015:

Input TypeScript | Output JavaScript  
---|---  
      
    
    tsimport foo = require("foo");

|

    
    
    jsconst foo = require("foo");  
      
    
    tsfunction foo() {}function bar() {}function baz() {}export = {    foo,    bar,    baz};

|

    
    
    jsfunction foo() {}function bar() {}function baz() {}module.exports = {    foo,    bar,    baz};  
  
While this is a limitation, it does help make some issues more obvious. For
example, it‚Äôs very common to forget to set the [`type` field in
`package.json`](https://nodejs.org/api/packages.html#type) under `--module
node16`. As a result, developers would start writing CommonJS modules instead
of an ES modules without realizing it, giving surprising lookup rules and
JavaScript output. This new flag ensures that you‚Äôre intentional about the
file type you‚Äôre using because the syntax is intentionally different.

Because `--verbatimModuleSyntax` provides a more consistent story than
`--importsNotUsedAsValues` and `--preserveValueImports`, those two existing
flags are being deprecated in its favor.

For more details, read up on [the original pull
request]<https://github.com/microsoft/TypeScript/pull/52203> and [its proposal
issue](https://github.com/microsoft/TypeScript/issues/51479).

## Support for `export type *`

When TypeScript 3.8 introduced type-only imports, the new syntax wasn‚Äôt
allowed on `export * from "module"` or `export * as ns from "module"` re-
exports. TypeScript 5.0 adds support for both of these forms:

    
    
    ts
    
    // models/vehicles.ts
    
    export class Spaceship {
    
      // ...
    
    }
    
    // models/index.ts
    
    export type * as vehicles from "./vehicles";
    
    // main.ts
    
    import { vehicles } from "./models";
    
    function takeASpaceship(s: vehicles.Spaceship) {
    
      // ‚úÖ ok - `vehicles` only used in a type position
    
    }
    
    function makeASpaceship() {
    
      return new vehicles.Spaceship();
    
      //         ^^^^^^^^
    
      // 'vehicles' cannot be used as a value because it was exported using 'export type'.
    
    }

You can [read more about the implementation
here](https://github.com/microsoft/TypeScript/pull/52217).

## `@satisfies` Support in JSDoc

TypeScript 4.9 introduced the `satisfies` operator. It made sure that the type
of an expression was compatible, without affecting the type itself. For
example, let‚Äôs take the following code:

    
    
    ts
    
    interface CompilerOptions {
    
        strict?: boolean;
    
        outDir?: string;
    
        // ...
    
    }
    
    interface ConfigSettings {
    
        compilerOptions?: CompilerOptions;
    
        extends?: string | string[];
    
        // ...
    
    }
    
    let myConfigSettings = {
    
        compilerOptions: {
    
            strict: true,
    
            outDir: "../lib",
    
            // ...
    
        },
    
        extends: [
    
            "@tsconfig/strictest/tsconfig.json",
    
            "../../../tsconfig.base.json"
    
        ],
    
    } satisfies ConfigSettings;

Here, TypeScript knows that `myConfigSettings.extends` was declared with an
array - because while `satisfies` validated the type of our object, it didn‚Äôt
bluntly change it to `CompilerOptions` and lose information. So if we want to
map over `extends`, that‚Äôs fine.

    
    
    ts
    
    declare function resolveConfig(configPath: string): CompilerOptions;
    
    let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);

This was helpful for TypeScript users, but plenty of people use TypeScript to
type-check their JavaScript code using JSDoc annotations. That‚Äôs why
TypeScript 5.0 is supporting a new JSDoc tag called `@satisfies` that does
exactly the same thing.

`/** @satisfies */` can catch type mismatches:

    
    
    js
    
    // @ts-check
    
    /**
    
     * @typedef CompilerOptions
    
     * @prop {boolean} [strict]
    
     * @prop {string} [outDir]
    
     */
    
    /**
    
     * @satisfies {CompilerOptions}
    
     */
    
    let myCompilerOptions = {
    
        outdir: "../lib",
    
    //  ~~~~~~ oops! we meant outDir
    
    };

But it will preserve the original type of our expressions, allowing us to use
our values more precisely later on in our code.

    
    
    js
    
    // @ts-check
    
    /**
    
     * @typedef CompilerOptions
    
     * @prop {boolean} [strict]
    
     * @prop {string} [outDir]
    
     */
    
    /**
    
     * @typedef ConfigSettings
    
     * @prop {CompilerOptions} [compilerOptions]
    
     * @prop {string | string[]} [extends]
    
     */
    
    /**
    
     * @satisfies {ConfigSettings}
    
     */
    
    let myConfigSettings = {
    
        compilerOptions: {
    
            strict: true,
    
            outDir: "../lib",
    
        },
    
        extends: [
    
            "@tsconfig/strictest/tsconfig.json",
    
            "../../../tsconfig.base.json"
    
        ],
    
    };
    
    let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);

`/** @satisfies */` can also be used inline on any parenthesized expression.
We could have written `myCompilerOptions` like this:

    
    
    ts
    
    let myConfigSettings = /** @satisfies {ConfigSettings} */ ({
    
        compilerOptions: {
    
            strict: true,
    
            outDir: "../lib",
    
        },
    
        extends: [
    
            "@tsconfig/strictest/tsconfig.json",
    
            "../../../tsconfig.base.json"
    
        ],
    
    });

Why? Well, it usually makes more sense when you‚Äôre deeper in some other code,
like a function call.

    
    
    js
    
    compileCode(/** @satisfies {CompilerOptions} */ ({
    
        // ...
    
    }));

[This feature](https://github.com/microsoft/TypeScript/pull/51753) was
provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)!

## `@overload` Support in JSDoc

In TypeScript, you can specify overloads for a function. Overloads give us a
way to say that a function can be called with different arguments, and
possibly return different results. They can restrict how callers can actually
use our functions, and refine what results they‚Äôll get back.

    
    
    ts
    
    // Our overloads:
    
    function printValue(str: string): void;
    
    function printValue(num: number, maxFractionDigits?: number): void;
    
    // Our implementation:
    
    function printValue(value: string | number, maximumFractionDigits?: number) {
    
        if (typeof value === "number") {
    
            const formatter = Intl.NumberFormat("en-US", {
    
                maximumFractionDigits,
    
            });
    
            value = formatter.format(value);
    
        }
    
        console.log(value);
    
    }

Here, we‚Äôve said that `printValue` takes either a `string` or a `number` as
its first argument. If it takes a `number`, it can take a second argument to
determine how many fractional digits we can print.

TypeScript 5.0 now allows JSDoc to declare overloads with a new `@overload`
tag. Each JSDoc comment with an `@overload` tag is treated as a distinct
overload for the following function declaration.

    
    
    js
    
    // @ts-check
    
    /**
    
     * @overload
    
     * @param {string} value
    
     * @return {void}
    
     */
    
    /**
    
     * @overload
    
     * @param {number} value
    
     * @param {number} [maximumFractionDigits]
    
     * @return {void}
    
     */
    
    /**
    
     * @param {string | number} value
    
     * @param {number} [maximumFractionDigits]
    
     */
    
    function printValue(value, maximumFractionDigits) {
    
        if (typeof value === "number") {
    
            const formatter = Intl.NumberFormat("en-US", {
    
                maximumFractionDigits,
    
            });
    
            value = formatter.format(value);
    
        }
    
        console.log(value);
    
    }

Now regardless of whether we‚Äôre writing in a TypeScript or JavaScript file,
TypeScript can let us know if we‚Äôve called our functions incorrectly.

    
    
    ts
    
    // all allowed
    
    printValue("hello!");
    
    printValue(123.45);
    
    printValue(123.45, 2);
    
    printValue("hello!", 123); // error!

This new tag [was
implemented](https://github.com/microsoft/TypeScript/pull/51234) thanks to
[Tomasz Lenarcik](https://github.com/apendua).

## Passing Emit-Specific Flags Under `--build`

TypeScript now allows the following flags to be passed under `--build` mode

  * `--declaration`
  * `--emitDeclarationOnly`
  * `--declarationMap`
  * `--sourceMap`
  * `--inlineSourceMap`

This makes it way easier to customize certain parts of a build where you might
have different development and production builds.

For example, a development build of a library might not need to produce
declaration files, but a production build would. A project can configure
declaration emit to be off by default and simply be built with

    
    
    sh
    
    tsc --build -p ./my-project-dir

Once you‚Äôre done iterating in the inner loop, a ‚Äúproduction‚Äù build can just
pass the `--declaration` flag.

    
    
    sh
    
    tsc --build -p ./my-project-dir --declaration

[More information on this change is available
here](https://github.com/microsoft/TypeScript/pull/51241).

## Case-Insensitive Import Sorting in Editors

In editors like Visual Studio and VS Code, TypeScript powers the experience
for organizing and sorting imports and exports. Often though, there can be
different interpretations of when a list is ‚Äúsorted‚Äù.

For example, is the following import list sorted?

    
    
    ts
    
    import {
    
        Toggle,
    
        freeze,
    
        toBoolean,
    
    } from "./utils";

The answer might surprisingly be ‚Äúit depends‚Äù. If we _don‚Äôt_ care about case-
sensitivity, then this list is clearly not sorted. The letter `f` comes before
both `t` and `T`.

But in most programming languages, sorting defaults to comparing the byte
values of strings. The way JavaScript compares strings means that `"Toggle"`
always comes before `"freeze"` because according to the [ASCII character
encoding](https://en.wikipedia.org/wiki/ASCII), uppercase letters come before
lowercase. So from that perspective, the import list is sorted.

TypeScript previously considered the import list to be sorted because it was
doing a basic case-sensitive sort. This could be a point of frustration for
developers who preferred a case-_insensitive_ ordering, or who used tools like
ESLint which require to case-insensitive ordering by default.

TypeScript now detects case sensitivity by default. This means that TypeScript
and tools like ESLint typically won‚Äôt ‚Äúfight‚Äù each other over how to best sort
imports.

Our team has also been experimenting [with further sorting strategies which
you can read about here](https://github.com/microsoft/TypeScript/pull/52115).
These options may eventually be configurable by editors. For now, they are
still unstable and experimental, and you can opt into them in VS Code today by
using the `typescript.unstable` entry in your JSON options. Below are all of
the options you can try out (set to their defaults):

    
    
    jsonc
    
    {
    
        "typescript.unstable": {
    
            // Should sorting be case-sensitive? Can be:
    
            // - true
    
            // - false
    
            // - "auto" (auto-detect)
    
            "organizeImportsIgnoreCase": "auto",
    
            // Should sorting be "ordinal" and use code points or consider Unicode rules? Can be:
    
            // - "ordinal"
    
            // - "unicode"
    
            "organizeImportsCollation": "ordinal",
    
            // Under `"organizeImportsCollation": "unicode"`,
    
            // what is the current locale? Can be:
    
            // - [any other locale code]
    
            // - "auto" (use the editor's locale)
    
            "organizeImportsLocale": "en",
    
            // Under `"organizeImportsCollation": "unicode"`,
    
            // should upper-case letters or lower-case letters come first? Can be:
    
            // - false (locale-specific)
    
            // - "upper"
    
            // - "lower"
    
            "organizeImportsCaseFirst": false,
    
            // Under `"organizeImportsCollation": "unicode"`,
    
            // do runs of numbers get compared numerically (i.e. "a1" < "a2" < "a100")? Can be:
    
            // - true
    
            // - false
    
            "organizeImportsNumericCollation": true,
    
            // Under `"organizeImportsCollation": "unicode"`,
    
            // do letters with accent marks/diacritics get sorted distinctly
    
            // from their "base" letter (i.e. is √© different from e)? Can be
    
            // - true
    
            // - false
    
            "organizeImportsAccentCollation": true
    
        },
    
        "javascript.unstable": {
    
            // same options valid here...
    
        },
    
    }

You can read more details on [the original work for auto-detecting and
specifying case-
insensitivity](https://github.com/microsoft/TypeScript/pull/51733), followed
by the [the broader set of
options](https://github.com/microsoft/TypeScript/pull/52115).

## Exhaustive `switch`/`case` Completions

When writing a `switch` statement, TypeScript now detects when the value being
checked has a literal type. If so, it will offer a completion that scaffolds
out each uncovered `case`.

![A set of case statements generated through auto-completion based on literal
types.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/01/switchCaseSnippets-5-0_1.gif)

You can [see specifics of the implementation on
GitHub](https://github.com/microsoft/TypeScript/pull/50996).

## Speed, Memory, and Package Size Optimizations

TypeScript 5.0 contains lots of powerful changes across our code structure,
our data structures, and algorithmic implementations. What these all mean is
that your entire experience should be faster - not just running TypeScript,
but even installing it.

Here are a few interesting wins in speed and size that we‚Äôve been able to
capture relative to TypeScript 4.9.

Scenario | Time or Size Relative to TS 4.9  
---|---  
material-ui build time | 89%  
TypeScript Compiler startup time | 89%  
Playwright build time | 88%  
TypeScript Compiler self-build time | 87%  
Outlook Web build time | 82%  
VS Code build time | 80%  
typescript npm Package Size | 59%  
  
![Chart of build/run times and package size of TypeScript 5.0 relative to
TypeScript 4.9: material-ui docs build time: 89%; Playwright build time: 88%;
tsc startup time: 87%; tsc build time: 87%; Outlook Web build time: 82%; VS
Code build time: 80%; typescript Package Size:
59%](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/03/speed-and-size-5-0-rc.png?1)

How? There are a few notable improvements we‚Äôd like give more details on in
the future. But we won‚Äôt make you wait for that blog post.

First off, we recently migrated TypeScript from namespaces to modules,
allowing us to leverage modern build tooling that can perform optimizations
like scope hoisting. Using this tooling, revisiting our packaging strategy,
and removing some deprecated code has shaved off about 26.4 MB from TypeScript
4.9‚Äôs 63.8 MB package size. It also brought us a notable speed-up through
direct function calls.

TypeScript also added more uniformity to internal object types within the
compiler, and also slimmed the data stored on some of these object types as
well. This reduced polymorphic and megamorphic use sites, while offsetting
most of the necessary memory consumption that was necessary for uniform
shapes.

We‚Äôve also performed some caching when serializing information to strings.
Type display, which can happen as part of error reporting, declaration emit,
code completions, and more, can end up being fairly expensive. TypeScript now
caches some commonly used machinery to reuse across these operations.

Another notable change we made that improved our parser was leveraging `var`
to occasionally side-step the cost of using `let` and `const` across closures.
This improved some of our parsing performance.

Overall, we expect most codebases should see speed improvements from
TypeScript 5.0, and have consistently been able to reproduce wins between 10%
to 20%. Of course this will depend on hardware and codebase characteristics,
but we encourage you to try it out on your codebase today!

For more information, see some of our notable optimizations:

  * [Migrate to Modules](https://github.com/microsoft/TypeScript/pull/51387)
  * [`Node` Monomorphization](https://github.com/microsoft/TypeScript/pull/51682)
  * [`Symbol` Monomorphization](https://github.com/microsoft/TypeScript/pull/51880)
  * [`Identifier` Size Reduction](https://github.com/microsoft/TypeScript/pull/52170)
  * [`Printer` Caching](https://github.com/microsoft/TypeScript/pull/52382)
  * [Limited Usage of `var`](https://github.com/microsoft/TypeScript/issues/52924)

## Breaking Changes and Deprecations

### Runtime Requirements

TypeScript now targets ECMAScript 2018. For Node users, that means a minimum
version requirement of at least Node.js 10 and later.

### `lib.d.ts` Changes

Changes to how types for the DOM are generated might have an impact on
existing code. Notably, certain properties have been converted from `number`
to numeric literal types, and properties and methods for cut, copy, and paste
event handling have been moved across interfaces.

### API Breaking Changes

In TypeScript 5.0, we moved to modules, removed some unnecessary interfaces,
and made some correctness improvements. For more details on what‚Äôs changed,
see our [API Breaking
Changes](https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes)
page.

### Forbidden Implicit Coercions in Relational Operators

Certain operations in TypeScript will already warn you if you write code which
may cause an implicit string-to-number coercion:

    
    
    ts
    
    function func(ns: number | string) {
    
      return ns * 4; // Error, possible implicit coercion
    
    }

In 5.0, this will also be applied to the relational operators `>`, `<`, `<=`,
and `>=`:

    
    
    ts
    
    function func(ns: number | string) {
    
      return ns > 4; // Now also an error
    
    }

To allow this if desired, you can explicitly coerce the operand to a `number`
using `+`:

    
    
    ts
    
    function func(ns: number | string) {
    
      return +ns > 4; // OK
    
    }

This [correctness
improvement](https://github.com/microsoft/TypeScript/pull/52048) was
contributed courtesy of [Mateusz Burzy≈Ñski](https://github.com/Andarist).

### Enum Overhaul

TypeScript has had some long-standing oddities around `enum`s ever since its
first release. In 5.0, we‚Äôre cleaning up some of these problems, as well as
reducing the concept count needed to understand the various kinds of `enum`s
you can declare.

There are two main new errors you might see as part of this. The first is that
assigning an out-of-domain literal to an `enum` type will now error as one
might expect:

    
    
    ts
    
    enum SomeEvenDigit {
    
        Zero = 0,
    
        Two = 2,
    
        Four = 4
    
    }
    
    // Now correctly an error
    
    let m: SomeEvenDigit = 1;

The other is that declaration of certain kinds of indirected mixed
string/number `enum` forms would, incorrectly, create an all-number `enum`:

    
    
    ts
    
    enum Letters {
    
        A = "a"
    
    }
    
    enum Numbers {
    
        one = 1,
    
        two = Letters.A
    
    }
    
    // Now correctly an error
    
    const t: number = Numbers.two;

You can [see more details in relevant
change](https://github.com/microsoft/TypeScript/pull/50528).

### More Accurate Type-Checking for Parameter Decorators in Constructors Under
`--experimentalDecorators`

TypeScript 5.0 makes type-checking more accurate for decorators under
`--experimentalDecorators`. One place where this becomes apparent is when
using a decorator on a constructor parameter.

    
    
    ts
    
    export declare const inject:
    
      (entity: any) =>
    
        (target: object, key: string | symbol, index?: number) => void;
    
    export class Foo {}
    
    export class C {
    
        constructor(@inject(Foo) private x: any) {
    
        }
    
    }

This call will fail because `key` expects a `string | symbol`, but constructor parameters receive a key of `undefined`. The correct fix is to change the type of `key` within `inject`. A reasonable workaround if you‚Äôre using a library that can‚Äôt be upgraded is is to wrap `inject` in a more type-safe decorator function, and use a type-assertion on `key`.

For more details, [see this
issue](https://github.com/microsoft/TypeScript/issues/52435).

### Deprecations and Default Changes

In TypeScript 5.0, we‚Äôve deprecated the following settings and setting values:

  * `--target: ES3`
  * `--out`
  * `--noImplicitUseStrict`
  * `--keyofStringsOnly`
  * `--suppressExcessPropertyErrors`
  * `--suppressImplicitAnyIndexErrors`
  * `--noStrictGenericChecks`
  * `--charset`
  * `--importsNotUsedAsValues`
  * `--preserveValueImports`
  * `prepend` in project references

These configurations will continue to be allowed until TypeScript 5.5, at
which point they will be removed entirely, however, you will receive a warning
if you are using these settings. In TypeScript 5.0, as well as future releases
5.1, 5.2, 5.3, and 5.4, you can specify `"ignoreDeprecations": "5.0"` to
silence those warnings. We‚Äôll also shortly be releasing a 4.9 patch to allow
specifying `ignoreDeprecations` to allow for smoother upgrades. Aside from
deprecations, we‚Äôve changed some settings to better improve cross-platform
behavior in TypeScript.

`--newLine`, which controls the line endings emitted in JavaScript files, used
to be inferred based on the current operating system if not specified. We
think builds should be as deterministic as possible, and Windows Notepad
supports line-feed line endings now, so the new default setting is `LF`. The
old OS-specific inference behavior is no longer available.

`--forceConsistentCasingInFileNames`, which ensured that all references to the
same file name in a project agreed in casing, now defaults to `true`. This can
help catch differences issues with code written on case-insensitive file
systems.

You can leave feedback and view more information on the [tracking issue for
5.0 deprecations](https://github.com/microsoft/TypeScript/issues/51909)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.0.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(7\)](https://gravatar.com/avatar/71d2fed56905b0ea9daf87357af10333?s=32&&d=blank)

M![marcustyphoon
\(1\)](https://gravatar.com/avatar/4408b8544eb37a98e8d7f62023e61ddb?s=32&&d=blank)

M![Mohi
\(1\)](https://gravatar.com/avatar/3acc57b892d73bd8f3b730812936101a?s=32&&d=blank)

KM![kota marusue
\(1\)](https://gravatar.com/avatar/c5026aadc401a016707a086dacc6adbd?s=32&&d=blank)

PL![Pablo LION
\(1\)](https://gravatar.com/avatar/f0151d312fca900bb10fb948878e4602?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.1

## Easier Implicit Returns for `undefined`-Returning Functions

In JavaScript, if a function finishes running without hitting a `return`, it
returns the value `undefined`.

    
    
    ts
    
    function foo() {
    
        // no return
    
    }
    
    // x = undefined
    
    let x = foo();

However, in previous versions of TypeScript, the _only_ functions that could
have absolutely no return statements were `void`\- and `any`-returning
functions. That meant that even if you explicitly said ‚Äúthis function returns
`undefined`‚Äù you were forced to have at least one return statement.

    
    
    ts
    
    // ‚úÖ fine - we inferred that 'f1' returns 'void'
    
    function f1() {
    
        // no returns
    
    }
    
    // ‚úÖ fine - 'void' doesn't need a return statement
    
    function f2(): void {
    
        // no returns
    
    }
    
    // ‚úÖ fine - 'any' doesn't need a return statement
    
    function f3(): any {
    
        // no returns
    
    }
    
    // ‚ùå error!
    
    // A function whose declared type is neither 'void' nor 'any' must return a value.
    
    function f4(): undefined {
    
        // no returns
    
    }

This could be a pain if some API expected a function returning `undefined` \-
you would need to have either at least one explicit return of `undefined` or a
`return` statement _and_ an explicit annotation.

    
    
    ts
    
    declare function takesFunction(f: () => undefined): undefined;
    
    // ‚ùå error!
    
    // Argument of type '() => void' is not assignable to parameter of type '() => undefined'.
    
    takesFunction(() => {
    
        // no returns
    
    });
    
    // ‚ùå error!
    
    // A function whose declared type is neither 'void' nor 'any' must return a value.
    
    takesFunction((): undefined => {
    
        // no returns
    
    });
    
    // ‚ùå error!
    
    // Argument of type '() => void' is not assignable to parameter of type '() => undefined'.
    
    takesFunction(() => {
    
        return;
    
    });
    
    // ‚úÖ works
    
    takesFunction(() => {
    
        return undefined;
    
    });
    
    // ‚úÖ works
    
    takesFunction((): undefined => {
    
        return;
    
    });

This behavior was frustrating and confusing, especially when calling functions
outside of one‚Äôs control. Understanding the interplay between inferring `void`
over `undefined`, whether an `undefined`-returning function needs a `return`
statement, etc. seems like a distraction.

First, TypeScript 5.1 now allows `undefined`-returning functions to have no
return statement.

    
    
    ts
    
    // ‚úÖ Works in TypeScript 5.1!
    
    function f4(): undefined {
    
        // no returns
    
    }
    
    // ‚úÖ Works in TypeScript 5.1!
    
    takesFunction((): undefined => {
    
        // no returns
    
    });

Second, if a function has no return expressions and is being passed to
something expecting a function that returns `undefined`, TypeScript infers
`undefined` for that function‚Äôs return type.

    
    
    ts
    
    // ‚úÖ Works in TypeScript 5.1!
    
    takesFunction(function f() {
    
        //                 ^ return type is undefined
    
        // no returns
    
    });
    
    // ‚úÖ Works in TypeScript 5.1!
    
    takesFunction(function f() {
    
        //                 ^ return type is undefined
    
        return;
    
    });

To address another similar pain-point, under TypeScript‚Äôs
`--noImplicitReturns` option, functions returning _only_ `undefined` now have
a similar exception to `void`, in that not every single code path must end in
an explicit `return`.

    
    
    ts
    
    // ‚úÖ Works in TypeScript 5.1 under '--noImplicitReturns'!
    
    function f(): undefined {
    
        if (Math.random()) {
    
            // do some stuff...
    
            return;
    
        }
    
    }

For more information, you can read up on [the original
issue](https://github.com/microsoft/TypeScript/issues/36288) and [the
implementing pull
request](https://github.com/microsoft/TypeScript/pull/53607).

## Unrelated Types for Getters and Setters

TypeScript 4.3 made it possible to say that a `get` and `set` accessor pair
might specify two different types.

    
    
    ts
    
    interface Serializer {
    
        set value(v: string | number | boolean);
    
        get value(): string;
    
    }
    
    declare let box: Serializer;
    
    // Allows writing a 'boolean'
    
    box.value = true;
    
    // Comes out as a 'string'
    
    console.log(box.value.toUpperCase());

Initially we required that the `get` type had to be a subtype of the `set`
type. This meant that writing

    
    
    ts
    
    box.value = box.value;

would always be valid.

However, there are plenty of existing and proposed APIs that have completely
unrelated types between their getters and setters. For example, consider one
of the most common examples - the `style` property in the DOM and
[`CSSStyleRule`](https://developer.mozilla.org/en-
US/docs/Web/API/CSSStyleRule) API. Every style rule has [a `style`
property](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule/style)
that is a [`CSSStyleDeclaration`](https://developer.mozilla.org/en-
US/docs/Web/API/CSSStyleDeclaration); however, if you try to write to that
property, it will only work correctly with a string!

TypeScript 5.1 now allows completely unrelated types for `get` and `set`
accessor properties, provided that they have explicit type annotations. And
while this version of TypeScript does not yet change the types for these
built-in interfaces, `CSSStyleRule` can now be defined in the following way:

    
    
    ts
    
    interface CSSStyleRule {
    
        // ...
    
        /** Always reads as a `CSSStyleDeclaration` */
    
        get style(): CSSStyleDeclaration;
    
        /** Can only write a `string` here. */
    
        set style(newValue: string);
    
        // ...
    
    }

This also allows other patterns like requiring `set` accessors to accept only
‚Äúvalid‚Äù data, but specifying that `get` accessors may return `undefined` if
some underlying state hasn‚Äôt been initialized yet.

    
    
    ts
    
    class SafeBox {
    
        #value: string | undefined;
    
        // Only accepts strings!
    
        set value(newValue: string) {
    
        }
    
        // Must check for 'undefined'!
    
        get value(): string | undefined {
    
            return this.#value;
    
        }
    
    }

In fact, this is similar to how optional properties are checked under
`--exactOptionalProperties`.

You can read up more on [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/53417).

## Decoupled Type-Checking Between JSX Elements and JSX Tag Types

One pain point TypeScript had with JSX was its requirements on the type of
every JSX element‚Äôs tag.

For context, a JSX element is either of the following:

    
    
    tsx
    
    // A self-closing JSX tag
    
    <Foo />
    
    // A regular element with an opening/closing tag
    
    <Bar></Bar>

When type-checking `<Foo />` or `<Bar></Bar>`, TypeScript always looks up a
namespace called `JSX` and fetches a type out of it called `Element` \- or
more directly, it looks up `JSX.Element`.

But to check whether `Foo` or `Bar` themselves were valid to use as tag names,
TypeScript would roughly just grab the types returned or constructed by `Foo`
or `Bar` and check for compatibility with `JSX.Element` (or another type
called `JSX.ElementClass` if the type is constructable).

The limitations here meant that components could not be used if they returned
or ‚Äúrendered‚Äù a more broad type than just `JSX.Element`. For example, a JSX
library might be fine with a component returning `string`s or `Promise`s.

As a more concrete example, [React is considering adding limited support for
components that return `Promise`s](https://github.com/acdlite/rfcs/blob/first-
class-promises/text/0000-first-class-support-for-promises.md), but existing
versions of TypeScript cannot express that without someone drastically
loosening the type of `JSX.Element`.

    
    
    tsx
    
    import * as React from "react";
    
    async function Foo() {
    
        return <div></div>;
    
    }
    
    let element = <Foo />;
    
    //             ~~~
    
    // 'Foo' cannot be used as a JSX component.
    
    //   Its return type 'Promise<Element>' is not a valid JSX element.

To provide libraries with a way to express this, TypeScript 5.1 now looks up a
type called `JSX.ElementType`. `ElementType` specifies precisely what is valid
to use as a tag in a JSX element. So it might be typed today as something like

    
    
    tsx
    
    namespace JSX {
    
        export type ElementType =
    
            // All the valid lowercase tags
    
            keyof IntrinsicAttributes
    
            // Function components
    
            (props: any) => Element
    
            // Class components
    
            new (props: any) => ElementClass;
    
        export interface IntrinsicAttributes extends /*...*/ {}
    
        export type Element = /*...*/;
    
        export type ElementClass = /*...*/;
    
    }

We‚Äôd like to extend our thanks to [Sebastian
Silbermann](https://github.com/eps1lon) who contributed [this
change](https://github.com/microsoft/TypeScript/pull/51328)!

## Namespaced JSX Attributes

TypeScript now supports namespaced attribute names when using JSX.

    
    
    tsx
    
    import * as React from "react";
    
    // Both of these are equivalent:
    
    const x = <Foo a:b="hello" />;
    
    const y = <Foo a : b="hello" />;
    
    interface FooProps {
    
        "a:b": string;
    
    }
    
    function Foo(props: FooProps) {
    
        return <div>{props["a:b"]}</div>;
    
    }

Namespaced tag names are looked up in a similar way on
`JSX.IntrinsicAttributes` when the first segment of the name is a lowercase
name.

    
    
    tsx
    
    // In some library's code or in an augmentation of that library:
    
    namespace JSX {
    
        interface IntrinsicElements {
    
            ["a:b"]: { prop: string };
    
        }
    
    }
    
    // In our code:
    
    let x = <a:b prop="hello!" />;

[This contribution](https://github.com/microsoft/TypeScript/pull/53799) was
provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).

## `typeRoots` Are Consulted In Module Resolution

When TypeScript‚Äôs specified module lookup strategy is unable to resolve a
path, it will now resolve packages relative to the specified `typeRoots`.

See [this pull request](https://github.com/microsoft/TypeScript/pull/51715)
for more details.

## Move Declarations to Existing Files

In addition to moving declarations to new files, TypeScript now ships a
preview feature for moving declarations to existing files as well. You can try
this functionality out in a recent version of Visual Studio Code.

![Moving a function 'getThanks' to an existing file in the
workspace.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/05/moveToFile-5.1-preview.gif)

Keep in mind that this feature is currently in preview, and we are seeking
further feedback on it.

<https://github.com/microsoft/TypeScript/pull/53542>

## Linked Cursors for JSX Tags

TypeScript now supports _linked editing_ for JSX tag names. Linked editing
(occasionally called ‚Äúmirrored cursors‚Äù) allows an editor to edit multiple
locations at the same time automatically.

![An example of JSX tags with linked editing modifying a JSX fragment and a
div element.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/04/linkedEditingJsx-5.1-1.gif)

This new feature should work in both TypeScript and JavaScript files, and can
be enabled in Visual Studio Code Insiders. In Visual Studio Code, you can
either edit the `Editor: Linked Editing` option in the Settings UI:

![Visual Studio Code's Editor: Linked Editing`
option](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/04/linkedEditing-5.1-vscode-ui-1.png)

or configure `editor.linkedEditing` in your JSON settings file:

    
    
    jsonc
    
    {
    
        // ...
    
        "editor.linkedEditing": true,
    
    }

This feature will also be supported by Visual Studio 17.7 Preview 1.

You can take a look at [our implementation of linked
editing](https://github.com/microsoft/TypeScript/pull/53284) here!

## Snippet Completions for `@param` JSDoc Tags

TypeScript now provides snippet completions when typing out a `@param` tag in
both TypeScript and JavaScript files. This can help cut down on some typing
and jumping around text as you document your code or add JSDoc types in
JavaScript.

![An example of completing JSDoc param comments on an 'add'
function.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/04/paramTagSnippets-5-1-1.gif)

You can [check out how this new feature was implemented on
GitHub](https://github.com/microsoft/TypeScript/pull/53260).

## Optimizations

### Avoiding Unnecessary Type Instantiation

TypeScript 5.1 now avoids performing type instantiation within object types
that are known not to contain references to outer type parameters. This has
the potential to cut down on many unnecessary computations, and reduced the
type-checking time of [material-ui‚Äôs docs
directory](https://github.com/mui/material-
ui/tree/b0351248fb396001a30330daac86d0e0794a0c1d/docs) by over 50%.

You can [see the changes involved for this change on
GitHub](https://github.com/microsoft/TypeScript/pull/53246).

### Negative Case Checks for Union Literals

When checking if a source type is part of a union type, TypeScript will first
do a fast look-up using an internal type identifier for that source. If that
look-up fails, then TypeScript checks for compatibility against every type
within the union.

When relating a literal type to a union of purely literal types, TypeScript
can now avoid that full walk against every other type in the union. This
assumption is safe because TypeScript always interns/caches literal types -
though there are some edge cases to handle relating to ‚Äúfresh‚Äù literal types.

[This optimization](https://github.com/microsoft/TypeScript/pull/53192) was
able to reduce the type-checking time of [the code in this
issue](https://github.com/microsoft/TypeScript/issues/53191) from about 45
seconds to about 0.4 seconds.

### Reduced Calls into Scanner for JSDoc Parsing

When older versions of TypeScript parsed out a JSDoc comment, they would use
the scanner/tokenizer to break the comment into fine-grained tokens and piece
the contents back together. This could be helpful for normalizing comment
text, so that multiple spaces would just collapse into one; but it was
extremely ‚Äúchatty‚Äù and meant the parser and scanner would jump back and forth
very often, adding overhead to JSDoc parsing.

TypeScript 5.1 has moved more logic around breaking down JSDoc comments into
the scanner/tokenizer. The scanner now returns larger chunks of content
directly to the parser to do as it needs.

[These changes](https://github.com/microsoft/TypeScript/pull/53081) have
brought down the parse time of several 10Mb mostly-prose-comment JavaScript
files by about half. For a more realistic example, our performance suite‚Äôs
snapshot of [xstate](https://github.com/statelyai/xstate) dropped about 300ms
of parse time, making it faster to load and analyze.

## Breaking Changes

### ES2020 and Node.js 14.17 as Minimum Runtime Requirements

TypeScript 5.1 now ships JavaScript functionality that was introduced in
ECMAScript 2020. As a result, at minimum TypeScript must be run in a
reasonably modern runtime. For most users, this means TypeScript now only runs
on Node.js 14.17 and later.

If you try running TypeScript 5.1 under an older version of Node.js such as
Node 10 or 12, you may see an error like the following from running either
`tsc.js` or `tsserver.js`:

    
    
    node_modules/typescript/lib/tsserver.js:2406
    
      for (let i = startIndex ?? 0; i < array.length; i++) {
    
                               ^
    
     
    
    SyntaxError: Unexpected token '?'
    
        at wrapSafe (internal/modules/cjs/loader.js:915:16)
    
        at Module._compile (internal/modules/cjs/loader.js:963:27)
    
        at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)
    
        at Module.load (internal/modules/cjs/loader.js:863:32)
    
        at Function.Module._load (internal/modules/cjs/loader.js:708:14)
    
        at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)
    
        at internal/main/run_main_module.js:17:47

Additionally, if you try installing TypeScript you‚Äôll get something like the
following error messages from npm:

    
    
    npm WARN EBADENGINE Unsupported engine {
    
    npm WARN EBADENGINE   package: 'typescript@5.1.1-rc',
    
    npm WARN EBADENGINE   required: { node: '>=14.17' },
    
    npm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' }
    
    npm WARN EBADENGINE }

from Yarn:

    
    
    error typescript@5.1.1-rc: The engine "node" is incompatible with this module. Expected version ">=14.17". Got "12.22.12"
    
    error Found incompatible module.

[See more information around this change
here](https://github.com/microsoft/TypeScript/pull/53291).

### Explicit `typeRoots` Disables Upward Walks for `node_modules/@types`

Previously, when the `typeRoots` option was specified in a `tsconfig.json` but
resolution to any `typeRoots` directories had failed, TypeScript would still
continue walking up parent directories, trying to resolve packages within each
parent‚Äôs `node_modules/@types` folder.

This behavior could prompt excessive look-ups and has been disabled in
TypeScript 5.1. As a result, you may begin to see errors like the following
based on entries in your `tsconfig.json`‚Äôs `types` option or `/// <reference
>` directives

    
    
    error TS2688: Cannot find type definition file for 'node'.
    
    error TS2688: Cannot find type definition file for 'mocha'.
    
    error TS2688: Cannot find type definition file for 'jasmine'.
    
    error TS2688: Cannot find type definition file for 'chai-http'.
    
    error TS2688: Cannot find type definition file for 'webpack-env"'.

The solution is typically to add specific entries for `node_modules/@types` to
your `typeRoots`:

    
    
    jsonc
    
    {
    
        "compilerOptions": {
    
            "types": [
    
                "node",
    
                "mocha"
    
            ],
    
            "typeRoots": [
    
                // Keep whatever you had around before.
    
                "./some-custom-types/",
    
                // You might need your local 'node_modules/@types'.
    
                "./node_modules/@types",
    
                // You might also need to specify a shared 'node_modules/@types'
    
                // if you're using a "monorepo" layout.
    
                "../../node_modules/@types",
    
            ]
    
        }
    
    }

More information is available [on the original change on our issue
tracker](https://github.com/microsoft/TypeScript/pull/51715).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.1.md) ‚ù§

Contributors to this page:  

N![navya9singh
\(6\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

BT![Beeno Tung
\(1\)](https://gravatar.com/avatar/fda886ef64db0a0519b1c7841ae26bc7?s=32&&d=blank)

LL![Lazar Ljubenoviƒá
\(1\)](https://gravatar.com/avatar/4895babd94e2cdbcb20a74204b37c32d?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.2

## `using` Declarations and Explicit Resource Management

TypeScript 5.2 adds support for the upcoming [Explicit Resource
Management](https://github.com/tc39/proposal-explicit-resource-management)
feature in ECMAScript. Let‚Äôs explore some of the motivations and understand
what the feature brings us.

It‚Äôs common to need to do some sort of ‚Äúclean-up‚Äù after creating an object.
For example, you might need to close network connections, delete temporary
files, or just free up some memory.

Let‚Äôs imagine a function that creates a temporary file, reads and writes to it
for various operations, and then closes and deletes it.

    
    
    ts
    
    import * as fs from "fs";
    
    export function doSomeWork() {
    
        const path = ".some_temp_file";
    
        const file = fs.openSync(path, "w+");
    
        // use file...
    
        // Close the file and delete it.
    
        fs.closeSync(file);
    
        fs.unlinkSync(path);
    
    }

This is fine, but what happens if we need to perform an early exit?

    
    
    ts
    
    export function doSomeWork() {
    
        const path = ".some_temp_file";
    
        const file = fs.openSync(path, "w+");
    
        // use file...
    
        if (someCondition()) {
    
            // do some more work...
    
            // Close the file and delete it.
    
            fs.closeSync(file);
    
            fs.unlinkSync(path);
    
            return;
    
        }
    
        // Close the file and delete it.
    
        fs.closeSync(file);
    
        fs.unlinkSync(path);
    
    }

We‚Äôre starting to see some duplication of clean-up which can be easy to
forget. We‚Äôre also not guaranteed to close and delete the file if an error
gets thrown. This could be solved by wrapping this all in a `try`/`finally`
block.

    
    
    ts
    
    export function doSomeWork() {
    
        const path = ".some_temp_file";
    
        const file = fs.openSync(path, "w+");
    
        try {
    
            // use file...
    
            if (someCondition()) {
    
                // do some more work...
    
                return;
    
            }
    
        }
    
        finally {
    
            // Close the file and delete it.
    
            fs.closeSync(file);
    
            fs.unlinkSync(path);
    
        }
    
    }

While this is more robust, it‚Äôs added quite a bit of ‚Äúnoise‚Äù to our code.
There are also other foot-guns we can run into if we start adding more clean-
up logic to our `finally` block ‚Äî for example, exceptions preventing other
resources from being disposed. This is what the [explicit resource
management](https://github.com/tc39/proposal-explicit-resource-management)
proposal aims to solve. The key idea of the proposal is to support resource
disposal ‚Äî this clean-up work we‚Äôre trying to deal with ‚Äî as a first class
idea in JavaScript.

This starts by adding a new built-in `symbol` called `Symbol.dispose`, and we
can create objects with methods named by `Symbol.dispose`. For convenience,
TypeScript defines a new global type called `Disposable` which describes
these.

    
    
    ts
    
    class TempFile implements Disposable {
    
        #path: string;
    
        #handle: number;
    
        constructor(path: string) {
    
            this.#path = path;
    
            this.#handle = fs.openSync(path, "w+");
    
        }
    
        // other methods
    
        [Symbol.dispose]() {
    
            // Close the file and delete it.
    
            fs.closeSync(this.#handle);
    
            fs.unlinkSync(this.#path);
    
        }
    
    }

Later on we can call those methods.

    
    
    ts
    
    export function doSomeWork() {
    
        const file = new TempFile(".some_temp_file");
    
        try {
    
            // ...
    
        }
    
        finally {
    
            file[Symbol.dispose]();
    
        }
    
    }

Moving the clean-up logic to `TempFile` itself doesn‚Äôt buy us much; we‚Äôve
basically just moved all the clean-up work from the `finally` block into a
method, and that‚Äôs always been possible. But having a well-known ‚Äúname‚Äù for
this method means that JavaScript can build other features on top of it.

That brings us to the first star of the feature: `using` declarations! `using`
is a new keyword that lets us declare new fixed bindings, kind of like
`const`. The key difference is that variables declared with `using` get their
`Symbol.dispose` method called at the end of the scope!

So we could simply have written our code like this:

    
    
    ts
    
    export function doSomeWork() {
    
        using file = new TempFile(".some_temp_file");
    
        // use file...
    
        if (someCondition()) {
    
            // do some more work...
    
            return;
    
        }
    
    }

Check it out ‚Äî no `try`/`finally` blocks! At least, none that we see.
Functionally, that‚Äôs exactly what `using` declarations will do for us, but we
don‚Äôt have to deal with that.

You might be familiar with [`using` declarations in
C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-
reference/proposals/csharp-8.0/using), [`with` statements in
Python](https://docs.python.org/3/reference/compound_stmts.html#the-with-
statement), or [`try`-with-resource declarations in
Java](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).
These are all similar to JavaScript‚Äôs new `using` keyword, and provide a
similar explicit way to perform a ‚Äútear-down‚Äù of an object at the end of a
scope.

`using` declarations do this clean-up at the very end of their containing
scope or right before an ‚Äúearly return‚Äù like a `return` or a `throw`n error.
They also dispose in a first-in-last-out order like a stack.

    
    
    ts
    
    function loggy(id: string): Disposable {
    
        console.log(`Creating ${id}`);
    
        return {
    
            [Symbol.dispose]() {
    
                console.log(`Disposing ${id}`);
    
            }
    
        }
    
    }
    
    function func() {
    
        using a = loggy("a");
    
        using b = loggy("b");
    
        {
    
            using c = loggy("c");
    
            using d = loggy("d");
    
        }
    
        using e = loggy("e");
    
        return;
    
        // Unreachable.
    
        // Never created, never disposed.
    
        using f = loggy("f");
    
    }
    
    func();
    
    // Creating a
    
    // Creating b
    
    // Creating c
    
    // Creating d
    
    // Disposing d
    
    // Disposing c
    
    // Creating e
    
    // Disposing e
    
    // Disposing b
    
    // Disposing a

`using` declarations are supposed to be resilient to exceptions; if an error
is thrown, it‚Äôs rethrown after disposal. On the other hand, the body of your
function might execute as expected, but the `Symbol.dispose` might throw. In
that case, that exception is rethrown as well.

But what happens if both the logic before and during disposal throws an error?
For those cases, `SuppressedError` has been introduced as a new subtype of
`Error`. It features a `suppressed` property that holds the last-thrown error,
and an `error` property for the most-recently thrown error.

    
    
    ts
    
    class ErrorA extends Error {
    
        name = "ErrorA";
    
    }
    
    class ErrorB extends Error {
    
        name = "ErrorB";
    
    }
    
    function throwy(id: string) {
    
        return {
    
            [Symbol.dispose]() {
    
                throw new ErrorA(`Error from ${id}`);
    
            }
    
        };
    
    }
    
    function func() {
    
        using a = throwy("a");
    
        throw new ErrorB("oops!")
    
    }
    
    try {
    
        func();
    
    }
    
    catch (e: any) {
    
        console.log(e.name); // SuppressedError
    
        console.log(e.message); // An error was suppressed during disposal.
    
        console.log(e.error.name); // ErrorA
    
        console.log(e.error.message); // Error from a
    
        console.log(e.suppressed.name); // ErrorB
    
        console.log(e.suppressed.message); // oops!
    
    }

You might have noticed that we‚Äôre using synchronous methods in these examples.
However, lots of resource disposal involves _asynchronous_ operations, and we
need to wait for those to complete before we continue running any other code.

That‚Äôs why there is also a new `Symbol.asyncDispose`, and it brings us to the
next star of the show ‚Äî `await using` declarations. These are similar to
`using` declarations, but the key is that they look up whose disposal must be
`await`ed. They use a different method named by `Symbol.asyncDispose`, though
they can operate on anything with a `Symbol.dispose` as well. For convenience,
TypeScript also introduces a global type called `AsyncDisposable` that
describes any object with an asynchronous dispose method.

    
    
    ts
    
    async function doWork() {
    
        // Do fake work for half a second.
    
        await new Promise(resolve => setTimeout(resolve, 500));
    
    }
    
    function loggy(id: string): AsyncDisposable {
    
        console.log(`Constructing ${id}`);
    
        return {
    
            async [Symbol.asyncDispose]() {
    
                console.log(`Disposing (async) ${id}`);
    
                await doWork();
    
            },
    
        }
    
    }
    
    async function func() {
    
        await using a = loggy("a");
    
        await using b = loggy("b");
    
        {
    
            await using c = loggy("c");
    
            await using d = loggy("d");
    
        }
    
        await using e = loggy("e");
    
        return;
    
        // Unreachable.
    
        // Never created, never disposed.
    
        await using f = loggy("f");
    
    }
    
    func();
    
    // Constructing a
    
    // Constructing b
    
    // Constructing c
    
    // Constructing d
    
    // Disposing (async) d
    
    // Disposing (async) c
    
    // Constructing e
    
    // Disposing (async) e
    
    // Disposing (async) b
    
    // Disposing (async) a

Defining types in terms of `Disposable` and `AsyncDisposable` can make your
code much easier to work with if you expect others to do tear-down logic
consistently. In fact, lots of existing types exist in the wild which have a
`dispose()` or `close()` method. For example, the Visual Studio Code APIs even
define [their own `Disposable`
interface](https://code.visualstudio.com/api/references/vscode-
api#Disposable). APIs in the browser and in runtimes like Node.js, Deno, and
Bun might also choose to use `Symbol.dispose` and `Symbol.asyncDispose` for
objects which already have clean-up methods, like file handles, connections,
and more.

Now maybe this all sounds great for libraries, but a little bit heavy-weight
for your scenarios. If you‚Äôre doing a lot of ad-hoc clean-up, creating a new
type might introduce a lot of over-abstraction and questions about best-
practices. For example, take our `TempFile` example again.

    
    
    ts
    
    class TempFile implements Disposable {
    
        #path: string;
    
        #handle: number;
    
        constructor(path: string) {
    
            this.#path = path;
    
            this.#handle = fs.openSync(path, "w+");
    
        }
    
        // other methods
    
        [Symbol.dispose]() {
    
            // Close the file and delete it.
    
            fs.closeSync(this.#handle);
    
            fs.unlinkSync(this.#path);
    
        }
    
    }
    
    export function doSomeWork() {
    
        using file = new TempFile(".some_temp_file");
    
        // use file...
    
        if (someCondition()) {
    
            // do some more work...
    
            return;
    
        }
    
    }

All we wanted was to remember to call two functions ‚Äî but was this the best
way to write it? Should we be calling `openSync` in the constructor, create an
`open()` method, or pass in the handle ourselves? Should we expose a method
for every possible operation we need to perform, or should we just make the
properties public?

That brings us to the final stars of the feature: `DisposableStack` and
`AsyncDisposableStack`. These objects are useful for doing both one-off clean-
up, along with arbitrary amounts of cleanup. A `DisposableStack` is an object
that has several methods for keeping track of `Disposable` objects, and can be
given functions for doing arbitrary clean-up work. We can also assign them to
`using` variables because ‚Äî get this ‚Äî _they‚Äôre also`Disposable`_! So here‚Äôs
how we could‚Äôve written the original example.

    
    
    ts
    
    function doSomeWork() {
    
        const path = ".some_temp_file";
    
        const file = fs.openSync(path, "w+");
    
        using cleanup = new DisposableStack();
    
        cleanup.defer(() => {
    
            fs.closeSync(file);
    
            fs.unlinkSync(path);
    
        });
    
        // use file...
    
        if (someCondition()) {
    
            // do some more work...
    
            return;
    
        }
    
        // ...
    
    }

Here, the `defer()` method just takes a callback, and that callback will be
run once `cleanup` is disposed of. Typically, `defer` (and other
`DisposableStack` methods like `use` and `adopt`) should be called immediately
after creating a resource. As the name suggests, `DisposableStack` disposes of
everything it keeps track of like a stack, in a first-in-last-out order, so
`defer`ing immediately after creating a value helps avoid odd dependency
issues. `AsyncDisposableStack` works similarly, but can keep track of `async`
functions and `AsyncDisposable`s, and is itself an `AsyncDisposable.`

The `defer` method is similar in many ways to the `defer` keyword in
[Go](https://go.dev/tour/flowcontrol/12),
[Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-
language/statements/#Defer-Statement),
[Zig](https://ziglang.org/documentation/master/#defer), [Odin](https://odin-
lang.org/docs/overview/#defer-statement), and others, where the conventions
should be similar.

Because this feature is so recent, most runtimes will not support it natively.
To use it, you will need runtime polyfills for the following:

  * `Symbol.dispose`
  * `Symbol.asyncDispose`
  * `DisposableStack`
  * `AsyncDisposableStack`
  * `SuppressedError`

However, if all you‚Äôre interested in is `using` and `await using`, you should
be able to get away with only polyfilling the built-in `symbol`s. Something as
simple as the following should work for most cases:

    
    
    ts
    
    Symbol.dispose ??= Symbol("Symbol.dispose");
    
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");

You will also need to set your compilation `target` to `es2022` or below, and
configure your `lib` setting to either include `"esnext"` or
`"esnext.disposable"`.

    
    
    json
    
    {
    
        "compilerOptions": {
    
            "target": "es2022",
    
            "lib": ["es2022", "esnext.disposable", "dom"]
    
        }
    
    }

For more information on this feature, [take a look at the work on
GitHub](https://github.com/microsoft/TypeScript/pull/54505)!

## Decorator Metadata

TypeScript 5.2 implements [an upcoming ECMAScript feature called decorator
metadata](https://github.com/tc39/proposal-decorator-metadata).

The key idea of this feature is to make it easy for decorators to create and
consume metadata on any class they‚Äôre used on or within.

Whenever decorator functions are used, they now have access to a new
`metadata` property on their context object. The `metadata` property just
holds a simple object. Since JavaScript lets us add properties arbitrarily, it
can be used as a dictionary that is updated by each decorator. Alternatively,
since every `metadata` object will be identical for each decorated portion of
a class, it can be used as a key into a `Map`. After all decorators on or in a
class get run, that object can be accessed on the class via `Symbol.metadata`.

    
    
    ts
    
    interface Context {
    
        name: string;
    
        metadata: Record<PropertyKey, unknown>;
    
    }
    
    function setMetadata(_target: any, context: Context) {
    
        context.metadata[context.name] = true;
    
    }
    
    class SomeClass {
    
        @setMetadata
    
        foo = 123;
    
        @setMetadata
    
        accessor bar = "hello!";
    
        @setMetadata
    
        baz() { }
    
    }
    
    const ourMetadata = SomeClass[Symbol.metadata];
    
    console.log(JSON.stringify(ourMetadata));
    
    // { "bar": true, "baz": true, "foo": true }

This can be useful in a number of different scenarios. Metadata could possibly
be attached for lots of uses like debugging, serialization, or performing
dependency injection with decorators. Since metadata objects are created per
decorated class, frameworks can either privately use them as keys into a `Map`
or `WeakMap`, or tack properties on as necessary.

For example, let‚Äôs say we wanted to use decorators to keep track of which
properties and accessors are serializable when using `JSON.stringify` like so:

    
    
    ts
    
    import { serialize, jsonify } from "./serializer";
    
    class Person {
    
        firstName: string;
    
        lastName: string;
    
        @serialize
    
        age: number
    
        @serialize
    
        get fullName() {
    
            return `${this.firstName} ${this.lastName}`;
    
        }
    
        toJSON() {
    
            return jsonify(this)
    
        }
    
        constructor(firstName: string, lastName: string, age: number) {
    
            // ...
    
        }
    
    }

Here, the intent is that only `age` and `fullName` should be serialized
because they are marked with the `@serialize` decorator. We define a `toJSON`
method for this purpose, but it just calls out to `jsonify` which uses the
metadata that `@serialize` created.

Here‚Äôs an example of how the module `./serialize.ts` might be defined:

    
    
    ts
    
    const serializables = Symbol();
    
    type Context =
    
        | ClassAccessorDecoratorContext
    
        | ClassGetterDecoratorContext
    
        | ClassFieldDecoratorContext
    
        ;
    
    export function serialize(_target: any, context: Context): void {
    
        if (context.static || context.private) {
    
            throw new Error("Can only serialize public instance members.")
    
        }
    
        if (typeof context.name === "symbol") {
    
            throw new Error("Cannot serialize symbol-named properties.");
    
        }
    
        const propNames =
    
            (context.metadata[serializables] as string[] | undefined) ??= [];
    
        propNames.push(context.name);
    
    }
    
    export function jsonify(instance: object): string {
    
        const metadata = instance.constructor[Symbol.metadata];
    
        const propNames = metadata?.[serializables] as string[] | undefined;
    
        if (!propNames) {
    
            throw new Error("No members marked with @serialize.");
    
        }
    
        const pairStrings = propNames.map(key => {
    
            const strKey = JSON.stringify(key);
    
            const strValue = JSON.stringify((instance as any)[key]);
    
            return `${strKey}: ${strValue}`;
    
        });
    
        return `{ ${pairStrings.join(", ")} }`;
    
    }

This module has a local `symbol` called `serializables` to store and retrieve
the names of properties marked `@serializable`. It stores a list of these
property names on the metadata on each invocation of `@serializable`. When
`jsonify` is called, the list of properties is fetched off of the metadata and
used to retrieve the actual values from the instance, eventually serializing
those names and values.

Using a `symbol` technically makes this data accessible to others. An
alternative might be to use a `WeakMap` using the metadata object as a key.
This keeps data private and happens to use fewer type assertions in this case,
but is otherwise similar.

    
    
    ts
    
    const serializables = new WeakMap<object, string[]>();
    
    type Context =
    
        | ClassAccessorDecoratorContext
    
        | ClassGetterDecoratorContext
    
        | ClassFieldDecoratorContext
    
        ;
    
    export function serialize(_target: any, context: Context): void {
    
        if (context.static || context.private) {
    
            throw new Error("Can only serialize public instance members.")
    
        }
    
        if (typeof context.name !== "string") {
    
            throw new Error("Can only serialize string properties.");
    
        }
    
        let propNames = serializables.get(context.metadata);
    
        if (propNames === undefined) {
    
            serializables.set(context.metadata, propNames = []);
    
        }
    
        propNames.push(context.name);
    
    }
    
    export function jsonify(instance: object): string {
    
        const metadata = instance.constructor[Symbol.metadata];
    
        const propNames = metadata && serializables.get(metadata);
    
        if (!propNames) {
    
            throw new Error("No members marked with @serialize.");
    
        }
    
        const pairStrings = propNames.map(key => {
    
            const strKey = JSON.stringify(key);
    
            const strValue = JSON.stringify((instance as any)[key]);
    
            return `${strKey}: ${strValue}`;
    
        });
    
        return `{ ${pairStrings.join(", ")} }`;
    
    }

As a note, these implementations don‚Äôt handle subclassing and inheritance.
That‚Äôs left as an exercise to you (and you might find that it is easier in one
version of the file than the other!).

Because this feature is still fresh, most runtimes will not support it
natively. To use it, you will need a polyfill for `Symbol.metadata`. Something
as simple as the following should work for most cases:

    
    
    ts
    
    Symbol.metadata ??= Symbol("Symbol.metadata");

You will also need to set your compilation `target` to `es2022` or below, and
configure your `lib` setting to either include `"esnext"` or
`"esnext.decorators"`.

    
    
    json
    
    {
    
        "compilerOptions": {
    
            "target": "es2022",
    
            "lib": ["es2022", "esnext.decorators", "dom"]
    
        }
    
    }

We‚Äôd like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) for
contributing [the implementation of decorator
metadata](https://github.com/microsoft/TypeScript/pull/54657) for TypeScript
5.2!

## Named and Anonymous Tuple Elements

Tuple types have supported optional labels or names for each element.

    
    
    ts
    
    type Pair<T> = [first: T, second: T];

These labels don‚Äôt change what you‚Äôre allowed to do with them ‚Äî they‚Äôre solely
to help with readability and tooling.

However, TypeScript previously had a rule that tuples could not mix and match
between labeled and unlabeled elements. In other words, either no element
could have a label in a tuple, or all elements needed one.

    
    
    ts
    
    // ‚úÖ fine - no labels
    
    type Pair1<T> = [T, T];
    
    // ‚úÖ fine - all fully labeled
    
    type Pair2<T> = [first: T, second: T];
    
    // ‚ùå previously an error
    
    type Pair3<T> = [first: T, T];
    
    //                         ~
    
    // Tuple members must all have names
    
    // or all not have names.

This could be annoying for rest elements where we‚Äôd be forced to just add a
label like `rest` or `tail`.

    
    
    ts
    
    // ‚ùå previously an error
    
    type TwoOrMore_A<T> = [first: T, second: T, ...T[]];
    
    //                                          ~~~~~~
    
    // Tuple members must all have names
    
    // or all not have names.
    
    // ‚úÖ
    
    type TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]];

It also meant that this restriction had to be enforced internally in the type
system, meaning TypeScript would lose labels.

    
    
    ts
    
    type HasLabels = [a: string, b: string];
    
    type HasNoLabels = [number, number];
    
    type Merged = [...HasNoLabels, ...HasLabels];
    
    //   ^ [number, number, string, string]
    
    //
    
    //     'a' and 'b' were lost in 'Merged'

In TypeScript 5.2, the all-or-nothing restriction on tuple labels has been
lifted. The language can now also preserve labels when spreading into an
unlabeled tuple.

We‚Äôd like to extend our thanks to [Josh
Goldberg](https://github.com/JoshuaKGoldberg) and [Mateusz
Burzy≈Ñski](https://github.com/Andarist) who [collaborated to lift this
restriction](https://github.com/microsoft/TypeScript/pull/53356).

## Easier Method Usage for Unions of Arrays

In previous versions on TypeScript, calling a method on a union of arrays
could end in pain.

    
    
    ts
    
    declare let array: string[] | number[];
    
    array.filter(x => !!x);
    
    //    ~~~~~~ error!
    
    // This expression is not callable.
    
    //   Each member of the union type '...' has signatures,
    
    //   but none of those signatures are compatible
    
    //   with each other.

In this example, TypeScript would try to see if each version of `filter` is
compatible across `string[]` and `number[]`. Without a coherent strategy,
TypeScript threw its hands in the air and said ‚ÄúI can‚Äôt make it work‚Äù.

In TypeScript 5.2, before giving up in these cases, unions of arrays are
treated as a special case. A new array type is constructed out of each
member‚Äôs element type, and then the method is invoked on that.

Taking the above example, `string[] | number[]` is transformed into `(string | number)[]` (or `Array<string | number>`), and `filter` is invoked on that type. There is a slight caveat which is that `filter` will produce an `Array<string | number>` instead of a `string[] | number[]`; but for a freshly produced value there is less risk of something ‚Äúgoing wrong‚Äù.

This means lots of methods like `filter`, `find`, `some`, `every`, and
`reduce` should all be invokable on unions of arrays in cases where they were
not previously.

You can [read up more details on the implementing pull
request](https://github.com/microsoft/TypeScript/pull/53489).

## Type-Only Import Paths with TypeScript Implementation File Extensions

TypeScript now allows both declaration _and_ implementation file extensions to
be included in type-only import paths, regardless of whether
`allowImportingTsExtensions` is enabled.

This means that you can now write `import type` statements that use `.ts`,
`.mts`, `.cts`, and `.tsx` file extensions.

    
    
    ts
    
    import type { JustAType } from "./justTypes.ts";
    
    export function f(param: JustAType) {
    
        // ...
    
    }

It also means that `import()` types, which can be used in both TypeScript and
JavaScript with JSDoc, can use those file extensions.

    
    
    js
    
    /**
    
     * @param {import("./justTypes.ts").JustAType} param
    
     */
    
    export function f(param) {
    
        // ...
    
    }

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/54746).

## Comma Completions for Object Members

It can be easy to forget to add a comma when adding a new property to an
object. Previously, if you forgot a comma and requested auto-completion,
TypeScript would confusingly give poor unrelated completion results.

TypeScript 5.2 now gracefully provides object member completions when you‚Äôre
missing a comma. But to just skip past hitting you with a syntax error, it
will _also_ auto-insert the missing comma.

![Properties in an object literal are completed despite missing a comma after
a prior property. When the property name is completed, the missing comma is
automatically inserted.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/06/comma-completions-5-2-beta.gif)

For more information, [see the implementation
here](https://github.com/microsoft/TypeScript/pull/52899).

## Inline Variable Refactoring

TypeScript 5.2 now has a refactoring to inline the contents of a variable to
all usage sites.

![A variable called 'path' initialized to a string, having both of its usages
replaced](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/06/inline-variable-5-2-beta.gif).

Using the ‚Äúinline variable‚Äù refactoring will eliminate the variable and
replace all the variable‚Äôs usages with its initializer. Note that this may
cause that initializer‚Äôs side-effects to run at a different time, and as many
times as the variable has been used.

For more details, [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/54281).

## Optimized Checks for Ongoing Type Compatibility

Because TypeScript is a structural type system, types occasionally need to be
compared in a member-wise fashion; however, recursive types add some issues
here. For example:

    
    
    ts
    
    interface A {
    
        value: A;
    
        other: string;
    
    }
    
    interface B {
    
        value: B;
    
        other: number;
    
    }

When checking whether the type `A` is compatible with the type `B`, TypeScript
will end up checking whether the types of `value` in `A` and `B` are
respectively compatible. At this point, the type system needs to stop checking
any further and proceed to check other members. To do this, the type system
has to track when any two types are already being related.

Previously TypeScript already kept a stack of type pairs, and iterated through
that to determine whether those types are being related. When this stack is
shallow that‚Äôs not a problem; but when the stack isn‚Äôt shallow, that, uh, [is
a problem](https://accidentallyquadratic.tumblr.com/).

In TypeScript 5.3, a simple `Set` helps tracks this information. This reduced
the time spent on a reported test case that used the
[drizzle](https://github.com/drizzle-team/drizzle-orm) library by over 33%!

    
    
    Benchmark 1: old
    
      Time (mean ¬± œÉ):      3.115 s ¬±  0.067 s    [User: 4.403 s, System: 0.124 s]
    
      Range (min ‚Ä¶ max):    3.018 s ‚Ä¶  3.196 s    10 runs
    
     
    
    Benchmark 2: new
    
      Time (mean ¬± œÉ):      2.072 s ¬±  0.050 s    [User: 3.355 s, System: 0.135 s]
    
      Range (min ‚Ä¶ max):    1.985 s ‚Ä¶  2.150 s    10 runs
    
     
    
    Summary
    
      'new' ran
    
        1.50 ¬± 0.05 times faster than 'old'

[Read more on the change
here](https://github.com/microsoft/TypeScript/pull/55224).

## Breaking Changes and Correctness Fixes

TypeScript strives not to unnecessarily introduce breaks; however,
occasionally we must make corrections and improvements so that code can be
better-analyzed.

### `lib.d.ts` Changes

Types generated for the DOM may have an impact on your codebase. For more
information, [see the DOM updates for TypeScript
5.2](https://github.com/microsoft/TypeScript/pull/54725).

### `labeledElementDeclarations` May Hold `undefined` Elements

In order [to support a mixture of labeled and unlabeled
elements](https://github.com/microsoft/TypeScript/pull/53356), TypeScript‚Äôs
API has changed slightly. The `labeledElementDeclarations` property of
`TupleType` may hold `undefined` for at each position where an element is
unlabeled.

    
    
    diff
    
      interface TupleType {
    
    -     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];
    
    +     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];
    
      }

### `module` and `moduleResolution` Must Match Under Recent Node.js settings

The `--module` and `--moduleResolution` options each support a `node16` and
`nodenext` setting. These are effectively ‚Äúmodern Node.js‚Äù settings that
should be used on any recent Node.js project. What we‚Äôve found is that when
these two options don‚Äôt agree on whether they are using Node.js-related
settings, projects are effectively misconfigured.

In TypeScript 5.2, when using `node16` or `nodenext` for either of the
`--module` and `--moduleResolution` options, TypeScript now requires the other
to have a similar Node.js-related setting. In cases where the settings
diverge, you‚Äôll likely get an error message like either

    
    
    Option 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'.

or

    
    
    Option 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'.

So for example `--module esnext --moduleResolution node16` will be rejected ‚Äî
but you may be better off just using `--module nodenext` alone, or `--module
esnext --moduleResolution bundler`.

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/54567).

### Consistent Export Checking for Merged Symbols

When two declarations merge, they must agree in whether they are both
exported. Due to a bug, TypeScript missed specific cases in ambient contexts,
like in declaration files or `declare module` blocks. For example, it would
not issue an error on a case like the following, where `replaceInFile` is
declared once as an exported function, and one as an un-exported namespace.

    
    
    ts
    
    declare module 'replace-in-file' {
    
        export function replaceInFile(config: unknown): Promise<unknown[]>;
    
        export {};
    
        namespace replaceInFile {
    
            export function sync(config: unknown): unknown[];
    
      }
    
    }

In an ambient module, adding an `export { ... }` or a similar construct like
`export default ...` implicitly changes whether all declarations are
automatically exported. TypeScript now recognizes these unfortunately
confusing semantics more consistently, and issues an error on the fact that
all declarations of `replaceInFile` need to agree in their modifiers, and will
issue the following error:

    
    
    Individual declarations in merged declaration 'replaceInFile' must be all exported or all local.

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/54659).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.2.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.3

## Import Attributes

TypeScript 5.3 supports the latest updates to the [import
attributes](https://github.com/tc39/proposal-import-attributes) proposal.

One use-case of import attributes is to provide information about the expected
format of a module to the runtime.

    
    
    ts
    
    // We only want this to be interpreted as JSON,
    
    // not a runnable/malicious JavaScript file with a `.json` extension.
    
    import obj from "./something.json" with { type: "json" };

The contents of these attributes are not checked by TypeScript since they‚Äôre
host-specific, and are simply left alone so that browsers and runtimes can
handle them (and possibly error).

    
    
    ts
    
    // TypeScript is fine with this.
    
    // But your browser? Probably not.
    
    import * as foo from "./foo.js" with { type: "fluffy bunny" };

Dynamic `import()` calls can also use import attributes through a second
argument.

    
    
    ts
    
    const obj = await import("./something.json", {
    
        with: { type: "json" }
    
    });

The expected type of that second argument is defined by a type called
`ImportCallOptions`, which by default just expects a property called `with`.

Note that import attributes are an evolution of an earlier proposal called
[‚Äúimport assertions‚Äù, which were implemented in TypeScript
4.5](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-5/#import-assertions). The most obvious difference is the use of
the `with` keyword over the `assert` keyword. But the less-visible difference
is that runtimes are now free to use attributes to guide the resolution and
interpretation of import paths, whereas import assertions could only assert
some characteristics after loading a module.

Over time, TypeScript will be deprecating the old syntax for import assertions
in favor of the proposed syntax for import attributes. Existing code using
`assert` should migrate towards the `with` keyword. New code that needs an
import attribute should use `with` exclusively.

We‚Äôd like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) for
[implementing this
proposal](https://github.com/microsoft/TypeScript/pull/54242)! And we‚Äôd also
like to call out [Wenlu Wang](https://github.com/Kingwl) for their
implementation of [import
assertions](https://github.com/microsoft/TypeScript/pull/40698)!

## Stable Support `resolution-mode` in Import Types

In TypeScript 4.7, TypeScript added support for a `resolution-mode` attribute
in `/// <reference types="..." />` to control whether a specifier should be
resolved via `import` or `require` semantics.

    
    
    ts
    
    /// <reference types="pkg" resolution-mode="require" />
    
    // or
    
    /// <reference types="pkg" resolution-mode="import" />

A corresponding field was added to import assertions on type-only imports as
well; however, it was only supported in nightly versions of TypeScript. The
rationale was that in spirit, import _assertions_ were not intended to guide
module resolution. So this feature was shipped experimentally in a nightly-
only mode to get more feedback.

But given that _import attributes_ can guide resolution, and that we‚Äôve seen
reasonable use-cases, TypeScript 5.3 now supports the `resolution-mode`
attribute for `import type`.

    
    
    ts
    
    // Resolve `pkg` as if we were importing with a `require()`
    
    import type { TypeFromRequire } from "pkg" with {
    
        "resolution-mode": "require"
    
    };
    
    // Resolve `pkg` as if we were importing with an `import`
    
    import type { TypeFromImport } from "pkg" with {
    
        "resolution-mode": "import"
    
    };
    
    export interface MergedType extends TypeFromRequire, TypeFromImport {}

These import attributes can also be used on `import()` types.

    
    
    ts
    
    export type TypeFromRequire =
    
        import("pkg", { with: { "resolution-mode": "require" } }).TypeFromRequire;
    
    export type TypeFromImport =
    
        import("pkg", { with: { "resolution-mode": "import" } }).TypeFromImport;
    
    export interface MergedType extends TypeFromRequire, TypeFromImport {}

For more information, [check out the change
here](https://github.com/microsoft/TypeScript/pull/55725)

## `resolution-mode` Supported in All Module Modes

Previously, using `resolution-mode` was only allowed under the
`moduleResolution` options `node16` and `nodenext`. To make it easier to look
up modules specifically for type purposes, `resolution-mode` now works
appropriately in all other `moduleResolution` options like `bundler`,
`node10`, and simply doesn‚Äôt error under `classic`.

For more information, [see the implementing pull
request](https://github.com/microsoft/TypeScript/pull/55725).

## `switch (true)` Narrowing

TypeScript 5.3 now can perform narrowing based on conditions in each `case`
clause within a `switch (true)`.

    
    
    ts
    
    function f(x: unknown) {
    
        switch (true) {
    
            case typeof x === "string":
    
                // 'x' is a 'string' here
    
                console.log(x.toUpperCase());
    
                // falls through...
    
            case Array.isArray(x):
    
                // 'x' is a 'string | any[]' here.
    
                console.log(x.length);
    
                // falls through...
    
            default:
    
              // 'x' is 'unknown' here.
    
              // ...
    
        }
    
    }

[This feature](https://github.com/microsoft/TypeScript/pull/55991) was
spearheaded [initial work](https://github.com/microsoft/TypeScript/pull/53681)
by [Mateusz Burzy≈Ñski](https://github.com/Andarist) We‚Äôd like to extend a
‚Äúthank you!‚Äù for this contribution.

## Narrowing On Comparisons to Booleans

Occasionally you may find yourself performing a direct comparison with `true`
or `false` in a condition. Usually these are unnecessary comparisons, but you
might prefer it as a point of style, or to avoid certain issues around
JavaScript truthiness. Regardless, previously TypeScript just didn‚Äôt recognize
such forms when performing narrowing.

TypeScript 5.3 now keeps up and understands these expressions when narrowing
variables.

    
    
    ts
    
    interface A {
    
        a: string;
    
    }
    
    interface B {
    
        b: string;
    
    }
    
    type MyType = A | B;
    
    function isA(x: MyType): x is A {
    
        return "a" in x;
    
    }
    
    function someFn(x: MyType) {
    
        if (isA(x) === true) {
    
            console.log(x.a); // works!
    
        }
    
    }

We‚Äôd like to thank [Mateusz Burzy≈Ñski](https://github.com/Andarist) for [the
pull request](https://github.com/microsoft/TypeScript/pull/53681) that
implemented this.

## `instanceof` Narrowing Through `Symbol.hasInstance`

A slightly esoteric feature of JavaScript is that it is possible to override
the behavior of the `instanceof` operator. To do so, the value on the right
side of the `instanceof` operator needs to have a specific method named by
`Symbol.hasInstance`.

    
    
    js
    
    class Weirdo {
    
        static [Symbol.hasInstance](testedValue) {
    
            // wait, what?
    
            return testedValue === undefined;
    
        }
    
    }
    
    // false
    
    console.log(new Thing() instanceof Weirdo);
    
    // true
    
    console.log(undefined instanceof Weirdo);

To better model this behavior in `instanceof`, TypeScript now checks if such a
`[Symbol.hasInstance]` method exists and is declared as a type predicate
function. If it does, the tested value on the left side of the `instanceof`
operator will be narrowed appropriately by that type predicate.

    
    
    ts
    
    interface PointLike {
    
        x: number;
    
        y: number;
    
    }
    
    class Point implements PointLike {
    
        x: number;
    
        y: number;
    
        constructor(x: number, y: number) {
    
            this.x = x;
    
            this.y = y;
    
        }
    
        distanceFromOrigin() {
    
            return Math.sqrt(this.x ** 2 + this.y ** 2);
    
        }
    
        static [Symbol.hasInstance](val: unknown): val is PointLike {
    
            return !!val && typeof val === "object" &&
    
                "x" in val && "y" in val &&
    
                typeof val.x === "number" &&
    
                typeof val.y === "number";
    
        }
    
    }
    
    function f(value: unknown) {
    
        if (value instanceof Point) {
    
            // Can access both of these - correct!
    
            value.x;
    
            value.y;
    
            // Can't access this - we have a 'PointLike',
    
            // but we don't *actually* have a 'Point'.
    
            value.distanceFromOrigin();
    
        }
    
    }

As you can see in this example, `Point` defines its own `[Symbol.hasInstance]`
method. It actually acts as a custom type guard over a separate type called
`PointLike`. In the function `f`, we were able to narrow `value` down to a
`PointLike` with `instanceof`, but _not_ a `Point`. That means that we can
access the properties `x` and `y`, but not the method `distanceFromOrigin`.

For more information, you can [read up on this change
here](https://github.com/microsoft/TypeScript/pull/55052).

## Checks for `super` Property Accesses on Instance Fields

In JavaScript, it‚Äôs possible to access a declaration in a base class through
the `super` keyword.

    
    
    js
    
    class Base {
    
        someMethod() {
    
            console.log("Base method called!");
    
        }
    
    }
    
    class Derived extends Base {
    
        someMethod() {
    
            console.log("Derived method called!");
    
            super.someMethod();
    
        }
    
    }
    
    new Derived().someMethod();
    
    // Prints:
    
    //   Derived method called!
    
    //   Base method called!

This is different from writing something like `this.someMethod()`, since that
could invoke an overridden method. This is a subtle distinction, made more
subtle by the fact that often the two can be interchangeable if a declaration
is never overridden at all.

    
    
    js
    
    class Base {
    
        someMethod() {
    
            console.log("someMethod called!");
    
        }
    
    }
    
    class Derived extends Base {
    
        someOtherMethod() {
    
            // These act identically.
    
            this.someMethod();
    
            super.someMethod();
    
        }
    
    }
    
    new Derived().someOtherMethod();
    
    // Prints:
    
    //   someMethod called!
    
    //   someMethod called!

The problem is using them interchangeably is that `super` only works on
members declared on the prototype ‚Äî _not_ instance properties. That means that
if you wrote `super.someMethod()`, but `someMethod` was defined as a field,
you‚Äôd get a runtime error!

    
    
    ts
    
    class Base {
    
        someMethod = () => {
    
            console.log("someMethod called!");
    
        }
    
    }
    
    class Derived extends Base {
    
        someOtherMethod() {
    
            super.someMethod();
    
        }
    
    }
    
    new Derived().someOtherMethod();
    
    // üí•
    
    // Doesn't work because 'super.someMethod' is 'undefined'.

TypeScript 5.3 now more-closely inspects `super` property accesses/method
calls to see if they correspond to class fields. If they do, we‚Äôll now get a
type-checking error.

[This check](https://github.com/microsoft/TypeScript/pull/54056) was
contributed thanks to [Jack Works](https://github.com/Jack-Works)!

## Interactive Inlay Hints for Types

TypeScript‚Äôs inlay hints now support jumping to the definition of types! This
makes it easier to casually navigate your code.

![Ctrl-clicking an inlay hint to jump to the definition of a parameter
type.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2023/10/clickable-inlay-hints-for-types-5-3-beta.gif)

See more at [the implementation
here](https://github.com/microsoft/TypeScript/pull/55141).

## Settings to Prefer `type` Auto-Imports

Previously when TypeScript generated auto-imports for something in a type
position, it would add a `type` modifier based on your settings. For example,
when getting an auto-import on `Person` in the following:

    
    
    ts
    
    export let p: Person

TypeScript‚Äôs editing experience would usually add an import for `Person` as:

    
    
    ts
    
    import { Person } from "./types";
    
    export let p: Person

and under certain settings like `verbatimModuleSyntax`, it would add the
`type` modifier:

    
    
    ts
    
    import { type Person } from "./types";
    
    export let p: Person

However, maybe your codebase isn‚Äôt able to use some of these options; or you
just have a preference for explicit `type` imports when possible.

[With a recent change](https://github.com/microsoft/TypeScript/pull/56090),
TypeScript now enables this to be an editor-specific option. In Visual Studio
Code, you can enable it in the UI under ‚ÄúTypeScript ‚Ä∫ Preferences: Prefer Type
Only Auto Imports‚Äù, or as the JSON configuration option
`typescript.preferences.preferTypeOnlyAutoImports`

## Optimizations by Skipping JSDoc Parsing

When running TypeScript via `tsc`, the compiler will now avoid parsing JSDoc.
This drops parsing time on its own, but also reduces memory usage to store
comments along with time spent in garbage collection. All-in-all, you should
see slightly faster compiles and quicker feedback in `--watch` mode.

[The specific changes can be viewed
here](https://github.com/microsoft/TypeScript/pull/52921).

Because not every tool using TypeScript will need to store JSDoc (e.g.
typescript-eslint and Prettier), this parsing strategy has been surfaced as
part of the API itself. This can enable these tools to gain the same memory
and speed improvements we‚Äôve brought to the TypeScript compiler. The new
options for comment parsing strategy are described in `JSDocParsingMode`. More
information is available [on this pull
request](https://github.com/microsoft/TypeScript/pull/55739).

## Optimizations by Comparing Non-Normalized Intersections

In TypeScript, unions and intersections always follow a specific form, where intersections can‚Äôt contain union types. That means that when we create an intersection over a union like `A & (B | C)`, that intersection will be normalized into `(A & B) | (A & C)`. Still, in some cases the type system will maintain the original form for display purposes.

It turns out that the original form can be used for some clever fast-path
comparisons between types.

For example, let‚Äôs say we have `SomeType & (Type1 | Type2 | ... | Type99999NINE)` and we want to see if that‚Äôs assignable to `SomeType`. Recall that we don‚Äôt really have an intersection as our source type ‚Äî we have a union that looks like `(SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE)`. When checking if a union is assignable to some target type, we have to check if _every_ member of the union is assignable to the target type, and that can be very slow.

In TypeScript 5.3, we peek at the original intersection form that we were able
to tuck away. When we compare the types, we do a quick check to see if the
target exists in any constituent of the source intersection.

For more information, [see this pull
request](https://github.com/microsoft/TypeScript/pull/55851).

## Consolidation Between `tsserverlibrary.js` and `typescript.js`

TypeScript itself ships two library files: `tsserverlibrary.js` and
`typescript.js`. There are certain APIs available only in `tsserverlibrary.js`
(like the `ProjectService` API), which may be useful to some importers. Still,
the two are distinct bundles with a lot of overlap, duplicating code in the
package. What‚Äôs more, it can be challenging to consistently use one over the
other due to auto-imports or muscle memory. Accidentally loading both modules
is far too easy, and code may not work properly on a different instance of the
API. Even if it does work, loading a second bundle increases resource usage.

Given this, we‚Äôve decided to consolidate the two. `typescript.js` now contains
what `tsserverlibrary.js` used to contain, and `tsserverlibrary.js` now simply
re-exports `typescript.js`. Comparing the before/after of this consolidation,
we saw the following reduction in package size:

| Before | After | Diff | Diff (percent)  
---|---|---|---|---  
Packed | 6.90 MiB | 5.48 MiB | -1.42 MiB | -20.61%  
Unpacked | 38.74 MiB | 30.41 MiB | -8.33 MiB | -21.50%  
| Before | After | Diff | Diff (percent)  
---|---|---|---|---  
`lib/tsserverlibrary.d.ts` | 570.95 KiB | 865.00 B | -570.10 KiB | -99.85%  
`lib/tsserverlibrary.js` | 8.57 MiB | 1012.00 B | -8.57 MiB | -99.99%  
`lib/typescript.d.ts` | 396.27 KiB | 570.95 KiB | +174.68 KiB | +44.08%  
`lib/typescript.js` | 7.95 MiB | 8.57 MiB | +637.53 KiB | +7.84%  
  
In other words, this is over a 20.5% reduction in package size.

For more information, you can [see the work involved
here](https://github.com/microsoft/TypeScript/pull/55273).

## Breaking Changes and Correctness Improvements

### `lib.d.ts` Changes

Types generated for the DOM may have an impact on your codebase. For more
information, [see the DOM updates for TypeScript
5.3](https://github.com/microsoft/TypeScript/pull/55798).

### Checks for `super` Accesses on Instance Properties

TypeScript 5.3 now detects when the declaration referenced by a `super.`
property access is a class field and issues an error. This prevents errors
that might occur at runtime.

[See more on this change
here](https://github.com/microsoft/TypeScript/pull/54056).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.3.md) ‚ù§

Contributors to this page:  

AB![Andrew Branch
\(6\)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)

EL![Eliran Levi
\(1\)](https://gravatar.com/avatar/8a81d3dd6957e01e288d05ebdd66466d?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.4

## Preserved Narrowing in Closures Following Last Assignments

TypeScript can usually figure out a more specific type for a variable based on
checks that you might perform. This process is called narrowing.

    
    
    ts
    
    function uppercaseStrings(x: string | number) {
    
        if (typeof x === "string") {
    
            // TypeScript knows 'x' is a 'string' here.
    
            return x.toUpperCase();
    
        }
    
    }

One common pain point was that these narrowed types weren‚Äôt always preserved
within function closures.

    
    
    ts
    
    function getUrls(url: string | URL, names: string[]) {
    
        if (typeof url === "string") {
    
            url = new URL(url);
    
        }
    
        return names.map(name => {
    
            url.searchParams.set("name", name)
    
            //  ~~~~~~~~~~~~
    
            // error!
    
            // Property 'searchParams' does not exist on type 'string | URL'.
    
            return url.toString();
    
        });
    
    }

Here, TypeScript decided that it wasn‚Äôt ‚Äúsafe‚Äù to assume that `url` was
_actually_ a `URL` object in our callback function because it was mutated
elsewhere; however, in this instance, that arrow function is _always_ created
after that assignment to `url`, and it‚Äôs also the _last_ assignment to `url`.

TypeScript 5.4 takes advantage of this to make narrowing a little smarter.
When parameters and `let` variables are used in
non-[hoisted](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
functions, the type-checker will look for a last assignment point. If one is
found, TypeScript can safely narrow from outside the containing function. What
that means is the above example just works now.

Note that narrowing analysis doesn‚Äôt kick in if the variable is assigned
anywhere in a nested function. This is because there‚Äôs no way to know for sure
whether the function will be called later.

    
    
    ts
    
    function printValueLater(value: string | undefined) {
    
        if (value === undefined) {
    
            value = "missing!";
    
        }
    
        setTimeout(() => {
    
            // Modifying 'value', even in a way that shouldn't affect
    
            // its type, will invalidate type refinements in closures.
    
            value = value;
    
        }, 500);
    
        setTimeout(() => {
    
            console.log(value.toUpperCase());
    
            //          ~~~~~
    
            // error! 'value' is possibly 'undefined'.
    
        }, 1000);
    
    }

This should make lots of typical JavaScript code easier to express. You can
[read more about the change on
GitHub](https://github.com/microsoft/TypeScript/pull/56908).

## The `NoInfer` Utility Type

When calling generic functions, TypeScript is able to infer type arguments
from whatever you pass in.

    
    
    ts
    
    function doSomething<T>(arg: T) {
    
        // ...
    
    }
    
    // We can explicitly say that 'T' should be 'string'.
    
    doSomething<string>("hello!");
    
    // We can also just let the type of 'T' get inferred.
    
    doSomething("hello!");

One challenge, however, is that it is not always clear what the ‚Äúbest‚Äù type is
to infer. This might lead to TypeScript rejecting valid calls, accepting
questionable calls, or just reporting worse error messages when it catches a
bug.

For example, let‚Äôs imagine a `createStreetLight` function that takes a list of
color names, along with an optional default color.

    
    
    ts
    
    function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {
    
        // ...
    
    }
    
    createStreetLight(["red", "yellow", "green"], "red");

What happens when we pass in a `defaultColor` that wasn‚Äôt in the original
`colors` array? In this function, `colors` is supposed to be the ‚Äúsource of
truth‚Äù and describe what can be passed to `defaultColor`.

    
    
    ts
    
    // Oops! This is undesirable, but is allowed!
    
    createStreetLight(["red", "yellow", "green"], "blue");

In this call, type inference decided that `"blue"` was just as valid of a type as `"red"` or `"yellow"` or `"green"`. So instead of rejecting the call, TypeScript infers the type of `C` as `"red" | "yellow" | "green" | "blue"`. You might say that inference just blue up in our faces!

One way people currently deal with this is to add a separate type parameter
that‚Äôs bounded by the existing type parameter.

    
    
    ts
    
    function createStreetLight<C extends string, D extends C>(colors: C[], defaultColor?: D) {
    
    }
    
    createStreetLight(["red", "yellow", "green"], "blue");
    
    //                                            ~~~~~~
    
    // error!
    
    // Argument of type '"blue"' is not assignable to parameter of type '"red" | "yellow" | "green" | undefined'.

This works, but is a little bit awkward because `D` probably won‚Äôt be used
anywhere else in the signature for `createStreetLight`. While not bad _in this
case_ , using a type parameter only once in a signature is often a code smell.

That‚Äôs why TypeScript 5.4 introduces a new `NoInfer<T>` utility type.
Surrounding a type in `NoInfer<...>` gives a signal to TypeScript not to dig
in and match against the inner types to find candidates for type inference.

Using `NoInfer`, we can rewrite `createStreetLight` as something like this:

    
    
    ts
    
    function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {
    
        // ...
    
    }
    
    createStreetLight(["red", "yellow", "green"], "blue");
    
    //                                            ~~~~~~
    
    // error!
    
    // Argument of type '"blue"' is not assignable to parameter of type '"red" | "yellow" | "green" | undefined'.

Excluding the type of `defaultColor` from being explored for inference means
that `"blue"` never ends up as an inference candidate, and the type-checker
can reject it.

You can see the specific changes in [the implementing pull
request](https://github.com/microsoft/TypeScript/pull/56794), along with [the
initial implementation](https://github.com/microsoft/TypeScript/pull/52968)
provided thanks to [Mateusz Burzy≈Ñski](https://github.com/Andarist)!

## `Object.groupBy` and `Map.groupBy`

TypeScript 5.4 adds declarations for JavaScript‚Äôs new `Object.groupBy` and
`Map.groupBy` static methods.

`Object.groupBy` takes an iterable, and a function that decides which ‚Äúgroup‚Äù
each element should be placed in. The function needs to make a ‚Äúkey‚Äù for each
distinct group, and `Object.groupBy` uses that key to make an object where
every key maps to an array with the original element in it.

So the following JavaScript:

    
    
    js
    
    const array = [0, 1, 2, 3, 4, 5];
    
    const myObj = Object.groupBy(array, (num, index) => {
    
        return num % 2 === 0 ? "even": "odd";
    
    });

is basically equivalent to writing this:

    
    
    js
    
    const myObj = {
    
        even: [0, 2, 4],
    
        odd: [1, 3, 5],
    
    };

`Map.groupBy` is similar, but produces a `Map` instead of a plain object. This
might be more desirable if you need the guarantees of `Map`s, you‚Äôre dealing
with APIs that expect `Map`s, or you need to use any kind of key for grouping
- not just keys that can be used as property names in JavaScript.

    
    
    js
    
    const myObj = Map.groupBy(array, (num, index) => {
    
        return num % 2 === 0 ? "even" : "odd";
    
    });

and just as before, you could have created `myObj` in an equivalent way:

    
    
    js
    
    const myObj = new Map();
    
    myObj.set("even", [0, 2, 4]);
    
    myObj.set("odd", [1, 3, 5]);

Note that in the above example of `Object.groupBy`, the object produced uses
all optional properties.

    
    
    ts
    
    interface EvenOdds {
    
        even?: number[];
    
        odd?: number[];
    
    }
    
    const myObj: EvenOdds = Object.groupBy(...);
    
    myObj.even;
    
    //    ~~~~
    
    // Error to access this under 'strictNullChecks'.

This is because there‚Äôs no way to guarantee in a general way that _all_ the
keys were produced by `groupBy`.

Note also that these methods are only accessible by configuring your `target`
to `esnext` or adjusting your `lib` settings. We expect they will eventually
be available under a stable `es2024` target.

We‚Äôd like to extend a thanks to [Kevin Gibbons](https://github.com/bakkot) for
[adding the declarations to these `groupBy`
methods](https://github.com/microsoft/TypeScript/pull/56805).

## Support for `require()` calls in `--moduleResolution bundler` and `--module
preserve`

TypeScript has a `moduleResolution` option called `bundler` that is meant to
model the way modern bundlers figure out which file an import path refers to.
One of the limitations of the option is that it had to be paired with
`--module esnext`, making it impossible to use the `import ... = require(...)`
syntax.

    
    
    ts
    
    // previously errored
    
    import myModule = require("module/path");

That might not seem like a big deal if you‚Äôre planning on just writing
standard ECMAScript `import`s, but there‚Äôs a difference when using a package
with [conditional exports](https://nodejs.org/api/packages.html#conditional-
exports).

In TypeScript 5.4, `require()` can now be used when setting the `module`
setting to a new option called `preserve`.

Between `--module preserve` and `--moduleResolution bundler`, the two more
accurately model what bundlers and runtimes like Bun will allow, and how
they‚Äôll perform module lookups. In fact, when using `--module preserve`, the
`bundler` option will be implicitly set for `--moduleResolution` (along with
`--esModuleInterop` and `--resolveJsonModule`)

    
    
    json
    
    {
    
        "compilerOptions": {
    
            "module": "preserve",
    
            // ^ also implies:
    
            // "moduleResolution": "bundler",
    
            // "esModuleInterop": true,
    
            // "resolveJsonModule": true,
    
            // ...
    
        }
    
    }

Under `--module preserve`, an ECMAScript `import` will always be emitted as-
is, and `import ... = require(...)` will be emitted as a `require()` call
(though in practice you may not even use TypeScript for emit, since it‚Äôs
likely you‚Äôll be using a bundler for your code). This holds true regardless of
the file extension of the containing file. So the output of this code:

    
    
    ts
    
    import * as foo from "some-package/foo";
    
    import bar = require("some-package/bar");

should look something like this:

    
    
    js
    
    import * as foo from "some-package/foo";
    
    var bar = require("some-package/bar");

What this also means is that the syntax you choose directs how [conditional
exports](https://nodejs.org/api/packages.html#conditional-exports) are
matched. So in the above example, if the `package.json` of `some-package`
looks like this:

    
    
    json
    
    {
    
      "name": "some-package",
    
      "version": "0.0.1",
    
      "exports": {
    
        "./foo": {
    
            "import": "./esm/foo-from-import.mjs",
    
            "require": "./cjs/foo-from-require.cjs"
    
        },
    
        "./bar": {
    
            "import": "./esm/bar-from-import.mjs",
    
            "require": "./cjs/bar-from-require.cjs"
    
        }
    
      }
    
    }

TypeScript will resolve these paths to `[...]/some-package/esm/foo-from-
import.mjs` and `[...]/some-package/cjs/bar-from-require.cjs`.

For more information, you can [read up on these new settings
here](https://github.com/microsoft/TypeScript/pull/56785).

## Checked Import Attributes and Assertions

Import attributes and assertions are now checked against the global
`ImportAttributes` type. This means that runtimes can now more accurately
describe the import attributes

    
    
    ts
    
    // In some global file.
    
    interface ImportAttributes {
    
        type: "json";
    
    }
    
    // In some other module
    
    import * as ns from "foo" with { type: "not-json" };
    
    //                                     ~~~~~~~~~~
    
    // error!
    
    //
    
    // Type '{ type: "not-json"; }' is not assignable to type 'ImportAttributes'.
    
    //  Types of property 'type' are incompatible.
    
    //    Type '"not-json"' is not assignable to type '"json"'.

[This change](https://github.com/microsoft/TypeScript/pull/56034) was provided
thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).

## Quick Fix for Adding Missing Parameters

TypeScript now has a quick fix to add a new parameter to functions that are
called with too many arguments.

![A quick fix being offered when someFunction calls someHelperFunction with 2
more arguments than are
expected.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-before.png)

![The missing arguments have been added to someHelperFunction after the quick
fix was applied.](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-after.png)

This can be useful when threading a new argument through several existing
functions, which can be cumbersome today.

[This quick fix](https://github.com/microsoft/TypeScript/pull/56411) was
provided courtsey of [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).

## Upcoming Changes from TypeScript 5.0 Deprecations

TypeScript 5.0 deprecated the following options and behaviors:

  * `charset`
  * `target: ES3`
  * `importsNotUsedAsValues`
  * `noImplicitUseStrict`
  * `noStrictGenericChecks`
  * `keyofStringsOnly`
  * `suppressExcessPropertyErrors`
  * `suppressImplicitAnyIndexErrors`
  * `out`
  * `preserveValueImports`
  * `prepend` in project references
  * implicitly OS-specific `newLine`

To continue using them, developers using TypeScript 5.0 and other more recent
versions have had to specify a new option called `ignoreDeprecations` with the
value `"5.0"`.

However, TypScript 5.4 will be the last version in which these will continue
to function as normal. By TypeScript 5.5 (likely June 2024), these will become
hard errors, and code using them will need to be migrated away.

For more information, you can [read up on this plan on
GitHub](https://github.com/microsoft/TypeScript/issues/51909), which contains
suggestions in how to best adapt your codebase.

## Notable Behavioral Changes

This section highlights a set of noteworthy changes that should be
acknowledged and understood as part of any upgrade. Sometimes it will
highlight deprecations, removals, and new restrictions. It can also contain
bug fixes that are functionally improvements, but which can also affect an
existing build by introducing new errors.

### `lib.d.ts` Changes

Types generated for the DOM may have an impact on type-checking your codebase.
For more information, [see the DOM updates for TypeScript
5.4](https://github.com/microsoft/TypeScript/pull/57027).

### More Accurate Conditional Type Constraints

The following code no longer allows the second variable declaration in the
function `foo`.

    
    
    ts
    
    type IsArray<T> = T extends any[] ? true : false;
    
    function foo<U extends object>(x: IsArray<U>) {
    
        let first: true = x;    // Error
    
        let second: false = x;  // Error, but previously wasn't
    
    }

Previously, when TypeScript checked the initializer for `second`, it needed to
determine whether `IsArray<U>` was assignable to the unit type `false`. While
`IsArray<U>` isn‚Äôt compatible any obvious way, TypeScript looks at the
_constraint_ of that type as well. In a conditional type like `T extends Foo ?
TrueBranch : FalseBranch`, where `T` is generic, the type system would look at
the constraint of `T`, substitute it in for `T` itself, and decide on either
the true or false branch.

But this behavior was inaccurate because it was overly eager. Even if the
constraint of `T` isn‚Äôt assignable to `Foo`, that doesn‚Äôt mean that it won‚Äôt
be instantiated with something that is. And so the more correct behavior is to
produce a union type for the constraint of the conditional type in cases where
it can‚Äôt be proven that `T` _never_ or _always_ extends `Foo.`

TypeScript 5.4 adopts this more accurate behavior. What this means in practice
is that you may begin to find that some conditional type instances are no
longer compatible with their branches.

[You can read about the specific changes
here](https://github.com/microsoft/TypeScript/pull/56004).

### More Aggressive Reduction of Intersections Between Type Variables and
Primitive Types

TypeScript now reduces intersections with type variables and primitives more
aggressively, depending on how the type variable‚Äôs constraint overlaps with
those primitives.

    
    
    ts
    
    declare function intersect<T, U>(x: T, y: U): T & U;
    
    function foo<T extends "abc" | "def">(x: T, str: string, num: number) {
    
        // Was 'T & string', now is just 'T'
    
        let a = intersect(x, str);
    
        // Was 'T & number', now is just 'never'
    
        let b = intersect(x, num)
    
        // Was '(T & "abc") | (T & "def")', now is just 'T'
    
        let c = Math.random() < 0.5 ?
    
            intersect(x, "abc") :
    
            intersect(x, "def");
    
    }

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/56515).

### Improved Checking Against Template Strings with Interpolations

TypeScript now more accurately checks whether or not strings are assignable to
the placeholder slots of a template string type.

    
    
    ts
    
    function a<T extends {id: string}>() {
    
        let x: `-${keyof T & string}`;
    
        
    
        // Used to error, now doesn't.
    
        x = "-id";
    
    }

This behavior is more desirable, but may cause breaks in code using constructs
like conditional types, where these rule changes are easy to witness.

[See this change](https://github.com/microsoft/TypeScript/pull/56598) for more
details.

### Errors When Type-Only Imports Conflict with Local Values

Previously, TypeScript would permit the following code under `isolatedModules`
if the import to `Something` only referred to a type.

    
    
    ts
    
    import { Something } from "./some/path";
    
    let Something = 123;

However, it‚Äôs not safe for single-file compilers to assume whether it‚Äôs ‚Äúsafe‚Äù
to drop the `import`, even if the code is guaranteed to fail at runtime. In
TypeScript 5.4, this code will trigger an error like the following:

    
    
    Import 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled.

The fix should be to either make a local rename, or, as the error states, add
the `type` modifier to the import:

    
    
    ts
    
    import type { Something } from "./some/path";
    
    // or
    
    import { type Something } from "./some/path";

[See more information on the change
itself](https://github.com/microsoft/TypeScript/pull/56354).

### New Enum Assignability Restrictions

When two enums have the same declared names and enum member names, they were
previously always considered compatible; however, when the values were known,
TypeScript would silently allow them to have differing values.

TypeScript 5.4 tightens this restriction by requiring the values to be
identical when they are known.

    
    
    ts
    
    namespace First {
    
        export enum SomeEnum {
    
            A = 0,
    
            B = 1,
    
        }
    
    }
    
    namespace Second {
    
        export enum SomeEnum {
    
            A = 0,
    
            B = 2,
    
        }
    
    }
    
    function foo(x: First.SomeEnum, y: Second.SomeEnum) {
    
        // Both used to be compatible - no longer the case,
    
        // TypeScript errors with something like:
    
        //
    
        //  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.
    
        x = y;
    
        y = x;
    
    }

Additionally, there are new restrictions for when one of the enum members does
not have a statically known value. In these cases, the other enum must at
least be implicitly numeric (e.g. it has no statically resolved initializer),
or it is explicitly numeric (meaning TypeScript could resolve the value to
something numeric). Practically speaking, what this means is that string enum
members are only ever compatible with other string enums of the same value.

    
    
    ts
    
    namespace First {
    
        export declare enum SomeEnum {
    
            A,
    
            B,
    
        }
    
    }
    
    namespace Second {
    
        export declare enum SomeEnum {
    
            A,
    
            B = "some known string",
    
        }
    
    }
    
    function foo(x: First.SomeEnum, y: Second.SomeEnum) {
    
        // Both used to be compatible - no longer the case,
    
        // TypeScript errors with something like:
    
        //
    
        //  One value of 'SomeEnum.B' is the string '"some known string"', and the other is assumed to be an unknown numeric value.
    
        x = y;
    
        y = x;
    
    }

For more information, [see the pull request that introduced this
change](https://github.com/microsoft/TypeScript/pull/55924).

### Name Restrictions on Enum Members

TypeScript no longer allows enum members to use the names `Infinity`,
`-Infinity`, or `NaN`.

    
    
    ts
    
    // Errors on all of these:
    
    //
    
    //  An enum member cannot have a numeric name.
    
    enum E {
    
        Infinity = 0,
    
        "-Infinity" = 1,
    
        NaN = 2,
    
    }

[See more details here](https://github.com/microsoft/TypeScript/pull/56161).

### Better Mapped Type Preservation Over Tuples with `any` Rest Elements

Previously, applying a mapped type with `any` into a tuple would create an
`any` element type. This is undesirable and is now fixed.

    
    
    ts
    
    Promise.all(["", ...([] as any)])
    
        .then((result) => {
    
            const head = result[0];       // 5.3: any, 5.4: string
    
            const tail = result.slice(1); // 5.3 any, 5.4: any[]
    
        });

For more information, see [the
fix](https://github.com/microsoft/TypeScript/pull/57031) along with [the
follow-on discussion around behavioral
changes](https://github.com/microsoft/TypeScript/issues/57389) and [further
tweaks](https://github.com/microsoft/TypeScript/issues/57389).

### Emit Changes

While not a breaking change per se, developers may have implicitly taken
dependencies on TypeScript‚Äôs JavaScript or declaration emit outputs. The
following are notable changes.

  * [Preserve type parameter names more often when shadowed](https://github.com/microsoft/TypeScript/pull/55820)
  * [Move complex parameter lists of async function into downlevel generator body](https://github.com/microsoft/TypeScript/pull/56296)
  * [Do not remove binding alias in function declarations](https://github.com/microsoft/TypeScript/pull/57020)
  * [ImportAttributes should go through the same emit phases when in an ImportTypeNode](https://github.com/microsoft/TypeScript/pull/56395)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.4.md) ‚ù§

Contributors to this page:  

N![navya9singh
\(6\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

I![IC-EnzoD-FRA
\(1\)](https://gravatar.com/avatar/9b93c2571baa3090d8a01fb17c543126?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript 5.5

## Inferred Type Predicates

_This section was written by[Dan Vanderkam](https://github.com/danvk), who
[implemented this feature in TypeScript
5.5](https://github.com/microsoft/TypeScript/pull/57465). Thanks Dan!_

TypeScript‚Äôs control flow analysis does a great job of tracking how the type
of a variable changes as it moves through your code:

    
    
    tsx
    
    interface Bird {
    
        commonName: string;
    
        scientificName: string;
    
        sing(): void;
    
    }
    
    // Maps country names -> national bird.
    
    // Not all nations have official birds (looking at you, Canada!)
    
    declare const nationalBirds: Map<string, Bird>;
    
    function makeNationalBirdCall(country: string) {
    
      const bird = nationalBirds.get(country);  // bird has a declared type of Bird | undefined
    
      if (bird) {
    
        bird.sing();  // bird has type Bird inside the if statement
    
      } else {
    
        // bird has type undefined here.
    
      }
    
    }

By making you handle the `undefined` case, TypeScript pushes you to write more
robust code.

In the past, this sort of type refinement was more difficult to apply to
arrays. This would have been an error in all previous versions of TypeScript:

    
    
    tsx
    
    function makeBirdCalls(countries: string[]) {
    
      // birds: (Bird | undefined)[]
    
      const birds = countries
    
        .map(country => nationalBirds.get(country))
    
        .filter(bird => bird !== undefined);
    
      for (const bird of birds) {
    
        bird.sing();  // error: 'bird' is possibly 'undefined'.
    
      }
    
    }

This code is perfectly fine: we‚Äôve filtered all the `undefined` values out of
the list. But TypeScript hasn‚Äôt been able to follow along.

With TypeScript 5.5, the type checker is fine with this code:

    
    
    tsx
    
    function makeBirdCalls(countries: string[]) {
    
      // birds: Bird[]
    
      const birds = countries
    
        .map(country => nationalBirds.get(country))
    
        .filter(bird => bird !== undefined);
    
      for (const bird of birds) {
    
        bird.sing();  // ok!
    
      }
    
    }

Note the more precise type for `birds`.

This works because TypeScript now infers a [type
predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-
type-predicates) for the `filter` function. You can see what‚Äôs going on more
clearly by pulling it out into a standalone function:

    
    
    tsx
    
    // function isBirdReal(bird: Bird | undefined): bird is Bird
    
    function isBirdReal(bird: Bird | undefined) {
    
      return bird !== undefined;
    
    }

`bird is Bird` is the type predicate. It means that, if the function returns
`true`, then it‚Äôs a `Bird` (if the function returns `false` then it‚Äôs
`undefined`). The type declarations for `Array.prototype.filter` know about
type predicates, so the net result is that you get a more precise type and the
code passes the type checker.

TypeScript will infer that a function returns a type predicate if these
conditions hold:

  1. The function does not have an explicit return type or type predicate annotation.
  2. The function has a single `return` statement and no implicit returns.
  3. The function does not mutate its parameter.
  4. The function returns a `boolean` expression that‚Äôs tied to a refinement on the parameter.

Generally this works how you‚Äôd expect. Here‚Äôs a few more examples of inferred
type predicates:

    
    
    tsx
    
    // const isNumber: (x: unknown) => x is number
    
    const isNumber = (x: unknown) => typeof x === 'number';
    
    // const isNonNullish: <T>(x: T) => x is NonNullable<T>
    
    const isNonNullish = <T,>(x: T) => x != null;

Previously, TypeScript would have just inferred that these functions return
`boolean`. It now infers signatures with type predicates like `x is number` or
`x is NonNullable<T>`.

Type predicates have ‚Äúif and only if‚Äù semantics. If a function returns `x is
T`, then it means that:

  1. If the function returns `true` then `x` has the type `T`.
  2. If the function returns `false` then `x` does _not_ have type `T`.

If you‚Äôre expecting a type predicate to be inferred but it‚Äôs not, then you may
be running afoul of the second rule. This often comes up with ‚Äútruthiness‚Äù
checks:

    
    
    tsx
    
    function getClassroomAverage(students: string[], allScores: Map<string, number>) {
    
      const studentScores = students
    
        .map(student => allScores.get(student))
    
        .filter(score => !!score);
    
      return studentScores.reduce((a, b) => a + b) / studentScores.length;
    
      //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
      // error: Object is possibly 'undefined'.
    
    }

TypeScript did not infer a type predicate for `score => !!score`, and rightly
so: if this returns `true` then `score` is a `number`. But if it returns
`false`, then `score` could be either `undefined` or a `number` (specifically,
`0`). This is a real bug: if any student got a zero on the test, then
filtering out their score will skew the average upwards. Fewer will be above
average and more will be sad!

As with the first example, it‚Äôs better to explicitly filter out `undefined`
values:

    
    
    tsx
    
    function getClassroomAverage(students: string[], allScores: Map<string, number>) {
    
      const studentScores = students
    
        .map(student => allScores.get(student))
    
        .filter(score => score !== undefined);
    
      return studentScores.reduce((a, b) => a + b) / studentScores.length;  // ok!
    
    }

A truthiness check _will_ infer a type predicate for object types, where
there‚Äôs no ambiguity. Remember that functions must return a `boolean` to be a
candidate for an inferred type predicate: `x => !!x` might infer a type
predicate, but `x => x` definitely won‚Äôt.

Explicit type predicates continue to work exactly as before. TypeScript will
not check whether it would infer the same type predicate. Explicit type
predicates (‚Äúis‚Äù) are no safer than a type assertion (‚Äúas‚Äù).

It‚Äôs possible that this feature will break existing code if TypeScript now
infers a more precise type than you want. For example:

    
    
    tsx
    
    // Previously, nums: (number | null)[]
    
    // Now, nums: number[]
    
    const nums = [1, 2, 3, null, 5].filter(x => x !== null);
    
    nums.push(null);  // ok in TS 5.4, error in TS 5.5

The fix is to tell TypeScript the type that you want using an explicit type
annotation:

    
    
    tsx
    
    const nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null);
    
    nums.push(null);  // ok in all versions

For more information, check out the [implementing pull
request](https://github.com/microsoft/TypeScript/pull/57465) and [Dan‚Äôs blog
post about implementing this
feature](https://effectivetypescript.com/2024/04/16/inferring-a-type-
predicate/).

## Control Flow Narrowing for Constant Indexed Accesses

TypeScript is now able to narrow expressions of the form `obj[key]` when both
`obj` and `key` are effectively constant.

    
    
    ts
    
    function f1(obj: Record<string, unknown>, key: string) {
    
        if (typeof obj[key] === "string") {
    
            // Now okay, previously was error
    
            obj[key].toUpperCase();
    
        }
    
    }

In the above, neither `obj` nor `key` are ever mutated, so TypeScript can
narrow the type of `obj[key]` to `string` after the `typeof` check. For more
information, [see the implementing pull request
here](https://github.com/microsoft/TypeScript/pull/57847).

## The JSDoc `@import` Tag

Today, if you want to import something only for type-checking in a JavaScript
file, it is cumbersome. JavaScript developers can‚Äôt simply import a type named
`SomeType` if it‚Äôs not there at runtime.

    
    
    js
    
    // ./some-module.d.ts
    
    export interface SomeType {
    
        // ...
    
    }
    
    // ./index.js
    
    import { SomeType } from "./some-module"; // ‚ùå runtime error!
    
    /**
    
     * @param {SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

`SomeType` won‚Äôt exist at runtime, so the import will fail. Developers can
instead use a namespace import instead.

    
    
    js
    
    import * as someModule from "./some-module";
    
    /**
    
     * @param {someModule.SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

But `./some-module` is still imported at runtime - which might also not be
desirable.

To avoid this, developers typically had to use `import(...)` types in JSDoc
comments.

    
    
    js
    
    /**
    
     * @param {import("./some-module").SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

If you wanted to reuse the same type in multiple places, you could use a
`typedef` to avoid repeating the import.

    
    
    js
    
    /**
    
     * @typedef {import("./some-module").SomeType} SomeType
    
     */
    
    /**
    
     * @param {SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

This helps with local uses of `SomeType`, but it gets repetitive for many
imports and can be a bit verbose.

That‚Äôs why TypeScript now supports a new `@import` comment tag that has the
same syntax as ECMAScript imports.

    
    
    js
    
    /** @import { SomeType } from "some-module" */
    
    /**
    
     * @param {SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

Here, we used named imports. We could also have written our import as a
namespace import.

    
    
    js
    
    /** @import * as someModule from "some-module" */
    
    /**
    
     * @param {someModule.SomeType} myValue
    
     */
    
    function doSomething(myValue) {
    
        // ...
    
    }

Because these are just JSDoc comments, they don‚Äôt affect runtime behavior at
all.

We would like to extend a big thanks to [Oleksandr
Tarasiuk](https://github.com/a-tarasyuk) who contributed [this
change](https://github.com/microsoft/TypeScript/pull/57207)!

## Regular Expression Syntax Checking

Until now, TypeScript has typically skipped over most regular expressions in
code. This is because regular expressions technically have an extensible
grammar and TypeScript never made any effort to compile regular expressions to
earlier versions of JavaScript. Still, this meant that lots of common problems
would go undiscovered in regular expressions, and they would either turn into
errors at runtime, or silently fail.

But TypeScript now does basic syntax checking on regular expressions!

    
    
    ts
    
    let myRegex = /@robot(\s+(please|immediately)))? do some task/;
    
    //                                            ~
    
    // error!
    
    // Unexpected ')'. Did you mean to escape it with backslash?

This is a simple example, but this checking can catch a lot of common
mistakes. In fact, TypeScript‚Äôs checking goes slightly beyond syntactic
checks. For instance, TypeScript can now catch issues around backreferences
that don‚Äôt exist.

    
    
    ts
    
    let myRegex = /@typedef \{import\((.+)\)\.([a-zA-Z_]+)\} \3/u;
    
    //                                                        ~
    
    // error!
    
    // This backreference refers to a group that does not exist.
    
    // There are only 2 capturing groups in this regular expression.

The same applies to named capturing groups.

    
    
    ts
    
    let myRegex = /@typedef \{import\((?<importPath>.+)\)\.(?<importedEntity>[a-zA-Z_]+)\} \k<namedImport>/;
    
    //                                                                                        ~~~~~~~~~~~
    
    // error!
    
    // There is no capturing group named 'namedImport' in this regular expression.

TypeScript‚Äôs checking is now also aware of when certain RegExp features are
used when newer than your target version of ECMAScript. For example, if we use
named capturing groups like the above in an ES5 target, we‚Äôll get an error.

    
    
    ts
    
    let myRegex = /@typedef \{import\((?<importPath>.+)\)\.(?<importedEntity>[a-zA-Z_]+)\} \k<importedEntity>/;
    
    //                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~
    
    // error!
    
    // Named capturing groups are only available when targeting 'ES2018' or later.

The same is true for certain regular expression flags as well.

Note that TypeScript‚Äôs regular expression support is limited to regular
expression _literals_. If you try calling `new RegExp` with a string literal,
TypeScript will not check the provided string.

We would like to thank [GitHub user
graphemecluster](https://github.com/graphemecluster/) who iterated a ton with
us [to get this feature into
TypeScript](https://github.com/microsoft/TypeScript/pull/55600).

## Support for New ECMAScript `Set` Methods

TypeScript 5.5 declares [new proposed methods for the ECMAScript `Set`
type](https://github.com/tc39/proposal-set-methods).

Some of these methods, like `union`, `intersection`, `difference`, and
`symmetricDifference`, take another `Set` and return a new `Set` as the
result. The other methods, `isSubsetOf`, `isSupersetOf`, and `isDisjointFrom`,
take another `Set` and return a `boolean`. None of these methods mutate the
original `Set`s.

Here‚Äôs a quick example of how you might use these methods and how they behave:

    
    
    ts
    
    let fruits = new Set(["apples", "bananas", "pears", "oranges"]);
    
    let applesAndBananas = new Set(["apples", "bananas"]);
    
    let applesAndOranges = new Set(["apples", "oranges"]);
    
    let oranges = new Set(["oranges"]);
    
    let emptySet = new Set();
    
    ////
    
    // union
    
    ////
    
    // Set(4)¬†{'apples', 'bananas', 'pears', 'oranges'}
    
    console.log(fruits.union(oranges));
    
    // Set(3)¬†{'apples', 'bananas', 'oranges'}
    
    console.log(applesAndBananas.union(oranges));
    
    ////
    
    // intersection
    
    ////
    
    // Set(2)¬†{'apples', 'bananas'}
    
    console.log(fruits.intersection(applesAndBananas));
    
    // Set(0)¬†{}
    
    console.log(applesAndBananas.intersection(oranges));
    
    // Set(1)¬†{'apples'}
    
    console.log(applesAndBananas.intersection(applesAndOranges));
    
    ////
    
    // difference
    
    ////
    
    // Set(3)¬†{'apples', 'bananas', 'pears'}
    
    console.log(fruits.difference(oranges));
    
    // Set(2)¬†{'pears', 'oranges'}
    
    console.log(fruits.difference(applesAndBananas));
    
    // Set(1) {'bananas'}
    
    console.log(applesAndBananas.difference(applesAndOranges));
    
    ////
    
    // symmetricDifference
    
    ////
    
    // Set(2)¬†{'bananas', 'oranges'}
    
    console.log(applesAndBananas.symmetricDifference(applesAndOranges)); // no apples
    
    ////
    
    // isDisjointFrom
    
    ////
    
    // true
    
    console.log(applesAndBananas.isDisjointFrom(oranges));
    
    // false
    
    console.log(applesAndBananas.isDisjointFrom(applesAndOranges));
    
    // true
    
    console.log(fruits.isDisjointFrom(emptySet));
    
    // true
    
    console.log(emptySet.isDisjointFrom(emptySet));
    
    ////
    
    // isSubsetOf
    
    ////
    
    // true
    
    console.log(applesAndBananas.isSubsetOf(fruits));
    
    // false
    
    console.log(fruits.isSubsetOf(applesAndBananas));
    
    // false
    
    console.log(applesAndBananas.isSubsetOf(oranges));
    
    // true
    
    console.log(fruits.isSubsetOf(fruits));
    
    // true
    
    console.log(emptySet.isSubsetOf(fruits));
    
    ////
    
    // isSupersetOf
    
    ////
    
    // true
    
    console.log(fruits.isSupersetOf(applesAndBananas));
    
    // false
    
    console.log(applesAndBananas.isSupersetOf(fruits));
    
    // false
    
    console.log(applesAndBananas.isSupersetOf(oranges));
    
    // true
    
    console.log(fruits.isSupersetOf(fruits));
    
    // false
    
    console.log(emptySet.isSupersetOf(fruits));

We‚Äôd like to thank [Kevin Gibbons](https://github.com/bakkot) who not only co-
championed the feature in ECMAScript, but [also provided the declarations for
`Set`, `ReadonlySet`, and `ReadonlySetLike` in
TypeScript](https://github.com/microsoft/TypeScript/pull/57230)!

## Isolated Declarations

_This section was co-authored by[Rob Palmer](https://github.com/robpalme) who
supported the design of isolated declarations._

Declaration files (a.k.a. `.d.ts` files) describe the shape of existing
libraries and modules to TypeScript. This lightweight description includes the
library‚Äôs type signatures and excludes implementation details such as the
function bodies. They are published so that TypeScript can efficiently check
your usage of a library without needing to analyse the library itself. Whilst
it is possible to handwrite declaration files, if you are authoring typed
code, it‚Äôs much safer and simpler to let TypeScript generate them
automatically from source files using `--declaration`.

The TypeScript compiler and its APIs have always had the job of generating
declaration files; however, there are some use-cases where you might want to
use other tools, or where the traditional build process doesn‚Äôt scale.

### Use-case: Faster Declaration Emit Tools

Imagine if you wanted to create a faster tool to generate declaration files,
perhaps as part of a publishing service or a new bundler. Whilst there is a
thriving ecosystem of blazing fast tools that can turn TypeScript into
JavaScript, the same is not true for turning TypeScript into declaration
files. The reason is that TypeScript‚Äôs inference allows us to write code
without explicitly declaring types, meaning declaration emit can be complex.

Let‚Äôs consider a simple example of a function that adds two imported
variables.

    
    
    ts
    
    // util.ts
    
    export let one = "1";
    
    export let two = "2";
    
    // add.ts
    
    import { one, two } from "./util";
    
    export function add() { return one + two; }

Even if the only thing we want to do is generate `add.d.ts`, TypeScript needs
to crawl into another imported file (`util.ts`), infer that the type of `one`
and `two` are strings, and then calculate that the `+` operator on two strings
will lead to a `string` return type.

    
    
    ts
    
    // add.d.ts
    
    export declare function add(): string;

While this inference is important for the developer experience, it means that
tools that want to generate declaration files would need to replicate parts of
the type-checker including inference and the ability to resolve module
specifiers to follow the imports.

### Use-case: Parallel Declaration Emit and Parallel Checking

Imagine if you had a monorepo containing many projects and a multi-core CPU
that just wished it could help you check your code faster. Wouldn‚Äôt it be
great if we could check all those projects at the same time by running each
project on a different core?

Unfortunately we don‚Äôt have the freedom to do all the work in parallel. The
reason is that we have to build those projects in dependency order, because
each project is checking against the declaration files of their dependencies.
So we must build the dependency first to generate the declaration files.
TypeScript‚Äôs project references feature works the same way, building the set
of projects in ‚Äútopological‚Äù dependency order.

As an example, if we have two projects called `backend` and `frontend`, and
they both depend on a project called `core`, TypeScript can‚Äôt start type-
checking either `frontend` or `backend` until `core` has been built and its
declaration files have been generated.

![frontend and backend point to core, other stuff might point to each of
those](https://devblogs.microsoft.com/typescript/wp-
content/uploads/sites/11/2024/04/5-5-beta-isolated-declarations-deps.png)

In the above graph, you can see that we have a bottleneck. Whilst we can build
`frontend` and `backend` in parallel, we need to first wait for `core` to
finish building before either can start.

How could we improve upon this? Well, if a fast tool could generate all those
declaration files for `core` _in parallel_ , TypeScript then could immediately
follow that by type-checking `core`, `frontend`, and `backend` also _in
parallel_.

### Solution: Explicit Types!

The common requirement in both use-cases is that we need a cross-file type-
checker to generate declaration files. Which is a lot to ask from the tooling
community.

As a more complex example, if we want a declaration file for the following
code‚Ä¶

    
    
    ts
    
    import { add } from "./add";
    
    const x = add();
    
    export function foo() {
    
        return x;
    
    }

‚Ä¶we would need to generate a signature for `foo`. Well that requires looking
at the implementation of `foo`. `foo` just returns `x`, so getting the type of
`x` requires looking at the implementation of `add`. But that might require
looking at the implementation of `add`‚Äôs dependencies, and so on. What we‚Äôre
seeing here is that generating declaration files requires a whole lot of logic
to figure out the types of different places that might not even be local to
the current file.

Still, for developers looking for fast iteration time and fully parallel
builds, there is another way of thinking about this problem. A declaration
file only requires the types of the public API of a module - in other words,
the types of the things that are exported. If, controversially, developers are
willing to explicitly write out the types of the things they export, tools
could generate declaration files without needing to look at the implementation
of the module - and without reimplementing a full type-checker.

This is where the new `--isolatedDeclarations` option comes in.
`--isolatedDeclarations` reports errors when a module can‚Äôt be reliably
transformed without a type-checker. More plainly, it makes TypeScript report
errors if you have a file that isn‚Äôt sufficiently annotated on its exports.

That means in the above example, we would see an error like the following:

    
    
    ts
    
    export function foo() {
    
    //              ~~~
    
    // error! Function must have an explicit
    
    // return type annotation with --isolatedDeclarations.
    
        return x;
    
    }

### Why are errors desirable?

Because it means that TypeScript can

  1. Tell us up-front whether other tools will have issues with generating declaration files
  2. Provide a quick fix to help add these missing annotations.

This mode doesn‚Äôt require annotations _everywhere_ though. For locals, these
can be ignored, since they don‚Äôt affect the public API. For example, the
following code would **not** produce an error:

    
    
    ts
    
    import { add } from "./add";
    
    const x = add("1", "2"); // no error on 'x', it's not exported.
    
    export function foo(): string {
    
        return x;
    
    }

There are also certain expressions where the type is ‚Äútrivial‚Äù to calculate.

    
    
    ts
    
    // No error on 'x'.
    
    // It's trivial to calculate the type is 'number'
    
    export let x = 10;
    
    // No error on 'y'.
    
    // We can get the type from the return expression.
    
    export function y() {
    
        return 20;
    
    }
    
    // No error on 'z'.
    
    // The type assertion makes it clear what the type is.
    
    export function z() {
    
        return Math.max(x, y()) as number;
    
    }

### Using `isolatedDeclarations`

`isolatedDeclarations` requires that either the `declaration` or `composite`
flags are also set.

Note that `isolatedDeclarations` does not change how TypeScript performs emit
- just how it reports errors. Importantly, and similar to `isolatedModules`,
enabling the feature in TypeScript won‚Äôt immediately bring about the potential
benefits discussed here. So please be patient and look forward to future
developments in this space. Keeping tool authors in mind, we should also
recognize that today, not all of TypeScript‚Äôs declaration emit can be easily
replicated by other tools wanting to use it as a guide. That‚Äôs something we‚Äôre
actively working on improving.

On top of this, isolated declarations are still a new feature, and we‚Äôre
actively working on improving the experience. Some scenarios, like using
computed property declarations in classes and object literals, are not _yet_
supported under `isolatedDeclarations`. Keep an eye on this space, and feel
free to provide us with feedback.

We also feel it is worth calling out that `isolatedDeclarations` should be
adopted on a case-by-case basis. There are some developer ergonomics that are
lost when using `isolatedDeclarations`, and thus it may not be the right
choice if your setup is not leveraging the two scenarios mentioned earlier.
For others, the work on `isolatedDeclarations` has already uncovered many
optimizations and opportunities to unlock different parallel build strategies.
In the meantime, if you‚Äôre willing to make the trade-offs, we believe
`isolatedDeclarations` can be a powerful tool to speed up your build process
as external tooling becomes more widely available.

For more information, read up on the [Isolated Declarations: State of the
Feature](https://github.com/microsoft/TypeScript/issues/58944) discussion on
the TypeScript issue tracker.

### Credit

Work on `isolatedDeclarations` has been a long-time collaborative effort
between the TypeScript team and the infrastructure and tooling teams within
Bloomberg and Google. Individuals like Hana Joo from Google who implemented
[the quick fix for isolated declaration
errors](https://github.com/microsoft/TypeScript/pull/58260) (more on that
soon), as well as Ashley Claymore, Jan K√ºhle, Lisa Velden, Rob Palmer, and
Thomas Chetwin have been involved in discussion, specification, and
implementation for many months. But we feel it is specifically worth calling
out the tremendous amount of work provided by [Titian Cernicova-
Dragomir](https://github.com/dragomirtitian) from Bloomberg. Titian has been
instrumental in driving the implementation of `isolatedDeclarations` and has
been a contributor to the TypeScript project for years prior.

While the feature involved many changes, you can see [the core work for
Isolated Declarations
here](https://github.com/microsoft/TypeScript/pull/58201).

## The `${configDir}` Template Variable for Configuration Files

It‚Äôs common in many codebases to reuse a shared `tsconfig.json` file that acts
as a ‚Äúbase‚Äù for other configuration files. This is done by using the `extends`
field in a `tsconfig.json` file.

    
    
    json
    
    {
    
        "extends": "../../tsconfig.base.json",
    
        "compilerOptions": {
    
            "outDir": "./dist"
    
        }
    
    }

One of the issues with this is that all paths in the `tsconfig.json` file are
relative to the location of the file itself. This means that if you have a
shared `tsconfig.base.json` file that is used by multiple projects, relative
paths often won‚Äôt be useful in the derived projects. For example, imagine the
following `tsconfig.base.json`:

    
    
    json
    
    {
    
        "compilerOptions": {
    
            "typeRoots": [
    
                "./node_modules/@types"
    
                "./custom-types"
    
            ],
    
            "outDir": "dist"
    
        }
    
    }

If author‚Äôs intent was that every `tsconfig.json` that extends this file
should

  1. output to a `dist` directory relative to the derived `tsconfig.json` , and
  2. have a `custom-types` directory relative to the derived `tsconfig.json`,

then this would not work. The `typeRoots` paths would be relative to the
location of the shared `tsconfig.base.json` file, not the project that extends
it. Each project that extends this shared file would need to declare its own
`outDir` and `typeRoots` with identical contents. This could be frustrating
and hard to keep in sync between projects, and while the example above is
using `typeRoots`, this is a common problem for `paths` and other options.

To solve this, TypeScript 5.5 introduces a new template variable
`${configDir}`. When `${configDir}` is written in certain path fields of a
`tsconfig.json` or `jsconfig.json` files, this variable is substituted with
the containing directory of the configuration file in a given compilation.
This means that the above `tsconfig.base.json` could be rewritten as:

    
    
    json
    
    {
    
        "compilerOptions": {
    
            "typeRoots": [
    
                "${configDir}/node_modules/@types"
    
                "${configDir}/custom-types"
    
            ],
    
            "outDir": "${configDir}/dist"
    
        }
    
    }

Now, when a project extends this file, the paths will be relative to the
derived `tsconfig.json`, not the shared `tsconfig.base.json` file. This makes
it easier to share configuration files across projects and ensures that the
configuration files are more portable.

If you intend to make a `tsconfig.json` file extendable, consider if a `./`
should instead be written with `${configDir}`.

For more information, see [the proposal
issue](https://github.com/microsoft/TypeScript/issues/57485) and [the
implementing pull
request](https://github.com/microsoft/TypeScript/pull/58042).

## Consulting `package.json` Dependencies for Declaration File Generation

Previously, TypeScript would often issue an error message like

    
    
    The inferred type of "X" cannot be named without a reference to "Y". This is likely not portable. A type annotation is necessary.

This was often due to TypeScript‚Äôs declaration file generation finding itself
in the contents of files that were never explicitly imported in a program.
Generating an import to such a file could be risky if the path ended up being
relative. Still, for codebases with explicit dependencies in the
`dependencies` (or `peerDependencies` and `optionalDependencies`) of a
`package.json`, generating such an import should be safe under certain
resolution modes. So in TypeScript 5.5, we‚Äôre more lenient when that‚Äôs the
case, and many occurrences of this error should disappear.

[See this pull request](https://github.com/microsoft/TypeScript/issues/42873)
for more details on the change.

## Editor and Watch-Mode Reliability Improvements

TypeScript has either added some new functionality or fixed existing logic
that makes `--watch` mode and TypeScript‚Äôs editor integration feel more
reliable. That should hopefully translate to fewer TSServer/editor restarts.

### Correctly Refresh Editor Errors in Configuration Files

TypeScript can generate errors for `tsconfig.json` files; however, those
errors are actually generated from loading a project, and editors typically
don‚Äôt directly request those errors for `tsconfig.json` files. While this
sounds like a technical detail, it means that when all errors issued in a
`tsconfig.json` are fixed, TypeScript doesn‚Äôt issue a new fresh empty set of
errors, and users are left with stale errors unless they reload their editor.

TypeScript 5.5 now intentionally issues an event to clear these out. [See more
here](https://github.com/microsoft/TypeScript/pull/58120).

### Better Handling for Deletes Followed by Immediate Writes

Instead of overwriting files, some tools will opt to delete them and then
create new files from scratch. This is the case when running `npm ci`, for
instance.

While this can be efficient for those tools, it can be problematic for
TypeScript‚Äôs editor scenarios where deleting a watched might dispose of it and
all of its transitive dependencies. Deleting and creating a file in quick
succession could lead to TypeScript tearing down an entire project and then
rebuilding it from scratch.

TypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted
project around until it picks up on a new creation event. This should make
operations like `npm ci` work a lot better with TypeScript. See [more
information on the approach
here](https://github.com/microsoft/TypeScript/pull/57492).

### Symlinks are Tracked in Failed Resolutions

When TypeScript fails to resolve a module, it will still need to watch for any
failed lookup paths in case the module is added later. Previously this was not
done for symlinked directories, which could cause reliability issues in
monorepo-like scenarios when a build occurred in one project but was not
witnessed in the other. This should be fixed in TypeScript 5.5, and means you
won‚Äôt need to restart your editor as often.

[See more information
here](https://github.com/microsoft/TypeScript/pull/58139).

### Project References Contribute to Auto-Imports

Auto-imports no longer requires at least one explicit import to dependent
projects in a project reference setup. Instead, auto-import completions should
just work across anything you‚Äôve listed in the `references` field of your
`tsconfig.json`.

[See more on the implementing pull
request](https://github.com/microsoft/TypeScript/pull/55955).

## Performance and Size Optimizations

### Monomorphized Objects in Language Service and Public API

In TypeScript 5.0, we ensured that our
[`Node`](https://github.com/microsoft/TypeScript/pull/51682) and
[`Symbol`](https://github.com/microsoft/TypeScript/pull/51880) objects had a
consistent set of properties with a consistent initialization order. Doing so
helps reduce polymorphism in different operations, which allows runtimes to
fetch properties more quickly.

By making this change, we witnessed impressive speed wins in the compiler;
however, most of these changes were performed on internal allocators for our
data structures. The language service, along with TypeScript‚Äôs public API,
uses a different set of allocators for certain objects. This allowed the
TypeScript compiler to be a bit leaner, as data used only for the language
service would never be used in the compiler.

In TypeScript 5.5, the same monomorphization work has been done for the
language service and public API. What this means is that your editor
experience, and any build tools that use the TypeScript API, will get a decent
amount faster. In fact, in our benchmarks, we‚Äôve seen a **5-8% speedup in
build times** when using the public TypeScript API‚Äôs allocators, and
**language service operations getting 10-20% faster**. While this does imply
an increase in memory, we believe that tradeoff is worth it and hope to find
ways to reduce that memory overhead. Things should feel a lot snappier now.

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/58045).

### Monomorphized Control Flow Nodes

In TypeScript 5.5, nodes of the control flow graph have been monomorphized so
that they always hold a consistent shape. By doing so, check times will often
be reduced by about 1%.

[See this change here](https://github.com/microsoft/TypeScript/pull/57977).

### Optimizations on our Control Flow Graph

In many cases, control flow analysis will traverse nodes that don‚Äôt provide
any new information. We observed that in the absence of any early termination
or effects in the antecedents (or ‚Äúdominators‚Äù) of certain nodes meant that
those nodes could always be skipped over. As such, TypeScript now constructs
its control flow graphs to take advantage of this by linking to an earlier
node that _does_ provide interesting information for control flow analysis.
This yields a flatter control flow graph, which can be more efficient to
traverse. This optimization has yielded modest gains, but with up to 2%
reductions in build time on certain codebases.

You can [read more here](https://github.com/microsoft/TypeScript/pull/58013).

### Skipped Checking in `transpileModule` and `transpileDeclaration`

TypeScript‚Äôs `transpileModule` API can be used for compiling a single
TypeScript file‚Äôs contents into JavaScript. Similarly, the
`transpileDeclaration` API (see below) can be used to generate a declaration
file for a single TypeScript file. One of the issues with these APIs is that
TypeScript internally would perform a full type-checking pass over the entire
contents of the file before emitting the output. This was necessary to collect
certain information which would later be used for the emit phase.

In TypeScript 5.5, we‚Äôve found a way to avoid performing a full check, only
lazily collecting this information as necessary, and `transpileModule` and
`transpileDeclaration` both enable this functionality by default. As a result,
tools that integrate with these APIs, like [ts-
loader](https://www.npmjs.com/package/ts-loader) with `transpileOnly` and [ts-
jest](https://www.npmjs.com/package/ts-jest), should see a noticeable speedup.
In our testing, [we generally witness around a 2x speed-up in build time using
`transpileModule`](https://github.com/microsoft/TypeScript/pull/58364#issuecomment-2138580690).

### TypeScript Package Size Reduction

Further leveraging [our transition to modules in
5.0](https://devblogs.microsoft.com/typescript/typescripts-migration-to-
modules/), we‚Äôve significantly reduced TypeScript‚Äôs overall package size [by
making `tsserver.js` and `typingsInstaller.js` import from a common API
library instead of having each of them produce standalone
bundles](https://github.com/microsoft/TypeScript/pull/55326).

This reduces TypeScript‚Äôs size on disk from 30.2 MB to 20.4 MB, and reduces
its packed size from 5.5 MB to 3.7 MB!

### Node Reuse in Declaration Emit

As part of the work to enable `isolatedDeclarations`, we‚Äôve substantially
improved how often TypeScript can directly copy your input source code when
producing declaration files.

For example, let‚Äôs say you wrote

    
    
    ts
    
    export const strBool: string | boolean = "hello";
    
    export const boolStr: boolean | string = "world";

Note that the union types are equivalent, but the order of the union is
different. When emitting the declaration file, TypeScript has two equivalent
output possibilities.

The first is to use a consistent canonical representation for each type:

    
    
    ts
    
    export const strBool: string | boolean;
    
    export const boolStr: string | boolean;

The second is to re-use the type annotations exactly as written:

    
    
    ts
    
    export const strBool: string | boolean;
    
    export const boolStr: boolean | string;

The second approach is generally preferable for a few reasons:

  * Many equivalent representations still encode some level of intent that is better to preserve in the declaration file
  * Producing a fresh representation of a type can be somewhat expensive, so avoiding is better
  * User-written types are usually shorter than generated type representations

In 5.5, we‚Äôve greatly improved the number of places where TypeScript can
correctly identify places where it‚Äôs safe and correct to print back types
exactly as they were written in the input file. Many of these cases are
invisible performance improvements - TypeScript would generate fresh sets of
syntax nodes and serialize them into a string. Instead, TypeScript can now
operate over the original syntax nodes directly, which is much cheaper and
faster.

### Caching Contextual Types from Discriminated Unions

When TypeScript asks for the contextual type of an expression like an object
literal, it will often encounter a union type. In those cases, TypeScript
tries to filter out members of the union based on known properties with well
known values (i.e. discriminant properties). This work can be fairly
expensive, especially if you end up with an object consisting of many many
properties. In TypeScript 5.5, [much of the computation is cached once so that
TypeScript doesn‚Äôt need to recompute it for every property in the object
literal](https://github.com/microsoft/TypeScript/pull/58372). Performing this
optimization shaved 250ms off of compiling the TypeScript compiler itself.

## Easier API Consumption from ECMAScript Modules

Previously, if you were writing an ECMAScript module in Node.js, named imports
were not available from the `typescript` package.

    
    
    ts
    
    import { createSourceFile } from "typescript"; // ‚ùå error
    
    import * as ts from "typescript";
    
    ts.createSourceFile // ‚ùå undefined???
    
    ts.default.createSourceFile // ‚úÖ works - but ugh!

This is because [cjs-module-lexer](https://github.com/nodejs/cjs-module-lexer)
did not recognize the pattern of TypeScript‚Äôs generated CommonJS code. This
has been fixed, and users can now use named imports from the TypeScript npm
package with ECMAScript modules in Node.js.

    
    
    ts
    
    import { createSourceFile } from "typescript"; // ‚úÖ works now!
    
    import * as ts from "typescript";
    
    ts.createSourceFile // ‚úÖ works now!

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/57133).

## The `transpileDeclaration` API

TypeScript‚Äôs API exposes a function called `transpileModule`. It‚Äôs intended to
make it easy to compile a single file of TypeScript code. Because it doesn‚Äôt
have access to an entire _program_ , the caveat is that it may not produce the
right output if the code violates any errors under the `isolatedModules`
option.

In TypeScript 5.5, we‚Äôve added a new similar API called
`transpileDeclaration`. This API is similar to `transpileModule`, but it‚Äôs
specifically designed to generate a single _declaration file_ based on some
input source text. Just like `transpileModule`, it doesn‚Äôt have access to a
full program, and a similar caveat applies: it only generates an accurate
declaration file if the input code is free of errors under the new
`isolatedDeclarations` option.

If desired, this function can be used to parallelize declaration emit across
all files under `isolatedDeclarations` mode.

For more information, [see the implementation
here](https://github.com/microsoft/TypeScript/pull/58261).

## Notable Behavioral Changes

This section highlights a set of noteworthy changes that should be
acknowledged and understood as part of any upgrade. Sometimes it will
highlight deprecations, removals, and new restrictions. It can also contain
bug fixes that are functionally improvements, but which can also affect an
existing build by introducing new errors.

### Disabling Features Deprecated in TypeScript 5.0

TypeScript 5.0 deprecated the following options and behaviors:

  * `charset`
  * `target: ES3`
  * `importsNotUsedAsValues`
  * `noImplicitUseStrict`
  * `noStrictGenericChecks`
  * `keyofStringsOnly`
  * `suppressExcessPropertyErrors`
  * `suppressImplicitAnyIndexErrors`
  * `out`
  * `preserveValueImports`
  * `prepend` in project references
  * implicitly OS-specific `newLine`

To continue using the deprecated options above, developers using TypeScript
5.0 and other more recent versions have had to specify a new option called
`ignoreDeprecations` with the value `"5.0"`.

In TypeScript 5.5, these options no longer have any effect. To help with a
smooth upgrade path, you may still specify them in your tsconfig, but these
will be an error to specify in TypeScript 6.0. See also the [Flag Deprecation
Plan](https://github.com/microsoft/TypeScript/issues/51000) which outlines our
deprecation strategy.

[More information around these deprecation plans is available on
GitHub](https://github.com/microsoft/TypeScript/issues/51909), which contains
suggestions in how to best adapt your codebase.

### `lib.d.ts` Changes

Types generated for the DOM may have an impact on type-checking your codebase.
For more information, [see the DOM updates for TypeScript
5.5](https://github.com/microsoft/TypeScript/pull/58211).

### Stricter Parsing for Decorators

Since TypeScript originally introduced support for decorators, the specified
grammar for the proposal has been tightened up. TypeScript is now stricter
about what forms it allows. While rare, existing decorators may need to be
parenthesized to avoid errors.

    
    
    ts
    
    class DecoratorProvider {
    
        decorate(...args: any[]) { }
    
    }
    
    class D extends DecoratorProvider {
    
        m() {
    
            class C {
    
                @super.decorate // ‚ùå error
    
                method1() { }
    
                @(super.decorate) // ‚úÖ okay
    
                method2() { }
    
            }
    
        }
    
    }

See [more information on the change
here](https://github.com/microsoft/TypeScript/pull/57749).

### `undefined` is No Longer a Definable Type Name

TypeScript has always disallowed type alias names that conflict with built-in
types:

    
    
    ts
    
    // Illegal
    
    type null = any;
    
    // Illegal
    
    type number = any;
    
    // Illegal
    
    type object = any;
    
    // Illegal
    
    type any = any;

Due to a bug, this logic didn‚Äôt also apply to the built-in type `undefined`.
In 5.5, this is now correctly identified as an error:

    
    
    ts
    
    // Now also illegal
    
    type undefined = any;

Bare references to type aliases named `undefined` never actually worked in the
first place. You could define them, but you couldn‚Äôt use them as an
unqualified type name.

    
    
    ts
    
    export type undefined = string;
    
    export const m: undefined = "";
    
    //           ^
    
    // Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted.

For more information, [see the change
here](https://github.com/microsoft/TypeScript/pull/57575).

### Simplified Reference Directive Declaration Emit

When producing a declaration file, TypeScript would synthesize a reference
directive when it believed one was required. For example, all Node.js modules
are declared ambiently, so cannot be loaded by module resolution alone. A file
like:

    
    
    tsx
    
    import path from "path";
    
    export const myPath = path.parse(__filename);

Would emit a declaration file like:

    
    
    tsx
    
    /// <reference types="node" />
    
    import path from "path";
    
    export declare const myPath: path.ParsedPath;

Even though the reference directive never appeared in the original source.

Similarly, TypeScript also _removed_ reference directives that it did not
believe needed to be a part of the output. For example, let‚Äôs imagine we had a
reference directive to `jest`; however, imagine the reference directive isn‚Äôt
necessary to generate the declaration file. TypeScript would simply drop it.
So in the following example:

    
    
    tsx
    
    /// <reference types="jest" />
    
    import path from "path";
    
    export const myPath = path.parse(__filename);

TypeScript would still emit:

    
    
    tsx
    
    /// <reference types="node" />
    
    import path from "path";
    
    export declare const myPath: path.ParsedPath;

In the course of working on `isolatedDeclarations`, we realized that this
logic was untenable for anyone attempting to implement a declaration emitter
without type checking or using more than a single file‚Äôs context. This
behavior is also hard to understand from a user‚Äôs perspective; whether or not
a reference directive appeared in the emitted file seems inconsistent and
difficult to predict unless you understand exactly what‚Äôs going on during
typechecking. To prevent declaration emit from being different when
`isolatedDeclarations` was enabled, we knew that our emit needed to change.

Through [experimentation](https://github.com/microsoft/TypeScript/pull/57569),
we found that nearly all cases where TypeScript synthesized reference
directives were just to pull in `node` or `react`. These are cases where the
expectation is that a downstream user already references those types through
tsconfig.json `"types"` or library imports, so no longer synthesizing these
reference directives would be unlikely to break anyone. It‚Äôs worth noting that
this is already how it works for `lib.d.ts`; TypeScript doesn‚Äôt synthesize a
reference to `lib="es2015"` when a module exports a `WeakMap`, instead
assuming that a downstream user will have included that as part of their
environment.

For reference directives that had been written by library authors (not
synthesized), [further
experimentation](https://github.com/microsoft/TypeScript/pull/57656) showed
that nearly all were removed, never showing up in the output. Most reference
directives that were preserved were broken and likely not intended to be
preserved.

Given those results, we decided to greatly simplfy reference directives in
declaration emit in TypeScript 5.5. A more consistent strategy will help
library authors and consumers have better control of their declaration files.

Reference directives are no longer synthesized. User-written reference
directives are no longer preserved, unless annotated with a new
`preserve="true"` attribute. Concretely, an input file like:

    
    
    tsx
    
    /// <reference types="some-lib" preserve="true" />
    
    /// <reference types="jest" />
    
    import path from "path";
    
    export const myPath = path.parse(__filename);

will emit:

    
    
    tsx
    
    /// <reference types="some-lib" preserve="true" />
    
    import path from "path";
    
    export declare const myPath: path.ParsedPath;

Adding `preserve="true"` is backwards compatible with older versions of
TypeScript as unknown attributes are ignored.

This change also improved performance; in our benchmarks, the emit stage saw a
1-4% improvement in projects with declaration emit enabled.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript
5.5.md) ‚ù§

Contributors to this page:  

N![navya9singh
\(6\)](https://gravatar.com/avatar/2b57837ccc20004adc72645a6662c90c?s=32&&d=blank)

DR![Daniel Rosenwasser
\(1\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Symbols

Starting with ECMAScript 2015, `symbol` is a primitive data type, just like
`number` and `string`.

`symbol` values are created by calling the `Symbol` constructor.

    
    
    ts
    
    let sym1 = Symbol();
    
    let sym2 = Symbol("key"); // optional string key

Symbols are immutable, and unique.

    
    
    ts
    
    let sym2 = Symbol("key");
    
    let sym3 = Symbol("key");
    
    sym2 === sym3; // false, symbols are unique

Just like strings, symbols can be used as keys for object properties.

    
    
    ts
    
    const sym = Symbol();
    
    let obj = {
    
      [sym]: "value",
    
    };
    
    console.log(obj[sym]); // "value"

Symbols can also be combined with computed property declarations to declare
object properties and class members.

    
    
    ts
    
    const getClassNameSymbol = Symbol();
    
    class C {
    
      [getClassNameSymbol]() {
    
        return "C";
    
      }
    
    }
    
    let c = new C();
    
    let className = c[getClassNameSymbol](); // "C"

## `unique symbol`

To enable treating symbols as unique literals a special type `unique symbol`
is available. `unique symbol` is a subtype of `symbol`, and are produced only
from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations.
This type is only allowed on `const` declarations and `readonly static`
properties, and in order to reference a specific unique symbol, you‚Äôll have to
use the `typeof` operator. Each reference to a unique symbol implies a
completely unique identity that‚Äôs tied to a given declaration.

    
    
    ts
    
    declare const sym1: unique symbol;
    
    ¬†
    
    // sym2 can only be a constant reference.
    
    let sym2: unique symbol = Symbol();
    
    A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.
    
    ¬†
    
    // Works - refers to a unique symbol, but its identity is tied to 'sym1'.
    
    let sym3: typeof sym1 = sym1;
    
    ¬†
    
    // Also works.
    
    class C {
    
      static readonly StaticSymbol: unique symbol = Symbol();
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYMCYBQATSAYwBsBDaSUIuAO0QBdREBPAWzVQFdaBLARy5VWbAEZwSAbly4QzdtmplaoOiRahRVMtTqNlTSgDMYkWkUgA6XCUhMR2bn0HD24kqAC8oAMpuJABQAlNKyYADqCADWiKAAtKDGMLEMcKA6PAJC8mISADSaXEy8DLG8hLQMJRq8KbyQ+KCpoADkImgt1rb27BioDCwADpBwRjloXuOhcgCCJIhpAO7RiNakZIixAMKgAN64oMwMZFVEiZBk+GoaPsenfrkkTlmuj5MP7sHSAL5AA)

Because each `unique symbol` has a completely separate identity, no two
`unique symbol` types are assignable or comparable to each other.

    
    
    ts
    
    const sym2 = Symbol();
    
    const sym3 = Symbol();
    
    ¬†
    
    if (sym2 === sym3) {
    
    This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.
    
      // ...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqIgJ4C2aoAvKAMq0BGcANgBQCUA3IRLlKtDIxbsufQXgCWAM1DdqdRgyaqMvUAG88oUCFAA6M3gC+QA)

## Well-known Symbols

In addition to user-defined symbols, there are well-known built-in symbols.
Built-in symbols are used to represent internal language behaviors.

Here is a list of well-known symbols:

### `Symbol.asyncIterator`

A method that returns async iterator for an object, compatible to be used with
for await..of loop.

### `Symbol.hasInstance`

A method that determines if a constructor object recognizes an object as one
of the constructor‚Äôs instances. Called by the semantics of the instanceof
operator.

### `Symbol.isConcatSpreadable`

A Boolean value indicating that an object should be flattened to its array
elements by Array.prototype.concat.

### `Symbol.iterator`

A method that returns the default iterator for an object. Called by the
semantics of the for-of statement.

### `Symbol.match`

A regular expression method that matches the regular expression against a
string. Called by the `String.prototype.match` method.

### `Symbol.replace`

A regular expression method that replaces matched substrings of a string.
Called by the `String.prototype.replace` method.

### `Symbol.search`

A regular expression method that returns the index within a string that
matches the regular expression. Called by the `String.prototype.search`
method.

### `Symbol.species`

A function valued property that is the constructor function that is used to
create derived objects.

### `Symbol.split`

A regular expression method that splits a string at the indices that match the
regular expression. Called by the `String.prototype.split` method.

### `Symbol.toPrimitive`

A method that converts an object to a corresponding primitive value. Called by
the `ToPrimitive` abstract operation.

### `Symbol.toStringTag`

A String value that is used in the creation of the default string description
of an object. Called by the built-in method `Object.prototype.toString`.

### `Symbol.unscopables`

An Object whose own property names are property names that are excluded from
the ‚Äòwith‚Äô environment bindings of the associated objects.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Symbols.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(52\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

GB![Gabriel Burdeti
\(2\)](https://gravatar.com/avatar/28ff7ada33ca80bfae575ae1321176ca?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

MN![Micha≈Ç Niedzi√≥≈Çka
\(1\)](https://gravatar.com/avatar/3a088a3160cc0147561dfad28b73cedd?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Triple-Slash Directives

Triple-slash directives are single-line comments containing a single XML tag.
The contents of the comment are used as compiler directives.

Triple-slash directives are **only** valid at the top of their containing
file. A triple-slash directive can only be preceded by single or multi-line
comments, including other triple-slash directives. If they are encountered
following a statement or a declaration they are treated as regular single-line
comments, and hold no special meaning.

## `/// <reference path="..." />`

The `/// <reference path="..." />` directive is the most common of this group.
It serves as a declaration of _dependency_ between files.

Triple-slash references instruct the compiler to include additional files in
the compilation process.

They also serve as a method to order the output when using
[`out`](/tsconfig#out) or [`outFile`](/tsconfig#outFile). Files are emitted to
the output file location in the same order as the input after preprocessing
pass.

### Preprocessing input files

The compiler performs a preprocessing pass on input files to resolve all
triple-slash reference directives. During this process, additional files are
added to the compilation.

The process starts with a set of _root files_ ; these are the file names
specified on the command-line or in the [`files`](/tsconfig#files) list in the
`tsconfig.json` file. These root files are preprocessed in the same order they
are specified. Before a file is added to the list, all triple-slash references
in it are processed, and their targets included. Triple-slash references are
resolved in a depth-first manner, in the order they have been seen in the
file.

A triple-slash reference path is resolved relative to the containing file, if
a relative path is used.

### Errors

It is an error to reference a file that does not exist. It is an error for a
file to have a triple-slash reference to itself.

### Using `--noResolve`

If the compiler flag [`noResolve`](/tsconfig#noResolve) is specified, triple-
slash references are ignored; they neither result in adding new files, nor
change the order of the files provided.

## `/// <reference types="..." />`

Similar to a `/// <reference path="..." />` directive, which serves as a
declaration of _dependency_ , a `/// <reference types="..." />` directive
declares a dependency on a package.

The process of resolving these package names is similar to the process of
resolving module names in an `import` statement. An easy way to think of
triple-slash-reference-types directives are as an `import` for declaration
packages.

For example, including `/// <reference types="node" />` in a declaration file
declares that this file uses names declared in `@types/node/index.d.ts`; and
thus, this package needs to be included in the compilation along with the
declaration file.

Use these directives only when you‚Äôre authoring a `d.ts` file by hand.

For declaration files generated during compilation, the compiler will
automatically add `/// <reference types="..." />` for you; A `/// <reference
types="..." />` in a generated declaration file is added _if and only if_ the
resulting file uses any declarations from the referenced package.

For declaring a dependency on an `@types` package in a `.ts` file, use
[`types`](/tsconfig#types) on the command line or in your `tsconfig.json`
instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json`
files](/docs/handbook/tsconfig-json.html#types-typeroots-and-types) for more
details.

## `/// <reference lib="..." />`

This directive allows a file to explicitly include an existing built-in _lib_
file.

Built-in _lib_ files are referenced in the same fashion as the
[`lib`](/tsconfig#lib) compiler option in _tsconfig.json_ (e.g. use
`lib="es2015"` and not `lib="lib.es2015.d.ts"`, etc.).

For declaration file authors who rely on built-in types, e.g. DOM APIs or
built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-
reference lib directives are recommended. Previously these .d.ts files had to
add forward/duplicate declarations of such types.

For example, adding `/// <reference lib="es2017.string" />` to one of the
files in a compilation is equivalent to compiling with `--lib es2017.string`.

    
    
    ts
    
    /// <reference lib="es2017.string" />
    
    "foo".padStart(4);

## `/// <reference no-default-lib="true"/>`

This directive marks a file as a _default library_. You will see this comment
at the top of `lib.d.ts` and its different variants.

This directive instructs the compiler to _not_ include the default library
(i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing
[`noLib`](/tsconfig#noLib) on the command line.

Also note that when passing
[`skipDefaultLibCheck`](/tsconfig#skipDefaultLibCheck), the compiler will only
skip checking files with `/// <reference no-default-lib="true"/>`.

## `/// <amd-module />`

By default AMD modules are generated anonymous. This can lead to problems when
other tools are used to process the resulting modules, such as bundlers (e.g.
`r.js`).

The `amd-module` directive allows passing an optional module name to the
compiler:

##### amdModule.ts

    
    
    ts
    
    /// <amd-module name="NamedModule"/>
    
    export class C {}

Will result in assigning the name `NamedModule` to the module as part of
calling the AMD `define`:

##### amdModule.js

    
    
    js
    
    define("NamedModule", ["require", "exports"], function (require, exports) {
    
      var C = (function () {
    
        function C() {}
    
        return C;
    
      })();
    
      exports.C = C;
    
    });

## `/// <amd-dependency />`

> **Note** : this directive has been deprecated. Use `import "moduleName";`
> statements instead.

`/// <amd-dependency path="x" />` informs the compiler about a non-TS module
dependency that needs to be injected in the resulting module‚Äôs require call.

The `amd-dependency` directive can also have an optional `name` property; this
allows passing an optional name for an amd-dependency:

    
    
    ts
    
    /// <amd-dependency path="legacy/moduleA" name="moduleA"/>
    
    declare var moduleA: MyType;
    
    moduleA.callStuff();

Generated JS code:

    
    
    js
    
    define(["require", "exports", "legacy/moduleA"], function (
    
      require,
    
      exports,
    
      moduleA
    
    ) {
    
      moduleA.callStuff();
    
    });

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Triple-Slash
Directives.md) ‚ù§

Contributors to this page:  

MH![Mohamed Hegazy
\(58\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JM![Juyeong Maing
\(1\)](https://gravatar.com/avatar/0137470c8550ca5b4f9b52c44b665dc3?s=32&&d=blank)

JB![Jack Bates
\(1\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

GS![Gurjeet Singh
\(1\)](https://gravatar.com/avatar/40ae597fea65bbe3bd7cfa893f6db554?s=32&&d=blank)

9+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# What is a tsconfig.json

## Overview

The presence of a `tsconfig.json` file in a directory indicates that the
directory is the root of a TypeScript project. The `tsconfig.json` file
specifies the root files and the compiler options required to compile the
project.

JavaScript projects can use a `jsconfig.json` file instead, which acts almost
the same but has some JavaScript-related compiler flags enabled by default.

A project is compiled in one of the following ways:

## Using `tsconfig.json` or `jsconfig.json`

  * By invoking tsc with no input files, in which case the compiler searches for the `tsconfig.json` file starting in the current directory and continuing up the parent directory chain.
  * By invoking tsc with no input files and a `--project` (or just `-p`) command line option that specifies the path of a directory containing a `tsconfig.json` file, or a path to a valid `.json` file containing the configurations.

When input files are specified on the command line, `tsconfig.json` files are
ignored.

## Examples

Example `tsconfig.json` files:

  * Using the [`files`](/tsconfig#files) property
    
        {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[removeComments](https://www.typescriptlang.org/tsconfig#removeComments)": true,
    
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true,
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
    
      },
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": [
    
        "core.ts",
    
        "sys.ts",
    
        "types.ts",
    
        "scanner.ts",
    
        "parser.ts",
    
        "utilities.ts",
    
        "binder.ts",
    
        "checker.ts",
    
        "emitter.ts",
    
        "program.ts",
    
        "commandLineParser.ts",
    
        "tsc.ts",
    
        "diagnosticInformationMap.generated.ts"
    
      ]
    
    }

  * Using the [`include`](/tsconfig#include) and [`exclude`](/tsconfig#exclude) properties
    
        {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "system",
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[removeComments](https://www.typescriptlang.org/tsconfig#removeComments)": true,
    
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true,
    
        "[outFile](https://www.typescriptlang.org/tsconfig#outFile)": "../../built/local/tsc.js",
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
    
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["**/*.spec.ts"]
    
    }

## TSConfig Bases

Depending on the JavaScript runtime environment which you intend to run your
code in, there may be a base configuration which you can use at
[github.com/tsconfig/bases](https://github.com/tsconfig/bases/). These are
`tsconfig.json` files which your project extends from which simplifies your
`tsconfig.json` by handling the runtime support.

For example, if you were writing a project which uses Node.js version 12 and
above, then you could use the npm module
[`@tsconfig/node12`](https://www.npmjs.com/package/@tsconfig/node12):

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "@tsconfig/node12/tsconfig.json",
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true
    
      },
    
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
    
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["**/*.spec.ts"]
    
    }

This lets your `tsconfig.json` focus on the unique choices for your project,
and not all of the runtime mechanics. There are a few tsconfig bases already,
and we‚Äôre hoping the community can add more for different environments.

## Details

The `"compilerOptions"` property can be omitted, in which case the compiler‚Äôs
defaults are used. See our full list of supported [Compiler
Options](/tsconfig).

## TSConfig Reference

To learn more about the hundreds of configuration options in the [TSConfig
Reference](/tsconfig).

## Schema

The `tsconfig.json` Schema can be found at [the JSON Schema
Store](http://json.schemastore.org/tsconfig).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-
config/tsconfig.json.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(19\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

JB![Jake Bailey
\(1\)](https://gravatar.com/avatar/e1aaca71f55a5b193ecedfa5ea857ea2?s=32&&d=blank)

L‚ò∫![Loren ‚ò∫Ô∏è
\(1\)](https://gravatar.com/avatar/01628373ecd98f72d4212249797f4ab6?s=32&&d=blank)

AG![Anton Gilgur
\(1\)](https://gravatar.com/avatar/20827df1809becc22927b5ef5dfcde8d?s=32&&d=blank)

CB![Christian Bromann
\(1\)](https://gravatar.com/avatar/6ff923eca7af1ef2e7e54f0f9d6f35d2?s=32&&d=blank)

3+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Type Checking JavaScript Files

Here are some notable differences on how checking works in `.js` files
compared to `.ts` files.

## Properties are inferred from assignments in class bodies

ES2015 does not have a means for declaring properties on classes. Properties
are dynamically assigned, just like object literals.

In a `.js` file, the compiler infers properties from property assignments
inside the class body. The type of a property is the type given in the
constructor, unless it‚Äôs not defined there, or the type in the constructor is
undefined or null. In that case, the type is the union of the types of all the
right-hand values in these assignments. Properties defined in the constructor
are always assumed to exist, whereas ones defined just in methods, getters, or
setters are considered optional.

    
    
    js
    
    class C {
    
      constructor() {
    
        this.constructorOnly = 0;
    
        this.constructorUnknown = undefined;
    
      }
    
      method() {
    
        this.constructorOnly = false;
    
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.
    
        this.constructorUnknown = "plunkbat"; // ok, constructorUnknown is string | undefined
    
        this.methodOnly = "ok"; // ok, but methodOnly could also be undefined
    
      }
    
      method2() {
    
        this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQg6AEsUAOl4DhYidgDyfWgE9QAXlAAGANzzuS1Rv5DR4ggFU+CPngDufM6AifAAmsABmynywwTbcAL7yALawSnjBMnIKiirqms46BAbGAWH0tCiwsQr2uU7artgeXr7+5gBEAA60QQgARvSCbVagmHgIADQ8dS66Td5+oKqgzpEA5qAAPoEh4ZHRttkOyanBRSbtY0MjYGOTvSKCoMfQaWdTIrTBoGUoeKC9sG2oQiUWC8gS3GeaVIGU4WRqaihp0M50Uokq12+5Twk1uTxSL2RxgA5MxBEYOoClis+Ostr08HhaLB6P4tkFgXswfE0HEgA)

If properties are never set in the class body, they are considered unknown. If
your class has properties that are only read from, add and then annotate a
declaration in the constructor with JSDoc to specify the type. You don‚Äôt even
have to give a value if it will be initialized later:

    
    
    js
    
    class C {
    
      constructor() {
    
        /** @type {number | undefined} */
    
        this.prop = undefined;
    
        /** @type {number | undefined} */
    
        this.count;
    
      }
    
    }
    
    ¬†
    
    let c = new C();
    
    c.prop = 0; // OK
    
    c.count = "string";
    
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQwAFRKIggJ4AHWBz4iAtgCMcoAD6gRfACawAZgEs+sKwF9QS4PO6Do9lADpNfE1QAF4LaztHZwBuL0UVNS0ddj0jE3NLGwcnV3dPBVAfP39eS0E47hc0arRaWEEeMNAnAHdWGTjIQODmgAYYxTAAeQBpGlK8cuaAIiFsRwBzGZigA)

## Constructor functions are equivalent to classes

Before ES2015, JavaScript used constructor functions instead of classes. The
compiler supports this pattern and understands constructor functions as
equivalent to ES2015 classes. The property inference rules described above
work exactly the same way.

    
    
    js
    
    function C() {
    
      this.constructorOnly = 0;
    
      this.constructorUnknown = undefined;
    
    }
    
    C.prototype.method = function () {
    
      this.constructorOnly = false;
    
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.
    
      this.constructorUnknown = "plunkbat"; // OK, the type is string | undefined
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgDYAOAZjOtNLQDMBXAO0gBcBLPN0AMIAKAJSgA3mlChO0bigB0kPik7YWXAgHk2AGwCeoALygADAG4pMuYuVtV6zdgCqbBGzwB3fifYATWCZuNlg-SwBfNAEFAAd8TjxOfRjYBQBbWFk8P2NQVg4ePlBRCStZeSUVNQ0E7B0DXKYAQ10UWEtpctsqx1rXdy8fUAAiGN12BAAjJs5h81BMLQBpABprWBlkjflQB2CAc1AAH1B-QODQtHDzIA)

## CommonJS modules are supported

In a `.js` file, TypeScript understands the CommonJS module format.
Assignments to `exports` and `module.exports` are recognized as export
declarations. Similarly, `require` function calls are recognized as module
imports. For example:

    
    
    js
    
    // same as `import module "fs"`
    
    const fs = require("fs");
    
    // same as `export function readFile`
    
    module.exports.readFile = function (f) {
    
      return fs.readFileSync(f);
    
    };

The module support in JavaScript is much more syntactically forgiving than
TypeScript‚Äôs module support. Most combinations of assignments and declarations
are supported.

## Classes, functions, and object literals are namespaces

Classes are namespaces in `.js` files. This can be used to nest classes, for
example:

    
    
    js
    
    class C {}
    
    C.D = class {};
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8C+AoWA6AItAvNUkMyA3EA)

And, for pre-ES2015 code, it can be used to simulate static methods:

    
    
    js
    
    function Outer() {
    
      this.y = 2;
    
    }
    
    ¬†
    
    Outer.Inner = function () {
    
      this.yy = 2;
    
    };
    
    ¬†
    
    Outer.Inner();
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAeRFApgJwBQEpEDeAUIolABYwDOAdAJ6IC8iATANxEC+RRqGmNAJJgwWJolCRYCRHkIkylWnQbN2XDrzRYhIrHjZA)

It can also be used to create simple namespaces:

    
    
    js
    
    var ns = {};
    
    ns.C = class {};
    
    ns.func = function () {};
    
    ¬†
    
    ns;
    
    [Try](https://www.typescriptlang.org/play/#code/G4QwTgBAdgzhC8EDeBfA3AKFgOgMIIgGMAbEGOVTHAMwFcpCC6GAXASwHsoIAKASmToMWGGiA)

Other variants are allowed as well:

    
    
    js
    
    // IIFE
    
    var ns = (function (n) {
    
      return n || {};
    
    })();
    
    ns.CONST = 1;
    
    ¬†
    
    // defaulting to global
    
    var assign =
    
      assign ||
    
      function () {
    
        // code goes here
    
      };
    
    assign.extra = 1;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEElwMQUQKAG4EMBOoB2BnUBeUAKAMwFd0BjAFwEsB7dA9ASlAG85RQUBTC4le+gB9BrAL4BuOKMb5GkrADoAwgHkAcgGUAKrlABGSXBCgAJl0JJiAG2roA5qAo1QdqzQBGSK4lSgkmTCo7ehx2PwCgoUEwknJqOgJmNg4OYzIaMxcaLmwACy5uMIk4f0DghS4ADwoUJF0DIA)

## Object literals are open-ended

In a `.ts` file, an object literal that initializes a variable declaration
gives its type to the declaration. No new members can be added that were not
specified in the original literal. This rule is relaxed in a `.js` file;
object literals have an open-ended type (an index signature) that allows
adding and looking up properties that were not defined originally. For
instance:

    
    
    js
    
    var obj = { a: 1 };
    
    obj.b = 2; // Allowed
    
    [Try](https://www.typescriptlang.org/play/#code/G4QwTgBA9gRgVhAvBA3hEAuCBGCBfAbgChY4A6GJCAJgIgHp6IBBAG1agHcBTAEyA)

Object literals behave as if they have an index signature `[x:string]: any`
that allows them to be treated as open maps instead of closed objects.

Like other special JS checking behaviors, this behavior can be changed by
specifying a JSDoc type for the variable. For example:

    
    
    js
    
    /** @type {{a: number}} */
    
    var obj = { a: 1 };
    
    obj.b = 2;
    
    Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZyBODAKlogBcBPAB1lAG9OBDEgOwCuAWwBGOAL4TQtYGgBuPbKDyiAVqAC8XUH1ABGUBIDcaVWoB0orWWNA)

## null, undefined, and empty array initializers are of type any or any[]

Any variable, parameter or property that is initialized with null or undefined
will have type any, even if strict null checks is turned on. Any variable,
parameter or property that is initialized with [] will have type any[], even
if strict null checks is turned on. The only exception is for properties that
have multiple initializers as described above.

    
    
    js
    
    function Foo(i = null) {
    
      if (!i) i = 1;
    
      var j = undefined;
    
      j = 2;
    
      this.l = [];
    
    }
    
    ¬†
    
    var foo = new Foo();
    
    foo.l.push(foo.i);
    
    foo.l.push("end");
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAMTnAFDRBeRYQA2BAlIgN4BQiiMwi6AhDKVrgIwDcViAbgIYAnRACscicABMApsBhgpErtVG4ATEsRQAFjADOAOgJiA2gF0uAXwoV+Q4GjHyA7ijTpiXe3EP6ADiF0tdC99Zk80H39A9AAiKTAJGI8gA)

## Function parameters are optional by default

Since there is no way to specify optionality on parameters in pre-ES2015
JavaScript, all function parameters in `.js` file are considered optional.
Calls with fewer arguments than the declared number of parameters are allowed.

It is important to note that it is an error to call a function with too many
arguments.

For instance:

    
    
    js
    
    function bar(a, b) {
    
      console.log(a + " " + b);
    
    }
    
    ¬†
    
    bar(1); // OK, second argument considered optional
    
    bar(1, 2);
    
    bar(1, 2, 3); // Error, too many arguments
    
    Expected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEEUBcBOBLSbALlADMBDAGxVgzHFl1wHtcVSB2ABm4DZQPfqABMAVjEAWNGQCuAOyL4W80ACMKuABQUANOoCUoAN5pQoSCpQsqsAHRUWAcx2gA1KABEX94YDcaAC+aGga2gCMBn6gmADyANL6tJbyACagmk6yALaw8tgWVvipTLDpLAAO2Mry1KGaWuH6IlH1Ec36AMxRMWAAosxs+tgsLKDZFPIAnhm4Wbn5KEA)

JSDoc annotated functions are excluded from this rule. Use JSDoc optional
parameter syntax (`[` `]`) to express optionality. e.g.:

    
    
    js
    
    /**
    
     * @param {string} [somebody] - Somebody's name.
    
     */
    
    function sayHello(somebody) {
    
      if (!somebody) {
    
        somebody = "John Doe";
    
      }
    
      console.log("Hello " + somebody);
    
    }
    
    ¬†
    
    sayHello();
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwM4BdkCWAdgOYC+kA2tgPZoCmARjQCYCeAupALSQDKdJqzYBybJCLp6AOighg4AGYBXIgGNcBGkUjZEbABL0ANsZoAKWg2bsAlFiiQCiyOYCEVoXYeRfuwTZskAC8kABEAFI0ABY6ACI09GEA3I5kjmratMYyZiTmYUamNOGQANT+1sK2qengeoYmZuY1QA)

## Var-args parameter declaration inferred from use of `arguments`

A function whose body has a reference to the `arguments` reference is
implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) =>
any`). Use JSDoc var-arg syntax to specify the type of the arguments.

    
    
    js
    
    /** @param {...number} args */
    
    function sum(/* numbers */) {
    
      var total = 0;
    
      for (var i = 0; i < arguments.length; i++) {
    
        total += arguments[i];
    
      }
    
      return total;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEAcEMCdYFtwG8B0mB2BXJAjAU3gF9wEBzAZ3BGACgAzHLAYwBcBLAey3CrwAKUOFwFiNOgEo09cOABuCcO27tYAG3ABecAAYA3HPCNu8cIKXnOO-QfA2APOXgU8hLOyroNHiuwALe04AahCZVGN5VXUtEN1Kd08qAG1OAF0jeRJjeEJ2HHg+GM0jEiA)

## Unspecified type parameters default to `any`

Since there is no natural syntax for specifying generic type parameters in
JavaScript, an unspecified type parameter defaults to `any`.

### In extends clause

For instance, `React.Component` is defined to have two type parameters,
`Props` and `State`. In a `.js` file, there is no legal way to specify these
in the extends clause. By default the type arguments will be `any`:

    
    
    js
    
    import { Component } from "react";
    
    class MyComponent extends Component {
    
      render() {
    
        this.props.b; // Allowed, since this.props is of type any
    
      }
    
    }

Use JSDoc `@augments` to specify the types explicitly. for instance:

    
    
    js
    
    import { Component } from "react";
    
    /**
    
     * @augments {Component<{a: number}, State>}
    
     */
    
    class MyComponent extends Component {
    
      render() {
    
        this.props.b; // Error: b does not exist on {a:number}
    
      }
    
    }

### In JSDoc references

An unspecified type argument in JSDoc defaults to any:

    
    
    js
    
    /** @type{Array} */
    
    var x = [];
    
    ¬†
    
    x.push(1); // OK
    
    x.push("string"); // OK, x is of type Array<any>
    
    ¬†
    
    /** @type{Array.<number>} */
    
    var y = [];
    
    ¬†
    
    y.push(1); // OK
    
    y.push("string"); // Error, string is not assignable to number
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCmBvAggJ3QQ1gX3CMAFABuW64AHuALzgDaAugNxFGUB08ArgM4AWACgCMASmbhgwcAHkA0uy58hAIl7R0ASwB2AcxXjJ0+QBoq4Tb3AB7AGbg4ScBmywAPFm2wAfG1AQYBBQXHA43bW4AWwAjRHRvfEJScnBYWgYWNlglARFDKVkFbJ5ctQ0dfXzpAFFMa3QzdS09Cytta2hwLF5eTV1tLGiAG0QHa3AImLigA)

### In function calls

A call to a generic function uses the arguments to infer the type parameters.
Sometimes this process fails to infer any types, mainly because of lack of
inference sources; in these cases, the type parameters will default to `any`.
For example:

    
    
    js
    
    var p = new Promise((resolve, reject) => {
    
      reject();
    
    });
    
    p; // Promise<any>;

To learn all of the features available in JSDoc, see [the
reference](/docs/handbook/jsdoc-supported-types.html).

### [JS Projects Utilizing TypeScriptHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/intro-to-js-ts.html)

### [JSDoc ReferenceWhat JSDoc does TypeScript-powered JavaScript
support?](/docs/handbook/jsdoc-supported-types.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Type Checking
JavaScript Files.md) ‚ù§

Contributors to this page:  

HN![Harry Nguyen
\(51\)](https://gravatar.com/avatar/386e27141a29f5c1076619afc140ffb4?s=32&&d=blank)

OT![Orta Therox
\(17\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

RC![Ryan Cavanaugh
\(3\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

NS![Nathan Shively-Sanders
\(2\)](https://gravatar.com/avatar/8c5596e6ef2b41132cee585c9b146116?s=32&&d=blank)

MH![Mohamed Hegazy
\(2\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

15+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Type Compatibility

Type compatibility in TypeScript is based on structural subtyping. Structural
typing is a way of relating types based solely on their members. This is in
contrast with nominal typing. Consider the following code:

    
    
    ts
    
    interface Pet {
    
      name: string;
    
    }
    
    class Dog {
    
      name: string;
    
    }
    
    let pet: Pet;
    
    // OK, because of structural typing
    
    pet = new Dog();

In nominally-typed languages like C# or Java, the equivalent code would be an
error because the `Dog` class does not explicitly describe itself as being an
implementer of the `Pet` interface.

TypeScript‚Äôs structural type system was designed based on how JavaScript code
is typically written. Because JavaScript widely uses anonymous objects like
function expressions and object literals, it‚Äôs much more natural to represent
the kinds of relationships found in JavaScript libraries with a structural
type system instead of a nominal one.

## A Note on Soundness

TypeScript‚Äôs type system allows certain operations that can‚Äôt be known at
compile-time to be safe. When a type system has this property, it is said to
not be ‚Äúsound‚Äù. The places where TypeScript allows unsound behavior were
carefully considered, and throughout this document we‚Äôll explain where these
happen and the motivating scenarios behind them.

## Starting out

The basic rule for TypeScript‚Äôs structural type system is that `x` is
compatible with `y` if `y` has at least the same members as `x`. For example
consider the following code involving an interface named `Pet` which has a
`name` property:

    
    
    ts
    
    interface Pet {
    
      name: string;
    
    }
    
    let pet: Pet;
    
    // dog's inferred type is { name: string; owner: string; }
    
    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
    
    pet = dog;

To check whether `dog` can be assigned to `pet`, the compiler checks each
property of `pet` to find a corresponding compatible property in `dog`. In
this case, `dog` must have a member called `name` that is a string. It does,
so the assignment is allowed.

The same rule for assignment is used when checking function call arguments:

    
    
    ts
    
    interface Pet {
    
      name: string;
    
    }
    
    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
    
    function greet(pet: Pet) {
    
      console.log("Hello, " + pet.name);
    
    }
    
    greet(dog); // OK

Note that `dog` has an extra `owner` property, but this does not create an
error. Only members of the target type (`Pet` in this case) are considered
when checking for compatibility. This comparison process proceeds recursively,
exploring the type of each member and sub-member.

Be aware, however, that object literals [may only specify known
properties](/docs/handbook/2/objects.html#excess-property-checks). For
example, because we have explicitly specified that `dog` is of type `Pet`, the
following code is invalid:

    
    
    ts
    
    let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" }; // Error

## Comparing two functions

While comparing primitive types and object types is relatively
straightforward, the question of what kinds of functions should be considered
compatible is a bit more involved. Let‚Äôs start with a basic example of two
functions that differ only in their parameter lists:

    
    
    ts
    
    let x = (a: number) => 0;
    
    let y = (b: number, s: string) => 0;
    
    y = x; // OK
    
    x = y; // Error

To check if `x` is assignable to `y`, we first look at the parameter list.
Each parameter in `x` must have a corresponding parameter in `y` with a
compatible type. Note that the names of the parameters are not considered,
only their types. In this case, every parameter of `x` has a corresponding
compatible parameter in `y`, so the assignment is allowed.

The second assignment is an error, because `y` has a required second parameter
that `x` does not have, so the assignment is disallowed.

You may be wondering why we allow ‚Äòdiscarding‚Äô parameters like in the example
`y = x`. The reason for this assignment to be allowed is that ignoring extra
function parameters is actually quite common in JavaScript. For example,
`Array#forEach` provides three parameters to the callback function: the array
element, its index, and the containing array. Nevertheless, it‚Äôs very useful
to provide a callback that only uses the first parameter:

    
    
    ts
    
    let items = [1, 2, 3];
    
    // Don't force these extra parameters
    
    items.forEach((item, index, array) => console.log(item));
    
    // Should be OK!
    
    items.forEach((item) => console.log(item));

Now let‚Äôs look at how return types are treated, using two functions that
differ only by their return type:

    
    
    ts
    
    let x = () => ({ name: "Alice" });
    
    let y = () => ({ name: "Alice", location: "Seattle" });
    
    x = y; // OK
    
    y = x; // Error, because x() lacks a location property

The type system enforces that the source function‚Äôs return type be a subtype
of the target type‚Äôs return type.

### Function Parameter Bivariance

When comparing the types of function parameters, assignment succeeds if either
the source parameter is assignable to the target parameter, or vice versa.
This is unsound because a caller might end up being given a function that
takes a more specialized type, but invokes the function with a less
specialized type. In practice, this sort of error is rare, and allowing this
enables many common JavaScript patterns. A brief example:

    
    
    ts
    
    enum EventType {
    
      Mouse,
    
      Keyboard,
    
    }
    
    interface Event {
    
      timestamp: number;
    
    }
    
    interface MyMouseEvent extends Event {
    
      x: number;
    
      y: number;
    
    }
    
    interface MyKeyEvent extends Event {
    
      keyCode: number;
    
    }
    
    function listenEvent(eventType: EventType, handler: (n: Event) => void) {
    
      /* ... */
    
    }
    
    // Unsound, but useful and common
    
    listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y));
    
    // Undesirable alternatives in presence of soundness
    
    listenEvent(EventType.Mouse, (e: Event) =>
    
      console.log((e as MyMouseEvent).x + "," + (e as MyMouseEvent).y)
    
    );
    
    listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>
    
      console.log(e.x + "," + e.y)) as (e: Event) => void);
    
    // Still disallowed (clear error). Type safety enforced for wholly incompatible types
    
    listenEvent(EventType.Mouse, (e: number) => console.log(e));

You can have TypeScript raise errors when this happens via the compiler flag
[`strictFunctionTypes`](/tsconfig#strictFunctionTypes).

### Optional Parameters and Rest Parameters

When comparing functions for compatibility, optional and required parameters
are interchangeable. Extra optional parameters of the source type are not an
error, and optional parameters of the target type without corresponding
parameters in the source type are not an error.

When a function has a rest parameter, it is treated as if it were an infinite
series of optional parameters.

This is unsound from a type system perspective, but from a runtime point of
view the idea of an optional parameter is generally not well-enforced since
passing `undefined` in that position is equivalent for most functions.

The motivating example is the common pattern of a function that takes a
callback and invokes it with some predictable (to the programmer) but unknown
(to the type system) number of arguments:

    
    
    ts
    
    function invokeLater(args: any[], callback: (...args: any[]) => void) {
    
      /* ... Invoke callback with 'args' ... */
    
    }
    
    // Unsound - invokeLater "might" provide any number of arguments
    
    invokeLater([1, 2], (x, y) => console.log(x + ", " + y));
    
    // Confusing (x and y are actually required) and undiscoverable
    
    invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y));

### Functions with overloads

When a function has overloads, each overload in the target type must be
matched by a compatible signature on the source type. This ensures that the
source function can be called in all the same cases as the target function.

## Enums

Enums are compatible with numbers, and numbers are compatible with enums. Enum
values from different enum types are considered incompatible. For example,

    
    
    ts
    
    enum Status {
    
      Ready,
    
      Waiting,
    
    }
    
    enum Color {
    
      Red,
    
      Blue,
    
      Green,
    
    }
    
    let status = Status.Ready;
    
    status = Color.Green; // Error

## Classes

Classes work similarly to object literal types and interfaces with one
exception: they have both a static and an instance type. When comparing two
objects of a class type, only members of the instance are compared. Static
members and constructors do not affect compatibility.

    
    
    ts
    
    class Animal {
    
      feet: number;
    
      constructor(name: string, numFeet: number) {}
    
    }
    
    class Size {
    
      feet: number;
    
      constructor(numFeet: number) {}
    
    }
    
    let a: Animal;
    
    let s: Size;
    
    a = s; // OK
    
    s = a; // OK

### Private and protected members in classes

Private and protected members in a class affect their compatibility. When an
instance of a class is checked for compatibility, if the target type contains
a private member, then the source type must also contain a private member that
originated from the same class. Likewise, the same applies for an instance
with a protected member. This allows a class to be assignment compatible with
its super class, but _not_ with classes from a different inheritance hierarchy
which otherwise have the same shape.

## Generics

Because TypeScript is a structural type system, type parameters only affect
the resulting type when consumed as part of the type of a member. For example,

    
    
    ts
    
    interface Empty<T> {}
    
    let x: Empty<number>;
    
    let y: Empty<string>;
    
    x = y; // OK, because y matches structure of x

In the above, `x` and `y` are compatible because their structures do not use
the type argument in a differentiating way. Changing this example by adding a
member to `Empty<T>` shows how this works:

    
    
    ts
    
    interface NotEmpty<T> {
    
      data: T;
    
    }
    
    let x: NotEmpty<number>;
    
    let y: NotEmpty<string>;
    
    x = y; // Error, because x and y are not compatible

In this way, a generic type that has its type arguments specified acts just
like a non-generic type.

For generic types that do not have their type arguments specified,
compatibility is checked by specifying `any` in place of all unspecified type
arguments. The resulting types are then checked for compatibility, just as in
the non-generic case.

For example,

    
    
    ts
    
    let identity = function <T>(x: T): T {
    
      // ...
    
    };
    
    let reverse = function <U>(y: U): U {
    
      // ...
    
    };
    
    identity = reverse; // OK, because (x: any) => any matches (y: any) => any

## Advanced Topics

### Subtype vs Assignment

So far, we‚Äôve used ‚Äúcompatible‚Äù, which is not a term defined in the language
spec. In TypeScript, there are two kinds of compatibility: subtype and
assignment. These differ only in that assignment extends subtype compatibility
with rules to allow assignment to and from `any`, and to and from `enum` with
corresponding numeric values.

Different places in the language use one of the two compatibility mechanisms,
depending on the situation. For practical purposes, type compatibility is
dictated by assignment compatibility, even in the cases of the `implements`
and `extends` clauses.

## `any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never`
assignability

The following table summarizes assignability between some abstract types. Rows
indicate what each is assignable to, columns indicate what is assignable to
them. A ‚Äù‚úì‚Äù indicates a combination that is compatible only when
[`strictNullChecks`](/tsconfig#strictNullChecks) is off.

| any | unknown | object | void | undefined | null | never  
---|---|---|---|---|---|---|---  
any ‚Üí |  | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì | ‚úï  
unknown ‚Üí | ‚úì |  | ‚úï | ‚úï | ‚úï | ‚úï | ‚úï  
object ‚Üí | ‚úì | ‚úì |  | ‚úï | ‚úï | ‚úï | ‚úï  
void ‚Üí | ‚úì | ‚úì | ‚úï |  | ‚úï | ‚úï | ‚úï  
undefined ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì |  | ‚úì | ‚úï  
null ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì |  | ‚úï  
never ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì |   
  
Reiterating [The Basics](/docs/handbook/2/basic-types.html):

  * Everything is assignable to itself.
  * `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.
  * `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).
  * `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](/tsconfig#strictNullChecks) is off, see table for details).
  * When [`strictNullChecks`](/tsconfig#strictNullChecks) is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.
  * When [`strictNullChecks`](/tsconfig#strictNullChecks) is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Type
Compatibility.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(51\)](https://gravatar.com/avatar/b9d274ea3df40f132936da582f71b18f?s=32&&d=blank)

DR![Daniel Rosenwasser
\(19\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

OT![Orta Therox
\(18\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

MH![Mohamed Hegazy
\(4\)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)

JB![Jack Bates
\(3\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

26+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Type Inference

In TypeScript, there are several places where type inference is used to
provide type information when there is no explicit type annotation. For
example, in this code

    
    
    ts
    
    let x = 3;
    
       
    
    let x: number
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA)

The type of the `x` variable is inferred to be `number`. This kind of
inference takes place when initializing variables and members, setting
parameter default values, and determining function return types.

In most cases, type inference is straightforward. In the following sections,
we‚Äôll explore some of the nuances in how types are inferred.

## Best common type

When a type inference is made from several expressions, the types of those
expressions are used to calculate a ‚Äúbest common type‚Äù. For example,

    
    
    ts
    
    let x = [0, 1, null];
    
       
    
    let x: (number | null)[]
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA)

To infer the type of `x` in the example above, we must consider the type of
each array element. Here we are given two choices for the type of the array:
`number` and `null`. The best common type algorithm considers each candidate
type, and picks the type that is compatible with all the other candidates.

Because the best common type has to be chosen from the provided candidate
types, there are some cases where types share a common structure, but no one
type is the super type of all candidate types. For example:

    
    
    ts
    
    let zoo = [new Rhino(), new Elephant(), new Snake()];
    
        
    
    let zoo: (Rhino | Elephant | Snake)[]
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35BAF5QAG0qPAB3Ll4BAAoASgAaUE6e8ysbaCHR8cjo2KGAXQNixVAAPQB+IA)

Ideally, we may want `zoo` to be inferred as an `Animal[]`, but because there
is no object that is strictly of type `Animal` in the array, we make no
inference about the array element type. To correct this, explicitly provide
the type when no one type is a super type of all other candidates:

    
    
    ts
    
    let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
    
        
    
    let zoo: Animal[]
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35+NBlXAG0AXVAAXlA2qjwAdy5eAQAKAEoAGlAB4fMrG2hJmbnI6NjJjoNixVAAPQB+IA)

When no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.

## Contextual Typing

Type inference also works in ‚Äúthe other direction‚Äù in some cases in
TypeScript. This is known as ‚Äúcontextual typing‚Äù. Contextual typing occurs
when the type of an expression is implied by its location. For example:

    
    
    ts
    
    window.onmousedown = function (mouseEvent) {
    
      console.log(mouseEvent.button);
    
      console.log(mouseEvent.kangaroo);
    
    Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmIFs4BXRSc-Y0AXlADMHiBjAC6EaoABT0mkAKIA3SMUEBKUAG9coUPxqI4AG0iU9cAOYTGzOQsGUARg0GCaSgNwatO-YeNnJl+YqUANYAhsQmIfBwrrgAvi5AA)

Here, the TypeScript type checker used the type of the `Window.onmousedown`
function to infer the type of the function expression on the right hand side
of the assignment. When it did so, it was able to infer the
[type](https://developer.mozilla.org/docs/Web/API/MouseEvent) of the
`mouseEvent` parameter, which does contain a `button` property, but not a
`kangaroo` property.

This works because window already has `onmousedown` declared in its type:

    
    
    ts
    
    // Declares there is a global variable called 'window'
    
    declare var window: Window & typeof globalThis;
    
    // Which is declared as (simplified):
    
    interface Window extends GlobalEventHandlers {
    
      // ...
    
    }
    
    // Which defines a lot of known handler events
    
    interface GlobalEventHandlers {
    
      onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;
    
      // ...
    
    }

TypeScript is smart enough to infer types in other contexts as well:

    
    
    ts
    
    window.onscroll = function (uiEvent) {
    
      console.log(uiEvent.button);
    
    Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmMQGN4AbR0AXlADMBXYugF0I1QACi6EAogDdIxPgEpQAb1yhQdGojiNIlRnADmoidNmUARlz58acgNy4AvraA)

Based on the fact that the above function is being assigned to
`Window.onscroll`, TypeScript knows that `uiEvent` is a
[UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent), and not a
[MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent) like the
previous example. `UIEvent` objects contain no `button` property, and so
TypeScript will throw an error.

If this function were not in a contextually typed position, the function‚Äôs
argument would implicitly have type `any`, and no error would be issued
(unless you are using the [`noImplicitAny`](/tsconfig#noImplicitAny) option):

    
    
    ts
    
    const handler = function (uiEvent) {
    
      console.log(uiEvent.button); // <- OK
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFDrSSVagAWZkAJstQE6gBeUgFdI6LKkagAFMNQBRAG7VIWAJSgA3rVCgGTaDwB0yaAHNZC5aqMAjYViyM1AblAhQAHgC0oAPIA0rQAvi5AA)

We can also explicitly give type information to the function‚Äôs argument to
override any contextual type:

    
    
    ts
    
    window.onscroll = function (uiEvent: any) {
    
      console.log(uiEvent.button); // <- Now, no error is given
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/O4SwdgJg9sB0VgM4GMBOUA2GAEBebAZgK5jIAuIC2AFESAKIBuApmGQFzYCGYAngJTYA3gChs2ZAkSZmsDFADmtBizawARkTJkE-ANzYA9IewAeALTYAcjAA02MFGzNU6VNhCJsCkKpEBfPSA)

However, this code will log `undefined`, since `uiEvent` has no property
called `button`.

Contextual typing applies in many cases. Common cases include arguments to
function calls, right hand sides of assignments, type assertions, members of
object and array literals, and return statements. The contextual type also
acts as a candidate type in best common type. For example:

    
    
    ts
    
    function createZoo(): Animal[] {
    
      return [new Rhino(), new Elephant(), new Snake()];
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCdD9keH4qUERYPEwxAC1+fgAKAEo0GVcAbQBdd0U26G0NUBGqPAB3Ll4BAYAaUEWV8ysbaE3t5cjo2IGxg2YgA)

In this example, best common type has a set of four candidates: `Animal`,
`Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best
common type algorithm.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Type Inference.md) ‚ù§

Contributors to this page:  

RC![Ryan Cavanaugh
\(51\)](https://gravatar.com/avatar/b9d274ea3df40f132936da582f71b18f?s=32&&d=blank)

OT![Orta Therox
\(17\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DR![Daniel Rosenwasser
\(10\)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)

MH![Martin Hanzel
\(2\)](https://gravatar.com/avatar/306526665628a202cb974484101d3bcf?s=32&&d=blank)

TLAT![Think Like a Techy
\(1\)](https://gravatar.com/avatar/49e12316a213c5f53717150bc1cca82d?s=32&&d=blank)

12+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript for the New Programmer

Congratulations on choosing TypeScript as one of your first languages ‚Äî you‚Äôre
already making good decisions!

You‚Äôve probably already heard that TypeScript is a ‚Äúflavor‚Äù or ‚Äúvariant‚Äù of
JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is
rather unique among modern programming languages, so learning more about this
relationship will help you understand how TypeScript adds to JavaScript.

## What is JavaScript? A Brief History

JavaScript (also known as ECMAScript) started its life as a simple scripting
language for browsers. At the time it was invented, it was expected to be used
for short snippets of code embedded in a web page ‚Äî writing more than a few
dozen lines of code would have been somewhat unusual. Due to this, early web
browsers executed such code pretty slowly. Over time, though, JS became more
and more popular, and web developers started using it to create interactive
experiences.

Web browser developers responded to this increased JS usage by optimizing
their execution engines (dynamic compilation) and extending what could be done
with it (adding APIs), which in turn made web developers use it even more. On
modern websites, your browser is frequently running applications that span
hundreds of thousands of lines of code. This is the long and gradual growth of
‚Äúthe web‚Äù, starting as a simple network of static pages, and evolving into a
platform for rich _applications_ of all kinds.

More than this, JS has become popular enough to be used outside the context of
browsers, such as implementing JS servers using node.js. The ‚Äúrun anywhere‚Äù
nature of JS makes it an attractive choice for cross-platform development.
There are many developers these days that use _only_ JavaScript to program
their entire stack!

To summarize, we have a language that was designed for quick uses, and then
grew to a full-fledged tool to write applications with millions of lines.
Every language has its own _quirks_ ‚Äî oddities and surprises, and JavaScript‚Äôs
humble beginning makes it have _many_ of these. Some examples:

  * JavaScript‚Äôs equality operator (`==`) _coerces_ its operands, leading to unexpected behavior:
    
        js
    
    if ("" == 0) {
    
      // It is! But why??
    
    }
    
    if (1 < x < 3) {
    
      // True for *any* value of x!
    
    }

  * JavaScript also allows accessing properties which aren‚Äôt present:
    
        js
    
    const obj = { width: 10, height: 15 };
    
    // Why is this NaN? Spelling is hard!
    
    const area = obj.width * obj.heigth;

Most programming languages would throw an error when these sorts of errors
occur, some would do so during compilation ‚Äî before any code is running. When
writing small programs, such quirks are annoying but manageable; when writing
applications with hundreds or thousands of lines of code, these constant
surprises are a serious problem.

## TypeScript: A Static Type Checker

We said earlier that some languages wouldn‚Äôt allow those buggy programs to run
at all. Detecting errors in code without running it is referred to as _static
checking_. Determining what‚Äôs an error and what‚Äôs not based on the kinds of
values being operated on is known as static _type_ checking.

TypeScript checks a program for errors before execution, and does so based on
the _kinds of values_ , making it a _static type checker_. For example, the
last example above has an error because of the _type_ of `obj`. Here‚Äôs the
error TypeScript found:

    
    
    ts
    
    const obj = { width: 10, height: 15 };
    
    const area = obj.width * obj.heigth;
    
    Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBjOAO0QBdQ4AjAK1AF5QBvUAdwEsATUgC1WwAYANKG6Q2Ac26k+GUAF8A3AWJlQAQ2iQ19CjQB07Lt1AAqXdT2iJPBUA)

### A Typed Superset of JavaScript

How does TypeScript relate to JavaScript, though?

#### Syntax

TypeScript is a language that is a _superset_ of JavaScript: JS syntax is
therefore legal TS. Syntax refers to the way we write text to form a program.
For example, this code has a _syntax_ error because it‚Äôs missing a `)`:

    
    
    ts
    
    let a = (4
    
    ')' expected.1005')' expected.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQAbSAF1AENQBeUACgBYg)

TypeScript doesn‚Äôt consider any JavaScript code to be an error because of its
syntax. This means you can take any working JavaScript code and put it in a
TypeScript file without worrying about exactly how it is written.

#### Types

However, TypeScript is a _typed_ superset, meaning that it adds rules about
how different kinds of values can be used. The earlier error about
`obj.heigth` was not a _syntax_ error: it is an error of using some kind of
value (a _type_) in an incorrect way.

As another example, this is JavaScript code that you can run in your browser,
and it _will_ log a value:

    
    
    js
    
    console.log(4 / []);

This syntactically-legal program logs `Infinity`. TypeScript, though,
considers division of number by an array to be a nonsensical operation, and
will issue an error:

    
    
    ts
    
    console.log(4 / []);
    
    The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsGBQBjOAO0TgBtIA6MuAcwAoAWUMAbQF0BKAbiA)

It‚Äôs possible you really _did_ intend to divide a number by an array, perhaps
just to see what happens, but most of the time, though, this is a programming
mistake. TypeScript‚Äôs type checker is designed to allow correct programs
through while still catching as many common errors as possible. (Later, we‚Äôll
learn about settings you can use to configure how strictly TypeScript checks
your code.)

If you move some code from a JavaScript file to a TypeScript file, you might
see _type errors_ depending on how the code is written. These may be
legitimate problems with the code, or TypeScript being overly conservative.
Throughout this guide we‚Äôll demonstrate how to add various TypeScript syntax
to eliminate such errors.

#### Runtime Behavior

TypeScript is also a programming language that preserves the _runtime
behavior_ of JavaScript. For example, dividing by zero in JavaScript produces
`Infinity` instead of throwing a runtime exception. As a principle, TypeScript
**never** changes the runtime behavior of JavaScript code.

This means that if you move code from JavaScript to TypeScript, it is
**guaranteed** to run the same way, even if TypeScript thinks that the code
has type errors.

Keeping the same runtime behavior as JavaScript is a foundational promise of
TypeScript because it means you can easily transition between the two
languages without worrying about subtle differences that might make your
program stop working.

#### Erased Types

Roughly speaking, once TypeScript‚Äôs compiler is done with checking your code,
it _erases_ the types to produce the resulting ‚Äúcompiled‚Äù code. This means
that once your code is compiled, the resulting plain JS code has no type
information.

This also means that TypeScript never changes the _behavior_ of your program
based on the types it inferred. The bottom line is that while you might see
type errors during compilation, the type system itself has no bearing on how
your program works when it runs.

Finally, TypeScript doesn‚Äôt provide any additional runtime libraries. Your
programs will use the same standard library (or external libraries) as
JavaScript programs, so there‚Äôs no additional TypeScript-specific framework to
learn.

## Learning JavaScript and TypeScript

We frequently see the question ‚ÄúShould I learn JavaScript or TypeScript?‚Äú.

The answer is that you can‚Äôt learn TypeScript without learning JavaScript!
TypeScript shares syntax and runtime behavior with JavaScript, so anything you
learn about JavaScript is helping you learn TypeScript at the same time.

There are many, many resources available for programmers to learn JavaScript;
you should _not_ ignore these resources if you‚Äôre writing TypeScript. For
example, there are about 20 times more StackOverflow questions tagged
`javascript` than `typescript`, but _all_ of the `javascript` questions also
apply to TypeScript.

If you find yourself searching for something like ‚Äúhow to sort a list in
TypeScript‚Äù, remember: **TypeScript is JavaScript‚Äôs runtime with a compile-
time type checker**. The way you sort a list in TypeScript is the same way you
do so in JavaScript. If you find a resource that uses TypeScript directly,
that‚Äôs great too, but don‚Äôt limit yourself to thinking you need TypeScript-
specific answers for everyday questions about how to accomplish runtime tasks.

## Next Steps

This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:

  * Learn some of the JavaScript fundamentals, we recommend either:

    * [Microsoft‚Äôs JavaScript Resources](https://developer.microsoft.com/javascript/) or
    * [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)
  * Continue to [TypeScript for JavaScript Programmers](/docs/handbook/typescript-in-5-minutes.html)

  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)

  * Explore the [Playground examples](/play#show-examples)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for the New
Programmer.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(19\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

EB![Eli Barzilay
\(2\)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)

XL![Xavi Lee
\(1\)](https://gravatar.com/avatar/43234add53f35134fc6fd80849a721e5?s=32&&d=blank)

NS![Nick Schonning
\(1\)](https://gravatar.com/avatar/629fa905b76d5e22210586cec7a98825?s=32&&d=blank)

AO![Alex Ownejazayeri
\(1\)](https://gravatar.com/avatar/14a3f1d49716f8ccec49c3a7c5d3a12f?s=32&&d=blank)

8+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript for Functional Programmers

TypeScript began its life as an attempt to bring traditional object-oriented
types to JavaScript so that the programmers at Microsoft could bring
traditional object-oriented programs to the web. As it has developed,
TypeScript‚Äôs type system has evolved to model code written by native
JavaScripters. The resulting system is powerful, interesting and messy.

This introduction is designed for working Haskell or ML programmers who want
to learn TypeScript. It describes how the type system of TypeScript differs
from Haskell‚Äôs type system. It also describes unique features of TypeScript‚Äôs
type system that arise from its modelling of JavaScript code.

This introduction does not cover object-oriented programming. In practice,
object-oriented programs in TypeScript are similar to those in other popular
languages with OO features.

## Prerequisites

In this introduction, I assume you know the following:

  * How to program in JavaScript, the good parts.
  * Type syntax of a C-descended language.

If you need to learn the good parts of JavaScript, read [JavaScript: The Good
Parts](https://shop.oreilly.com/product/9780596517748.do). You may be able to
skip the book if you know how to write programs in a call-by-value lexically
scoped language with lots of mutability and not much else. [R4RS
Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf) is a good example.

[The C++ Programming Language](http://www.stroustrup.com/4th.html) is a good
place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix
types, like so: `x: string` instead of `string x`.

## Concepts not in Haskell

### Built-in types

JavaScript defines 8 built-in types:

Type | Explanation  
---|---  
`Number` | a double-precision IEEE 754 floating point.  
`String` | an immutable UTF-16 string.  
`BigInt` | integers in the arbitrary precision format.  
`Boolean` | `true` and `false`.  
`Symbol` | a unique value usually used as a key.  
`Null` | equivalent to the unit type.  
`Undefined` | also equivalent to the unit type.  
`Object` | similar to records.  
  
[See the MDN page for more
detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures).

TypeScript has corresponding primitive types for the built-in types:

  * `number`
  * `string`
  * `bigint`
  * `boolean`
  * `symbol`
  * `null`
  * `undefined`
  * `object`

#### Other important TypeScript types

Type | Explanation  
---|---  
`unknown` | the top type.  
`never` | the bottom type.  
object literal | e.g. `{ property: Type }`  
`void` | for functions with no documented return value  
`T[]` | mutable arrays, also written `Array<T>`  
`[T, T]` | tuples, which are fixed-length but mutable  
`(t: T) => U` | functions  
  
Notes:

  1. Function syntax includes parameter names. This is pretty hard to get used to!
    
        ts
    
    let fst: (a: any, b: any) => any = (a, b) => a;
    
    // or more precisely:
    
    let fst: <T, U>(a: T, b: U) => T = (a, b) => a;

  2. Object literal type syntax closely mirrors object literal value syntax:
    
        ts
    
    let o: { n: number; xs: object[] } = { n: 1, xs: [] };

  3. `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.

#### Boxed types

JavaScript has boxed equivalents of primitive types that contain the methods
that programmers associate with those types. TypeScript reflects this with,
for example, the difference between the primitive type `number` and the boxed
type `Number`. The boxed types are rarely needed, since their methods return
primitives.

    
    
    ts
    
    (1).toExponential();
    
    // equivalent to
    
    Number.prototype.toExponential.call(1);

Note that calling a method on a numeric literal requires it to be in
parentheses to aid the parser.

### Gradual typing

TypeScript uses the type `any` whenever it can‚Äôt tell what the type of an
expression should be. Compared to `Dynamic`, calling `any` a type is an
overstatement. It just turns off the type checker wherever it appears. For
example, you can push any value into an `any[]` without marking the value in
any way:

    
    
    ts
    
    // with "noImplicitAny": false in tsconfig.json, anys: any[]
    
    const anys = [];
    
    anys.push(1);
    
    anys.push("oh no");
    
    anys.push({ anything: "goes" });
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEHcEsBcAtQEQDsD2BJAtgBwDaQMYwCCSAnggFygBmAhjgM4CmokSo0D+KS1kA5gDoAVgx4AaULTIMq00gG0AugChuSBtCkzQAXlDKA3CvkNBWAK4NYACgCMASmOnzV2whTxUCJyZmvrGwBvbVI4Nn4qBH4UJgYEUABfJyA)

And you can use an expression of type `any` anywhere:

    
    
    ts
    
    anys.map(anys[1]); // oh no, "oh no" is not a function

`any` is contagious, too ‚Äî if you initialize a variable with an expression of
type `any`, the variable has type `any` too.

    
    
    ts
    
    let sepsis = anys[0] + anys[1]; // this could mean anything

To get an error when TypeScript produces an `any`, use `"noImplicitAny":
true`, or `"strict": true` in `tsconfig.json`.

### Structural typing

Structural typing is a familiar concept to most functional programmers,
although Haskell and most MLs are not structurally typed. Its basic form is
pretty simple:

    
    
    ts
    
    // @strict: false
    
    let o = { x: "hi", extra: 1 }; // ok
    
    let o2: { x: string } = o; // ok

Here, the object literal `{ x: "hi", extra: 1 }` has a matching literal type
`{ x: string, extra: number }`. That type is assignable to `{ x: string }`
since it has all the required properties and those properties have assignable
types. The extra property doesn‚Äôt prevent assignment, it just makes it a
subtype of `{ x: string }`.

Named types just give a name to a type; for assignability purposes there‚Äôs no
difference between the type alias `One` and the interface type `Two` below.
They both have a property `p: string`. (Type aliases behave differently from
interfaces with respect to recursive definitions and type parameters,
however.)

    
    
    ts
    
    type One = { p: string };
    
    interface Two {
    
      p: string;
    
    }
    
    class Three {
    
      p = "Hello";
    
    }
    
    ¬†
    
    let x: One = { p: "hi" };
    
    let two: Two = x;
    
    two = new Three();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAHkA7UgXlAG9QjVE9oBLCgc1AF8BuHBzwwAZgEMAxqQAqAdzj0coRs1YdOAnjgkAbMYkShpAC2iRSdJY1C0ARAAlIOnXFuacOHZDygAHqkoaehVQW2M2W14BLx88eVQ5BVpfATik0CpZI1NzAAoASj4gA)

### Unions

In TypeScript, union types are untagged. In other words, they are not
discriminated unions like `data` in Haskell. However, you can often
discriminate types in a union using built-in tags or other properties.

    
    
    ts
    
    function start(
    
      arg: string | string[] | (() => string) | { s: string }
    
    ): string {
    
      // this is super common in JavaScript
    
      if (typeof arg === "string") {
    
        return commonCase(arg);
    
      } else if (Array.isArray(arg)) {
    
        return arg.map(commonCase).join(",");
    
      } else if (typeof arg === "function") {
    
        return commonCase(arg());
    
      } else {
    
        return commonCase(arg.s);
    
      }
    
    ¬†
    
      function commonCase(s: string): string {
    
        // finally, just convert a string to another string
    
        return s;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZygQwE5QBQChGKYDmAXClBjGEYgD7mXUDaAunYttgJSIC8AfAypEe9AN4oyqRjQC+uLlIrDEY-IgD0GxFAAWMZIgMoQABwCmGRBDgBbWwiNIAUmgBuaAMoRKpqOphgDigATws4IOI+Xl5EACJpYTieNQICDHMoEAwkG3sEAGE0ZHNsYi4AbnVZRHMAGxKjIOwAQQwMNBCAOgM2jpCyjBEU9XTM7KRiLts0U2w8hzAikq4ugCs4Kmw4gBpkqoIa+sbA4LDzCMIh6Ni40EhYBGTVUcQMrJzrO0Xl0uJuSrVWoNcwvNJvcafBaFYp-IZdZCAw64dT3aDwXLfGElbDIJQyRRCahgtJaRDAKhoOp1EI7RBrECoL5gNyWKCEIk0KBwQhgOB6Syc17vCYoA6IeSyIA)

`string`, `Array` and `Function` have built-in type predicates, conveniently
leaving the object type for the `else` branch. It is possible, however, to
generate unions that are difficult to differentiate at runtime. For new code,
it‚Äôs best to build only discriminated unions.

The following types have built-in predicates:

Type | Predicate  
---|---  
string | `typeof s === "string"`  
number | `typeof n === "number"`  
bigint | `typeof m === "bigint"`  
boolean | `typeof b === "boolean"`  
symbol | `typeof g === "symbol"`  
undefined | `typeof undefined === "undefined"`  
function | `typeof f === "function"`  
array | `Array.isArray(a)`  
object | `typeof o === "object"`  
  
Note that functions and arrays are objects at runtime, but have their own
predicates.

#### Intersections

In addition to unions, TypeScript also has intersections:

    
    
    ts
    
    type Combined = { a: number } & { b: string };
    
    type Conflicting = { a: number } & { a: string };
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gWwEYEsB2EAmUC8UDeUAhgFxRoCuyEATlAL5QBkBUSZAzsDegOYMBuAFChIsOGgBmAGxQBjYH1ytS5KkloNmKztyX0BQA)

`Combined` has two properties, `a` and `b`, just as if they had been written
as one object literal type. Intersection and union are recursive in case of
conflicts, so `Conflicting.a: number & string`.

### Unit types

Unit types are subtypes of primitive types that contain exactly one primitive
value. For example, the string `"foo"` has the type `"foo"`. Since JavaScript
has no built-in enums, it is common to use a set of well-known strings
instead. Unions of string literal types allow TypeScript to type this pattern:

    
    
    ts
    
    declare function pad(s: string, n: number, direction: "left" | "right"): string;
    
    pad("hi", 10, "left");
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFBFS4lVnEsAjAAYWk6Rt1A)

When needed, the compiler _widens_ ‚Äî converts to a supertype ‚Äî the unit type
to the primitive type, such as `"foo"` to `string`. This happens when using
mutability, which can hamper some uses of mutable variables:

    
    
    ts
    
    let s = "right";
    
    pad("hi", 10, s); // error: 'string' is not assignable to '"left" | "right"'
    
    Argument of type 'string' is not assignable to parameter of type '"left" | "right"'.2345Argument of type 'string' is not assignable to parameter of type '"left" | "right"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6AA7kEAUKUImbRWDAOYAaUA1QM6AWwBGMaQVZUW7WaABEpSDWa7QAHz2jxAC2MBKVMNESA3HhCgAtF+J1mXj3gGzEKgALwWrNbGrjz8ulasutIAjAAM0oi2zqDuMPDQqADkjmLihaCsiDJwweSIiJEM5EoGoMxwoIX6hsZmEVG6hUA)

Here‚Äôs how the error happens:

  * `"right": "right"`
  * `s: string` because `"right"` widens to `string` on assignment to a mutable variable.
  * `string` is not assignable to `"left" | "right"`

You can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `"left" | "right"`.
    
    
    ts
    
    let s: "left" | "right" = "right";
    
    pad("hi", 10, s);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFAB6Q-AC05sMgznT+qRmpVJ02QqVZVrgLzvP4g0Sk4ipY4iwAjAAMLGTqukA)

## Concepts similar to Haskell

### Contextual typing

TypeScript has some obvious places where it can infer types, like variable
declarations:

    
    
    ts
    
    let s = "I'm a string!";
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECICSByAthAhtMAnAlgHYDmAhAgNxA)

But it also infers types in a few other places that you may not expect if
you‚Äôve worked with other C-syntax languages:

    
    
    ts
    
    declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];
    
    let sns = map((n) => n.toString(), [1, 2, 3]);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKRALngY1fIEp4BeO2tQwBnTgG0Aul1Y1JAbgBQEEBnjDUwvoRIMGqHv3ioAdBhwBlDDCyoA5gy7UxARmoAmagGYpcoA)

Here, `n: number` in this example also, despite the fact that `T` and `U` have
not been inferred before the call. In fact, after `[1,2,3]` has been used to
infer `T=number`, the return type of `n => n.toString()` is used to infer
`U=string`, causing `sns` to have the type `string[]`.

Note that inference will work in any order, but intellisense will only work
left-to-right, so TypeScript prefers to declare `map` with the array first:

    
    
    ts
    
    declare function map<T, U>(ts: T[], f: (t: T) => U): U[];
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKDAZwC55yBtAXWsXabtyASngBeOrWHsaPANxA)

Contextual typing also works recursively through object literals, and on unit
types that would otherwise be inferred as `string` or `number`. And it can
infer return types from context:

    
    
    ts
    
    declare function run<T>(thunk: (t: T) => void): T;
    
    let i: { inference: string } = run((o) => {
    
      o.inference = "INSERT STATE HERE";
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxjQB4AVAPgAoMALNAawC54qmSBKeAXjPgDccswNqwDcAKAggM8LEwDeM1IhBx0IJgGcMMLKgDm8AL5cCaChRwdu8OWPjwcAOl3LVYBJ3gAiAJIA5AGUAUQAlEngAkgBBEiD4AAlQoK9xQzYRIA)

The type of `o` is determined to be `{ inference: string }` because

  1. Declaration initializers are contextually typed by the declaration‚Äôs type: `{ inference: string }`.
  2. The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.
  3. Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.

And it does so while you are typing, so that after typing `o.`, you get
completions for the property `inference`, along with any other properties
you‚Äôd have in a real program. Altogether, this feature can make TypeScript‚Äôs
inference look a bit like a unifying type inference engine, but it is not.

### Type aliases

Type aliases are mere aliases, just like `type` in Haskell. The compiler will
attempt to use the alias name wherever it was used in the source code, but
does not always succeed.

    
    
    ts
    
    type Size = [number, number];
    
    let x: Size = [101.1, 999.9];
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyglgL2gXigbQHYFcC2AjCAJwBopt8iBdAbgCgAbCYKADwC5ZEV0BGABh4A6HqQCc4waJpA)

The closest equivalent to `newtype` is a _tagged intersection_ :

    
    
    ts
    
    type FString = string & { __compileTimeOnly: any };

An `FString` is just like a normal string, except that the compiler thinks it
has a property named `__compileTimeOnly` that doesn‚Äôt actually exist. This
means that `FString` can still be assigned to `string`, but not the other way
round.

### Discriminated Unions

The closest equivalent to `data` is a union of types with discriminant
properties, normally called discriminated unions in TypeScript:

    
    
    ts
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; x: number }
    
      | { kind: "triangle"; x: number; y: number };

Unlike Haskell, the tag, or discriminant, is just a property in each object
type. Each variant has an identical property with a different unit type. This
is still a normal union type; the leading `|` is an optional part of the union
type syntax. You can discriminate the members of the union using normal
JavaScript code:

    
    
    ts
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; x: number }
    
      | { kind: "triangle"; x: number; y: number };
    
    ¬†
    
    function area(s: Shape) {
    
      if (s.kind === "circle") {
    
        return Math.PI * s.radius * s.radius;
    
      } else if (s.kind === "square") {
    
        return s.x * s.x;
    
      } else {
    
        return (s.x * s.y) / 2;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoaABmfCS0wEQA9iRQWhAIABRCsIiQAJR48kRBUEkAdBZkqCgoNPRMzhm48pjawHwMMQCyCMBweQAKAJJQAFRQAnncvIJ9A0M8-AIBmDJQEMwC0Nm5g4XFpdTqmtrUVTVcEPWN47pjg7ozsvOL0NWYtUcNMfln-YMgGQD0UABMV3IZEA)

Note that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.

Also, unlike Haskell, common properties show up in any union, so you can
usefully discriminate multiple members of the union:

    
    
    ts
    
    function height(s: Shape) {
    
      if (s.kind === "circle") {
    
        return 2 * s.radius;
    
      } else {
    
        // s.kind: "square" | "triangle"
    
        return s.x;
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoAPSBUAC04bR8wOGhaABmfCS0wEQA9iRQcBBEDnDAABRCsIiQAJR48kRxUIUAdBZkqCgoNPRMzuW48pjawHwMGQBMUABUUAK13LyCAZgyUBDMAtBdmJjB4-XKVuqa2tQK1rb2TmzdXBB9A5u6s7JoMkA)

### Type Parameters

Like most C-descended languages, TypeScript requires declaration of type
parameters:

    
    
    ts
    
    function liftArray<T>(t: T): Array<T> {
    
      return [t];
    
    }

There is no case requirement, but type parameters are conventionally single
uppercase letters. Type parameters can also be constrained to a type, which
behaves a bit like type class constraints:

    
    
    ts
    
    function firstish<T extends { length: number }>(t1: T, t2: T): T {
    
      return t1.length > t2.length ? t1 : t2;
    
    }

TypeScript can usually infer type arguments from a call based on the type of
the arguments, so type arguments are usually not needed.

Because TypeScript is structural, it doesn‚Äôt need type parameters as much as
nominal systems. Specifically, they are not needed to make a function
polymorphic. Type parameters should only be used to _propagate_ type
information, such as constraining parameters to be the same type:

    
    
    ts
    
    function length<T extends ArrayLike<unknown>>(t: T): number {}
    
    function length(t: ArrayLike<unknown>): number {}

In the first `length`, T is not necessary; notice that it‚Äôs only referenced
once, so it‚Äôs not being used to constrain the type of the return value or
other parameters.

#### Higher-kinded types

TypeScript does not have higher kinded types, so the following is not legal:

    
    
    ts
    
    function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}

#### Point-free programming

Point-free programming ‚Äî heavy use of currying and function composition ‚Äî is
possible in JavaScript, but can be verbose. In TypeScript, type inference
often fails for point-free programs, so you‚Äôll end up specifying type
parameters instead of value parameters. The result is so verbose that it‚Äôs
usually better to avoid point-free programming.

### Module system

JavaScript‚Äôs modern module syntax is a bit like Haskell‚Äôs, except that any
file with `import` or `export` is implicitly a module:

    
    
    ts
    
    import { value, Type } from "npm-package";
    
    import { other, Types } from "./local-package";
    
    import * as prefix from "../lib/third-package";

You can also import commonjs modules ‚Äî modules written using node.js‚Äô module
system:

    
    
    ts
    
    import f = require("single-function-package");

You can export with an export list:

    
    
    ts
    
    export { f };
    
    function f() {
    
      return g();
    
    }
    
    function g() {} // g is not exported

Or by marking each export individually:

    
    
    ts
    
    export function f() { return g() }
    
    function g() { }

The latter style is more common but both are allowed, even in the same file.

### `readonly` and `const`

In JavaScript, mutability is the default, although it allows variable
declarations with `const` to declare that the _reference_ is immutable. The
referent is still mutable:

    
    
    js
    
    const a = [1, 2, 3];
    
    a.push(102); // ):
    
    a[0] = 101; // D:

TypeScript additionally has a `readonly` modifier for properties.

    
    
    ts
    
    interface Rx {
    
      readonly x: number;
    
    }
    
    let rx: Rx = { x: 1 };
    
    rx.x = 12; // error

It also ships with a mapped type `Readonly<T>` that makes all properties
`readonly`:

    
    
    ts
    
    interface X {
    
      x: number;
    
    }
    
    let rx: Readonly<X> = { x: 1 };
    
    rx.x = 12; // error

And it has a specific `ReadonlyArray<T>` type that removes side-affecting
methods and prevents writing to indices of the array, as well as special
syntax for this type:

    
    
    ts
    
    let a: ReadonlyArray<number> = [1, 2, 3];
    
    let b: readonly number[] = [1, 2, 3];
    
    a.push(102); // error
    
    b[0] = 101; // error

You can also use a const-assertion, which operates on arrays and object
literals:

    
    
    ts
    
    let a = [1, 2, 3] as const;
    
    a.push(102); // error
    
    a[0] = 101; // error

However, none of these options are the default, so they are not consistently
used in TypeScript code.

### Next Steps

This doc is a high level overview of the syntax and types you would use in
everyday code. From here you should:

  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for Functional
Programmers.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(15\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

UJ![Udoh Jeremiah
\(1\)](https://gravatar.com/avatar/0aa6036d5891261b5344c2adf171fd09?s=32&&d=blank)

MF![Martin Fischer
\(1\)](https://gravatar.com/avatar/91cf0683fbec52e9d05166e17c66daa5?s=32&&d=blank)

JRSDS![Jonas Raoni Soares da Silva
\(1\)](https://gravatar.com/avatar/4b881f821de5800b8a1d5dab4127afb2?s=32&&d=blank)

RC![Ryan Cavanaugh
\(1\)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)

11+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript for Java/C# Programmers

TypeScript is a popular choice for programmers accustomed to other languages
with static typing, such as C# and Java.

TypeScript‚Äôs type system offers many of the same benefits, such as better code
completion, earlier detection of errors, and clearer communication between
parts of your program. While TypeScript provides many familiar features for
these developers, it‚Äôs worth stepping back to see how JavaScript (and
therefore TypeScript) differ from traditional OOP languages. Understanding
these differences will help you write better JavaScript code, and avoid common
pitfalls that programmers who go straight from C#/Java to TypeScript may fall
into.

## Co-learning JavaScript

If you‚Äôre familiar with JavaScript already but are primarily a Java or C#
programmer, this introductory page can help explain some of the common
misconceptions and pitfalls you might be susceptible to. Some of the ways that
TypeScript models types are quite different from Java or C#, and it‚Äôs
important to keep these in mind when learning TypeScript.

If you‚Äôre a Java or C# programmer that is new to JavaScript in general, we
recommend learning a little bit of JavaScript _without_ types first to
understand JavaScript‚Äôs runtime behaviors. Because TypeScript doesn‚Äôt change
how your code _runs_ , you‚Äôll still have to learn how JavaScript works in
order to write code that actually does something!

It‚Äôs important to remember that TypeScript uses the same _runtime_ as
JavaScript, so any resources about how to accomplish specific runtime behavior
(converting a string to a number, displaying an alert, writing a file to disk,
etc.) will always apply equally well to TypeScript programs. Don‚Äôt limit
yourself to TypeScript-specific resources!

## Rethinking the Class

C# and Java are what we might call _mandatory OOP_ languages. In these
languages, the _class_ is the basic unit of code organization, and also the
basic container of all data _and_ behavior at runtime. Forcing all
functionality and data to be held in classes can be a good domain model for
some problems, but not every domain _needs_ to be represented this way.

### Free Functions and Data

In JavaScript, functions can live anywhere, and data can be passed around
freely without being inside a pre-defined `class` or `struct`. This
flexibility is extremely powerful. ‚ÄúFree‚Äù functions (those not associated with
a class) working over data without an implied OOP hierarchy tend to be the
preferred model for writing programs in JavaScript.

### Static Classes

Additionally, certain constructs from C# and Java such as singletons and
static classes are unnecessary in TypeScript.

## OOP in TypeScript

That said, you can still use classes if you like! Some problems are well-
suited to being solved by a traditional OOP hierarchy, and TypeScript‚Äôs
support for JavaScript classes will make these models even more powerful.
TypeScript supports many common patterns such as implementing interfaces,
inheritance, and static methods.

We‚Äôll cover classes later in this guide.

## Rethinking Types

TypeScript‚Äôs understanding of a _type_ is actually quite different from C# or
Java‚Äôs. Let‚Äôs explore some differences.

### Nominal Reified Type Systems

In C# or Java, any given value or object has one exact type - either `null`, a
primitive, or a known class type. We can call methods like `value.GetType()`
or `value.getClass()` to query the exact type at runtime. The definition of
this type will reside in a class somewhere with some name, and we can‚Äôt use
two classes with similar shapes in lieu of each other unless there‚Äôs an
explicit inheritance relationship or commonly-implemented interface.

These aspects describe a _reified, nominal_ type system. The types we wrote in
the code are present at runtime, and the types are related via their
declarations, not their structures.

### Types as Sets

In C# or Java, it‚Äôs meaningful to think of a one-to-one correspondence between
runtime types and their compile-time declarations.

In TypeScript, it‚Äôs better to think of a type as a _set of values_ that share
something in common. Because types are just sets, a particular value can
belong to _many_ sets at the same time.

Once you start thinking of types as sets, certain operations become very
natural. For example, in C#, it‚Äôs awkward to pass around a value that is
_either_ a `string` or `int`, because there isn‚Äôt a single type that
represents this sort of value.

In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the _union_ of those sets: `string | number`.

TypeScript provides a number of mechanisms to work with types in a set-
theoretic way, and you‚Äôll find them more intuitive if you think of types as
sets.

### Erased Structural Types

In TypeScript, objects are _not_ of a single exact type. For example, if we
construct an object that satisfies an interface, we can use that object where
that interface is expected even though there was no declarative relationship
between the two.

    
    
    ts
    
    interface Pointlike {
    
      x: number;
    
      y: number;
    
    }
    
    interface Named {
    
      name: string;
    
    }
    
    ¬†
    
    function logPoint(point: Pointlike) {
    
      console.log("x = " + point.x + ", y = " + point.y);
    
    }
    
    ¬†
    
    function logName(x: Named) {
    
      console.log("Hello, " + x.name);
    
    }
    
    ¬†
    
    const obj = {
    
      x: 0,
    
      y: 0,
    
      name: "Origin",
    
    };
    
    ¬†
    
    logPoint(obj);
    
    logName(obj);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRgDbANYoDeAUMsgB4BcyIArgLYBG0A3KcgJ7V1OvEC+xLNHhJkAOTj0IAE2QkyIKRGoBnMFFABzNoOIxaIBGGDoQybOi0YsACgAOmcNRvhcBAJTz2CM6vTYEAB0llq2AETkyAC8yOHIANTIjlhBUUnhADScMXGJyU5gQRweusT6hsam5qGS0rZUEsoyXgrIviD+gSFWEQASENiW2fFJ5EFK0qUC5R3qyOiMAFa5bY0ADJnsXMib7JMqcQDymlqgWQJsxKGuYLaLS9O1yvfLpUA)

TypeScript‚Äôs type system is _structural_ , not nominal: We can use `obj` as a
`Pointlike` because it has `x` and `y` properties that are both numbers. The
relationships between types are determined by the properties they contain, not
whether they were declared with some particular relationship.

TypeScript‚Äôs type system is also _not reified_ : There‚Äôs nothing at runtime
that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is
not present _in any form_ at runtime.

Going back to the idea of _types as sets_ , we can think of `obj` as being a
member of both the `Pointlike` set of values and the `Named` set of values.

### Consequences of Structural Typing

OOP programmers are often surprised by two particular aspects of structural
typing.

#### Empty Types

The first is that the _empty type_ seems to defy expectation:

    
    
    ts
    
    class Empty {}
    
    ¬†
    
    function fn(arg: Empty) {
    
      // do something?
    
    }
    
    ¬†
    
    // No error, but this isn't an 'Empty' ?
    
    fn({ k: 10 });
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4CgcDMBXAO2GQEsB7Y6fYgCjACcBzALjiTQEpMdpoAekHQAJpWgRK8AKbIAFuWIsA-Dlw5h0AHISZTJpSYAaaACNCyaAvIxbxAORWwNBwhSoH0NXXoZoANYcAIwADNBY3ADcQA)

TypeScript determines if the call to `fn` here is valid by seeing if the
provided argument is a valid `Empty`. It does so by examining the _structure_
of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has _all_ of
the properties that `Empty` does, because `Empty` has no properties.
Therefore, this is a valid call!

This may seem surprising, but it‚Äôs ultimately a very similar relationship to
one enforced in nominal OOP languages. A subclass cannot _remove_ a property
of its base class, because doing so would destroy the natural subtype
relationship between the derived class and its base. Structural type systems
simply identify this relationship implicitly by describing subtypes in terms
of having properties of compatible types.

#### Identical Types

Another frequent source of surprise comes with identical types:

    
    
    ts
    
    class Car {
    
      drive() {
    
        // hit the gas
    
      }
    
    }
    
    class Golfer {
    
      drive() {
    
        // hit the ball far
    
      }
    
    }
    
    // No error?
    
    let w: Car = new Golfer();

Again, this isn‚Äôt an error because the _structures_ of these classes are the
same. While this may seem like a potential source of confusion, in practice,
identical classes that shouldn‚Äôt be related are not common.

We‚Äôll learn more about how classes relate to each other in the Classes
chapter.

### Reflection

OOP programmers are accustomed to being able to query the type of any value,
even a generic one:

    
    
    csharp
    
    // C#
    
    static void LogType<T>() {
    
        Console.WriteLine(typeof(T).Name);
    
    }

Because TypeScript‚Äôs type system is fully erased, information about e.g. the
instantiation of a generic type parameter is not available at runtime.

JavaScript does have some limited primitives like `typeof` and `instanceof`,
but remember that these operators are still working on the values as they
exist in the type-erased output code. For example, `typeof (new Car())` will
be `"object"`, not `Car` or `"Car"`.

## Next Steps

This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:

  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for OOPers.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(13\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

TZ![Tao Zhou
\(1\)](https://gravatar.com/avatar/1e986d9241ff3d4831b47bbcf3489dbe?s=32&&d=blank)

SP![Samuel Pak
\(1\)](https://gravatar.com/avatar/0865bafa91b38ca6222453490824c821?s=32&&d=blank)

L![Lalit
\(1\)](https://gravatar.com/avatar/4c1441a0cf0ea3fbdae9eb3914627009?s=32&&d=blank)

GD![Gonzalo Diethelm
\(1\)](https://gravatar.com/avatar/bce510d0f0878760fa1b0f0d6f2c9352?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript for JavaScript Programmers

TypeScript stands in an unusual relationship to JavaScript. TypeScript offers
all of JavaScript‚Äôs features, and an additional layer on top of these:
TypeScript‚Äôs type system.

For example, JavaScript provides language primitives like `string` and
`number`, but it doesn‚Äôt check that you‚Äôve consistently assigned these.
TypeScript does.

This means that your existing working JavaScript code is also TypeScript code.
The main benefit of TypeScript is that it can highlight unexpected behavior in
your code, lowering the chance of bugs.

This tutorial provides a brief overview of TypeScript, focusing on its type
system.

## Types by Inference

TypeScript knows the JavaScript language and will generate types for you in
many cases. For example in creating a variable and assigning it to a
particular value, TypeScript will use the value as its type.

    
    
    ts
    
    let helloWorld = "Hello World";
    
            
    
    let helloWorld: string
    
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAFizA9gdXgJ2AEwgXggIgBKwITJrq4DcAUAPQ0QQB6A-EA)

By understanding how JavaScript works, TypeScript can build a type-system that
accepts JavaScript code but has types. This offers a type-system without
needing to add extra characters to make types explicit in your code. That‚Äôs
how TypeScript knows that `helloWorld` is a `string` in the above example.

You may have written JavaScript in Visual Studio Code, and had editor auto-
completion. Visual Studio Code uses TypeScript under the hood to make it
easier to work with JavaScript.

## Defining Types

You can use a wide variety of design patterns in JavaScript. However, some
design patterns make it difficult for types to be inferred automatically (for
example, patterns that use dynamic programming). To cover these cases,
TypeScript supports an extension of the JavaScript language, which offers
places for you to tell TypeScript what the types should be.

For example, to create an object with an inferred type which includes `name:
string` and `id: number`, you can write:

    
    
    ts
    
    const user = {
    
      name: "Hayes",
    
      id: 0,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwFAxmAQwFtEAuGAIgAkCBPRCCgGlxgEsATcgBhYF8A3EA)

You can explicitly describe this object‚Äôs shape using an `interface`
declaration:

    
    
    ts
    
    interface User {
    
      name: string;
    
      id: number;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvkA)

You can then declare that a JavaScript object conforms to the shape of your
new `interface` by using syntax like `: TypeName` after a variable
declaration:

    
    
    ts
    
    const user: User = {
    
      name: "Hayes",
    
      id: 0,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrgD0Q5AFoJCDmAljcCAPYgqyDpigUMWALw4mRUhQBEACTgBPCOiMAaJqwoAGO-3pA)

If you provide an object that doesn‚Äôt match the interface you have provided,
TypeScript will warn you:

    
    
    ts
    
    interface User {
    
      name: string;
    
      id: number;
    
    }
    
    ¬†
    
    const user: User = {
    
      username: "Hayes",
    
    Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.
    
      id: 0,
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAFVEZQBvHUUA8gW0lUSOkIBzANytQeACaoCAV04AjGKIC+OHJTgE+oGQ2ip6jALzMxumB26oARAAlyAT0iJrAGjGTUABnfLhQA)

Since JavaScript supports classes and object-oriented programming, so does
TypeScript. You can use an interface declaration with classes:

    
    
    ts
    
    interface User {
    
      name: string;
    
      id: number;
    
    }
    
    ¬†
    
    class UserAccount {
    
      name: string;
    
      id: number;
    
    ¬†
    
      constructor(name: string, id: number) {
    
        this.name = name;
    
        this.id = id;
    
      }
    
    }
    
    ¬†
    
    const user: User = new UserAccount("Murphy", 1);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrlwIANnHTo0mKAEEECAPYdwOJkVIUqNEAyat2XXlEZNFILRwRgFUABTrylanQA0zNoUPQAlKoIEwAAtgdAA6B2QAXkISCEZ-ZCCQ0NYo93jkQUFhBXMwZA5pCgwsaJAIAHcpaDlFZTBbACIAWQ4oAAdAgE9GtwBGb3ogA)

You can use interfaces to annotate parameters and return values to functions:

    
    
    ts
    
    function deleteUser(user: User) {
    
      // ...
    
    }
    
    ¬†
    
    function getAdminUser(): User {
    
      //...
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEtIBcCm8AzAQwGNdQBVFfUAbzVFEiIFtcAuUFbeLAcwDcDUBgAmnSAFcWAI3xCAvmhCgAtOpKTs61WgKTIJbBmiRQo3ABtceKvgAUk6vE534ASjrCVAOj9olPQMjEzM+GwBBURYsN3t3V2cvRhA-HwCgA)

There is already a small set of primitive types available in JavaScript:
`boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`,
which you can use in an interface. TypeScript extends this list with a few
more, such as `any` (allow anything), [`unknown`](/play#example/unknown-and-
never) (ensure someone using this type declares what the type is),
[`never`](/play#example/unknown-and-never) (it‚Äôs not possible that this type
could happen), and `void` (a function which returns `undefined` or has no
return value).

You‚Äôll see that there are two syntaxes for building types: [Interfaces and
Types](/play/?e=83#example/types-vs-interfaces). You should prefer
`interface`. Use `type` when you need specific features.

## Composing Types

With TypeScript, you can create complex types by combining simple ones. There
are two popular ways to do so: with unions, and with generics.

### Unions

With a union, you can declare that a type could be one of many types. For
example, you can describe a `boolean` type as being either `true` or `false`:

    
    
    ts
    
    type MyBool = true | false;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAsiBCB7RAbKBeKwBOBXaAPlAGYCGKAzhANxA)

_Note:_ If you hover over `MyBool` above, you‚Äôll see that it is classed as
`boolean`. That‚Äôs a property of the Structural Type System. More on this
below.

A popular use-case for union types is to describe the set of `string` or
`number` [literals](/docs/handbook/2/everyday-types.html#literal-types) that a
value is allowed to be:

    
    
    ts
    
    type WindowStates = "open" | "closed" | "minimized";
    
    type LockStates = "locked" | "unlocked";
    
    type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6glgOwCYHsDuBlYBDYEDOUAvFAEQqQKlQA+ZAxgDYr4RLV2kC2icPAXm1IBuAFChIUADIp6Aayy4CxMs3lDaZAK4I1coWInQACizjA4ANwgB5JEgByWrgCMIAJ3wBVZB4AqEAgqAIyaAMyaAKyaAOyaAJzCQA)

Unions provide a way to handle different types too. For example, you may have
a function that takes an `array` or a `string`:

    
    
    ts
    
    function getLength(obj: string | string[]) {
    
      return obj.length;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQDKrMqALACjgCMArALkQGcoAnGHRAH2roeQG0BdASkQG8AUIkS10IWkhKkAdABtsuPAG5BAXyA)

To learn the type of a variable, use `typeof`:

Type | Predicate  
---|---  
string | `typeof s === "string"`  
number | `typeof n === "number"`  
boolean | `typeof b === "boolean"`  
undefined | `typeof undefined === "undefined"`  
function | `typeof f === "function"`  
array | `Array.isArray(a)`  
  
For example, you can make a function return different values depending on
whether it is passed a string or an array:

    
    
    ts
    
    function wrapInArray(obj: string | string[]) {
    
      if (typeof obj === "string") {
    
        return [obj];
    
                
    
    (parameter) obj: string
    
      }
    
      return obj;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwE4EMAOBJMBBVDATwAo4AjAKwC5EBnKVGMAc0QB97HmWBtAXQCUiAN4AoRIhjBEJKEUwBTODIqVEAXi2IARAyasdw8ZMmpFUEKiS81-ANxiA9E9NvTAPQD8ExAF9fc0trRDVHPyA)

### Generics

Generics provide variables to types. A common example is an array. An array
without generics could contain anything. An array with generics can describe
the values that the array contains.

    
    
    ts
    
    type StringArray = Array<string>;
    
    type NumberArray = Array<number>;
    
    type ObjectWithNameArray = Array<{ name: string }>;

You can declare your own types that use generics:

    
    
    ts
    
    interface Backpack<Type> {
    
      add: (obj: Type) => void;
    
      get: () => Type;
    
    }
    
    ¬†
    
    // This line is a shortcut to tell TypeScript there is a
    
    // constant called `backpack`, and to not worry about where it came from.
    
    declare const backpack: Backpack<string>;
    
    ¬†
    
    // object is a string, because we declared it above as the variable part of Backpack.
    
    const object = backpack.get();
    
    ¬†
    
    // Since the backpack variable is a string, you can't pass a number to the add function.
    
    backpack.add(23);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAEI0DWADswDwAqAni5AHygA3nlChKAEwmoAFHABGAK1Q8+ASlABeQQDc4BCQG5RoAOaQSsjdtCrIxgL548IWwAsCiUABtidT+KgiG4IJNQAriSgJHDRkN7etryQAMrU0AQsUSRuMP5elC5g1HBEiCSUpKDUlAmQEqAABvLMbNRMjQA04kQNMaBEcFEA7gjQ3OLycJGgw7nQ-lE1ALZ05PDLAHR4EpDU3pQL1aXloC3tbUyojBcc5RlEpvzGRaAKintRAZRBJA+m3Xke0o4UQdGGdF2+0O9VABCilCmOjolC8OToOkOBER3jobGgUTg5AYrWY2xKZUJSk+WjOpPam3MJBkaherhSxFo0VydNu7VAmIyOPygXuxABoG402qlQA5FE2IgCgNwssgdBorF0eIpKByOEiNQSARSttzqwyZIJDJMKygA)

## Structural Type System

One of TypeScript‚Äôs core principles is that type checking focuses on the
_shape_ that values have. This is sometimes called ‚Äúduck typing‚Äù or
‚Äústructural typing‚Äù.

In a structural type system, if two objects have the same shape, they are
considered to be of the same type.

    
    
    ts
    
    interface Point {
    
      x: number;
    
      y: number;
    
    }
    
    ¬†
    
    function logPoint(p: Point) {
    
      console.log(`${p.x}, ${p.y}`);
    
    }
    
    ¬†
    
    // logs "12, 26"
    
    const point = { x: 12, y: 26 };
    
    logPoint(point);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLIAeAXMiAK4C2ARtANwHICeZltDeAvnnjBSARhg6EMgA26AOYYsACgAOZWeACUuJglEBndOIgA6SVLkADACQ4FBolwA0yS9eZdTqxjzwB6LxOnbkACIARgAmB1CANkC8LRBtbAVMcGQAXlxiMjCHVmQo5C5GYxUwRWSwdyA)

The `point` variable is never declared to be a `Point` type. However,
TypeScript compares the shape of `point` to the shape of `Point` in the type-
check. They have the same shape, so the code passes.

The shape-matching only requires a subset of the object‚Äôs fields to match.

    
    
    ts
    
    const point3 = { x: 12, y: 26, z: 89 };
    
    logPoint(point3); // logs "12, 26"
    
    ¬†
    
    const rect = { x: 33, y: 3, width: 30, height: 80 };
    
    logPoint(rect); // logs "33, 3"
    
    ¬†
    
    const color = { hex: "#187ABF" };
    
    logPoint(color);
    
    Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.
      Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.
      Type '{ hex: string; }' is missing the following properties from type 'Point': x, y[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLwHIkQWMyZSDFAAXjZuVABGNFDpdAA2UIAvVAAOAE5QBXEPKxJzfJIMGNB4j0RQACJK0LRa8eUsnNBoSA1i0p5QDAxq1G3QAHcCABMSAAtdgAZQ08gCA1OSFouOrsMek2WNIZHDMfGt0IYOaZRwsBz6aBrVigG4bcYAYnKzQA7ABBABCADFxi88N1+iZwQgYkA)

There is no difference between how classes and objects conform to shapes:

    
    
    ts
    
    class VirtualPoint {
    
      x: number;
    
      y: number;
    
    ¬†
    
      constructor(x: number, y: number) {
    
        this.x = x;
    
        this.y = y;
    
      }
    
    }
    
    ¬†
    
    const newVPoint = new VirtualPoint(13, 56);
    
    logPoint(newVPoint); // logs "13, 56"
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLxqXUpERFAANQJoEj5KXSsWdk4eUH5hMQlpWtkG+0cSaD4NBBMaurlQpv6YWyrOUBIACwJEQNAAXm5xcYnp2ckFqWXQJSVM9trIAHd8is2iY4KikrKKkwBGDFCcADYYvA87i5OKmNB4jx5ABEj2eLyBQA)

If the object or class has all the required properties, TypeScript will say
they match, regardless of the implementation details.

## Next Steps

This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:

  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for JS
Programmers.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(24\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

DS![Dustin Stender
\(1\)](https://gravatar.com/avatar/28746adf20e8592ca459ed3191404e04?s=32&&d=blank)

MK![Matt Kantor
\(1\)](https://gravatar.com/avatar/225d0619e0b03ecd72c026954a0987cb?s=32&&d=blank)

JCR![Juan Carlos Ruiz
\(1\)](https://gravatar.com/avatar/24427ea070d361c247987ff7571862ce?s=32&&d=blank)

IO![Iv√°n Ovejero
\(1\)](https://gravatar.com/avatar/a836f92994cdbfc0e28239e52180c777?s=32&&d=blank)

18+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# TypeScript Tooling in 5 minutes

Let‚Äôs get started by building a simple web application with TypeScript.

## Installing TypeScript

There are two main ways to add TypeScript to your project:

  * Via npm (the Node.js package manager)
  * By installing TypeScript‚Äôs Visual Studio plugins

Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language
support by default but does not include the TypeScript compiler, `tsc`. If you
didn‚Äôt install TypeScript with Visual Studio, you can still [download
it](/download).

For npm users:

    
    
    shell
    
    > npm install -g typescript

## Building your first TypeScript file

In your editor, type the following JavaScript code in `greeter.ts`:

    
    
    ts
    
    function greeter(person) {
    
      return "Hello, " + person;
    
    }
    
    ¬†
    
    let user = "Jane User";
    
    ¬†
    
    document.body.textContent = greeter(user);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0koA5gE7XVbVuACkSDK7AJSgA3rVCheWBtw4AiABLVkyaABpQq0AGpQo7uMgBuWgF9atZP1AMa3UAF4DAKTKRqoAFVXVWtaABNodAZ4akgsADoAI2gw-HiBAA8sAGF2ATiPLl5+QSEXQQlLIA)

## Compiling your code

We used a `.ts` extension, but this code is just JavaScript. You could have
copy/pasted this straight out of an existing JavaScript app.

At the command line, run the TypeScript compiler:

    
    
    shell
    
    tsc greeter.ts

The result will be a file `greeter.js` which contains the same JavaScript that
you fed in. We‚Äôre up and running using TypeScript in our JavaScript app!

Now we can start taking advantage of some of the new tools TypeScript offers.
Add a `: string` type annotation to the ‚Äòperson‚Äô function parameter as shown
here:

    
    
    ts
    
    function greeter(person: string) {
    
      return "Hello, " + person;
    
    }
    
    ¬†
    
    let user = "Jane User";
    
    ¬†
    
    document.body.textContent = greeter(user);
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFABxwGcEAuRIqVGMZASkQG8AoRRDKEVJAIgAl0AG0FwANIh6IA1IkKoSYANzMAvs2aCsiEERyIAvBIBSAQzDpEAVV2oey5gBM4EEAFt0YKADoARnAcAnl7YAB5QAMII2J4GKBhYOLg6OHSKQA)

## Type annotations

Type annotations in TypeScript are lightweight ways to record the intended
contract of the function or variable. In this case, we intend the greeter
function to be called with a single string parameter. We can try changing the
call greeter to pass an array instead:

    
    
    ts
    
    function greeter(person: string) {
    
      return "Hello, " + person;
    
    }
    
    ¬†
    
    let user = [0, 1, 2];
    
    ¬†
    
    document.body.textContent = greeter(user);
    
    Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUwAUADjIraohdCol6ASlABvPKFBMKRaHQBEACUgAbNXAA0oRaADUoLkloBuPAF88eNS1BFEMUAF5QAbQAMOgIw60AXXM8ABM4MiIAW0gSCgA6ACM4YIBPWNYADwoAYVpWGJcGJhZ2BxgRUyA)

Re-compiling, you‚Äôll now see an error:

    
    
    shell
    
    error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.

Similarly, try removing all the arguments to the greeter call. TypeScript will
let you know that you have called this function with an unexpected number of
arguments. In both cases, TypeScript can offer static analysis based on both
the structure of your code, and the type annotations you provide.

Notice that although there were errors, the `greeter.js` file is still
created. You can use TypeScript even if there are errors in your code. But in
this case, TypeScript is warning that your code will likely not run as
expected.

## Interfaces

Let‚Äôs develop our sample further. Here we use an interface that describes
objects that have a firstName and lastName field. In TypeScript, two types are
compatible if their internal structure is compatible. This allows us to
implement an interface just by having the shape the interface requires,
without an explicit `implements` clause.

    
    
    ts
    
    interface Person {
    
      firstName: string;
    
      lastName: string;
    
    }
    
    ¬†
    
    function greeter(person: Person) {
    
      return "Hello, " + person.firstName + " " + person.lastName;
    
    }
    
    ¬†
    
    let user = { firstName: "Jane", lastName: "User" };
    
    ¬†
    
    document.body.textContent = greeter(user);
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyMwUGYAcnALYQBcyFUoA5gNxHIA2cF1dRszacAvgQIwAriARhgOZKygQIkKAAoADphyN05HAEp8XFWClRcAIgASEbtywAaZNeQBqZDsMgAdKTkVLQoXu7uXj7Y-rz8IWIS3GrIUhjQyAC8+CRkcYJuAFJwIBDWrrHB+dYAqmlQ7qKcBAAmWAhSdOB+AEZYzQCefpAAHmAAwjiQ4JlKKmrQGqnQRuxAA)

## Classes

Finally, let‚Äôs extend the example one last time with classes. TypeScript
supports new features in JavaScript, like support for class-based object-
oriented programming.

Here we‚Äôre going to create a `Student` class with a constructor and a few
public fields. Notice that classes and interfaces play well together, letting
the programmer decide on the right level of abstraction.

Also of note, the use of `public` on parameters to the constructor is a
shorthand that allows us to automatically create properties with that name.

    
    
    ts
    
    class Student {
    
      fullName: string;
    
      constructor(
    
        public firstName: string,
    
        public middleInitial: string,
    
        public lastName: string
    
      ) {
    
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    
      }
    
    }
    
    ¬†
    
    interface Person {
    
      firstName: string;
    
      lastName: string;
    
    }
    
    ¬†
    
    function greeter(person: Person) {
    
      return "Hello, " + person.firstName + " " + person.lastName;
    
    }
    
    ¬†
    
    let user = new Student("Jane", "M.", "User");
    
    ¬†
    
    document.body.textContent = greeter(user);
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAuBXAJgUwHb2gbwFDWgDNEQQA5MAW1QC5oJ4AnAS3QHMBufaYAe3QaNEweL0YAKbgQAOiAEYhmwIs0YMK1OoNZsANFOiyFS6JWbJkIVAEl0zeMzAgtTHfoIz5i5eHVVa9K7s3ACUOAbwABbMEAB0xKQaqNAAvCpq8EnQANTQAET5OabmljZ2Dk5FBQW5vpn+XAQAvrgtuKzwqIyEYMDJAApdEPzhBISqfpqBLOyN0HVJLjOcrbi4xOgizCNsjKionRLSQ-x0g2r8YXgEe0iM6PkAEqikvLqFuccX6PET9dRVD6GE4-BYNVa4KxYRAQLqpaDoVAAdzgSDQmHEeQAUmBEXl3nkALKxfH5ACqsMYeRCXFwyF4wEQ1EwsTkvGQAE9Yp0AB7wADC-E6mHhu32h3EMK6NKAA)

Re-run `tsc greeter.ts` and you‚Äôll see the generated JavaScript is the same as
the earlier code. Classes in TypeScript are just a shorthand for the same
prototype-based OO that is frequently used in JavaScript.

## Running your TypeScript web app

Now type the following in `greeter.html`:

    
    
    html
    
    <!DOCTYPE html>
    
    <html>
    
      <head>
    
        <title>TypeScript Greeter</title>
    
      </head>
    
      <body>
    
        <script src="greeter.js"></script>
    
      </body>
    
    </html>

Open `greeter.html` in the browser to run your first simple TypeScript web
application!

Optional: Open `greeter.ts` in Visual Studio, or copy the code into the
TypeScript playground. You can hover over identifiers to see their types.
Notice that in some cases these types are inferred automatically for you. Re-
type the last line, and see completion lists and parameter help based on the
types of the DOM elements. Put your cursor on the reference to the greeter
function, and hit F12 to go to its definition. Notice, too, that you can
right-click on a symbol and use refactoring to rename it.

The type information provided works together with the tools to work with
JavaScript at application scale. For more examples of what‚Äôs possible in
TypeScript, see the Samples section of the website.

![Visual Studio picture](/images/docs/greet_person.png)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/TypeScript Tooling in
5 minutes.md) ‚ù§

Contributors to this page:  

OT![Orta Therox
\(14\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

H![hanyujie2002
\(1\)](https://gravatar.com/avatar/207e18c1057c0a30572189b58f5e2104?s=32&&d=blank)

DS![Daniel Schroeder
\(1\)](https://gravatar.com/avatar/f5c062d4d1a11f7f7ca811c13cf043ac?s=32&&d=blank)

M![mahadyC
\(1\)](https://gravatar.com/avatar/62266f81763863333dc2a3a219cebb67?s=32&&d=blank)

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Utility Types

TypeScript provides several utility types to facilitate common type
transformations. These utilities are available globally.

## `Awaited<Type>`

> Released: [4.5](/docs/handbook/release-notes/typescript-4-5.html#the-
> awaited-type-and-promise-improvements)

This type is meant to model operations like `await` in `async` functions, or
the `.then()` method on `Promise`s - specifically, the way that they
recursively unwrap `Promise`s.

##### Example

    
    
    ts
    
    type A = Awaited<Promise<string>>;
    
        
    
    type A = string
    
    ¬†
    
    type B = Awaited<Promise<Promise<number>>>;
    
        
    
    type B = number
    
    ¬†
    
    type C = Awaited<boolean | Promise<number>>;
    
        
    
    type C = number | boolean
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAglC8sDuBDAlsCATAPABQCcB7AWzQGcIdzgC0A7AcwD5mBuAKAHouo+A9APwcOoSFABCCZOky5CpClQVlKOegFcSAIwgFW7brwHDR4aAGFpMVBmw5tRIgBsIKelAA+UFUvVbdfUMePighIA)

## `Partial<Type>`

> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)

Constructs a type with all properties of `Type` set to optional. This utility
will return a type that represents all subsets of a given type.

##### Example

    
    
    ts
    
    interface Todo {
    
      title: string;
    
      description: string;
    
    }
    
    ¬†
    
    function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
    
      return { ...todo, ...fieldsToUpdate };
    
    }
    
    ¬†
    
    const todo1 = {
    
      title: "organize desk",
    
      description: "clear clutter",
    
    };
    
    ¬†
    
    const todo2 = updateTodo(todo1, {
    
      description: "throw out trash",
    
    });
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgW+AL758MAK4gE-EMhk9McSBmwAKMFnTVN6ADTIYwCGUw0MAVVXqqyAApwoJOGQA8hgHwBKPDYoCDAZKCVcZAA6GN1sExioswsrW3tIZHFWSXwEATpiPQBGZABeQKISckcAInQoRjgQYAAvFA4aAGsaozYO7mA+YAFqGoQKV2RxmTBIKB6JVlz8sELsACYy5XSIQx1ikwIift5FUbAACyh0AHdkdBniKDgaC4XxP2YgA)

## `Required<Type>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#improved-control-
> over-mapped-type-modifiers)

Constructs a type consisting of all properties of `Type` set to required. The
opposite of `Partial`.

##### Example

    
    
    ts
    
    interface Props {
    
      a?: number;
    
      b?: string;
    
    }
    
    ¬†
    
    const obj: Props = { a: 5 };
    
    ¬†
    
    const obj2: Required<Props> = { a: 5 };
    
    Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBGAUAJYB2ALjAGYCGAxpKAArwAOioA3nqKJQPypEBXALYAjGAG5OoEX1CIS0YgHNJAXzx5qcIvNBwRAK1SM4LUAF523VAFZQqyZu279BtKgBKkAI4CC0SAATAB4TFgA+CytKW3txIA)

## `Readonly<Type>`

> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)

Constructs a type with all properties of `Type` set to `readonly`, meaning the
properties of the constructed type cannot be reassigned.

##### Example

    
    
    ts
    
    interface Todo {
    
      title: string;
    
    }
    
    ¬†
    
    const todo: Readonly<Todo> = {
    
      title: "Delete inactive users",
    
    };
    
    ¬†
    
    todo.title = "Hello";
    
    Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKACpwAmcoA3nqKCQSQDaRUiEtGIBzANx4AvnjzU4RYd2ZxUAJUiUWRPgE8APIxYA+UAF52nbrwGoARABFIAsqGI0eANzoBXRDCI9gA0MlJ4JKoAdDz8dJb2ABIufHD2EkA)

This utility is useful for representing assignment expressions that will fail
at runtime (i.e. when attempting to reassign properties of a [frozen
object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).

##### `Object.freeze`

    
    
    ts
    
    function freeze<Type>(obj: Type): Readonly<Type>;

## `Record<Keys, Type>`

> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)

Constructs an object type whose property keys are `Keys` and whose property
values are `Type`. This utility can be used to map the properties of a type to
another type.

##### Example

    
    
    ts
    
    type CatName = "miffy" | "boris" | "mordred";
    
    ¬†
    
    interface CatInfo {
    
      age: number;
    
      breed: string;
    
    }
    
    ¬†
    
    const cats: Record<CatName, CatInfo> = {
    
      miffy: { age: 10, breed: "Persian" },
    
      boris: { age: 5, breed: "Maine Coon" },
    
      mordred: { age: 16, breed: "British Shorthair" },
    
    };
    
    ¬†
    
    cats.boris;
    
     
    
    const cats: Record<CatName, CatInfo>
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwghsAcnAttAvFARCglgM3xCygB9sAjAewCdcBnE8nWgExolawG4AoX3ADtgEGvjgBjaPGABJQfipQA3ryhQ4AcwgAuKIICuKCqL7qKHTnvrA6gzXwC+-CVUE2oEhPT0AlCK40rAA8MshoADSwCPKKAHxQmKrqeIQgesoa2noAjAAMURYQVtgACqL0uHCCJI4RalDUdD4qWbpQAKyFlqx6WACycELSVG619SlsHL2tWu05AGzdxTNYAEJ0wAwAFlAAytu0wNtDNOO8jny8XsD0AHRNDHwA9M9QAHoA-EA)

## `Pick<Type, Keys>`

> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)

Constructs a type by picking the set of properties `Keys` (string literal or
union of string literals) from `Type`.

##### Example

    
    
    ts
    
    interface Todo {
    
      title: string;
    
      description: string;
    
      completed: boolean;
    
    }
    
    ¬†
    
    type TodoPreview = Pick<Todo, "title" | "completed">;
    
    ¬†
    
    const todo: TodoPreview = {
    
      title: "Clean room",
    
      completed: false,
    
    };
    
    ¬†
    
    todo;
    
     
    
    const todo: TodoPreview
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVgF98+MAE8eKDNgAKUCADdgEAO7IAvMmPAEAawA8R9ABpkAIhLkEL7IAD5+EtKyEJi+AHys+BIgdMRY6NSephZWtg4ERAEU1L4AwqogyFDKkr5e4lIyEHLU8GQ0EHUaCWBprAD0fcgAegD8QA)

## `Omit<Type, Keys>`

> Released:  
>  [3.5](/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-
> type)

Constructs a type by picking all properties from `Type` and then removing
`Keys` (string literal or union of string literals). The opposite of `Pick`.

##### Example

    
    
    ts
    
    interface Todo {
    
      title: string;
    
      description: string;
    
      completed: boolean;
    
      createdAt: number;
    
    }
    
    ¬†
    
    type TodoPreview = Omit<Todo, "description">;
    
    ¬†
    
    const todo: TodoPreview = {
    
      title: "Clean room",
    
      completed: false,
    
      createdAt: 1615544252770,
    
    };
    
    ¬†
    
    todo;
    
     
    
    const todo: TodoPreview
    
    ¬†
    
    type TodoInfo = Omit<Todo, "completed" | "createdAt">;
    
    ¬†
    
    const todoInfo: TodoInfo = {
    
      title: "Pick up kids",
    
      description: "Kindergarten closes at 5pm",
    
    };
    
    ¬†
    
    todoInfo;
    
       
    
    const todoInfo: TodoInfo
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVkW4Q4cgIJhqIAK6SF0VgF98+MAE8eKDNgAKUCADdgEAO7IAvMgA8pKkADxO6AA0yABEHFy8-CAxAHys+BIgdMRY6NQRrh5evgEERCTkVLEAwqogyFDKkjGR4lIyEHLU8GQ0EK2abjoQmPrUAIwAbOMArDMALPMATDNLAOxrAAytFulguawA9IfIAHoA-NZ2Dmi5AJIgMDgBwWER0TES0rIjMcgAPrEtMNRmBUulMtl9tgHk98vdHs88GwKhRqDFnMAEABrZBGHjIbHATA0FpseLcYB8YACdEAaVAHCgjDgUEg9QQZHQfRoyB0yBmPGaOz2CKeRxOFyAA)

## `Exclude<UnionType, ExcludedMembers>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)

Constructs a type by excluding from `UnionType` all union members that are
assignable to `ExcludedMembers`.

##### Example

    
    
    ts
    
    type T0 = Exclude<"a" | "b" | "c", "a">;
    
         
    
    type T0 = "b" | "c"
    
    type T1 = Exclude<"a" | "b" | "c", "a" | "b">;
    
         
    
    type T1 = "c"
    
    type T2 = Exclude<string | number | (() => void), Function>;
    
         
    
    type T2 = string | number
    
    ¬†
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; x: number }
    
      | { kind: "triangle"; x: number; y: number };
    
    ¬†
    
    type T3 = Exclude<Shape, { kind: "circle" }>
    
         
    
    type T3 = {
        kind: "square";
        x: number;
    } | {
        kind: "triangle";
        x: number;
        y: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogDwMYBsCuATCAHgCIBDYqAHymICMLriNiAaG8gPgG4AoAej5QhUAHoB+HqEiwAjElSZcBEuSo16apq3YN1xbv0HDxk8NBgAmeemz4iAZ2AAnAJYA7AOZq3OALa0IJzUACmCASiQOKAA3AHsXPDC2ADEcNwxgF1i3AwFhUQlTaQBlAAtSaUQeIWoAbygAa3c8AC4aDBcnbAhiLignUjwXHHs2n39AqABfarV6prdWmnsARxxSJx6+tDG-AKCZmqh55rbiZxdSTywtqB2ocf2+kF2Jg94i8wBma0U7QjKFQgbBOizOHS6NwoUw4hny4iAA)

## `Extract<Type, Union>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)

Constructs a type by extracting from `Type` all union members that are
assignable to `Union`.

##### Example

    
    
    ts
    
    type T0 = Extract<"a" | "b" | "c", "a" | "f">;
    
         
    
    type T0 = "a"
    
    type T1 = Extract<string | number | (() => void), Function>;
    
         
    
    type T1 = () => void
    
    ¬†
    
    type Shape =
    
      | { kind: "circle"; radius: number }
    
      | { kind: "square"; x: number }
    
      | { kind: "triangle"; x: number; y: number };
    
    ¬†
    
    type T2 = Extract<Shape, { kind: "circle" }>
    
         
    
    type T2 = {
        kind: "circle";
        radius: number;
    }
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogD2AJwIYGNgA8ARNkVAD5REBGZlRuRANFaRVQGZEB8A3AFAB6QVFFQAegH5+oSLACMSVBhz4CAZywBLAHYBzdjoCuAW2oRM7ABRWAlEm5QAbgHstAE1ssAYkZ34tFx0+IRExKX4ZcGgAZQALbDlEflFKAG8oAGtddwAuKlwtTFwAGwgiXigcdy0jdXzjMwsoAF8U9gzsnTyqdQBHI2xMcsq0BtNzSzbUqE6c-KJtbH0yiqgxqEbJypBxpqmBKLkYACYldCw8QnjEiBY57oXC4tXW7lCxCUkgA)

## `NonNullable<Type>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)

Constructs a type by excluding `null` and `undefined` from `Type`.

##### Example

    
    
    ts
    
    type T0 = NonNullable<string | number | undefined>;
    
         
    
    type T0 = string | number
    
    type T1 = NonNullable<string[] | null | undefined>;
    
         
    
    type T1 = string[]
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAcgewHYoK4BtcCGARrhADwDOwATgJYYDmUAPlBtgLZETUtTYYAJhABm9CIIB8AbgBQAenlRlUAHoB+WaEiwAjElSYc+YqUo16DANoBdPu3x8BwsRgkyFSlRqA)

## `Parameters<Type>`

> Released:  
>  [3.1](https://github.com/microsoft/TypeScript/pull/26243)

Constructs a tuple type from the types used in the parameters of a function
type `Type`.

For overloaded functions, this will be the parameters of the _last_ signature;
see [Inferring Within Conditional Types](/docs/handbook/2/conditional-
types.html#inferring-within-conditional-types).

##### Example

    
    
    ts
    
    declare function f1(arg: { a: number; b: string }): void;
    
    ¬†
    
    type T0 = Parameters<() => string>;
    
         
    
    type T0 = []
    
    type T1 = Parameters<(s: string) => void>;
    
         
    
    type T1 = [s: string]
    
    type T2 = Parameters<<T>(arg: T) => T>;
    
         
    
    type T2 = [arg: unknown]
    
    type T3 = Parameters<typeof f1>;
    
         
    
    type T3 = [arg: {
        a: number;
        b: string;
    }]
    
    type T4 = Parameters<any>;
    
         
    
    type T4 = unknown[]
    
    type T5 = Parameters<never>;
    
         
    
    type T5 = never
    
    type T6 = Parameters<string>;
    
    Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.
    
         
    
    type T6 = never
    
    type T7 = Parameters<Function>;
    
    Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.
    
         
    
    type T7 = never
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQATSAYwBsBDaSUAMwFcA7IgFwEs56aBGACgoHNUAb1BlU9WgFsARjADcoKakRNoLen1ABfAJSoAbnBb5ZuXEwCeAByoAVAAygAvKAAKFMhMhMYiADzdtJwA+UGVVdSCTEFAY0AA9AH4zK1tOJ1d3T28kfxRQlTU+QMcQgyNI3GjYxOTrUBs0dLdoDy8fX18bIN5oAXrikK6osGqkizqbDCbMtpzxyDhqLgqqmJr5+qxplqz2snpzFZG1sZT6gFZt1uy-ekg9GCPY+NOJgDYr3ZywwqfR2tsAHZPrM-AAxBjMNj0P4nIA)

## `ConstructorParameters<Type>`

> Released:  
>  [3.1](https://github.com/microsoft/TypeScript/pull/26243)

Constructs a tuple or array type from the types of a constructor function
type. It produces a tuple type with all the parameter types (or the type
`never` if `Type` is not a function).

##### Example

    
    
    ts
    
    type T0 = ConstructorParameters<ErrorConstructor>;
    
         
    
    type T0 = [message?: string]
    
    type T1 = ConstructorParameters<FunctionConstructor>;
    
         
    
    type T1 = string[]
    
    type T2 = ConstructorParameters<RegExpConstructor>;
    
         
    
    type T2 = [pattern: string | RegExp, flags?: string]
    
    class C {
    
      constructor(a: number, b: string) {}
    
    }
    
    type T3 = ConstructorParameters<typeof C>;
    
         
    
    type T3 = [a: number, b: string]
    
    type T4 = ConstructorParameters<any>;
    
         
    
    type T4 = unknown[]
    
    ¬†
    
    type T5 = ConstructorParameters<Function>;
    
    Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.
    
         
    
    type T5 = never
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQIJEAXaASwGMjUAzAQwBtFJciBPAB0lABUAGUALygAwnAB2xaAFdKCAAq1otALaQiMRAB4AorASiJJGUQQA+ANz4woGwD0A-Cw5duARkEjxk4-MUq1GpoAYlJilKTiBt6y0BZWNnaObJw8aB5RRjEKSqrqSJoASpAA5toAHuwZ0jFxBAkOuOT0tIiIIqAA3rg25F6ZJtAAFLSoYlLKAEYwADSgE6iSpGLFAJSdAL64m8kuGOl91QPZ-nlaO3DUIrXWiU4p3Fj7hoe+OQH5tGKs1wmgDXcuACsT2iRz8uUCITCRAiYh+9XsQA)

## `ReturnType<Type>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)

Constructs a type consisting of the return type of function `Type`.

For overloaded functions, this will be the return type of the _last_
signature; see [Inferring Within Conditional
Types](/docs/handbook/2/conditional-types.html#inferring-within-conditional-
types).

##### Example

    
    
    ts
    
    declare function f1(): { a: number; b: string };
    
    ¬†
    
    type T0 = ReturnType<() => string>;
    
         
    
    type T0 = string
    
    type T1 = ReturnType<(s: string) => void>;
    
         
    
    type T1 = void
    
    type T2 = ReturnType<<T>() => T>;
    
         
    
    type T2 = unknown
    
    type T3 = ReturnType<<T extends U, U extends number[]>() => T>;
    
         
    
    type T3 = number[]
    
    type T4 = ReturnType<typeof f1>;
    
         
    
    type T4 = {
        a: number;
        b: string;
    }
    
    type T5 = ReturnType<any>;
    
         
    
    type T5 = any
    
    type T6 = ReturnType<never>;
    
         
    
    type T6 = never
    
    type T7 = ReturnType<string>;
    
    Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.
    
         
    
    type T7 = any
    
    type T8 = ReturnType<Function>;
    
    Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.
    
         
    
    type T8 = any
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAAmkAxgDYCG0koAZgK4B2pALgJZxP0CMAFAEpUAb1CVUTBgFsARjADcoGakSto7JgHNQAX3kECrAJ4AHWgBUADKAC8oAEqRWDaE3OnIAHkG2AfKFV1LV99EFBw0AA9AH5DD1BzHlsHJxc3D28UALUNTQE-UAA3OHYiEIIwiJi4swS0ZMdnV3czT09zXx8bfw7QsCrY41rzDAbU5oz20EgAD1ZIJiJEUABVABpV6bmFpdBJWRgAbQBdTvzuhPLK8Oqhi1w7RrSWrzu4Ol4r-pvB+PMAVjGTXSrUoTCMXwiUV+wwAbEDnhkmJBCjBIQMahYAOwIiatQK5dE-TEJAAcuJBXgAYsw2JwmEToUA)

## `InstanceType<Type>`

> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)

Constructs a type consisting of the instance type of a constructor function in
`Type`.

##### Example

    
    
    ts
    
    class C {
    
      x = 0;
    
      y = 0;
    
    }
    
    ¬†
    
    type T0 = InstanceType<typeof C>;
    
         
    
    type T0 = C
    
    type T1 = InstanceType<any>;
    
         
    
    type T1 = any
    
    type T2 = InstanceType<never>;
    
         
    
    type T2 = never
    
    type T3 = InstanceType<string>;
    
    Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.
    
         
    
    type T3 = any
    
    type T4 = InstanceType<Function>;
    
    Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.
    
         
    
    type T4 = any
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAgSIAu0AlgMamoBmAhgDaKQFVMOKKgDCoAbwKhQAD1ABeUAAYA3MNABPSTPkBfAgVKKADpFAAVaSoCSAOzIMzVSAd2QAPNr1w6fAHzziI0AD0A-Fr2hgCMphakVjZ2eg5Wip5EYD4BQXqGaOGW1rb2DmaQAG4wid4iqc76BhhZkTkxjmSUZgDmpcnlgZWGuFLm2dF5AGIArtakFHBm7T5+-kA)

## `NoInfer<Type>`

> Released:  
>  [5.4](/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-
> type)

Blocks inferences to the contained type. Other than blocking inferences,
`NoInfer<Type>` is identical to `Type`.

##### Example

    
    
    ts
    
    function createStreetLight<C extends string>(
    
      colors: C[],
    
      defaultColor?: NoInfer<C>,
    
    ) {
    
      // ...
    
    }
    
    createStreetLight(["red", "yellow", "green"], "red");  // OK
    
    createStreetLight(["red", "yellow", "green"], "blue");  // Error

## `ThisParameterType<Type>`

> Released:  
>  [3.3](https://github.com/microsoft/TypeScript/pull/28920)

Extracts the type of the [this](/docs/handbook/functions.html#this-parameters)
parameter for a function type, or [unknown](/docs/handbook/release-
notes/typescript-3-0.html#new-unknown-top-type) if the function type has no
`this` parameter.

##### Example

    
    
    ts
    
    function toHex(this: Number) {
    
      return this.toString(16);
    
    }
    
    ¬†
    
    function numberToString(n: ThisParameterType<typeof toHex>) {
    
      return toHex.apply(n);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWoSLASIwVWnQAqcMROnYwpIwUIAFAIZ0HlbvSMBPAA7oAPFG90OGBkNCwAPiY2Di4ePlCMTEEHLy8AGw9LZTUgA)

## `OmitThisParameter<Type>`

> Released:  
>  [3.3](https://github.com/microsoft/TypeScript/pull/28920)

Removes the [`this`](/docs/handbook/functions.html#this-parameters) parameter
from `Type`. If `Type` has no explicitly declared `this` parameter, the result
is simply `Type`. Otherwise, a new function type with no `this` parameter is
created from `Type`. Generics are erased and only the last overload signature
is propagated into the new function type.

##### Example

    
    
    ts
    
    function toHex(this: Number) {
    
      return this.toString(16);
    
    }
    
    ¬†
    
    const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);
    
    ¬†
    
    console.log(fiveToHex());
    
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWEBISiJgMAG7oAKmiykA8pRhRjBQgAUAhnSeVu9ADxQAngAd0OGBkM0wAPkQAXhCMTEFqSQATbABWZQ0tMEI4ABt0QRy4GX0jU1jsBmUgA)

## `ThisType<Type>`

> Released:  
>  [2.3](https://github.com/microsoft/TypeScript/pull/14141)

This utility does not return a transformed type. Instead, it serves as a
marker for a contextual [`this`](/docs/handbook/functions.html#this) type.
Note that the [`noImplicitThis`](/tsconfig#noImplicitThis) flag must be
enabled to use this utility.

##### Example

    
    
    ts
    
    type ObjectDescriptor<D, M> = {
    
      data?: D;
    
      methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M
    
    };
    
    ¬†
    
    function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
    
      let data: object = desc.data || {};
    
      let methods: object = desc.methods || {};
    
      return { ...data, ...methods } as D & M;
    
    }
    
    ¬†
    
    let obj = makeObject({
    
      data: { x: 0, y: 0 },
    
      methods: {
    
        moveBy(dx: number, dy: number) {
    
          this.x += dx; // Strongly typed this
    
          this.y += dy; // Strongly typed this
    
        },
    
      },
    
    });
    
    ¬†
    
    obj.x = 10;
    
    obj.y = 20;
    
    obj.moveBy(5, 5);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwCoAtUBnALlCwCcBXAUwCgsBPRa0AeQCMAra9LAEWqF05VIizRyAHj4AaUAFkAfKAC8oAN61QoACYBDLHoD8pPgG4toeNSx5oOwiYWgAZKHxEcTatNcLFZqAg7t6g0ABmoADktkRRoKiQVjZ2DgmEoHx+8rQAvha04ZSQvKjQSfB6ANbUHNy80nJKABQ6guikdTz87SJiEo3+AJSm2RqWyDa6Bnqk0FzdqrrtAHT6hqAAPpsa+RNT1rb2JGELvEttQiuHqRnbuxba5DaU5EnqoCtf63pyX9cpY6gXKgPQZLJueQWXK0WiTLCnThLSo1Lq8ZqabQ-UgfAAepAADHIGITgTJLDdjjjLNp4NAAG7UABCDFa+NAkEo8HY1HIch0JI5XJ55CG420ErIBEIK1xoAA1GodLjAsEAMoUcoAc2QDDI3h0UqINIlsRlesVugYqrAGvI2t1+uYhrNJty5O07ryQwK804sqWAEYCRY-Ss9WoAEwh2hhumMlnNACsciTPqAA)

In the example above, the `methods` object in the argument to `makeObject` has
a contextual type that includes `ThisType<D & M>` and therefore the type of
[this](/docs/handbook/functions.html#this) in methods within the `methods`
object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void
}`. Notice how the type of the `methods` property simultaneously is an
inference target and a source for the `this` type in methods.

The `ThisType<T>` marker interface is simply an empty interface declared in
`lib.d.ts`. Beyond being recognized in the contextual type of an object
literal, the interface acts like any empty interface.

## Intrinsic String Manipulation Types

### `Uppercase<StringType>`

### `Lowercase<StringType>`

### `Capitalize<StringType>`

### `Uncapitalize<StringType>`

To help with string manipulation around template string literals, TypeScript
includes a set of types which can be used in string manipulation within the
type system. You can find those in the [Template Literal
Types](/docs/handbook/2/template-literal-types.html#uppercasestringtype)
documentation.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Utility Types.md) ‚ù§

Contributors to this page:  

C![christian
\(54\)](https://gravatar.com/avatar/1f58f226873fbbebcb8d4741b56fc99c?s=32&&d=blank)

OT![Orta Therox
\(23\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

B![bob1983
\(4\)](https://gravatar.com/avatar/7bb14891ac3b3865d24d3842118dd12d?s=32&&d=blank)

JB![Jack Bates
\(3\)](https://gravatar.com/avatar/960dbdfd730d53c6ea7ff4df072abe1c?s=32&&d=blank)

HX![Hong Xu
\(2\)](https://gravatar.com/avatar/190ceb7cbc2eb3ec3fe7fb7f15166842?s=32&&d=blank)

34+

Last updated: Sep 16, 2024  
  

 Was this page helpful?

# Variable Declaration

`let` and `const` are two relatively new concepts for variable declarations in
JavaScript. [As we mentioned earlier](/docs/handbook/basic-types.html#a-note-
about-let), `let` is similar to `var` in some respects, but allows users to
avoid some of the common ‚Äúgotchas‚Äù that users run into in JavaScript.

`const` is an augmentation of `let` in that it prevents re-assignment to a
variable.

With TypeScript being an extension of JavaScript, the language naturally
supports `let` and `const`. Here we‚Äôll elaborate more on these new
declarations and why they‚Äôre preferable to `var`.

If you‚Äôve used JavaScript offhandedly, the next section might be a good way to
refresh your memory. If you‚Äôre intimately familiar with all the quirks of
`var` declarations in JavaScript, you might find it easier to skip ahead.

## `var` declarations

Declaring a variable in JavaScript has always traditionally been done with the
`var` keyword.

    
    
    ts
    
    var a = 10;

As you might‚Äôve figured out, we just declared a variable named `a` with the
value `10`.

We can also declare a variable inside of a function:

    
    
    ts
    
    function f() {
    
      var message = "Hello, world!";
    
      return message;
    
    }

and we can also access those same variables within other functions:

    
    
    ts
    
    function f() {
    
      var a = 10;
    
      return function g() {
    
        var b = a + 1;
    
        return b;
    
      };
    
    }
    
    var g = f();
    
    g(); // returns '11'

In this above example, `g` captured the variable `a` declared in `f`. At any
point that `g` gets called, the value of `a` will be tied to the value of `a`
in `f`. Even if `g` is called once `f` is done running, it will be able to
access and modify `a`.

    
    
    ts
    
    function f() {
    
      var a = 1;
    
      a = 2;
    
      var b = g();
    
      a = 3;
    
      return b;
    
      function g() {
    
        return a;
    
      }
    
    }
    
    f(); // returns '2'

### Scoping rules

`var` declarations have some odd scoping rules for those used to other
languages. Take the following example:

    
    
    ts
    
    function f(shouldInitialize: boolean) {
    
      if (shouldInitialize) {
    
        var x = 10;
    
      }
    
      return x;
    
    }
    
    f(true); // returns '10'
    
    f(false); // returns 'undefined'

Some readers might do a double-take at this example. The variable `x` was
declared _within the`if` block_, and yet we were able to access it from
outside that block. That‚Äôs because `var` declarations are accessible anywhere
within their containing function, module, namespace, or global scope - all
which we‚Äôll go over later on - regardless of the containing block. Some people
call this _`var`-scoping_ or _function-scoping_. Parameters are also function
scoped.

These scoping rules can cause several types of mistakes. One problem they
exacerbate is the fact that it is not an error to declare the same variable
multiple times:

    
    
    ts
    
    function sumMatrix(matrix: number[][]) {
    
      var sum = 0;
    
      for (var i = 0; i < matrix.length; i++) {
    
        var currentRow = matrix[i];
    
        for (var i = 0; i < currentRow.length; i++) {
    
          sum += currentRow[i];
    
        }
    
      }
    
      return sum;
    
    }

Maybe it was easy to spot out for some experienced JavaScript developers, but
the inner `for`-loop will accidentally overwrite the variable `i` because `i`
refers to the same function-scoped variable. As experienced developers know by
now, similar sorts of bugs slip through code reviews and can be an endless
source of frustration.

### Variable capturing quirks

Take a quick second to guess what the output of the following snippet is:

    
    
    ts
    
    for (var i = 0; i < 10; i++) {
    
      setTimeout(function () {
    
        console.log(i);
    
      }, 100 * i);
    
    }

For those unfamiliar, `setTimeout` will try to execute a function after a
certain number of milliseconds (though waiting for anything else to stop
running).

Ready? Take a look:

    
    
    10
    
    10
    
    10
    
    10
    
    10
    
    10
    
    10
    
    10
    
    10
    
    10

Many JavaScript developers are intimately familiar with this behavior, but if
you‚Äôre surprised, you‚Äôre certainly not alone. Most people expect the output to
be

    
    
    0
    
    1
    
    2
    
    3
    
    4
    
    5
    
    6
    
    7
    
    8
    
    9

Remember what we mentioned earlier about variable capturing? Every function
expression we pass to `setTimeout` actually refers to the same `i` from the
same scope.

Let‚Äôs take a minute to consider what that means. `setTimeout` will run a
function after some number of milliseconds, _but only_ after the `for` loop
has stopped executing; By the time the `for` loop has stopped executing, the
value of `i` is `10`. So each time the given function gets called, it will
print out `10`!

A common work around is to use an IIFE - an Immediately Invoked Function
Expression - to capture `i` at each iteration:

    
    
    ts
    
    for (var i = 0; i < 10; i++) {
    
      // capture the current state of 'i'
    
      // by invoking a function with its current value
    
      (function (i) {
    
        setTimeout(function () {
    
          console.log(i);
    
        }, 100 * i);
    
      })(i);
    
    }

This odd-looking pattern is actually pretty common. The `i` in the parameter
list actually shadows the `i` declared in the `for` loop, but since we named
them the same, we didn‚Äôt have to modify the loop body too much.

## `let` declarations

By now you‚Äôve figured out that `var` has some problems, which is precisely why
`let` statements were introduced. Apart from the keyword used, `let`
statements are written the same way `var` statements are.

    
    
    ts
    
    let hello = "Hello!";

The key difference is not in the syntax, but in the semantics, which we‚Äôll now
dive into.

### Block-scoping

When a variable is declared using `let`, it uses what some call _lexical-
scoping_ or _block-scoping_. Unlike variables declared with `var` whose scopes
leak out to their containing function, block-scoped variables are not visible
outside of their nearest containing block or `for`-loop.

    
    
    ts
    
    function f(input: boolean) {
    
      let a = 100;
    
      if (input) {
    
        // Still okay to reference 'a'
    
        let b = a + 1;
    
        return b;
    
      }
    
      // Error: 'b' doesn't exist here
    
      return b;
    
    }

Here, we have two local variables `a` and `b`. `a`‚Äôs scope is limited to the
body of `f` while `b`‚Äôs scope is limited to the containing `if` statement‚Äôs
block.

Variables declared in a `catch` clause also have similar scoping rules.

    
    
    ts
    
    try {
    
      throw "oh no!";
    
    } catch (e) {
    
      console.log("Oh well.");
    
    }
    
    // Error: 'e' doesn't exist here
    
    console.log(e);

Another property of block-scoped variables is that they can‚Äôt be read or
written to before they‚Äôre actually declared. While these variables are
‚Äúpresent‚Äù throughout their scope, all points up until their declaration are
part of their _temporal dead zone_. This is just a sophisticated way of saying
you can‚Äôt access them before the `let` statement, and luckily TypeScript will
let you know that.

    
    
    ts
    
    a++; // illegal to use 'a' before it's declared;
    
    let a;

Something to note is that you can still _capture_ a block-scoped variable
before it‚Äôs declared. The only catch is that it‚Äôs illegal to call that
function before the declaration. If targeting ES2015, a modern runtime will
throw an error; however, right now TypeScript is permissive and won‚Äôt report
this as an error.

    
    
    ts
    
    function foo() {
    
      // okay to capture 'a'
    
      return a;
    
    }
    
    // illegal call 'foo' before 'a' is declared
    
    // runtimes should throw an error here
    
    foo();
    
    let a;

For more information on temporal dead zones, see relevant content on the
[Mozilla Developer
Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).

### Re-declarations and Shadowing

With `var` declarations, we mentioned that it didn‚Äôt matter how many times you
declared your variables; you just got one.

    
    
    ts
    
    function f(x) {
    
      var x;
    
      var x;
    
      if (true) {
    
        var x;
    
      }
    
    }

In the above example, all declarations of `x` actually refer to the _same_
`x`, and this is perfectly valid. This often ends up being a source of bugs.
Thankfully, `let` declarations are not as forgiving.

    
    
    ts
    
    let x = 10;
    
    let x = 20; // error: can't re-declare 'x' in the same scope

The variables don‚Äôt necessarily need to both be block-scoped for TypeScript to
tell us that there‚Äôs a problem.

    
    
    ts
    
    function f(x) {
    
      let x = 100; // error: interferes with parameter declaration
    
    }
    
    function g() {
    
      let x = 100;
    
      var x = 100; // error: can't have both declarations of 'x'
    
    }

That‚Äôs not to say that a block-scoped variable can never be declared with a
function-scoped variable. The block-scoped variable just needs to be declared
within a distinctly different block.

    
    
    ts
    
    function f(condition, x) {
    
      if (condition) {
    
        let x = 100;
    
        return x;
    
      }
    
      return x;
    
    }
    
    f(false, 0); // returns '0'
    
    f(true, 0); // returns '100'

The act of introducing a new name in a more nested scope is called
_shadowing_. It is a bit of a double-edged sword in that it can introduce
certain bugs on its own in the event of accidental shadowing, while also
preventing certain bugs. For instance, imagine we had written our earlier
`sumMatrix` function using `let` variables.

    
    
    ts
    
    function sumMatrix(matrix: number[][]) {
    
      let sum = 0;
    
      for (let i = 0; i < matrix.length; i++) {
    
        var currentRow = matrix[i];
    
        for (let i = 0; i < currentRow.length; i++) {
    
          sum += currentRow[i];
    
        }
    
      }
    
      return sum;
    
    }

This version of the loop will actually perform the summation correctly because
the inner loop‚Äôs `i` shadows `i` from the outer loop.

Shadowing should _usually_ be avoided in the interest of writing clearer code.
While there are some scenarios where it may be fitting to take advantage of
it, you should use your best judgement.

### Block-scoped variable capturing

When we first touched on the idea of variable capturing with `var`
declaration, we briefly went into how variables act once captured. To give a
better intuition of this, each time a scope is run, it creates an
‚Äúenvironment‚Äù of variables. That environment and its captured variables can
exist even after everything within its scope has finished executing.

    
    
    ts
    
    function theCityThatAlwaysSleeps() {
    
      let getCity;
    
      if (true) {
    
        let city = "Seattle";
    
        getCity = function () {
    
          return city;
    
        };
    
      }
    
      return getCity();
    
    }

Because we‚Äôve captured `city` from within its environment, we‚Äôre still able to
access it despite the fact that the `if` block finished executing.

Recall that with our earlier `setTimeout` example, we ended up needing to use
an IIFE to capture the state of a variable for every iteration of the `for`
loop. In effect, what we were doing was creating a new variable environment
for our captured variables. That was a bit of a pain, but luckily, you‚Äôll
never have to do that again in TypeScript.

`let` declarations have drastically different behavior when declared as part
of a loop. Rather than just introducing a new environment to the loop itself,
these declarations sort of create a new scope _per iteration_. Since this is
what we were doing anyway with our IIFE, we can change our old `setTimeout`
example to just use a `let` declaration.

    
    
    ts
    
    for (let i = 0; i < 10; i++) {
    
      setTimeout(function () {
    
        console.log(i);
    
      }, 100 * i);
    
    }

and as expected, this will print out

    
    
    0
    
    1
    
    2
    
    3
    
    4
    
    5
    
    6
    
    7
    
    8
    
    9

## `const` declarations

`const` declarations are another way of declaring variables.

    
    
    ts
    
    const numLivesForCat = 9;

They are like `let` declarations but, as their name implies, their value
cannot be changed once they are bound. In other words, they have the same
scoping rules as `let`, but you can‚Äôt re-assign to them.

This should not be confused with the idea that the values they refer to are
_immutable_.

    
    
    ts
    
    const numLivesForCat = 9;
    
    const kitty = {
    
      name: "Aurora",
    
      numLives: numLivesForCat,
    
    };
    
    // Error
    
    kitty = {
    
      name: "Danielle",
    
      numLives: numLivesForCat,
    
    };
    
    // all "okay"
    
    kitty.name = "Rory";
    
    kitty.name = "Kitty";
    
    kitty.name = "Cat";
    
    kitty.numLives--;

Unless you take specific measures to avoid it, the internal state of a `const`
variable is still modifiable. Fortunately, TypeScript allows you to specify
that members of an object are `readonly`. The [chapter on
Interfaces](/docs/handbook/interfaces.html) has the details.

## `let` vs. `const`

Given that we have two types of declarations with similar scoping semantics,
it‚Äôs natural to find ourselves asking which one to use. Like most broad
questions, the answer is: it depends.

Applying the [principle of least
privilege](https://wikipedia.org/wiki/Principle_of_least_privilege), all
declarations other than those you plan to modify should use `const`. The
rationale is that if a variable didn‚Äôt need to get written to, others working
on the same codebase shouldn‚Äôt automatically be able to write to the object,
and will need to consider whether they really need to reassign to the
variable. Using `const` also makes code more predictable when reasoning about
flow of data.

Use your best judgement, and if applicable, consult the matter with the rest
of your team.

The majority of this handbook uses `let` declarations.

## Destructuring

Another ECMAScript 2015 feature that TypeScript has is destructuring. For a
complete reference, see [the article on the Mozilla Developer
Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
In this section, we‚Äôll give a short overview.

### Array destructuring

The simplest form of destructuring is array destructuring assignment:

    
    
    ts
    
    let input = [1, 2];
    
    let [first, second] = input;
    
    console.log(first); // outputs 1
    
    console.log(second); // outputs 2

This creates two new variables named `first` and `second`. This is equivalent
to using indexing, but is much more convenient:

    
    
    ts
    
    first = input[0];
    
    second = input[1];

Destructuring works with already-declared variables as well:

    
    
    ts
    
    // swap variables
    
    [first, second] = [second, first];

And with parameters to a function:

    
    
    ts
    
    function f([first, second]: [number, number]) {
    
      console.log(first);
    
      console.log(second);
    
    }
    
    f([1, 2]);

You can create a variable for the remaining items in a list using the syntax
`...`:

    
    
    ts
    
    let [first, ...rest] = [1, 2, 3, 4];
    
    console.log(first); // outputs 1
    
    console.log(rest); // outputs [ 2, 3, 4 ]

Of course, since this is JavaScript, you can just ignore trailing elements you
don‚Äôt care about:

    
    
    ts
    
    let [first] = [1, 2, 3, 4];
    
    console.log(first); // outputs 1

Or other elements:

    
    
    ts
    
    let [, second, , fourth] = [1, 2, 3, 4];
    
    console.log(second); // outputs 2
    
    console.log(fourth); // outputs 4

### Tuple destructuring

Tuples may be destructured like arrays; the destructuring variables get the
types of the corresponding tuple elements:

    
    
    ts
    
    let tuple: [number, string, boolean] = [7, "hello", true];
    
    let [a, b, c] = tuple; // a: number, b: string, c: boolean

It‚Äôs an error to destructure a tuple beyond the range of its elements:

    
    
    ts
    
    let [a, b, c, d] = tuple; // Error, no element at index 3

As with arrays, you can destructure the rest of the tuple with `...`, to get a
shorter tuple:

    
    
    ts
    
    let [a, ...bc] = tuple; // bc: [string, boolean]
    
    let [a, b, c, ...d] = tuple; // d: [], the empty tuple

Or ignore trailing elements, or other elements:

    
    
    ts
    
    let [a] = tuple; // a: number
    
    let [, b] = tuple; // b: string

### Object destructuring

You can also destructure objects:

    
    
    ts
    
    let o = {
    
      a: "foo",
    
      b: 12,
    
      c: "bar",
    
    };
    
    let { a, b } = o;

This creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you
can skip `c` if you don‚Äôt need it.

Like array destructuring, you can have assignment without declaration:

    
    
    ts
    
    ({ a, b } = { a: "baz", b: 101 });

Notice that we had to surround this statement with parentheses. JavaScript
normally parses a `{` as the start of block.

You can create a variable for the remaining items in an object using the
syntax `...`:

    
    
    ts
    
    let { a, ...passthrough } = o;
    
    let total = passthrough.b + passthrough.c.length;

#### Property renaming

You can also give different names to properties:

    
    
    ts
    
    let { a: newName1, b: newName2 } = o;

Here the syntax starts to get confusing. You can read `a: newName1` as ‚Äù`a` as
`newName1`‚Äù. The direction is left-to-right, as if you had written:

    
    
    ts
    
    let newName1 = o.a;
    
    let newName2 = o.b;

Confusingly, the colon here does _not_ indicate the type. The type, if you
specify it, still needs to be written after the entire destructuring:

    
    
    ts
    
    let { a: newName1, b: newName2 }: { a: string; b: number } = o;

#### Default values

Default values let you specify a default value in case a property is
undefined:

    
    
    ts
    
    function keepWholeObject(wholeObject: { a: string; b?: number }) {
    
      let { a, b = 1001 } = wholeObject;
    
    }

In this example the `b?` indicates that `b` is optional, so it may be
`undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as
the properties `a` and `b`, even if `b` is undefined.

## Function declarations

Destructuring also works in function declarations. For simple cases this is
straightforward:

    
    
    ts
    
    type C = { a: string; b?: number };
    
    function f({ a, b }: C): void {
    
      // ...
    
    }

But specifying defaults is more common for parameters, and getting defaults
right with destructuring can be tricky. First of all, you need to remember to
put the pattern before the default value.

    
    
    ts
    
    function f({ a = "", b = 0 } = {}): void {
    
      // ...
    
    }
    
    f();

> The snippet above is an example of type inference, explained earlier in the
> handbook.

Then, you need to remember to give a default for optional properties on the
destructured property instead of the main initializer. Remember that `C` was
defined with `b` optional:

    
    
    ts
    
    function f({ a, b = 0 } = { a: "" }): void {
    
      // ...
    
    }
    
    f({ a: "yes" }); // ok, default b = 0
    
    f(); // ok, default to { a: "" }, which then defaults b = 0
    
    f({}); // error, 'a' is required if you supply an argument

Use destructuring with care. As the previous example demonstrates, anything
but the simplest destructuring expression is confusing. This is especially
true with deeply nested destructuring, which gets _really_ hard to understand
even without piling on renaming, default values, and type annotations. Try to
keep destructuring expressions small and simple. You can always write the
assignments that destructuring would generate yourself.

## Spread

The spread operator is the opposite of destructuring. It allows you to spread
an array into another array, or an object into another object. For example:

    
    
    ts
    
    let first = [1, 2];
    
    let second = [3, 4];
    
    let bothPlus = [0, ...first, ...second, 5];

This gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a
shallow copy of `first` and `second`. They are not changed by the spread.

You can also spread objects:

    
    
    ts
    
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    
    let search = { ...defaults, food: "rich" };

Now `search` is `{ food: "rich", price: "$$", ambiance: "noisy" }`. Object
spreading is more complex than array spreading. Like array spreading, it
proceeds from left-to-right, but the result is still an object. This means
that properties that come later in the spread object overwrite properties that
come earlier. So if we modify the previous example to spread at the end:

    
    
    ts
    
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    
    let search = { food: "rich", ...defaults };

Then the `food` property in `defaults` overwrites `food: "rich"`, which is not
what we want in this case.

Object spread also has a couple of other surprising limits. First, it only
includes an objects‚Äô [own, enumerable
properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
Basically, that means you lose methods when you spread instances of an object:

    
    
    ts
    
    class C {
    
      p = 12;
    
      m() {}
    
    }
    
    let c = new C();
    
    let clone = { ...c };
    
    clone.p; // ok
    
    clone.m(); // error!

Second, the TypeScript compiler doesn‚Äôt allow spreads of type parameters from
generic functions. That feature is expected in future versions of the
language.

## `using` declarations

`using` declarations are an upcoming feature for JavaScript that are part of
the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-
explicit-resource-management) proposal. A `using` declaration is much like a
`const` declaration, except that it couples the _lifetime_ of the value bound
to the declaration with the _scope_ of the variable.

When control exits the block containing a `using` declaration, the
`[Symbol.dispose]()` method of the declared value is executed, which allows
that value to perform cleanup:

    
    
    ts
    
    function f() {
    
      using x = new C();
    
      doSomethingWith(x);
    
    } // `x[Symbol.dispose]()` is called

At runtime, this has an effect _roughly_ equivalent to the following:

    
    
    ts
    
    function f() {
    
      const x = new C();
    
      try {
    
        doSomethingWith(x);
    
      }
    
      finally {
    
        x[Symbol.dispose]();
    
      }
    
    }

`using` declarations are extremely useful for avoiding memory leaks when
working with JavaScript objects that hold on to native references like file
handles

    
    
    ts
    
    {
    
      using file = await openFile();
    
      file.write(text);
    
      doSomethingThatMayThrow();
    
    } // `file` is disposed, even if an error is thrown

or scoped operations like tracing

    
    
    ts
    
    function f() {
    
      using activity = new TraceActivity("f"); // traces entry into function
    
      // ...
    
    } // traces exit of function

Unlike `var`, `let`, and `const`, `using` declarations do not support
destructuring.

### `null` and `undefined`

It‚Äôs important to note that the value can be `null` or `undefined`, in which
case nothing is disposed at the end of the block:

    
    
    ts
    
    {
    
      using x = b ? new C() : null;
    
      // ...
    
    }

which is _roughly_ equivalent to:

    
    
    ts
    
    {
    
      const x = b ? new C() : null;
    
      try {
    
        // ...
    
      }
    
      finally {
    
        x?.[Symbol.dispose]();
    
      }
    
    }

This allows you to conditionally acquire resources when declaring a `using`
declaration without the need for complex branching or repetition.

### Defining a disposable resource

You can indicate the classes or objects you produce are disposable by
implementing the `Disposable` interface:

    
    
    ts
    
    // from the default lib:
    
    interface Disposable {
    
      [Symbol.dispose](): void;
    
    }
    
    // usage:
    
    class TraceActivity implements Disposable {
    
      readonly name: string;
    
      constructor(name: string) {
    
        this.name = name;
    
        console.log(`Entering: ${name}`);
    
      }
    
      [Symbol.dispose](): void {
    
        console.log(`Exiting: ${name}`);
    
      }
    
    }
    
    function f() {
    
      using _activity = new TraceActivity("f");
    
      console.log("Hello world!");
    
    }
    
    f();
    
    // prints:
    
    //   Entering: f
    
    //   Hello world!
    
    //   Exiting: f

## `await using` declarations

Some resources or operations may have cleanup that needs to be performed
asynchronously. To accommodate this, the [Explicit Resource
Management](https://github.com/tc39/proposal-explicit-resource-management)
proposal also introduces the `await using` declaration:

    
    
    ts
    
    async function f() {
    
      await using x = new C();
    
    } // `await x[Symbol.asyncDispose]()` is invoked

An `await using` declaration invokes, and _awaits_ , its value‚Äôs
`[Symbol.asyncDispose]()` method as control leaves the containing block. This
allows for asynchronous cleanup, such as a database transaction performing a
rollback or commit, or a file stream flushing any pending writes to storage
before it is closed.

As with `await`, `await using` can only be used in an `async` function or
method, or at the top level of a module.

### Defining an asynchronously disposable resource

Just as `using` relies on objects that are `Disposable`, an `await using`
relies on objects that are `AsyncDisposable`:

    
    
    ts
    
    // from the default lib:
    
    interface AsyncDisposable {
    
      [Symbol.asyncDispose]: PromiseLike<void>;
    
    }
    
    // usage:
    
    class DatabaseTransaction implements AsyncDisposable {
    
      public success = false;
    
      private db: Database | undefined;
    
      private constructor(db: Database) {
    
        this.db = db;
    
      }
    
      static async create(db: Database) {
    
        await db.execAsync("BEGIN TRANSACTION");
    
        return new DatabaseTransaction(db);
    
      }
    
      async [Symbol.asyncDispose]() {
    
        if (this.db) {
    
          const db = this.db:
    
          this.db = undefined;
    
          if (this.success) {
    
            await db.execAsync("COMMIT TRANSACTION");
    
          }
    
          else {
    
            await db.execAsync("ROLLBACK TRANSACTION");
    
          }
    
        }
    
      }
    
    }
    
    async function transfer(db: Database, account1: Account, account2: Account, amount: number) {
    
      using tx = await DatabaseTransaction.create(db);
    
      if (await debitAccount(db, account1, amount)) {
    
        await creditAccount(db, account2, amount);
    
      }
    
      // if an exception is thrown before this line, the transaction will roll back
    
      tx.success = true;
    
      // now the transaction will commit
    
    }

### `await using` vs `await`

The `await` keyword that is part of the `await using` declaration only
indicates that the _disposal_ of the resource is `await`-ed. It does _not_
`await` the value itself:

    
    
    ts
    
    {
    
      await using x = getResourceSynchronously();
    
    } // performs `await x[Symbol.asyncDispose]()`
    
    {
    
      await using y = await getResourceAsynchronously();
    
    } // performs `await y[Symbol.asyncDispose]()`

### `await using` and `return`

It‚Äôs important to note that there is a small caveat with this behavior if you
are using an `await using` declaration in an `async` function that returns a
`Promise` without first `await`-ing it:

    
    
    ts
    
    function g() {
    
      return Promise.reject("error!");
    
    }
    
    async function f() {
    
      await using x = new C();
    
      return g(); // missing an `await`
    
    }

Because the returned promise isn‚Äôt `await`-ed, it‚Äôs possible that the
JavaScript runtime may report an unhandled rejection since execution pauses
while `await`-ing the asynchronous disposal of `x`, without having subscribed
to the returned promise. This is not a problem that is unique to `await
using`, however, as this can also occur in an `async` function that uses
`try..finally`:

    
    
    ts
    
    async function f() {
    
      try {
    
        return g(); // also reports an unhandled rejection
    
      }
    
      finally {
    
        await somethingElse();
    
      }
    
    }

To avoid this situation, it is recommended that you `await` your return value
if it may be a `Promise`:

    
    
    ts
    
    async function f() {
    
      await using x = new C();
    
      return await g();
    
    }

## `using` and `await using` in `for` and `for..of` statements

Both `using` and `await using` can be used in a `for` statement:

    
    
    ts
    
    for (using x = getReader(); !x.eof; x.next()) {
    
      // ...
    
    }

In this case, the lifetime of `x` is scoped to the entire `for` statement and
is only disposed when control leaves the loop due to `break`, `return`,
`throw`, or when the loop condition is false.

In addition to `for` statements, both declarations can also be used in
`for..of` statements:

    
    
    ts
    
    function * g() {
    
      yield createResource1();
    
      yield createResource2();
    
    }
    
    for (using x of g()) {
    
      // ...
    
    }

Here, `x` is disposed at the end of _each iteration of the loop_ , and is then
reinitialized with the next value. This is especially useful when consuming
resources produced one at a time by a generator.

## `using` and `await using` in older runtimes

`using` and `await using` declarations can be used when targeting older
ECMAScript editions as long as you are using a compatible polyfill for
`Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in
recent editions of NodeJS.

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)

The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Variable
Declarations.md) ‚ù§

Contributors to this page:  

DR![Daniel Rosenwasser
\(58\)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)

OT![Orta Therox
\(20\)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)

NS![Nathan Shively-Sanders
\(9\)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)

VR![Vimal Raghubir
\(3\)](https://gravatar.com/avatar/9bd70673d4a0c3ab8461871af1896215?s=32&&d=blank)

BC![Brett Cannon
\(3\)](https://gravatar.com/avatar/962cb4064811fd8c78dfc01eb27d4871?s=32&&d=blank)

24+

Last updated: Sep 16, 2024  
  

  # Download TypeScript

TypeScript can be installed through three installation routes depending on how
you intend to use it: an npm module, a NuGet package or a Visual Studio
Extension.

If you are using Node.js, you want the npm version. If you are using MSBuild
in your project, you want the NuGet package or Visual Studio extension.

## TypeScript in Your Project

Having TypeScript set up on a per-project basis lets you have many projects
with many different versions of TypeScript, this keeps each project working
consistently.

### via npm

TypeScript is available as a [package on the npm
registry](https://www.npmjs.com/package/typescript) available as
`"typescript"`.

You will need a copy of [Node.js](https://nodejs.org/en/ "Link to the node.js
project") as an environment to run the package. Then you use a dependency
manager like [npm](https://www.npmjs.com/ "Link to the npm package manager"),
[yarn](https://yarnpkg.com/ "Link to the yarn package manager") or
[pnpm](https://pnpm.js.org/ "Link to the pnpm package manager") to download
TypeScript into your project.

`npm install typescript --save-dev`  
  
npm yarn pnpm

All of these dependency managers support lockfiles, ensuring that everyone on
your team is using the same version of the language. You can then run the
TypeScript compiler using one of the following commands:

`npx tsc`  
  
npm yarn pnpm

### with Visual Studio

For most project types, you can get TypeScript as a package in Nuget for your
MSBuild projects, for example an ASP.NET Core app.

When using Nuget, you can [install TypeScript through Visual
Studio](https://learn.microsoft.com/visualstudio/javascript/tutorial-aspnet-
with-typescript) using:

  * The Manage NuGet Packages window (which you can get to by right-clicking on a project node)
  * The Nuget Package Manager Console (found in Tools > NuGet Package Manager > Package Manager Console) and then running:  
`Install-Package Microsoft.TypeScript.MSBuild`

For project types which don't support Nuget, you can use the [ TypeScript
Visual Studio
extension](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494).
You can [install the
extension](https://learn.microsoft.com/visualstudio/ide/finding-and-using-
visual-studio-extensions) using `Extensions > Manage Extensions` in Visual
Studio.

The examples below are for more advanced use cases.

## Globally Installing TypeScript

It can be handy to have TypeScript available across all projects, often to
test one-off ideas. Long-term, codebases should prefer a project-wide
installation over a global install so that they can benefit from reproducible
builds across different machines.

### via npm

You can use npm to install TypeScript globally, this means that you can use
the `tsc` command anywhere in your terminal.

To do this, run `npm install -g typescript`. This will install the latest
version (currently 5.6).

### via Visual Studio Marketplace

You can install TypeScript as a Visual Studio extension, which will allow you
to use TypeScript across many MSBuild projects in Visual Studio.

The latest version is available [in the Visual Studio
Marketplace](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494
"Link to the Visual Studio Marketplace for the TypeScript MSBuild extension").

## Working with TypeScript-compatible transpilers

There are other tools which convert TypeScript files to JavaScript files. You
might use these tools for speed or consistency with your existing build
tooling.

Each of these projects handle the file conversion, but do not handle the type-
checking aspects of the TypeScript compiler. So it's likely that you will
still need to keep the above TypeScript dependency around, and you will want
to enable [`isolatedModules`](/tsconfig/#isolatedModules).

### Babel

[Babel](https://babeljs.io/) is a very popular JavaScript transpiler which
supports TypeScript files via the plugin [@babel/plugin-transform-
typescript](https://babeljs.io/docs/en/babel-preset-typescript#docsNav).

### swc

[swc](https://swc-project.github.io/docs/installation/) is a fast transpiler
created in Rust which supports many of Babel's features including TypeScript.

### Sucrase

[Sucrase](https://github.com/alangpierce/sucrase#sucrase/) is a Babel fork
focused on speed for using in development mode. Sucrase supports TypeScript
natively.

## Next Steps

#### Get Started

  * [JS to TS](/docs/handbook/typescript-in-5-minutes.html)
  * [New to Programming](/docs/handbook/typescript-from-scratch.html)
  * [OOP to JS](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [Functional to JS](/docs/handbook/typescript-in-5-minutes-func.html)
  * [Installation](/download/)

#### Handbook

  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * [Variable Declarations](/docs/handbook/variable-declarations.html)
  * [More on Functions](/docs/handbook/2/functions.html)

#### Tools

  * [Playground](/play/)
  * [TSConfig Reference](/tsconfig/)

#### Release Notes

  * [What's new in 5.6](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/)

#### Tutorials

  * [ASP.NET](/docs/handbook/asp-net-core.html)
  * [Migrating from JS](/docs/handbook/migrating-from-javascript.html)
  * [Working with the DOM](/docs/handbook/dom-manipulation.html)
  * [React & Webpack](/docs/handbook/react-&-webpack.html)

 # Download TypeScript

TypeScript can be installed through three installation routes depending on how
you intend to use it: an npm module, a NuGet package or a Visual Studio
Extension.

If you are using Node.js, you want the npm version. If you are using MSBuild
in your project, you want the NuGet package or Visual Studio extension.

## TypeScript in Your Project

Having TypeScript set up on a per-project basis lets you have many projects
with many different versions of TypeScript, this keeps each project working
consistently.

### via npm

TypeScript is available as a [package on the npm
registry](https://www.npmjs.com/package/typescript) available as
`"typescript"`.

You will need a copy of [Node.js](https://nodejs.org/en/ "Link to the node.js
project") as an environment to run the package. Then you use a dependency
manager like [npm](https://www.npmjs.com/ "Link to the npm package manager"),
[yarn](https://yarnpkg.com/ "Link to the yarn package manager") or
[pnpm](https://pnpm.js.org/ "Link to the pnpm package manager") to download
TypeScript into your project.

`npm install typescript --save-dev`  
  
npm yarn pnpm

All of these dependency managers support lockfiles, ensuring that everyone on
your team is using the same version of the language. You can then run the
TypeScript compiler using one of the following commands:

`npx tsc`  
  
npm yarn pnpm

### with Visual Studio

For most project types, you can get TypeScript as a package in Nuget for your
MSBuild projects, for example an ASP.NET Core app.

When using Nuget, you can [install TypeScript through Visual
Studio](https://learn.microsoft.com/visualstudio/javascript/tutorial-aspnet-
with-typescript) using:

  * The Manage NuGet Packages window (which you can get to by right-clicking on a project node)
  * The Nuget Package Manager Console (found in Tools > NuGet Package Manager > Package Manager Console) and then running:  
`Install-Package Microsoft.TypeScript.MSBuild`

For project types which don't support Nuget, you can use the [ TypeScript
Visual Studio
extension](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494).
You can [install the
extension](https://learn.microsoft.com/visualstudio/ide/finding-and-using-
visual-studio-extensions) using `Extensions > Manage Extensions` in Visual
Studio.

The examples below are for more advanced use cases.

## Globally Installing TypeScript

It can be handy to have TypeScript available across all projects, often to
test one-off ideas. Long-term, codebases should prefer a project-wide
installation over a global install so that they can benefit from reproducible
builds across different machines.

### via npm

You can use npm to install TypeScript globally, this means that you can use
the `tsc` command anywhere in your terminal.

To do this, run `npm install -g typescript`. This will install the latest
version (currently 5.6).

### via Visual Studio Marketplace

You can install TypeScript as a Visual Studio extension, which will allow you
to use TypeScript across many MSBuild projects in Visual Studio.

The latest version is available [in the Visual Studio
Marketplace](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494
"Link to the Visual Studio Marketplace for the TypeScript MSBuild extension").

## Working with TypeScript-compatible transpilers

There are other tools which convert TypeScript files to JavaScript files. You
might use these tools for speed or consistency with your existing build
tooling.

Each of these projects handle the file conversion, but do not handle the type-
checking aspects of the TypeScript compiler. So it's likely that you will
still need to keep the above TypeScript dependency around, and you will want
to enable [`isolatedModules`](/tsconfig/#isolatedModules).

### Babel

[Babel](https://babeljs.io/) is a very popular JavaScript transpiler which
supports TypeScript files via the plugin [@babel/plugin-transform-
typescript](https://babeljs.io/docs/en/babel-preset-typescript#docsNav).

### swc

[swc](https://swc-project.github.io/docs/installation/) is a fast transpiler
created in Rust which supports many of Babel's features including TypeScript.

### Sucrase

[Sucrase](https://github.com/alangpierce/sucrase#sucrase/) is a Babel fork
focused on speed for using in development mode. Sucrase supports TypeScript
natively.

## Next Steps

#### Get Started

  * [JS to TS](/docs/handbook/typescript-in-5-minutes.html)
  * [New to Programming](/docs/handbook/typescript-from-scratch.html)
  * [OOP to JS](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [Functional to JS](/docs/handbook/typescript-in-5-minutes-func.html)
  * [Installation](/download/)

#### Handbook

  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * [Variable Declarations](/docs/handbook/variable-declarations.html)
  * [More on Functions](/docs/handbook/2/functions.html)

#### Tools

  * [Playground](/play/)
  * [TSConfig Reference](/tsconfig/)

#### Release Notes

  * [What's new in 5.6](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/)

#### Tutorials

  * [ASP.NET](/docs/handbook/asp-net-core.html)
  * [Migrating from JS](/docs/handbook/migrating-from-javascript.html)
  * [Working with the DOM](/docs/handbook/dom-manipulation.html)
  * [React & Webpack](/docs/handbook/react-&-webpack.html)

 # TypeScript is **JavaScript with syntax for types.**

TypeScript is a strongly typed programming language that builds on JavaScript,
giving you better tooling at any scale.

[Try TypeScript NowOnline or via npm](/download)

  * Editor Checks
  * Auto-complete
  * Interfaces
  * JSX

    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†
    
    
    ts
    
    const user = {
    
      firstName: "Angela",
    
      lastName: "Davis",
    
      role: "Professor",
    
    }
    
    ¬†
    
    console.log(user.name)
    
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    
    ¬†

[TypeScript 5.6](https://devblogs.microsoft.com/typescript/announcing-
typescript-5-6/) is now available

## What is TypeScript?

### JavaScript and More

TypeScript adds additional syntax to JavaScript to support a **tighter
integration with your editor**. Catch errors early in your editor.

### A Result You Can Trust

TypeScript code converts to JavaScript, which **runs anywhere JavaScript
runs** : In a browser, on Node.js or Deno and in your apps.

### Safety at Scale

TypeScript understands JavaScript and uses **type inference to give you great
tooling** without additional code.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

## Adopt TypeScript Gradually

Apply types to your JavaScript project incrementally, **each step improves
editor support** and improves your codebase.

Let's take this incorrect JavaScript code, and see how **TypeScript can catch
mistakes in your editor**.

    
    
    js
    
    function compact(arr) {
    
        if (orr.length > 10)
    
            return arr.trim(0, 10)
    
        return arr
    
    }

No editor warnings in JavaScript files  
  
This code crashes at runtime!

JavaScript file

    
    
    js
    
    // @ts-check
    
    ¬†
    
    function compact(arr) {
    
      if (orr.length > 10)
    
    Cannot find name 'orr'.2304Cannot find name 'orr'.
    
        return arr.trim(0, 10)
    
      return arr
    
    }

Adding this to a JS file shows errors in your editor

the param is arr, not orr!

JavaScript with TS Check

    
    
    js
    
    // @ts-check
    
    ¬†
    
    /** @param {any[]} arr */
    
    function compact(arr) {
    
        if (arr.length > 10)
    
          return arr.trim(0, 10)
    
    Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.
    
        return arr
    
      }

Using JSDoc to give type information

Now TS has found a bad call. Arrays have slice, not trim.

JavaScript with JSDoc

    
    
    ts
    
    function compact(arr: string[]) {
    
      if (arr.length > 10)
    
        return arr.slice(0, 10)
    
      return arr
    
    }

TypeScript adds natural syntax for providing types

TypeScript file

### Describe Your Data

**Describe the shape of objects and functions** in your code.

Making it possible to see **documentation and issues in your editor**.

    
    
    ts
    
    interface Account {
    
      id: number
    
      displayName: string
    
      version: 1
    
    }
    
    ¬†
    
    function welcome(user: Account) {
    
      console.log(user.id)
    
    }
    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }

## TypeScript becomes JavaScript via the delete key.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**TypeScript file**.

    
    
    ts
    
    type Result = "pass" | "fail"
    
    ¬†
    
    function verify(result: Result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**Types are removed**.

    
    
    js
    
    ¬†
    
    ¬†
    
    function verify(result) {
    
      if (result === "pass") {
    
        console.log("Passed")
    
      } else {
    
        console.log("Failed")
    
      }
    
    }
    
    ¬†

**JavaScript file**.

## TypeScript Testimonials

**First** , we were surprised by the number of small bugs we found when
converting our code.

**Second** , we underestimated how powerful the editor integration is.

TypeScript was such a boon to our stability and sanity that we started using
it for all new code within days of starting the conversion.

Felix Rieseberg at Slack covered the transition of their desktop app from
JavaScript to TypeScript in their blog

[Read](https://slack.engineering/typescript-at-slack-a81307fa288d)

### Open Source with TypeScript

[Angular](https://angular.io/)[Vue](https://vuejs.org/)[Jest](https://jestjs.io/)[Redux](https://redux.js.org/)[Ionic](https://ionicframework.com/)[Probot](https://probot.github.io/)[Deno](https://deno.land/)[Vercel](https://github.com/vercel/vercel)[Yarn](https://yarnpkg.com/)[GitHub  
Desktop](https://github.com/desktop/desktop/)

## Loved by Developers

![Image of the stack overflow logo, and a graph showing TypeScript as the 2nd
most popular language](/images/index/stack-overflow.svg)

Voted **2nd most loved programming language** in the [Stack Overflow 2020
Developer survey](https://insights.stackoverflow.com/survey/2020#most-loved-
dreaded-and-wanted)

![Logo of the State of JS survey](/images/index/state-of-js.svg)

TypeScript was **used by 78%** of the [2020 State of
JS](https://2020.stateofjs.com/en-US/technologies/javascript-flavors/)
respondents, with **93% saying they would use it again**.

TypeScript was given the award for **‚ÄúMost Adopted Technology‚Äù** based on
year-on-year growth.

## Get Started

[HandbookLearn the language](/docs/handbook/intro.html)

[PlaygroundTry in your browser](/play)

[DownloadInstall TypeScript](/download/)

 Downloading TypeScript...

  * Version...... 
  * Run
  * Export
    * Tweet link to Playground
    *     * Copy as Markdown Issue
    * Copy as Markdown Link
    * Copy as Markdown Link with Preview
    *     * Open in TypeScript AST Viewer
    * Open in Bug Workbench
    * Open in VSCode TS Playground (alpha)
    *     * Open in CodeSandbox
    * Open in StackBlitz
  * Share

  * ‚á•

 Downloading TypeScript...

  * Version...... 
  * Run
  * Export
    * Tweet link to Playground
    *     * Copy as Markdown Issue
    * Copy as Markdown Link
    * Copy as Markdown Link with Preview
    *     * Open in TypeScript AST Viewer
    * Open in Bug Workbench
    * Open in VSCode TS Playground (alpha)
    *     * Open in CodeSandbox
    * Open in StackBlitz
  * Share

  * ‚á•

 [![Preview of the TypeScript Playground
screenshot](/static/play-03b12a3d83a6a50a7fde7a2b663f482d.png)Playground](/play)

A live environment for exploring, learning and sharing TypeScript code. Try
different compiler flags, run through extensive code samples to learn
specifics about how TypeScript works.

[![Preview of the TypeScript TSConfig Reference screenshot](/static/tsconfig-
ref-cf26083c052d3495a7f06f12850b28f1.png)TSConfig Reference](/tsconfig/)

An annotated reference to more than a hundred compiler options available in a
`tsconfig.json` or `jsconfig.json`.

[![Preview of the cheat sheets page](/static/cheat-
sheets-30af7529402f347061db3c6eacdf40ab.png)Cheat Sheets](/cheatsheets)

Quickly look up the syntax for common TypeScript code.

 Intro to the TSConfig ReferenceA TSConfig file in a directory indicates that
the directory is the root of a TypeScript or JavaScript project...

## Compiler Options

##### Top Level

  1. `files, `
  2. `extends, `
  3. `include, `
  4. `exclude and `
  5. `references`

#### `"compilerOptions"`

##### Type Checking

  1. `allowUnreachableCode, `
  2. `allowUnusedLabels, `
  3. `alwaysStrict, `
  4. `exactOptionalPropertyTypes, `
  5. `noFallthroughCasesInSwitch, `
  6. `noImplicitAny, `
  7. `noImplicitOverride, `
  8. `noImplicitReturns, `
  9. `noImplicitThis, `
  10. `noPropertyAccessFromIndexSignature, `
  11. `noUncheckedIndexedAccess, `
  12. `noUnusedLocals, `
  13. `noUnusedParameters, `
  14. `strict, `
  15. `strictBindCallApply, `
  16. `strictBuiltinIteratorReturn, `
  17. `strictFunctionTypes, `
  18. `strictNullChecks, `
  19. `strictPropertyInitialization and `
  20. `useUnknownInCatchVariables`

##### Modules

  1. `allowArbitraryExtensions, `
  2. `allowImportingTsExtensions, `
  3. `allowUmdGlobalAccess, `
  4. `baseUrl, `
  5. `customConditions, `
  6. `module, `
  7. `moduleResolution, `
  8. `moduleSuffixes, `
  9. `noResolve, `
  10. `noUncheckedSideEffectImports, `
  11. `paths, `
  12. `resolveJsonModule, `
  13. `resolvePackageJsonExports, `
  14. `resolvePackageJsonImports, `
  15. `rootDir, `
  16. `rootDirs, `
  17. `typeRoots and `
  18. `types`

##### Emit

  1. `declaration, `
  2. `declarationDir, `
  3. `declarationMap, `
  4. `downlevelIteration, `
  5. `emitBOM, `
  6. `emitDeclarationOnly, `
  7. `importHelpers, `
  8. `inlineSourceMap, `
  9. `inlineSources, `
  10. `mapRoot, `
  11. `newLine, `
  12. `noEmit, `
  13. `noEmitHelpers, `
  14. `noEmitOnError, `
  15. `outDir, `
  16. `outFile, `
  17. `preserveConstEnums, `
  18. `removeComments, `
  19. `sourceMap, `
  20. `sourceRoot and `
  21. `stripInternal`

##### JavaScript Support

  1. `allowJs, `
  2. `checkJs and `
  3. `maxNodeModuleJsDepth`

##### Editor Support

  1. `disableSizeLimit and `
  2. `plugins`

##### Interop Constraints

  1. `allowSyntheticDefaultImports, `
  2. `esModuleInterop, `
  3. `forceConsistentCasingInFileNames, `
  4. `isolatedDeclarations, `
  5. `isolatedModules, `
  6. `preserveSymlinks and `
  7. `verbatimModuleSyntax`

##### Backwards Compatibility

  1. `charset, `
  2. `importsNotUsedAsValues, `
  3. `keyofStringsOnly, `
  4. `noImplicitUseStrict, `
  5. `noStrictGenericChecks, `
  6. `out, `
  7. `preserveValueImports, `
  8. `suppressExcessPropertyErrors and `
  9. `suppressImplicitAnyIndexErrors`

##### Language and Environment

  1. `emitDecoratorMetadata, `
  2. `experimentalDecorators, `
  3. `jsx, `
  4. `jsxFactory, `
  5. `jsxFragmentFactory, `
  6. `jsxImportSource, `
  7. `lib, `
  8. `moduleDetection, `
  9. `noLib, `
  10. `reactNamespace, `
  11. `target and `
  12. `useDefineForClassFields`

##### Compiler Diagnostics

  1. `diagnostics, `
  2. `explainFiles, `
  3. `extendedDiagnostics, `
  4. `generateCpuProfile, `
  5. `generateTrace, `
  6. `listEmittedFiles, `
  7. `listFiles, `
  8. `noCheck and `
  9. `traceResolution`

##### Projects

  1. `composite, `
  2. `disableReferencedProjectLoad, `
  3. `disableSolutionSearching, `
  4. `disableSourceOfProjectReferenceRedirect, `
  5. `incremental and `
  6. `tsBuildInfoFile`

##### Output Formatting

  1. `noErrorTruncation, `
  2. `preserveWatchOutput and `
  3. `pretty`

##### Completeness

  1. `skipDefaultLibCheck and `
  2. `skipLibCheck`

##### Command Line

##### Watch Options

  1. `assumeChangesOnlyAffectDirectDependencies`

#### `"watchOptions"`

##### watchOptions

  1. `watchFile, `
  2. `watchDirectory, `
  3. `fallbackPolling, `
  4. `synchronousWatchDirectory, `
  5. `excludeDirectories and `
  6. `excludeFiles`

#### `"typeAcquisition"`

##### typeAcquisition

  1. `enable, `
  2. `include, `
  3. `exclude and `
  4. `disableFilenameBasedTypeAcquisition`

### Root Fields

Starting up are the root options in the TSConfig - these options relate to how
your TypeScript or JavaScript project is set up.

### # Files - `files`

Specifies an allowlist of files to include in the program. An error occurs if
any of the files can‚Äôt be found.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {},
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": [
    
        "core.ts",
    
        "sys.ts",
    
        "types.ts",
    
        "scanner.ts",
    
        "parser.ts",
    
        "utilities.ts",
    
        "binder.ts",
    
        "checker.ts",
    
        "tsc.ts"
    
      ]
    
    }

This is useful when you only have a small number of files and don‚Äôt need to
use a glob to reference many files. If you need that then use `include`.

  * Default:

`false`

  * Related:
    * `include`

    * `exclude`

### # Extends - `extends`

The value of `extends` is a string which contains a path to another
configuration file to inherit from. The path may use Node.js style resolution.

The configuration from the base file are loaded first, then overridden by
those in the inheriting config file. All relative paths found in the
configuration file will be resolved relative to the configuration file they
originated in.

It‚Äôs worth noting that `files`, `include`, and `exclude` from the inheriting
config file _overwrite_ those from the base config file, and that circularity
between configuration files is not allowed.

Currently, the only top-level property that is excluded from inheritance is
`references`.

##### Example

`configs/base.json`:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": true
    
      }
    
    }

`tsconfig.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./configs/base",
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["main.ts", "supplemental.ts"]
    
    }

`tsconfig.nostrictnull.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./tsconfig",
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": false
    
      }
    
    }

Properties with relative paths found in the configuration file, which aren‚Äôt
excluded from inheritance, will be resolved relative to the configuration file
they originated in.

  * Default:

`false`

  * Released:

[2.1](/docs/handbook/release-notes/typescript-2-1.html)

### # Include - `include`

Specifies an array of filenames or patterns to include in the program. These
filenames are resolved relative to the directory containing the
`tsconfig.json` file.

    
    
    json
    
    {
    
      "include": ["src/**/*", "tests/**/*"]
    
    }

Which would include:

    
    
    .
    
    ‚îú‚îÄ‚îÄ scripts                ‚®Ø
    
    ‚îÇ   ‚îú‚îÄ‚îÄ lint.ts            ‚®Ø
    
    ‚îÇ   ‚îú‚îÄ‚îÄ update_deps.ts     ‚®Ø
    
    ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts           ‚®Ø
    
    ‚îú‚îÄ‚îÄ src                    ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ client             ‚úì
    
    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ index.ts      ‚úì
    
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ utils.ts      ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ server             ‚úì
    
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ index.ts      ‚úì
    
    ‚îú‚îÄ‚îÄ tests                  ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ app.test.ts        ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           ‚úì
    
    ‚îÇ   ‚îî‚îÄ‚îÄ tests.d.ts         ‚úì
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îî‚îÄ‚îÄ yarn.lock

`include` and `exclude` support wildcard characters to make glob patterns:

  * `*` matches zero or more characters (excluding directory separators)
  * `?` matches any one character (excluding directory separators)
  * `**/` matches any directory nested to any level

If the last path segment in a pattern does not contain a file extension or
wildcard character, then it is treated as a directory, and files with
supported extensions inside that directory are included (e.g. `.ts`, `.tsx`,
and `.d.ts` by default, with `.js` and `.jsx` if `allowJs` is set to true).

  * Default:

`[]` if `files` is specified; `**/*` otherwise.

  * Related:
    * `files`

    * `exclude`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Exclude - `exclude`

Specifies an array of filenames or patterns that should be skipped when
resolving `include`.

**Important** : `exclude` _only_ changes which files are included as a result
of the `include` setting. A file specified by `exclude` can still become part
of your codebase due to an `import` statement in your code, a `types`
inclusion, a `/// <reference` directive, or being specified in the `files`
list.

It is not a mechanism that **prevents** a file from being included in the
codebase - it simply changes what the `include` setting finds.

  * Default:

node_modules bower_components jspm_packages `outDir`

  * Related:
    * `include`

    * `files`

### # References - `references`

Project references are a way to structure your TypeScript programs into
smaller pieces. Using Project References can greatly improve build and editor
interaction times, enforce logical separation between components, and organize
your code in new and improved ways.

You can read more about how references works in the [Project
References](/docs/handbook/project-references.html) section of the handbook

  * Default:

`false`

### Compiler Options

These options make up the bulk of TypeScript‚Äôs configuration and it covers how
the language should work.

## #Type Checking

### # Allow Unreachable Code - `allowUnreachableCode`

When:

  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unreachable code is ignored
  * `false` raises compiler errors about unreachable code

These warnings are only about code which is provably unreachable due to the
use of JavaScript syntax, for example:

    
    
    ts
    
    function fn(n: number) {
    
      if (n > 5) {
    
        return true;
    
      } else {
    
        return false;
    
      }
    
      return true;
    
    }

With `"allowUnreachableCode": false`:

    
    
    ts
    
    function fn(n: number) {
    
      if (n > 5) {
    
        return true;
    
      } else {
    
        return false;
    
      }
    
      return true;
    
    Unreachable code detected.7027Unreachable code detected.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMaBQIIBDAG2LgHcBVAO2kkIGMALQgI2MgGE4ATSVAGYlEkXAICu1BgBcAlnGqgB1ABTVU1cQFtWMAJSgA3rlChZA0GtAA+UAFYDx06brTx0RdOjjIAbhOgAL6gkMQiRgEukG4eSsJ+AYEBru6e3gmBQA)

This does not affect errors on the basis of code which _appears_ to be
unreachable due to type analysis.

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Allow Unused Labels - `allowUnusedLabels`

When:

  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unused labels are ignored
  * `false` raises compiler errors about unused labels

Labels are very rare in JavaScript and typically indicate an attempt to write
an object literal:

    
    
    ts
    
    function verifyAge(age: number) {
    
      // Forgot 'return' statement
    
      if (age > 18) {
    
        verified: true;
    
    Unused label.7028Unused label.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMAOAUCBAIYA2JcA7gKoB2AropACYAyRARpCSqAGamM8vOjQDGAFwCWcGqABuMSbwCeAQQDmkABRFNqegFtO0AJSgA3nlChCAMQTq440AHJokcXWg0XoROKJxSANIGnErUCVQHU1QAD5QAEYcM0trawVoJUlmVHFoOkgAbgiAXzxSoA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Always Strict - `alwaysStrict`

Ensures that your files are parsed in the ECMAScript strict mode, and emit
‚Äúuse strict‚Äù for each source file.

[ECMAScript
strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode)
mode was introduced in ES5 and provides behavior tweaks to the runtime of the
JavaScript engine to improve performance, and makes a set of errors throw
instead of silently ignoring them.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.1](/docs/handbook/release-notes/typescript-2-1.html)

### # Exact Optional Property Types - `exactOptionalPropertyTypes`

With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules
around how it handles properties on `type` or `interfaces` which have a `?`
prefix.

For example, this interface declares that there is a property which can be one
of two strings: ‚Äòdark‚Äô or ‚Äòlight‚Äô or it should not be in the object.

    
    
    ts
    
    interface UserDefaults {
    
      // The absence of a value represents 'system'
    
      colorThemeOverride?: "dark" | "light";
    
    }

Without this flag enabled, there are three values which you can set
`colorThemeOverride` to be: ‚Äúdark‚Äù, ‚Äúlight‚Äù and `undefined`.

Setting the value to `undefined` will allow most JavaScript runtime checks for
the existence to fail, which is effectively falsy. However, this isn‚Äôt quite
accurate; `colorThemeOverride: undefined` is not the same as
`colorThemeOverride` not being defined. For example, `"colorThemeOverride" in
settings` would have different behavior with `undefined` as the key compared
to not being defined.

`exactOptionalPropertyTypes` makes TypeScript truly enforce the definition
provided as an optional property:

    
    
    ts
    
    const settings = getUserSettings();
    
    settings.colorThemeOverride = "dark";
    
    settings.colorThemeOverride = "light";
    
    ¬†
    
    // But not:
    
    settings.colorThemeOverride = undefined;
    
    Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.2412Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9efACwBGXkww5EFAGYJIoAKoMKAEUgKArvkQNQAbyahQ8LPizEaAC0gBbSMgBu7DABNIAfh4Aid7DEANa+oAA+oL74GADmNoi+ANxMAL5MnvD4gUpy2jhI2DigMZCIqhQAyqWYODEMABQAlDzlxJo6egzJrAC0ffDaiH09TOY4DIigaog1daAAvMWlrVUz0nVNydOzDAB05pbWdo4ubp4LkQHBSUzb63sHVrYOTq7ExB5Ki1Gx8TcsYAAQoNQDgsIguLdqvd9hYnsdXmcvqA8p45NJIO5EkA)

  * Recommended
  * Released:

[4.4](/docs/handbook/release-notes/typescript-4-4.html)

### # No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`

Report errors for fallthrough cases in switch statements. Ensures that any
non-empty case inside a switch statement includes either `break`, `return`, or
`throw`. This means you won‚Äôt accidentally ship a case fallthrough bug.

    
    
    ts
    
    const a: number = 6;
    
    ¬†
    
    switch (a) {
    
      case 0:
    
    Fallthrough case in switch.7029Fallthrough case in switch.
    
        console.log("even");
    
      case 1:
    
        console.log("odd");
    
        break;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsDEEMA2iAuALATtArgczQMLwDOApsQJKQDKA7gJYoDGaAUCBKRlhsQFygA7AAYATAE5WTaJGIpQ8AZGwBbAEZdQAXlAA2ANytWxBszSgAFPACUoAN6tQoJiVKhhfR0+czi0RKQAdIjQuBYARKQAbqSQ4daGTi5koACMnt4+sv5BIWHh0AAmhfGJ3moYpPAA1oYAvkA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # No Implicit Any - `noImplicitAny`

In some cases where no type annotations are present, TypeScript will fall back
to a type of `any` for a variable when it cannot infer the type.

This can cause some errors to be missed, for example:

    
    
    ts
    
    function fn(s) {
    
      // No error?
    
      console.log(s.subtr(3));
    
    }
    
    fn(42);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0kpkAFJQJSgBvWqFAhQAOWihqAJxnQZAfmGh07StGTUAdMmgBzHtsoMARlhlcAzL14BuWgF963ACwAme0A)

Turning on `noImplicitAny` however TypeScript will issue an error whenever it
would have inferred `any`:

    
    
    ts
    
    function fn(s) {
    
    Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.
    
      console.log(s.subtr(3));
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYBQAzAVwDsBjAFwEs5jR9iAKRASlAG9dRRSbE4AbSADp+cAOZMhiQgCNy0BgGZmzANy4AvkA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

### # No Implicit Override - `noImplicitOverride`

When working with classes which use inheritance, it‚Äôs possible for a sub-class
to get ‚Äúout of sync‚Äù with the functions it overloads when they are renamed in
the base class.

For example, imagine you are modeling a music album syncing system:

    
    
    ts
    
    class Album {
    
      download() {
    
        // Default behavior
    
      }
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      download() {
    
        // Override to get info from many sources
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaATA9gO4B2I+YuAFAJQbY7QD0j0AIgKYBmYSIALtATsAFmABuAS3wAnegF9MCzKEgwAyqOntc8ZGnYAPPu2K4Yu1HRwESZCjSsNm0APJj206RNztoffNAA5uwCEsScAZzS+GgoYMQAntAQ+EjSwOwQ8opAA)

Then when you add support for machine-learning generated playlists, you
refactor the `Album` class to have a ‚Äòsetup‚Äô function instead:

    
    
    ts
    
    class Album {
    
      setup() {
    
        // Default behavior
    
      }
    
    }
    
    ¬†
    
    class MLAlbum extends Album {
    
      setup() {
    
        // Override to get info from algorithm
    
      }
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      download() {
    
        // Override to get info from many sources
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaECmALkgA4AUAlBtjtAPS3QAieAZmEiAdAngBZgA3AJYB7AE7UAvpmmZQkGAFkAMvGRo8ADwJ4AdgBMYa1FRz4iZSlhp0GAeQF4xYofrzQCI6AHNC0IbosXixiImhgIN7iQgS8KFIymHLgUNAAyvxiePrGGtp6hnCIJtbQ+iIA7rogImD6FKY09NAOTi5uHl6+XAFB0CFh0ChgugCeuCJIYsB4EAmSQA)

In this case, TypeScript has provided no warning that `download` on
`SharedAlbum` _expected_ to override a function in the base class.

Using `noImplicitOverride` you can ensure that the sub-classes never go out of
sync, by ensuring that functions which override include the keyword
`override`.

The following example has `noImplicitOverride` enabled, and you can see the
error received when `override` is missing:

    
    
    ts
    
    class Album {
    
      setup() {}
    
    }
    
    ¬†
    
    class MLAlbum extends Album {
    
      override setup() {}
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      setup() {}
    
    This member must have an 'override' modifier because it overrides a member in the base class 'Album'.4114This member must have an 'override' modifier because it overrides a member in the base class 'Album'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg7cvWQENGjUAEFkAIwCu8UAG9KoUIwJZJiABQBKOQF9Ke3gKGgAsgBkxUmQQAeWApDLDL0uQtDRCJcgSUq1Wrr6lIaCwgDKABb8RARkLtZ2Dk6iEq7yisqqGtqyejpAA)

  * Released:

[4.3](/docs/handbook/release-notes/typescript-4-3.html)

### # No Implicit Returns - `noImplicitReturns`

When enabled, TypeScript will check all code paths in a function to ensure
they return a value.

    
    
    ts
    
    function lookupHeadphonesManufacturer(color: "blue" | "black"): string {
    
    Function lacks ending return statement and return type does not include 'undefined'.2366Function lacks ending return statement and return type does not include 'undefined'.
    
      if (color === "blue") {
    
        return "beats";
    
      } else {
    
        ("bose");
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsX0bWgFABmArgHYDGALgJZzmgA2ccA1qQA4ASkAhgBNOACwaREAWT7lSxPjVLQYACkpwW0VACIARk1KQtoAD6hdTeWy0BKVImrRa5AOagA3oVChaxUKvUIoAC8IWZ6Bjbunl6gStSKjLr81IhaANzRAL6gkEyIkFExfrpw+TYZXpmEmUA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # No Implicit This - `noImplicitThis`

Raise error on ‚Äòthis‚Äô expressions with an implied ‚Äòany‚Äô type.

For example, the class below returns a function which tries to access
`this.width` and `this.height` ‚Äì but the context for `this` inside the
function inside `getAreaFunction` is not the instance of the Rectangle.

    
    
    ts
    
    class Rectangle {
    
      width: number;
    
      height: number;
    
    ¬†
    
      constructor(width: number, height: number) {
    
        this.width = width;
    
        this.height = height;
    
      }
    
    ¬†
    
      getAreaFunction() {
    
        return function () {
    
          return this.width * this.height;
    
    'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.2683  
    2683'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.
    
        };
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcBmAUAMYA2AhooqAEqQEAuJAdgOZGSgDeeooA7gJYATWgAtUDAK4BbAEYwA3F1DDIfJsNpips6AsUE4DRLWji6CABT8ho0BJkwANEpVqNtrTACUHRdxF9EADorEVAAXl5BEQVuP2EAwOVVdXDnZNoY0ABfPEUmSFoAQWhIEgAxcQY6PgNzb05Y0BLacWgGUAAzSuqDUDqfRu5m1vb-IJDhUAAqUDHEl3VM7izMnKygA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # No Property Access From Index Signature -
`noPropertyAccessFromIndexSignature`

This setting ensures consistency between accessing a field via the ‚Äúdot‚Äù
(`obj.key`) syntax, and ‚Äúindexed‚Äù (`obj["key"]`) and the way which the
property is declared in the type.

Without this flag, TypeScript will allow you to use the dot syntax to access
fields which are not defined:

    
    
    ts
    
    interface GameSettings {
    
      // Known up-front properties
    
      speed: "fast" | "medium" | "slow";
    
      quality: "high" | "low";
    
    ¬†
    
      // Assume anything unknown to the interface
    
      // is a string.
    
      [key: string]: string;
    
    }
    
    ¬†
    
    const settings = getSettings();
    
    settings.speed;
    
              
    
    (property) GameSettings.speed: "fast" | "medium" | "slow"
    
    settings.quality;
    
               
    
    (property) GameSettings.quality: "high" | "low"
    
    ¬†
    
    // Unknown key accessors are allowed on
    
    // this object, and are `string`
    
    settings.username;
    
                
    
    (index) GameSettings[string]: string
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgAmkBjAGwENpJQAzAVwDsCAXASzltAHNIGBlL529ogAUASlQBxEgFtIvBv0EBubCFABaDQWoMNa7E1oMYlEgQqSZchYlABvbKFCqA0rTgB3NtQAOayvENQb3hvGGZIRAdQRFDIXFQAIhNEBgTQAB9QBJlcJmopNMyExCIPBOVHAEdqEiImBgBPRIALJnZmwqzS93LsKNUAQUREfIoSWgaGVoFQOgBrN09QBjhl5ooDI2gTM36wJhsSaIZoA3YAOiiAbTnIJuPTgQBdVBTH9mUAXz6CVhTovhnGwAXg4XCsQNEykQgIEiHOMUgcWUqkcaNAAD0APzYGHyIHnaq1eoNFFgdGObF9VQAVVoCw8bFuDVApjMwwQh3IrKI3TioFYKjAUwOAoARgArQgMAA0rNouFZ3IABm8zsrcbDBOdqDDoLRpJAyRTKVigA)

Turning the flag on will raise an error because the unknown field uses dot
syntax instead of indexed syntax.

    
    
    ts
    
    const settings = getSettings();
    
    settings.speed;
    
    settings.quality;
    
    ¬†
    
    // This would need to be settings["username"];
    
    settings.username;
    
    Property 'username' comes from an index signature, so it must be accessed with ['username'].4111Property 'username' comes from an index signature, so it must be accessed with ['username'].
    
                
    
    (index) GameSettings[string]: string
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgQQHZwAK8ADjAC4CeAggMZ2SKIBi8AtgJL4AmkAHgGUAlgHN8AQwoBXaJGx86AGwlzQAM2n46FYXHyhRkCoOO78oxAAoAlKgDiE9pFMVzlgNzZh+CjHUSjKCOzq7uiKAA3tigoIjkkDyoAEQBiBTJoAA+oMnOPMLS7Jk5yYhKcADuyV6xAI7SEkrC1CkAFmJtJbkV1bWgANoA1pBUqOnQPqIAuuMUkxZeAL64YAC0G3TSFBtr2HT66XFmUxEAvIbGYae2XognFogAdPGQiXcPlk8NTS1UXqtQAAVDoRSpwaRKHigfBvaEUOCgABGkGOblOA2S0nu0EkzmS0w+6MeT2xMDxkC8eFiNNAAD0APxAA)

The goal of this flag is to signal intent in your calling syntax about how
certain you are this property exists.

  * Released:

[4.2](/docs/handbook/release-notes/typescript-4-2.html)

### # No Unchecked Indexed Access - `noUncheckedIndexedAccess`

TypeScript has a way to describe objects which have unknown keys but known
values on an object, via index signatures.

    
    
    ts
    
    interface EnvironmentVars {
    
      NAME: string;
    
      OS: string;
    
    ¬†
    
      // Unknown properties are covered by this index signature.
    
      [propName: string]: string;
    
    }
    
    ¬†
    
    declare const env: EnvironmentVars;
    
    ¬†
    
    // Declared as existing
    
    const sysName = env.NAME;
    
    const os = env.OS;
    
          
    
    const os: string
    
    ¬†
    
    // Not declared, but because of the index
    
    // signature, then it is considered a string
    
    const nodeEnv = env.NODE_ENV;
    
            
    
    const nodeEnv: string
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL5yvggANhbIViDcyEQYnOhYuAREYKQUQjSKyAAiEMUWDnCU-l4mMjTlleTO5MmEyAC8VZhRzGxC42DIOJQL1VHiQh30yAB6APxyHQw4G4UlkXYANE5hG449cGHkKDgwbu4oPn87SU5CCIXCkSeHiIyGAGy8ZTwoN892QcC46VG62Qml8dXmiwwyxEnVQAH1UAxiAclEczkA)

Turning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared
field in the type.

    
    
    ts
    
    declare const env: EnvironmentVars;
    
    ¬†
    
    // Declared as existing
    
    const sysName = env.NAME;
    
    const os = env.OS;
    
          
    
    const os: string
    
    ¬†
    
    // Not declared, but because of the index
    
    // signature, then it is considered a string
    
    const nodeEnv = env.NODE_ENV;
    
            
    
    const nodeEnv: string | undefined
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL40isgAApqqCO4QCGr2AJIgvn72TAhI5OQFSgC03QhhYN2dNL4IADYWyFYg3MhEGJzoWLgERGCkFEIdyAAilWORDnCU-l4mMjST0+TO5MmEyAC8M5hRzGxCF2DIOJSPs1HiQkK9GQAD0APxyQoMHCfYZ7ewAGicfSclTgYXIKBwMDcFWQPn8m3IQRC4UiSI8RHxny8EzwxN8+2QcC46TOH2Qml8CweTwwLxEW1QAH1UAxiIClMDwUA)

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

### # No Unused Locals - `noUnusedLocals`

Report errors on unused local variables.

    
    
    ts
    
    const createKeyboard = (modelID: number) => {
    
      const defaultModelID = 23;
    
    'defaultModelID' is declared but its value is never read.6133'defaultModelID' is declared but its value is never read.
    
      return { type: "keyboard", modelID };
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBsAjAMwtHbSRIAuo25FLh4oA0igCeAI2i5yaUAF5QACgC20NCnwBJACL1EaqRQCUSgHygA3kVD8uvUFoBmuBPh4BZTdv1LQACYWAG47UEEeBHJIG1AeCQAHFHoAIgBrSRk5NFSAGlANLV09UABfMIqgA)

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # No Unused Parameters - `noUnusedParameters`

Report errors on unused parameters in functions.

    
    
    ts
    
    const createDefaultKeyboard = (modelID: number) => {
    
    'modelID' is declared but its value is never read.6133'modelID' is declared but its value is never read.
    
      const defaultModelID = 23;
    
      return { type: "keyboard", modelID: defaultModelID };
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATACgQwE5YLYoAuKOSAUCBKTtGQFygBsAjAMxvkDG0kSRoLjhRYSAERQAzLAgA2RANIoAngCNouNKAC8oABT5oaFLICSYxonyrSASh0A+UAG9yoQb36hj0uUQCyRibmOqAATGwA3G6gwkQIOJAuoETKAA4ojABEANYq6ppZADSghsZmFt5SMvKB5SEAvtFNQA)

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Strict - `strict`

The `strict` flag enables a wide range of type checking behavior that results
in stronger guarantees of program correctness. Turning this on is equivalent
to enabling all of the _strict mode family_ options, which are outlined below.
You can then turn off individual strict mode family checks as needed.

Future versions of TypeScript may introduce additional stricter checking under
this flag, so upgrades of TypeScript might result in new type errors in your
program. When appropriate and possible, a corresponding flag will be added to
disable that behavior.

  * Recommended
  * Related:
    * `alwaysStrict`

    * `strictNullChecks`

    * `strictBindCallApply`

    * `strictFunctionTypes`

    * `strictPropertyInitialization`

    * `noImplicitAny`

    * `noImplicitThis`

    * `useUnknownInCatchVariables`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Strict Bind Call Apply - `strictBindCallApply`

When set, TypeScript will check that the built-in methods of functions `call`,
`bind`, and `apply` are invoked with correct argument for the underlying
function:

    
    
    ts
    
    // With strictBindCallApply on
    
    function fn(x: string) {
    
      return parseInt(x);
    
    }
    
    ¬†
    
    const n1 = fn.call(undefined, "10");
    
    ¬†
    
    const n2 = fn.call(undefined, false);
    
    Argument of type 'boolean' is not assignable to parameter of type 'string'.2345Argument of type 'boolean' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcocArgKYBQIEDssA9rJDQEwBmACwBWJizAB1eNAAWoGAmRoseQqXIVQndEwBmddMng7Qe9AAoAHjUUYA5gEpQAbyahQsBtDqx0oElweBgBJdGhrRwBuJgBfcUQdGFB0AEZQAF4zdAA6RAJ8C0NMBj0MBkwAGlAAIlSABhrohKToFL5M7LyCoqxS8qqzAkgGaKA)

Otherwise, these functions accept any arguments and will return `any`:

    
    
    ts
    
    // With strictBindCallApply off
    
    function fn(x: string) {
    
      return parseInt(x);
    
    }
    
    ¬†
    
    // Note: No error; return type is 'any'
    
    const n = fn.call(undefined, false);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcoAZgZAKYBQzIoA6vNABagwJkaLHkKlyFUAHtatZrQCu6ZPCno66ABQAPGgIwBzAJSgA3s1ChYjaAtjqSuWEwCS6aDqMBuZgF9W7AByUtCMNMGgjLCwUrBeVjZ26tAUJIyg8JCgAOS46BTZzIhqMKDqALwaAHSIBPiaSpiMtBiMmAA0dAyM3kA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[3.2](/docs/handbook/release-notes/typescript-3-2.html)

### # strictBuiltinIteratorReturn - `strictBuiltinIteratorReturn`

Built-in iterators are instantiated with a `TReturn` type of undefined instead
of `any`.

  * Recommended
  * Default:

`false`, unless `strict` is set

### # Strict Function Types - `strictFunctionTypes`

When enabled, this flag causes functions parameters to be checked more
correctly.

Here‚Äôs a basic example with `strictFunctionTypes` off:

    
    
    ts
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    type StringOrNumberFunc = (ns: string | number) => void;
    
    ¬†
    
    // Unsafe assignment
    
    let func: StringOrNumberFunc = fn;
    
    // Unsafe call - will crash
    
    func(10);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BiBXAds+B7DAVATwAcBTSALlADMBDAG0lIChrNs8aMAKADypgIMAcwCUoAN7NQoRHkg56pAHT0cw7gCIAEqXpqANKE2gA1KF7LoOADI4A7qVgBhWk26jRAbmYBfZszQJKSgAMpw8CIA8rAAcmgAtgBGTuhYoAC8oNwYlKCCkcKgAD6gGIkpsOIZAHygAG448AAmPswgoACqubTUIW6Q8MIYCaQY0MxK0DTsVOFCwjHxyansmVw+Hd2QvSGIDPSgALSg9vD6srBuABas7NwAjAAM3kA)

With `strictFunctionTypes` _on_ , the error is correctly detected:

    
    
    ts
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    type StringOrNumberFunc = (ns: string | number) => void;
    
    ¬†
    
    // Unsafe assignment is prevented
    
    let func: StringOrNumberFunc = fn;
    
    Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.2322Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFADMBXAOwGMAXASziNDyIAoAPVRM6CogcwEpQBvHKFAlqiOABtIAOnFxO9AEQAJSONkAaUAtABqUIylk4AGTgB3GAGEAhokj1u3ANw4AvjhxkAngAdIoAGU2Dk4AeWgAOQIAWwAjGAAxYhJQAF5QeiIUUFZ2LlAAH1AiGPjoXlSAPlAANzgKABMXHBBQAFUs6zx-W0QKTiJoyCIyUApEUB9oSBrhskgGnElRwlJUILywyNLE5LTaIicgA)

During development of this feature, we discovered a large number of inherently
unsafe class hierarchies, including some in the DOM. Because of this, the
setting only applies to functions written in _function_ syntax, not to those
in _method_ syntax:

    
    
    ts
    
    type Methodish = {
    
      func(x: string | number): void;
    
    };
    
    ¬†
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    // Ultimately an unsafe assignment, but not detected
    
    const m: Methodish = {
    
      func: fn,
    
    };
    
    m.func(10);
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshwAsD2ATAlgZwVAvFA3gFBRQBmArgHYDGAFAB4BcUGwATmpQOZQA+UlcgFsARhDYBKZgDckaFAG5CAXyWEKNYGiSUylBs1YduEgsSjUdGJABsIAOhtIutAEQAJCDacAaKK6gAaih6e2AkABkkAHdxAGEAQwwIWgkJJWVCQgB6bKgAVRstIQTgLxAoBN0qDATSaCSMNC5KIQhKYD8RcmABJF6UeAhqMpRCS0pWKCFmOERUTGw8IhINamZSSh8VJSF7NdoARgAGdKA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.6](/docs/handbook/release-notes/typescript-2-6.html)

### # Strict Null Checks - `strictNullChecks`

When `strictNullChecks` is `false`, `null` and `undefined` are effectively
ignored by the language. This can lead to unexpected errors at runtime.

When `strictNullChecks` is `true`, `null` and `undefined` have their own
distinct types and you‚Äôll get a type error if you try to use them where a
concrete value is expected.

For example with this TypeScript code, `users.find` has no guarantee that it
will actually find a user, but you can write code as though it will:

    
    
    ts
    
    declare const loggedInUsername: string;
    
    ¬†
    
    const users = [
    
      { name: "Oby", age: 12 },
    
      { name: "Heera", age: 32 },
    
    ];
    
    ¬†
    
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    
    console.log(loggedInUser.age);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0ByBXANhgwgCwKaIDWkAXKAGYCGGk+AUCBNFbAOb7TkCiAygEwAGAIwBWegBNCGVvlCIA9gDsYoDArYcJASSUBVOrCVUAtvnIwEStgG569RSuig0hyKAC8oANr1QoAG9QYzNyACIAeQAjAE8wgBpQKg5yYX5QAF94v0Dg03NQMIAJfHxYKgSklNAAZnSs+gBdOwdlVXVNfB19Q08XNwA6CnglCQAKMbQASk8APhcBkLkPFbUNLV0DMqWpu0dIBQx8AY6xjo2esoHk-F2gA)

Setting `strictNullChecks` to `true` will raise an error that you have not
made a guarantee that the `loggedInUser` exists before trying to use it.

    
    
    ts
    
    declare const loggedInUsername: string;
    
    ¬†
    
    const users = [
    
      { name: "Oby", age: 12 },
    
      { name: "Heera", age: 32 },
    
    ];
    
    ¬†
    
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    
    console.log(loggedInUser.age);
    
    'loggedInUser' is possibly 'undefined'.18048'loggedInUser' is possibly 'undefined'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME50FYM1QBGADgAYAWUgKBAgBcBDaAc0gdQFEBlNc-nTDhEDaAEsAxgwByAVwA2CgMIALSJIDWiGgBMNClpFCS4AO1GgFcVu10BJMwFVEMM0wC2kVKIlnWANw0NKYWDKByrkigALygANo0oKAA3qDuXqgARADyAEYAnlkANKBM7KjERAC+xUmp6Z7eoFkAEpAwTCVlFaCEoLU0ALpBIeaW1raQDs5RsRFRiAB0AGbiZroAFJtyAJSxAHwRSxnGMedWNnaOLm5Nu0GhiHAKkEuTm5PXszBL5ZAPIA)

The second example failed because the array‚Äôs `find` function looks a bit like
this simplification:

    
    
    ts
    
    // When strictNullChecks: true
    
    type Array = {
    
      find(predicate: (value: any, index: number) => boolean): S | undefined;
    
    };
    
    // When strictNullChecks: false the undefined is removed from the type system,
    
    // allowing you to write code which assumes it always found a result
    
    type Array = {
    
      find(predicate: (value: any, index: number) => boolean): S;
    
    };

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Strict Property Initialization - `strictPropertyInitialization`

When set to true, TypeScript will raise an error when a class property was
declared but not set in the constructor.

    
    
    ts
    
    class UserAccount {
    
      name: string;
    
      accountType = "user";
    
    ¬†
    
      email: string;
    
    Property 'email' has no initializer and is not definitely assigned in the constructor.2564Property 'email' has no initializer and is not definitely assigned in the constructor.
    
      address: string | undefined;
    
    ¬†
    
      constructor(name: string) {
    
        this.name = name;
    
        // Note that this.email is not set
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAUAMYA2AhooqAKqIwCCBBcArgHYAuoA3nqKCyQFtIqRG2gBLFgHMA3D1AkGzdgBUAngAdIoALygARExrR9c+ZAElxREWMmz5JACZPokcrYnTQAH1CsnSAAzSUgnM15GFlFoJgI2BAAKfiFPewBKLnleNgALcUQAOhTtPRK5Xl4QUAA5ODZtPJIOPILCiysiUAK+etAaNnkAXzwhoA)

In the above case:

  * `this.name` is set specifically.
  * `this.accountType` is set by default.
  * `this.email` is not set and raises an error.
  * `this.address` is declared as potentially `undefined` which means it does not have to be set.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.7](/docs/handbook/release-notes/typescript-2-7.html)

### # Use Unknown In Catch Variables - `useUnknownInCatchVariables`

In TypeScript 4.0, support was added to allow changing the type of the
variable in a catch clause from `any` to `unknown`. Allowing for code like:

    
    
    ts
    
    try {
    
      // ...
    
    } catch (err: unknown) {
    
      // We have to verify err is an
    
      // error before using it as one.
    
      if (err instanceof Error) {
    
        console.log(err.message);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFBHUCeoA3m6FAhQAOjFsAvqBLFyoABSxq1AFyhIKdFgCUfAULAB1WKDIEAbiaJpQlugDMeS6qFrRQBRPuHO0LhrD2fiYwtIgA5q5EHu5oiLAi+rT2Cs6uiNBEniSwaCkAosp+uvyCgiRx0GgsIkxo4YrKIgC2rNAE4bDaANz6EpJAA)

This pattern ensures that error handling code becomes more comprehensive
because you cannot guarantee that the object being thrown _is_ a Error
subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled,
then you do not need the additional syntax (`: unknown`) nor a linter rule to
try enforce this behavior.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[4.4](/docs/handbook/release-notes/typescript-4-4.html)

## #Modules

### # Allow Arbitrary Extensions - `allowArbitraryExtensions`

In TypeScript 5.0, when an import path ends in an extension that isn‚Äôt a known
JavaScript or TypeScript file extension, the compiler will look for a
declaration file for that path in the form of `{file
basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a
bundler project, you might want to write (or generate) declaration files for
those stylesheets:

    
    
    css
    
    /* app.css */
    
    .cookie-banner {
    
      display: none;
    
    }
    
    
    ts
    
    // app.d.css.ts
    
    declare const css: {
    
      cookieBanner: string;
    
    };
    
    export default css;
    
    
    ts
    
    // App.tsx
    
    import styles from "./app.css";
    
    styles.cookieBanner; // string

By default, this import will raise an error to let you know that TypeScript
doesn‚Äôt understand this file type and your runtime might not support importing
it. But if you‚Äôve configured your runtime or bundler to handle it, you can
suppress the error with the new `--allowArbitraryExtensions` compiler option.

Note that historically, a similar effect has often been achievable by adding a
declaration file named `app.css.d.ts` instead of `app.d.css.ts` \- however,
this just worked through Node‚Äôs `require` resolution rules for CommonJS.
Strictly speaking, the former is interpreted as a declaration file for a
JavaScript file named `app.css.js`. Because relative files imports need to
include extensions in Node‚Äôs ESM support, TypeScript would error on our
example in an ESM file under `--moduleResolution node16` or `nodenext`.

For more information, read up [the proposal for this
feature](https://github.com/microsoft/TypeScript/issues/50133) and [its
corresponding pull
request](https://github.com/microsoft/TypeScript/pull/51435).

### # Allow Importing TS Extensions - `allowImportingTsExtensions`

`--allowImportingTsExtensions` allows TypeScript files to import each other
with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.

This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is
enabled, since these import paths would not be resolvable at runtime in
JavaScript output files. The expectation here is that your resolver (e.g. your
bundler, a runtime, or some other tool) is going to make these imports between
`.ts` files work.

### # Allow Umd Global Access - `allowUmdGlobalAccess`

When set to true, `allowUmdGlobalAccess` lets you access UMD exports as
globals from inside module files. A module file is a file that has imports
and/or exports. Without this flag, using an export from a UMD module requires
an import declaration.

An example use case for this flag would be a web project where you know the
particular library (like jQuery or Lodash) will always be available at
runtime, but you can‚Äôt access it with an import.

  * Released:

[3.5](/docs/handbook/release-notes/typescript-3-5.html)

### # Base URL - `baseUrl`

Sets a base directory from which to resolve bare specifier module names. For
example, in the directory structure:

    
    
    project
    
    ‚îú‚îÄ‚îÄ ex.ts
    
    ‚îú‚îÄ‚îÄ hello
    
    ‚îÇ   ‚îî‚îÄ‚îÄ world.ts
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With `"baseUrl": "./"`, TypeScript will look for files starting at the same
folder as the `tsconfig.json`:

    
    
    ts
    
    import { helloWorld } from "hello/world";
    
    console.log(helloWorld);

This resolution has higher priority than lookups from `node_modules`.

This feature was designed for use in conjunction with AMD module loaders in
the browser, and is not recommended in any other context. As of TypeScript
4.1, `baseUrl` is no longer required to be set when using `paths`.

### # Custom Conditions - `customConditions`

`--customConditions` takes a list of additional
[conditions](https://nodejs.org/api/packages.html#nested-conditions) that
should succeed when TypeScript resolves from an
[`exports`](https://nodejs.org/api/packages.html#exports) or
[`imports`](https://nodejs.org/api/packages.html#imports) field of a
`package.json`. These conditions are added to whatever existing conditions a
resolver will use by default.

For example, when this field is set in a `tsconfig.json` as so:

    
    
    jsonc
    
    {
    
      "compilerOptions": {
    
        "target": "es2022",
    
        "moduleResolution": "bundler",
    
        "customConditions": ["my-condition"]
    
      }
    
    }

Any time an `exports` or `imports` field is referenced in `package.json`,
TypeScript will consider conditions called `my-condition`.

So when importing from a package with the following `package.json`

    
    
    jsonc
    
    {
    
      // ...
    
      "exports": {
    
        ".": {
    
          "my-condition": "./foo.mjs",
    
          "node": "./bar.mjs",
    
          "import": "./baz.mjs",
    
          "require": "./biz.mjs"
    
        }
    
      }
    
    }

TypeScript will try to look for files corresponding to `foo.mjs`.

This field is only valid under the `node16`, `nodenext`, and `bundler` options
for `--moduleResolution`.

  * Related:
    * `moduleResolution`

    * `resolvePackageJsonExports`

    * `resolvePackageJsonImports`

### # Module - `module`

Sets the module system for the program. See the [theory behind TypeScript‚Äôs
`module` option](/docs/handbook/modules/theory.html#the-module-output-format)
and [its reference page](/docs/handbook/modules/reference.html#the-module-
compiler-option) for more information. You very likely want `"nodenext"` for
modern Node.js projects and `preserve` or `esnext` for code that will be
bundled.

Changing `module` affects `moduleResolution` which [also has a reference
page](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).

Here‚Äôs some example output for this file:

    
    
    ts
    
    // @filename: index.ts
    
    import { valueOfPi } from "./constants";
    
    ¬†
    
    export const twoPi = valueOfPi * 2;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQFDwAeADrgE5E77GgBuysArvADykAArRQAXlABmCgEYALACYA3NRCgAtNux8i2zerBQ4SNJlDREAE3pUC1aKiatQAb268BwsaAC+oJDMuKigAEQUwHiEJGQEYWq0jCxs0ZxEAO64vlI8-EKi4gBUoKpAA)

#### `CommonJS`

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.twoPi = void 0;
    
    const constants_1 = require("./constants");
    
    exports.twoPi = constants_1.valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAGNZk8A7AK0mzHHtkQCcvYuXUyAA590oAN6gAbgENihUgHkAZgAVUoAL6hlvZKABEAOmA16kdDPrpIBgNyZMpAB4iuYsxdDp4sdaABeaTkFFX8AKlAAJjsgA)

#### `UMD`

    
    
    ts
    
    (function (factory) {
    
        if (typeof module === "object" && typeof module.exports === "object") {
    
            var v = factory(require, exports);
    
            if (v !== undefined) module.exports = v;
    
        }
    
        else if (typeof define === "function" && define.amd) {
    
            define(["require", "exports", "./constants"], factory);
    
        }
    
    })(function (require, exports) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.twoPi = void 0;
    
        const constants_1 = require("./constants");
    
        exports.twoPi = constants_1.valueOfPi * 2;
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEOX2zHADtZEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNYDSOnEN0kbQG5MmUgA9+LQUZOD08WEtABeMZLS8j4AVKAATNZAA)

#### `AMD`

    
    
    ts
    
    define(["require", "exports", "./constants"], function (require, exports, constants_1) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.twoPi = void 0;
    
        exports.twoPi = constants_1.valueOfPi * 2;
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAENl9sxwA7WRAJ1dlck1WQAdO6UAG9QANyrFCpAPIAzAAqpQAX1ByOyUACIAdMADGsRpHRVG6SNoDcmTKQAeA1kKMmh6eLCWgAvOMlpeR8AKlAAJmsgA)

#### `System`

    
    
    ts
    
    System.register(["./constants"], function (exports_1, context_1) {
    
        "use strict";
    
        var constants_1, twoPi;
    
        var __moduleName = context_1 && context_1.id;
    
        return {
    
            setters: [
    
                function (constants_1_1) {
    
                    constants_1 = constants_1_1;
    
                }
    
            ],
    
            execute: function () {
    
                exports_1("twoPi", twoPi = constants_1.valueOfPi * 2);
    
            }
    
        };
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEgE9J1TlsxwA7WRAJw9g8k1WQAHHulABvUADcAhsUKkA8gDMACqlABfUEu7JQAIgB0wAMawWdaS3SR9AbkyZSAD2EdRZi6PTxYa0AC8UrLyyv4AVKAATHZAA)

#### `ESNext`

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    export const twoPi = valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgDtSAPLHcG2RAJ3dnck1WQAO3dKADeoAG4BDYoVIB5AGYAFVKAC+oRV2SgARADpgAY1g1I6KTXSQ9AbkyYGQ9iNPmR6eLFWgAvJIyckq+AFSgAEx2QA)

#### `ES2015`/`ES6`/`ES2020`/`ES2022`

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    export const twoPi = valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgCYAGARgFZsxwA7WRAJ29m8iZUyAA790oAN6gAbgENihUgHkAZgAVUoAL6hVfZKABEAOmABjWO0jo57dJCMBuTJlIAPMdwmXrE9PCwmqAAvLIKSmrBAFSgNE5AA)

In addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support
for [dynamic `import`s](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import), and
[`import.meta`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further
adds support for [top level `await`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).

#### `node16`/`nodenext`

Available from 4.7+, the `node16` and `nodenext` modes integrate with Node‚Äôs
[native ECMAScript Module support](https://nodejs.org/api/esm.html). The
emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the
file extension and the value of the `type` setting in the nearest
`package.json`. Module resolution also works differently. You can learn more
in the [handbook](/docs/handbook/esm-node.html) and [Modules
Reference](/docs/handbook/modules/reference.html#node16-nodenext).

#### `preserve`

In `--module preserve`
([added](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-
bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and
exports written in input files are preserved in the output, and CommonJS-style
`import x = require("...")` and `export = ...` statements are emitted as
CommonJS `require` and `module.exports`. In other words, the format of each
individual import or export statement is preserved, rather than being coerced
into a single format for the whole compilation (or even a whole file).

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    const constants = require("./constants");
    
    export const piSquared = valueOfPi * constants.valueOfPi;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAAcAnUyUmgN1OzHADtZEabYbImVMir90oAN6gmAQ2KFSAeQBmABVSgAvqGV9koAEQA6YAGNYHSOhkd0kAwG4hIsaHOXrtyKAC8oOgCOhKh0ABTGZhZWNnYGAJROmKQAHqI04u5W1KgAykEydPi+0nIKKuqgAFRuUZ52RrLySmqoDkA)

While it‚Äôs rare to need to mix imports and require calls in the same file,
this `module` mode best reflects the capabilities of most modern bundlers, as
well as the Bun runtime.

> Why care about TypeScript‚Äôs `module` emit with a bundler or with Bun, where
> you‚Äôre likely also setting `noEmit`? TypeScript‚Äôs type checking and module
> resolution behavior are affected by the module format that it _would_ emit.
> Setting `module` gives TypeScript information about how your bundler or
> runtime will process imports and exports, which ensures that the types you
> see on imported values accurately reflect what will happen at runtime or
> after bundling.

#### `None`

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.twoPi = void 0;
    
    const constants_1 = require("./constants");
    
    exports.twoPi = constants_1.valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlADtYrTsxwbEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNakdOKrpI2gNyZMpAB78Wgo1ROh08WEtABeMZLS8j4AVKAATFZAA)

  * Default:

`CommonJS` if `target` is `ES5`; `ES6`/`ES2015` otherwise.

  * Allowed:
    * `none`

    * `commonjs`

    * `amd`

    * `umd`

    * `system`

    * `es6`/`es2015`

    * `es2020`

    * `es2022`

    * `esnext`

    * `node16`

    * `nodenext`

    * `preserve`

  * Related:
    * `moduleResolution`

    * `esModuleInterop`

    * `allowImportingTsExtensions`

    * `allowArbitraryExtensions`

    * `resolveJsonModule`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Module Resolution - `moduleResolution`

Specify the module resolution strategy:

  * `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding `module` values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.
  * `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won‚Äôt need to use `node10` in modern code.
  * `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `"imports"` and `"exports"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.
  * `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.

There are reference pages explaining the [theory behind TypeScript‚Äôs module
resolution](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-
resolution) and the [details of each
option](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).

  * Default:

`Classic` if `module` is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if
`module` is `node16` or `nodenext`; `Node` otherwise.

  * Allowed:
    * `classic`

    * `node10`/`node`

    * `node16`

    * `nodenext`

    * `bundler`

  * Related:
    * `module`

    * `paths`

    * `baseUrl`

    * `rootDirs`

    * `moduleSuffixes`

    * `customConditions`

    * `resolvePackageJsonExports`

    * `resolvePackageJsonImports`

### # Module Suffixes - `moduleSuffixes`

Provides a way to override the default list of file name suffixes to search
when resolving a module.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[moduleSuffixes](https://www.typescriptlang.org/tsconfig#moduleSuffixes)": [".ios", ".native", ""]
    
      }
    
    }

Given the above configuration, an import like the following:

    
    
    ts
    
    import * as foo from "./foo";

TypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`,
and finally `./foo.ts`.

Note the empty string `""` in `moduleSuffixes` which is necessary for
TypeScript to also look-up `./foo.ts`.

This feature can be useful for React Native projects where each target
platform can use a separate tsconfig.json with differing `moduleSuffixes`.

  * Released:

[4.7](/docs/handbook/release-notes/typescript-4-7.html)

### # No Resolve - `noResolve`

By default, TypeScript will examine the initial set of files for `import` and
`<reference` directives and add these resolved files to your program.

If `noResolve` is set, this process doesn‚Äôt happen. However, `import`
statements are still checked to see if they resolve to a valid module, so
you‚Äôll need to make sure this is satisfied by some other means.

### # noUncheckedSideEffectImports - `noUncheckedSideEffectImports`

In JavaScript it‚Äôs possible to `import` a module without actually importing
any values from it.

    
    
    ts
    
    import "some-module";

These imports are often called _side effect imports_ because the only useful
behavior they can provide is by executing some side effect (like registering a
global variable, or adding a polyfill to a prototype).

By default, TypeScript will not check these imports for validity. If the
import resolves to a valid source file, TypeScript will load and check the
file. If no source file is found, TypeScript will silently ignore the import.

This is surprising behavior, but it partially stems from modeling patterns in
the JavaScript ecosystem. For example, this syntax has also been used with
special loaders in bundlers to load CSS or other assets. Your bundler might be
configured in such a way where you can include specific `.css` files by
writing something like the following:

    
    
    tsx
    
    import "./button-component.css";
    
    export function Button() {
    
      // ...
    
    }

Still, this masks potential typos on side effect imports.

When `--noUncheckedSideEffectImports` is enabled, TypeScript will error if it
can‚Äôt find a source file for a side effect import.

    
    
    ts
    
    import "oops-this-module-does-not-exist";
    
    //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations.

When enabling this option, some working code may now receive an error, like in
the CSS example above. To work around this, users who want to just write side
effect `import`s for assets might be better served by writing what‚Äôs called an
_ambient module declaration_ with a wildcard specifier. It would go in a
global file and look something like the following:

    
    
    ts
    
    // ./src/globals.d.ts
    
    // Recognize all CSS files as module imports.
    
    declare module "*.css" {}

In fact, you might already have a file like this in your project! For example,
running something like `vite init` might create a similar `vite-env.d.ts`.

### # Paths - `paths`

A series of entries which re-map imports to lookup locations relative to the
`baseUrl` if set, or to the tsconfig file itself otherwise. There is a larger
coverage of `paths` in [the `moduleResolution` reference
page](/docs/handbook/modules/reference.html#paths).

`paths` lets you declare how TypeScript should resolve an import in your
`require`/`import`s.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
    
          "jquery": ["./vendor/jquery/dist/jquery"]
    
        }
    
      }
    
    }

This would allow you to be able to write `import "jquery"`, and get all of the
correct typing locally.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
    
            "app/*": ["./src/app/*"],
    
            "config/*": ["./src/app/_config/*"],
    
            "environment/*": ["./src/environments/*"],
    
            "shared/*": ["./src/app/_shared/*"],
    
            "helpers/*": ["./src/helpers/*"],
    
            "tests/*": ["./src/tests/*"]
    
        },
    
    }

In this case, you can tell the TypeScript file resolver to support a number of
custom prefixes to find code.

Note that this feature does not change how import paths are emitted by `tsc`,
so `paths` should only be used to inform TypeScript that another tool has this
mapping and will use it at runtime or when bundling.

### # Resolve JSON Module - `resolveJsonModule`

Allows importing modules with a `.json` extension, which is a common practice
in node projects. This includes generating a type for the `import` based on
the static JSON shape.

TypeScript does not support resolving JSON files by default:

    
    
    ts
    
    // @filename: settings.json
    
    {
    
        "repo": "TypeScript",
    
        "dry": false,
    
        "debug": false
    
    }
    
    // @filename: index.ts
    
    import settings from "./settings.json";
    
    Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.2732Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.
    
    ¬†
    
    settings.debug === true;
    
    settings.dry === 2;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYDMaBQIIAzASwBtIA7AQwFtJVFIAXJ4igc0QDoArROCrgDeuUGNAAiaJAAOcCagkAVAJ4zIAZQDG0YjKYSANKPESAJtBULQhKqUbHxks5ABGAV3bXb9yLgC++GDgJOTUdKhsLgAeXEyIuMQ0ctBMoIwsbJw28DSSXMAZrBzcfAISANy4uEVZ3C4e7KAAvK2gTNDukFW1JVwWKi1taBVAA)

Enabling the option allows importing JSON, and validating the types in that
JSON file.

    
    
    ts
    
    // @filename: settings.json
    
    {
    
        "repo": "TypeScript",
    
        "dry": false,
    
        "debug": false
    
    }
    
    // @filename: index.ts
    
    import settings from "./settings.json";
    
    ¬†
    
    settings.debug === true;
    
    settings.dry === 2;
    
    This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.2367This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUCBNJInADYBukAUqQHYCycAJgK5mQFjgC2L7kVAGM4PPnQBWiLhD5sOAJRLlWAFwCWcOqjotOhcADN1HOgEMeg0IkiqNdAOaIAdFK14A3nlA-QAImIABzg-VD8AFQBPQMgAZSFodUDVPwAab18-ZmhI0NBDMzIbdN9-ZkgAI1YHPIKizgBfGSMTSHNLVHU6coAPZ1VpdR5g6FVrW3snfPgef2dgGzsup1d6PwBuPDxFyZdyqodQAF4T0FVoVkhNneW9nOPTtHWgA)

### # Resolve package.json Exports - `resolvePackageJsonExports`

`--resolvePackageJsonExports` forces TypeScript to consult [the `exports`
field of `package.json` files](https://nodejs.org/api/packages.html#exports)
if it ever reads from a package in `node_modules`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

  * Default:

`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`

  * Related:
    * `moduleResolution`

    * `customConditions`

    * `resolvePackageJsonImports`

### # Resolve package.json Imports - `resolvePackageJsonImports`

`--resolvePackageJsonImports` forces TypeScript to consult [the `imports`
field of `package.json` files](https://nodejs.org/api/packages.html#imports)
when performing a lookup that starts with `#` from a file whose ancestor
directory contains a `package.json`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

  * Default:

`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`

  * Related:
    * `moduleResolution`

    * `customConditions`

    * `resolvePackageJsonExports`

### # Root Dir - `rootDir`

**Default** : The longest common path of all non-declaration input files. If
`composite` is set, the default is instead the directory containing the
`tsconfig.json` file.

When TypeScript compiles files, it keeps the same directory structure in the
output directory as exists in the input directory.

For example, let‚Äôs say you have some input files:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.ts
    
    ‚îú‚îÄ‚îÄ types.d.ts

The inferred value for `rootDir` is the longest common path of all non-
declaration input files, which in this case is `core/`.

If your `outDir` was `dist`, TypeScript would write this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js

However, you may have intended for `core` to be part of the output directory
structure. By setting `rootDir: "."` in `tsconfig.json`, TypeScript would
write this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js

Importantly, `rootDir` **does not affect which files become part of the
compilation**. It has no interaction with the `include`, `exclude`, or `files`
`tsconfig.json` settings.

Note that TypeScript will never write an output file to a directory outside of
`outDir`, and will never skip emitting a file. For this reason, `rootDir` also
enforces that all files which need to be emitted are underneath the `rootDir`
path.

For example, let‚Äôs say you had this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    
    ‚îú‚îÄ‚îÄ helpers.ts

It would be an error to specify `rootDir` as `core` _and_ `include` as `*`
because it creates a file (`helpers.ts`) that would need to be emitted
_outside_ the `outDir` (i.e. `../helpers.js`).

  * Default:

Computed from the list of input files.

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Root Dirs - `rootDirs`

Using `rootDirs`, you can inform the compiler that there are many ‚Äúvirtual‚Äù
directories acting as a single root. This allows the compiler to resolve
relative module imports within these ‚Äúvirtual‚Äù directories, as if they were
merged in to one directory.

For example:

    
    
     src
    
     ‚îî‚îÄ‚îÄ views
    
         ‚îî‚îÄ‚îÄ view1.ts (can import "./template1", "./view2`)
    
         ‚îî‚îÄ‚îÄ view2.ts (can import "./template1", "./view1`)
    
     generated
    
     ‚îî‚îÄ‚îÄ templates
    
             ‚îî‚îÄ‚îÄ views
    
                 ‚îî‚îÄ‚îÄ template1.ts (can import "./view1", "./view2")
    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src/views", "generated/templates/views"]
    
      }
    
    }

This does not affect how TypeScript emits JavaScript, it only emulates the
assumption that they will be able to work via those relative paths at runtime.

`rootDirs` can be used to provide a separate ‚Äútype layer‚Äù to files that are
not TypeScript or JavaScript by providing a home for generated `.d.ts` files
in another folder. This technique is useful for bundled applications where you
use `import` of files that aren‚Äôt necessarily code:

    
    
    sh
    
     src
    
     ‚îî‚îÄ‚îÄ index.ts
    
     ‚îî‚îÄ‚îÄ css
    
         ‚îî‚îÄ‚îÄ main.css
    
         ‚îî‚îÄ‚îÄ navigation.css
    
     generated
    
     ‚îî‚îÄ‚îÄ css
    
         ‚îî‚îÄ‚îÄ main.css.d.ts
    
         ‚îî‚îÄ‚îÄ navigation.css.d.ts
    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src", "generated"]
    
      }
    
    }

This technique lets you generate types ahead of time for the non-code source
files. Imports then work naturally based off the source file‚Äôs location. For
example `./src/index.ts` can import the file `./src/css/main.css` and
TypeScript will be aware of the bundler‚Äôs behavior for that filetype via the
corresponding generated declaration file.

    
    
    ts
    
    // @filename: index.ts
    
    import { appClass } from "./main.css";
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVzqIHQDGAzsfgCb4AuxAUPAB4AOA9gE5WiEuLGfJMmAYVjJSoALygARDjwixxAGIBmAKJCATNIDctEKAC0xwgFcqxw-rBQ4SNJlB5yjanWipWHUAG9QA4VFxAF9QSDYWVBl8YDkCEmJdIA)

  * Default:

Computed from the list of input files.

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Type Roots - `typeRoots`

By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.

If `typeRoots` is specified, _only_ packages under `typeRoots` will be
included. For example:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[typeRoots](https://www.typescriptlang.org/tsconfig#typeRoots)": ["./typings", "./vendor/types"]
    
      }
    
    }

This config file will include _all_ packages under `./typings` and
`./vendor/types`, and no packages from `./node_modules/@types`. All paths are
relative to the `tsconfig.json`.

  * Related:
    * `types`

### # Types - `types`

By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.

If `types` is specified, only packages listed will be included in the global
scope. For instance:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["node", "jest", "express"]
    
      }
    
    }

This `tsconfig.json` file will _only_ include `./node_modules/@types/node`,
`./node_modules/@types/jest` and `./node_modules/@types/express`. Other
packages under `node_modules/@types/*` will not be included.

### What does this affect?

This option does not affect how `@types/*` are included in your application
code, for example if you had the above `compilerOptions` example with code
like:

    
    
    ts
    
    import * as moment from "moment";
    
    moment().format("MMMM Do YYYY, h:mm:ss a");

The `moment` import would be fully typed.

When you have this option set, by not including a module in the `types` array
it:

  * Will not add globals to your project (e.g `process` in node, or `expect` in Jest)
  * Will not have exports appear as auto-import recommendations

This feature differs from `typeRoots` in that it is about specifying only the
exact types you want included, whereas `typeRoots` supports saying you want
particular folders.

  * Related:
    * `typeRoots`

## #Emit

### # Declaration - `declaration`

Generate `.d.ts` files for every TypeScript or JavaScript file inside your
project. These `.d.ts` files are type definition files which describe the
external API of your module. With `.d.ts` files, tools like TypeScript can
provide intellisense and accurate types for un-typed code.

When `declaration` is set to `true`, running the compiler with this TypeScript
code:

    
    
    ts
    
    export let helloWorld = "hi";
    
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAG2PAFsBCIHVoICZwC8cARCgJYkDcQA)

Will generate an `index.js` file like this:

    
    
    ts
    
    export let helloWorld = "hi";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMAeAHWAJ3VABttTpsyzYB1YsgE1AF5QAiaVTgbiA)

With a corresponding `helloWorld.d.ts`:

    
    
    ts
    
    export declare let helloWorld: string;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCi1oAHWKPShiy6FkKFYAdUWEcoALygARNFQmA3EA)

When working with `.d.ts` files for JavaScript files you may want to use
`emitDeclarationOnly` or use `outDir` to ensure that the JavaScript files are
not overwritten.

  * Default:

`true` if `composite`; `false` otherwise.

  * Related:
    * `declarationDir`

    * `emitDeclarationOnly`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Declaration Dir - `declarationDir`

Offers a way to configure the root directory for where declaration files are
emitted.

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

with this `tsconfig.json`:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
        "[declarationDir](https://www.typescriptlang.org/tsconfig#declarationDir)": "./types"
    
      }
    
    }

Would place the d.ts for the `index.ts` in a `types` folder:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.js
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îî‚îÄ‚îÄ types
    
        ‚îî‚îÄ‚îÄ index.d.ts

  * Related:
    * `declaration`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Declaration Map - `declarationMap`

Generates a source map for `.d.ts` files which map back to the original `.ts`
source file. This will allow editors such as VS Code to go to the original
`.ts` file when using features like _Go to Definition_.

You should strongly consider turning this on if you‚Äôre using project
references.

  * Released:

[2.9](/docs/handbook/release-notes/typescript-2-9.html)

### # Downlevel Iteration - `downlevelIteration`

Downleveling is TypeScript‚Äôs term for transpiling to an older version of
JavaScript. This flag is to enable support for a more accurate implementation
of how modern JavaScript iterates through new concepts in older JavaScript
runtimes.

ECMAScript 6 added several new iteration primitives: the `for / of` loop (`for
(el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`),
and `Symbol.iterator`. `downlevelIteration` allows for these iteration
primitives to be used more accurately in ES5 environments if a
`Symbol.iterator` implementation is present.

#### Example: Effects on `for / of`

With this TypeScript code:

    
    
    ts
    
    const str = "Hello!";
    
    for (const s of str) {
    
      console.log(s);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBNBOMC8MBEAJApgG2yAhKgNwBQAZiIgBSiSwQwhlxTwCUMA3iTDLRCGyYAdHgDmVCG1IBfIA)

Without `downlevelIteration` enabled, a `for / of` loop on any object is
downleveled to a traditional `for` loop:

    
    
    ts
    
    "use strict";
    
    var str = "Hello!";
    
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
    
        var s = str_1[_i];
    
        console.log(s);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBAM4AWA9gO7oC2AlpLgMakB2hkobsoAvKAEQAJRABthpAIR8A3LgBmpLgAomrdoVClZHSLACUoAN65QoFYVLDEAOjHxFhXTIC+QA)

This is often what people expect, but it‚Äôs not 100% compliant with ECMAScript
iteration protocol. Certain strings, such as emoji (üòú), have a `.length` of 2
(or even more!), but should iterate as 1 unit in a `for-of` loop. See [this
blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-
equals-two) for a longer explanation.

When `downlevelIteration` is enabled, TypeScript will use a helper function
that checks for a `Symbol.iterator` implementation (either native or
polyfill). If this implementation is missing, you‚Äôll fall back to index-based
iteration.

    
    
    ts
    
    "use strict";
    
    var __values = (this && this.__values) || function(o) {
    
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    
        if (m) return m.call(o);
    
        if (o && typeof o.length === "number") return {
    
            next: function () {
    
                if (o && i >= o.length) o = void 0;
    
                return { value: o && o[i++], done: !o };
    
            }
    
        };
    
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    
    };
    
    var e_1, _a;
    
    var str = "Hello!";
    
    try {
    
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
    
            var s = str_1_1.value;
    
            console.log(s);
    
        }
    
    }
    
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    
    finally {
    
        try {
    
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
    
        }
    
        finally { if (e_1) throw e_1.error; }
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y4AzgAsy6ALbtIuAMZc+kULNigAvKABEACXqViAQlUBuXADNiigBTTys+aGJH5kWAEpQAb1yhQlvsWoA6bXgzPidDAF8gA)

You can use [tslib](https://www.npmjs.com/package/tslib) via `importHelpers`
to reduce the amount of inline JavaScript too:

    
    
    ts
    
    "use strict";
    
    var __values = (this && this.__values) || function(o) {
    
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    
        if (m) return m.call(o);
    
        if (o && typeof o.length === "number") return {
    
            next: function () {
    
                if (o && i >= o.length) o = void 0;
    
                return { value: o && o[i++], done: !o };
    
            }
    
        };
    
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    
    };
    
    var e_1, _a;
    
    var str = "Hello!";
    
    try {
    
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
    
            var s = str_1_1.value;
    
            console.log(s);
    
        }
    
    }
    
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    
    finally {
    
        try {
    
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
    
        }
    
        finally { if (e_1) throw e_1.error; }
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y47AtgAdisSAAl6glgGceEaQAsy6fu0i4Axl2mRQO2KAC8oAEQTKlYgEITAblwAzEaAAUW8jr2hiDvZFgAlKAA3rigoO7SxNQAdJbwLtIB9gC+QA)

**Note:** enabling `downlevelIteration` does not improve compliance if
`Symbol.iterator` is not present in the runtime.

#### Example: Effects on Array Spreads

This is an array spread:

    
    
    js
    
    // Make a new array whose elements are 1 followed by the elements of arr2
    
    const arr = [1, ...arr2];

Based on the description, it sounds easy to downlevel to ES5:

    
    
    js
    
    // The same, right?
    
    const arr = [1].concat(arr2);

However, this is observably different in certain rare cases.

For example, if a source array is missing one or more items (contains a hole),
the spread syntax will replace each empty item with `undefined`, whereas
`.concat` will leave them intact.

    
    
    js
    
    // Make an array where the element at index 1 is missing
    
    let arrayWithHole = ["a", , "c"];
    
    let spread = [...arrayWithHole];
    
    let concatenated = [].concat(arrayWithHole);
    
    console.log(arrayWithHole);
    
    // [ 'a', <1 empty item>, 'c' ]
    
    console.log(spread);
    
    // [ 'a', undefined, 'c' ]
    
    console.log(concatenated);
    
    // [ 'a', <1 empty item>, 'c' ]

Just as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if
present) to more accurately emulate ES 6 behavior.

  * Related:
    * `importHelpers`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Emit BOM - `emitBOM`

Controls whether TypeScript will emit a [byte order mark
(BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files.
Some runtime environments require a BOM to correctly interpret a JavaScript
files; others require that it is not present. The default value of `false` is
generally best unless you have a reason to change it.

### # Emit Declaration Only - `emitDeclarationOnly`

_Only_ emit `.d.ts` files; do not emit `.js` files.

This setting is useful in two cases:

  * You are using a transpiler other than TypeScript to generate your JavaScript.
  * You are using TypeScript to only generate `d.ts` files for your consumers.

  * Related:
    * `declaration`

  * Released:

[2.8](/docs/handbook/release-notes/typescript-2-8.html)

### # Import Helpers - `importHelpers`

For certain downleveling operations, TypeScript uses some helper code for
operations like extending class, spreading arrays or objects, and async
operations. By default, these helpers are inserted into files which use them.
This can result in code duplication if the same helper is used in many
different modules.

If the `importHelpers` flag is on, these helper functions are instead imported
from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to
ensure that the `tslib` module is able to be imported at runtime. This only
affects modules; global script files will not attempt to import modules.

For example, with this TypeScript:

    
    
    ts
    
    export function fn(arr: number[]) {
    
      const arr2 = [1, ...arr];
    
    }

Turning on `downlevelIteration` and `importHelpers` is still false:

    
    
    ts
    
    var __read = (this && this.__read) || function (o, n) {
    
        var m = typeof Symbol === "function" && o[Symbol.iterator];
    
        if (!m) return o;
    
        var i = m.call(o), r, ar = [], e;
    
        try {
    
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    
        }
    
        catch (error) { e = { error: error }; }
    
        finally {
    
            try {
    
                if (r && !r.done && (m = i["return"])) m.call(i);
    
            }
    
            finally { if (e) throw e.error; }
    
        }
    
        return ar;
    
    };
    
    var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    
            if (ar || !(i in from)) {
    
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
    
                ar[i] = from[i];
    
            }
    
        }
    
        return to.concat(ar || Array.prototype.slice.call(from));
    
    };
    
    export function fn(arr) {
    
        var arr2 = __spreadArray([1], __read(arr), false);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFaYSADwAOsAulAAzAK6sAxsNGLWACkIFKrJcgBGAgNoBdAJSgA3plChVoyPL0AmUAF5QZgIwANKAAdKF6FgDcmAC+QA)

Then turning on both `downlevelIteration` and `importHelpers`:

    
    
    ts
    
    import { __read, __spreadArray } from "tslib";
    
    export function fn(arr) {
    
        var arr2 = __spreadArray([1], __read(arr), false);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFYMIqZAAdYBdNF5SBkceFaxEBArJUkAHjLmgAZgFdWAY2GiTrABSEClVqeQAjAQG0AugEpQAN6YoKAWopDooI4ATKAAvKCeAIwANKAAdJmO3gDcmAC+QA)

You can use `noEmitHelpers` when you provide your own implementations of these
functions.

  * Related:
    * `noEmitHelpers`

    * `downlevelIteration`

### # Inline Source Map - `inlineSourceMap`

When set, instead of writing out a `.js.map` file to provide source maps,
TypeScript will embed the source map content in the `.js` files. Although this
results in larger JS files, it can be convenient in some scenarios. For
example, you might want to debug JS files on a webserver that doesn‚Äôt allow
`.map` files to be served.

Mutually exclusive with `sourceMap`.

For example, with this TypeScript:

    
    
    ts
    
    const helloWorld = "hi";
    
    console.log(helloWorld);

Converts to this JavaScript:

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)

Then enable building it with `inlineSourceMap` enabled there is a comment at
the bottom of the file which includes a source-map for the file.

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQWQIYAOAUCBAM4AWKA7gKIC2kALsVitOc6JQrLCgDqKDLAAmoALygARJUgyA3Gw7kUsBADoBAcwAUvfkJHiAlIqA)

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Inline Sources - `inlineSources`

When set, TypeScript will include the original content of the `.ts` file as an
embedded string in the source map (using the source map‚Äôs `sourcesContent`
property). This is often useful in the same cases as `inlineSourceMap`.

Requires either `sourceMap` or `inlineSourceMap` to be set.

For example, with this TypeScript:

    
    
    ts
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAFgUwDZJAdRAJyQExgXhgCI4BLIgbgChRIQkEA6VAcwApEV0tcBKCoA)

By default converts to this JavaScript:

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)

Then enable building it with `inlineSources` and `inlineSourceMap` enabled
there is a comment at the bottom of the file which includes a source-map for
the file. Note that the end is different from the example in `inlineSourceMap`
because the source-map now contains the original source code also.

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQZwFAgQzzTLrYICyAhgA6Fji4AWKA7gKIC2kALviwpouPqBYJYsFAHUUGWABNQAXlAAiFpHUBuQcNwpYCAHTSA5gAoJU2fKUBKHUA)

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Map Root - `mapRoot`

Specify the location where debugger should locate map files instead of
generated locations. This string is treated verbatim inside the source-map,
for example:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
    
        "[mapRoot](https://www.typescriptlang.org/tsconfig#mapRoot)": "https://my-website.com/debug/sourcemaps/"
    
      }
    
    }

Would declare that `index.js` will have sourcemaps at `https://my-
website.com/debug/sourcemaps/index.js.map`.

### # New Line - `newLine`

Specify the end of line sequence to be used when emitting files: ‚ÄòCRLF‚Äô (dos)
or ‚ÄòLF‚Äô (unix).

  * Default:

`lf`

  * Allowed:
    * `crlf`

    * `lf`

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # No Emit - `noEmit`

Do not emit compiler output files like JavaScript source code, source-maps or
declarations.

This makes room for another tool like [Babel](https://babeljs.io), or
[swc](https://github.com/swc-project/swc) to handle converting the TypeScript
file to a file which can run inside a JavaScript environment.

You can then use TypeScript as a tool for providing editor integration, and as
a source code type-checker.

### # No Emit Helpers - `noEmitHelpers`

Instead of importing helpers with `importHelpers`, you can provide
implementations in the global scope for the helpers you use and completely
turn off emitting of helper functions.

For example, using this `async` function in ES5 requires a `await`-like
function and `generator`-like function to run:

    
    
    ts
    
    const getAPI = async (url: string) => {
    
      // Get API
    
      return {};
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBA5gUygQQAoEkYF4YEMICeYwMAFAK4BOANgFwzSUCWYcAlNgHwwDeAUDBgB6ITADiSGGnQCYlJFTC8AvgG4+aoA)

Which creates quite a lot of JavaScript:

    
    
    ts
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    
        return new (P || (P = Promise))(function (resolve, reject) {
    
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
    
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
    
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
    
            step((generator = generator.apply(thisArg, _arguments || [])).next());
    
        });
    
    };
    
    var __generator = (this && this.__generator) || function (thisArg, body) {
    
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    
        function verb(n) { return function (v) { return step([n, v]); }; }
    
        function step(op) {
    
            if (f) throw new TypeError("Generator is already executing.");
    
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
    
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
    
                if (y = 0, t) op = [op[0] & 2, t.value];
    
                switch (op[0]) {
    
                    case 0: case 1: t = op; break;
    
                    case 4: _.label++; return { value: op[1], done: false };
    
                    case 5: _.label++; y = op[1]; op = [0]; continue;
    
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
    
                    default:
    
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
    
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
    
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
    
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
    
                        if (t[2]) _.ops.pop();
    
                        _.trys.pop(); continue;
    
                }
    
                op = body.call(thisArg, _);
    
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
    
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    
        }
    
    };
    
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
    
        return __generator(this, function (_a) {
    
            // Get API
    
            return [2 /*return*/, {}];
    
        });
    
    }); };
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArJgMawB2k6op6AggAoCSoALyg8kAJ7MGoABQBXAgBtKbAqmZEAlEIB8oAN6ZQoHAHEyoXn0OgCZec30BfANyYXQA)

Which can be switched out with your own globals via this flag:

    
    
    ts
    
    "use strict";
    
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
    
        return __generator(this, function (_a) {
    
            // Get API
    
            return [2 /*return*/, {}];
    
        });
    
    }); };
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOAHawoYASJANgA4kGRMAY1hNI6UKXQBBAAoBJUAF5QeSAE8mQ0AAoArgS6VxBVEyIBKZQD5QAb0yhQOAOJlQc+Y9AEyBpvYAvgDcmCFAA)

  * Related:
    * `importHelpers`

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # No Emit On Error - `noEmitOnError`

Do not emit compiler output files like JavaScript source code, source-maps or
declarations if any errors were reported.

This defaults to `false`, making it easier to work with TypeScript in a watch-
like environment where you may want to see results of changes to your code in
another environment before making sure all errors are resolved.

  * Released:

[1.4](/docs/handbook/release-notes/typescript-1-4.html)

### # Out Dir - `outDir`

If specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be
emitted into this directory. The directory structure of the original source
files is preserved; see `rootDir` if the computed root is not what you
intended.

If not specified, `.js` files will be emitted in the same directory as the
`.ts` files they were generated from:

    
    
    sh
    
    $ tsc
    
    example
    
    ‚îú‚îÄ‚îÄ index.js
    
    ‚îî‚îÄ‚îÄ index.ts

With a `tsconfig.json` like this:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "dist"
    
      }
    
    }

Running `tsc` with these settings moves the files into the specified `dist`
folder:

    
    
    sh
    
    $ tsc
    
    example
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îî‚îÄ‚îÄ tsconfig.json

  * Related:
    * `out`

    * `outFile`

### # Out File - `outFile`

If specified, all _global_ (non-module) files will be concatenated into the
single output file specified.

If `module` is `system` or `amd`, all module files will also be concatenated
into this file after all global content.

Note: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`.
This option _cannot_ be used to bundle CommonJS or ES6 modules.

  * Related:
    * `out`

    * `outDir`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Preserve Const Enums - `preserveConstEnums`

Do not erase `const enum` declarations in generated code. `const enum`s
provide a way to reduce the overall memory footprint of your application at
runtime by emitting the enum value instead of a reference.

For example with this TypeScript:

    
    
    ts
    
    const enum Album {
    
      JimmyEatWorldFutures = 1,
    
      TubRingZooHypothesis = 2,
    
      DogFashionDiscoAdultery = 3,
    
    }
    
    ¬†
    
    const selectedAlbum = Album.JimmyEatWorldFutures;
    
    if (selectedAlbum === Album.JimmyEatWorldFutures) {
    
      console.log("That is a great choice.");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgQQDYCMUwN4BQMMAUgJbLICeAogIZQDqIAThgCYBiiUiLcEGAF4YARgA0RGABVEWAEpkwAcwBaIEAAkqABxBQAFgLKCRAJknEAIiGWc6EA2XBWToNO0QYocFlWEwAMySAL4EBKCQsBBwGHDAPuyYOKgiySgAdOSUtAzMbFw8fAIA3ARkAGYwABQxcQlwSdi4Qq3ozchZFNT0TKwc3Lz8EACU+FKRECBxGRi21QBE0gYMMCYwdDDK-KvABiBkwHAZCyNlIUA)

The default `const enum` behavior is to convert any `Album.Something` to the
corresponding number literal, and to remove a reference to the enum from the
JavaScript completely.

    
    
    ts
    
    "use strict";
    
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
    
        console.log("That is a great choice.");
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VAEEAbAIwtAG9NRQApVZZAT0QEN0AdVgAnGgBMAYmXRlRxSKAC8oAIwAaVqAAqZOgCVUeAOYAtWLAASPAA6x00RaiWqATFrYARWCan8YVHwvF1wqCTIadGJRHhVQAGYtAF9MHHxCUEhiGmJsaIlaBkpVIooAOk5uPkERcWlZeUUAbkxUADNQAAps3PziQvpGZRHqIeRKrl4BYTFJGTkFSABKZm1cAlhc8ppfLoAiHWhBUBdQflATBRPsOFRsYnL95dbkoA)

With `preserveConstEnums` set to `true`, the `enum` exists at runtime and the
numbers are still emitted.

    
    
    ts
    
    "use strict";
    
    var Album;
    
    (function (Album) {
    
        Album[Album["JimmyEatWorldFutures"] = 1] = "JimmyEatWorldFutures";
    
        Album[Album["TubRingZooHypothesis"] = 2] = "TubRingZooHypothesis";
    
        Album[Album["DogFashionDiscoAdultery"] = 3] = "DogFashionDiscoAdultery";
    
    })(Album || (Album = {}));
    
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
    
        console.log("That is a great choice.");
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEAcCcFMGdbQG6wMIHsB28AuBRLAVwFt4AuUXaI2AKBAngAsMB3fEgS1zoGNseULGIlQAQQA2AI1KgA3nVCgAUlxIkAnvgCGuAOoZokgCYAxIriJx4oALygAjABoloACpFpAJS5YA5gBaGBgAEpqQGLjMCFy2DgBMrsoAIhj+ZjosXNgpcQLiJkSSuEia9qAAzK4AvnT8grigiJKwfKUmUrJiDl2kAHRqGtp6hsbmltYIANx0XABmoAAULW0dfT12vTIDQ1q6BkamFlY2AJQKbgI4GK39kulLAETuzHqgcaA6oP5w73ysLh8WD9J5nWY1IA)

This essentially makes such `const enums` a source-code feature only, with no
runtime traces.

  * Default:

`true` if `isolatedModules`; `false` otherwise.

### # Remove Comments - `removeComments`

Strips all comments from TypeScript files when converting into JavaScript.
Defaults to `false`.

For example, this is a TypeScript file which has a JSDoc comment:

    
    
    ts
    
    /** The translation of 'Hello world' into Portuguese */
    
    export const helloWorldPTBR = "Ol√° Mundo";

When `removeComments` is set to `true`:

    
    
    ts
    
    export const helloWorldPTBR = "Ol√° Mundo";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBco6uArvtgFSegAq0+ZrgCGNSABth6VLBqhYAM1AByABL5x42KHixc4gCbLQqOtoAKe9KwDm7SIM7BM+AB4AHK6ADGsyOlABTVgAdT1Dc14AIQAlUABeUAAiAHlxAEPQAFlWGgNYJIBuIA)

Without setting `removeComments` or having it as `false`:

    
    
    ts
    
    /** The translation of 'Hello world' into Portuguese */
    
    export const helloWorldPTBR = "Ol√° Mundo";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBcoAZgIYA2k+2AVD6ABVo+UOlysakdq3SpYNULGagA5AAl87drFDxYudgBMVoVHR0AFfegCuAcxv4uoHsEz4AHgAdroAMbykOigwlqwAOr6RhYCAEIASqAAvKAARADy7ACHoACyNjSGsKkA3EA)

This means that your comments will show up in the JavaScript code.

### # Source Map - `sourceMap`

Enables the generation of [sourcemap
files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map).
These files allow debuggers and other tools to display the original TypeScript
source code when actually working with the emitted JavaScript files. Source
map files are emitted as `.js.map` (or `.jsx.map`) files next to the
corresponding `.js` output file.

The `.js` files will in turn contain a sourcemap comment to indicate where the
files are to external tools, for example:

    
    
    ts
    
    // helloWorld.ts
    
    export declare const helloWorld = "hi";

Compiling with `sourceMap` set to `true` creates the following JavaScript
file:

    
    
    js
    
    // helloWorld.js
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.helloWorld = "hi";
    
    //# sourceMappingURL=// helloWorld.js.map

And this also generates this json map:

    
    
    json
    
    // helloWorld.js.map
    
    {
    
      "version": 3,
    
      "file": "ex.js",
    
      "sourceRoot": "",
    
      "sources": ["../ex.ts"],
    
      "names": [],
    
      "mappings": ";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA"
    
    }

### # Source Root - `sourceRoot`

Specify the location where a debugger should locate TypeScript files instead
of relative source locations. This string is treated verbatim inside the
source-map where you can use a path or a URL:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
    
        "[sourceRoot](https://www.typescriptlang.org/tsconfig#sourceRoot)": "https://my-website.com/debug/source/"
    
      }
    
    }

Would declare that `index.js` will have a source file at `https://my-
website.com/debug/source/index.ts`.

### # Strip Internal - `stripInternal`

Do not emit declarations for code that has an `@internal` annotation in its
JSDoc comment. This is an internal compiler option; use at your own risk,
because the compiler does not check that the result is valid. If you are
searching for a tool to handle additional levels of visibility within your
`d.ts` files, look at [api-extractor](https://api-extractor.com).

    
    
    ts
    
    /**
    
     * Days available in a week
    
     * @internal
    
     */
    
    export const daysInAWeek = 7;
    
    ¬†
    
    /** Calculate how much someone earns in a week */
    
    export function weeklySalary(dayRate: number) {
    
      return daysInAWeek * dayRate;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgRBDAngZ0vAbvAlgG3gIxwFNIsA7NSAdyKIGsoYABcgFyICcz4dHhwiADwAOAew6tIAY1FlkkgCZJkASTIBBAOq06kALyQA7AG5w4UDADCPKQFc87SAAtRVSAFtbUp5GSj3RLIkRPBcqOSUNPTQ-EJiEpAAZrZkUqxYstQ6OIgAyjyhiAAUSogASvDsAFyQZLbu+JwAlJAA3lCQHESstlyQpaoa2tEwpRXspgC+QA)

With the flag set to `false` (default):

    
    
    ts
    
    /**
    
     * Days available in a week
    
     * @internal
    
     */
    
    export declare const daysInAWeek = 7;
    
    /** Calculate how much someone earns in a week */
    
    export declare function weeklySalary(dayRate: number): number;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCmwBUslqFmgAIsICekUMIBuwosIBGxchW2h4WLAGtFy8JWyiKwwneAtaAB1ij0oAWlIfxwNSABJCgBBAHUra1AAXlAAdgBuFjllAGFXAQBXEWxQOHhQZHyBaFBIWGQsaSxQLDEKLUpzSxslD29ffwAzfIoBSWkLeMJ1AGVXMXUAClD1ACUJUlAKfORDLFEASlAAb0VQUSx0fOdQZYjouO7lZbXsDIBfIA)

With `stripInternal` set to `true` the `d.ts` emitted will be redacted.

    
    
    ts
    
    /** Calculate how much someone earns in a week */
    
    export declare function weeklySalary(dayRate: number): number;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsAO8B20CmsUEMA2AoECSACwHsB3AUQFt5oMATAMXl3QC5RVH0APAHSMB0SITBRy1OtHEReAY1zZY2aPDIpCAKm35Q20ABFsAT0ihsAN2xtsAI3bcUl0BXToA1vsPhUGLDwfYHx+RDJYaFAFTRhQRjNIAEkUAEEAdQ9PUABeUAB2AG58HUMAYTwFAFdlDFApUBoqhRJQSDIadE10UHQVFAtUV3cvAxCwiKiAMyqUBXVNNyzcUwBlPBVTAAoE0wAlNU5QFCqae0wASlAAb31QWHRoKqx4xJSMrINX-cPigF8gA)

The JavaScript output is still the same.

  * Internal

## #JavaScript Support

### # Allow JS - `allowJs`

Allow JavaScript files to be imported inside your project, instead of just
`.ts` and `.tsx` files. For example, this JS file:

    
    
    js
    
    // @filename: card.js
    
    export const defaultCardDeck = "Heart";
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQ8AHgA4D2eALjvYmSwfJMgK6xMAwvgIAReNgDWoALygARAAl4+JvIDcQA)

When imported into a TypeScript file will raise an error:

    
    
    ts
    
    // @filename: index.ts
    
    import { defaultCardDeck } from "./card";
    
    ¬†
    
    console.log(defaultCardDeck);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMB2AUCBAGYCWANpAHYCGAtpKgMbXQAmAdAFaJ61ysBXCu0gAPAA4IALonatIRakKkBhFqwAikRgGtQAXlAAiABKQWUowG4CYALQPGAqQ7u3i5KnQagSleaLsMngktJLQUqAA3qDyispqbFq6oAC+oETwtMbswMxs1nh4jHCUiHDCZHAA5gAUcUpkqurJOgCUVkA)

Imports fine with `allowJs` enabled:

    
    
    ts
    
    // @filename: index.ts
    
    import { defaultCardDeck } from "./card";
    
    ¬†
    
    console.log(defaultCardDeck);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQqA9gQK4JHwAeADtXgC5lEHyTIGnAML4CAEXjYA1qAC8oAEQAJePk6KA3BRCgAtAex1OBvTrDhksWNQDuAKUq6ocJGkyhoiPsyLcK0KjsXKAA3qB8AkKihJIyoAC+oJB41KhKRMC4hFoUFNjUiGTUjDYA5gAUkYKwImJx0gCUmkA)

This flag can be used as a way to incrementally add TypeScript files into JS
projects by allowing the `.ts` and `.tsx` files to live along-side existing
JavaScript files.

It can also be used along-side `declaration` and `emitDeclarationOnly` to
[create declarations for JS files](/docs/handbook/declaration-files/dts-from-
js.html).

  * Related:
    * `checkJs`

    * `emitDeclarationOnly`

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Check JS - `checkJs`

Works in tandem with `allowJs`. When `checkJs` is enabled then errors are
reported in JavaScript files. This is the equivalent of including `// @ts-
check` at the top of all JavaScript files which are included in your project.

For example, this is incorrect JavaScript according to the `parseFloat` type
definition which comes with TypeScript:

    
    
    js
    
    // parseFloat only takes a string
    
    module.exports.pi = parseFloat(3.142);

When imported into a TypeScript module:

    
    
    ts
    
    // @filename: constants.js
    
    module.exports.pi = parseFloat(3.142);
    
    ¬†
    
    // @filename: index.ts
    
    import { pi } from "./constants";
    
    console.log(pi);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEMBtoewO4CkDOAoEEBmBLaBTAO0gFt8AuUAYzkJQBdJD6UA6AK3RLgBMBXAq3wAPAA5wATi1aicoALyhRkCSnwAxeJHoAKAMysAjABYATAEoA3GgxhwuAsTKUchHiNYs0OEuKmgAbyU5AF9QLAk4ElAAIlZgGjpGZhQY60SUOEF4AHMdWSsgA)

You will not get any errors. However, if you turn on `checkJs` then you will
get error messages from the JavaScript file.

    
    
    ts
    
    // @filename: constants.js
    
    module.exports.pi = parseFloat(3.142);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    
    ¬†
    
    // @filename: index.ts
    
    import { pi } from "./constants";
    
    console.log(pi);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUCBAIYA2JcA7gFYqgAu0ArpAWOAMYAWk7A1jagbNWEAGYBLEpAB2RALaRU7ONMR0i0uogB0NPHLgATRlO2QAHgAcEW7ZfGgAvKEtEkkAGLkidABQZtAEYsNABKAG48EXAJKVkFVHFpQwttLTxxOWtoOlAAbxcHAF9QUXg5UAAibWBlVXVNRErIusQ4U3IAc197CKA)

  * Related:
    * `allowJs`

    * `emitDeclarationOnly`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Max Node Module JS Depth - `maxNodeModuleJsDepth`

The maximum dependency depth to search under `node_modules` and load
JavaScript files.

This flag can only be used when `allowJs` is enabled, and is used if you want
to have TypeScript infer types for all of the JavaScript inside your
`node_modules`.

Ideally this should stay at 0 (the default), and `d.ts` files should be used
to explicitly define the shape of modules. However, there are cases where you
may want to turn this on at the expense of speed and potential accuracy.

## #Editor Support

### # Disable Size Limit - `disableSizeLimit`

To avoid a possible memory bloat issues when working with very large
JavaScript projects, there is an upper limit to the amount of memory
TypeScript will allocate. Turning this flag on will remove the limit.

### # Plugins - `plugins`

List of language service plugins to run inside the editor.

Language service plugins are a way to provide additional information to a user
based on existing TypeScript files. They can enhance existing messages between
TypeScript and an editor, or to provide their own error messages.

For example:

  * [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) ‚Äî Adds SQL linting with a template strings SQL builder.
  * [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) ‚Äî Provides CSS linting inside template strings .
  * [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) ‚Äî Provides eslint error messaging and fix-its inside the compiler‚Äôs output.
  * [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) ‚Äî Provides validation and auto-completion inside GraphQL query template strings.

VS Code has the ability for a extension to [automatically include language
service plugins](https://code.visualstudio.com/api/references/contribution-
points#contributes.typescriptServerPlugins), and so you may have some running
in your editor without needing to define them in your `tsconfig.json`.

## #Interop Constraints

### # Allow Synthetic Default Imports - `allowSyntheticDefaultImports`

When set to true, `allowSyntheticDefaultImports` allows you to write an import
like:

    
    
    ts
    
    import React from "react";

instead of:

    
    
    ts
    
    import * as React from "react";

When the module **does not** explicitly specify a default export.

For example, without `allowSyntheticDefaultImports` as true:

    
    
    ts
    
    // @filename: utilFunctions.js
    
    const getStringLength = (str) => str.length;
    
    ¬†
    
    module.exports = {
    
      getStringLength,
    
    };
    
    ¬†
    
    // @filename: index.ts
    
    import utils from "./utilFunctions";
    
    Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.1192Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.
    
    ¬†
    
    const count = utils.getStringLength("Check JS");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYCsBOdacMAoECAYwAtIyBrAKURLHAEMAbNuAdwaYkkQBZOABMArm0gBJAHYAXGHAAOqAGbtEkPuFUBLSTJYBbSKjFz9AMTEyyFuDMQA6AFaNS4GXClGlbXWS6cgCCMgCeahpaZA6IcqAA5pByAMpy0LoyCQAykFlyFKAAvKAAFHHQAJTFAHygFU4GCQUA3ERERqISkE6QAB5KCHKIxaAA3kSgiclpGVm5+RQANEQAvm3aegbGpqCZIv1Ow0S6vkOg5vojqvBGoABETsCXbNa29o73GzGO8TE28RKL2cSVS6UyOTyzQopXuAGEqLRQHQUvdKi0gA)

This code raises an error because there isn‚Äôt a `default` object which you can
import. Even though it feels like it should. For convenience, transpilers like
Babel will automatically create a default if one isn‚Äôt created. Making the
module look a bit more like:

    
    
    js
    
    // @filename: utilFunctions.js
    
    const getStringLength = (str) => str.length;
    
    const allFunctions = {
    
      getStringLength,
    
    };
    
    module.exports = allFunctions;
    
    module.exports.default = allFunctions;

This flag does not affect the JavaScript emitted by TypeScript, it‚Äôs only for
the type checking. This option brings the behavior of TypeScript in-line with
Babel, where extra code is emitted to make using a default export of a module
more ergonomic.

  * Default:

`true` if `esModuleInterop` is enabled, `module` is `system`, or
`moduleResolution` is `bundler`; `false` otherwise.

  * Related:
    * `esModuleInterop`

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # ES Module Interop - `esModuleInterop`

By default (with `esModuleInterop` false or not set) TypeScript treats
CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two
parts in particular which turned out to be flawed assumptions:

  * a namespace import like `import * as moment from "moment"` acts the same as `const moment = require("moment")`

  * a default import like `import moment from "moment"` acts the same as `const moment = require("moment").default`

This mis-match causes these two issues:

  * the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require("x")` then TypeScript allowed for the import to be treated as a function and be callable. That‚Äôs not valid according to the spec.

  * while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn‚Äôt conform as strictly as TypeScript‚Äôs implementation.

Turning on `esModuleInterop` will fix both of these problems in the code
transpiled by TypeScript. The first changes the behavior in the compiler, the
second is fixed by two new helper functions which provide a shim to ensure
compatibility in the emitted JavaScript:

    
    
    ts
    
    import * as fs from "fs";
    
    import _ from "lodash";
    
    fs.readFileSync("file.txt", "utf8");
    
    _.chunk(["a", "b", "c", "d"], 2);

With `esModuleInterop` disabled:

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const fs = require("fs");
    
    const lodash_1 = require("lodash");
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4BcoAGYBDFiioUIhRqyqCAxtEIzIAK3TFCvZKVAAqUCJTCTQpIVAAiISisBuNFp3w9AfWEXrLRsewO0NFsAOngqEQYAMWI2AGUAT0gFAAobGKpg0gAPUisAGmsmUiEADisASkc3YIVsJkgAa2SAbSsRfOsAIw6rBR6GKwBdAoAmSqA)

With `esModuleInterop` set to `true`:

    
    
    ts
    
    "use strict";
    
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    
        if (k2 === undefined) k2 = k;
    
        var desc = Object.getOwnPropertyDescriptor(m, k);
    
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    
          desc = { enumerable: true, get: function() { return m[k]; } };
    
        }
    
        Object.defineProperty(o, k2, desc);
    
    }) : (function(o, m, k, k2) {
    
        if (k2 === undefined) k2 = k;
    
        o[k2] = m[k];
    
    }));
    
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    
    }) : function(o, v) {
    
        o["default"] = v;
    
    });
    
    var __importStar = (this && this.__importStar) || function (mod) {
    
        if (mod && mod.__esModule) return mod;
    
        var result = {};
    
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    
        __setModuleDefault(result, mod);
    
        return result;
    
    };
    
    var __importDefault = (this && this.__importDefault) || function (mod) {
    
        return (mod && mod.__esModule) ? mod : { "default": mod };
    
    };
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const fs = __importStar(require("fs"));
    
    const lodash_1 = __importDefault(require("lodash"));
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URCjVlQBcoAMbRCQyACt0xQr2SlQAKlABDFKABmuvUkKgARAdMBuNEpXw1AfX3GzLRjuxW0aAwDp4VFoMAGLEbADKAJ6QEgAU5mFUvqQAHqSmADRmTKR6ABymAJTWDr4S2EyQANaxANqmWplmAEZNphJtDKYAulkATMVAA)

_Note_ : The namespace import `import * as fs from "fs"` only accounts for
properties which [are owned](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)
(basically properties set on the object and not via the prototype chain) on
the imported object. If the module you‚Äôre importing defines its API using
inherited properties, you need to use the default import form (`import fs from
"fs"`), or disable `esModuleInterop`.

_Note_ : You can make JS emit terser by enabling `importHelpers`:

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const tslib_1 = require("tslib");
    
    const fs = tslib_1.__importStar(require("fs"));
    
    const lodash_1 = tslib_1.__importDefault(require("lodash"));
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URihXslIAJKi1490mcIUasqALlABjaIQWQAVuiEj4pUACpQAQxSgAZletJCoAES2nAbjQHRoAPo2HziyMltjuaGi2AHTwVOYMAGLEbADKAJ6QagAULklUkaQAHqROADTOTKTWABxOAJQePpFq2EyQANaZANpO5qXOAEZ9TmpDDE4AumUATPVAA)

Enabling `esModuleInterop` will also enable `allowSyntheticDefaultImports`.

  * Recommended
  * Default:

`true` if `module` is `node16` or `nodenext`; `false` otherwise.

  * Related:
    * `allowSyntheticDefaultImports`

  * Released:

[2.7](/docs/handbook/release-notes/typescript-2-7.html)

### # Force Consistent Casing In File Names -
`forceConsistentCasingInFileNames`

TypeScript follows the case sensitivity rules of the file system it‚Äôs running
on. This can be problematic if some developers are working in a case-sensitive
file system and others aren‚Äôt. If a file attempts to import `fileManager.ts`
by specifying `./FileManager.ts` the file will be found in a case-insensitive
file system, but not on a case-sensitive file system.

When this option is set, TypeScript will issue an error if a program tries to
include a file by a casing different from the casing on disk.

  * Recommended
  * Default:

`true`

### # isolatedDeclarations - `isolatedDeclarations`

Require sufficient annotation on exports so other tools can trivially generate
declaration files.

For more information, see the [5.5 release notes](/docs/handbook/release-
notes/typescript-5-5.html#isolated-declarations)

### # Isolated Modules - `isolatedModules`

While you can use TypeScript to produce JavaScript code from TypeScript code,
it‚Äôs also common to use other transpilers such as [Babel](https://babeljs.io)
to do this. However, other transpilers only operate on a single file at a
time, which means they can‚Äôt apply code transforms that depend on
understanding the full type system. This restriction also applies to
TypeScript‚Äôs `ts.transpileModule` API which is used by some build tools.

These limitations can cause runtime problems with some TypeScript features
like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells
TypeScript to warn you if you write certain code that can‚Äôt be correctly
interpreted by a single-file transpilation process.

It does not change the behavior of your code, or otherwise change the behavior
of TypeScript‚Äôs checking and emitting process.

Some examples of code which does not work when `isolatedModules` is enabled.

#### Exports of Non-Value Identifiers

In TypeScript, you can import a _type_ and then subsequently export it:

    
    
    ts
    
    import { someType, someFunction } from "someModule";
    
    ¬†
    
    someFunction();
    
    ¬†
    
    export { someType, someFunction };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEsC2AHZAXUAb1BWiwFMAVATxwoBpTyKAxAV0gGN8NpJQAX1AAzJFlAAiMpQCy0ACbsANhUkBuNGhltOPPpAAUASk1oKADzzxCJHbXpMdHbr35D1QA)

Because there‚Äôs no value for `someType`, the emitted `export` will not try to
export it (this would be a runtime error in JavaScript):

    
    
    js
    
    export { someFunction };

Single-file transpilers don‚Äôt know whether `someType` produces a value or not,
so it‚Äôs an error to export a name that only refers to a type.

#### Non-Module Files

If `isolatedModules` is set, namespaces are only allowed in _modules_ (which
means it has some form of `import`/`export`). An error occurs if a namespace
is found in a non-module file:

    
    
    ts
    
    namespace Instantiated {
    
    Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.1280Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.
    
      export const x = 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYDsWBQIIBLROAGwEMAXSAEwFk4aBXUyRXAO3IFs2AHcgGNIoAJIdElch0qEqtUAG9coUJAAefBJVCC4EnetABedAG5cAXyA)

This restriction doesn‚Äôt apply to `.d.ts` files.

#### References to `const enum` members

In TypeScript, when you reference a `const enum` member, the reference is
replaced by its actual value in the emitted JavaScript. Changing this
TypeScript:

    
    
    ts
    
    declare const enum Numbers {
    
      Zero = 0,
    
      One = 1,
    
    }
    
    console.log(Numbers.Zero + Numbers.One);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iFBXAtvAHIEBGIMa8A3gFDzwBaFS8AvPAAwA098A8igQcAjLwC+tZOiQQQAOghIA5gAoS+cpXnMYrANTEyFNPMEgAlAG4gA)

To this JavaScript:

    
    
    ts
    
    "use strict";
    
    console.log(0 + 1);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqSYAm+AxgDYCGBoLsNk6ULQCuyUADlRAI3y5IoAN6ZQoAFqzYoALygADABploAPI1820AEZDAX0y9+sNvgB0bWAHMAFJOQy5Luq4mgDUEtKykC6m+ACUANxAA)

Without knowledge of the values of these members, other transpilers can‚Äôt
replace the references to `Numbers`, which would be a runtime error if left
alone (since there are no `Numbers` object at runtime). Because of this, when
`isolatedModules` is set, it is an error to reference an ambient `const enum`
member.

  * Default:

`true` if `verbatimModuleSyntax`; `false` otherwise.

### # Preserve Symlinks - `preserveSymlinks`

This is to reflect the same flag in Node.js; which does not resolve the real
path of symlinks.

This flag also exhibits the opposite behavior to Webpack‚Äôs `resolve.symlinks`
option (i.e. setting TypeScript‚Äôs `preserveSymlinks` to true parallels setting
Webpack‚Äôs `resolve.symlinks` to false, and vice-versa).

With this enabled, references to modules and packages (e.g. `import`s and `///
<reference type="..." />` directives) are all resolved relative to the
location of the symbolic link file, rather than relative to the path that the
symbolic link resolves to.

### # Verbatim Module Syntax - `verbatimModuleSyntax`

By default, TypeScript does something called _import elision_. Basically, if
you write something like

    
    
    ts
    
    import { Car } from "./car";
    
    export function drive(car: Car) {
    
      // ...
    
    }

TypeScript detects that you‚Äôre only using an import for types and drops the
import entirely. Your output JavaScript might look something like this:

    
    
    js
    
    export function drive(car) {
    
      // ...
    
    }

Most of the time this is good, because if `Car` isn‚Äôt a value that‚Äôs exported
from `./car`, we‚Äôll get a runtime error.

But it does add a layer of complexity for certain edge cases. For example,
notice there‚Äôs no statement like `import "./car";` \- the import was dropped
entirely. That actually makes a difference for modules that have side-effects
or not.

TypeScript‚Äôs emit strategy for JavaScript also has another few layers of
complexity - import elision isn‚Äôt always just driven by how an import is used
- it often consults how a value is declared as well. So it‚Äôs not always clear
whether code like the following

    
    
    ts
    
    export { Car } from "./car";

should be preserved or dropped. If `Car` is declared with something like a
`class`, then it can be preserved in the resulting JavaScript file. But if
`Car` is only declared as a `type` alias or `interface`, then the JavaScript
file shouldn‚Äôt export `Car` at all.

While TypeScript might be able to make these emit decisions based on
information from across files, not every compiler can.

The `type` modifier on imports and exports helps with these situations a bit.
We can make it explicit whether an import or export is only being used for
type analysis, and can be dropped entirely in JavaScript files by using the
`type` modifier.

    
    
    ts
    
    // This statement can be dropped entirely in JS output
    
    import type * as car from "./car";
    
    // The named import/export 'Car' can be dropped in JS output
    
    import { type Car } from "./car";
    
    export { type Car } from "./car";

`type` modifiers are not quite useful on their own - by default, module
elision will still drop imports, and nothing forces you to make the
distinction between `type` and plain imports and exports. So TypeScript has
the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier,
`--preserveValueImports` to prevent _some_ module elision behavior, and
`--isolatedModules` to make sure that your TypeScript code works across
different compilers. Unfortunately, understanding the fine details of those 3
flags is hard, and there are still some edge cases with unexpected behavior.

TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to
simplify the situation. The rules are much simpler - any imports or exports
without a `type` modifier are left around. Anything that uses the `type`
modifier is dropped entirely.

    
    
    ts
    
    // Erased away entirely.
    
    import type { A } from "a";
    
    // Rewritten to 'import { b } from "bcd";'
    
    import { b, type c, type d } from "bcd";
    
    // Rewritten to 'import {} from "xyz";'
    
    import { type xyz } from "xyz";

With this new option, what you see is what you get.

That does have some implications when it comes to module interop though. Under
this flag, ECMAScript `import`s and `export`s won‚Äôt be rewritten to `require`
calls when your settings or file extension implied a different module system.
Instead, you‚Äôll get an error. If you need to emit code that uses `require` and
`module.exports`, you‚Äôll have to use TypeScript‚Äôs module syntax that predates
ES2015:

Input TypeScript | Output JavaScript  
---|---  
      
    
    tsimport foo = require("foo");

|

    
    
    jsconst foo = require("foo");  
      
    
    tsfunction foo() {}function bar() {}function baz() {}export = {  foo,  bar,  baz,};

|

    
    
    jsfunction foo() {}function bar() {}function baz() {}module.exports = {  foo,  bar,  baz,};  
  
While this is a limitation, it does help make some issues more obvious. For
example, it‚Äôs very common to forget to set the [`type` field in
`package.json`](https://nodejs.org/api/packages.html#type) under `--module
node16`. As a result, developers would start writing CommonJS modules instead
of an ES modules without realizing it, giving surprising lookup rules and
JavaScript output. This new flag ensures that you‚Äôre intentional about the
file type you‚Äôre using because the syntax is intentionally different.

Because `--verbatimModuleSyntax` provides a more consistent story than
`--importsNotUsedAsValues` and `--preserveValueImports`, those two existing
flags are being deprecated in its favor.

For more details, read up on [the original pull
request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal
issue](https://github.com/microsoft/TypeScript/issues/51479).

## #Backwards Compatibility

### # Charset - `charset`

In prior versions of TypeScript, this controlled what encoding was used when
reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but
will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.

  * Deprecated
  * Default:

`utf8`

### # Imports Not Used As Values - `importsNotUsedAsValues`

Deprecated in favor of `verbatimModuleSyntax`.

This flag controls how `import` works, there are 3 different options:

  * `remove`: The default behavior of dropping `import` statements which only reference types.

  * `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.

  * `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.

This flag works because you can use `import type` to explicitly create an
`import` statement which should never be emitted into JavaScript.

  * Default:

`remove`

  * Allowed:
    * `remove`

    * `preserve`

    * `error`

  * Related:
    * `preserveValueImports`

    * `verbatimModuleSyntax`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Keyof Strings Only - `keyofStringsOnly`

This flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.

This flag is used to help people keep this behavior from [before TypeScript
2.9‚Äôs release](/docs/handbook/release-notes/typescript-2-9.html#support-
number-and-symbol-named-properties-with-keyof-and-mapped-types).

  * Deprecated
  * Released:

[2.9](/docs/handbook/release-notes/typescript-2-9.html)

### # No Implicit Use Strict - `noImplicitUseStrict`

You shouldn‚Äôt need this. By default, when emitting a module file to a non-ES6
target, TypeScript emits a `"use strict";` prologue at the top of the file.
This setting disables the prologue.

### # No Strict Generic Checks - `noStrictGenericChecks`

TypeScript will unify type parameters when comparing two generic functions.

    
    
    ts
    
    type A = <T, U>(x: T, y: U) => [T, U];
    
    type B = <S>(x: S, y: S) => [S, S];
    
    ¬†
    
    function f(a: A, b: B) {
    
      b = a; // Ok
    
      a = b; // Error
    
    Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.2322Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFA4C4CeADpKAIKgC8oAPACoA0oAqgHwAUAHqk6IahYBKam1ABtPiwC6AbgIkyAIWp0Aypx6g1zAdpFUx4ndrl4AZgFcAdgGN8ASzjXQ5jgENU5ZgCNUSkQBvHFBQH1V3WVAQUAB5AGsQ0HdVHyiYgFFYBBwAXyA)

This flag can be used to remove that check.

  * Released:

[2.4](/docs/handbook/release-notes/typescript-2-4.html)

### # Out - `out`

Use `outFile` instead.

The `out` option computes the final file location in a way that is not
predictable or consistent. This option is retained for backward compatibility
only and is deprecated.

  * Deprecated
  * Related:
    * `outDir`

    * `outFile`

### # Preserve Value Imports - `preserveValueImports`

Deprecated in favor of `verbatimModuleSyntax`.

There are some cases where TypeScript can‚Äôt detect that you‚Äôre using an
import. For example, take the following code:

    
    
    ts
    
    import { Animal } from "./animal.js";
    
    eval("console.log(new Animal().isDangerous())");

or code using ‚ÄòCompiles to HTML‚Äô languages like Svelte or Vue.
`preserveValueImports` will prevent TypeScript from removing the import, even
if it appears unused.

When combined with `isolatedModules`: imported types _must_ be marked as type-
only because compilers that process single files at a time have no way of
knowing whether imports are values that appear unused, or a type that must be
removed in order to avoid a runtime crash.

  * Related:
    * `isolatedModules`

    * `importsNotUsedAsValues`

    * `verbatimModuleSyntax`

  * Released:

[4.5](/docs/handbook/release-notes/typescript-4-5.html)

### # Suppress Excess Property Errors - `suppressExcessPropertyErrors`

This disables reporting of excess property errors, such as the one shown in
the following example:

    
    
    ts
    
    type Point = { x: number; y: number };
    
    const p: Point = { x: 1, y: 3, m: 10 };
    
    Object literal may only specify known properties, and 'm' does not exist in type 'Point'.2353Object literal may only specify known properties, and 'm' does not exist in type 'Point'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAAU4BLAOz1AF5QBvUAD1WoFcBbAIxgDcoAhx79ooAL4CcAYzjVEdIqgo06jFu1ABGADTDUGA91Q6ADFIFA)

This flag was added to help people migrate to the stricter checking of new
object literals in [TypeScript 1.6](/docs/handbook/release-
notes/typescript-1-6.html#stricter-object-literal-assignment-checks).

We don‚Äôt recommend using this flag in a modern codebase, you can suppress one-
off cases where you need it using `// @ts-ignore`.

### # Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`

Turning `suppressImplicitAnyIndexErrors` on suppresses reporting the error
about implicit anys when indexing into objects, as shown in the following
example:

    
    
    ts
    
    const obj = { x: 10 };
    
    console.log(obj["foo"]);
    
    Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.7053Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM7mKKmX30IobZ76yQATSgA8AoqVLRS9YgDMAhsno064emQxZiZKrTDhKEqTNAB2AAwBWAMzV00SOtDQARgCtQAXlABvUMOIARnNQAF8AbjsHemhkSgA6ZGgAcwAKVzcAbQAiWWhobIBdAEpwoA)

Using `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is
recommended to use a `@ts-ignore` comment instead:

    
    
    ts
    
    const obj = { x: 10 };
    
    // @ts-ignore
    
    console.log(obj["foo"]);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM5kZbFlXXrSSOjQBGAK1ABeUAG9QAD2IBGAAygAvgG5aYcFnoBaVAHMYpGp27RklAHTJougBT8BAbQBEAM2jQnAXQCUyoA)

  * Related:
    * `noImplicitAny`

## #Language and Environment

### # Emit Decorator Metadata - `emitDecoratorMetadata`

Enables experimental support for emitting type metadata for decorators which
works with the module [`reflect-
metadata`](https://www.npmjs.com/package/reflect-metadata).

For example, here is the TypeScript

    
    
    ts
    
    function LogMethod(
    
      target: any,
    
      propertyKey: string | symbol,
    
      descriptor: PropertyDescriptor
    
    ) {
    
      console.log(target);
    
      console.log(propertyKey);
    
      console.log(descriptor);
    
    }
    
    ¬†
    
    class Demo {
    
      @LogMethod
    
      public foo(bar: number) {
    
        // do nothing
    
      }
    
    }
    
    ¬†
    
    const demo = new Demo();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgAyJA5gLKRMACxIATABQ1QoHAh6CAXKGzoAngBopoWAhLwEmVQGlIqpVUzJ0PUAB9QVVSgBGJXJumjIVIsliUEJQAFXX1DQh8-AJoASlAAby1SdCo3SAA6XF5xWXlMGIBuJPZU3AysnnEdPURDE1VC4pS0zOyvSKR-MkaAXxoaIlxsKipQQhQSBK1wbn5BEVEtWAZnXCQiUDoSEnFnbEDQdAYXRDjE6WkQUFFJ9BJhJGstPr6BksxryAnQAF5DyAA7mMvjtCkA)

With `emitDecoratorMetadata` not set to true (default) the emitted JavaScript
is:

    
    
    ts
    
    "use strict";
    
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    
    };
    
    function LogMethod(target, propertyKey, descriptor) {
    
        console.log(target);
    
        console.log(propertyKey);
    
        console.log(descriptor);
    
    }
    
    class Demo {
    
        foo(bar) {
    
            // do nothing
    
        }
    
    }
    
    __decorate([
    
        LogMethod
    
    ], Demo.prototype, "foo", null);
    
    const demo = new Demo();
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmNAZgK7oimJCXSgAMiQDmAWUiZmAEwAUNUKBwIp8gFyhs6AJ4AaNaFgIS8BJkMBpSIb1VMydFNAAfUFUMoARiS4puqKkFREyLCUCHoACpbWtoQRUTE0AJSgAN5mpOhUQZAAdLjSypramBkA3HmihbglZVLKFlaItg6GtfUFRaXlYalI0WS9AL40NES42FRUoIQoJDlm4JKy8kpmsHz+uEhEoDwkJMr+2LGg6HwBiFm56ur0iqvoJApI7mZTUzMNTCgMIrUAAXhukBYS0gK2UtSAA)

With `emitDecoratorMetadata` set to true the emitted JavaScript is:

    
    
    ts
    
    "use strict";
    
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    
    };
    
    var __metadata = (this && this.__metadata) || function (k, v) {
    
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    
    };
    
    function LogMethod(target, propertyKey, descriptor) {
    
        console.log(target);
    
        console.log(propertyKey);
    
        console.log(descriptor);
    
    }
    
    class Demo {
    
        foo(bar) {
    
            // do nothing
    
        }
    
    }
    
    __decorate([
    
        LogMethod,
    
        __metadata("design:type", Function),
    
        __metadata("design:paramtypes", [Number]),
    
        __metadata("design:returntype", void 0)
    
    ], Demo.prototype, "foo", null);
    
    const demo = new Demo();
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmdYUnmhUuUoIAspBwATCthoAzAK7oimJCXSgAMiQDm4zM0kAKGqFA4EOiQC5Q2dAE8ANKdCwEJeAkwOA0pAdbKkxkdB1QAB9QKgcUACMSXBczSUgqImRYEVsABQ8vH0J0zJEaAEpQAG9XUnQqRMgAOlxdIwsrTDKAbhr1etwmlp0jd09EH38Hbt66hubW1OKkLLJpgF8aGiJcbCoqUEIUEirXcG09CUNXWAU43CQiUDkSEiM47ARbdAV4xArqsxmeiSY7oEgGJBhVwbDZbPqYUCpI6gAC8oHQkBYB0gRyM3SAA)

  * Related:
    * `experimentalDecorators`

### # Experimental Decorators - `experimentalDecorators`

Enables [experimental support for
decorators](https://github.com/tc39/proposal-decorators), which is a version
of decorators that predates the TC39 standardization process.

Decorators are a language feature which hasn‚Äôt yet been fully ratified into
the JavaScript specification. This means that the implementation version in
TypeScript may differ from the implementation in JavaScript when it it decided
by TC39.

You can find out more about decorator support in TypeScript in [the
handbook](/docs/handbook/decorators.html).

  * Related:
    * `emitDecoratorMetadata`

### # JSX - `jsx`

Controls how JSX constructs are emitted in JavaScript files. This only affects
output of JS files that started in `.tsx` files.

  * `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production
  * `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only
  * `preserve`: Emit `.jsx` files with the JSX unchanged
  * `react-native`: Emit `.js` files with the JSX unchanged
  * `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls

### For example

This sample code:

    
    
    tsx
    
    export const HelloWorld = () => <h1>Hello world</h1>;

React: `"react-jsx"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-
new-jsx-transform.html)

    
    
    tsx
    
    import { jsx as _jsx } from "react/jsx-runtime";
    
    export const HelloWorld = () => _jsx("h1", { children: "Hello world" });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q2kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQLAHxwADwZAIzro+MQcNkzrFvke+txQA)

React dev transform: `"react-
jsxdev"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html)

    
    
    tsx
    
    import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
    
    const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx";
    
    export const HelloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q3sAG6kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJTLAHxwADwZAIxbE1MQcNnzrLvkh1txQA)

Preserve: `"preserve"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => <h1>Hello world</h1>;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BYET2agBuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlEsAfHAAPBkAjJvjkxBw2XOsO+QHm3FAA)

React Native: `"react-native"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => <h1>Hello world</h1>;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhMSigwwABuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlKsAfHAAPBkAjDtTMxBw2Yus++THO3FAA)

Legacy React runtime: `"react"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => React.createElement("h1", null, "Hello world");
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9qRIAB6QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQjAHxwADwZAIzTnd0QcNkDrHPkS9NxQA)

This option can be used on a per-file basis too using an `@jsxRuntime`
comment.

Always use the classic runtime (`"react"`) for this file:

    
    
    tsx
    
    /* @jsxRuntime classic */
    
    export const HelloWorld = () => <h1>Hello world</h1>;

Always use the automatic runtime (`"react-jsx"`) for this file:

    
    
    tsx
    
    /* @jsxRuntime automatic */
    
    export const HelloWorld = () => <h1>Hello world</h1>;

  * Allowed:
    * `preserve`

    * `react`

    * `react-native`

    * `react-jsx`

    * `react-jsxdev`

  * Related:
    * `jsxFactory`

    * `jsxFragmentFactory`

    * `jsxImportSource`

  * Released:

[2.2](/docs/handbook/release-notes/typescript-2-2.html)

### # JSX Factory - `jsxFactory`

Changes the function called in `.js` files when compiling JSX Elements using
the classic JSX runtime. The most common change is to use `"h"` or
`"preact.h"` instead of the default `"React.createElement"` if using `preact`.

For example, this TSX file:

    
    
    tsx
    
    import { h } from "preact";
    
    const HelloWorld = () => <div>Hello</div>;

With `jsxFactory: "h"` looks like:

    
    
    tsx
    
    const preact_1 = require("preact");
    
    const HelloWorld = () => (0, preact_1.h)("div", null, "Hello");
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdTmiPyg4oJymJgooAcyQw6kgcmnoinmwgELL0KupouFGaxqSkoJCwcADecFwANHDyUCi+IEia8AC+cNi4cABEYERW9QDcqQmaHPAAEkhKShAA6tBKsnAAvHAAFACUkwB8cAA8ssAAbgt9AxDL5GubrUA)

This option can be used on a per-file basis too similar to [Babel‚Äôs `/** @jsx
h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-
jsx#custom).

    
    
    tsx
    
    /** @jsx h */
    
    import { h } from "preact";
    
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    
    ¬†
    
    const HelloWorld = () => <div>Hello</div>;
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3KlQkWHADewuAF842XHABEYIuhhqA3KVJoIAO17wAEkgA2ViAHVoVgCZwAvHAAUASjcA+OAA8TsAAbr6WNhAB5MFhukA)

The factory chosen will also affect where the `JSX` namespace is looked up
(for type checking information) before falling back to the global one.

If the factory is defined as `React.createElement` (the default), the compiler
will check for `React.JSX` before checking for a global `JSX`. If the factory
is defined as `h`, it will check for `h.JSX` before a global `JSX`.

  * Default:

`React.createElement`

  * Allowed:
    * Any identifier or dotted identifier.

  * Related:
    * `jsx`

    * `jsxFragmentFactory`

    * `jsxImportSource`

### # JSX Fragment Factory - `jsxFragmentFactory`

Specify the JSX fragment factory function to use when targeting react JSX emit
with `jsxFactory` compiler option is specified, e.g. `Fragment`.

For example with this TSConfig:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react",
    
        "[jsxFactory](https://www.typescriptlang.org/tsconfig#jsxFactory)": "h",
    
        "[jsxFragmentFactory](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)": "Fragment"
    
      }
    
    }

This TSX file:

    
    
    tsx
    
    import { h, Fragment } from "preact";
    
    const HelloWorld = () => (
    
      <>
    
        <div>Hello</div>
    
      </>
    
    );

Would look like:

    
    
    tsx
    
    const preact_1 = require("preact");
    
    const HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,
    
        (0, preact_1.h)("div", null, "Hello")));
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdT5+VBQBzEEk0xLGW+uduHl6mmhD8UDhQJpRiMChQrkgw6kgcmnoiMWwgELL0KupouDmaxqSkoJCwcADecFwANHAB7p7wAL5w2LhwAERgRFa9ANzlRZoc8AASSEpKEADq0EqycAC8cAAUAJTrAHxbpHBwADx7R8enssAAbnszcxAn5Nd3F8-n28NAA)

This option can be used on a per-file basis too similar to [Babel‚Äôs `/*
@jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-
react-jsx#fragments).

For example:

    
    
    tsx
    
    /** @jsx h */
    
    /** @jsxFrag Fragment */
    
    ¬†
    
    import { h, Fragment } from "preact";
    
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    
    ¬†
    
    const HelloWorld = () => (
    
      <>
    
        <div>Hello</div>
    
      </>
    
    );
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3JsOPAQDEoKAOZxZCkEgB28MaVKhIsOAG9hAGiVz5qjXAC+cbLjgAiMEXQxHAbm1oIa3vAAJJAAbYIgAdWhggBM4AF44AAoASniAPiTSODgAHjSs7Nzo4AA3NKDQiBzyYrKC6vzkjyA)

  * Default:

`React.Fragment`

  * Related:
    * `jsx`

    * `jsxFactory`

    * `jsxImportSource`

  * Released:

[4.0](/docs/handbook/release-notes/typescript-4-0.html)

### # JSX Import Source - `jsxImportSource`

Declares the module specifier to be used for importing the `jsx` and `jsxs`
factory functions when using `jsx` as `"react-jsx"` or `"react-jsxdev"` which
were introduced in TypeScript 4.1.

With [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html) the library supports a new form of JSX transformation via a
separate import.

For example with this code:

    
    
    tsx
    
    import React from "react";
    
    function App() {
    
      return <h1>Hello World</h1>;
    
    }

Using this TSConfig:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx"
    
      }
    
    }

The emitted JavaScript from TypeScript is:

    
    
    tsx
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const jsx_runtime_1 = require("react/jsx-runtime");
    
    function App() {
    
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggO1ogE6GyGTZjgBWkAHgFyiECmAhgMboC0NtFEyWABMArgBtmjdrGSDcNfuHStCAc2bpGzSLma0sQ5uzErmoQaImgAUgGUAGqADemUKFS50zQgDMOZxAlkZk9nAF9Xd09vP3YzAElPQg9IVHZA5mDPSGdItwBtSEZIdGTcVQBdRlZcAE8AbkiIiNRkAAdSdFAAJTZOUB8SZFAAIhYOdBHGzB8RXE5UWFxQAEE2toAKAEpctxZ0EUJlgB5oAEYAPgAJZjExWFAAdVIxIWPgc4vGsKA)

For example if you wanted to use `"jsxImportSource": "preact"`, you need a
tsconfig like:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx",
    
        "[jsxImportSource](https://www.typescriptlang.org/tsconfig#jsxImportSource)": "preact",
    
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["preact"]
    
      }
    
    }

Which generates code like:

    
    
    tsx
    
    function App() {
    
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOGwBWHAB4BJcNBgBlCPShokALjhgi6EZTEwAnmCQctO4vvaSpW3Rmq3RbGCigBzJDC1mAdkhS1mIgEAAm9AA2mnBouKF+ki5+EPxQOFAcpKSBkLBwmPR+GMAQfnAAgmBgABQAlHAA3qRwcEQwquUAPFwAjAB8ABJIkZEQcADq0JFhXeR9-QDcpAC+QA)

Alternatively, you can use a per-file pragma to set this option, for example:

    
    
    tsx
    
    /** @jsxImportSource preact */
    
    export function App() {
    
      return <h1>Hello World</h1>;
    
    }

Would add `preact/jsx-runtime` as an import for the `_jsx` factory.

_Note:_ In order for this to work like you would expect, your `tsx` file must
include an `export` or `import` so that it is considered a module.

  * Default:

`react`

  * Related:
    * `jsx`

    * `jsxFactory`

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

### # Lib - `lib`

TypeScript includes a default set of type definitions for built-in JS APIs
(like `Math`), as well as type definitions for things found in browser
environments (like `document`). TypeScript also includes APIs for newer JS
features matching the `target` you specify; for example the definition for
`Map` is available if `target` is `ES6` or newer.

You may want to change these for a few reasons:

  * Your program doesn‚Äôt run in a browser, so you don‚Äôt want the `"dom"` type definitions
  * Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn‚Äôt yet support the full syntax of a given ECMAScript version
  * You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version

In TypeScript 4.5, lib files can be overridden by npm modules, find out more
[in the blog](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-5-beta/#supporting-lib-from-node_modules).

### High Level libraries

Name | Contents  
---|---  
`ES5` | Core definitions for all ES5 functionality  
`ES2015` | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.  
`ES6` | Alias for ‚ÄúES2015‚Äù  
`ES2016` | Additional APIs available in ES2016 - `array.include`, etc.  
`ES7` | Alias for ‚ÄúES2016‚Äù  
`ES2017` | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc.  
`ES2018` | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.  
`ES2019` | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.  
`ES2020` | Additional APIs available in ES2020 - `string.matchAll`, etc.  
`ES2021` | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.  
`ES2022` | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.  
`ES2023` | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.  
`ESNext` | Additional APIs available in ESNext - This changes as the JavaScript specification evolves  
`DOM` | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.  
`WebWorker` | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts  
`ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)  
  
### Individual library components

Name  
---  
`DOM.Iterable`  
`ES2015.Core`  
`ES2015.Collection`  
`ES2015.Generator`  
`ES2015.Iterable`  
`ES2015.Promise`  
`ES2015.Proxy`  
`ES2015.Reflect`  
`ES2015.Symbol`  
`ES2015.Symbol.WellKnown`  
`ES2016.Array.Include`  
`ES2017.object`  
`ES2017.Intl`  
`ES2017.SharedMemory`  
`ES2017.String`  
`ES2017.TypedArrays`  
`ES2018.Intl`  
`ES2018.Promise`  
`ES2018.RegExp`  
`ES2019.Array`  
`ES2019.Object`  
`ES2019.String`  
`ES2019.Symbol`  
`ES2020.String`  
`ES2020.Symbol.wellknown`  
`ES2021.Promise`  
`ES2021.String`  
`ES2021.WeakRef`  
`ESNext.AsyncIterable`  
`ESNext.Array`  
`ESNext.Intl`  
`ESNext.Symbol`  
  
This list may be out of date, you can see the full list in the [TypeScript
source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).

  * Related:
    * `noLib`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Module Detection - `moduleDetection`

This setting controls how TypeScript determines whether a file is a [script or
a module](/docs/handbook/modules/theory.html#scripts-and-modules-in-
javascript).

There are three choices:

  * `"auto"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `"type"` field in a `package.json` is set to `"module"` when running with `module`: `nodenext` or `node16`, and check whether the current file is a JSX file when running under `jsx`: `react-jsx`.

  * `"legacy"` \- The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.

  * `"force"` \- Ensures that every non-declaration file is treated as a module.

  * Default:

"auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-
jsx), or esm format (with module: node16+) as modules.

  * Allowed:
    * `legacy`

    * `auto`

    * `force`

  * Released:

[4.7](/docs/handbook/release-notes/typescript-4-7.html)

### # No Lib - `noLib`

Disables the automatic inclusion of any library files. If this option is set,
`lib` is ignored.

TypeScript _cannot_ compile anything without a set of interfaces for key
primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`,
`Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you
will be including your own type definitions for these.

  * Related:
    * `lib`

### # React Namespace - `reactNamespace`

Use `jsxFactory` instead. Specify the object invoked for `createElement` when
targeting `react` for TSX files.

  * Default:

`React`

### # Target - `target`

Modern browsers support all ES6 features, so `ES6` is a good choice. You might
choose to set a lower target if your code is deployed to older environments,
or a higher target if your code is guaranteed to run in newer environments.

The `target` setting changes which JS features are downleveled and which are
left intact. For example, an arrow function `() => this` will be turned into
an equivalent `function` expression if `target` is ES5 or lower.

Changing `target` also changes the default value of `lib`. You may ‚Äúmix and
match‚Äù `target` and `lib` settings as desired, but you could just set `target`
for convenience.

For developer platforms like Node there are baselines for the `target`,
depending on the type of platform and its version. You can find a set of
community organized TSConfigs at
[tsconfig/bases](https://github.com/tsconfig/bases#centralized-
recommendations-for-tsconfig-bases), which has configurations for common
platforms and their versions.

The special `ESNext` value refers to the highest version your version of
TypeScript supports. This setting should be used with caution, since it
doesn‚Äôt mean the same thing between different TypeScript versions and can make
upgrades less predictable.

  * Default:

`ES5`

  * Allowed:
    * `es3`

    * `es5`

    * `es6`/`es2015`

    * `es2016`

    * `es2017`

    * `es2018`

    * `es2019`

    * `es2020`

    * `es2021`

    * `es2022`

    * `es2023`

    * `esnext`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Use Define For Class Fields - `useDefineForClassFields`

This flag is used as part of migrating to the upcoming standard version of
class fields. TypeScript introduced class fields many years before it was
ratified in TC39. The latest version of the upcoming specification has a
different runtime behavior to TypeScript‚Äôs implementation but the same syntax.

This flag switches to the upcoming ECMA runtime behavior.

You can read more about the transition in [the 3.7 release
notes](/docs/handbook/release-notes/typescript-3-7.html#the-
usedefineforclassfields-flag-and-the-declare-property-modifier).

  * Default:

`true` if `target` is `ES2022` or higher, including `ESNext`; `false`
otherwise.

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

## #Compiler Diagnostics

### # Diagnostics - `diagnostics`

Used to output diagnostic information for debugging. This command is a subset
of `extendedDiagnostics` which are more user-facing results, and easier to
interpret.

If you have been asked by a TypeScript compiler engineer to give the results
using this flag in a compile, in which there is no harm in using
`extendedDiagnostics` instead.

  * Deprecated
  * Related:
    * `extendedDiagnostics`

### # Explain Files - `explainFiles`

Print names of files which TypeScript sees as a part of your project and the
reason they are part of the compilation.

For example, with this project of just a single `index.ts` file

    
    
    sh
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

Using a `tsconfig.json` which has `explainFiles` set to true:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "target": "es5",
    
        "module": "commonjs",
    
        "explainFiles": true
    
      }
    
    }

Running TypeScript against this folder would have output like this:

    
    
    ‚ùØ tsc
    
    node_modules/typescript/lib/lib.d.ts
    
      Default library for target 'es5'
    
    node_modules/typescript/lib/lib.es5.d.ts
    
      Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.dom.d.ts
    
      Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    
      Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.scripthost.d.ts
    
      Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'
    
    index.ts
    
      Matched by include pattern '**/*' in 'tsconfig.json'

The output above show:

  * The initial lib.d.ts lookup based on `target`, and the chain of `.d.ts` files which are referenced
  * The `index.ts` file located via the default pattern of `include`

This option is intended for debugging how a file has become a part of your
compile.

  * Released:

[4.2](/docs/handbook/release-notes/typescript-4-2.html)

### # Extended Diagnostics - `extendedDiagnostics`

You can use this flag to discover where TypeScript is spending its time when
compiling. This is a tool used for understanding the performance
characteristics of your codebase overall.

You can learn more about how to measure and understand the output in the
performance [section of the
wiki](https://github.com/microsoft/TypeScript/wiki/Performance).

  * Related:
    * `diagnostics`

### # Generate CPU Profile - `generateCpuProfile`

This option gives you the chance to have TypeScript emit a v8 CPU profile
during the compiler run. The CPU profile can provide insight into why your
builds may be slow.

This option can only be used from the CLI via: `--generateCpuProfile tsc-
output.cpuprofile`.

    
    
    sh
    
    npm run tsc --generateCpuProfile tsc-output.cpuprofile

This file can be opened in a chromium based browser like Chrome or Edge
Developer in [the CPU
profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-
tools/js-execution) section. You can learn more about understanding the
compilers performance in the [TypeScript wiki section on
performance](https://github.com/microsoft/TypeScript/wiki/Performance).

  * Default:

`profile.cpuprofile`

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

### # generateTrace - `generateTrace`

Generates an event trace and a list of types.

### # List Emitted Files - `listEmittedFiles`

Print names of generated files part of the compilation to the terminal.

This flag is useful in two cases:

  * You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.
  * You are not sure that TypeScript has included a file you expected, as a part of debugging the file inclusion settings.

For example:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
        "[listEmittedFiles](https://www.typescriptlang.org/tsconfig#listEmittedFiles)": true
    
      }
    
    }

Would echo paths like:

    
    
    $ npm run tsc
    
    path/to/example/index.js
    
    path/to/example/index.d.ts

Normally, TypeScript would return silently on success.

### # List Files - `listFiles`

Print names of files part of the compilation. This is useful when you are not
sure that TypeScript has included a file you expected.

For example:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[listFiles](https://www.typescriptlang.org/tsconfig#listFiles)": true
    
      }
    
    }

Would echo paths like:

    
    
    $ npm run tsc
    
    path/to/example/node_modules/typescript/lib/lib.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.es5.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.dom.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.scripthost.d.ts
    
    path/to/example/index.ts

Note if using TypeScript 4.2, prefer `explainFiles` which offers an
explanation of why a file was added too.

  * Related:
    * `explainFiles`

### # noCheck - `noCheck`

Disable full type checking (only critical parse and emit errors will be
reported).

### # Trace Resolution - `traceResolution`

When you are trying to debug why a module isn‚Äôt being included. You can set
`traceResolution` to `true` to have TypeScript print information about its
resolution process for each processed file.

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

## #Projects

### # Composite - `composite`

The `composite` option enforces certain constraints which make it possible for
build tools (including TypeScript itself, under `--build` mode) to quickly
determine if a project has been built yet.

When this setting is on:

  * The `rootDir` setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.

  * All implementation files must be matched by an `include` pattern or listed in the `files` array. If this constraint is violated, `tsc` will inform you which files weren‚Äôt specified.

  * `declaration` defaults to `true`

You can find documentation on TypeScript projects in [the
handbook](https://www.typescriptlang.org/docs/handbook/project-
references.html).

  * Related:
    * `incremental`

    * `tsBuildInfoFile`

  * Released:

[3.0](/docs/handbook/release-notes/typescript-3-0.html)

### # Disable Referenced Project Load - `disableReferencedProjectLoad`

In multi-project TypeScript programs, TypeScript will load all of the
available projects into memory in order to provide accurate results for editor
responses which require a full knowledge graph like ‚ÄòFind All References‚Äô.

If your project is large, you can use the flag `disableReferencedProjectLoad`
to disable the automatic loading of all projects. Instead, projects are loaded
dynamically as you open files through your editor.

  * Released:

[4.0](/docs/handbook/release-notes/typescript-4-0.html)

### # Disable Solution Searching - `disableSolutionSearching`

When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to declare that you do not want a
project to be included when using features like _find all references_ or _jump
to definition_ in an editor.

This flag is something you can use to increase responsiveness in large
composite projects.

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Disable Source Project Reference Redirect -
`disableSourceOfProjectReferenceRedirect`

When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to go [back to the
pre-3.7](/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-
with-project-references) behavior where d.ts files were used to as the
boundaries between modules. In 3.7 the source of truth is now your TypeScript
files.

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

### # Incremental - `incremental`

Tells TypeScript to save information about the project graph from the last
compilation to files stored on disk. This creates a series of `.tsbuildinfo`
files in the same folder as your compilation output. They are not used by your
JavaScript at runtime and can be safely deleted. You can read more about the
flag in the [3.4 release notes](/docs/handbook/release-
notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-
flag).

To control which folders you want to the files to be built to, use the config
option `tsBuildInfoFile`.

  * Default:

`true` if `composite`; `false` otherwise.

  * Related:
    * `composite`

    * `tsBuildInfoFile`

  * Released:

[3.4](/docs/handbook/release-notes/typescript-3-4.html)

### # TS Build Info File - `tsBuildInfoFile`

This setting lets you specify a file for storing incremental compilation
information as a part of composite projects which enables faster building of
larger TypeScript codebases. You can read more about composite projects [in
the handbook](/docs/handbook/project-references.html).

The default depends on a combination of other settings:

  * If `outFile` is set, the default is `<outFile>.tsbuildinfo`.
  * If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.
  * If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`
  * Otherwise, the default is `<config name>.tsbuildInfo`

  * Default:

`.tsbuildinfo`

  * Related:
    * `incremental`

    * `composite`

  * Released:

[3.4](/docs/handbook/release-notes/typescript-3-4.html)

## #Output Formatting

### # No Error Truncation - `noErrorTruncation`

Do not truncate error messages.

With `false`, the default.

    
    
    ts
    
    var x: {
    
      propertyWithAnExceedinglyLongName1: string;
    
      propertyWithAnExceedinglyLongName2: string;
    
      propertyWithAnExceedinglyLongName3: string;
    
      propertyWithAnExceedinglyLongName4: string;
    
      propertyWithAnExceedinglyLongName5: string;
    
      propertyWithAnExceedinglyLongName6: string;
    
      propertyWithAnExceedinglyLongName7: string;
    
      propertyWithAnExceedinglyLongName8: string;
    
    };
    
    ¬†
    
    // String representation of type of 'x' should be truncated in error message
    
    var s: string = x;
    
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQAbgIbSgAeqA3kaKAA7xMwAuAngOoCW7ACwCCAOwCiVAMaRIAE14iA5gBtOAGThKAcmQC2kAIypE7aAsUBuBs1Yce-YeKkz5S1Ru17IaY6fNXGFjg2aC4+QVEJaTlzd01FHX0MXzMlAJtgu3DHKJdY9XjEyFwU-2sgkLCHSOcYtwLPfXxStPLbUPsIp2jXFQaErwA2Fss2zI7smp78jwH9AHYR9Iqs6u68+tmigA4logBfKyIQUABlPyVQaEgWSERIEXYydl5NUDgAM1AuNnevgHIqP9QIgBHAAK7KWSgABGkG+0HBIkkzzkoAUoBg8Eo+kQiDIikgpAoIJGoAAvNQLEA)

With `true`

    
    
    ts
    
    var x: {
    
      propertyWithAnExceedinglyLongName1: string;
    
      propertyWithAnExceedinglyLongName2: string;
    
      propertyWithAnExceedinglyLongName3: string;
    
      propertyWithAnExceedinglyLongName4: string;
    
      propertyWithAnExceedinglyLongName5: string;
    
      propertyWithAnExceedinglyLongName6: string;
    
      propertyWithAnExceedinglyLongName7: string;
    
      propertyWithAnExceedinglyLongName8: string;
    
    };
    
    ¬†
    
    // String representation of type of 'x' should be truncated in error message
    
    var s: string = x;
    
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQIEAdnAKKwIAq0ArmQMYCGALgJZxmruOQiAN1bRQAD1QBvIqFAAHePJjsAngHVO7ABYBBMpXHNIkACacyAcwA2qgDI9LAOVYBbSAEZUifhcsBuWQUlFQ0tPQMjE3MrWwcrF3c0b18rQLlFOGVoNU0dfUNjMz84x0TIDBToP3TgrNC8iMLokvsyt0hcKpqgzOzc8IKo4ti2hI78brTekJyw-MiimJsx5w6ANimAmfq5xqGl1vi19wB2Ldq+hsHFltHj8oAOC6IAX0CSMABlVMtQaEgikgiEgZHYHG4ZFAcAAZqA1MpoXCAOTiZGgRDaOAMaymUAAI0g8MYLA4ZlAFlAMHgYnciEQrEsghEYhQGN+oAAvBJ-EA)

### # Preserve Watch Output - `preserveWatchOutput`

Whether to keep outdated console output in watch mode instead of clearing the
screen every time a change happened.

  * Internal

### # Pretty - `pretty`

Stylize errors and messages using color and context, this is on by default ‚Äî
offers you a chance to have less terse, single colored messages from the
compiler.

  * Default:

`true`

## #Completeness

### # Skip Default Lib Check - `skipDefaultLibCheck`

Use `skipLibCheck` instead. Skip type checking of default library declaration
files.

### # Skip Lib Check - `skipLibCheck`

Skip type checking of declaration files.

This can save time during compilation at the expense of type-system accuracy.
For example, two libraries could define two copies of the same `type` in an
inconsistent way. Rather than doing a full check of all `d.ts` files,
TypeScript will type check the code you specifically refer to in your app‚Äôs
source code.

A common case where you might think to use `skipLibCheck` is when there are
two copies of a library‚Äôs types in your `node_modules`. In these cases, you
should consider using a feature like [yarn‚Äôs
resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/)
to ensure there is only one copy of that dependency in your tree or
investigate how to ensure there is only one copy by understanding the
dependency resolution to fix the issue without additional tooling.

Another possibility is when you are migrating between TypeScript releases and
the changes cause breakages in node_modules and the JS standard libraries
which you do not want to deal with during the TypeScript update.

Note, that if these issues come from the TypeScript standard library you can
replace the library using [TypeScript 4.5‚Äôs lib
replacement](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.

  * Recommended
  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

## #Command Line

## #Watch Options

TypeScript 3.8 shipped a new strategy for watching directories, which is
crucial for efficiently picking up changes to `node_modules`.

On operating systems like Linux, TypeScript installs directory watchers (as
opposed to file watchers) on `node_modules` and many of its subdirectories to
detect changes in dependencies. This is because the number of available file
watchers is often eclipsed by the number of files in `node_modules`, whereas
there are way fewer directories to track.

Because every project might work better under different strategies, and this
new approach might not work well for your workflows, TypeScript 3.8 introduces
a new `watchOptions` field which allows users to tell the compiler/language
service which watching strategies should be used to keep track of files and
directories.

### # Assume Changes Only Affect Direct Dependencies -
`assumeChangesOnlyAffectDirectDependencies`

When this option is enabled, TypeScript will avoid rechecking/rebuilding all
truly possibly-affected files, and only recheck/rebuild files that have
changed as well as files that directly import them.

This can be considered a ‚Äòfast & loose‚Äô implementation of the watching
algorithm, which can drastically reduce incremental rebuild times at the
expense of having to run the full build occasionally to get all compiler error
messages.

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

## Watch Options

You can configure the how TypeScript `--watch` works. This section is mainly
for handling case where `fs.watch` and `fs.watchFile` have additional
constraints like on Linux. You can read more at [Configuring
Watch](/docs/handbook/configuring-watch.html).

### # Watch File - `watchFile`

The strategy for how individual files are watched.

  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for file changes.
  * `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system‚Äôs native events to listen for changes on a file‚Äôs parent directory

  * Allowed:
    * `fixedpollinginterval`

    * `prioritypollinginterval`

    * `dynamicprioritypolling`

    * `fixedchunksizepolling`

    * `usefsevents`

    * `usefseventsonparentdirectory`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Watch Directory - `watchDirectory`

The strategy for how entire directory trees are watched under systems that
lack recursive file-watching functionality.

  * `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for directory changes.

  * Allowed:
    * `usefsevents`

    * `fixedpollinginterval`

    * `dynamicprioritypolling`

    * `fixedchunksizepolling`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Fallback Polling - `fallbackPolling`

When using file system events, this option specifies the polling strategy that
gets used when the system runs out of native file watchers and/or doesn‚Äôt
support native file watchers.

  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.

  * Allowed:
    * `fixedinterval`

    * `priorityinterval`

    * `dynamicpriority`

    * `fixedchunksize`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Synchronous Watch Directory - `synchronousWatchDirectory`

Synchronously call callbacks and update the state of directory watchers on
platforms that don`t support recursive watching natively. Instead of giving a
small timeout to allow for potentially multiple edits to occur on a file.

    
    
    {
    
      "watchOptions": {
    
        "[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory)": true
    
      }
    
    }

### # Exclude Directories - `excludeDirectories`

You can use `excludeFiles` to drastically reduce the number of files which are
watched during `--watch`. This can be a useful way to reduce the number of
open file which TypeScript tracks on Linux.

    
    
    {
    
      "watchOptions": {
    
        "[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories)": ["**/node_modules", "_build", "temp/*"]
    
      }
    
    }

### # Exclude Files - `excludeFiles`

You can use `excludeFiles` to remove a set of specific files from the files
which are watched.

    
    
    {
    
      "watchOptions": {
    
        "[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles)": ["temp/file.ts"]
    
      }
    
    }

## Type Acquisition

Type Acquisition is only important for JavaScript projects. In TypeScript
projects you need to include the types in your projects explicitly. However,
for JavaScript projects, the TypeScript tooling will download types for your
modules in the background and outside of your node_modules folder.

### # Enable - `enable`

Disables automatic type acquisition in JavaScript projects:

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "enable": false
    
      }
    
    }

### # Include - `include`

If you have a JavaScript project where TypeScript needs additional guidance to
understand global dependencies, or have disabled the built-in inference via
`disableFilenameBasedTypeAcquisition`.

You can use `include` to specify which types should be used from
DefinitelyTyped:

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "include": ["jquery"]
    
      }
    
    }

### # Exclude - `exclude`

Offers a config for disabling the type-acquisition for a certain module in
JavaScript projects. This can be useful for projects which include other
libraries in testing infrastructure which aren‚Äôt needed in the main
application.

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "exclude": ["jest", "mocha"]
    
      }
    
    }

### # Disable Filename Based Type Acquisition -
`disableFilenameBasedTypeAcquisition`

TypeScript‚Äôs type acquisition can infer what types should be added based on
filenames in a project. This means that having a file like `jquery.js` in your
project would automatically download the types for JQuery from
DefinitelyTyped.

You can disable this via `disableFilenameBasedTypeAcquisition`.

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "disableFilenameBasedTypeAcquisition": true
    
      }
    
    }

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

 Intro to the TSConfig ReferenceA TSConfig file in a directory indicates that
the directory is the root of a TypeScript or JavaScript project...

## Compiler Options

##### Top Level

  1. `files, `
  2. `extends, `
  3. `include, `
  4. `exclude and `
  5. `references`

#### `"compilerOptions"`

##### Type Checking

  1. `allowUnreachableCode, `
  2. `allowUnusedLabels, `
  3. `alwaysStrict, `
  4. `exactOptionalPropertyTypes, `
  5. `noFallthroughCasesInSwitch, `
  6. `noImplicitAny, `
  7. `noImplicitOverride, `
  8. `noImplicitReturns, `
  9. `noImplicitThis, `
  10. `noPropertyAccessFromIndexSignature, `
  11. `noUncheckedIndexedAccess, `
  12. `noUnusedLocals, `
  13. `noUnusedParameters, `
  14. `strict, `
  15. `strictBindCallApply, `
  16. `strictBuiltinIteratorReturn, `
  17. `strictFunctionTypes, `
  18. `strictNullChecks, `
  19. `strictPropertyInitialization and `
  20. `useUnknownInCatchVariables`

##### Modules

  1. `allowArbitraryExtensions, `
  2. `allowImportingTsExtensions, `
  3. `allowUmdGlobalAccess, `
  4. `baseUrl, `
  5. `customConditions, `
  6. `module, `
  7. `moduleResolution, `
  8. `moduleSuffixes, `
  9. `noResolve, `
  10. `noUncheckedSideEffectImports, `
  11. `paths, `
  12. `resolveJsonModule, `
  13. `resolvePackageJsonExports, `
  14. `resolvePackageJsonImports, `
  15. `rootDir, `
  16. `rootDirs, `
  17. `typeRoots and `
  18. `types`

##### Emit

  1. `declaration, `
  2. `declarationDir, `
  3. `declarationMap, `
  4. `downlevelIteration, `
  5. `emitBOM, `
  6. `emitDeclarationOnly, `
  7. `importHelpers, `
  8. `inlineSourceMap, `
  9. `inlineSources, `
  10. `mapRoot, `
  11. `newLine, `
  12. `noEmit, `
  13. `noEmitHelpers, `
  14. `noEmitOnError, `
  15. `outDir, `
  16. `outFile, `
  17. `preserveConstEnums, `
  18. `removeComments, `
  19. `sourceMap, `
  20. `sourceRoot and `
  21. `stripInternal`

##### JavaScript Support

  1. `allowJs, `
  2. `checkJs and `
  3. `maxNodeModuleJsDepth`

##### Editor Support

  1. `disableSizeLimit and `
  2. `plugins`

##### Interop Constraints

  1. `allowSyntheticDefaultImports, `
  2. `esModuleInterop, `
  3. `forceConsistentCasingInFileNames, `
  4. `isolatedDeclarations, `
  5. `isolatedModules, `
  6. `preserveSymlinks and `
  7. `verbatimModuleSyntax`

##### Backwards Compatibility

  1. `charset, `
  2. `importsNotUsedAsValues, `
  3. `keyofStringsOnly, `
  4. `noImplicitUseStrict, `
  5. `noStrictGenericChecks, `
  6. `out, `
  7. `preserveValueImports, `
  8. `suppressExcessPropertyErrors and `
  9. `suppressImplicitAnyIndexErrors`

##### Language and Environment

  1. `emitDecoratorMetadata, `
  2. `experimentalDecorators, `
  3. `jsx, `
  4. `jsxFactory, `
  5. `jsxFragmentFactory, `
  6. `jsxImportSource, `
  7. `lib, `
  8. `moduleDetection, `
  9. `noLib, `
  10. `reactNamespace, `
  11. `target and `
  12. `useDefineForClassFields`

##### Compiler Diagnostics

  1. `diagnostics, `
  2. `explainFiles, `
  3. `extendedDiagnostics, `
  4. `generateCpuProfile, `
  5. `generateTrace, `
  6. `listEmittedFiles, `
  7. `listFiles, `
  8. `noCheck and `
  9. `traceResolution`

##### Projects

  1. `composite, `
  2. `disableReferencedProjectLoad, `
  3. `disableSolutionSearching, `
  4. `disableSourceOfProjectReferenceRedirect, `
  5. `incremental and `
  6. `tsBuildInfoFile`

##### Output Formatting

  1. `noErrorTruncation, `
  2. `preserveWatchOutput and `
  3. `pretty`

##### Completeness

  1. `skipDefaultLibCheck and `
  2. `skipLibCheck`

##### Command Line

##### Watch Options

  1. `assumeChangesOnlyAffectDirectDependencies`

#### `"watchOptions"`

##### watchOptions

  1. `watchFile, `
  2. `watchDirectory, `
  3. `fallbackPolling, `
  4. `synchronousWatchDirectory, `
  5. `excludeDirectories and `
  6. `excludeFiles`

#### `"typeAcquisition"`

##### typeAcquisition

  1. `enable, `
  2. `include, `
  3. `exclude and `
  4. `disableFilenameBasedTypeAcquisition`

### Root Fields

Starting up are the root options in the TSConfig - these options relate to how
your TypeScript or JavaScript project is set up.

### # Files - `files`

Specifies an allowlist of files to include in the program. An error occurs if
any of the files can‚Äôt be found.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {},
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": [
    
        "core.ts",
    
        "sys.ts",
    
        "types.ts",
    
        "scanner.ts",
    
        "parser.ts",
    
        "utilities.ts",
    
        "binder.ts",
    
        "checker.ts",
    
        "tsc.ts"
    
      ]
    
    }

This is useful when you only have a small number of files and don‚Äôt need to
use a glob to reference many files. If you need that then use `include`.

  * Default:

`false`

  * Related:
    * `include`

    * `exclude`

### # Extends - `extends`

The value of `extends` is a string which contains a path to another
configuration file to inherit from. The path may use Node.js style resolution.

The configuration from the base file are loaded first, then overridden by
those in the inheriting config file. All relative paths found in the
configuration file will be resolved relative to the configuration file they
originated in.

It‚Äôs worth noting that `files`, `include`, and `exclude` from the inheriting
config file _overwrite_ those from the base config file, and that circularity
between configuration files is not allowed.

Currently, the only top-level property that is excluded from inheritance is
`references`.

##### Example

`configs/base.json`:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": true
    
      }
    
    }

`tsconfig.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./configs/base",
    
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["main.ts", "supplemental.ts"]
    
    }

`tsconfig.nostrictnull.json`:

    
    
    {
    
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./tsconfig",
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": false
    
      }
    
    }

Properties with relative paths found in the configuration file, which aren‚Äôt
excluded from inheritance, will be resolved relative to the configuration file
they originated in.

  * Default:

`false`

  * Released:

[2.1](/docs/handbook/release-notes/typescript-2-1.html)

### # Include - `include`

Specifies an array of filenames or patterns to include in the program. These
filenames are resolved relative to the directory containing the
`tsconfig.json` file.

    
    
    json
    
    {
    
      "include": ["src/**/*", "tests/**/*"]
    
    }

Which would include:

    
    
    .
    
    ‚îú‚îÄ‚îÄ scripts                ‚®Ø
    
    ‚îÇ   ‚îú‚îÄ‚îÄ lint.ts            ‚®Ø
    
    ‚îÇ   ‚îú‚îÄ‚îÄ update_deps.ts     ‚®Ø
    
    ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts           ‚®Ø
    
    ‚îú‚îÄ‚îÄ src                    ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ client             ‚úì
    
    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ index.ts      ‚úì
    
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ utils.ts      ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ server             ‚úì
    
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ index.ts      ‚úì
    
    ‚îú‚îÄ‚îÄ tests                  ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ app.test.ts        ‚úì
    
    ‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           ‚úì
    
    ‚îÇ   ‚îî‚îÄ‚îÄ tests.d.ts         ‚úì
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îî‚îÄ‚îÄ yarn.lock

`include` and `exclude` support wildcard characters to make glob patterns:

  * `*` matches zero or more characters (excluding directory separators)
  * `?` matches any one character (excluding directory separators)
  * `**/` matches any directory nested to any level

If the last path segment in a pattern does not contain a file extension or
wildcard character, then it is treated as a directory, and files with
supported extensions inside that directory are included (e.g. `.ts`, `.tsx`,
and `.d.ts` by default, with `.js` and `.jsx` if `allowJs` is set to true).

  * Default:

`[]` if `files` is specified; `**/*` otherwise.

  * Related:
    * `files`

    * `exclude`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Exclude - `exclude`

Specifies an array of filenames or patterns that should be skipped when
resolving `include`.

**Important** : `exclude` _only_ changes which files are included as a result
of the `include` setting. A file specified by `exclude` can still become part
of your codebase due to an `import` statement in your code, a `types`
inclusion, a `/// <reference` directive, or being specified in the `files`
list.

It is not a mechanism that **prevents** a file from being included in the
codebase - it simply changes what the `include` setting finds.

  * Default:

node_modules bower_components jspm_packages `outDir`

  * Related:
    * `include`

    * `files`

### # References - `references`

Project references are a way to structure your TypeScript programs into
smaller pieces. Using Project References can greatly improve build and editor
interaction times, enforce logical separation between components, and organize
your code in new and improved ways.

You can read more about how references works in the [Project
References](/docs/handbook/project-references.html) section of the handbook

  * Default:

`false`

### Compiler Options

These options make up the bulk of TypeScript‚Äôs configuration and it covers how
the language should work.

## #Type Checking

### # Allow Unreachable Code - `allowUnreachableCode`

When:

  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unreachable code is ignored
  * `false` raises compiler errors about unreachable code

These warnings are only about code which is provably unreachable due to the
use of JavaScript syntax, for example:

    
    
    ts
    
    function fn(n: number) {
    
      if (n > 5) {
    
        return true;
    
      } else {
    
        return false;
    
      }
    
      return true;
    
    }

With `"allowUnreachableCode": false`:

    
    
    ts
    
    function fn(n: number) {
    
      if (n > 5) {
    
        return true;
    
      } else {
    
        return false;
    
      }
    
      return true;
    
    Unreachable code detected.7027Unreachable code detected.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMaBQIIBDAG2LgHcBVAO2kkIGMALQgI2MgGE4ATSVAGYlEkXAICu1BgBcAlnGqgB1ABTVU1cQFtWMAJSgA3rlChZA0GtAA+UAFYDx06brTx0RdOjjIAbhOgAL6gkMQiRgEukG4eSsJ+AYEBru6e3gmBQA)

This does not affect errors on the basis of code which _appears_ to be
unreachable due to type analysis.

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Allow Unused Labels - `allowUnusedLabels`

When:

  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unused labels are ignored
  * `false` raises compiler errors about unused labels

Labels are very rare in JavaScript and typically indicate an attempt to write
an object literal:

    
    
    ts
    
    function verifyAge(age: number) {
    
      // Forgot 'return' statement
    
      if (age > 18) {
    
        verified: true;
    
    Unused label.7028Unused label.
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMAOAUCBAIYA2JcA7gKoB2AropACYAyRARpCSqAGamM8vOjQDGAFwCWcGqABuMSbwCeAQQDmkABRFNqegFtO0AJSgA3nlChCAMQTq440AHJokcXWg0XoROKJxSANIGnErUCVQHU1QAD5QAEYcM0trawVoJUlmVHFoOkgAbgiAXzxSoA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Always Strict - `alwaysStrict`

Ensures that your files are parsed in the ECMAScript strict mode, and emit
‚Äúuse strict‚Äù for each source file.

[ECMAScript
strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode)
mode was introduced in ES5 and provides behavior tweaks to the runtime of the
JavaScript engine to improve performance, and makes a set of errors throw
instead of silently ignoring them.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.1](/docs/handbook/release-notes/typescript-2-1.html)

### # Exact Optional Property Types - `exactOptionalPropertyTypes`

With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules
around how it handles properties on `type` or `interfaces` which have a `?`
prefix.

For example, this interface declares that there is a property which can be one
of two strings: ‚Äòdark‚Äô or ‚Äòlight‚Äô or it should not be in the object.

    
    
    ts
    
    interface UserDefaults {
    
      // The absence of a value represents 'system'
    
      colorThemeOverride?: "dark" | "light";
    
    }

Without this flag enabled, there are three values which you can set
`colorThemeOverride` to be: ‚Äúdark‚Äù, ‚Äúlight‚Äù and `undefined`.

Setting the value to `undefined` will allow most JavaScript runtime checks for
the existence to fail, which is effectively falsy. However, this isn‚Äôt quite
accurate; `colorThemeOverride: undefined` is not the same as
`colorThemeOverride` not being defined. For example, `"colorThemeOverride" in
settings` would have different behavior with `undefined` as the key compared
to not being defined.

`exactOptionalPropertyTypes` makes TypeScript truly enforce the definition
provided as an optional property:

    
    
    ts
    
    const settings = getUserSettings();
    
    settings.colorThemeOverride = "dark";
    
    settings.colorThemeOverride = "light";
    
    ¬†
    
    // But not:
    
    settings.colorThemeOverride = undefined;
    
    Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.2412Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9efACwBGXkww5EFAGYJIoAKoMKAEUgKArvkQNQAbyahQ8LPizEaAC0gBbSMgBu7DABNIAfh4Aid7DEANa+oAA+oL74GADmNoi+ANxMAL5MnvD4gUpy2jhI2DigMZCIqhQAyqWYODEMABQAlDzlxJo6egzJrAC0ffDaiH09TOY4DIigaog1daAAvMWlrVUz0nVNydOzDAB05pbWdo4ubp4LkQHBSUzb63sHVrYOTq7ExB5Ki1Gx8TcsYAAQoNQDgsIguLdqvd9hYnsdXmcvqA8p45NJIO5EkA)

  * Recommended
  * Released:

[4.4](/docs/handbook/release-notes/typescript-4-4.html)

### # No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`

Report errors for fallthrough cases in switch statements. Ensures that any
non-empty case inside a switch statement includes either `break`, `return`, or
`throw`. This means you won‚Äôt accidentally ship a case fallthrough bug.

    
    
    ts
    
    const a: number = 6;
    
    ¬†
    
    switch (a) {
    
      case 0:
    
    Fallthrough case in switch.7029Fallthrough case in switch.
    
        console.log("even");
    
      case 1:
    
        console.log("odd");
    
        break;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsDEEMA2iAuALATtArgczQMLwDOApsQJKQDKA7gJYoDGaAUCBKRlhsQFygA7AAYATAE5WTaJGIpQ8AZGwBbAEZdQAXlAA2ANytWxBszSgAFPACUoAN6tQoJiVKhhfR0+czi0RKQAdIjQuBYARKQAbqSQ4daGTi5koACMnt4+sv5BIWHh0AAmhfGJ3moYpPAA1oYAvkA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # No Implicit Any - `noImplicitAny`

In some cases where no type annotations are present, TypeScript will fall back
to a type of `any` for a variable when it cannot infer the type.

This can cause some errors to be missed, for example:

    
    
    ts
    
    function fn(s) {
    
      // No error?
    
      console.log(s.subtr(3));
    
    }
    
    fn(42);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0kpkAFJQJSgBvWqFAhQAOWihqAJxnQZAfmGh07StGTUAdMmgBzHtsoMARlhlcAzL14BuWgF963ACwAme0A)

Turning on `noImplicitAny` however TypeScript will issue an error whenever it
would have inferred `any`:

    
    
    ts
    
    function fn(s) {
    
    Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.
    
      console.log(s.subtr(3));
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYBQAzAVwDsBjAFwEs5jR9iAKRASlAG9dRRSbE4AbSADp+cAOZMhiQgCNy0BgGZmzANy4AvkA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

### # No Implicit Override - `noImplicitOverride`

When working with classes which use inheritance, it‚Äôs possible for a sub-class
to get ‚Äúout of sync‚Äù with the functions it overloads when they are renamed in
the base class.

For example, imagine you are modeling a music album syncing system:

    
    
    ts
    
    class Album {
    
      download() {
    
        // Default behavior
    
      }
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      download() {
    
        // Override to get info from many sources
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaATA9gO4B2I+YuAFAJQbY7QD0j0AIgKYBmYSIALtATsAFmABuAS3wAnegF9MCzKEgwAyqOntc8ZGnYAPPu2K4Yu1HRwESZCjSsNm0APJj206RNztoffNAA5uwCEsScAZzS+GgoYMQAntAQ+EjSwOwQ8opAA)

Then when you add support for machine-learning generated playlists, you
refactor the `Album` class to have a ‚Äòsetup‚Äô function instead:

    
    
    ts
    
    class Album {
    
      setup() {
    
        // Default behavior
    
      }
    
    }
    
    ¬†
    
    class MLAlbum extends Album {
    
      setup() {
    
        // Override to get info from algorithm
    
      }
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      download() {
    
        // Override to get info from many sources
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaECmALkgA4AUAlBtjtAPS3QAieAZmEiAdAngBZgA3AJYB7AE7UAvpmmZQkGAFkAMvGRo8ADwJ4AdgBMYa1FRz4iZSlhp0GAeQF4xYofrzQCI6AHNC0IbosXixiImhgIN7iQgS8KFIymHLgUNAAyvxiePrGGtp6hnCIJtbQ+iIA7rogImD6FKY09NAOTi5uHl6+XAFB0CFh0ChgugCeuCJIYsB4EAmSQA)

In this case, TypeScript has provided no warning that `download` on
`SharedAlbum` _expected_ to override a function in the base class.

Using `noImplicitOverride` you can ensure that the sub-classes never go out of
sync, by ensuring that functions which override include the keyword
`override`.

The following example has `noImplicitOverride` enabled, and you can see the
error received when `override` is missing:

    
    
    ts
    
    class Album {
    
      setup() {}
    
    }
    
    ¬†
    
    class MLAlbum extends Album {
    
      override setup() {}
    
    }
    
    ¬†
    
    class SharedAlbum extends Album {
    
      setup() {}
    
    This member must have an 'override' modifier because it overrides a member in the base class 'Album'.4114This member must have an 'override' modifier because it overrides a member in the base class 'Album'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg7cvWQENGjUAEFkAIwCu8UAG9KoUIwJZJiABQBKOQF9Ke3gKGgAsgBkxUmQQAeWApDLDL0uQtDRCJcgSUq1Wrr6lIaCwgDKABb8RARkLtZ2Dk6iEq7yisqqGtqyejpAA)

  * Released:

[4.3](/docs/handbook/release-notes/typescript-4-3.html)

### # No Implicit Returns - `noImplicitReturns`

When enabled, TypeScript will check all code paths in a function to ensure
they return a value.

    
    
    ts
    
    function lookupHeadphonesManufacturer(color: "blue" | "black"): string {
    
    Function lacks ending return statement and return type does not include 'undefined'.2366Function lacks ending return statement and return type does not include 'undefined'.
    
      if (color === "blue") {
    
        return "beats";
    
      } else {
    
        ("bose");
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsX0bWgFABmArgHYDGALgJZzmgA2ccA1qQA4ASkAhgBNOACwaREAWT7lSxPjVLQYACkpwW0VACIARk1KQtoAD6hdTeWy0BKVImrRa5AOagA3oVChaxUKvUIoAC8IWZ6Bjbunl6gStSKjLr81IhaANzRAL6gkEyIkFExfrpw+TYZXpmEmUA)

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # No Implicit This - `noImplicitThis`

Raise error on ‚Äòthis‚Äô expressions with an implied ‚Äòany‚Äô type.

For example, the class below returns a function which tries to access
`this.width` and `this.height` ‚Äì but the context for `this` inside the
function inside `getAreaFunction` is not the instance of the Rectangle.

    
    
    ts
    
    class Rectangle {
    
      width: number;
    
      height: number;
    
    ¬†
    
      constructor(width: number, height: number) {
    
        this.width = width;
    
        this.height = height;
    
      }
    
    ¬†
    
      getAreaFunction() {
    
        return function () {
    
          return this.width * this.height;
    
    'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.2683  
    2683'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.
    
        };
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcBmAUAMYA2AhooqAEqQEAuJAdgOZGSgDeeooA7gJYATWgAtUDAK4BbAEYwA3F1DDIfJsNpips6AsUE4DRLWji6CABT8ho0BJkwANEpVqNtrTACUHRdxF9EADorEVAAXl5BEQVuP2EAwOVVdXDnZNoY0ABfPEUmSFoAQWhIEgAxcQY6PgNzb05Y0BLacWgGUAAzSuqDUDqfRu5m1vb-IJDhUAAqUDHEl3VM7izMnKygA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # No Property Access From Index Signature -
`noPropertyAccessFromIndexSignature`

This setting ensures consistency between accessing a field via the ‚Äúdot‚Äù
(`obj.key`) syntax, and ‚Äúindexed‚Äù (`obj["key"]`) and the way which the
property is declared in the type.

Without this flag, TypeScript will allow you to use the dot syntax to access
fields which are not defined:

    
    
    ts
    
    interface GameSettings {
    
      // Known up-front properties
    
      speed: "fast" | "medium" | "slow";
    
      quality: "high" | "low";
    
    ¬†
    
      // Assume anything unknown to the interface
    
      // is a string.
    
      [key: string]: string;
    
    }
    
    ¬†
    
    const settings = getSettings();
    
    settings.speed;
    
              
    
    (property) GameSettings.speed: "fast" | "medium" | "slow"
    
    settings.quality;
    
               
    
    (property) GameSettings.quality: "high" | "low"
    
    ¬†
    
    // Unknown key accessors are allowed on
    
    // this object, and are `string`
    
    settings.username;
    
                
    
    (index) GameSettings[string]: string
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgAmkBjAGwENpJQAzAVwDsCAXASzltAHNIGBlL529ogAUASlQBxEgFtIvBv0EBubCFABaDQWoMNa7E1oMYlEgQqSZchYlABvbKFCqA0rTgB3NtQAOayvENQb3hvGGZIRAdQRFDIXFQAIhNEBgTQAB9QBJlcJmopNMyExCIPBOVHAEdqEiImBgBPRIALJnZmwqzS93LsKNUAQUREfIoSWgaGVoFQOgBrN09QBjhl5ooDI2gTM36wJhsSaIZoA3YAOiiAbTnIJuPTgQBdVBTH9mUAXz6CVhTovhnGwAXg4XCsQNEykQgIEiHOMUgcWUqkcaNAAD0APzYGHyIHnaq1eoNFFgdGObF9VQAVVoCw8bFuDVApjMwwQh3IrKI3TioFYKjAUwOAoARgArQgMAA0rNouFZ3IABm8zsrcbDBOdqDDoLRpJAyRTKVigA)

Turning the flag on will raise an error because the unknown field uses dot
syntax instead of indexed syntax.

    
    
    ts
    
    const settings = getSettings();
    
    settings.speed;
    
    settings.quality;
    
    ¬†
    
    // This would need to be settings["username"];
    
    settings.username;
    
    Property 'username' comes from an index signature, so it must be accessed with ['username'].4111Property 'username' comes from an index signature, so it must be accessed with ['username'].
    
                
    
    (index) GameSettings[string]: string
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgQQHZwAK8ADjAC4CeAggMZ2SKIBi8AtgJL4AmkAHgGUAlgHN8AQwoBXaJGx86AGwlzQAM2n46FYXHyhRkCoOO78oxAAoAlKgDiE9pFMVzlgNzZh+CjHUSjKCOzq7uiKAA3tigoIjkkDyoAEQBiBTJoAA+oMnOPMLS7Jk5yYhKcADuyV6xAI7SEkrC1CkAFmJtJbkV1bWgANoA1pBUqOnQPqIAuuMUkxZeAL64YAC0G3TSFBtr2HT66XFmUxEAvIbGYae2XognFogAdPGQiXcPlk8NTS1UXqtQAAVDoRSpwaRKHigfBvaEUOCgABGkGOblOA2S0nu0EkzmS0w+6MeT2xMDxkC8eFiNNAAD0APxAA)

The goal of this flag is to signal intent in your calling syntax about how
certain you are this property exists.

  * Released:

[4.2](/docs/handbook/release-notes/typescript-4-2.html)

### # No Unchecked Indexed Access - `noUncheckedIndexedAccess`

TypeScript has a way to describe objects which have unknown keys but known
values on an object, via index signatures.

    
    
    ts
    
    interface EnvironmentVars {
    
      NAME: string;
    
      OS: string;
    
    ¬†
    
      // Unknown properties are covered by this index signature.
    
      [propName: string]: string;
    
    }
    
    ¬†
    
    declare const env: EnvironmentVars;
    
    ¬†
    
    // Declared as existing
    
    const sysName = env.NAME;
    
    const os = env.OS;
    
          
    
    const os: string
    
    ¬†
    
    // Not declared, but because of the index
    
    // signature, then it is considered a string
    
    const nodeEnv = env.NODE_ENV;
    
            
    
    const nodeEnv: string
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL5yvggANhbIViDcyEQYnOhYuAREYKQUQjSKyAAiEMUWDnCU-l4mMjTlleTO5MmEyAC8VZhRzGxC42DIOJQL1VHiQh30yAB6APxyHQw4G4UlkXYANE5hG449cGHkKDgwbu4oPn87SU5CCIXCkSeHiIyGAGy8ZTwoN892QcC46VG62Qml8dXmiwwyxEnVQAH1UAxiAclEczkA)

Turning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared
field in the type.

    
    
    ts
    
    declare const env: EnvironmentVars;
    
    ¬†
    
    // Declared as existing
    
    const sysName = env.NAME;
    
    const os = env.OS;
    
          
    
    const os: string
    
    ¬†
    
    // Not declared, but because of the index
    
    // signature, then it is considered a string
    
    const nodeEnv = env.NODE_ENV;
    
            
    
    const nodeEnv: string | undefined
    
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL40isgAApqqCO4QCGr2AJIgvn72TAhI5OQFSgC03QhhYN2dNL4IADYWyFYg3MhEGJzoWLgERGCkFEIdyAAilWORDnCU-l4mMjST0+TO5MmEyAC8M5hRzGxCF2DIOJSPs1HiQkK9GQAD0APxyQoMHCfYZ7ewAGicfSclTgYXIKBwMDcFWQPn8m3IQRC4UiSI8RHxny8EzwxN8+2QcC46TOH2Qml8CweTwwLxEW1QAH1UAxiIClMDwUA)

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

### # No Unused Locals - `noUnusedLocals`

Report errors on unused local variables.

    
    
    ts
    
    const createKeyboard = (modelID: number) => {
    
      const defaultModelID = 23;
    
    'defaultModelID' is declared but its value is never read.6133'defaultModelID' is declared but its value is never read.
    
      return { type: "keyboard", modelID };
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBsAjAMwtHbSRIAuo25FLh4oA0igCeAI2i5yaUAF5QACgC20NCnwBJACL1EaqRQCUSgHygA3kVD8uvUFoBmuBPh4BZTdv1LQACYWAG47UEEeBHJIG1AeCQAHFHoAIgBrSRk5NFSAGlANLV09UABfMIqgA)

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # No Unused Parameters - `noUnusedParameters`

Report errors on unused parameters in functions.

    
    
    ts
    
    const createDefaultKeyboard = (modelID: number) => {
    
    'modelID' is declared but its value is never read.6133'modelID' is declared but its value is never read.
    
      const defaultModelID = 23;
    
      return { type: "keyboard", modelID: defaultModelID };
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATACgQwE5YLYoAuKOSAUCBKTtGQFygBsAjAMxvkDG0kSRoLjhRYSAERQAzLAgA2RANIoAngCNouNKAC8oABT5oaFLICSYxonyrSASh0A+UAG9yoQb36hj0uUQCyRibmOqAATGwA3G6gwkQIOJAuoETKAA4ojABEANYq6ppZADSghsZmFt5SMvKB5SEAvtFNQA)

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Strict - `strict`

The `strict` flag enables a wide range of type checking behavior that results
in stronger guarantees of program correctness. Turning this on is equivalent
to enabling all of the _strict mode family_ options, which are outlined below.
You can then turn off individual strict mode family checks as needed.

Future versions of TypeScript may introduce additional stricter checking under
this flag, so upgrades of TypeScript might result in new type errors in your
program. When appropriate and possible, a corresponding flag will be added to
disable that behavior.

  * Recommended
  * Related:
    * `alwaysStrict`

    * `strictNullChecks`

    * `strictBindCallApply`

    * `strictFunctionTypes`

    * `strictPropertyInitialization`

    * `noImplicitAny`

    * `noImplicitThis`

    * `useUnknownInCatchVariables`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Strict Bind Call Apply - `strictBindCallApply`

When set, TypeScript will check that the built-in methods of functions `call`,
`bind`, and `apply` are invoked with correct argument for the underlying
function:

    
    
    ts
    
    // With strictBindCallApply on
    
    function fn(x: string) {
    
      return parseInt(x);
    
    }
    
    ¬†
    
    const n1 = fn.call(undefined, "10");
    
    ¬†
    
    const n2 = fn.call(undefined, false);
    
    Argument of type 'boolean' is not assignable to parameter of type 'string'.2345Argument of type 'boolean' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcocArgKYBQIEDssA9rJDQEwBmACwBWJizAB1eNAAWoGAmRoseQqXIVQndEwBmddMng7Qe9AAoAHjUUYA5gEpQAbyahQsBtDqx0oElweBgBJdGhrRwBuJgBfcUQdGFB0AEZQAF4zdAA6RAJ8C0NMBj0MBkwAGlAAIlSABhrohKToFL5M7LyCoqxS8qqzAkgGaKA)

Otherwise, these functions accept any arguments and will return `any`:

    
    
    ts
    
    // With strictBindCallApply off
    
    function fn(x: string) {
    
      return parseInt(x);
    
    }
    
    ¬†
    
    // Note: No error; return type is 'any'
    
    const n = fn.call(undefined, false);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcoAZgZAKYBQzIoA6vNABagwJkaLHkKlyFUAHtatZrQCu6ZPCno66ABQAPGgIwBzAJSgA3s1ChYjaAtjqSuWEwCS6aDqMBuZgF9W7AByUtCMNMGgjLCwUrBeVjZ26tAUJIyg8JCgAOS46BTZzIhqMKDqALwaAHSIBPiaSpiMtBiMmAA0dAyM3kA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[3.2](/docs/handbook/release-notes/typescript-3-2.html)

### # strictBuiltinIteratorReturn - `strictBuiltinIteratorReturn`

Built-in iterators are instantiated with a `TReturn` type of undefined instead
of `any`.

  * Recommended
  * Default:

`false`, unless `strict` is set

### # Strict Function Types - `strictFunctionTypes`

When enabled, this flag causes functions parameters to be checked more
correctly.

Here‚Äôs a basic example with `strictFunctionTypes` off:

    
    
    ts
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    type StringOrNumberFunc = (ns: string | number) => void;
    
    ¬†
    
    // Unsafe assignment
    
    let func: StringOrNumberFunc = fn;
    
    // Unsafe call - will crash
    
    func(10);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BiBXAds+B7DAVATwAcBTSALlADMBDAG0lIChrNs8aMAKADypgIMAcwCUoAN7NQoRHkg56pAHT0cw7gCIAEqXpqANKE2gA1KF7LoOADI4A7qVgBhWk26jRAbmYBfZszQJKSgAMpw8CIA8rAAcmgAtgBGTuhYoAC8oNwYlKCCkcKgAD6gGIkpsOIZAHygAG448AAmPswgoACqubTUIW6Q8MIYCaQY0MxK0DTsVOFCwjHxyansmVw+Hd2QvSGIDPSgALSg9vD6srBuABas7NwAjAAM3kA)

With `strictFunctionTypes` _on_ , the error is correctly detected:

    
    
    ts
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    type StringOrNumberFunc = (ns: string | number) => void;
    
    ¬†
    
    // Unsafe assignment is prevented
    
    let func: StringOrNumberFunc = fn;
    
    Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.2322Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFADMBXAOwGMAXASziNDyIAoAPVRM6CogcwEpQBvHKFAlqiOABtIAOnFxO9AEQAJSONkAaUAtABqUIylk4AGTgB3GAGEAhokj1u3ANw4AvjhxkAngAdIoAGU2Dk4AeWgAOQIAWwAjGAAxYhJQAF5QeiIUUFZ2LlAAH1AiGPjoXlSAPlAANzgKABMXHBBQAFUs6zx-W0QKTiJoyCIyUApEUB9oSBrhskgGnElRwlJUILywyNLE5LTaIicgA)

During development of this feature, we discovered a large number of inherently
unsafe class hierarchies, including some in the DOM. Because of this, the
setting only applies to functions written in _function_ syntax, not to those
in _method_ syntax:

    
    
    ts
    
    type Methodish = {
    
      func(x: string | number): void;
    
    };
    
    ¬†
    
    function fn(x: string) {
    
      console.log("Hello, " + x.toLowerCase());
    
    }
    
    ¬†
    
    // Ultimately an unsafe assignment, but not detected
    
    const m: Methodish = {
    
      func: fn,
    
    };
    
    m.func(10);
    
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshwAsD2ATAlgZwVAvFA3gFBRQBmArgHYDGAFAB4BcUGwATmpQOZQA+UlcgFsARhDYBKZgDckaFAG5CAXyWEKNYGiSUylBs1YduEgsSjUdGJABsIAOhtIutAEQAJCDacAaKK6gAaih6e2AkABkkAHdxAGEAQwwIWgkJJWVCQgB6bKgAVRstIQTgLxAoBN0qDATSaCSMNC5KIQhKYD8RcmABJF6UeAhqMpRCS0pWKCFmOERUTGw8IhINamZSSh8VJSF7NdoARgAGdKA)

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.6](/docs/handbook/release-notes/typescript-2-6.html)

### # Strict Null Checks - `strictNullChecks`

When `strictNullChecks` is `false`, `null` and `undefined` are effectively
ignored by the language. This can lead to unexpected errors at runtime.

When `strictNullChecks` is `true`, `null` and `undefined` have their own
distinct types and you‚Äôll get a type error if you try to use them where a
concrete value is expected.

For example with this TypeScript code, `users.find` has no guarantee that it
will actually find a user, but you can write code as though it will:

    
    
    ts
    
    declare const loggedInUsername: string;
    
    ¬†
    
    const users = [
    
      { name: "Oby", age: 12 },
    
      { name: "Heera", age: 32 },
    
    ];
    
    ¬†
    
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    
    console.log(loggedInUser.age);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0ByBXANhgwgCwKaIDWkAXKAGYCGGk+AUCBNFbAOb7TkCiAygEwAGAIwBWegBNCGVvlCIA9gDsYoDArYcJASSUBVOrCVUAtvnIwEStgG569RSuig0hyKAC8oANr1QoAG9QYzNyACIAeQAjAE8wgBpQKg5yYX5QAF94v0Dg03NQMIAJfHxYKgSklNAAZnSs+gBdOwdlVXVNfB19Q08XNwA6CnglCQAKMbQASk8APhcBkLkPFbUNLV0DMqWpu0dIBQx8AY6xjo2esoHk-F2gA)

Setting `strictNullChecks` to `true` will raise an error that you have not
made a guarantee that the `loggedInUser` exists before trying to use it.

    
    
    ts
    
    declare const loggedInUsername: string;
    
    ¬†
    
    const users = [
    
      { name: "Oby", age: 12 },
    
      { name: "Heera", age: 32 },
    
    ];
    
    ¬†
    
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    
    console.log(loggedInUser.age);
    
    'loggedInUser' is possibly 'undefined'.18048'loggedInUser' is possibly 'undefined'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME50FYM1QBGADgAYAWUgKBAgBcBDaAc0gdQFEBlNc-nTDhEDaAEsAxgwByAVwA2CgMIALSJIDWiGgBMNClpFCS4AO1GgFcVu10BJMwFVEMM0wC2kVKIlnWANw0NKYWDKByrkigALygANo0oKAA3qDuXqgARADyAEYAnlkANKBM7KjERAC+xUmp6Z7eoFkAEpAwTCVlFaCEoLU0ALpBIeaW1raQDs5RsRFRiAB0AGbiZroAFJtyAJSxAHwRSxnGMedWNnaOLm5Nu0GhiHAKkEuTm5PXszBL5ZAPIA)

The second example failed because the array‚Äôs `find` function looks a bit like
this simplification:

    
    
    ts
    
    // When strictNullChecks: true
    
    type Array = {
    
      find(predicate: (value: any, index: number) => boolean): S | undefined;
    
    };
    
    // When strictNullChecks: false the undefined is removed from the type system,
    
    // allowing you to write code which assumes it always found a result
    
    type Array = {
    
      find(predicate: (value: any, index: number) => boolean): S;
    
    };

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Strict Property Initialization - `strictPropertyInitialization`

When set to true, TypeScript will raise an error when a class property was
declared but not set in the constructor.

    
    
    ts
    
    class UserAccount {
    
      name: string;
    
      accountType = "user";
    
    ¬†
    
      email: string;
    
    Property 'email' has no initializer and is not definitely assigned in the constructor.2564Property 'email' has no initializer and is not definitely assigned in the constructor.
    
      address: string | undefined;
    
    ¬†
    
      constructor(name: string) {
    
        this.name = name;
    
        // Note that this.email is not set
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAUAMYA2AhooqAKqIwCCBBcArgHYAuoA3nqKCyQFtIqRG2gBLFgHMA3D1AkGzdgBUAngAdIoALygARExrR9c+ZAElxREWMmz5JACZPokcrYnTQAH1CsnSAAzSUgnM15GFlFoJgI2BAAKfiFPewBKLnleNgALcUQAOhTtPRK5Xl4QUAA5ODZtPJIOPILCiysiUAK+etAaNnkAXzwhoA)

In the above case:

  * `this.name` is set specifically.
  * `this.accountType` is set by default.
  * `this.email` is not set and raises an error.
  * `this.address` is declared as potentially `undefined` which means it does not have to be set.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[2.7](/docs/handbook/release-notes/typescript-2-7.html)

### # Use Unknown In Catch Variables - `useUnknownInCatchVariables`

In TypeScript 4.0, support was added to allow changing the type of the
variable in a catch clause from `any` to `unknown`. Allowing for code like:

    
    
    ts
    
    try {
    
      // ...
    
    } catch (err: unknown) {
    
      // We have to verify err is an
    
      // error before using it as one.
    
      if (err instanceof Error) {
    
        console.log(err.message);
    
      }
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFBHUCeoA3m6FAhQAOjFsAvqBLFyoABSxq1AFyhIKdFgCUfAULAB1WKDIEAbiaJpQlugDMeS6qFrRQBRPuHO0LhrD2fiYwtIgA5q5EHu5oiLAi+rT2Cs6uiNBEniSwaCkAosp+uvyCgiRx0GgsIkxo4YrKIgC2rNAE4bDaANz6EpJAA)

This pattern ensures that error handling code becomes more comprehensive
because you cannot guarantee that the object being thrown _is_ a Error
subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled,
then you do not need the additional syntax (`: unknown`) nor a linter rule to
try enforce this behavior.

  * Recommended
  * Default:

`true` if `strict`; `false` otherwise.

  * Related:
    * `strict`

  * Released:

[4.4](/docs/handbook/release-notes/typescript-4-4.html)

## #Modules

### # Allow Arbitrary Extensions - `allowArbitraryExtensions`

In TypeScript 5.0, when an import path ends in an extension that isn‚Äôt a known
JavaScript or TypeScript file extension, the compiler will look for a
declaration file for that path in the form of `{file
basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a
bundler project, you might want to write (or generate) declaration files for
those stylesheets:

    
    
    css
    
    /* app.css */
    
    .cookie-banner {
    
      display: none;
    
    }
    
    
    ts
    
    // app.d.css.ts
    
    declare const css: {
    
      cookieBanner: string;
    
    };
    
    export default css;
    
    
    ts
    
    // App.tsx
    
    import styles from "./app.css";
    
    styles.cookieBanner; // string

By default, this import will raise an error to let you know that TypeScript
doesn‚Äôt understand this file type and your runtime might not support importing
it. But if you‚Äôve configured your runtime or bundler to handle it, you can
suppress the error with the new `--allowArbitraryExtensions` compiler option.

Note that historically, a similar effect has often been achievable by adding a
declaration file named `app.css.d.ts` instead of `app.d.css.ts` \- however,
this just worked through Node‚Äôs `require` resolution rules for CommonJS.
Strictly speaking, the former is interpreted as a declaration file for a
JavaScript file named `app.css.js`. Because relative files imports need to
include extensions in Node‚Äôs ESM support, TypeScript would error on our
example in an ESM file under `--moduleResolution node16` or `nodenext`.

For more information, read up [the proposal for this
feature](https://github.com/microsoft/TypeScript/issues/50133) and [its
corresponding pull
request](https://github.com/microsoft/TypeScript/pull/51435).

### # Allow Importing TS Extensions - `allowImportingTsExtensions`

`--allowImportingTsExtensions` allows TypeScript files to import each other
with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.

This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is
enabled, since these import paths would not be resolvable at runtime in
JavaScript output files. The expectation here is that your resolver (e.g. your
bundler, a runtime, or some other tool) is going to make these imports between
`.ts` files work.

### # Allow Umd Global Access - `allowUmdGlobalAccess`

When set to true, `allowUmdGlobalAccess` lets you access UMD exports as
globals from inside module files. A module file is a file that has imports
and/or exports. Without this flag, using an export from a UMD module requires
an import declaration.

An example use case for this flag would be a web project where you know the
particular library (like jQuery or Lodash) will always be available at
runtime, but you can‚Äôt access it with an import.

  * Released:

[3.5](/docs/handbook/release-notes/typescript-3-5.html)

### # Base URL - `baseUrl`

Sets a base directory from which to resolve bare specifier module names. For
example, in the directory structure:

    
    
    project
    
    ‚îú‚îÄ‚îÄ ex.ts
    
    ‚îú‚îÄ‚îÄ hello
    
    ‚îÇ   ‚îî‚îÄ‚îÄ world.ts
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With `"baseUrl": "./"`, TypeScript will look for files starting at the same
folder as the `tsconfig.json`:

    
    
    ts
    
    import { helloWorld } from "hello/world";
    
    console.log(helloWorld);

This resolution has higher priority than lookups from `node_modules`.

This feature was designed for use in conjunction with AMD module loaders in
the browser, and is not recommended in any other context. As of TypeScript
4.1, `baseUrl` is no longer required to be set when using `paths`.

### # Custom Conditions - `customConditions`

`--customConditions` takes a list of additional
[conditions](https://nodejs.org/api/packages.html#nested-conditions) that
should succeed when TypeScript resolves from an
[`exports`](https://nodejs.org/api/packages.html#exports) or
[`imports`](https://nodejs.org/api/packages.html#imports) field of a
`package.json`. These conditions are added to whatever existing conditions a
resolver will use by default.

For example, when this field is set in a `tsconfig.json` as so:

    
    
    jsonc
    
    {
    
      "compilerOptions": {
    
        "target": "es2022",
    
        "moduleResolution": "bundler",
    
        "customConditions": ["my-condition"]
    
      }
    
    }

Any time an `exports` or `imports` field is referenced in `package.json`,
TypeScript will consider conditions called `my-condition`.

So when importing from a package with the following `package.json`

    
    
    jsonc
    
    {
    
      // ...
    
      "exports": {
    
        ".": {
    
          "my-condition": "./foo.mjs",
    
          "node": "./bar.mjs",
    
          "import": "./baz.mjs",
    
          "require": "./biz.mjs"
    
        }
    
      }
    
    }

TypeScript will try to look for files corresponding to `foo.mjs`.

This field is only valid under the `node16`, `nodenext`, and `bundler` options
for `--moduleResolution`.

  * Related:
    * `moduleResolution`

    * `resolvePackageJsonExports`

    * `resolvePackageJsonImports`

### # Module - `module`

Sets the module system for the program. See the [theory behind TypeScript‚Äôs
`module` option](/docs/handbook/modules/theory.html#the-module-output-format)
and [its reference page](/docs/handbook/modules/reference.html#the-module-
compiler-option) for more information. You very likely want `"nodenext"` for
modern Node.js projects and `preserve` or `esnext` for code that will be
bundled.

Changing `module` affects `moduleResolution` which [also has a reference
page](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).

Here‚Äôs some example output for this file:

    
    
    ts
    
    // @filename: index.ts
    
    import { valueOfPi } from "./constants";
    
    ¬†
    
    export const twoPi = valueOfPi * 2;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQFDwAeADrgE5E77GgBuysArvADykAArRQAXlABmCgEYALACYA3NRCgAtNux8i2zerBQ4SNJlDREAE3pUC1aKiatQAb268BwsaAC+oJDMuKigAEQUwHiEJGQEYWq0jCxs0ZxEAO64vlI8-EKi4gBUoKpAA)

#### `CommonJS`

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.twoPi = void 0;
    
    const constants_1 = require("./constants");
    
    exports.twoPi = constants_1.valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAGNZk8A7AK0mzHHtkQCcvYuXUyAA590oAN6gAbgENihUgHkAZgAVUoAL6hlvZKABEAOmA16kdDPrpIBgNyZMpAB4iuYsxdDp4sdaABeaTkFFX8AKlAAJjsgA)

#### `UMD`

    
    
    ts
    
    (function (factory) {
    
        if (typeof module === "object" && typeof module.exports === "object") {
    
            var v = factory(require, exports);
    
            if (v !== undefined) module.exports = v;
    
        }
    
        else if (typeof define === "function" && define.amd) {
    
            define(["require", "exports", "./constants"], factory);
    
        }
    
    })(function (require, exports) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.twoPi = void 0;
    
        const constants_1 = require("./constants");
    
        exports.twoPi = constants_1.valueOfPi * 2;
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEOX2zHADtZEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNYDSOnEN0kbQG5MmUgA9+LQUZOD08WEtABeMZLS8j4AVKAATNZAA)

#### `AMD`

    
    
    ts
    
    define(["require", "exports", "./constants"], function (require, exports, constants_1) {
    
        "use strict";
    
        Object.defineProperty(exports, "__esModule", { value: true });
    
        exports.twoPi = void 0;
    
        exports.twoPi = constants_1.valueOfPi * 2;
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAENl9sxwA7WRAJ1dlck1WQAdO6UAG9QANyrFCpAPIAzAAqpQAX1ByOyUACIAdMADGsRpHRVG6SNoDcmTKQAeA1kKMmh6eLCWgAvOMlpeR8AKlAAJmsgA)

#### `System`

    
    
    ts
    
    System.register(["./constants"], function (exports_1, context_1) {
    
        "use strict";
    
        var constants_1, twoPi;
    
        var __moduleName = context_1 && context_1.id;
    
        return {
    
            setters: [
    
                function (constants_1_1) {
    
                    constants_1 = constants_1_1;
    
                }
    
            ],
    
            execute: function () {
    
                exports_1("twoPi", twoPi = constants_1.valueOfPi * 2);
    
            }
    
        };
    
    });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEgE9J1TlsxwA7WRAJw9g8k1WQAHHulABvUADcAhsUKkA8gDMACqlABfUEu7JQAIgB0wAMawWdaS3SR9AbkyZSAD2EdRZi6PTxYa0AC8UrLyyv4AVKAATHZAA)

#### `ESNext`

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    export const twoPi = valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgDtSAPLHcG2RAJ3dnck1WQAO3dKADeoAG4BDYoVIB5AGYAFVKAC+oRV2SgARADpgAY1g1I6KTXSQ9AbkyYGQ9iNPmR6eLFWgAvJIyckq+AFSgAEx2QA)

#### `ES2015`/`ES6`/`ES2020`/`ES2022`

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    export const twoPi = valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgCYAGARgFZsxwA7WRAJ29m8iZUyAA790oAN6gAbgENihUgHkAZgAVUoAL6hVfZKABEAOmABjWO0jo57dJCMBuTJlIAPMdwmXrE9PCwmqAAvLIKSmrBAFSgNE5AA)

In addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support
for [dynamic `import`s](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import), and
[`import.meta`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further
adds support for [top level `await`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).

#### `node16`/`nodenext`

Available from 4.7+, the `node16` and `nodenext` modes integrate with Node‚Äôs
[native ECMAScript Module support](https://nodejs.org/api/esm.html). The
emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the
file extension and the value of the `type` setting in the nearest
`package.json`. Module resolution also works differently. You can learn more
in the [handbook](/docs/handbook/esm-node.html) and [Modules
Reference](/docs/handbook/modules/reference.html#node16-nodenext).

#### `preserve`

In `--module preserve`
([added](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-
bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and
exports written in input files are preserved in the output, and CommonJS-style
`import x = require("...")` and `export = ...` statements are emitted as
CommonJS `require` and `module.exports`. In other words, the format of each
individual import or export statement is preserved, rather than being coerced
into a single format for the whole compilation (or even a whole file).

    
    
    ts
    
    import { valueOfPi } from "./constants";
    
    const constants = require("./constants");
    
    export const piSquared = valueOfPi * constants.valueOfPi;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAAcAnUyUmgN1OzHADtZEabYbImVMir90oAN6gmAQ2KFSAeQBmABVSgAvqGV9koAEQA6YAGNYHSOhkd0kAwG4hIsaHOXrtyKAC8oOgCOhKh0ABTGZhZWNnYGAJROmKQAHqI04u5W1KgAykEydPi+0nIKKuqgAFRuUZ52RrLySmqoDkA)

While it‚Äôs rare to need to mix imports and require calls in the same file,
this `module` mode best reflects the capabilities of most modern bundlers, as
well as the Bun runtime.

> Why care about TypeScript‚Äôs `module` emit with a bundler or with Bun, where
> you‚Äôre likely also setting `noEmit`? TypeScript‚Äôs type checking and module
> resolution behavior are affected by the module format that it _would_ emit.
> Setting `module` gives TypeScript information about how your bundler or
> runtime will process imports and exports, which ensures that the types you
> see on imported values accurately reflect what will happen at runtime or
> after bundling.

#### `None`

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.twoPi = void 0;
    
    const constants_1 = require("./constants");
    
    exports.twoPi = constants_1.valueOfPi * 2;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlADtYrTsxwbEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNakdOKrpI2gNyZMpAB78Wgo1ROh08WEtABeMZLS8j4AVKAATFZAA)

  * Default:

`CommonJS` if `target` is `ES5`; `ES6`/`ES2015` otherwise.

  * Allowed:
    * `none`

    * `commonjs`

    * `amd`

    * `umd`

    * `system`

    * `es6`/`es2015`

    * `es2020`

    * `es2022`

    * `esnext`

    * `node16`

    * `nodenext`

    * `preserve`

  * Related:
    * `moduleResolution`

    * `esModuleInterop`

    * `allowImportingTsExtensions`

    * `allowArbitraryExtensions`

    * `resolveJsonModule`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Module Resolution - `moduleResolution`

Specify the module resolution strategy:

  * `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding `module` values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.
  * `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won‚Äôt need to use `node10` in modern code.
  * `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `"imports"` and `"exports"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.
  * `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.

There are reference pages explaining the [theory behind TypeScript‚Äôs module
resolution](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-
resolution) and the [details of each
option](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).

  * Default:

`Classic` if `module` is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if
`module` is `node16` or `nodenext`; `Node` otherwise.

  * Allowed:
    * `classic`

    * `node10`/`node`

    * `node16`

    * `nodenext`

    * `bundler`

  * Related:
    * `module`

    * `paths`

    * `baseUrl`

    * `rootDirs`

    * `moduleSuffixes`

    * `customConditions`

    * `resolvePackageJsonExports`

    * `resolvePackageJsonImports`

### # Module Suffixes - `moduleSuffixes`

Provides a way to override the default list of file name suffixes to search
when resolving a module.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[moduleSuffixes](https://www.typescriptlang.org/tsconfig#moduleSuffixes)": [".ios", ".native", ""]
    
      }
    
    }

Given the above configuration, an import like the following:

    
    
    ts
    
    import * as foo from "./foo";

TypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`,
and finally `./foo.ts`.

Note the empty string `""` in `moduleSuffixes` which is necessary for
TypeScript to also look-up `./foo.ts`.

This feature can be useful for React Native projects where each target
platform can use a separate tsconfig.json with differing `moduleSuffixes`.

  * Released:

[4.7](/docs/handbook/release-notes/typescript-4-7.html)

### # No Resolve - `noResolve`

By default, TypeScript will examine the initial set of files for `import` and
`<reference` directives and add these resolved files to your program.

If `noResolve` is set, this process doesn‚Äôt happen. However, `import`
statements are still checked to see if they resolve to a valid module, so
you‚Äôll need to make sure this is satisfied by some other means.

### # noUncheckedSideEffectImports - `noUncheckedSideEffectImports`

In JavaScript it‚Äôs possible to `import` a module without actually importing
any values from it.

    
    
    ts
    
    import "some-module";

These imports are often called _side effect imports_ because the only useful
behavior they can provide is by executing some side effect (like registering a
global variable, or adding a polyfill to a prototype).

By default, TypeScript will not check these imports for validity. If the
import resolves to a valid source file, TypeScript will load and check the
file. If no source file is found, TypeScript will silently ignore the import.

This is surprising behavior, but it partially stems from modeling patterns in
the JavaScript ecosystem. For example, this syntax has also been used with
special loaders in bundlers to load CSS or other assets. Your bundler might be
configured in such a way where you can include specific `.css` files by
writing something like the following:

    
    
    tsx
    
    import "./button-component.css";
    
    export function Button() {
    
      // ...
    
    }

Still, this masks potential typos on side effect imports.

When `--noUncheckedSideEffectImports` is enabled, TypeScript will error if it
can‚Äôt find a source file for a side effect import.

    
    
    ts
    
    import "oops-this-module-does-not-exist";
    
    //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations.

When enabling this option, some working code may now receive an error, like in
the CSS example above. To work around this, users who want to just write side
effect `import`s for assets might be better served by writing what‚Äôs called an
_ambient module declaration_ with a wildcard specifier. It would go in a
global file and look something like the following:

    
    
    ts
    
    // ./src/globals.d.ts
    
    // Recognize all CSS files as module imports.
    
    declare module "*.css" {}

In fact, you might already have a file like this in your project! For example,
running something like `vite init` might create a similar `vite-env.d.ts`.

### # Paths - `paths`

A series of entries which re-map imports to lookup locations relative to the
`baseUrl` if set, or to the tsconfig file itself otherwise. There is a larger
coverage of `paths` in [the `moduleResolution` reference
page](/docs/handbook/modules/reference.html#paths).

`paths` lets you declare how TypeScript should resolve an import in your
`require`/`import`s.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
    
          "jquery": ["./vendor/jquery/dist/jquery"]
    
        }
    
      }
    
    }

This would allow you to be able to write `import "jquery"`, and get all of the
correct typing locally.

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
    
            "app/*": ["./src/app/*"],
    
            "config/*": ["./src/app/_config/*"],
    
            "environment/*": ["./src/environments/*"],
    
            "shared/*": ["./src/app/_shared/*"],
    
            "helpers/*": ["./src/helpers/*"],
    
            "tests/*": ["./src/tests/*"]
    
        },
    
    }

In this case, you can tell the TypeScript file resolver to support a number of
custom prefixes to find code.

Note that this feature does not change how import paths are emitted by `tsc`,
so `paths` should only be used to inform TypeScript that another tool has this
mapping and will use it at runtime or when bundling.

### # Resolve JSON Module - `resolveJsonModule`

Allows importing modules with a `.json` extension, which is a common practice
in node projects. This includes generating a type for the `import` based on
the static JSON shape.

TypeScript does not support resolving JSON files by default:

    
    
    ts
    
    // @filename: settings.json
    
    {
    
        "repo": "TypeScript",
    
        "dry": false,
    
        "debug": false
    
    }
    
    // @filename: index.ts
    
    import settings from "./settings.json";
    
    Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.2732Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.
    
    ¬†
    
    settings.debug === true;
    
    settings.dry === 2;
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYDMaBQIIAzASwBtIA7AQwFtJVFIAXJ4igc0QDoArROCrgDeuUGNAAiaJAAOcCagkAVAJ4zIAZQDG0YjKYSANKPESAJtBULQhKqUbHxks5ABGAV3bXb9yLgC++GDgJOTUdKhsLgAeXEyIuMQ0ctBMoIwsbJw28DSSXMAZrBzcfAISANy4uEVZ3C4e7KAAvK2gTNDukFW1JVwWKi1taBVAA)

Enabling the option allows importing JSON, and validating the types in that
JSON file.

    
    
    ts
    
    // @filename: settings.json
    
    {
    
        "repo": "TypeScript",
    
        "dry": false,
    
        "debug": false
    
    }
    
    // @filename: index.ts
    
    import settings from "./settings.json";
    
    ¬†
    
    settings.debug === true;
    
    settings.dry === 2;
    
    This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.2367This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUCBNJInADYBukAUqQHYCycAJgK5mQFjgC2L7kVAGM4PPnQBWiLhD5sOAJRLlWAFwCWcOqjotOhcADN1HOgEMeg0IkiqNdAOaIAdFK14A3nlA-QAImIABzg-VD8AFQBPQMgAZSFodUDVPwAab18-ZmhI0NBDMzIbdN9-ZkgAI1YHPIKizgBfGSMTSHNLVHU6coAPZ1VpdR5g6FVrW3snfPgef2dgGzsup1d6PwBuPDxFyZdyqodQAF4T0FVoVkhNneW9nOPTtHWgA)

### # Resolve package.json Exports - `resolvePackageJsonExports`

`--resolvePackageJsonExports` forces TypeScript to consult [the `exports`
field of `package.json` files](https://nodejs.org/api/packages.html#exports)
if it ever reads from a package in `node_modules`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

  * Default:

`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`

  * Related:
    * `moduleResolution`

    * `customConditions`

    * `resolvePackageJsonImports`

### # Resolve package.json Imports - `resolvePackageJsonImports`

`--resolvePackageJsonImports` forces TypeScript to consult [the `imports`
field of `package.json` files](https://nodejs.org/api/packages.html#imports)
when performing a lookup that starts with `#` from a file whose ancestor
directory contains a `package.json`.

This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.

  * Default:

`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`

  * Related:
    * `moduleResolution`

    * `customConditions`

    * `resolvePackageJsonExports`

### # Root Dir - `rootDir`

**Default** : The longest common path of all non-declaration input files. If
`composite` is set, the default is instead the directory containing the
`tsconfig.json` file.

When TypeScript compiles files, it keeps the same directory structure in the
output directory as exists in the input directory.

For example, let‚Äôs say you have some input files:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.ts
    
    ‚îú‚îÄ‚îÄ types.d.ts

The inferred value for `rootDir` is the longest common path of all non-
declaration input files, which in this case is `core/`.

If your `outDir` was `dist`, TypeScript would write this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js

However, you may have intended for `core` to be part of the output directory
structure. By setting `rootDir: "."` in `tsconfig.json`, TypeScript would
write this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sub
    
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js

Importantly, `rootDir` **does not affect which files become part of the
compilation**. It has no interaction with the `include`, `exclude`, or `files`
`tsconfig.json` settings.

Note that TypeScript will never write an output file to a directory outside of
`outDir`, and will never skip emitting a file. For this reason, `rootDir` also
enforces that all files which need to be emitted are underneath the `rootDir`
path.

For example, let‚Äôs say you had this tree:

    
    
    MyProj
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îú‚îÄ‚îÄ core
    
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    
    ‚îú‚îÄ‚îÄ helpers.ts

It would be an error to specify `rootDir` as `core` _and_ `include` as `*`
because it creates a file (`helpers.ts`) that would need to be emitted
_outside_ the `outDir` (i.e. `../helpers.js`).

  * Default:

Computed from the list of input files.

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Root Dirs - `rootDirs`

Using `rootDirs`, you can inform the compiler that there are many ‚Äúvirtual‚Äù
directories acting as a single root. This allows the compiler to resolve
relative module imports within these ‚Äúvirtual‚Äù directories, as if they were
merged in to one directory.

For example:

    
    
     src
    
     ‚îî‚îÄ‚îÄ views
    
         ‚îî‚îÄ‚îÄ view1.ts (can import "./template1", "./view2`)
    
         ‚îî‚îÄ‚îÄ view2.ts (can import "./template1", "./view1`)
    
     generated
    
     ‚îî‚îÄ‚îÄ templates
    
             ‚îî‚îÄ‚îÄ views
    
                 ‚îî‚îÄ‚îÄ template1.ts (can import "./view1", "./view2")
    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src/views", "generated/templates/views"]
    
      }
    
    }

This does not affect how TypeScript emits JavaScript, it only emulates the
assumption that they will be able to work via those relative paths at runtime.

`rootDirs` can be used to provide a separate ‚Äútype layer‚Äù to files that are
not TypeScript or JavaScript by providing a home for generated `.d.ts` files
in another folder. This technique is useful for bundled applications where you
use `import` of files that aren‚Äôt necessarily code:

    
    
    sh
    
     src
    
     ‚îî‚îÄ‚îÄ index.ts
    
     ‚îî‚îÄ‚îÄ css
    
         ‚îî‚îÄ‚îÄ main.css
    
         ‚îî‚îÄ‚îÄ navigation.css
    
     generated
    
     ‚îî‚îÄ‚îÄ css
    
         ‚îî‚îÄ‚îÄ main.css.d.ts
    
         ‚îî‚îÄ‚îÄ navigation.css.d.ts
    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src", "generated"]
    
      }
    
    }

This technique lets you generate types ahead of time for the non-code source
files. Imports then work naturally based off the source file‚Äôs location. For
example `./src/index.ts` can import the file `./src/css/main.css` and
TypeScript will be aware of the bundler‚Äôs behavior for that filetype via the
corresponding generated declaration file.

    
    
    ts
    
    // @filename: index.ts
    
    import { appClass } from "./main.css";
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVzqIHQDGAzsfgCb4AuxAUPAB4AOA9gE5WiEuLGfJMmAYVjJSoALygARDjwixxAGIBmAKJCATNIDctEKAC0xwgFcqxw-rBQ4SNJlB5yjanWipWHUAG9QA4VFxAF9QSDYWVBl8YDkCEmJdIA)

  * Default:

Computed from the list of input files.

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Type Roots - `typeRoots`

By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.

If `typeRoots` is specified, _only_ packages under `typeRoots` will be
included. For example:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[typeRoots](https://www.typescriptlang.org/tsconfig#typeRoots)": ["./typings", "./vendor/types"]
    
      }
    
    }

This config file will include _all_ packages under `./typings` and
`./vendor/types`, and no packages from `./node_modules/@types`. All paths are
relative to the `tsconfig.json`.

  * Related:
    * `types`

### # Types - `types`

By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.

If `types` is specified, only packages listed will be included in the global
scope. For instance:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["node", "jest", "express"]
    
      }
    
    }

This `tsconfig.json` file will _only_ include `./node_modules/@types/node`,
`./node_modules/@types/jest` and `./node_modules/@types/express`. Other
packages under `node_modules/@types/*` will not be included.

### What does this affect?

This option does not affect how `@types/*` are included in your application
code, for example if you had the above `compilerOptions` example with code
like:

    
    
    ts
    
    import * as moment from "moment";
    
    moment().format("MMMM Do YYYY, h:mm:ss a");

The `moment` import would be fully typed.

When you have this option set, by not including a module in the `types` array
it:

  * Will not add globals to your project (e.g `process` in node, or `expect` in Jest)
  * Will not have exports appear as auto-import recommendations

This feature differs from `typeRoots` in that it is about specifying only the
exact types you want included, whereas `typeRoots` supports saying you want
particular folders.

  * Related:
    * `typeRoots`

## #Emit

### # Declaration - `declaration`

Generate `.d.ts` files for every TypeScript or JavaScript file inside your
project. These `.d.ts` files are type definition files which describe the
external API of your module. With `.d.ts` files, tools like TypeScript can
provide intellisense and accurate types for un-typed code.

When `declaration` is set to `true`, running the compiler with this TypeScript
code:

    
    
    ts
    
    export let helloWorld = "hi";
    
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAG2PAFsBCIHVoICZwC8cARCgJYkDcQA)

Will generate an `index.js` file like this:

    
    
    ts
    
    export let helloWorld = "hi";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMAeAHWAJ3VABttTpsyzYB1YsgE1AF5QAiaVTgbiA)

With a corresponding `helloWorld.d.ts`:

    
    
    ts
    
    export declare let helloWorld: string;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCi1oAHWKPShiy6FkKFYAdUWEcoALygARNFQmA3EA)

When working with `.d.ts` files for JavaScript files you may want to use
`emitDeclarationOnly` or use `outDir` to ensure that the JavaScript files are
not overwritten.

  * Default:

`true` if `composite`; `false` otherwise.

  * Related:
    * `declarationDir`

    * `emitDeclarationOnly`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Declaration Dir - `declarationDir`

Offers a way to configure the root directory for where declaration files are
emitted.

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

with this `tsconfig.json`:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
        "[declarationDir](https://www.typescriptlang.org/tsconfig#declarationDir)": "./types"
    
      }
    
    }

Would place the d.ts for the `index.ts` in a `types` folder:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.js
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îú‚îÄ‚îÄ tsconfig.json
    
    ‚îî‚îÄ‚îÄ types
    
        ‚îî‚îÄ‚îÄ index.d.ts

  * Related:
    * `declaration`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Declaration Map - `declarationMap`

Generates a source map for `.d.ts` files which map back to the original `.ts`
source file. This will allow editors such as VS Code to go to the original
`.ts` file when using features like _Go to Definition_.

You should strongly consider turning this on if you‚Äôre using project
references.

  * Released:

[2.9](/docs/handbook/release-notes/typescript-2-9.html)

### # Downlevel Iteration - `downlevelIteration`

Downleveling is TypeScript‚Äôs term for transpiling to an older version of
JavaScript. This flag is to enable support for a more accurate implementation
of how modern JavaScript iterates through new concepts in older JavaScript
runtimes.

ECMAScript 6 added several new iteration primitives: the `for / of` loop (`for
(el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`),
and `Symbol.iterator`. `downlevelIteration` allows for these iteration
primitives to be used more accurately in ES5 environments if a
`Symbol.iterator` implementation is present.

#### Example: Effects on `for / of`

With this TypeScript code:

    
    
    ts
    
    const str = "Hello!";
    
    for (const s of str) {
    
      console.log(s);
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBNBOMC8MBEAJApgG2yAhKgNwBQAZiIgBSiSwQwhlxTwCUMA3iTDLRCGyYAdHgDmVCG1IBfIA)

Without `downlevelIteration` enabled, a `for / of` loop on any object is
downleveled to a traditional `for` loop:

    
    
    ts
    
    "use strict";
    
    var str = "Hello!";
    
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
    
        var s = str_1[_i];
    
        console.log(s);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBAM4AWA9gO7oC2AlpLgMakB2hkobsoAvKAEQAJRABthpAIR8A3LgBmpLgAomrdoVClZHSLACUoAN65QoFYVLDEAOjHxFhXTIC+QA)

This is often what people expect, but it‚Äôs not 100% compliant with ECMAScript
iteration protocol. Certain strings, such as emoji (üòú), have a `.length` of 2
(or even more!), but should iterate as 1 unit in a `for-of` loop. See [this
blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-
equals-two) for a longer explanation.

When `downlevelIteration` is enabled, TypeScript will use a helper function
that checks for a `Symbol.iterator` implementation (either native or
polyfill). If this implementation is missing, you‚Äôll fall back to index-based
iteration.

    
    
    ts
    
    "use strict";
    
    var __values = (this && this.__values) || function(o) {
    
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    
        if (m) return m.call(o);
    
        if (o && typeof o.length === "number") return {
    
            next: function () {
    
                if (o && i >= o.length) o = void 0;
    
                return { value: o && o[i++], done: !o };
    
            }
    
        };
    
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    
    };
    
    var e_1, _a;
    
    var str = "Hello!";
    
    try {
    
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
    
            var s = str_1_1.value;
    
            console.log(s);
    
        }
    
    }
    
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    
    finally {
    
        try {
    
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
    
        }
    
        finally { if (e_1) throw e_1.error; }
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y4AzgAsy6ALbtIuAMZc+kULNigAvKABEACXqViAQlUBuXADNiigBTTys+aGJH5kWAEpQAb1yhQlvsWoA6bXgzPidDAF8gA)

You can use [tslib](https://www.npmjs.com/package/tslib) via `importHelpers`
to reduce the amount of inline JavaScript too:

    
    
    ts
    
    "use strict";
    
    var __values = (this && this.__values) || function(o) {
    
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    
        if (m) return m.call(o);
    
        if (o && typeof o.length === "number") return {
    
            next: function () {
    
                if (o && i >= o.length) o = void 0;
    
                return { value: o && o[i++], done: !o };
    
            }
    
        };
    
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    
    };
    
    var e_1, _a;
    
    var str = "Hello!";
    
    try {
    
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
    
            var s = str_1_1.value;
    
            console.log(s);
    
        }
    
    }
    
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    
    finally {
    
        try {
    
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
    
        }
    
        finally { if (e_1) throw e_1.error; }
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y47AtgAdisSAAl6glgGceEaQAsy6fu0i4Axl2mRQO2KAC8oAEQTKlYgEITAblwAzEaAAUW8jr2hiDvZFgAlKAA3rigoO7SxNQAdJbwLtIB9gC+QA)

**Note:** enabling `downlevelIteration` does not improve compliance if
`Symbol.iterator` is not present in the runtime.

#### Example: Effects on Array Spreads

This is an array spread:

    
    
    js
    
    // Make a new array whose elements are 1 followed by the elements of arr2
    
    const arr = [1, ...arr2];

Based on the description, it sounds easy to downlevel to ES5:

    
    
    js
    
    // The same, right?
    
    const arr = [1].concat(arr2);

However, this is observably different in certain rare cases.

For example, if a source array is missing one or more items (contains a hole),
the spread syntax will replace each empty item with `undefined`, whereas
`.concat` will leave them intact.

    
    
    js
    
    // Make an array where the element at index 1 is missing
    
    let arrayWithHole = ["a", , "c"];
    
    let spread = [...arrayWithHole];
    
    let concatenated = [].concat(arrayWithHole);
    
    console.log(arrayWithHole);
    
    // [ 'a', <1 empty item>, 'c' ]
    
    console.log(spread);
    
    // [ 'a', undefined, 'c' ]
    
    console.log(concatenated);
    
    // [ 'a', <1 empty item>, 'c' ]

Just as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if
present) to more accurately emulate ES 6 behavior.

  * Related:
    * `importHelpers`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Emit BOM - `emitBOM`

Controls whether TypeScript will emit a [byte order mark
(BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files.
Some runtime environments require a BOM to correctly interpret a JavaScript
files; others require that it is not present. The default value of `false` is
generally best unless you have a reason to change it.

### # Emit Declaration Only - `emitDeclarationOnly`

_Only_ emit `.d.ts` files; do not emit `.js` files.

This setting is useful in two cases:

  * You are using a transpiler other than TypeScript to generate your JavaScript.
  * You are using TypeScript to only generate `d.ts` files for your consumers.

  * Related:
    * `declaration`

  * Released:

[2.8](/docs/handbook/release-notes/typescript-2-8.html)

### # Import Helpers - `importHelpers`

For certain downleveling operations, TypeScript uses some helper code for
operations like extending class, spreading arrays or objects, and async
operations. By default, these helpers are inserted into files which use them.
This can result in code duplication if the same helper is used in many
different modules.

If the `importHelpers` flag is on, these helper functions are instead imported
from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to
ensure that the `tslib` module is able to be imported at runtime. This only
affects modules; global script files will not attempt to import modules.

For example, with this TypeScript:

    
    
    ts
    
    export function fn(arr: number[]) {
    
      const arr2 = [1, ...arr];
    
    }

Turning on `downlevelIteration` and `importHelpers` is still false:

    
    
    ts
    
    var __read = (this && this.__read) || function (o, n) {
    
        var m = typeof Symbol === "function" && o[Symbol.iterator];
    
        if (!m) return o;
    
        var i = m.call(o), r, ar = [], e;
    
        try {
    
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    
        }
    
        catch (error) { e = { error: error }; }
    
        finally {
    
            try {
    
                if (r && !r.done && (m = i["return"])) m.call(i);
    
            }
    
            finally { if (e) throw e.error; }
    
        }
    
        return ar;
    
    };
    
    var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    
            if (ar || !(i in from)) {
    
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
    
                ar[i] = from[i];
    
            }
    
        }
    
        return to.concat(ar || Array.prototype.slice.call(from));
    
    };
    
    export function fn(arr) {
    
        var arr2 = __spreadArray([1], __read(arr), false);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFaYSADwAOsAulAAzAK6sAxsNGLWACkIFKrJcgBGAgNoBdAJSgA3plChVoyPL0AmUAF5QZgIwANKAAdKF6FgDcmAC+QA)

Then turning on both `downlevelIteration` and `importHelpers`:

    
    
    ts
    
    import { __read, __spreadArray } from "tslib";
    
    export function fn(arr) {
    
        var arr2 = __spreadArray([1], __read(arr), false);
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFYMIqZAAdYBdNF5SBkceFaxEBArJUkAHjLmgAZgFdWAY2GiTrABSEClVqeQAjAQG0AugEpQAN6YoKAWopDooI4ATKAAvKCeAIwANKAAdJmO3gDcmAC+QA)

You can use `noEmitHelpers` when you provide your own implementations of these
functions.

  * Related:
    * `noEmitHelpers`

    * `downlevelIteration`

### # Inline Source Map - `inlineSourceMap`

When set, instead of writing out a `.js.map` file to provide source maps,
TypeScript will embed the source map content in the `.js` files. Although this
results in larger JS files, it can be convenient in some scenarios. For
example, you might want to debug JS files on a webserver that doesn‚Äôt allow
`.map` files to be served.

Mutually exclusive with `sourceMap`.

For example, with this TypeScript:

    
    
    ts
    
    const helloWorld = "hi";
    
    console.log(helloWorld);

Converts to this JavaScript:

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)

Then enable building it with `inlineSourceMap` enabled there is a comment at
the bottom of the file which includes a source-map for the file.

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQWQIYAOAUCBAM4AWKA7gKIC2kALsVitOc6JQrLCgDqKDLAAmoALygARJUgyA3Gw7kUsBADoBAcwAUvfkJHiAlIqA)

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Inline Sources - `inlineSources`

When set, TypeScript will include the original content of the `.ts` file as an
embedded string in the source map (using the source map‚Äôs `sourcesContent`
property). This is often useful in the same cases as `inlineSourceMap`.

Requires either `sourceMap` or `inlineSourceMap` to be set.

For example, with this TypeScript:

    
    
    ts
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAFgUwDZJAdRAJyQExgXhgCI4BLIgbgChRIQkEA6VAcwApEV0tcBKCoA)

By default converts to this JavaScript:

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)

Then enable building it with `inlineSources` and `inlineSourceMap` enabled
there is a comment at the bottom of the file which includes a source-map for
the file. Note that the end is different from the example in `inlineSourceMap`
because the source-map now contains the original source code also.

    
    
    ts
    
    "use strict";
    
    const helloWorld = "hi";
    
    console.log(helloWorld);
    
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQZwFAgQzzTLrYICyAhgA6Fji4AWKA7gKIC2kALviwpouPqBYJYsFAHUUGWABNQAXlAAiFpHUBuQcNwpYCAHTSA5gAoJU2fKUBKHUA)

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # Map Root - `mapRoot`

Specify the location where debugger should locate map files instead of
generated locations. This string is treated verbatim inside the source-map,
for example:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
    
        "[mapRoot](https://www.typescriptlang.org/tsconfig#mapRoot)": "https://my-website.com/debug/sourcemaps/"
    
      }
    
    }

Would declare that `index.js` will have sourcemaps at `https://my-
website.com/debug/sourcemaps/index.js.map`.

### # New Line - `newLine`

Specify the end of line sequence to be used when emitting files: ‚ÄòCRLF‚Äô (dos)
or ‚ÄòLF‚Äô (unix).

  * Default:

`lf`

  * Allowed:
    * `crlf`

    * `lf`

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # No Emit - `noEmit`

Do not emit compiler output files like JavaScript source code, source-maps or
declarations.

This makes room for another tool like [Babel](https://babeljs.io), or
[swc](https://github.com/swc-project/swc) to handle converting the TypeScript
file to a file which can run inside a JavaScript environment.

You can then use TypeScript as a tool for providing editor integration, and as
a source code type-checker.

### # No Emit Helpers - `noEmitHelpers`

Instead of importing helpers with `importHelpers`, you can provide
implementations in the global scope for the helpers you use and completely
turn off emitting of helper functions.

For example, using this `async` function in ES5 requires a `await`-like
function and `generator`-like function to run:

    
    
    ts
    
    const getAPI = async (url: string) => {
    
      // Get API
    
      return {};
    
    };
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBA5gUygQQAoEkYF4YEMICeYwMAFAK4BOANgFwzSUCWYcAlNgHwwDeAUDBgB6ITADiSGGnQCYlJFTC8AvgG4+aoA)

Which creates quite a lot of JavaScript:

    
    
    ts
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    
        return new (P || (P = Promise))(function (resolve, reject) {
    
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
    
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
    
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
    
            step((generator = generator.apply(thisArg, _arguments || [])).next());
    
        });
    
    };
    
    var __generator = (this && this.__generator) || function (thisArg, body) {
    
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    
        function verb(n) { return function (v) { return step([n, v]); }; }
    
        function step(op) {
    
            if (f) throw new TypeError("Generator is already executing.");
    
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
    
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
    
                if (y = 0, t) op = [op[0] & 2, t.value];
    
                switch (op[0]) {
    
                    case 0: case 1: t = op; break;
    
                    case 4: _.label++; return { value: op[1], done: false };
    
                    case 5: _.label++; y = op[1]; op = [0]; continue;
    
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
    
                    default:
    
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
    
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
    
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
    
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
    
                        if (t[2]) _.ops.pop();
    
                        _.trys.pop(); continue;
    
                }
    
                op = body.call(thisArg, _);
    
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
    
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    
        }
    
    };
    
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
    
        return __generator(this, function (_a) {
    
            // Get API
    
            return [2 /*return*/, {}];
    
        });
    
    }); };
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArJgMawB2k6op6AggAoCSoALyg8kAJ7MGoABQBXAgBtKbAqmZEAlEIB8oAN6ZQoHAHEyoXn0OgCZec30BfANyYXQA)

Which can be switched out with your own globals via this flag:

    
    
    ts
    
    "use strict";
    
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
    
        return __generator(this, function (_a) {
    
            // Get API
    
            return [2 /*return*/, {}];
    
        });
    
    }); };
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOAHawoYASJANgA4kGRMAY1hNI6UKXQBBAAoBJUAF5QeSAE8mQ0AAoArgS6VxBVEyIBKZQD5QAb0yhQOAOJlQc+Y9AEyBpvYAvgDcmCFAA)

  * Related:
    * `importHelpers`

  * Released:

[1.5](/docs/handbook/release-notes/typescript-1-5.html)

### # No Emit On Error - `noEmitOnError`

Do not emit compiler output files like JavaScript source code, source-maps or
declarations if any errors were reported.

This defaults to `false`, making it easier to work with TypeScript in a watch-
like environment where you may want to see results of changes to your code in
another environment before making sure all errors are resolved.

  * Released:

[1.4](/docs/handbook/release-notes/typescript-1-4.html)

### # Out Dir - `outDir`

If specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be
emitted into this directory. The directory structure of the original source
files is preserved; see `rootDir` if the computed root is not what you
intended.

If not specified, `.js` files will be emitted in the same directory as the
`.ts` files they were generated from:

    
    
    sh
    
    $ tsc
    
    example
    
    ‚îú‚îÄ‚îÄ index.js
    
    ‚îî‚îÄ‚îÄ index.ts

With a `tsconfig.json` like this:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "dist"
    
      }
    
    }

Running `tsc` with these settings moves the files into the specified `dist`
folder:

    
    
    sh
    
    $ tsc
    
    example
    
    ‚îú‚îÄ‚îÄ dist
    
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îî‚îÄ‚îÄ tsconfig.json

  * Related:
    * `out`

    * `outFile`

### # Out File - `outFile`

If specified, all _global_ (non-module) files will be concatenated into the
single output file specified.

If `module` is `system` or `amd`, all module files will also be concatenated
into this file after all global content.

Note: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`.
This option _cannot_ be used to bundle CommonJS or ES6 modules.

  * Related:
    * `out`

    * `outDir`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Preserve Const Enums - `preserveConstEnums`

Do not erase `const enum` declarations in generated code. `const enum`s
provide a way to reduce the overall memory footprint of your application at
runtime by emitting the enum value instead of a reference.

For example with this TypeScript:

    
    
    ts
    
    const enum Album {
    
      JimmyEatWorldFutures = 1,
    
      TubRingZooHypothesis = 2,
    
      DogFashionDiscoAdultery = 3,
    
    }
    
    ¬†
    
    const selectedAlbum = Album.JimmyEatWorldFutures;
    
    if (selectedAlbum === Album.JimmyEatWorldFutures) {
    
      console.log("That is a great choice.");
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgQQDYCMUwN4BQMMAUgJbLICeAogIZQDqIAThgCYBiiUiLcEGAF4YARgA0RGABVEWAEpkwAcwBaIEAAkqABxBQAFgLKCRAJknEAIiGWc6EA2XBWToNO0QYocFlWEwAMySAL4EBKCQsBBwGHDAPuyYOKgiySgAdOSUtAzMbFw8fAIA3ARkAGYwABQxcQlwSdi4Qq3ozchZFNT0TKwc3Lz8EACU+FKRECBxGRi21QBE0gYMMCYwdDDK-KvABiBkwHAZCyNlIUA)

The default `const enum` behavior is to convert any `Album.Something` to the
corresponding number literal, and to remove a reference to the enum from the
JavaScript completely.

    
    
    ts
    
    "use strict";
    
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
    
        console.log("That is a great choice.");
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VAEEAbAIwtAG9NRQApVZZAT0QEN0AdVgAnGgBMAYmXRlRxSKAC8oAIwAaVqAAqZOgCVUeAOYAtWLAASPAA6x00RaiWqATFrYARWCan8YVHwvF1wqCTIadGJRHhVQAGYtAF9MHHxCUEhiGmJsaIlaBkpVIooAOk5uPkERcWlZeUUAbkxUADNQAAps3PziQvpGZRHqIeRKrl4BYTFJGTkFSABKZm1cAlhc8ppfLoAiHWhBUBdQflATBRPsOFRsYnL95dbkoA)

With `preserveConstEnums` set to `true`, the `enum` exists at runtime and the
numbers are still emitted.

    
    
    ts
    
    "use strict";
    
    var Album;
    
    (function (Album) {
    
        Album[Album["JimmyEatWorldFutures"] = 1] = "JimmyEatWorldFutures";
    
        Album[Album["TubRingZooHypothesis"] = 2] = "TubRingZooHypothesis";
    
        Album[Album["DogFashionDiscoAdultery"] = 3] = "DogFashionDiscoAdultery";
    
    })(Album || (Album = {}));
    
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
    
        console.log("That is a great choice.");
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEAcCcFMGdbQG6wMIHsB28AuBRLAVwFt4AuUXaI2AKBAngAsMB3fEgS1zoGNseULGIlQAQQA2AI1KgA3nVCgAUlxIkAnvgCGuAOoZokgCYAxIriJx4oALygAjABoloACpFpAJS5YA5gBaGBgAEpqQGLjMCFy2DgBMrsoAIhj+ZjosXNgpcQLiJkSSuEia9qAAzK4AvnT8grigiJKwfKUmUrJiDl2kAHRqGtp6hsbmltYIANx0XABmoAAULW0dfT12vTIDQ1q6BkamFlY2AJQKbgI4GK39kulLAETuzHqgcaA6oP5w73ysLh8WD9J5nWY1IA)

This essentially makes such `const enums` a source-code feature only, with no
runtime traces.

  * Default:

`true` if `isolatedModules`; `false` otherwise.

### # Remove Comments - `removeComments`

Strips all comments from TypeScript files when converting into JavaScript.
Defaults to `false`.

For example, this is a TypeScript file which has a JSDoc comment:

    
    
    ts
    
    /** The translation of 'Hello world' into Portuguese */
    
    export const helloWorldPTBR = "Ol√° Mundo";

When `removeComments` is set to `true`:

    
    
    ts
    
    export const helloWorldPTBR = "Ol√° Mundo";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBco6uArvtgFSegAq0+ZrgCGNSABth6VLBqhYAM1AByABL5x42KHixc4gCbLQqOtoAKe9KwDm7SIM7BM+AB4AHK6ADGsyOlABTVgAdT1Dc14AIQAlUABeUAAiAHlxAEPQAFlWGgNYJIBuIA)

Without setting `removeComments` or having it as `false`:

    
    
    ts
    
    /** The translation of 'Hello world' into Portuguese */
    
    export const helloWorldPTBR = "Ol√° Mundo";
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBcoAZgIYA2k+2AVD6ABVo+UOlysakdq3SpYNULGagA5AAl87drFDxYudgBMVoVHR0AFfegCuAcxv4uoHsEz4AHgAdroAMbykOigwlqwAOr6RhYCAEIASqAAvKAARADy7ACHoACyNjSGsKkA3EA)

This means that your comments will show up in the JavaScript code.

### # Source Map - `sourceMap`

Enables the generation of [sourcemap
files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map).
These files allow debuggers and other tools to display the original TypeScript
source code when actually working with the emitted JavaScript files. Source
map files are emitted as `.js.map` (or `.jsx.map`) files next to the
corresponding `.js` output file.

The `.js` files will in turn contain a sourcemap comment to indicate where the
files are to external tools, for example:

    
    
    ts
    
    // helloWorld.ts
    
    export declare const helloWorld = "hi";

Compiling with `sourceMap` set to `true` creates the following JavaScript
file:

    
    
    js
    
    // helloWorld.js
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    exports.helloWorld = "hi";
    
    //# sourceMappingURL=// helloWorld.js.map

And this also generates this json map:

    
    
    json
    
    // helloWorld.js.map
    
    {
    
      "version": 3,
    
      "file": "ex.js",
    
      "sourceRoot": "",
    
      "sources": ["../ex.ts"],
    
      "names": [],
    
      "mappings": ";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA"
    
    }

### # Source Root - `sourceRoot`

Specify the location where a debugger should locate TypeScript files instead
of relative source locations. This string is treated verbatim inside the
source-map where you can use a path or a URL:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
    
        "[sourceRoot](https://www.typescriptlang.org/tsconfig#sourceRoot)": "https://my-website.com/debug/source/"
    
      }
    
    }

Would declare that `index.js` will have a source file at `https://my-
website.com/debug/source/index.ts`.

### # Strip Internal - `stripInternal`

Do not emit declarations for code that has an `@internal` annotation in its
JSDoc comment. This is an internal compiler option; use at your own risk,
because the compiler does not check that the result is valid. If you are
searching for a tool to handle additional levels of visibility within your
`d.ts` files, look at [api-extractor](https://api-extractor.com).

    
    
    ts
    
    /**
    
     * Days available in a week
    
     * @internal
    
     */
    
    export const daysInAWeek = 7;
    
    ¬†
    
    /** Calculate how much someone earns in a week */
    
    export function weeklySalary(dayRate: number) {
    
      return daysInAWeek * dayRate;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgRBDAngZ0vAbvAlgG3gIxwFNIsA7NSAdyKIGsoYABcgFyICcz4dHhwiADwAOAew6tIAY1FlkkgCZJkASTIBBAOq06kALyQA7AG5w4UDADCPKQFc87SAAtRVSAFtbUp5GSj3RLIkRPBcqOSUNPTQ-EJiEpAAZrZkUqxYstQ6OIgAyjyhiAAUSogASvDsAFyQZLbu+JwAlJAA3lCQHESstlyQpaoa2tEwpRXspgC+QA)

With the flag set to `false` (default):

    
    
    ts
    
    /**
    
     * Days available in a week
    
     * @internal
    
     */
    
    export declare const daysInAWeek = 7;
    
    /** Calculate how much someone earns in a week */
    
    export declare function weeklySalary(dayRate: number): number;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCmwBUslqFmgAIsICekUMIBuwosIBGxchW2h4WLAGtFy8JWyiKwwneAtaAB1ij0oAWlIfxwNSABJCgBBAHUra1AAXlAAdgBuFjllAGFXAQBXEWxQOHhQZHyBaFBIWGQsaSxQLDEKLUpzSxslD29ffwAzfIoBSWkLeMJ1AGVXMXUAClD1ACUJUlAKfORDLFEASlAAb0VQUSx0fOdQZYjouO7lZbXsDIBfIA)

With `stripInternal` set to `true` the `d.ts` emitted will be redacted.

    
    
    ts
    
    /** Calculate how much someone earns in a week */
    
    export declare function weeklySalary(dayRate: number): number;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsAO8B20CmsUEMA2AoECSACwHsB3AUQFt5oMATAMXl3QC5RVH0APAHSMB0SITBRy1OtHEReAY1zZY2aPDIpCAKm35Q20ABFsAT0ihsAN2xtsAI3bcUl0BXToA1vsPhUGLDwfYHx+RDJYaFAFTRhQRjNIAEkUAEEAdQ9PUABeUAB2AG58HUMAYTwFAFdlDFApUBoqhRJQSDIadE10UHQVFAtUV3cvAxCwiKiAMyqUBXVNNyzcUwBlPBVTAAoE0wAlNU5QFCqae0wASlAAb31QWHRoKqx4xJSMrINX-cPigF8gA)

The JavaScript output is still the same.

  * Internal

## #JavaScript Support

### # Allow JS - `allowJs`

Allow JavaScript files to be imported inside your project, instead of just
`.ts` and `.tsx` files. For example, this JS file:

    
    
    js
    
    // @filename: card.js
    
    export const defaultCardDeck = "Heart";
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQ8AHgA4D2eALjvYmSwfJMgK6xMAwvgIAReNgDWoALygARAAl4+JvIDcQA)

When imported into a TypeScript file will raise an error:

    
    
    ts
    
    // @filename: index.ts
    
    import { defaultCardDeck } from "./card";
    
    ¬†
    
    console.log(defaultCardDeck);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMB2AUCBAGYCWANpAHYCGAtpKgMbXQAmAdAFaJ61ysBXCu0gAPAA4IALonatIRakKkBhFqwAikRgGtQAXlAAiABKQWUowG4CYALQPGAqQ7u3i5KnQagSleaLsMngktJLQUqAA3qDyispqbFq6oAC+oETwtMbswMxs1nh4jHCUiHDCZHAA5gAUcUpkqurJOgCUVkA)

Imports fine with `allowJs` enabled:

    
    
    ts
    
    // @filename: index.ts
    
    import { defaultCardDeck } from "./card";
    
    ¬†
    
    console.log(defaultCardDeck);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQqA9gQK4JHwAeADtXgC5lEHyTIGnAML4CAEXjYA1qAC8oAEQAJePk6KA3BRCgAtAex1OBvTrDhksWNQDuAKUq6ocJGkyhoiPsyLcK0KjsXKAA3qB8AkKihJIyoAC+oJB41KhKRMC4hFoUFNjUiGTUjDYA5gAUkYKwImJx0gCUmkA)

This flag can be used as a way to incrementally add TypeScript files into JS
projects by allowing the `.ts` and `.tsx` files to live along-side existing
JavaScript files.

It can also be used along-side `declaration` and `emitDeclarationOnly` to
[create declarations for JS files](/docs/handbook/declaration-files/dts-from-
js.html).

  * Related:
    * `checkJs`

    * `emitDeclarationOnly`

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # Check JS - `checkJs`

Works in tandem with `allowJs`. When `checkJs` is enabled then errors are
reported in JavaScript files. This is the equivalent of including `// @ts-
check` at the top of all JavaScript files which are included in your project.

For example, this is incorrect JavaScript according to the `parseFloat` type
definition which comes with TypeScript:

    
    
    js
    
    // parseFloat only takes a string
    
    module.exports.pi = parseFloat(3.142);

When imported into a TypeScript module:

    
    
    ts
    
    // @filename: constants.js
    
    module.exports.pi = parseFloat(3.142);
    
    ¬†
    
    // @filename: index.ts
    
    import { pi } from "./constants";
    
    console.log(pi);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEMBtoewO4CkDOAoEEBmBLaBTAO0gFt8AuUAYzkJQBdJD6UA6AK3RLgBMBXAq3wAPAA5wATi1aicoALyhRkCSnwAxeJHoAKAMysAjABYATAEoA3GgxhwuAsTKUchHiNYs0OEuKmgAbyU5AF9QLAk4ElAAIlZgGjpGZhQY60SUOEF4AHMdWSsgA)

You will not get any errors. However, if you turn on `checkJs` then you will
get error messages from the JavaScript file.

    
    
    ts
    
    // @filename: constants.js
    
    module.exports.pi = parseFloat(3.142);
    
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    
    ¬†
    
    // @filename: index.ts
    
    import { pi } from "./constants";
    
    console.log(pi);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUCBAIYA2JcA7gFYqgAu0ArpAWOAMYAWk7A1jagbNWEAGYBLEpAB2RALaRU7ONMR0i0uogB0NPHLgATRlO2QAHgAcEW7ZfGgAvKEtEkkAGLkidABQZtAEYsNABKAG48EXAJKVkFVHFpQwttLTxxOWtoOlAAbxcHAF9QUXg5UAAibWBlVXVNRErIusQ4U3IAc197CKA)

  * Related:
    * `allowJs`

    * `emitDeclarationOnly`

  * Released:

[2.3](/docs/handbook/release-notes/typescript-2-3.html)

### # Max Node Module JS Depth - `maxNodeModuleJsDepth`

The maximum dependency depth to search under `node_modules` and load
JavaScript files.

This flag can only be used when `allowJs` is enabled, and is used if you want
to have TypeScript infer types for all of the JavaScript inside your
`node_modules`.

Ideally this should stay at 0 (the default), and `d.ts` files should be used
to explicitly define the shape of modules. However, there are cases where you
may want to turn this on at the expense of speed and potential accuracy.

## #Editor Support

### # Disable Size Limit - `disableSizeLimit`

To avoid a possible memory bloat issues when working with very large
JavaScript projects, there is an upper limit to the amount of memory
TypeScript will allocate. Turning this flag on will remove the limit.

### # Plugins - `plugins`

List of language service plugins to run inside the editor.

Language service plugins are a way to provide additional information to a user
based on existing TypeScript files. They can enhance existing messages between
TypeScript and an editor, or to provide their own error messages.

For example:

  * [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) ‚Äî Adds SQL linting with a template strings SQL builder.
  * [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) ‚Äî Provides CSS linting inside template strings .
  * [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) ‚Äî Provides eslint error messaging and fix-its inside the compiler‚Äôs output.
  * [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) ‚Äî Provides validation and auto-completion inside GraphQL query template strings.

VS Code has the ability for a extension to [automatically include language
service plugins](https://code.visualstudio.com/api/references/contribution-
points#contributes.typescriptServerPlugins), and so you may have some running
in your editor without needing to define them in your `tsconfig.json`.

## #Interop Constraints

### # Allow Synthetic Default Imports - `allowSyntheticDefaultImports`

When set to true, `allowSyntheticDefaultImports` allows you to write an import
like:

    
    
    ts
    
    import React from "react";

instead of:

    
    
    ts
    
    import * as React from "react";

When the module **does not** explicitly specify a default export.

For example, without `allowSyntheticDefaultImports` as true:

    
    
    ts
    
    // @filename: utilFunctions.js
    
    const getStringLength = (str) => str.length;
    
    ¬†
    
    module.exports = {
    
      getStringLength,
    
    };
    
    ¬†
    
    // @filename: index.ts
    
    import utils from "./utilFunctions";
    
    Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.1192Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.
    
    ¬†
    
    const count = utils.getStringLength("Check JS");
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYCsBOdacMAoECAYwAtIyBrAKURLHAEMAbNuAdwaYkkQBZOABMArm0gBJAHYAXGHAAOqAGbtEkPuFUBLSTJYBbSKjFz9AMTEyyFuDMQA6AFaNS4GXClGlbXWS6cgCCMgCeahpaZA6IcqAA5pByAMpy0LoyCQAykFlyFKAAvKAAFHHQAJTFAHygFU4GCQUA3ERERqISkE6QAB5KCHKIxaAA3kSgiclpGVm5+RQANEQAvm3aegbGpqCZIv1Ow0S6vkOg5vojqvBGoABETsCXbNa29o73GzGO8TE28RKL2cSVS6UyOTyzQopXuAGEqLRQHQUvdKi0gA)

This code raises an error because there isn‚Äôt a `default` object which you can
import. Even though it feels like it should. For convenience, transpilers like
Babel will automatically create a default if one isn‚Äôt created. Making the
module look a bit more like:

    
    
    js
    
    // @filename: utilFunctions.js
    
    const getStringLength = (str) => str.length;
    
    const allFunctions = {
    
      getStringLength,
    
    };
    
    module.exports = allFunctions;
    
    module.exports.default = allFunctions;

This flag does not affect the JavaScript emitted by TypeScript, it‚Äôs only for
the type checking. This option brings the behavior of TypeScript in-line with
Babel, where extra code is emitted to make using a default export of a module
more ergonomic.

  * Default:

`true` if `esModuleInterop` is enabled, `module` is `system`, or
`moduleResolution` is `bundler`; `false` otherwise.

  * Related:
    * `esModuleInterop`

  * Released:

[1.8](/docs/handbook/release-notes/typescript-1-8.html)

### # ES Module Interop - `esModuleInterop`

By default (with `esModuleInterop` false or not set) TypeScript treats
CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two
parts in particular which turned out to be flawed assumptions:

  * a namespace import like `import * as moment from "moment"` acts the same as `const moment = require("moment")`

  * a default import like `import moment from "moment"` acts the same as `const moment = require("moment").default`

This mis-match causes these two issues:

  * the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require("x")` then TypeScript allowed for the import to be treated as a function and be callable. That‚Äôs not valid according to the spec.

  * while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn‚Äôt conform as strictly as TypeScript‚Äôs implementation.

Turning on `esModuleInterop` will fix both of these problems in the code
transpiled by TypeScript. The first changes the behavior in the compiler, the
second is fixed by two new helper functions which provide a shim to ensure
compatibility in the emitted JavaScript:

    
    
    ts
    
    import * as fs from "fs";
    
    import _ from "lodash";
    
    fs.readFileSync("file.txt", "utf8");
    
    _.chunk(["a", "b", "c", "d"], 2);

With `esModuleInterop` disabled:

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const fs = require("fs");
    
    const lodash_1 = require("lodash");
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4BcoAGYBDFiioUIhRqyqCAxtEIzIAK3TFCvZKVAAqUCJTCTQpIVAAiISisBuNFp3w9AfWEXrLRsewO0NFsAOngqEQYAMWI2AGUAT0gFAAobGKpg0gAPUisAGmsmUiEADisASkc3YIVsJkgAa2SAbSsRfOsAIw6rBR6GKwBdAoAmSqA)

With `esModuleInterop` set to `true`:

    
    
    ts
    
    "use strict";
    
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    
        if (k2 === undefined) k2 = k;
    
        var desc = Object.getOwnPropertyDescriptor(m, k);
    
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    
          desc = { enumerable: true, get: function() { return m[k]; } };
    
        }
    
        Object.defineProperty(o, k2, desc);
    
    }) : (function(o, m, k, k2) {
    
        if (k2 === undefined) k2 = k;
    
        o[k2] = m[k];
    
    }));
    
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    
    }) : function(o, v) {
    
        o["default"] = v;
    
    });
    
    var __importStar = (this && this.__importStar) || function (mod) {
    
        if (mod && mod.__esModule) return mod;
    
        var result = {};
    
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    
        __setModuleDefault(result, mod);
    
        return result;
    
    };
    
    var __importDefault = (this && this.__importDefault) || function (mod) {
    
        return (mod && mod.__esModule) ? mod : { "default": mod };
    
    };
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const fs = __importStar(require("fs"));
    
    const lodash_1 = __importDefault(require("lodash"));
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URCjVlQBcoAMbRCQyACt0xQr2SlQAKlABDFKABmuvUkKgARAdMBuNEpXw1AfX3GzLRjuxW0aAwDp4VFoMAGLEbADKAJ6QEgAU5mFUvqQAHqSmADRmTKR6ABymAJTWDr4S2EyQANaxANqmWplmAEZNphJtDKYAulkATMVAA)

_Note_ : The namespace import `import * as fs from "fs"` only accounts for
properties which [are owned](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)
(basically properties set on the object and not via the prototype chain) on
the imported object. If the module you‚Äôre importing defines its API using
inherited properties, you need to use the default import form (`import fs from
"fs"`), or disable `esModuleInterop`.

_Note_ : You can make JS emit terser by enabling `importHelpers`:

    
    
    ts
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const tslib_1 = require("tslib");
    
    const fs = tslib_1.__importStar(require("fs"));
    
    const lodash_1 = tslib_1.__importDefault(require("lodash"));
    
    fs.readFileSync("file.txt", "utf8");
    
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URihXslIAJKi1490mcIUasqALlABjaIQWQAVuiEj4pUACpQAQxSgAZletJCoAES2nAbjQHRoAPo2HziyMltjuaGi2AHTwVOYMAGLEbADKAJ6QagAULklUkaQAHqROADTOTKTWABxOAJQePpFq2EyQANaZANpO5qXOAEZ9TmpDDE4AumUATPVAA)

Enabling `esModuleInterop` will also enable `allowSyntheticDefaultImports`.

  * Recommended
  * Default:

`true` if `module` is `node16` or `nodenext`; `false` otherwise.

  * Related:
    * `allowSyntheticDefaultImports`

  * Released:

[2.7](/docs/handbook/release-notes/typescript-2-7.html)

### # Force Consistent Casing In File Names -
`forceConsistentCasingInFileNames`

TypeScript follows the case sensitivity rules of the file system it‚Äôs running
on. This can be problematic if some developers are working in a case-sensitive
file system and others aren‚Äôt. If a file attempts to import `fileManager.ts`
by specifying `./FileManager.ts` the file will be found in a case-insensitive
file system, but not on a case-sensitive file system.

When this option is set, TypeScript will issue an error if a program tries to
include a file by a casing different from the casing on disk.

  * Recommended
  * Default:

`true`

### # isolatedDeclarations - `isolatedDeclarations`

Require sufficient annotation on exports so other tools can trivially generate
declaration files.

For more information, see the [5.5 release notes](/docs/handbook/release-
notes/typescript-5-5.html#isolated-declarations)

### # Isolated Modules - `isolatedModules`

While you can use TypeScript to produce JavaScript code from TypeScript code,
it‚Äôs also common to use other transpilers such as [Babel](https://babeljs.io)
to do this. However, other transpilers only operate on a single file at a
time, which means they can‚Äôt apply code transforms that depend on
understanding the full type system. This restriction also applies to
TypeScript‚Äôs `ts.transpileModule` API which is used by some build tools.

These limitations can cause runtime problems with some TypeScript features
like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells
TypeScript to warn you if you write certain code that can‚Äôt be correctly
interpreted by a single-file transpilation process.

It does not change the behavior of your code, or otherwise change the behavior
of TypeScript‚Äôs checking and emitting process.

Some examples of code which does not work when `isolatedModules` is enabled.

#### Exports of Non-Value Identifiers

In TypeScript, you can import a _type_ and then subsequently export it:

    
    
    ts
    
    import { someType, someFunction } from "someModule";
    
    ¬†
    
    someFunction();
    
    ¬†
    
    export { someType, someFunction };
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEsC2AHZAXUAb1BWiwFMAVATxwoBpTyKAxAV0gGN8NpJQAX1AAzJFlAAiMpQCy0ACbsANhUkBuNGhltOPPpAAUASk1oKADzzxCJHbXpMdHbr35D1QA)

Because there‚Äôs no value for `someType`, the emitted `export` will not try to
export it (this would be a runtime error in JavaScript):

    
    
    js
    
    export { someFunction };

Single-file transpilers don‚Äôt know whether `someType` produces a value or not,
so it‚Äôs an error to export a name that only refers to a type.

#### Non-Module Files

If `isolatedModules` is set, namespaces are only allowed in _modules_ (which
means it has some form of `import`/`export`). An error occurs if a namespace
is found in a non-module file:

    
    
    ts
    
    namespace Instantiated {
    
    Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.1280Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.
    
      export const x = 1;
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYDsWBQIIBLROAGwEMAXSAEwFk4aBXUyRXAO3IFs2AHcgGNIoAJIdElch0qEqtUAG9coUJAAefBJVCC4EnetABedAG5cAXyA)

This restriction doesn‚Äôt apply to `.d.ts` files.

#### References to `const enum` members

In TypeScript, when you reference a `const enum` member, the reference is
replaced by its actual value in the emitted JavaScript. Changing this
TypeScript:

    
    
    ts
    
    declare const enum Numbers {
    
      Zero = 0,
    
      One = 1,
    
    }
    
    console.log(Numbers.Zero + Numbers.One);
    
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iFBXAtvAHIEBGIMa8A3gFDzwBaFS8AvPAAwA098A8igQcAjLwC+tZOiQQQAOghIA5gAoS+cpXnMYrANTEyFNPMEgAlAG4gA)

To this JavaScript:

    
    
    ts
    
    "use strict";
    
    console.log(0 + 1);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqSYAm+AxgDYCGBoLsNk6ULQCuyUADlRAI3y5IoAN6ZQoAFqzYoALygADABploAPI1820AEZDAX0y9+sNvgB0bWAHMAFJOQy5Luq4mgDUEtKykC6m+ACUANxAA)

Without knowledge of the values of these members, other transpilers can‚Äôt
replace the references to `Numbers`, which would be a runtime error if left
alone (since there are no `Numbers` object at runtime). Because of this, when
`isolatedModules` is set, it is an error to reference an ambient `const enum`
member.

  * Default:

`true` if `verbatimModuleSyntax`; `false` otherwise.

### # Preserve Symlinks - `preserveSymlinks`

This is to reflect the same flag in Node.js; which does not resolve the real
path of symlinks.

This flag also exhibits the opposite behavior to Webpack‚Äôs `resolve.symlinks`
option (i.e. setting TypeScript‚Äôs `preserveSymlinks` to true parallels setting
Webpack‚Äôs `resolve.symlinks` to false, and vice-versa).

With this enabled, references to modules and packages (e.g. `import`s and `///
<reference type="..." />` directives) are all resolved relative to the
location of the symbolic link file, rather than relative to the path that the
symbolic link resolves to.

### # Verbatim Module Syntax - `verbatimModuleSyntax`

By default, TypeScript does something called _import elision_. Basically, if
you write something like

    
    
    ts
    
    import { Car } from "./car";
    
    export function drive(car: Car) {
    
      // ...
    
    }

TypeScript detects that you‚Äôre only using an import for types and drops the
import entirely. Your output JavaScript might look something like this:

    
    
    js
    
    export function drive(car) {
    
      // ...
    
    }

Most of the time this is good, because if `Car` isn‚Äôt a value that‚Äôs exported
from `./car`, we‚Äôll get a runtime error.

But it does add a layer of complexity for certain edge cases. For example,
notice there‚Äôs no statement like `import "./car";` \- the import was dropped
entirely. That actually makes a difference for modules that have side-effects
or not.

TypeScript‚Äôs emit strategy for JavaScript also has another few layers of
complexity - import elision isn‚Äôt always just driven by how an import is used
- it often consults how a value is declared as well. So it‚Äôs not always clear
whether code like the following

    
    
    ts
    
    export { Car } from "./car";

should be preserved or dropped. If `Car` is declared with something like a
`class`, then it can be preserved in the resulting JavaScript file. But if
`Car` is only declared as a `type` alias or `interface`, then the JavaScript
file shouldn‚Äôt export `Car` at all.

While TypeScript might be able to make these emit decisions based on
information from across files, not every compiler can.

The `type` modifier on imports and exports helps with these situations a bit.
We can make it explicit whether an import or export is only being used for
type analysis, and can be dropped entirely in JavaScript files by using the
`type` modifier.

    
    
    ts
    
    // This statement can be dropped entirely in JS output
    
    import type * as car from "./car";
    
    // The named import/export 'Car' can be dropped in JS output
    
    import { type Car } from "./car";
    
    export { type Car } from "./car";

`type` modifiers are not quite useful on their own - by default, module
elision will still drop imports, and nothing forces you to make the
distinction between `type` and plain imports and exports. So TypeScript has
the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier,
`--preserveValueImports` to prevent _some_ module elision behavior, and
`--isolatedModules` to make sure that your TypeScript code works across
different compilers. Unfortunately, understanding the fine details of those 3
flags is hard, and there are still some edge cases with unexpected behavior.

TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to
simplify the situation. The rules are much simpler - any imports or exports
without a `type` modifier are left around. Anything that uses the `type`
modifier is dropped entirely.

    
    
    ts
    
    // Erased away entirely.
    
    import type { A } from "a";
    
    // Rewritten to 'import { b } from "bcd";'
    
    import { b, type c, type d } from "bcd";
    
    // Rewritten to 'import {} from "xyz";'
    
    import { type xyz } from "xyz";

With this new option, what you see is what you get.

That does have some implications when it comes to module interop though. Under
this flag, ECMAScript `import`s and `export`s won‚Äôt be rewritten to `require`
calls when your settings or file extension implied a different module system.
Instead, you‚Äôll get an error. If you need to emit code that uses `require` and
`module.exports`, you‚Äôll have to use TypeScript‚Äôs module syntax that predates
ES2015:

Input TypeScript | Output JavaScript  
---|---  
      
    
    tsimport foo = require("foo");

|

    
    
    jsconst foo = require("foo");  
      
    
    tsfunction foo() {}function bar() {}function baz() {}export = {  foo,  bar,  baz,};

|

    
    
    jsfunction foo() {}function bar() {}function baz() {}module.exports = {  foo,  bar,  baz,};  
  
While this is a limitation, it does help make some issues more obvious. For
example, it‚Äôs very common to forget to set the [`type` field in
`package.json`](https://nodejs.org/api/packages.html#type) under `--module
node16`. As a result, developers would start writing CommonJS modules instead
of an ES modules without realizing it, giving surprising lookup rules and
JavaScript output. This new flag ensures that you‚Äôre intentional about the
file type you‚Äôre using because the syntax is intentionally different.

Because `--verbatimModuleSyntax` provides a more consistent story than
`--importsNotUsedAsValues` and `--preserveValueImports`, those two existing
flags are being deprecated in its favor.

For more details, read up on [the original pull
request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal
issue](https://github.com/microsoft/TypeScript/issues/51479).

## #Backwards Compatibility

### # Charset - `charset`

In prior versions of TypeScript, this controlled what encoding was used when
reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but
will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.

  * Deprecated
  * Default:

`utf8`

### # Imports Not Used As Values - `importsNotUsedAsValues`

Deprecated in favor of `verbatimModuleSyntax`.

This flag controls how `import` works, there are 3 different options:

  * `remove`: The default behavior of dropping `import` statements which only reference types.

  * `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.

  * `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.

This flag works because you can use `import type` to explicitly create an
`import` statement which should never be emitted into JavaScript.

  * Default:

`remove`

  * Allowed:
    * `remove`

    * `preserve`

    * `error`

  * Related:
    * `preserveValueImports`

    * `verbatimModuleSyntax`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Keyof Strings Only - `keyofStringsOnly`

This flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.

This flag is used to help people keep this behavior from [before TypeScript
2.9‚Äôs release](/docs/handbook/release-notes/typescript-2-9.html#support-
number-and-symbol-named-properties-with-keyof-and-mapped-types).

  * Deprecated
  * Released:

[2.9](/docs/handbook/release-notes/typescript-2-9.html)

### # No Implicit Use Strict - `noImplicitUseStrict`

You shouldn‚Äôt need this. By default, when emitting a module file to a non-ES6
target, TypeScript emits a `"use strict";` prologue at the top of the file.
This setting disables the prologue.

### # No Strict Generic Checks - `noStrictGenericChecks`

TypeScript will unify type parameters when comparing two generic functions.

    
    
    ts
    
    type A = <T, U>(x: T, y: U) => [T, U];
    
    type B = <S>(x: S, y: S) => [S, S];
    
    ¬†
    
    function f(a: A, b: B) {
    
      b = a; // Ok
    
      a = b; // Error
    
    Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.2322Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.
    
    }
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFA4C4CeADpKAIKgC8oAPACoA0oAqgHwAUAHqk6IahYBKam1ABtPiwC6AbgIkyAIWp0Aypx6g1zAdpFUx4ndrl4AZgFcAdgGN8ASzjXQ5jgENU5ZgCNUSkQBvHFBQH1V3WVAQUAB5AGsQ0HdVHyiYgFFYBBwAXyA)

This flag can be used to remove that check.

  * Released:

[2.4](/docs/handbook/release-notes/typescript-2-4.html)

### # Out - `out`

Use `outFile` instead.

The `out` option computes the final file location in a way that is not
predictable or consistent. This option is retained for backward compatibility
only and is deprecated.

  * Deprecated
  * Related:
    * `outDir`

    * `outFile`

### # Preserve Value Imports - `preserveValueImports`

Deprecated in favor of `verbatimModuleSyntax`.

There are some cases where TypeScript can‚Äôt detect that you‚Äôre using an
import. For example, take the following code:

    
    
    ts
    
    import { Animal } from "./animal.js";
    
    eval("console.log(new Animal().isDangerous())");

or code using ‚ÄòCompiles to HTML‚Äô languages like Svelte or Vue.
`preserveValueImports` will prevent TypeScript from removing the import, even
if it appears unused.

When combined with `isolatedModules`: imported types _must_ be marked as type-
only because compilers that process single files at a time have no way of
knowing whether imports are values that appear unused, or a type that must be
removed in order to avoid a runtime crash.

  * Related:
    * `isolatedModules`

    * `importsNotUsedAsValues`

    * `verbatimModuleSyntax`

  * Released:

[4.5](/docs/handbook/release-notes/typescript-4-5.html)

### # Suppress Excess Property Errors - `suppressExcessPropertyErrors`

This disables reporting of excess property errors, such as the one shown in
the following example:

    
    
    ts
    
    type Point = { x: number; y: number };
    
    const p: Point = { x: 1, y: 3, m: 10 };
    
    Object literal may only specify known properties, and 'm' does not exist in type 'Point'.2353Object literal may only specify known properties, and 'm' does not exist in type 'Point'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAAU4BLAOz1AF5QBvUAD1WoFcBbAIxgDcoAhx79ooAL4CcAYzjVEdIqgo06jFu1ABGADTDUGA91Q6ADFIFA)

This flag was added to help people migrate to the stricter checking of new
object literals in [TypeScript 1.6](/docs/handbook/release-
notes/typescript-1-6.html#stricter-object-literal-assignment-checks).

We don‚Äôt recommend using this flag in a modern codebase, you can suppress one-
off cases where you need it using `// @ts-ignore`.

### # Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`

Turning `suppressImplicitAnyIndexErrors` on suppresses reporting the error
about implicit anys when indexing into objects, as shown in the following
example:

    
    
    ts
    
    const obj = { x: 10 };
    
    console.log(obj["foo"]);
    
    Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.7053Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM7mKKmX30IobZ76yQATSgA8AoqVLRS9YgDMAhsno064emQxZiZKrTDhKEqTNAB2AAwBWAMzV00SOtDQARgCtQAXlABvUMOIARnNQAF8AbjsHemhkSgA6ZGgAcwAKVzcAbQAiWWhobIBdAEpwoA)

Using `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is
recommended to use a `@ts-ignore` comment instead:

    
    
    ts
    
    const obj = { x: 10 };
    
    // @ts-ignore
    
    console.log(obj["foo"]);
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM5kZbFlXXrSSOjQBGAK1ABeUAG9QAD2IBGAAygAvgG5aYcFnoBaVAHMYpGp27RklAHTJougBT8BAbQBEAM2jQnAXQCUyoA)

  * Related:
    * `noImplicitAny`

## #Language and Environment

### # Emit Decorator Metadata - `emitDecoratorMetadata`

Enables experimental support for emitting type metadata for decorators which
works with the module [`reflect-
metadata`](https://www.npmjs.com/package/reflect-metadata).

For example, here is the TypeScript

    
    
    ts
    
    function LogMethod(
    
      target: any,
    
      propertyKey: string | symbol,
    
      descriptor: PropertyDescriptor
    
    ) {
    
      console.log(target);
    
      console.log(propertyKey);
    
      console.log(descriptor);
    
    }
    
    ¬†
    
    class Demo {
    
      @LogMethod
    
      public foo(bar: number) {
    
        // do nothing
    
      }
    
    }
    
    ¬†
    
    const demo = new Demo();
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgAyJA5gLKRMACxIATABQ1QoHAh6CAXKGzoAngBopoWAhLwEmVQGlIqpVUzJ0PUAB9QVVSgBGJXJumjIVIsliUEJQAFXX1DQh8-AJoASlAAby1SdCo3SAA6XF5xWXlMGIBuJPZU3AysnnEdPURDE1VC4pS0zOyvSKR-MkaAXxoaIlxsKipQQhQSBK1wbn5BEVEtWAZnXCQiUDoSEnFnbEDQdAYXRDjE6WkQUFFJ9BJhJGstPr6BksxryAnQAF5DyAA7mMvjtCkA)

With `emitDecoratorMetadata` not set to true (default) the emitted JavaScript
is:

    
    
    ts
    
    "use strict";
    
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    
    };
    
    function LogMethod(target, propertyKey, descriptor) {
    
        console.log(target);
    
        console.log(propertyKey);
    
        console.log(descriptor);
    
    }
    
    class Demo {
    
        foo(bar) {
    
            // do nothing
    
        }
    
    }
    
    __decorate([
    
        LogMethod
    
    ], Demo.prototype, "foo", null);
    
    const demo = new Demo();
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmNAZgK7oimJCXSgAMiQDmAWUiZmAEwAUNUKBwIp8gFyhs6AJ4AaNaFgIS8BJkMBpSIb1VMydFNAAfUFUMoARiS4puqKkFREyLCUCHoACpbWtoQRUTE0AJSgAN5mpOhUQZAAdLjSypramBkA3HmihbglZVLKFlaItg6GtfUFRaXlYalI0WS9AL40NES42FRUoIQoJDlm4JKy8kpmsHz+uEhEoDwkJMr+2LGg6HwBiFm56ur0iqvoJApI7mZTUzMNTCgMIrUAAXhukBYS0gK2UtSAA)

With `emitDecoratorMetadata` set to true the emitted JavaScript is:

    
    
    ts
    
    "use strict";
    
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    
    };
    
    var __metadata = (this && this.__metadata) || function (k, v) {
    
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    
    };
    
    function LogMethod(target, propertyKey, descriptor) {
    
        console.log(target);
    
        console.log(propertyKey);
    
        console.log(descriptor);
    
    }
    
    class Demo {
    
        foo(bar) {
    
            // do nothing
    
        }
    
    }
    
    __decorate([
    
        LogMethod,
    
        __metadata("design:type", Function),
    
        __metadata("design:paramtypes", [Number]),
    
        __metadata("design:returntype", void 0)
    
    ], Demo.prototype, "foo", null);
    
    const demo = new Demo();
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmdYUnmhUuUoIAspBwATCthoAzAK7oimJCXSgAMiQDm4zM0kAKGqFA4EOiQC5Q2dAE8ANKdCwEJeAkwOA0pAdbKkxkdB1QAB9QKgcUACMSXBczSUgqImRYEVsABQ8vH0J0zJEaAEpQAG9XUnQqRMgAOlxdIwsrTDKAbhr1etwmlp0jd09EH38Hbt66hubW1OKkLLJpgF8aGiJcbCoqUEIUEirXcG09CUNXWAU43CQiUDkSEiM47ARbdAV4xArqsxmeiSY7oEgGJBhVwbDZbPqYUCpI6gAC8oHQkBYB0gRyM3SAA)

  * Related:
    * `experimentalDecorators`

### # Experimental Decorators - `experimentalDecorators`

Enables [experimental support for
decorators](https://github.com/tc39/proposal-decorators), which is a version
of decorators that predates the TC39 standardization process.

Decorators are a language feature which hasn‚Äôt yet been fully ratified into
the JavaScript specification. This means that the implementation version in
TypeScript may differ from the implementation in JavaScript when it it decided
by TC39.

You can find out more about decorator support in TypeScript in [the
handbook](/docs/handbook/decorators.html).

  * Related:
    * `emitDecoratorMetadata`

### # JSX - `jsx`

Controls how JSX constructs are emitted in JavaScript files. This only affects
output of JS files that started in `.tsx` files.

  * `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production
  * `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only
  * `preserve`: Emit `.jsx` files with the JSX unchanged
  * `react-native`: Emit `.js` files with the JSX unchanged
  * `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls

### For example

This sample code:

    
    
    tsx
    
    export const HelloWorld = () => <h1>Hello world</h1>;

React: `"react-jsx"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-
new-jsx-transform.html)

    
    
    tsx
    
    import { jsx as _jsx } from "react/jsx-runtime";
    
    export const HelloWorld = () => _jsx("h1", { children: "Hello world" });
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q2kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQLAHxwADwZAIzro+MQcNkzrFvke+txQA)

React dev transform: `"react-
jsxdev"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html)

    
    
    tsx
    
    import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
    
    const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx";
    
    export const HelloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q3sAG6kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJTLAHxwADwZAIxbE1MQcNnzrLvkh1txQA)

Preserve: `"preserve"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => <h1>Hello world</h1>;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BYET2agBuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlEsAfHAAPBkAjJvjkxBw2XOsO+QHm3FAA)

React Native: `"react-native"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => <h1>Hello world</h1>;
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhMSigwwABuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlKsAfHAAPBkAjDtTMxBw2Yus++THO3FAA)

Legacy React runtime: `"react"`

    
    
    tsx
    
    import React from 'react';
    
    export const HelloWorld = () => React.createElement("h1", null, "Hello world");
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9qRIAB6QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQjAHxwADwZAIzTnd0QcNkDrHPkS9NxQA)

This option can be used on a per-file basis too using an `@jsxRuntime`
comment.

Always use the classic runtime (`"react"`) for this file:

    
    
    tsx
    
    /* @jsxRuntime classic */
    
    export const HelloWorld = () => <h1>Hello world</h1>;

Always use the automatic runtime (`"react-jsx"`) for this file:

    
    
    tsx
    
    /* @jsxRuntime automatic */
    
    export const HelloWorld = () => <h1>Hello world</h1>;

  * Allowed:
    * `preserve`

    * `react`

    * `react-native`

    * `react-jsx`

    * `react-jsxdev`

  * Related:
    * `jsxFactory`

    * `jsxFragmentFactory`

    * `jsxImportSource`

  * Released:

[2.2](/docs/handbook/release-notes/typescript-2-2.html)

### # JSX Factory - `jsxFactory`

Changes the function called in `.js` files when compiling JSX Elements using
the classic JSX runtime. The most common change is to use `"h"` or
`"preact.h"` instead of the default `"React.createElement"` if using `preact`.

For example, this TSX file:

    
    
    tsx
    
    import { h } from "preact";
    
    const HelloWorld = () => <div>Hello</div>;

With `jsxFactory: "h"` looks like:

    
    
    tsx
    
    const preact_1 = require("preact");
    
    const HelloWorld = () => (0, preact_1.h)("div", null, "Hello");
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdTmiPyg4oJymJgooAcyQw6kgcmnoinmwgELL0KupouFGaxqSkoJCwcADecFwANHDyUCi+IEia8AC+cNi4cABEYERW9QDcqQmaHPAAEkhKShAA6tBKsnAAvHAAFACUkwB8cAA8ssAAbgt9AxDL5GubrUA)

This option can be used on a per-file basis too similar to [Babel‚Äôs `/** @jsx
h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-
jsx#custom).

    
    
    tsx
    
    /** @jsx h */
    
    import { h } from "preact";
    
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    
    ¬†
    
    const HelloWorld = () => <div>Hello</div>;
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3KlQkWHADewuAF842XHABEYIuhhqA3KVJoIAO17wAEkgA2ViAHVoVgCZwAvHAAUASjcA+OAA8TsAAbr6WNhAB5MFhukA)

The factory chosen will also affect where the `JSX` namespace is looked up
(for type checking information) before falling back to the global one.

If the factory is defined as `React.createElement` (the default), the compiler
will check for `React.JSX` before checking for a global `JSX`. If the factory
is defined as `h`, it will check for `h.JSX` before a global `JSX`.

  * Default:

`React.createElement`

  * Allowed:
    * Any identifier or dotted identifier.

  * Related:
    * `jsx`

    * `jsxFragmentFactory`

    * `jsxImportSource`

### # JSX Fragment Factory - `jsxFragmentFactory`

Specify the JSX fragment factory function to use when targeting react JSX emit
with `jsxFactory` compiler option is specified, e.g. `Fragment`.

For example with this TSConfig:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react",
    
        "[jsxFactory](https://www.typescriptlang.org/tsconfig#jsxFactory)": "h",
    
        "[jsxFragmentFactory](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)": "Fragment"
    
      }
    
    }

This TSX file:

    
    
    tsx
    
    import { h, Fragment } from "preact";
    
    const HelloWorld = () => (
    
      <>
    
        <div>Hello</div>
    
      </>
    
    );

Would look like:

    
    
    tsx
    
    const preact_1 = require("preact");
    
    const HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,
    
        (0, preact_1.h)("div", null, "Hello")));
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdT5+VBQBzEEk0xLGW+uduHl6mmhD8UDhQJpRiMChQrkgw6kgcmnoiMWwgELL0KupouDmaxqSkoJCwcADecFwANHAB7p7wAL5w2LhwAERgRFa9ANzlRZoc8AASSEpKEADq0EqycAC8cAAUAJTrAHxbpHBwADx7R8enssAAbnszcxAn5Nd3F8-n28NAA)

This option can be used on a per-file basis too similar to [Babel‚Äôs `/*
@jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-
react-jsx#fragments).

For example:

    
    
    tsx
    
    /** @jsx h */
    
    /** @jsxFrag Fragment */
    
    ¬†
    
    import { h, Fragment } from "preact";
    
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    
    ¬†
    
    const HelloWorld = () => (
    
      <>
    
        <div>Hello</div>
    
      </>
    
    );
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3JsOPAQDEoKAOZxZCkEgB28MaVKhIsOAG9hAGiVz5qjXAC+cbLjgAiMEXQxHAbm1oIa3vAAJJAAbYIgAdWhggBM4AF44AAoASniAPiTSODgAHjSs7Nzo4AA3NKDQiBzyYrKC6vzkjyA)

  * Default:

`React.Fragment`

  * Related:
    * `jsx`

    * `jsxFactory`

    * `jsxImportSource`

  * Released:

[4.0](/docs/handbook/release-notes/typescript-4-0.html)

### # JSX Import Source - `jsxImportSource`

Declares the module specifier to be used for importing the `jsx` and `jsxs`
factory functions when using `jsx` as `"react-jsx"` or `"react-jsxdev"` which
were introduced in TypeScript 4.1.

With [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html) the library supports a new form of JSX transformation via a
separate import.

For example with this code:

    
    
    tsx
    
    import React from "react";
    
    function App() {
    
      return <h1>Hello World</h1>;
    
    }

Using this TSConfig:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx"
    
      }
    
    }

The emitted JavaScript from TypeScript is:

    
    
    tsx
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    
    const jsx_runtime_1 = require("react/jsx-runtime");
    
    function App() {
    
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggO1ogE6GyGTZjgBWkAHgFyiECmAhgMboC0NtFEyWABMArgBtmjdrGSDcNfuHStCAc2bpGzSLma0sQ5uzErmoQaImgAUgGUAGqADemUKFS50zQgDMOZxAlkZk9nAF9Xd09vP3YzAElPQg9IVHZA5mDPSGdItwBtSEZIdGTcVQBdRlZcAE8AbkiIiNRkAAdSdFAAJTZOUB8SZFAAIhYOdBHGzB8RXE5UWFxQAEE2toAKAEpctxZ0EUJlgB5oAEYAPgAJZjExWFAAdVIxIWPgc4vGsKA)

For example if you wanted to use `"jsxImportSource": "preact"`, you need a
tsconfig like:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
    
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
    
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx",
    
        "[jsxImportSource](https://www.typescriptlang.org/tsconfig#jsxImportSource)": "preact",
    
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["preact"]
    
      }
    
    }

Which generates code like:

    
    
    tsx
    
    function App() {
    
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    
    }
    
    ¬†
    
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOGwBWHAB4BJcNBgBlCPShokALjhgi6EZTEwAnmCQctO4vvaSpW3Rmq3RbGCigBzJDC1mAdkhS1mIgEAAm9AA2mnBouKF+ki5+EPxQOFAcpKSBkLBwmPR+GMAQfnAAgmBgABQAlHAA3qRwcEQwquUAPFwAjAB8ABJIkZEQcADq0JFhXeR9-QDcpAC+QA)

Alternatively, you can use a per-file pragma to set this option, for example:

    
    
    tsx
    
    /** @jsxImportSource preact */
    
    export function App() {
    
      return <h1>Hello World</h1>;
    
    }

Would add `preact/jsx-runtime` as an import for the `_jsx` factory.

_Note:_ In order for this to work like you would expect, your `tsx` file must
include an `export` or `import` so that it is considered a module.

  * Default:

`react`

  * Related:
    * `jsx`

    * `jsxFactory`

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

### # Lib - `lib`

TypeScript includes a default set of type definitions for built-in JS APIs
(like `Math`), as well as type definitions for things found in browser
environments (like `document`). TypeScript also includes APIs for newer JS
features matching the `target` you specify; for example the definition for
`Map` is available if `target` is `ES6` or newer.

You may want to change these for a few reasons:

  * Your program doesn‚Äôt run in a browser, so you don‚Äôt want the `"dom"` type definitions
  * Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn‚Äôt yet support the full syntax of a given ECMAScript version
  * You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version

In TypeScript 4.5, lib files can be overridden by npm modules, find out more
[in the blog](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-5-beta/#supporting-lib-from-node_modules).

### High Level libraries

Name | Contents  
---|---  
`ES5` | Core definitions for all ES5 functionality  
`ES2015` | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.  
`ES6` | Alias for ‚ÄúES2015‚Äù  
`ES2016` | Additional APIs available in ES2016 - `array.include`, etc.  
`ES7` | Alias for ‚ÄúES2016‚Äù  
`ES2017` | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc.  
`ES2018` | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.  
`ES2019` | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.  
`ES2020` | Additional APIs available in ES2020 - `string.matchAll`, etc.  
`ES2021` | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.  
`ES2022` | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.  
`ES2023` | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.  
`ESNext` | Additional APIs available in ESNext - This changes as the JavaScript specification evolves  
`DOM` | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.  
`WebWorker` | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts  
`ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)  
  
### Individual library components

Name  
---  
`DOM.Iterable`  
`ES2015.Core`  
`ES2015.Collection`  
`ES2015.Generator`  
`ES2015.Iterable`  
`ES2015.Promise`  
`ES2015.Proxy`  
`ES2015.Reflect`  
`ES2015.Symbol`  
`ES2015.Symbol.WellKnown`  
`ES2016.Array.Include`  
`ES2017.object`  
`ES2017.Intl`  
`ES2017.SharedMemory`  
`ES2017.String`  
`ES2017.TypedArrays`  
`ES2018.Intl`  
`ES2018.Promise`  
`ES2018.RegExp`  
`ES2019.Array`  
`ES2019.Object`  
`ES2019.String`  
`ES2019.Symbol`  
`ES2020.String`  
`ES2020.Symbol.wellknown`  
`ES2021.Promise`  
`ES2021.String`  
`ES2021.WeakRef`  
`ESNext.AsyncIterable`  
`ESNext.Array`  
`ESNext.Intl`  
`ESNext.Symbol`  
  
This list may be out of date, you can see the full list in the [TypeScript
source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).

  * Related:
    * `noLib`

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

### # Module Detection - `moduleDetection`

This setting controls how TypeScript determines whether a file is a [script or
a module](/docs/handbook/modules/theory.html#scripts-and-modules-in-
javascript).

There are three choices:

  * `"auto"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `"type"` field in a `package.json` is set to `"module"` when running with `module`: `nodenext` or `node16`, and check whether the current file is a JSX file when running under `jsx`: `react-jsx`.

  * `"legacy"` \- The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.

  * `"force"` \- Ensures that every non-declaration file is treated as a module.

  * Default:

"auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-
jsx), or esm format (with module: node16+) as modules.

  * Allowed:
    * `legacy`

    * `auto`

    * `force`

  * Released:

[4.7](/docs/handbook/release-notes/typescript-4-7.html)

### # No Lib - `noLib`

Disables the automatic inclusion of any library files. If this option is set,
`lib` is ignored.

TypeScript _cannot_ compile anything without a set of interfaces for key
primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`,
`Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you
will be including your own type definitions for these.

  * Related:
    * `lib`

### # React Namespace - `reactNamespace`

Use `jsxFactory` instead. Specify the object invoked for `createElement` when
targeting `react` for TSX files.

  * Default:

`React`

### # Target - `target`

Modern browsers support all ES6 features, so `ES6` is a good choice. You might
choose to set a lower target if your code is deployed to older environments,
or a higher target if your code is guaranteed to run in newer environments.

The `target` setting changes which JS features are downleveled and which are
left intact. For example, an arrow function `() => this` will be turned into
an equivalent `function` expression if `target` is ES5 or lower.

Changing `target` also changes the default value of `lib`. You may ‚Äúmix and
match‚Äù `target` and `lib` settings as desired, but you could just set `target`
for convenience.

For developer platforms like Node there are baselines for the `target`,
depending on the type of platform and its version. You can find a set of
community organized TSConfigs at
[tsconfig/bases](https://github.com/tsconfig/bases#centralized-
recommendations-for-tsconfig-bases), which has configurations for common
platforms and their versions.

The special `ESNext` value refers to the highest version your version of
TypeScript supports. This setting should be used with caution, since it
doesn‚Äôt mean the same thing between different TypeScript versions and can make
upgrades less predictable.

  * Default:

`ES5`

  * Allowed:
    * `es3`

    * `es5`

    * `es6`/`es2015`

    * `es2016`

    * `es2017`

    * `es2018`

    * `es2019`

    * `es2020`

    * `es2021`

    * `es2022`

    * `es2023`

    * `esnext`

  * Released:

[1.0](/docs/handbook/release-notes/typescript-1-0.html)

### # Use Define For Class Fields - `useDefineForClassFields`

This flag is used as part of migrating to the upcoming standard version of
class fields. TypeScript introduced class fields many years before it was
ratified in TC39. The latest version of the upcoming specification has a
different runtime behavior to TypeScript‚Äôs implementation but the same syntax.

This flag switches to the upcoming ECMA runtime behavior.

You can read more about the transition in [the 3.7 release
notes](/docs/handbook/release-notes/typescript-3-7.html#the-
usedefineforclassfields-flag-and-the-declare-property-modifier).

  * Default:

`true` if `target` is `ES2022` or higher, including `ESNext`; `false`
otherwise.

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

## #Compiler Diagnostics

### # Diagnostics - `diagnostics`

Used to output diagnostic information for debugging. This command is a subset
of `extendedDiagnostics` which are more user-facing results, and easier to
interpret.

If you have been asked by a TypeScript compiler engineer to give the results
using this flag in a compile, in which there is no harm in using
`extendedDiagnostics` instead.

  * Deprecated
  * Related:
    * `extendedDiagnostics`

### # Explain Files - `explainFiles`

Print names of files which TypeScript sees as a part of your project and the
reason they are part of the compilation.

For example, with this project of just a single `index.ts` file

    
    
    sh
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

Using a `tsconfig.json` which has `explainFiles` set to true:

    
    
    json
    
    {
    
      "compilerOptions": {
    
        "target": "es5",
    
        "module": "commonjs",
    
        "explainFiles": true
    
      }
    
    }

Running TypeScript against this folder would have output like this:

    
    
    ‚ùØ tsc
    
    node_modules/typescript/lib/lib.d.ts
    
      Default library for target 'es5'
    
    node_modules/typescript/lib/lib.es5.d.ts
    
      Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.dom.d.ts
    
      Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    
      Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'
    
    node_modules/typescript/lib/lib.scripthost.d.ts
    
      Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'
    
    index.ts
    
      Matched by include pattern '**/*' in 'tsconfig.json'

The output above show:

  * The initial lib.d.ts lookup based on `target`, and the chain of `.d.ts` files which are referenced
  * The `index.ts` file located via the default pattern of `include`

This option is intended for debugging how a file has become a part of your
compile.

  * Released:

[4.2](/docs/handbook/release-notes/typescript-4-2.html)

### # Extended Diagnostics - `extendedDiagnostics`

You can use this flag to discover where TypeScript is spending its time when
compiling. This is a tool used for understanding the performance
characteristics of your codebase overall.

You can learn more about how to measure and understand the output in the
performance [section of the
wiki](https://github.com/microsoft/TypeScript/wiki/Performance).

  * Related:
    * `diagnostics`

### # Generate CPU Profile - `generateCpuProfile`

This option gives you the chance to have TypeScript emit a v8 CPU profile
during the compiler run. The CPU profile can provide insight into why your
builds may be slow.

This option can only be used from the CLI via: `--generateCpuProfile tsc-
output.cpuprofile`.

    
    
    sh
    
    npm run tsc --generateCpuProfile tsc-output.cpuprofile

This file can be opened in a chromium based browser like Chrome or Edge
Developer in [the CPU
profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-
tools/js-execution) section. You can learn more about understanding the
compilers performance in the [TypeScript wiki section on
performance](https://github.com/microsoft/TypeScript/wiki/Performance).

  * Default:

`profile.cpuprofile`

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

### # generateTrace - `generateTrace`

Generates an event trace and a list of types.

### # List Emitted Files - `listEmittedFiles`

Print names of generated files part of the compilation to the terminal.

This flag is useful in two cases:

  * You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.
  * You are not sure that TypeScript has included a file you expected, as a part of debugging the file inclusion settings.

For example:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
    
        "[listEmittedFiles](https://www.typescriptlang.org/tsconfig#listEmittedFiles)": true
    
      }
    
    }

Would echo paths like:

    
    
    $ npm run tsc
    
    path/to/example/index.js
    
    path/to/example/index.d.ts

Normally, TypeScript would return silently on success.

### # List Files - `listFiles`

Print names of files part of the compilation. This is useful when you are not
sure that TypeScript has included a file you expected.

For example:

    
    
    example
    
    ‚îú‚îÄ‚îÄ index.ts
    
    ‚îú‚îÄ‚îÄ package.json
    
    ‚îî‚îÄ‚îÄ tsconfig.json

With:

    
    
    {
    
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
    
        "[listFiles](https://www.typescriptlang.org/tsconfig#listFiles)": true
    
      }
    
    }

Would echo paths like:

    
    
    $ npm run tsc
    
    path/to/example/node_modules/typescript/lib/lib.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.es5.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.dom.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    
    path/to/example/node_modules/typescript/lib/lib.scripthost.d.ts
    
    path/to/example/index.ts

Note if using TypeScript 4.2, prefer `explainFiles` which offers an
explanation of why a file was added too.

  * Related:
    * `explainFiles`

### # noCheck - `noCheck`

Disable full type checking (only critical parse and emit errors will be
reported).

### # Trace Resolution - `traceResolution`

When you are trying to debug why a module isn‚Äôt being included. You can set
`traceResolution` to `true` to have TypeScript print information about its
resolution process for each processed file.

  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

## #Projects

### # Composite - `composite`

The `composite` option enforces certain constraints which make it possible for
build tools (including TypeScript itself, under `--build` mode) to quickly
determine if a project has been built yet.

When this setting is on:

  * The `rootDir` setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.

  * All implementation files must be matched by an `include` pattern or listed in the `files` array. If this constraint is violated, `tsc` will inform you which files weren‚Äôt specified.

  * `declaration` defaults to `true`

You can find documentation on TypeScript projects in [the
handbook](https://www.typescriptlang.org/docs/handbook/project-
references.html).

  * Related:
    * `incremental`

    * `tsBuildInfoFile`

  * Released:

[3.0](/docs/handbook/release-notes/typescript-3-0.html)

### # Disable Referenced Project Load - `disableReferencedProjectLoad`

In multi-project TypeScript programs, TypeScript will load all of the
available projects into memory in order to provide accurate results for editor
responses which require a full knowledge graph like ‚ÄòFind All References‚Äô.

If your project is large, you can use the flag `disableReferencedProjectLoad`
to disable the automatic loading of all projects. Instead, projects are loaded
dynamically as you open files through your editor.

  * Released:

[4.0](/docs/handbook/release-notes/typescript-4-0.html)

### # Disable Solution Searching - `disableSolutionSearching`

When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to declare that you do not want a
project to be included when using features like _find all references_ or _jump
to definition_ in an editor.

This flag is something you can use to increase responsiveness in large
composite projects.

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Disable Source Project Reference Redirect -
`disableSourceOfProjectReferenceRedirect`

When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to go [back to the
pre-3.7](/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-
with-project-references) behavior where d.ts files were used to as the
boundaries between modules. In 3.7 the source of truth is now your TypeScript
files.

  * Released:

[3.7](/docs/handbook/release-notes/typescript-3-7.html)

### # Incremental - `incremental`

Tells TypeScript to save information about the project graph from the last
compilation to files stored on disk. This creates a series of `.tsbuildinfo`
files in the same folder as your compilation output. They are not used by your
JavaScript at runtime and can be safely deleted. You can read more about the
flag in the [3.4 release notes](/docs/handbook/release-
notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-
flag).

To control which folders you want to the files to be built to, use the config
option `tsBuildInfoFile`.

  * Default:

`true` if `composite`; `false` otherwise.

  * Related:
    * `composite`

    * `tsBuildInfoFile`

  * Released:

[3.4](/docs/handbook/release-notes/typescript-3-4.html)

### # TS Build Info File - `tsBuildInfoFile`

This setting lets you specify a file for storing incremental compilation
information as a part of composite projects which enables faster building of
larger TypeScript codebases. You can read more about composite projects [in
the handbook](/docs/handbook/project-references.html).

The default depends on a combination of other settings:

  * If `outFile` is set, the default is `<outFile>.tsbuildinfo`.
  * If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.
  * If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`
  * Otherwise, the default is `<config name>.tsbuildInfo`

  * Default:

`.tsbuildinfo`

  * Related:
    * `incremental`

    * `composite`

  * Released:

[3.4](/docs/handbook/release-notes/typescript-3-4.html)

## #Output Formatting

### # No Error Truncation - `noErrorTruncation`

Do not truncate error messages.

With `false`, the default.

    
    
    ts
    
    var x: {
    
      propertyWithAnExceedinglyLongName1: string;
    
      propertyWithAnExceedinglyLongName2: string;
    
      propertyWithAnExceedinglyLongName3: string;
    
      propertyWithAnExceedinglyLongName4: string;
    
      propertyWithAnExceedinglyLongName5: string;
    
      propertyWithAnExceedinglyLongName6: string;
    
      propertyWithAnExceedinglyLongName7: string;
    
      propertyWithAnExceedinglyLongName8: string;
    
    };
    
    ¬†
    
    // String representation of type of 'x' should be truncated in error message
    
    var s: string = x;
    
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQAbgIbSgAeqA3kaKAA7xMwAuAngOoCW7ACwCCAOwCiVAMaRIAE14iA5gBtOAGThKAcmQC2kAIypE7aAsUBuBs1Yce-YeKkz5S1Ru17IaY6fNXGFjg2aC4+QVEJaTlzd01FHX0MXzMlAJtgu3DHKJdY9XjEyFwU-2sgkLCHSOcYtwLPfXxStPLbUPsIp2jXFQaErwA2Fss2zI7smp78jwH9AHYR9Iqs6u68+tmigA4logBfKyIQUABlPyVQaEgWSERIEXYydl5NUDgAM1AuNnevgHIqP9QIgBHAAK7KWSgABGkG+0HBIkkzzkoAUoBg8Eo+kQiDIikgpAoIJGoAAvNQLEA)

With `true`

    
    
    ts
    
    var x: {
    
      propertyWithAnExceedinglyLongName1: string;
    
      propertyWithAnExceedinglyLongName2: string;
    
      propertyWithAnExceedinglyLongName3: string;
    
      propertyWithAnExceedinglyLongName4: string;
    
      propertyWithAnExceedinglyLongName5: string;
    
      propertyWithAnExceedinglyLongName6: string;
    
      propertyWithAnExceedinglyLongName7: string;
    
      propertyWithAnExceedinglyLongName8: string;
    
    };
    
    ¬†
    
    // String representation of type of 'x' should be truncated in error message
    
    var s: string = x;
    
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQIEAdnAKKwIAq0ArmQMYCGALgJZxmruOQiAN1bRQAD1QBvIqFAAHePJjsAngHVO7ABYBBMpXHNIkACacyAcwA2qgDI9LAOVYBbSAEZUifhcsBuWQUlFQ0tPQMjE3MrWwcrF3c0b18rQLlFOGVoNU0dfUNjMz84x0TIDBToP3TgrNC8iMLokvsyt0hcKpqgzOzc8IKo4ti2hI78brTekJyw-MiimJsx5w6ANimAmfq5xqGl1vi19wB2Ldq+hsHFltHj8oAOC6IAX0CSMABlVMtQaEgikgiEgZHYHG4ZFAcAAZqA1MpoXCAOTiZGgRDaOAMaymUAAI0g8MYLA4ZlAFlAMHgYnciEQrEsghEYhQGN+oAAvBJ-EA)

### # Preserve Watch Output - `preserveWatchOutput`

Whether to keep outdated console output in watch mode instead of clearing the
screen every time a change happened.

  * Internal

### # Pretty - `pretty`

Stylize errors and messages using color and context, this is on by default ‚Äî
offers you a chance to have less terse, single colored messages from the
compiler.

  * Default:

`true`

## #Completeness

### # Skip Default Lib Check - `skipDefaultLibCheck`

Use `skipLibCheck` instead. Skip type checking of default library declaration
files.

### # Skip Lib Check - `skipLibCheck`

Skip type checking of declaration files.

This can save time during compilation at the expense of type-system accuracy.
For example, two libraries could define two copies of the same `type` in an
inconsistent way. Rather than doing a full check of all `d.ts` files,
TypeScript will type check the code you specifically refer to in your app‚Äôs
source code.

A common case where you might think to use `skipLibCheck` is when there are
two copies of a library‚Äôs types in your `node_modules`. In these cases, you
should consider using a feature like [yarn‚Äôs
resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/)
to ensure there is only one copy of that dependency in your tree or
investigate how to ensure there is only one copy by understanding the
dependency resolution to fix the issue without additional tooling.

Another possibility is when you are migrating between TypeScript releases and
the changes cause breakages in node_modules and the JS standard libraries
which you do not want to deal with during the TypeScript update.

Note, that if these issues come from the TypeScript standard library you can
replace the library using [TypeScript 4.5‚Äôs lib
replacement](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.

  * Recommended
  * Released:

[2.0](/docs/handbook/release-notes/typescript-2-0.html)

## #Command Line

## #Watch Options

TypeScript 3.8 shipped a new strategy for watching directories, which is
crucial for efficiently picking up changes to `node_modules`.

On operating systems like Linux, TypeScript installs directory watchers (as
opposed to file watchers) on `node_modules` and many of its subdirectories to
detect changes in dependencies. This is because the number of available file
watchers is often eclipsed by the number of files in `node_modules`, whereas
there are way fewer directories to track.

Because every project might work better under different strategies, and this
new approach might not work well for your workflows, TypeScript 3.8 introduces
a new `watchOptions` field which allows users to tell the compiler/language
service which watching strategies should be used to keep track of files and
directories.

### # Assume Changes Only Affect Direct Dependencies -
`assumeChangesOnlyAffectDirectDependencies`

When this option is enabled, TypeScript will avoid rechecking/rebuilding all
truly possibly-affected files, and only recheck/rebuild files that have
changed as well as files that directly import them.

This can be considered a ‚Äòfast & loose‚Äô implementation of the watching
algorithm, which can drastically reduce incremental rebuild times at the
expense of having to run the full build occasionally to get all compiler error
messages.

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

## Watch Options

You can configure the how TypeScript `--watch` works. This section is mainly
for handling case where `fs.watch` and `fs.watchFile` have additional
constraints like on Linux. You can read more at [Configuring
Watch](/docs/handbook/configuring-watch.html).

### # Watch File - `watchFile`

The strategy for how individual files are watched.

  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for file changes.
  * `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system‚Äôs native events to listen for changes on a file‚Äôs parent directory

  * Allowed:
    * `fixedpollinginterval`

    * `prioritypollinginterval`

    * `dynamicprioritypolling`

    * `fixedchunksizepolling`

    * `usefsevents`

    * `usefseventsonparentdirectory`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Watch Directory - `watchDirectory`

The strategy for how entire directory trees are watched under systems that
lack recursive file-watching functionality.

  * `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for directory changes.

  * Allowed:
    * `usefsevents`

    * `fixedpollinginterval`

    * `dynamicprioritypolling`

    * `fixedchunksizepolling`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Fallback Polling - `fallbackPolling`

When using file system events, this option specifies the polling strategy that
gets used when the system runs out of native file watchers and/or doesn‚Äôt
support native file watchers.

  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.

  * Allowed:
    * `fixedinterval`

    * `priorityinterval`

    * `dynamicpriority`

    * `fixedchunksize`

  * Released:

[3.8](/docs/handbook/release-notes/typescript-3-8.html)

### # Synchronous Watch Directory - `synchronousWatchDirectory`

Synchronously call callbacks and update the state of directory watchers on
platforms that don`t support recursive watching natively. Instead of giving a
small timeout to allow for potentially multiple edits to occur on a file.

    
    
    {
    
      "watchOptions": {
    
        "[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory)": true
    
      }
    
    }

### # Exclude Directories - `excludeDirectories`

You can use `excludeFiles` to drastically reduce the number of files which are
watched during `--watch`. This can be a useful way to reduce the number of
open file which TypeScript tracks on Linux.

    
    
    {
    
      "watchOptions": {
    
        "[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories)": ["**/node_modules", "_build", "temp/*"]
    
      }
    
    }

### # Exclude Files - `excludeFiles`

You can use `excludeFiles` to remove a set of specific files from the files
which are watched.

    
    
    {
    
      "watchOptions": {
    
        "[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles)": ["temp/file.ts"]
    
      }
    
    }

## Type Acquisition

Type Acquisition is only important for JavaScript projects. In TypeScript
projects you need to include the types in your projects explicitly. However,
for JavaScript projects, the TypeScript tooling will download types for your
modules in the background and outside of your node_modules folder.

### # Enable - `enable`

Disables automatic type acquisition in JavaScript projects:

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "enable": false
    
      }
    
    }

### # Include - `include`

If you have a JavaScript project where TypeScript needs additional guidance to
understand global dependencies, or have disabled the built-in inference via
`disableFilenameBasedTypeAcquisition`.

You can use `include` to specify which types should be used from
DefinitelyTyped:

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "include": ["jquery"]
    
      }
    
    }

### # Exclude - `exclude`

Offers a config for disabling the type-acquisition for a certain module in
JavaScript projects. This can be useful for projects which include other
libraries in testing infrastructure which aren‚Äôt needed in the main
application.

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "exclude": ["jest", "mocha"]
    
      }
    
    }

### # Disable Filename Based Type Acquisition -
`disableFilenameBasedTypeAcquisition`

TypeScript‚Äôs type acquisition can infer what types should be added based on
filenames in a project. This means that having a file like `jquery.js` in your
project would automatically download the types for JQuery from
DefinitelyTyped.

You can disable this via `disableFilenameBasedTypeAcquisition`.

    
    
    json
    
    {
    
      "typeAcquisition": {
    
        "disableFilenameBasedTypeAcquisition": true
    
      }
    
    }

  * Released:

[4.1](/docs/handbook/release-notes/typescript-4-1.html)

 TypeScript is a language from Microsoft which builds on JavaScript.  
This post is a non-technical overview of what JavaScript is, how TypeScript
extends JavaScript and what problems it solves.

## What is JavaScript?

Because TypeScript extends JavaScript, this makes it a good starting point.
JavaScript is commonly used to create websites. When building a website, you
work with three languages: HTML, CSS and JavaScript (JS). Broadly speaking:
HTML defines the content which will appear on the page, CSS defines the visual
style of the page, and JS defines the interactive behaviors of the page.

We describe having these sets of skills as being a "front-end" developer. You
use three languages to create pages inside a web browser like Safari, Firefox,
Edge or Chrome. Given how popular the web is for commerce and information
sharing, there is a massive demand for people who are good at using these
three languages.

Related to the role of being a "front-end" developer is the set of skills for
the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another
service (by sending data more directly.) You don't need to use HTML, CSS or JS
to write this type of code, but it's usually an end-product of your work
because it is likely to be presented in a web browser.

### What do Programming Languages do?

Programming languages are a way for humans and computers to communicate.
People read code many, many multiples of times more than they write it - so
developers create programming languages which are good at solving particular
problems with a small amount of code. Here's an example using JavaScript:

    
    
    var name = "Danger"
    console.log("Hello, " + name)

The first line makes a variable (effectively a box you can store other things
in) and then the second line outputs text to the console (for example DOS, or
the terminal) `"Hello, Danger"`.

JavaScript is designed to work as a scripting language, which means the code
starts at the top of the file and then goes through line by line downwards
running that code. To provide some contrast, here is the same behavior in
Java, which is built with different language constraints:

    
    
    class Main {
      public static void main(String[] args) {
        String name = "Danger";
        System.out.println("Hello, " + name);
      }
    }

These two code samples do the same thing, however the Java version comes with
a lot of words that aren't necessarily about telling the computer exactly what
to do, e.g. `class Main {`, `public static void main(String[] args) {`, and
two extra `}`s. It also has semi-colons at the end of some lines. Neither of
these programming languages are wrong, Java however, is aimed at building
different things from JavaScript, and these extra bits of code make sense
within the constraints of building a Java app.

To get to the key point though, there is one standout line I'd like us to
compare:

    
    
    // JavaScript
    var name = "Danger"
    
    // Java
    String name = "Danger";

Both of these lines declare variables called `name` which contain the value
`"Danger"`.

In JavaScript you use the abbreviation `var` to declare a variable. Meanwhile,
in Java you need to say _what kind of data_ the variable contains. In this
case the variable contains a `String`. (A string is a programming term for a
collection of characters. They `"look like this"`. This [5m
video](https://www.youtube.com/watch?v=czTWbdwbt7E) is a good primer if you
want to learn more.)

Both of these variables contain a string, but the difference is that in Java
the variable can _only_ ever contain a _string_ , because that's what we said
when we created the variable. In JS, the variable can change to be _anything_
, like a number, or a list of dates.

To illustrate:

    
    
    // Before in JS
    var name = "Danger"
    // Also OK
    var name = 1
    var name = false
    var name = ["2018-02-03", "2019-01-12"]
    
    // Before in Java
    String name = "Danger";
    // Not OK, the code wouldn't be accepted by Java
    String name = 1;
    String name = false
    String name = new String[]{"2018-02-03", "2019-01-12"};

These trade-offs make sense in the context for which these languages were
built back in 1995. JavaScript was originally designed to be a small
programming language which handled simple interactions on websites. Java on
the other hand was built specifically to make complex apps which could run on
any computer. They expected to be used to build codebases of different scales,
so the language required programmers write different types of code.

Java required programmers to be more explicit with the values of their
variables because the programs they expected people to build were more
complex. While JavaScript opted for ease of reading by omitting information
about the specifics, and expected codebases to be significantly smaller.

### What is TypeScript?

TypeScript is a programming language - it contains all of JavaScript, and then
a bit more. Using our example above, let's compare the scripts for "Hello,
Danger" in JavaScript vs TypeScript:

    
    
    // JavaScript
    var name = "Danger"
    console.log("Hello, " + name)
    
    // TypeScript
    var name = "Danger"
    console.log("Hello, " + name)
    
    // Yep, you're not missing something, there's no difference

Due to TypeScript's goal of only _extending_ JavaScript, the existing
JavaScript code we saw works as TypeScript. The extensions which TypeScript
adds to JavaScript are intended to help you be more explicit about what kinds
of data are used in your code, a bit like Java.

Here is the same sample, but using TypeScript to be more explicit about what
the variable is:

    
    
    var name: string = "Danger"
    console.log("Hello, " + name)

This extra `: string` allow the reader to be certain that `name` will only be
a string. Annotating your variables in this way also gives TypeScript the
chance to verify that these match. This is _very_ useful, because keeping
track of changes like the type of value in a variable seems easy when it's one
or two, but once it starts hitting the hundreds, that's a lot to keep track
of. Writing types help programmers be more confident about their code because
types catch mistakes.

Simply speaking, we call these annotations "Types". Hence the name _Type_
Script. One of the tag-lines for TypeScript is "JavaScript which scales" which
is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is.
This means you have less need to understand how every change affects the rest
of the program.

In the 90s, and maybe until a 5-10 years ago the trade-off for not having
types in your JavaScript application was fine because the size and
complexities of the programs being built were constrained to just the front-
end of websites. Today though, JavaScript is being used almost everywhere, to
build almost anything which runs on a computer. A large amount of mobile and
desktop apps use JavaScript and web technology under the hood.

These are all considerably more complicated to build and understand, adding
types drastically reduces the complexity of making improvements to those
programs.

### What Problems Can TypeScript Solve?

Typically, the need to ensure there are no bugs in your code can be handled by
writing automated tests, then by manually verifying that the code works as you
expect and finally having another person validate that it seems correct.

Not many companies are the size of Microsoft, however a lot of all problems
writing JavaScript in large codebases are the same. Many JavaScript apps are
made up of hundreds of thousands of files. A single change to one individual
file can affect the behaviour of any number of other files, like throwing a
pebble into a pond and causing ripples to spread out to the bank.

Validating the connections between every part of your project can get time
consuming quickly, using a type-checked language like TypeScript can handle
that automatically and provide instant feedback during development.

These features allows TypeScript to help developers feel more confident in
their code, and save considerable amounts time in validating that they have
not accidentally broken the project.