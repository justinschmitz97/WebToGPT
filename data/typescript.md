Domain: https://www.typescriptlang.org
Timestamp: 2024-09-21T20:56:03.796840

# TypeScript is **JavaScript with syntax for types.**
TypeScript is a strongly typed programming language that builds on JavaScript,
giving you better tooling at any scale.
[Try TypeScript NowOnline or via npm](/download)
  * Editor Checks
  * Auto-complete
  * Interfaces
  * JSX
    ts
    const user = {
      firstName: "Angela",
      lastName: "Davis",
      role: "Professor",
    }
    console.log(user.name)
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    ts
    const user = {
      firstName: "Angela",
      lastName: "Davis",
      role: "Professor",
    }
    console.log(user.name)
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
[TypeScript 5.6](https://devblogs.microsoft.com/typescript/announcing-
typescript-5-6/) is now available
## What is TypeScript?
### JavaScript and More
TypeScript adds additional syntax to JavaScript to support a **tighter
integration with your editor**. Catch errors early in your editor.
### A Result You Can Trust
TypeScript code converts to JavaScript, which **runs anywhere JavaScript
runs** : In a browser, on Node.js or Deno and in your apps.
### Safety at Scale
TypeScript understands JavaScript and uses **type inference to give you great
tooling** without additional code.
## Get Started
[HandbookLearn the language](/docs/handbook/intro.html)
[PlaygroundTry in your browser](/play)
[DownloadInstall TypeScript](/download/)
## Adopt TypeScript Gradually
Apply types to your JavaScript project incrementally, **each step improves
editor support** and improves your codebase.
Let's take this incorrect JavaScript code, and see how **TypeScript can catch
mistakes in your editor**.
    js
    function compact(arr) {
        if (orr.length > 10)
            return arr.trim(0, 10)
        return arr
    }
No editor warnings in JavaScript files  
This code crashes at runtime!
JavaScript file
    js
    // @ts-check
    function compact(arr) {
      if (orr.length > 10)
    Cannot find name 'orr'.2304Cannot find name 'orr'.
        return arr.trim(0, 10)
      return arr
    }
Adding this to a JS file shows errors in your editor
the param is arr, not orr!
JavaScript with TS Check
    js
    // @ts-check
    /** @param {any[]} arr */
    function compact(arr) {
        if (arr.length > 10)
          return arr.trim(0, 10)
    Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.
        return arr
      }
Using JSDoc to give type information
Now TS has found a bad call. Arrays have slice, not trim.
JavaScript with JSDoc
    ts
    function compact(arr: string[]) {
      if (arr.length > 10)
        return arr.slice(0, 10)
      return arr
    }
TypeScript adds natural syntax for providing types
TypeScript file
### Describe Your Data
**Describe the shape of objects and functions** in your code.
Making it possible to see **documentation and issues in your editor**.
    ts
    interface Account {
      id: number
      displayName: string
      version: 1
    }
    function welcome(user: Account) {
      console.log(user.id)
    }
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
## TypeScript becomes JavaScript via the delete key.
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**TypeScript file**.
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**Types are removed**.
    js
    function verify(result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**JavaScript file**.
## TypeScript Testimonials
**First** , we were surprised by the number of small bugs we found when
converting our code.
**Second** , we underestimated how powerful the editor integration is.
TypeScript was such a boon to our stability and sanity that we started using
it for all new code within days of starting the conversion.
Felix Rieseberg at Slack covered the transition of their desktop app from
JavaScript to TypeScript in their blog
[Read](https://slack.engineering/typescript-at-slack-a81307fa288d)
### Open Source with TypeScript
[Angular](https://angular.io/)[Vue](https://vuejs.org/)[Jest](https://jestjs.io/)[Redux](https://redux.js.org/)[Ionic](https://ionicframework.com/)[Probot](https://probot.github.io/)[Deno](https://deno.land/)[Vercel](https://github.com/vercel/vercel)[Yarn](https://yarnpkg.com/)[GitHub  
Desktop](https://github.com/desktop/desktop/)
## Loved by Developers
Voted **2nd most loved programming language** in the [Stack Overflow 2020
Developer survey](https://insights.stackoverflow.com/survey/2020#most-loved-
dreaded-and-wanted)
TypeScript was **used by 78%** of the [2020 State of
JS](https://2020.stateofjs.com/en-US/technologies/javascript-flavors/)
respondents, with **93% saying they would use it again**.
TypeScript was given the award for **‚ÄúMost Adopted Technology‚Äù** based on
year-on-year growth.
## Get Started
[HandbookLearn the language](/docs/handbook/intro.html)
[PlaygroundTry in your browser](/play)
[DownloadInstall TypeScript](/download/)

# Branding
## Logos and design assets for TypeScript
[Click to download
the asset pack](/branding/typescript-design-assets.zip)
## Recommendations
Please use the blue TypeScript mark above as the primary logo for TypeScript.
This is the right logo for blog posts, news articles, giveaway stickers and
general marketing for yourself.
The ‚ÄúTS‚Äù in the logo is white, not transparent by default.
There is a capital ‚ÄúS‚Äù in TypeScript, just like in JavaScript.
## Alternatives
[](/branding/typescript-design-assets.zip "Download the design
assets")
Single color variant which has the ‚ÄúTS‚Äù cut out, useful for when you need a
single color design.
[](/branding/typescript-design-
assets.zip "Download the design assets")
Full lettermark version of the TypeScript logo.
## Palette
[](/branding/typescript-design-assets.zip
"Download the design assets")
[](/branding/typescript-design-
assets.zip "Download the design assets")
## Please Don't
Use the TypeScript logos for your application/product.
Modify the shape of the logos when used.
Integrate the TypeScript logo into your application's logo.
Name a product which implies TypeScript's endorsement of the product.
## TypeScript Cheat Sheets
Downloadable syntax reference pages for different parts of everyday TypeScript
code
Learn more about Classes, Interfaces, Types and Control Flow Analysis
[Control Flow
Analysis](/static/TypeScript Control Flow
Analysis-8a549253ad8470850b77c4c5c351d457.png "Control Flow Analysis Cheat
Sheets")[Interfaces](/static/TypeScript
Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png "Interfaces Cheat
Sheets")[Types](/static/TypeScript Types-
ae199d69aeecf7d4a2704a528d0fd3f9.png "Types Cheat Sheets")[Classes](/static/TypeScript
Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png "Classes Cheat Sheets")
[Download PDFs and PNGsTo read later or print](/assets/typescript-cheat-
sheets.zip)
# Connect with us
## Online
Tell us what‚Äôs working well, what you want to see added or improved, and find
out about new updates.
### [Stack Overflow](https://stackoverflow.com/questions/tagged/typescript
"TypeScript tag on Stack Overflow")Engage with your peers and ask questions
about TypeScript using the tag 'typescript'
### [Chat](https://discord.gg/typescript "TypeScript Community on
Discord")Chat with other TypeScript users in the TypeScript Community Chat.
### [GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create
a new GitHub Issue on the TypeScript repo")Found a bug, or want to give us
constructive feedback? [Tell us on
GitHub](https://github.com/microsoft/TypeScript/issues/new/choose "Create a
new GitHub Issue on the TypeScript repo")
### [Twitter](https://twitter.com/typescript "The TypeScript team on
Twitter")Stay up to date. Follow us on Twitter
[@typescript](https://twitter.com/typescript "The TypeScript team on
Twitter")!
### [Blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")Learn about the latest TypeScript developments via our
[blog](https://devblogs.microsoft.com/typescript/ "The official TypeScript
blog")!
### [Definitely
Typed](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type
definitions")TypeScript definition files. [Browse the thousands
of](https://github.com/definitelytyped/definitelytyped/#definitelytyped
"Definitely Typed, a central location for third party type definitions")
available for common libraries and frameworks.
## Connect in person
ConferencesUpcoming EventsMeetups
### Conferences
[](https://tsconf.eu "Link to
TSConf:EU")#### [TSConf:EU](https://tsconf.eu)
Linz Austria  
March 31st, 2020
## Conferences
Hello
### Meetups
#### Boston TypeScript Club
üá∫üá∏  
[Website](https://bostonts.club "Website for Boston TypeScript Club")
#### Hamburg TypeScript
üá©üá™  
[Website](https://www.meetup.com/Hamburg-TypeScript-Meetup-Group "Website for
Hamburg TypeScript")
#### Krakow TypeScript User Group
üáµüá±  
[Website](https://www.meetup.com/typescript-krakow "Website for Krakow
TypeScript User Group")
#### Melbourne TypeScript
üá¶üá∫  
[Website](https://www.meetup.com/Melbourne-TypeScript-Meetup "Website for
Melbourne TypeScript")
#### Milano TS
üáÆüáπ  
[Website](https://www.meetup.com/MilanoTS/ "Website for Milano TS")
[Twitter](https://twitter.com/Milano_TS "Twitter page for Milano TS")
#### Seattle TypeScript
üá∫üá∏  
[Website](https://www.meetup.com/seattle-ts "Website for Seattle TypeScript")
#### Sevilla TypeScript
üá™üá∏  
[Website](https://www.meetup.com/Sevilla-TypeScript "Website for Sevilla
TypeScript") [Twitter](https://twitter.com/SVQTypeScript "Twitter page for
Sevilla TypeScript")
#### San Francisco TypeScript Meetup
üá∫üá∏  
[Website](https://www.meetup.com/San-Francisco-TypeScript-Meetup "Website for
San Francisco TypeScript Meetup")
#### Sydney TypeScript
üá¶üá∫  
[Website](https://www.meetup.com/Sydney-TypeScript "Website for Sydney
TypeScript") [Twitter](https://twitter.com/SydTypeScript "Twitter page for
Sydney TypeScript")
#### TypeScript NYC
üá∫üá∏  
[Website](https://www.meetup.com/NYC-Typescript "Website for TypeScript NYC")
#### TypeScript Brazil Meetup
üáßüá∑  
[Website](https://www.meetup.com/typescriptbr "Website for TypeScript Brazil
Meetup") [Twitter](https://twitter.com/tsbrmeetup "Twitter page for TypeScript
Brazil Meetup")
#### TypeScript JP
üáØüáµ  
[Website](https://typescript-jp.dev "Website for TypeScript JP")
[Twitter](https://twitter.com/typescriptjp "Twitter page for TypeScript JP")
#### Paris TypeScript
üá´üá∑  
[Website](https://www.meetup.com/Paris-Typescript "Website for Paris
TypeScript") [Twitter](https://twitter.com/ParisTypeScript "Twitter page for
Paris TypeScript")
#### Phoenix TypeScript
üá∫üá∏  
[Website](https://www.meetup.com/Phoenix-TypeScript "Website for Phoenix
TypeScript")
#### Wroclaw TypeScript
üáµüá±  
[Website](https://typescript.community/ "Website for Wroclaw TypeScript")
[Twitter](https://twitter.com/WrocTypeScript "Twitter page for Wroclaw
TypeScript")
Downloading TypeScript...
  * Version...... 
  * ‚á•

# Your toys, our sandbox
The new TypeScript Playground allows people to hook into the Playground and
extend it in ways in which the TypeScript team don't expect.
The sidebar of the Playground uses the same plugin infrastructure as external
plugins, so you have the same level of access as the playground to build
interesting projects.
Playground plugins are built via the DOM API and an expansive Design System,
however, you're free to use a framework like React or Svelte at runtime.
Getting started is easy, we have a plugin template, and the Playground has a
dev-mode for hooking directly to your local server, so you don't need to run a
copy of the TypeScript website to have a working development environment.
There is a repo of sample plugins at [microsoft/TypeScript-Playground-
Samples](https://github.com/microsoft/TypeScript-Playground-Samples/) and
there are many existing open source plugins to look at too: [Presentation
Mode](https://github.com/orta/playground-slides),
[Clippy](https://github.com/orta/playground-clippy#playground-plugin-clippy)
[TSQuery](https://github.com/orta/playground-plugin-tsquery),
[Collaborate](https://github.com/orta/playground-collaborate#typescript-
playground-collaborate) and [Transformer](https://github.com/orta/playground-
transformer-timeline) which are available by default for you to investigate
and understand.
If you have questions as you are working on your plugin, ask in the
[TypeScript Community Discord](https://discord.gg/typescript). When it is
polished, ship it to the npm registry and it will make its way into the
plugins sidebar.
## Quick Tutorial
You need about 5 minutes, Node.js, yarn and Firefox/Edge or Chrome.
**Step 1** : Use the template to bootstrap: `yarn create typescript-
playground-plugin playground-my-plugin`
**Step 2** : Run `yarn start` in the new repo, to start up the local dev
server
**Step 3** : Open the [playground](/play/) in your browser, click "Options"
and enable `"Connect to localhost:5000/index.js"`
**Step 4** : Refresh, and see the new tab. That's your plugin up and running
That's all the pieces working in tandem, now you can make changes to the
template and build out your plugin. The plugin in dev mode will always become
forefront when connected, so you can re-load without a lot of clicks. To
understand the template's technology, read the
[CONTRIBUTING.md](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/create-typescript-playground-
plugin/template/CONTRIBUTING.md)
## Alternatives
There are community-run templates for Playground plugins which bootstrap your
plugin with well-known view libraries:
  * [gojutin/typescript-playground-plugin-react](https://github.com/gojutin/typescript-playground-plugin-react#typescript-playground-plugin-react)
  * [gojutin/typescript-playground-plugin-svelte](https://github.com/gojutin/typescript-playground-plugin-svelte#typescript-playground-plugin-svelte)
They have their own up-to-date documentation in their READMEs.
# TypeScript Sandbox
A DOM library for interacting with TypeScript and JavaScript code, which
powers the heart of the [TypeScript playground](/play/)
You can use the TypeScript sandbox for:
  * Building IDE-like experiences for people to explore your library's API
  * Building interactive web tools which use TypeScript, with a lot of the Playgrounds developer experience for free
For example, the sandbox to the side has grabbed the Types for
[DangerJS](https://danger.systems/js/) with no modifications for this code
sample. This is because the Playground's Automatic Type Acquisition is enabled
by default. It will also look for the same parameters for code, and selection
indexes inside the URL.
Try clicking [this
URL](?q=1#code/PTAEBUAsFMGdtAYwPYFtXQHYBdagO7QBOCiJAhttACagCWmo2MEAngA7QDKZd72oAAoAbcqwDmRZAFdM1AFAhQ5OUxiNmCAKoAlADKhI5WJALGkydnRqhkAN2JNkahJmj5QuvfMVgodPAwVPBVWUHYpACtoRAFpWAZxNk4eIj4BWBVqACNkAA84JBVfUGhjOmEw+FUUagRyKVlabGcyxFNkTSJQHxRMWAEYYWFnAF5QACIACWhh5wB1ZCJhagn5PthkYWgAOhHxAAohkYBKIA)
to see that in action.
This library builds on top of the [Monaco
Editor](https://microsoft.github.io/monaco-editor/index.html), providing a
higher level API but offering access to all the lower-level APIs via a single
`sandbox` object.
You can find the code for the TypeScript Sandbox inside the
[microsoft/TypeScript-Website](https://github.com/microsoft/TypeScript-
Website/tree/v2/packages/sandbox#@typescript/sandbox) mono-repo.
Downloading Sandbox...
## Usage
A sandbox uses the same tools as monaco-editor, meaning this library is
shipped as an AMD bundle which you can use the [VSCode
Loader](https://github.com/microsoft/vscode-loader/) to `require`.
Because we need it for the TypeScript website, you can use our hosted copy
[here.](https://typescriptlang.org/js/vs.loader.js "Link to the JS for the
visual studio require loader")
### Get Started
Create a new file: `index.html` and paste this code into that file.
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
      </head>
      <div id="loader">Loading...</div>
      <div id="monaco-editor-embed" style="height: 800px;" />
      <script>
        // First set up the VSCode loader in a script tag
        const getLoaderScript = document.createElement('script')
        getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'
        getLoaderScript.async = true
        getLoaderScript.onload = () => {
          // Now the loader is ready, tell require where it can get the version of monaco, and the sandbox
          // This version uses the latest version of the sandbox, which is used on the TypeScript website
          // For the monaco version you can use unpkg or the TypeSCript web infra CDN
          // You can see the available releases for TypeScript here:
          // https://playgroundcdn.typescriptlang.org/indexes/releases.json
          //
          require.config({
            paths: {
              vs: 'https://playgroundcdn.typescriptlang.org/cdn/4.0.5/monaco/min/vs',
              // vs: 'https://unpkg.com/@typescript-deploys/monaco-editor@4.0.5/min/vs',
              sandbox: 'https://www.typescriptlang.org/js/sandbox',
            },
            // This is something you need for monaco to work
            ignoreDuplicateModules: ['vs/editor/editor.main'],
          })
          // Grab a copy of monaco, TypeScript and the sandbox
          require(['vs/editor/editor.main', 'vs/language/typescript/tsWorker', 'sandbox/index'], (
            main,
            _tsWorker,
            sandboxFactory
          ) => {
            const initialCode = `import {markdown, danger} from "danger"
    export default async function () {
        // Check for new @types in devDependencies
        const packageJSONDiff = await danger.git.JSONDiffForFile("package.json")
        const newDeps = packageJSONDiff.devDependencies.added
        const newTypesDeps = newDeps?.filter(d => d.includes("@types")) ?? []
        if (newTypesDeps.length){
            markdown("Added new types packages " + newTypesDeps.join(", "))
        }
    }
    `
            const isOK = main && window.ts && sandboxFactory
            if (isOK) {
              document.getElementById('loader').parentNode.removeChild(document.getElementById('loader'))
            } else {
              console.error('Could not get all the dependencies of sandbox set up!')
              console.error('main', !!main, 'ts', !!window.ts, 'sandbox', !!sandbox)
              return
            }
            // Create a sandbox and embed it into the div #monaco-editor-embed
            const sandboxConfig = {
              text: initialCode,
              compilerOptions: {},
              domID: 'monaco-editor-embed',
            }
            const sandbox = sandboxFactory.createTypeScriptSandbox(sandboxConfig, main, window.ts)
            sandbox.editor.focus()
          })
        }
        document.body.appendChild(getLoaderScript)
      </script>
    </html>
Opening the file `index.html` in a web browser will load up the same sandbox
up at the top of the page.
### Some examples of the API
Converting the user's TypeScript into JavaScript
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    // Async because it needs to go  
    const js = await sandbox.getRunnableJS()
    console.log(js)
Get the DTS for the user's editor
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    const dts = await sandbox.getDTSForCode()
    console.log(dts)
Make a request for an LSP response
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    // A worker here is a web-worker, set up by monaco-typescript
    // which does the computation in the background 
    const worker = await sandbox.getWorkerProcess()
    const definitions =  await client.getDefinitionAtPosition(model.uri.toString(), 6)
Change compiler flags using a few different APIs
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    // Hook in to all changes to the compiler
    sandbox.setDidUpdateCompilerSettings((newOptions) => {
      console.log("Compiler settings changed: ", newOptions)
    })
    // Update via key value
    sandbox.updateCompilerSetting("allowJs", true)
    // Update via an object
    sandbox.updateCompilerSettings({ jsx: 0 })
    // Replace the compiler settings
    sandbox.setCompilerSettings({})
Highlight some code in the editor
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    const start = {
      lineNumber: 0,
      column: 0
    }
    const end = {
      lineNumber: 0,
      column: 4
    }
    const decorations = sandbox.editor.deltaDecorations([], [
      {
        range: new sandbox.monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column),
        options: { inlineClassName: 'error-highlight' },
      },
    ])
Create your own playground.
    const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)
    // Use a script to make a JSON file like:
    // { 
    //   "file:///node_modules/types/keyboard/index.d.ts": "export const enterKey: string"
    // }
    //
    // Where the keys are the paths, and the values are the source-code. The sandbox
    // will use the node resolution lookup strategy by default.
    const dtsFiles = {} 
    Object.keys(dtsFiles).forEach(path => {
      sandbox.languageServiceDefaults.addExtraLib(dts[path], path);
    });
The API is mainly a light shim over the [monaco-editor
API](https://microsoft.github.io/monaco-editor/api/index.html) with the
[monaco-typescript API](https://github.com/microsoft/monaco-typescript).
# TypeScript Twoslash
A markup format for TypeScript code, ideal for creating self-contained code
samples which let the TypeScript compiler do the extra leg-work.
If you know TypeScript, you basically know twoslash.
Twoslash adds the ability to declare tsconfig options inline, split a sample
into multiple files and a few other useful commands. You can see the full API
[inside the README](https://github.com/microsoft/TypeScript-
Website/tree/v2/packages/ts-twoslasher)
The Twoslash markup language helps with:
  * Enforcing accurate errors from a TypeScript code sample, and leaving the messaging to the compiler
  * Splitting a code sample to hide distracting code
  * Declaratively highlighting symbols in your code sample
  * Replacing code with the results of transpilation to different files, or ancillary files like .d.ts or .map files
  * Handle multi-file imports in a single code sample
  * Creating a playground link for the code
### Markup
See how TS Twoslash will grab the highlight information for identifiers in
your code
Downloading Sandbox...
Highlights runtime types
Show Errors
Set Compiler Flags
Trims code
Show the JS
Show the DTS
Highlights
### Results
## Usage
Twoslash's usage guide is available on the npm README at
[`@typescript/twoslash`](https://www.npmjs.com/package/@typescript/twoslash).
# Easy access to the compiler API
TypeScript VFS lets you create a self-contained TypeScript environment
entirely under your control. This library is used to power the Playground, and
provides the underlying tooling for [twoslash](/dev/twoslash/) code samples.
There are 3 main uses for TypeScript VFS:
  * Creating a TypeScript Program as an entry-point to the compiler API
  * Running TypeScript to emit files like `*.js`, `*.d.ts` or `*.map`
  * Using TypeScript's language service to make the same calls an editor would make
You can learn more in the [TypeScript VFS
README](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/typescript-vfs/)
### Setup with TypeScript from node_modules
    import ts from 'typescript'
    import tsvfs from '@typescript/vfs'
    const fsMap = tsvfs.createDefaultMapFromNodeModules({ target: ts.ScriptTarget.ES2015 })
    fsMap.set('index.ts', 'console.log("Hello World")')
    // ....
### Use the TypeScript CDN to get your lib.d.ts files
    import ts from 'typescript'
    import tsvfs from '@typescript/vfs'
    const fsMap = await tsvfs.createDefaultMapFromCDN(compilerOptions, ts.version, true, ts)
    fsMap.set('index.ts', 'console.log("Hello World")')
    const system = tsvfs.createSystem(fsMap)
    const host = tsvfs.createVirtualCompilerHost(system, compilerOptions, ts)
    const program = ts.createProgram({
      rootNames: [...fsMap.keys()],
      options: compilerOptions,
      host: host.compilerHost,
    })
    // This will update the fsMap with new files
    // for the .d.ts and .js files
    program.emit()
    // Now I can look at the AST for the .ts file too
    const index = program.getSourceFile('index.ts')
# TypeScript Documentation
#### Get Started
Quick introductions based on your background or preference.
  * [TS for the New Programmer](/docs/handbook/typescript-from-scratch.html)
  * [TypeScript for JS Programmers](/docs/handbook/typescript-in-5-minutes.html)
  * [TS for Java/C# Programmers](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [TS for Functional Programmers](/docs/handbook/typescript-in-5-minutes-func.html)
  * [TypeScript Tooling in 5 minutes](/docs/handbook/typescript-tooling-in-5-minutes.html)
#### Handbook
A great first read for your daily TS work.
  * [The TypeScript Handbook](/docs/handbook/intro.html)
  * [The Basics](/docs/handbook/2/basic-types.html)
  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Narrowing](/docs/handbook/2/narrowing.html)
  * [More on Functions](/docs/handbook/2/functions.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * Type Manipulation
  *     * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
    * [Generics](/docs/handbook/2/generics.html)
    * [Keyof Type Operator](/docs/handbook/2/keyof-types.html)
    * [Typeof Type Operator](/docs/handbook/2/typeof-types.html)
    * [Indexed Access Types](/docs/handbook/2/indexed-access-types.html)
    * [Conditional Types](/docs/handbook/2/conditional-types.html)
    * [Mapped Types](/docs/handbook/2/mapped-types.html)
    * [Template Literal Types](/docs/handbook/2/template-literal-types.html)
  * [Classes](/docs/handbook/2/classes.html)
  * [Modules](/docs/handbook/2/modules.html)
#### Reference
Deep dive reference materials.
  * [Utility Types](/docs/handbook/utility-types.html)
  * [Cheat Sheets](/cheatsheets/)
  * [Decorators](/docs/handbook/decorators.html)
  * [Declaration Merging](/docs/handbook/declaration-merging.html)
  * [Enums](/docs/handbook/enums.html)
  * [Iterators and Generators](/docs/handbook/iterators-and-generators.html)
  * [JSX](/docs/handbook/jsx.html)
  * [Mixins](/docs/handbook/mixins.html)
  * [Namespaces](/docs/handbook/namespaces.html)
  * [Namespaces and Modules](/docs/handbook/namespaces-and-modules.html)
  * [Symbols](/docs/handbook/symbols.html)
  * [Triple-Slash Directives](/docs/handbook/triple-slash-directives.html)
  * [Type Compatibility](/docs/handbook/type-compatibility.html)
  * [Type Inference](/docs/handbook/type-inference.html)
  * [Variable Declaration](/docs/handbook/variable-declarations.html)
#### Modules Reference
How TypeScript models JavaScript modules.
  * [Introduction](/docs/handbook/modules/introduction.html)
  * [Theory](/docs/handbook/modules/theory.html)
  * Guides
  *     * [Choosing Compiler Options](/docs/handbook/modules/guides/choosing-compiler-options.html)
  * [Reference](/docs/handbook/modules/reference.html)
  * Appendices
  *     * [ESM/CJS Interoperability](/docs/handbook/modules/appendices/esm-cjs-interop.html)
#### Tutorials
Using TypeScript in several environments.
  * [ASP.NET Core](/docs/handbook/asp-net-core.html)
  * [Gulp](/docs/handbook/gulp.html)
  * [DOM Manipulation](/docs/handbook/dom-manipulation.html)
  * [Migrating from JavaScript](/docs/handbook/migrating-from-javascript.html)
  * [Using Babel with TypeScript](/docs/handbook/babel-with-typescript.html)
#### Declaration Files
Learn how to write declaration files to describe existing JavaScript.
Important for DefinitelyTyped contributions.
  * [Introduction](/docs/handbook/declaration-files/introduction.html)
  * [Declaration Reference](/docs/handbook/declaration-files/by-example.html)
  * [Library Structures](/docs/handbook/declaration-files/library-structures.html)
  * .d.ts Templates
  *     * [Modules .d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html)
    * [Module: Plugin](/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)
    * [Module: Class](/docs/handbook/declaration-files/templates/module-class-d-ts.html)
    * [Module: Function](/docs/handbook/declaration-files/templates/module-function-d-ts.html)
    * [Global .d.ts](/docs/handbook/declaration-files/templates/global-d-ts.html)
    * [Global: Modifying Module](/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)
  * [Do's and Don'ts](/docs/handbook/declaration-files/do-s-and-don-ts.html)
  * [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
  * [Publishing](/docs/handbook/declaration-files/publishing.html)
  * [Consumption](/docs/handbook/declaration-files/consumption.html)
#### JavaScript
How to use TypeScript-powered JavaScript tooling.
  * [JS Projects Utilizing TypeScript](/docs/handbook/intro-to-js-ts.html)
  * [Type Checking JavaScript Files](/docs/handbook/type-checking-javascript-files.html)
  * [JSDoc Reference](/docs/handbook/jsdoc-supported-types.html)
  * [Creating .d.ts Files from .js files](/docs/handbook/declaration-files/dts-from-js.html)
#### Project Configuration
Compiler configuration reference.
  * [What is a tsconfig.json](/docs/handbook/tsconfig-json.html)
  * [Compiler Options in MSBuild](/docs/handbook/compiler-options-in-msbuild.html)
  * [TSConfig Reference](/tsconfig/)
  * [tsc CLI Options](/docs/handbook/compiler-options.html)
  * [Project References](/docs/handbook/project-references.html)
  * [Integrating with Build Tools](/docs/handbook/integrating-with-build-tools.html)
  * [Configuring Watch](/docs/handbook/configuring-watch.html)
  * [Nightly Builds](/docs/handbook/nightly-builds.html)
#### Cheat Sheets
Downloadable syntax reference pages for different parts of everyday TypeScript
code.
  * [Control Flow Analysis](/static/TypeScript Control Flow Analysis-8a549253ad8470850b77c4c5c351d457.png)
  * [Classes](/static/TypeScript Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png)
  * [Interfaces](/static/TypeScript Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png)
  * [Types](/static/TypeScript Types-ae199d69aeecf7d4a2704a528d0fd3f9.png)
  * [Download PDFs and PNGs](/assets/typescript-cheat-sheets.zip)
## Learning Resources
#### Get Started
  * [JS to TS](/docs/handbook/typescript-in-5-minutes.html)
  * [New to Programming](/docs/handbook/typescript-from-scratch.html)
  * [OOP to JS](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [Functional to JS](/docs/handbook/typescript-in-5-minutes-func.html)
  * [Installation](/download/)
#### Handbook
  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * [Variable Declarations](/docs/handbook/variable-declarations.html)
  * [More on Functions](/docs/handbook/2/functions.html)
#### Tools
  * [Playground](/play/)
  * [TSConfig Reference](/tsconfig/)
#### Release Notes
  * [What's new in 5.6](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/)
#### Tutorials
  * [ASP.NET](/docs/handbook/asp-net-core.html)
  * [Migrating from JS](/docs/handbook/migrating-from-javascript.html)
  * [Working with the DOM](/docs/handbook/dom-manipulation.html)
  * [React & Webpack](/docs/handbook/react-&-webpack.html)
Was this page helpful?
# The Basics
Welcome to the first page of the handbook. If this is your first experience
with TypeScript - you may want to start at one of the '[Getting
Started](https://www.typescriptlang.org/docs/handbook/intro.html#get-started)'
guides
Each and every value in JavaScript has a set of behaviors you can observe from
running different operations. That sounds abstract, but as a quick example,
consider some operations we might run on a variable named `message`.
    js
    // Accessing the property 'toLowerCase'
    // on 'message' and then calling it
    message.toLowerCase();
    // Calling 'message'
    message();
If we break this down, the first runnable line of code accesses a property
called `toLowerCase` and then calls it. The second one tries to call `message`
directly.
But assuming we don‚Äôt know the value of `message` \- and that‚Äôs pretty common
- we can‚Äôt reliably say what results we‚Äôll get from trying to run any of this
code. The behavior of each operation depends entirely on what value we had in
the first place.
  * Is `message` callable?
  * Does it have a property called `toLowerCase` on it?
  * If it does, is `toLowerCase` even callable?
  * If both of these values are callable, what do they return?
The answers to these questions are usually things we keep in our heads when we
write JavaScript, and we have to hope we got all the details right.
Let‚Äôs say `message` was defined in the following way.
    js
    const message = "Hello World!";
As you can probably guess, if we try to run `message.toLowerCase()`, we‚Äôll get
the same string only in lower-case.
What about that second line of code? If you‚Äôre familiar with JavaScript,
you‚Äôll know this fails with an exception:
    txt
    TypeError: message is not a function
It‚Äôd be great if we could avoid mistakes like this.
When we run our code, the way that our JavaScript runtime chooses what to do
is by figuring out the _type_ of the value - what sorts of behaviors and
capabilities it has. That‚Äôs part of what that `TypeError` is alluding to -
it‚Äôs saying that the string `"Hello World!"` cannot be called as a function.
For some values, such as the primitives `string` and `number`, we can identify
their type at runtime using the `typeof` operator. But for other things like
functions, there‚Äôs no corresponding runtime mechanism to identify their types.
For example, consider this function:
    js
    function fn(x) {
      return x.flip();
    }
We can _observe_ by reading the code that this function will only work if
given an object with a callable `flip` property, but JavaScript doesn‚Äôt
surface this information in a way that we can check while the code is running.
The only way in pure JavaScript to tell what `fn` does with a particular value
is to call it and see what happens. This kind of behavior makes it hard to
predict what the code will do before it runs, which means it‚Äôs harder to know
what your code is going to do while you‚Äôre writing it.
Seen in this way, a _type_ is the concept of describing which values can be
passed to `fn` and which will crash. JavaScript only truly provides _dynamic_
typing - running the code to see what happens.
The alternative is to use a _static_ type system to make predictions about
what the code is expected to do _before_ it runs.
## Static type-checking
Think back to that `TypeError` we got earlier from trying to call a `string`
as a function. _Most people_ don‚Äôt like to get any sorts of errors when
running their code - those are considered bugs! And when we write new code, we
try our best to avoid introducing new bugs.
If we add just a bit of code, save our file, re-run the code, and immediately
see the error, we might be able to isolate the problem quickly; but that‚Äôs not
always the case. We might not have tested the feature thoroughly enough, so we
might never actually run into a potential error that would be thrown! Or if we
were lucky enough to witness the error, we might have ended up doing large
refactorings and adding a lot of different code that we‚Äôre forced to dig
through.
Ideally, we could have a tool that helps us find these bugs _before_ our code
runs. That‚Äôs what a static type-checker like TypeScript does. _Static types
systems_ describe the shapes and behaviors of what our values will be when we
run our programs. A type-checker like TypeScript uses that information and
tells us when things might be going off the rails.
    ts
    const message = "hello!";
    message();
    This expression is not callable.
      Type 'String' has no call signatures.2349This expression is not callable.
      Type 'String' has no call signatures.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA)
Running that last sample with TypeScript will give us an error message before
we run the code in the first place.
## Non-exception Failures
So far we‚Äôve been discussing certain things like runtime errors - cases where
the JavaScript runtime tells us that it thinks something is nonsensical. Those
cases come up because [the ECMAScript
specification](https://tc39.github.io/ecma262/) has explicit instructions on
how the language should behave when it runs into something unexpected.
For example, the specification says that trying to call something that isn‚Äôt
callable should throw an error. Maybe that sounds like ‚Äúobvious behavior‚Äù, but
you could imagine that accessing a property that doesn‚Äôt exist on an object
should throw an error too. Instead, JavaScript gives us different behavior and
returns the value `undefined`:
    js
    const user = {
      name: "Daniel",
      age: 26,
    };
    user.location; // returns undefined
Ultimately, a static type system has to make the call over what code should be
flagged as an error in its system, even if it‚Äôs ‚Äúvalid‚Äù JavaScript that won‚Äôt
immediately throw an error. In TypeScript, the following code produces an
error about `location` not being defined:
    ts
    const user = {
      name: "Daniel",
      age: 26,
    };
    user.location;
    Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA)
While sometimes that implies a trade-off in what you can express, the intent
is to catch legitimate bugs in our programs. And TypeScript catches _a lot_ of
legitimate bugs.
For example: typos,
    ts
    const announcement = "Hello World!";
    // How quickly can you spot the typos?
    announcement.toLocaleLowercase();
    announcement.toLocalLowerCase();
    // We probably meant to write this...
    announcement.toLocaleLowerCase();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA)
uncalled functions,
    ts
    function flipCoin() {
      // Meant to be Math.random()
      return Math.random < 0.5;
    Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA)
or basic logic errors.
    ts
    const value = Math.random() < 0.5 ? "a" : "b";
    if (value !== "a") {
      // ...
    } else if (value === "b") {
    This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap.2367This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap.
      // Oops, unreachable
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA)
## Types for Tooling
TypeScript can catch bugs when we make mistakes in our code. That‚Äôs great, but
TypeScript can _also_ prevent us from making those mistakes in the first
place.
The type-checker has information to check things like whether we‚Äôre accessing
the right properties on variables and other properties. Once it has that
information, it can also start _suggesting_ which properties you might want to
use.
That means TypeScript can be leveraged for editing code too, and the core
type-checker can provide error messages and code completion as you type in the
editor. That‚Äôs part of what people often refer to when they talk about tooling
in TypeScript.
    ts
    import express from "express";
    const app = express();
    app.get("/", function (req, res) {
      res.sen
      * send
      * sendDate
      * sendfile
      * sendFile
      * sendStatus
    });
    app.listen(3000);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA)
TypeScript takes tooling seriously, and that goes beyond completions and
errors as you type. An editor that supports TypeScript can deliver ‚Äúquick
fixes‚Äù to automatically fix errors, refactorings to easily re-organize code,
and useful navigation features for jumping to definitions of a variable, or
finding all references to a given variable. All of this is built on top of the
type-checker and is fully cross-platform, so it‚Äôs likely that [your favorite
editor has TypeScript support
available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-
Support).
## `tsc`, the TypeScript compiler
We‚Äôve been talking about type-checking, but we haven‚Äôt yet used our type-
_checker_. Let‚Äôs get acquainted with our new friend `tsc`, the TypeScript
compiler. First we‚Äôll need to grab it via npm.
    sh
    npm install -g typescript
> This installs the TypeScript Compiler `tsc` globally. You can use `npx` or
> similar tools if you‚Äôd prefer to run `tsc` from a local `node_modules`
> package instead.
Now let‚Äôs move to an empty folder and try writing our first TypeScript
program: `hello.ts`:
    ts
    // Greets the world.
    console.log("Hello world!");
    [Try](https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA)
Notice there are no frills here; this ‚Äúhello world‚Äù program looks identical to
what you‚Äôd write for a ‚Äúhello world‚Äù program in JavaScript. And now let‚Äôs
type-check it by running the command `tsc` which was installed for us by the
`typescript` package.
    sh
    tsc hello.ts
Tada!
Wait, ‚Äútada‚Äù _what_ exactly? We ran `tsc` and nothing happened! Well, there
were no type errors, so we didn‚Äôt get any output in our console since there
was nothing to report.
But check again - we got some _file_ output instead. If we look in our current
directory, we‚Äôll see a `hello.js` file next to `hello.ts`. That‚Äôs the output
from our `hello.ts` file after `tsc` _compiles_ or _transforms_ it into a
plain JavaScript file. And if we check the contents, we‚Äôll see what TypeScript
spits out after it processes a `.ts` file:
    js
    // Greets the world.
    console.log("Hello world!");
In this case, there was very little for TypeScript to transform, so it looks
identical to what we wrote. The compiler tries to emit clean readable code
that looks like something a person would write. While that‚Äôs not always so
easy, TypeScript indents consistently, is mindful of when our code spans
across different lines of code, and tries to keep comments around.
What about if we _did_ introduce a type-checking error? Let‚Äôs rewrite
`hello.ts`:
    ts
    // This is an industrial-grade general-purpose greeter function:
    function greet(person, date) {
      console.log(`Hello ${person}, today is ${date}!`);
    }
    greet("Brendan");
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA)
If we run `tsc hello.ts` again, notice that we get an error on the command
line!
    txt
    Expected 2 arguments, but got 1.
TypeScript is telling us we forgot to pass an argument to the `greet`
function, and rightfully so. So far we‚Äôve only written standard JavaScript,
and yet type-checking was still able to find problems with our code. Thanks
TypeScript!
## Emitting with Errors
One thing you might not have noticed from the last example was that our
`hello.js` file changed again. If we open that file up then we‚Äôll see that the
contents still basically look the same as our input file. That might be a bit
surprising given the fact that `tsc` reported an error about our code, but
this is based on one of TypeScript‚Äôs core values: much of the time, _you_ will
know better than TypeScript.
To reiterate from earlier, type-checking code limits the sorts of programs you
can run, and so there‚Äôs a tradeoff on what sorts of things a type-checker
finds acceptable. Most of the time that‚Äôs okay, but there are scenarios where
those checks get in the way. For example, imagine yourself migrating
JavaScript code over to TypeScript and introducing type-checking errors.
Eventually you‚Äôll get around to cleaning things up for the type-checker, but
that original JavaScript code was already working! Why should converting it
over to TypeScript stop you from running it?
So TypeScript doesn‚Äôt get in your way. Of course, over time, you may want to
be a bit more defensive against mistakes, and make TypeScript act a bit more
strictly. In that case, you can use the
[`noEmitOnError`](/tsconfig#noEmitOnError) compiler option. Try changing your
`hello.ts` file and running `tsc` with that flag:
    sh
    tsc --noEmitOnError hello.ts
You‚Äôll notice that `hello.js` never gets updated.
## Explicit Types
Up until now, we haven‚Äôt told TypeScript what `person` or `date` are. Let‚Äôs
edit the code to tell TypeScript that `person` is a `string`, and that `date`
should be a `Date` object. We‚Äôll also use the `toDateString()` method on
`date`.
    ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA)
What we did was add _type annotations_ on `person` and `date` to describe what
types of values `greet` can be called with. You can read that signature as
‚Äù`greet` takes a `person` of type `string`, and a `date` of type `Date`‚Äú.
With this, TypeScript can tell us about other cases where `greet` might have
been called incorrectly. For example‚Ä¶
    ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    greet("Maddison", Date());
    Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA)
Huh? TypeScript reported an error on our second argument, but why?
Perhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On
the other hand, constructing a `Date` with `new Date()` actually gives us what
we were expecting.
Anyway, we can quickly fix up the error:
    ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    greet("Maddison", new Date());
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA)
Keep in mind, we don‚Äôt always have to write explicit type annotations. In many
cases, TypeScript can even just _infer_ (or ‚Äúfigure out‚Äù) the types for us
even if we omit them.
    ts
    let msg = "hello there!";
    let msg: string
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA)
Even though we didn‚Äôt tell TypeScript that `msg` had the type `string` it was
able to figure that out. That‚Äôs a feature, and it‚Äôs best not to add
annotations when the type system would end up inferring the same type anyway.
> Note: The message bubble inside the previous code sample is what your editor
> would show if you had hovered over the word.
## Erased Types
Let‚Äôs take a look at what happens when we compile the above function `greet`
with `tsc` to output JavaScript:
    ts
    "use strict";
    function greet(person, date) {
        console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
    }
    greet("Maddison", new Date());
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA)
Notice two things here:
  1. Our `person` and `date` parameters no longer have type annotations.
  2. Our ‚Äútemplate string‚Äù - that string that used backticks (the ``` character) - was converted to plain strings with concatenations.
More on that second point later, but let‚Äôs now focus on that first point. Type
annotations aren‚Äôt part of JavaScript (or ECMAScript to be pedantic), so there
really aren‚Äôt any browsers or other runtimes that can just run TypeScript
unmodified. That‚Äôs why TypeScript needs a compiler in the first place - it
needs some way to strip out or transform any TypeScript-specific code so that
you can run it. Most TypeScript-specific code gets erased away, and likewise,
here our type annotations were completely erased.
> **Remember** : Type annotations never change the runtime behavior of your
> program.
## Downleveling
One other difference from the above was that our template string was rewritten
from
    js
    `Hello ${person}, today is ${date.toDateString()}!`;
to
    js
    "Hello ".concat(person, ", today is ").concat(date.toDateString(), "!");
Why did this happen?
Template strings are a feature from a version of ECMAScript called ECMAScript
2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - _don‚Äôt ask_). TypeScript has
the ability to rewrite code from newer versions of ECMAScript to older ones
such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5). This process of moving from
a newer or ‚Äúhigher‚Äù version of ECMAScript down to an older or ‚Äúlower‚Äù one is
sometimes called _downleveling_.
By default TypeScript targets ES5, an extremely old version of ECMAScript. We
could have chosen something a little bit more recent by using the
[`target`](/tsconfig#target) option. Running with `--target es2015` changes
TypeScript to target ECMAScript 2015, meaning code should be able to run
wherever ECMAScript 2015 is supported. So running `tsc --target es2015
hello.ts` gives us the following output:
    js
    function greet(person, date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    greet("Maddison", new Date());
> While the default target is ES5, the great majority of current browsers
> support ES2015. Most developers can therefore safely specify ES2015 or above
> as a target, unless compatibility with certain ancient browsers is
> important.
## Strictness
Different users come to TypeScript looking for different things in a type-
checker. Some people are looking for a more loose opt-in experience which can
help validate only some parts of their program, and still have decent tooling.
This is the default experience with TypeScript, where types are optional,
inference takes the most lenient types, and there‚Äôs no checking for
potentially `null`/`undefined` values. Much like how `tsc` emits in the face
of errors, these defaults are put in place to stay out of your way. If you‚Äôre
migrating existing JavaScript, that might be a desirable first step.
In contrast, a lot of users prefer to have TypeScript validate as much as it
can straight away, and that‚Äôs why the language provides strictness settings as
well. These strictness settings turn static type-checking from a switch
(either your code is checked or not) into something closer to a dial. The
further you turn this dial up, the more TypeScript will check for you. This
can require a little extra work, but generally speaking it pays for itself in
the long run, and enables more thorough checks and more accurate tooling. When
possible, a new codebase should always turn these strictness checks on.
TypeScript has several type-checking strictness flags that can be turned on or
off, and all of our examples will be written with all of them enabled unless
otherwise stated. The [`strict`](/tsconfig#strict) flag in the CLI, or
`"strict": true` in a
[`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-
json.html) toggles them all on simultaneously, but we can opt out of them
individually. The two biggest ones you should know about are
[`noImplicitAny`](/tsconfig#noImplicitAny) and
[`strictNullChecks`](/tsconfig#strictNullChecks).
## `noImplicitAny`
Recall that in some places, TypeScript doesn‚Äôt try to infer types for us and
instead falls back to the most lenient type: `any`. This isn‚Äôt the worst thing
that can happen - after all, falling back to `any` is just the plain
JavaScript experience anyway.
However, using `any` often defeats the purpose of using TypeScript in the
first place. The more typed your program is, the more validation and tooling
you‚Äôll get, meaning you‚Äôll run into fewer bugs as you code. Turning on the
[`noImplicitAny`](/tsconfig#noImplicitAny) flag will issue an error on any
variables whose type is implicitly inferred as `any`.
## `strictNullChecks`
By default, values like `null` and `undefined` are assignable to any other
type. This can make writing some code easier, but forgetting to handle `null`
and `undefined` is the cause of countless bugs in the world - some consider it
a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)! The
[`strictNullChecks`](/tsconfig#strictNullChecks) flag makes handling `null`
and `undefined` more explicit, and _spares_ us from worrying about whether we
_forgot_ to handle `null` and `undefined`.
### [The TypeScript HandbookYour first step to learn
TypeScript](/docs/handbook/intro.html)
### [Everyday TypesThe language primitives.](/docs/handbook/2/everyday-
types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Basics.md) ‚ù§
Contributors to this page:  
RC
OT
RT
DR
EB
18+
Last updated: Sep 16, 2024  
Was this page helpful?
# Classes
> Background Reading:  
> [Classes (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes)
TypeScript offers full support for the `class` keyword introduced in ES2015.
As with other JavaScript language features, TypeScript adds type annotations
and other syntax to allow you to express relationships between classes and
other types.
## Class Members
Here‚Äôs the most basic class - an empty one:
    ts
    class Point {}
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A)
This class isn‚Äôt very useful yet, so let‚Äôs start adding some members.
### Fields
A field declaration creates a public writeable property on a class:
    ts
    class Point {
      x: number;
      y: number;
    }
    const pt = new Point();
    pt.x = 0;
    pt.y = 0;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA)
As with other locations, the type annotation is optional, but will be an
implicit `any` if not specified.
Fields can also have _initializers_ ; these will run automatically when the
class is instantiated:
    ts
    class Point {
      x = 0;
      y = 0;
    }
    const pt = new Point();
    // Prints 0, 0
    console.log(`${pt.x}, ${pt.y}`);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA)
Just like with `const`, `let`, and `var`, the initializer of a class property
will be used to infer its type:
    ts
    const pt = new Point();
    pt.x = "0";
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA)
#### `--strictPropertyInitialization`
The [`strictPropertyInitialization`](/tsconfig#strictPropertyInitialization)
setting controls whether class fields need to be initialized in the
constructor.
    ts
    class BadGreeter {
      name: string;
    Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA)
    ts
    class GoodGreeter {
      name: string;
      constructor() {
        this.name = "hello";
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA)
Note that the field needs to be initialized _in the constructor itself_.
TypeScript does not analyze methods you invoke from the constructor to detect
initializations, because a derived class might override those methods and fail
to initialize the members.
If you intend to definitely initialize a field through means other than the
constructor (for example, maybe an external library is filling in part of your
class for you), you can use the _definite assignment assertion operator_ ,
`!`:
    ts
    class OKGreeter {
      // Not initialized, but no error
      name!: string;
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A)
### `readonly`
Fields may be prefixed with the `readonly` modifier. This prevents assignments
to the field outside of the constructor.
    ts
    class Greeter {
      readonly name: string = "world";
      constructor(otherName?: string) {
        if (otherName !== undefined) {
          this.name = otherName;
        }
      }
      err() {
        this.name = "not ok";
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.
      }
    }
    const g = new Greeter();
    g.name = "also not ok";
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA)
### Constructors
> Background Reading:  
>  [Constructor (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/constructor)  
>
Class constructors are very similar to functions. You can add parameters with
type annotations, default values, and overloads:
    ts
    class Point {
      x: number;
      y: number;
      // Normal signature with defaults
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA)
    ts
    class Point {
      x: number = 0;
      y: number = 0;
      // Constructor overloads
      constructor(x: number, y: number);
      constructor(xy: string);
      constructor(x: string | number, y: number = 0) {
        // Code logic here
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA)
There are just a few differences between class constructor signatures and
function signatures:
  * Constructors can‚Äôt have type parameters - these belong on the outer class declaration, which we‚Äôll learn about later
  * Constructors can‚Äôt have return type annotations - the class instance type is always what‚Äôs returned
#### Super Calls
Just as in JavaScript, if you have a base class, you‚Äôll need to call
`super();` in your constructor body before using any `this.` members:
    ts
    class Base {
      k = 4;
    }
    class Derived extends Base {
      constructor() {
        // Prints a wrong value in ES5; throws exception in ES6
        console.log(this.k);
    'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.
        super();
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA)
Forgetting to call `super` is an easy mistake to make in JavaScript, but
TypeScript will tell you when it‚Äôs necessary.
### Methods
> Background Reading:  
>  [Method definitions](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/Method_definitions)  
>
A function property on a class is called a _method_. Methods can use all the
same type annotations as functions and constructors:
    ts
    class Point {
      x = 10;
      y = 10;
      scale(n: number): void {
        this.x *= n;
        this.y *= n;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA)
Other than the standard type annotations, TypeScript doesn‚Äôt add anything else
new to methods.
Note that inside a method body, it is still mandatory to access fields and
other methods via `this.`. An unqualified name in a method body will always
refer to something in the enclosing scope:
    ts
    let x: number = 0;
    class C {
      x: string = "hello";
      m() {
        // This is trying to modify 'x' from line 1, not the class property
        x = "world";
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA)
### Getters / Setters
Classes can also have _accessors_ :
    ts
    class C {
      _length = 0;
      get length() {
        return this._length;
      }
      set length(value) {
        this._length = value;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA)
> Note that a field-backed get/set pair with no extra logic is very rarely
> useful in JavaScript. It‚Äôs fine to expose public fields if you don‚Äôt need to
> add additional logic during the get/set operations.
TypeScript has some special inference rules for accessors:
  * If `get` exists but no `set`, the property is automatically `readonly`
  * If the type of the setter parameter is not specified, it is inferred from the return type of the getter
Since [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-3/), it is possible to have accessors with different types for
getting and setting.
    ts
    class Thing {
      _size = 0;
      get size(): number {
        return this._size;
      }
      set size(value: string | number | boolean) {
        let num = Number(value);
        // Don't allow NaN, Infinity, etc
        if (!Number.isFinite(num)) {
          this._size = 0;
          return;
        }
        this._size = num;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA)
### Index Signatures
Classes can declare index signatures; these work the same as [Index Signatures
for other object types](/docs/handbook/2/objects.html#index-signatures):
    ts
    class MyClass {
      [s: string]: boolean | ((s: string) => boolean);
      check(s: string) {
        return this[s] as boolean;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA)
Because the index signature type needs to also capture the types of methods,
it‚Äôs not easy to usefully use these types. Generally it‚Äôs better to store
indexed data in another place instead of on the class instance itself.
## Class Heritage
Like other languages with object-oriented features, classes in JavaScript can
inherit from base classes.
### `implements` Clauses
You can use an `implements` clause to check that a class satisfies a
particular `interface`. An error will be issued if a class fails to correctly
implement it:
    ts
    interface Pingable {
      ping(): void;
    }
    class Sonar implements Pingable {
      ping() {
        console.log("ping!");
      }
    }
    class Ball implements Pingable {
    Class 'Ball' incorrectly implements interface 'Pingable'.
      Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.
      Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
      pong() {
        console.log("pong!");
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA)
Classes may also implement multiple interfaces, e.g. `class C implements A, B
{`.
#### Cautions
It‚Äôs important to understand that an `implements` clause is only a check that
the class can be treated as the interface type. It doesn‚Äôt change the type of
the class or its methods _at all_. A common source of error is to assume that
an `implements` clause will change the class type - it doesn‚Äôt!
    ts
    interface Checkable {
      check(name: string): boolean;
    }
    class NameChecker implements Checkable {
      check(s) {
    Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.
        // Notice no error here
        return s.toLowerCase() === "ok";
    any
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA)
In this example, we perhaps expected that `s`‚Äôs type would be influenced by
the `name: string` parameter of `check`. It is not - `implements` clauses
don‚Äôt change how the class body is checked or its type inferred.
Similarly, implementing an interface with an optional property doesn‚Äôt create
that property:
    ts
    interface A {
      x: number;
      y?: number;
    }
    class C implements A {
      x = 0;
    }
    const c = new C();
    c.y = 10;
    Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA)
### `extends` Clauses
> Background Reading:  
>  [extends keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/extends)  
>
Classes may `extend` from a base class. A derived class has all the properties
and methods of its base class, and can also define additional members.
    ts
    class Animal {
      move() {
        console.log("Moving along!");
      }
    }
    class Dog extends Animal {
      woof(times: number) {
        for (let i = 0; i < times; i++) {
          console.log("woof!");
        }
      }
    }
    const d = new Dog();
    // Base class method
    d.move();
    // Derived class method
    d.woof(3);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA)
#### Overriding Methods
> Background Reading:  
>  [super keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/super)  
>
A derived class can also override a base class field or property. You can use
the `super.` syntax to access base class methods. Note that because JavaScript
classes are a simple lookup object, there is no notion of a ‚Äúsuper field‚Äù.
TypeScript enforces that a derived class is always a subtype of its base
class.
For example, here‚Äôs a legal way to override a method:
    ts
    class Base {
      greet() {
        console.log("Hello, world!");
      }
    }
    class Derived extends Base {
      greet(name?: string) {
        if (name === undefined) {
          super.greet();
        } else {
          console.log(`Hello, ${name.toUpperCase()}`);
        }
      }
    }
    const d = new Derived();
    d.greet();
    d.greet("reader");
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA)
It‚Äôs important that a derived class follow its base class contract. Remember
that it‚Äôs very common (and always legal!) to refer to a derived class instance
through a base class reference:
    ts
    // Alias the derived instance through a base class reference
    const b: Base = d;
    // No problem
    b.greet();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA)
What if `Derived` didn‚Äôt follow `Base`‚Äôs contract?
    ts
    class Base {
      greet() {
        console.log("Hello, world!");
      }
    }
    class Derived extends Base {
      // Make this parameter required
      greet(name: string) {
    Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
      Type '(name: string) => void' is not assignable to type '() => void'.
        Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
      Type '(name: string) => void' is not assignable to type '() => void'.
        Target signature provides too few arguments. Expected 1 or more, but got 0.
        console.log(`Hello, ${name.toUpperCase()}`);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA)
If we compiled this code despite the error, this sample would then crash:
    ts
    const b: Base = new Derived();
    // Crashes because "name" will be undefined
    b.greet();
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA)
#### Type-only Field Declarations
When `target >= ES2022` or
[`useDefineForClassFields`](/tsconfig#useDefineForClassFields) is `true`,
class fields are initialized after the parent class constructor completes,
overwriting any value set by the parent class. This can be a problem when you
only want to re-declare a more accurate type for an inherited field. To handle
these cases, you can write `declare` to indicate to TypeScript that there
should be no runtime effect for this field declaration.
    ts
    interface Animal {
      dateOfBirth: any;
    }
    interface Dog extends Animal {
      breed: any;
    }
    class AnimalHouse {
      resident: Animal;
      constructor(animal: Animal) {
        this.resident = animal;
      }
    }
    class DogHouse extends AnimalHouse {
      // Does not emit JavaScript code,
      // only ensures the types are correct
      declare resident: Dog;
      constructor(dog: Dog) {
        super(dog);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA)
#### Initialization Order
The order that JavaScript classes initialize can be surprising in some cases.
Let‚Äôs consider this code:
    ts
    class Base {
      name = "base";
      constructor() {
        console.log("My name is " + this.name);
      }
    }
    class Derived extends Base {
      name = "derived";
    }
    // Prints "base", not "derived"
    const d = new Derived();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA)
What happened here?
The order of class initialization, as defined by JavaScript, is:
  * The base class fields are initialized
  * The base class constructor runs
  * The derived class fields are initialized
  * The derived class constructor runs
This means that the base class constructor saw its own value for `name` during
its own constructor, because the derived class field initializations hadn‚Äôt
run yet.
#### Inheriting Built-in Types
> Note: If you don‚Äôt plan to inherit from built-in types like `Array`,
> `Error`, `Map`, etc. or your compilation target is explicitly set to
> `ES6`/`ES2015` or above, you may skip this section
In ES2015, constructors which return an object implicitly substitute the value
of `this` for any callers of `super(...)`. It is necessary for generated
constructor code to capture any potential return value of `super(...)` and
replace it with `this`.
As a result, subclassing `Error`, `Array`, and others may no longer work as
expected. This is due to the fact that constructor functions for `Error`,
`Array`, and the like use ECMAScript 6‚Äôs `new.target` to adjust the prototype
chain; however, there is no way to ensure a value for `new.target` when
invoking a constructor in ECMAScript 5. Other downlevel compilers generally
have the same limitation by default.
For a subclass like the following:
    ts
    class MsgError extends Error {
      constructor(m: string) {
        super(m);
      }
      sayHello() {
        return "hello " + this.message;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA)
you may find that:
  * methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.
  * `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.
As a recommendation, you can manually adjust the prototype immediately after
any `super(...)` calls.
    ts
    class MsgError extends Error {
      constructor(m: string) {
        super(m);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, MsgError.prototype);
      }
      sayHello() {
        return "hello " + this.message;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA)
However, any subclass of `MsgError` will have to manually set the prototype as
well. For runtimes that don‚Äôt support
[`Object.setPrototypeOf`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf), you
may instead be able to use [`__proto__`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).
Unfortunately, [these workarounds will not work on Internet Explorer 10 and
prior](https://msdn.microsoft.com/en-us/library/s4esdbwz\(v=vs.94\).aspx). One
can manually copy methods from the prototype onto the instance itself (i.e.
`MsgError.prototype` onto `this`), but the prototype chain itself cannot be
fixed.
## Member Visibility
You can use TypeScript to control whether certain methods or properties are
visible to code outside the class.
### `public`
The default visibility of class members is `public`. A `public` member can be
accessed anywhere:
    ts
    class Greeter {
      public greet() {
        console.log("hi!");
      }
    }
    const g = new Greeter();
    g.greet();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA)
Because `public` is already the default visibility modifier, you don‚Äôt ever
_need_ to write it on a class member, but might choose to do so for
style/readability reasons.
### `protected`
`protected` members are only visible to subclasses of the class they‚Äôre
declared in.
    ts
    class Greeter {
      public greet() {
        console.log("Hello, " + this.getName());
      }
      protected getName() {
        return "hi";
      }
    }
    class SpecialGreeter extends Greeter {
      public howdy() {
        // OK to access protected member here
        console.log("Howdy, " + this.getName());
      }
    }
    const g = new SpecialGreeter();
    g.greet(); // OK
    g.getName();
    Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA)
#### Exposure of `protected` members
Derived classes need to follow their base class contracts, but may choose to
expose a subtype of base class with more capabilities. This includes making
`protected` members `public`:
    ts
    class Base {
      protected m = 10;
    }
    class Derived extends Base {
      // No modifier, so default is 'public'
      m = 15;
    }
    const d = new Derived();
    console.log(d.m); // OK
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA)
Note that `Derived` was already able to freely read and write `m`, so this
doesn‚Äôt meaningfully alter the ‚Äúsecurity‚Äù of this situation. The main thing to
note here is that in the derived class, we need to be careful to repeat the
`protected` modifier if this exposure isn‚Äôt intentional.
#### Cross-hierarchy `protected` access
Different OOP languages disagree about whether it‚Äôs legal to access a
`protected` member through a base class reference:
    ts
    class Base {
      protected x: number = 1;
    }
    class Derived1 extends Base {
      protected x: number = 5;
    }
    class Derived2 extends Base {
      f1(other: Derived2) {
        other.x = 10;
      }
      f2(other: Derived1) {
        other.x = 10;
    Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA)
Java, for example, considers this to be legal. On the other hand, C# and C++
chose that this code should be illegal.
TypeScript sides with C# and C++ here, because accessing `x` in `Derived2`
should only be legal from `Derived2`‚Äôs subclasses, and `Derived1` isn‚Äôt one of
them. Moreover, if accessing `x` through a `Derived1` reference is illegal
(which it certainly should be!), then accessing it through a base class
reference should never improve the situation.
See also [Why Can‚Äôt I Access A Protected Member From A Derived
Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-
access-a-protected-member-from-a-derived-class/) which explains more of C#‚Äòs
reasoning.
### `private`
`private` is like `protected`, but doesn‚Äôt allow access to the member even
from subclasses:
    ts
    class Base {
      private x = 0;
    }
    const b = new Base();
    // Can't access from outside the class
    console.log(b.x);
    Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA)
    ts
    class Derived extends Base {
      showX() {
        // Can't access in subclasses
        console.log(this.x);
    Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA)
Because `private` members aren‚Äôt visible to derived classes, a derived class
can‚Äôt increase their visibility:
    ts
    class Base {
      private x = 0;
    }
    class Derived extends Base {
    Class 'Derived' incorrectly extends base class 'Base'.
      Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.
      Property 'x' is private in type 'Base' but not in type 'Derived'.
      x = 1;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA)
#### Cross-instance `private` access
Different OOP languages disagree about whether different instances of the same
class may access each others‚Äô `private` members. While languages like Java,
C#, C++, Swift, and PHP allow this, Ruby does not.
TypeScript does allow cross-instance `private` access:
    ts
    class A {
      private x = 10;
      public sameAs(other: A) {
        // No error
        return other.x === this.x;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA)
#### Caveats
Like other aspects of TypeScript‚Äôs type system, `private` and `protected` [are
only enforced during type
checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-
HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-
KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA).
This means that JavaScript runtime constructs like `in` or simple property
lookup can still access a `private` or `protected` member:
    ts
    class MySafe {
      private secretKey = 12345;
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA)
    js
    // In a JavaScript file...
    const s = new MySafe();
    // Will print 12345
    console.log(s.secretKey);
`private` also allows access using bracket notation during type checking. This
makes `private`-declared fields potentially easier to access for things like
unit tests, with the drawback that these fields are _soft private_ and don‚Äôt
strictly enforce privacy.
    ts
    class MySafe {
      private secretKey = 12345;
    }
    const s = new MySafe();
    // Not allowed during type checking
    console.log(s.secretKey);
    Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'.
    // OK
    console.log(s["secretKey"]);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA)
Unlike TypeScripts‚Äôs `private`, JavaScript‚Äôs [private
fields](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) (`#`) remain
private after compilation and do not provide the previously mentioned escape
hatches like bracket notation access, making them _hard private_.
    ts
    class Dog {
      #barkAmount = 0;
      personality = "happy";
      constructor() {}
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA)
    ts
    "use strict";
    class Dog {
        #barkAmount = 0;
        personality = "happy";
        constructor() { }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA)
When compiling to ES2021 or less, TypeScript will use WeakMaps in place of
`#`.
    ts
    "use strict";
    var _Dog_barkAmount;
    class Dog {
        constructor() {
            _Dog_barkAmount.set(this, 0);
            this.personality = "happy";
        }
    }
    _Dog_barkAmount = new WeakMap();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA)
If you need to protect values in your class from malicious actors, you should
use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or
private fields. Note that these added privacy checks during runtime could
affect performance.
## Static Members
> Background Reading:  
>  [Static Members (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Classes/static)  
>
Classes may have `static` members. These members aren‚Äôt associated with a
particular instance of the class. They can be accessed through the class
constructor object itself:
    ts
    class MyClass {
      static x = 0;
      static printX() {
        console.log(MyClass.x);
      }
    }
    console.log(MyClass.x);
    MyClass.printX();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA)
Static members can also use the same `public`, `protected`, and `private`
visibility modifiers:
    ts
    class MyClass {
      private static x = 0;
    }
    console.log(MyClass.x);
    Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA)
Static members are also inherited:
    ts
    class Base {
      static getGreeting() {
        return "Hello world";
      }
    }
    class Derived extends Base {
      myGreeting = Derived.getGreeting();
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA)
### Special Static Names
It‚Äôs generally not safe/possible to overwrite properties from the `Function`
prototype. Because classes are themselves functions that can be invoked with
`new`, certain `static` names can‚Äôt be used. Function properties like `name`,
`length`, and `call` aren‚Äôt valid to define as `static` members:
    ts
    class S {
      static name = "S!";
    Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A)
### Why No Static Classes?
TypeScript (and JavaScript) don‚Äôt have a construct called `static class` the
same way as, for example, C# does.
Those constructs _only_ exist because those languages force all data and
functions to be inside a class; because that restriction doesn‚Äôt exist in
TypeScript, there‚Äôs no need for them. A class with only a single instance is
typically just represented as a normal _object_ in JavaScript/TypeScript.
For example, we don‚Äôt need a ‚Äústatic class‚Äù syntax in TypeScript because a
regular object (or even top-level function) will do the job just as well:
    ts
    // Unnecessary "static" class
    class MyStaticClass {
      static doSomething() {}
    }
    // Preferred (alternative 1)
    function doSomething() {}
    // Preferred (alternative 2)
    const MyHelperObject = {
      dosomething() {},
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA)
## `static` Blocks in Classes
Static blocks allow you to write a sequence of statements with their own scope
that can access private fields within the containing class. This means that we
can write initialization code with all the capabilities of writing statements,
no leakage of variables, and full access to our class‚Äôs internals.
    ts
    class Foo {
        static #count = 0;
        get count() {
            return Foo.#count;
        }
        static {
            try {
                const lastInstances = loadLastInstances();
                Foo.#count += lastInstances.length;
            }
            catch {}
        }
    }
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA)
## Generic Classes
Classes, much like interfaces, can be generic. When a generic class is
instantiated with `new`, its type parameters are inferred the same way as in a
function call:
    ts
    class Box<Type> {
      contents: Type;
      constructor(value: Type) {
        this.contents = value;
      }
    }
    const b = new Box("hello!");
    const b: Box<string>
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA)
Classes can use generic constraints and defaults the same way as interfaces.
### Type Parameters in Static Members
This code isn‚Äôt legal, and it may not be obvious why:
    ts
    class Box<Type> {
      static defaultValue: Type;
    Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A)
Remember that types are always fully erased! At runtime, there‚Äôs only _one_
`Box.defaultValue` property slot. This means that setting
`Box<string>.defaultValue` (if that were possible) would _also_ change
`Box<number>.defaultValue` \- not good. The `static` members of a generic
class can never refer to the class‚Äôs type parameters.
## `this` at Runtime in Classes
> Background Reading:  
>  [this keyword (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/this)  
>
It‚Äôs important to remember that TypeScript doesn‚Äôt change the runtime behavior
of JavaScript, and that JavaScript is somewhat famous for having some peculiar
runtime behaviors.
JavaScript‚Äôs handling of `this` is indeed unusual:
    ts
    class MyClass {
      name = "MyClass";
      getName() {
        return this.name;
      }
    }
    const c = new MyClass();
    const obj = {
      name: "obj",
      getName: c.getName,
    };
    // Prints "obj", not "MyClass"
    console.log(obj.getName());
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA)
Long story short, by default, the value of `this` inside a function depends on
_how the function was called_. In this example, because the function was
called through the `obj` reference, its value of `this` was `obj` rather than
the class instance.
This is rarely what you want to happen! TypeScript provides some ways to
mitigate or prevent this kind of error.
### Arrow Functions
> Background Reading:  
>  [Arrow functions (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)  
>
If you have a function that will often be called in a way that loses its
`this` context, it can make sense to use an arrow function property instead of
a method definition:
    ts
    class MyClass {
      name = "MyClass";
      getName = () => {
        return this.name;
      };
    }
    const c = new MyClass();
    const g = c.getName;
    // Prints "MyClass" instead of crashing
    console.log(g());
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA)
This has some trade-offs:
  * The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript
  * This will use more memory, because each class instance will have its own copy of each function defined this way
  * You can‚Äôt use `super.getName` in a derived class, because there‚Äôs no entry in the prototype chain to fetch the base class method from
### `this` parameters
In a method or function definition, an initial parameter named `this` has
special meaning in TypeScript. These parameters are erased during compilation:
    ts
    // TypeScript input with 'this' parameter
    function fn(this: SomeType, x: number) {
      /* ... */
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA)
    js
    // JavaScript output
    function fn(x) {
      /* ... */
    }
TypeScript checks that calling a function with a `this` parameter is done so
with a correct context. Instead of using an arrow function, we can add a
`this` parameter to method definitions to statically enforce that the method
is called correctly:
    ts
    class MyClass {
      name = "MyClass";
      getName(this: MyClass) {
        return this.name;
      }
    }
    const c = new MyClass();
    // OK
    c.getName();
    // Error, would crash
    const g = c.getName;
    console.log(g());
    The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA)
This method makes the opposite trade-offs of the arrow function approach:
  * JavaScript callers might still use the class method incorrectly without realizing it
  * Only one function per class definition gets allocated, rather than one per class instance
  * Base method definitions can still be called via `super`.
## `this` Types
In classes, a special type called `this` refers _dynamically_ to the type of
the current class. Let‚Äôs see how this is useful:
    ts
    class Box {
      contents: string = "";
      set(value: string) {
    (method) Box.set(value: string): this
        this.contents = value;
        return this;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA)
Here, TypeScript inferred the return type of `set` to be `this`, rather than
`Box`. Now let‚Äôs make a subclass of `Box`:
    ts
    class ClearableBox extends Box {
      clear() {
        this.contents = "";
      }
    }
    const a = new ClearableBox();
    const b = a.set("hello");
    const b: ClearableBox
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA)
You can also use `this` in a parameter type annotation:
    ts
    class Box {
      content: string = "";
      sameAs(other: this) {
        return other.content === this.content;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA)
This is different from writing `other: Box` ‚Äî if you have a derived class, its
`sameAs` method will now only accept other instances of that same derived
class:
    ts
    class Box {
      content: string = "";
      sameAs(other: this) {
        return other.content === this.content;
      }
    }
    class DerivedBox extends Box {
      otherContent: string = "?";
    }
    const base = new Box();
    const derived = new DerivedBox();
    derived.sameAs(base);
    Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
      Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
      Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA)
### `this`-based type guards
You can use `this is Type` in the return position for methods in classes and
interfaces. When mixed with a type narrowing (e.g. `if` statements) the type
of the target object would be narrowed to the specified `Type`.
    ts
    class FileSystemObject {
      isFile(): this is FileRep {
        return this instanceof FileRep;
      }
      isDirectory(): this is Directory {
        return this instanceof Directory;
      }
      isNetworked(): this is Networked & this {
        return this.networked;
      }
      constructor(public path: string, private networked: boolean) {}
    }
    class FileRep extends FileSystemObject {
      constructor(path: string, public content: string) {
        super(path, false);
      }
    }
    class Directory extends FileSystemObject {
      children: FileSystemObject[];
    }
    interface Networked {
      host: string;
    }
    const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");
    if (fso.isFile()) {
      fso.content;
    const fso: FileRep
    } else if (fso.isDirectory()) {
      fso.children;
    const fso: Directory
    } else if (fso.isNetworked()) {
      fso.host;
    const fso: Networked & FileSystemObject
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA)
A common use-case for a this-based type guard is to allow for lazy validation
of a particular field. For example, this case removes an `undefined` from the
value held inside box when `hasValue` has been verified to be true:
    ts
    class Box<T> {
      value?: T;
      hasValue(): this is { value: T } {
        return this.value !== undefined;
      }
    }
    const box = new Box<string>();
    box.value = "Gameboy";
    box.value;
    (property) Box<string>.value?: string
    if (box.hasValue()) {
      box.value;
    (property) value: string
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA)
## Parameter Properties
TypeScript offers special syntax for turning a constructor parameter into a
class property with the same name and value. These are called _parameter
properties_ and are created by prefixing a constructor argument with one of
the visibility modifiers `public`, `private`, `protected`, or `readonly`. The
resulting field gets those modifier(s):
    ts
    class Params {
      constructor(
        public readonly x: number,
        protected y: number,
        private z: number
      ) {
        // No body necessary
      }
    }
    const a = new Params(1, 2, 3);
    console.log(a.x);
    (property) Params.x: number
    console.log(a.z);
    Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA)
## Class Expressions
> Background Reading:  
>  [Class expressions (MDN)](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/class)  
>
Class expressions are very similar to class declarations. The only real
difference is that class expressions don‚Äôt need a name, though we can refer to
them via whatever identifier they ended up bound to:
    ts
    const someClass = class<Type> {
      content: Type;
      constructor(value: Type) {
        this.content = value;
      }
    };
    const m = new someClass("Hello, world");
    const m: someClass<string>
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA)
## Constructor Signatures
JavaScript classes are instantiated with the `new` operator. Given the type of
a class itself, the [InstanceType](/docs/handbook/utility-
types.html#instancetypetype) utility type models this operation.
    ts
    class Point {
      createdAt: number;
      x: number;
      y: number
      constructor(x: number, y: number) {
        this.createdAt = Date.now()
        this.x = x;
        this.y = y;
      }
    }
    type PointInstance = InstanceType<typeof Point>
    function moveRight(point: PointInstance) {
      point.x += 5;
    }
    const point = new Point(3, 4);
    moveRight(point);
    point.x; // => 8
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA)
## `abstract` Classes and Members
Classes, methods, and fields in TypeScript may be _abstract_.
An _abstract method_ or _abstract field_ is one that hasn‚Äôt had an
implementation provided. These members must exist inside an _abstract class_ ,
which cannot be directly instantiated.
The role of abstract classes is to serve as a base class for subclasses which
do implement all the abstract members. When a class doesn‚Äôt have any abstract
members, it is said to be _concrete_.
Let‚Äôs look at an example:
    ts
    abstract class Base {
      abstract getName(): string;
      printName() {
        console.log("Hello, " + this.getName());
      }
    }
    const b = new Base();
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA)
We can‚Äôt instantiate `Base` with `new` because it‚Äôs abstract. Instead, we need
to make a derived class and implement the abstract members:
    ts
    class Derived extends Base {
      getName() {
        return "world";
      }
    }
    const d = new Derived();
    d.printName();
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA)
Notice that if we forget to implement the base class‚Äôs abstract members, we‚Äôll
get an error:
    ts
    class Derived extends Base {
    Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
      // forgot to do anything
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA)
### Abstract Construct Signatures
Sometimes you want to accept some class constructor function that produces an
instance of a class which derives from some abstract class.
For example, you might want to write this code:
    ts
    function greet(ctor: typeof Base) {
      const instance = new ctor();
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.
      instance.printName();
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA)
TypeScript is correctly telling you that you‚Äôre trying to instantiate an
abstract class. After all, given the definition of `greet`, it‚Äôs perfectly
legal to write this code, which would end up constructing an abstract class:
    ts
    // Bad!
    greet(Base);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA)
Instead, you want to write a function that accepts something with a construct
signature:
    ts
    function greet(ctor: new () => Base) {
      const instance = new ctor();
      instance.printName();
    }
    greet(Derived);
    greet(Base);
    Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
      Cannot assign an abstract constructor type to a non-abstract constructor type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA)
Now TypeScript correctly tells you about which class constructor functions can
be invoked - `Derived` can because it‚Äôs concrete, but `Base` cannot.
## Relationships Between Classes
In most cases, classes in TypeScript are compared structurally, the same as
other types.
For example, these two classes can be used in place of each other because
they‚Äôre identical:
    ts
    class Point1 {
      x = 0;
      y = 0;
    }
    class Point2 {
      x = 0;
      y = 0;
    }
    // OK
    const p: Point1 = new Point2();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA)
Similarly, subtype relationships between classes exist even if there‚Äôs no
explicit inheritance:
    ts
    class Person {
      name: string;
      age: number;
    }
    class Employee {
      name: string;
      age: number;
      salary: number;
    }
    // OK
    const p: Person = new Employee();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA)
This sounds straightforward, but there are a few cases that seem stranger than
others.
Empty classes have no members. In a structural type system, a type with no
members is generally a supertype of anything else. So if you write an empty
class (don‚Äôt!), anything can be used in place of it:
    ts
    class Empty {}
    function fn(x: Empty) {
      // can't do anything with 'x', so I won't
    }
    // All OK!
    fn(window);
    fn({});
    fn(fn);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [ModulesHow JavaScript handles communicating across file
boundaries.](/docs/handbook/2/modules.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Classes.md) ‚ù§
Contributors to this page:  
RC
OT
HA
MR
U
22+
Last updated: Sep 16, 2024  
Was this page helpful?
# Conditional Types
At the heart of most useful programs, we have to make decisions based on
input. JavaScript programs are no different, but given the fact that values
can be easily introspected, those decisions are also based on the types of the
inputs. _Conditional types_ help describe the relation between the types of
inputs and outputs.
    ts
    interface Animal {
      live(): void;
    }
    interface Dog extends Animal {
      woof(): void;
    }
    type Example1 = Dog extends Animal ? number : string;
    type Example1 = number
    type Example2 = RegExp extends Animal ? number : string;
    type Example2 = string
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChlkdgA3CACgEoAuZcge2ABMBuQgX0NElkQoAIkwDmyCAA9IIVgGc0GbHiIkA7kyYxaDZm049CYAJ4AHFAFFJcTKZwQAjMgC8yEeKkz5irLmQB+ZBAAV0wAI2hkBjkwKFBRTgB6RJJkAD1-QiMzS2tbewAmF2QAJQhRK1MJaQhZBXRfPECQ8Mjo2PiklJIMoA)
Conditional types take a form that looks a little like conditional expressions
(`condition ? trueExpression : falseExpression`) in JavaScript:
    ts
      SomeType extends OtherType ? TrueType : FalseType;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgChRIoB5YACwgCdVTNcDi0pkaBXFVxvIk6ADEsAGwDO3Btj4tSMYBwBmiqOkJQoAek1QAtPoDGHYPt3rYiSdAgAPYBBwATMeSq160APxtOVqAC4oYXErfCA)
When the type on the left of the `extends` is assignable to the one on the
right, then you‚Äôll get the type in the first branch (the ‚Äútrue‚Äù branch);
otherwise you‚Äôll get the type in the latter branch (the ‚Äúfalse‚Äù branch).
From the examples above, conditional types might not immediately seem useful -
we can tell ourselves whether or not `Dog extends Animal` and pick `number` or
`string`! But the power of conditional types comes from using them with
generics.
For example, let‚Äôs take the following `createLabel` function:
    ts
    interface IdLabel {
      id: number /* some fields */;
    }
    interface NameLabel {
      name: string /* other fields */;
    }
    function createLabel(id: number): IdLabel;
    function createLabel(name: string): NameLabel;
    function createLabel(nameOrId: string | number): IdLabel | NameLabel;
    function createLabel(nameOrId: string | number): IdLabel | NameLabel {
      throw "unimplemented";
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbJIw6IBGGA8QyBFAg4SA0CAApKGnomaABKGgwQ-Ck3Dy8fPwCgiETQ3X4DI1M45FV1XAJk909vX39A4PL8XL0AeSgMAuMQMwAfWkZmYoTG5D7S7MbK1JqM+onNZv42ju5C7tH+6KghrBGxvUTiMmRrKB4Ad2QAIndgBgAHfAh+cAh0K+cgA)
These overloads for createLabel describe a single JavaScript function that
makes a choice based on the types of its inputs. Note a few things:
  1. If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.
  2. We have to create three overloads: one for each case when we‚Äôre _sure_ of the type (one for `string` and one for `number`), and one for the most general case (taking a `string | number`). For every new type `createLabel` can handle, the number of overloads grows exponentially.
Instead, we can encode that logic in a conditional type:
    ts
    type NameOrId<T extends number | string> = T extends number
      ? IdLabel
      : NameLabel;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbNatkAWk8I6YT+5JgAJ4ADip6APJQGAA8ACrIEAAekCAitIzMyAA+3EamAHzIALzI8UkpafRM0GTIAPxoWLgEtTSq6s34EkA)
We can then use that conditional type to simplify our overloads down to a
single function with no overloads.
    ts
    function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
      throw "unimplemented";
    }
    let a = createLabel("typescript");
    let a: NameLabel
    let b = createLabel(2.8);
    let b: IdLabel
    let c = createLabel(Math.random() ? "hello" : 42);
    let c: NameLabel | IdLabel
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbLABPAA4q9AeSgYAPAAqyBAAHpAgIrSMzMgAPtxGpgB8yAC8yMFhEVH0TNBkyAD8aFi4BIU0qurl+FKsrMgAtC0IdGAtTSQwdCAIYMA8IMgIUBBwkBoEQSHhEJGiebEJhsYgJskAFJS+1fqZAJRVPn7oQanayNZQPADuyABEvcAM7vgQ-OAQ6A-OJCTvMDIODpEZjCYQKb4TYPNyeLijYDuMAPA71RrIAB6RX+gOQOFBo3Gk1qmwATAA6AAcaJIDXI2NxECBCEJ4JJmk2AFkJlYKVA4JE+JsDsVHjZ8PgeA9kDQACxk2n0rFFIA)
### Conditional Type Constraints
Often, the checks in a conditional type will provide us with some new
information. Just like narrowing with type guards can give us a more specific
type, the true branch of a conditional type will further constrain generics by
the type we check against.
For example, let‚Äôs take the following:
    ts
    type MessageOf<T> = T["message"];
    Type '"message"' cannot be used to index type 'T'.2536Type '"message"' cannot be used to index type 'T'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMA2AUAC4CeADpKALKSKICGA5pAPIBmAPACoB8oAvKBwDaAIgC21Oo2EBdANxA)
In this example, TypeScript errors because `T` isn‚Äôt known to have a property
called `message`. We could constrain `T`, and TypeScript would no longer
complain:
    ts
    type MessageOf<T extends { message: unknown }> = T["message"];
    interface Email {
      message: string;
    }
    type EmailMessageContents = MessageOf<Email>;
    type EmailMessageContents = string
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCpQgA9gIA7AE3igG8oBbBZNALigFdSBrUgewHdSUAL4A+KAF4ouANoAiBolQRZAXQDcAKA0BLUiQBOmJAGNoAUTpJtAGxoao9Rktbxg+3Sk1CtoSFAtW1nCKaADCPHpkwFSSwUwYOAE2IpoA9KkOUAB6APxAA)
However, what if we wanted `MessageOf` to take any type, and default to
something like `never` if a `message` property isn‚Äôt available? We can do this
by moving the constraint out and introducing a conditional type:
    ts
    type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;
    interface Email {
      message: string;
    }
    interface Dog {
      bark(): void;
    }
    type EmailMessageContents = MessageOf<Email>;
    type EmailMessageContents = string
    type DogMessageContents = MessageOf<Dog>;
    type DogMessageContents = never
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCoD4oBeKXKCAD2AgDsATeKAbygFsFk0AuKAVxoDWNAPYB3GlAC+UAPykA2gCJ2iVBEUBdKDxoQAbhABOAbgBQpgJY1qhzEgDG0AKKskFgDbNTUNhzU94YEMrFDNJcysbO0coABFhFC8fACMkQwEACgBKHj1hCzow81BIKBc3dzhVNABhYWtaYEYSKs4MHHKPfDMAeh6fKAA9GWLwaHiUVrU6hutm2D80LGwJ7tM+geGgA)
Within the true branch, TypeScript knows that `T` _will_ have a `message`
property.
As another example, we could also write a type called `Flatten` that flattens
array types to their element types, but leaves them alone otherwise:
    ts
    type Flatten<T> = T extends any[] ? T[number] : T;
    // Extracts out the element type.
    type Str = Flatten<string[]>;
    type Str = string
    // Leaves the type alone.
    type Num = Flatten<number>;
    type Num = number
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFQHxQLxSZQQAeKqAJgM5QKogDaAulAPyEOoCuAtgEYQATiwBchANwAoSQHoZUAKJlBCAMbAaAey7AowABbQIcCDzS7QkAHSTL0AMrBB+WImRp0VJwEtUAc2ZsKTkoUIA9VmkQgBkIBAA3CBoDaDtaOE1UCBs0gDleF3gkcnRufiEg2Xlw1iA)
When `Flatten` is given an array type, it uses an indexed access with `number`
to fetch out `string[]`‚Äôs element type. Otherwise, it just returns the type it
was given.
### Inferring Within Conditional Types
We just found ourselves using conditional types to apply constraints and then
extract out types. This ends up being such a common operation that conditional
types make it easier.
Conditional types provide us with a way to infer from types we compare against
in the true branch using the `infer` keyword. For example, we could have
inferred the element type in `Flatten` instead of fetching it out ‚Äúmanually‚Äù
with an indexed access type:
    ts
    type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFXBAfFAXim0iggA8VUATAZygEEAnJhEdAS1QDMImoAkigC2+APyCRUAFzEcAbiA)
Here, we used the `infer` keyword to declaratively introduce a new generic
type variable named `Item` instead of specifying how to retrieve the element
type of `Type` within the true branch. This frees us from having to think
about how to dig through and probing apart the structure of the types we‚Äôre
interested in.
We can write some useful helper type aliases using the `infer` keyword. For
example, for simple cases, we can extract the return type out from function
types:
    ts
    type GetReturnType<Type> = Type extends (...args: never[]) => infer Return
      ? Return
      : never;
    type Num = GetReturnType<() => number>;
    type Num = number
    type Str = GetReturnType<(x: string) => string>;
    type Str = string
    type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;
    type Bools = boolean[]
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAebkAfFALxQHQQAewE6AJgM5QAUAdBwIaoDmjAXFHQQAbhFQBtALoBKUsQCW6AGbioSYGnQAoKFAD86lBl1RBwsagDc27aEhQAcsgC2pWPA1aKuFnJLE6K4ARuKENgD0EXpQAHr6tvbQAMrAqO5wiMZYOL5UgoxpSjz+xIWoxeHaUTHxiThQAEIA9s0ANsxkmV4YPiycgsGtbRCc6AA0UMGDw6PopVOzY9JVNXrxQA)
When inferring from a type with multiple call signatures (such as the type of
an overloaded function), inferences are made from the _last_ signature (which,
presumably, is the most permissive catch-all case). It is not possible to
perform overload resolution based on a list of argument types.
    ts
    declare function stringOrNum(x: string): number;
    declare function stringOrNum(x: number): string;
    declare function stringOrNum(x: string | number): string | number;
    type T1 = ReturnType<typeof stringOrNum>;
    type T1 = string | number
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGcMYtUBzAeRgDlkBbACgA8AuQ40sgSjdXoCMQMANwAoUJFgIU6bHnYlyVWo1bw+dQTB4LOYidDhI0mXPiKLKNeszYXO8AD7qBQnffJOXmoWNEYATwAHBAAVAEZ4AF54ACUQDGQYVFDgkAAeQJCcRF0lazoAPjEAehL4CoA9AH4gA)
## Distributive Conditional Types
When conditional types act on a generic type, they become _distributive_ when
given a union type. For example, take the following:
    ts
    type ToArray<Type> = Type extends any ? Type[] : never;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcQA)
If we plug a union type into `ToArray`, then the conditional type will be
applied to each member of that union.
    ts
    type ToArray<Type> = Type extends any ? Type[] : never;
    type StrArrOrNumArr = ToArray<string | number>;
    type StrArrOrNumArr = string[] | number[]
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKEmhIUAMrAkyJAHkkAOQCuAWxWFYiFOgx0lASyoBzKAB9BugEZjcUgPRuoXgHqsgA)
What happens here is that `ToArray` distributes on:
    ts
      string | number;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmUAHyjdcAIwjwA3EA)
and maps over each member type of the union, to what is effectively:
    ts
      ToArray<string> | ToArray<number>;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKFCQoAZWBJkSAPJIAcgFcAtssKSoUAPRGoAWgsBjTcAtmDsRCnQY6igJZUA5vgA+j5RcqHQAjMVxxIA)
which leaves us with:
    ts
      string[] | number[];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmA2gF0oAHyjdcAIwjwhAbiA)
Typically, distributivity is the desired behavior. To avoid that behavior, you
can surround each side of the `extends` keyword with square brackets.
    ts
    type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
    // 'ArrOfStrOrNum' is no longer a union.
    type ArrOfStrOrNum = ToArrayNonDist<string | number>;
    type ArrOfStrOrNum = (string | number)[]
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgHJwHYBECWAzsADwzgQB8UAvFANrmQC6UEAHsBNgCaEOpsIVgH5YFeqwBcUbBABuEJAG4AUKoD0GqAHJkSAPIAzAMrBDSDAFcAtjqhFZcKABscAcyVRUUK9nw4AHSqoJBQ+sZmFtY2tLCIKOhYeESkxEj42O5QAD6ytgBGSpRqWlDlAHoiQA)
### [Indexed Access TypesUsing Type['a'] syntax to access a subset of a
type.](/docs/handbook/2/indexed-access-types.html)
### [Mapped TypesGenerating types by re-using an existing
type.](/docs/handbook/2/mapped-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Conditional Types.md) ‚ù§
Contributors to this page:  
OT
BK
GF
SF
NM
9+
Last updated: Sep 16, 2024  
Was this page helpful?
# Everyday Types
In this chapter, we‚Äôll cover some of the most common types of values you‚Äôll
find in JavaScript code, and explain the corresponding ways to describe those
types in TypeScript. This isn‚Äôt an exhaustive list, and future chapters will
describe more ways to name and use other types.
Types can also appear in many more _places_ than just type annotations. As we
learn about the types themselves, we‚Äôll also learn about the places where we
can refer to these types to form new constructs.
We‚Äôll start by reviewing the most basic and common types you might encounter
when writing JavaScript or TypeScript code. These will later form the core
building blocks of more complex types.
## The primitives: `string`, `number`, and `boolean`
JavaScript has three very commonly used
[primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive):
`string`, `number`, and `boolean`. Each has a corresponding type in
TypeScript. As you might expect, these are the same names you‚Äôd see if you
used the JavaScript `typeof` operator on a value of those types:
  * `string` represents string values like `"Hello, world"`
  * `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there‚Äôs no equivalent to `int` or `float` \- everything is simply `number`
  * `boolean` is for the two values `true` and `false`
> The type names `String`, `Number`, and `Boolean` (starting with capital
> letters) are legal, but refer to some special built-in types that will very
> rarely appear in your code. _Always_ use `string`, `number`, or `boolean`
> for types.
## Arrays
To specify the type of an array like `[1, 2, 3]`, you can use the syntax
`number[]`; this syntax works for any type (e.g. `string[]` is an array of
strings, and so on). You may also see this written as `Array<number>`, which
means the same thing. We‚Äôll learn more about the syntax `T<U>` when we cover
_generics_.
> Note that `[number]` is a different thing; refer to the section on
> [Tuples](/docs/handbook/2/objects.html#tuple-types).
## `any`
TypeScript also has a special type, `any`, that you can use whenever you don‚Äôt
want a particular value to cause typechecking errors.
When a value is of type `any`, you can access any properties of it (which will
in turn be of type `any`), call it like a function, assign it to (or from) a
value of any type, or pretty much anything else that‚Äôs syntactically legal:
    ts
    let obj: any = { x: 0 };
    // None of the following lines of code will throw compiler errors.
    // Using `any` disables all further type checking, and it is assumed
    // you know the environment better than TypeScript.
    obj.foo();
    obj();
    obj.bar = 100;
    obj = "hello";
    const n: number = obj;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gRgVgLggQwHYE8IF4IG8IAeSADBAL4DcAsAFAD0dEAclKiNAGYRgAW7HUYMCgB3AJaoA5hGASQAZ04QAxlAAm7cUO48ATqJVQAtgAcxoXRBC79u+QDpaDCAFV5E6QAM06TxDVi8sgwoIrI2hwArrq81tzoJuzKfMoA1h4ANCioahBikIEo8vKRRiBqTozoUJEQqagGsVaoAG5i+qhlqJAw4GBxvGgQACoJIADKyrpiJmCONLBw9gJQABQAlNQL8Btbi-YwyJY4AIzExHvw2BAARHxCUDdbqqjykKhIqKW9x9DwFEA)
The `any` type is useful when you don‚Äôt want to write out a long type just to
convince TypeScript that a particular line of code is okay.
### `noImplicitAny`
When you don‚Äôt specify a type, and TypeScript can‚Äôt infer it from context, the
compiler will typically default to `any`.
You usually want to avoid this, though, because `any` isn‚Äôt type-checked. Use
the compiler flag [`noImplicitAny`](/tsconfig#noImplicitAny) to flag any
implicit `any` as an error.
## Type Annotations on Variables
When you declare a variable using `const`, `var`, or `let`, you can optionally
add a type annotation to explicitly specify the type of the variable:
    ts
    let myName: string = "Alice";
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngcgQyiAXBAzmATgSwHYDmEAvBAEQCCwOAxiGQNwCwAUAPRsRfdcB6-A-hAAqMAA4gICPHgD2YBGByy8QA)
> TypeScript doesn‚Äôt use ‚Äútypes on the left‚Äù-style declarations like `int x =
> 0;` Type annotations will always go _after_ the thing being typed.
In most cases, though, this isn‚Äôt needed. Wherever possible, TypeScript tries
to automatically _infer_ the types in your code. For example, the type of a
variable is inferred based on the type of its initializer:
    ts
    // No type annotation needed -- 'myName' inferred as type 'string'
    let myName = "Alice";
    [Try](https://www.typescriptlang.org/play/#code/PTAEDkHtQFwTwA4FNQEMB27I1TAlpOqOkkgCbmgC0VoA5ALZzioNJ2h7oBmSATn0qoAzrEQo6wmHy4BzOgFgAUABskMUExZtQAXlAAiAIIq8AYyQGA3EA)
For the most part you don‚Äôt need to explicitly learn the rules of inference.
If you‚Äôre starting out, try using fewer type annotations than you think - you
might be surprised how few you need for TypeScript to fully understand what‚Äôs
going on.
## Functions
Functions are the primary means of passing data around in JavaScript.
TypeScript allows you to specify the types of both the input and output values
of functions.
### Parameter Type Annotations
When you declare a function, you can add type annotations after each parameter
to declare what types of parameters the function accepts. Parameter type
annotations go after the parameter name:
    ts
    // Parameter type annotation
    function greet(name: string) {
      console.log("Hello, " + name.toUpperCase() + "!!");
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHVEgngBwaSA7fAeyUiQEsj8BYAKADMBXfAYwqtAHNoFkAKfPAQAuUAGck0cvk4BKUAG86oUCBXqNm9QD1de3ctAsqYogBsEAOjNFOfAEQAJBGZsAaUPdABqUIMSWSEQAqlg40ADCkGIIfPK+9gCEifayANx0AL5AA)
When a parameter has a type annotation, arguments to that function will be
checked:
    ts
    // Would be a runtime error if executed!
    greet(42);
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgDmNkrABRNKAW0ipEraOyY8AlKgBucdkQDchEKAC0e0g1Z6dWsAHU4DckVAAjWpVDRmHcaBjxoodnXcAPMkNIIgBCQj5IAUEsNHl1IA)
> Even if you don‚Äôt have type annotations on your parameters, TypeScript will
> still check that you passed the right number of arguments.
### Return Type Annotations
You can also add return type annotations. Return type annotations appear after
the parameter list:
    ts
    function getFavoriteNumber(): number {
      return 26;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQGIEMBucBOMUqAciALYBGq+AFAJQBciYF1+iA3gLABQiiAPSCBoseIliAejNky+A-OhD4kAJgBsAbj4BfIA)
Much like variable type annotations, you usually don‚Äôt need a return type
annotation because TypeScript will infer the function‚Äôs return type based on
its `return` statements. The type annotation in the above example doesn‚Äôt
change anything. Some codebases will explicitly specify a return type for
documentation purposes, to prevent accidental changes, or just for personal
preference.
#### Functions Which Return Promises
If you want to annotate the return type of a function which returns a promise,
you should use the `Promise` type:
    ts
    async function getFavoriteNumber(): Promise<number> {
      return 26;
    }
    [Try](https://www.typescriptlang.org/play/#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkBiwAbugE6rK4ByCAtgEa5kAUAlAFwwAKZ6dqELgA8EekzIA+GAG8AsACgYMMvgRksAJgBsAbkUBfIA)
### Anonymous Functions
Anonymous functions are a little bit different from function declarations.
When a function appears in a place where TypeScript can determine how it‚Äôs
going to be called, the parameters of that function are automatically given
types.
Here‚Äôs an example:
    ts
    const names = ["Alice", "Bob", "Eve"];
    // Contextual typing for function - parameter s inferred to have type string
    names.forEach(function (s) {
      console.log(s.toUpperCase());
    });
    // Contextual typing also applies to arrow functions
    names.forEach((s) => {
      console.log(s.toUpperCase());
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYCwAoAYzgDtEAXUEgQwFtJFQBeUAbQCIBBAGwEtDI7ADSh2AITgAjYaICiAN0EBdANwECIUAGFS5SAA9yAV2rdQ5AJ4AHXiQDmoAGYInRkoXK9SoALSgr1NB0kHrQoIy2jjDQkAAm5nCgABbUiubWkOHk0LZ2BDT0iAB0ztCy1IRJABSObh5eJKBViACUoADeBKCgxGRw3JBF3HB2zUXkcACqVlYwWtSIkFUtLWr4AL6r6viaOiR6hiZmljb2oKaIidQzfAwJ57BwAO6u7p6kiPnBxaXllVXNNpMAB8HS6PQ+-UGw1GxQm01m0Hmi2WWw2qyAA)
Even though the parameter `s` didn‚Äôt have a type annotation, TypeScript used
the types of the `forEach` function, along with the inferred type of the
array, to determine the type `s` will have.
This process is called _contextual typing_ because the _context_ that the
function occurred within informs what type it should have.
Similar to the inference rules, you don‚Äôt need to explicitly learn how this
happens, but understanding that it _does_ happen can help you notice when type
annotations aren‚Äôt needed. Later, we‚Äôll see more examples of how the context
that a value occurs in can affect its type.
## Object Types
Apart from primitives, the most common sort of type you‚Äôll encounter is an
_object type_. This refers to any JavaScript value with properties, which is
almost all of them! To define an object type, we simply list its properties
and their types.
For example, here‚Äôs a function that takes a point-like object:
    ts
    // The parameter's type annotation is an object type
    function printCoord(pt: { x: number; y: number }) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    printCoord({ x: 3, y: 7 });
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIOQGdQMBPOWBAO3IHsMEMBLK80egi0KgIwCtoBjDIRLQAsACgAZgFdyAxszhJ65DAGEqVJABMAFHAwAuUAG9QADyPkpqTtgDcoIpeu2koAL4BKE+NCgQfoFBwSF+AHoRkVHRMZG+oHxMeFQANtAAdClUAOY6AERQsImaWsp00PjmoABuCClSsKygeaAA1PAY6WaedvGJ5MlpmTn5hQka2mVYlUQ1dQ0sBC3t+ulEPeLu4orKahO6phagAMwANI5GAOwePUA)
Here, we annotated the parameter with a type with two properties - `x` and `y`
\- which are both of type `number`. You can use `,` or `;` to separate the
properties, and the last separator is optional either way.
The type part of each property is also optional. If you don‚Äôt specify a type,
it will be assumed to be `any`.
### Optional Properties
Object types can also specify that some or all of their properties are
_optional_. To do this, add a `?` after the property name:
    ts
    function printName(obj: { first: string; last?: string }) {
      // ...
    }
    // Both OK
    printName({ first: "Bob" });
    printName({ first: "Alice", last: "Alisson" });
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAcgQwLYCmAFHAEYBWAXIgN6LAyoDOU1L6YA5gNyIA2OFgH42UDp0QBfAJS0AsAChEiAPQrEAOi2LJitYgBCcKAAtEAeQDSitBmz5idBs1aIAREdJup07jY72hEROjCzUbgCCfDAQBG4ANPyCrpHRTEwI3jLcQA)
In JavaScript, if you access a property that doesn‚Äôt exist, you‚Äôll get the
value `undefined` rather than a runtime error. Because of this, when you
_read_ from an optional property, you‚Äôll have to check for `undefined` before
using it.
    ts
    function printName(obj: { first: string; last?: string }) {
      // Error - might crash if 'obj.last' wasn't provided!
      console.log(obj.last.toUpperCase());
    'obj.last' is possibly 'undefined'.18048'obj.last' is possibly 'undefined'.
      if (obj.last !== undefined) {
        // OK
        console.log(obj.last.toUpperCase());
      }
      // A safe alternative using modern JavaScript syntax:
      console.log(obj.last?.toUpperCase());
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMAWDBYAKADMBXAOwGMAXASznNAAdpbzqA5AQwFtIAKOACMAVqgDeoYrSTVUiaq3IBzANygANlwUB+eYrbLQAXwCUocUVCgQoAKKwEoALSgetZQAtqoStG2eoLTEoADkwiIAdFoKoaAA7trkoT4scAButAAmkFkAhFa+DIhwGpDRcMqCotHa1JHUcACqTEwwAMLaAqamqoXBoNVRMT55ALxjoBQ50uS55paE1ta2APIA0oXWlMWl5RqVQ7UKDc2tHV38PX1LJkSFtgCCoIhcxJCgXBrUMORcdOkPqREIY3HActBGAApLjpLgAZT8tCYPkQAE92FwAB7IQo7cglMoVKoRY7UHSnFptaCdRDdXpEYxAA)
## Union Types
TypeScript‚Äôs type system allows you to build new types out of existing ones
using a large variety of operators. Now that we know how to write a few types,
it‚Äôs time to start _combining_ them in interesting ways.
### Defining a Union Type
The first way to combine types you might see is a _union_ type. A union type
is a type formed from two or more other types, representing values that may be
_any one_ of those types. We refer to each of these types as the union‚Äôs
_members_.
Let‚Äôs write a function that can operate on strings or numbers:
    ts
    function printId(id: number | string) {
      console.log("Your ID is: " + id);
    }
    // OK
    printId(101);
    // OK
    printId("202");
    // Error
    printId({ myID: 22342 });
    Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.2345Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAkgCYAUNnqZEgFsARjFAAfUIiosyAcwCUoAN6FQoCvURwANpAB0uuPO4AiAJpwS0UOwAioGilBnQAaiedFAbkIBfQhBQAHkAaUJmVg4eAEYABljfILBwyLkY8zR4tDNkgmCAUVgEdOiubhVQIQBPB1Q0TCw0UH9fIA)
### Working with Union Types
It‚Äôs easy to _provide_ a value matching a union type - simply provide a type
matching any of the union‚Äôs members. If you _have_ a value of a union type,
how do you work with it?
TypeScript will only allow an operation if it is valid for _every_ member of the union. For example, if you have the union `string | number`, you can‚Äôt use methods that are only available on `string`:
    ts
    function printId(id: number | string) {
      console.log(id.toUpperCase());
    Property 'toUpperCase' does not exist on type 'string | number'.
      Property 'toUpperCase' does not exist on type 'number'.2339Property 'toUpperCase' does not exist on type 'string | number'.
      Property 'toUpperCase' does not exist on type 'number'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoAMwFcA7AYwBcBLOU0AB2mtMoEkATACmo9VOIBbAEYxQAH1CJKzUgHMAlKADeBUKHJ1EcADaQAdDrhyeHfZTgBVBgxgBhAIaJIXBQoDcBAL5A)
The solution is to _narrow_ the union with code, the same as you would in
JavaScript without type annotations. _Narrowing_ occurs when TypeScript can
deduce a more specific type for a value based on the structure of the code.
For example, TypeScript knows that only a `string` value will have a `typeof`
value `"string"`:
    ts
    function printId(id: number | string) {
      if (typeof id === "string") {
        // In this branch, id is of type 'string'
        console.log(id.toUpperCase());
      } else {
        // Here, id is of type 'number'
        console.log(id);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAkgEwBQw4BciYIAtgEYCmqiAPogM5TpgDmAlIgN4CwAKESIYwRHigBPZNThjCiALzLEAIhZt2q7vyHDEAegOIsSKAAsYTRJVQBDSOYA0InCOtzEUmYgDkGjHZfQX1ECAQmOAAbagA6KLh2AhxYqDgAVWQZVABhOyZqPE5OAG4QxABfRGoogt5y4SNEAAlaahcFK0RPb2o-MipaYL1hcLBImPjE5NLyisEKoA)
Another example is to use a function like `Array.isArray`:
    ts
    function welcomePeople(x: string[] | string) {
      if (Array.isArray(x)) {
        // Here: 'x' is 'string[]'
        console.log("Hello, " + x.join(" and "));
      } else {
        // Here: 'x' is 'string'
        console.log("Welcome lone traveler " + x);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwKYBsJwLaoAqpwAO6qAFAB4BciAzlAE4xgDmA2gLqIA+djzLAJSIA3gFgAUIkQxgiMgEEGDAIYBPAHQxaS1WsqDh4qdMQB6M4gASqBqhoByCg5m1ED+k1acHk04iwwWjhSDXQ4FjIAIht0cIAaRCjEAGpECg0AKzhmaMQVMAATJMMAbj9EAF9EDFpUUQrpC2tbe3dnV3dPAV8TaUDg0PDIqIB1DCxcRHCwesYVADcMWyTU9MFyk0rJSqA)
Notice that in the `else` branch, we don‚Äôt need to do anything special - if
`x` wasn‚Äôt a `string[]`, then it must have been a `string`.
Sometimes you‚Äôll have a union where all the members have something in common.
For example, both arrays and strings have a `slice` method. If every member in
a union has a property in common, you can use that property without narrowing:
    ts
    // Return type is inferred as number[] | string
    function getFirstThree(x: number[] | string) {
      return x.slice(0, 3);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMBcFcCcB2poE8AOlQEsDOPEAzSeeSAE1AEN9FYBbAIxIG0BdUAH1F2nm0QBzALAAoQrEQBjaNgD2yQTABi2eLwAqACzKQAFAA8AXKDpNWHbr35CAlKADeY0KDJwkoAwDpcAG2xS+gAMADSgAMy2ANxiAL5AA)
> It might be confusing that a _union_ of types appears to have the _intersection_ of those types‚Äô properties. This is not an accident - the name _union_ comes from type theory. The _union_ `number | string` is composed by taking the union _of the values_ from each type. Notice that given two sets with corresponding facts about each set, only the _intersection_ of those facts applies to the _union_ of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about _every_ person is that they must be wearing a hat.
## Type Aliases
We‚Äôve been using object types and union types by writing them directly in type
annotations. This is convenient, but it‚Äôs common to want to use the same type
more than once and refer to it by a single name.
A _type alias_ is exactly that - a _name_ for any _type_. The syntax for a
type alias is:
    ts
    type Point = {
      x: number;
      y: number;
    };
    // Exactly the same as the earlier example
    function printCoord(pt: Point) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    printCoord({ x: 100, y: 100 });
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbwLACgpQAeAXFEgK4C2ARhAE4DceBIpFN9TuAvl3gPT8oAUUIBDAMbAANiCjAAFtADOYytDHL5SqBDF1pCervGUw0iHgBm5JFIRwkUMHWTAAwnDh0AJgAowYFJ4NwBKLGYoCUdlOAsAOmk4AHM-ACIAFR1o7x9kMWAIAHItQigANzFpcmgELTSoAGpnYHjCUK4CaKRYhKTUzOyvX3zCkqg5Sura+qaW+JAOvG48PBc3T1y-TCJSAEYABgOAGgn9o6huDqA)
You can actually use a type alias to give a name to any type at all, not just
an object type. For example, a type alias can name a union type:
    ts
    type ID = number | string;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAkgIlAvFAdgVwLYCMICcoA+UAzsLgJYoDmA3EA)
Note that aliases are _only_ aliases - you cannot use type aliases to create
different/distinct ‚Äúversions‚Äù of the same type. When you use the alias, it‚Äôs
exactly as if you had written the aliased type. In other words, this code
might _look_ illegal, but is OK according to TypeScript because both types are
aliases for the same type:
    ts
    type UserInputSanitizedString = string;
    function sanitizeInput(str: string): UserInputSanitizedString {
      return sanitize(str);
    }
    // Create a sanitized input
    let userInput = sanitizeInput(getInput());
    // Can still be re-assigned with a string though
    userInput = "new input";
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBJVAB2QwAoBKALngGcMYtUCBuAWAChRIsBCnTY8zKKizYAXiGosYjRewINmrVT14B6HfAC0RsFSMG+GAJ7kEAVSYgYZShgDKk6VjnBXmjvABeDTYObT4RTFx8Jg9ZEGcqBVZlPzVGe0cEt1ivEB9U+ABvPnh4OAxkGGicuSSYWm0AXz4+PXgAYTgoDAQoCSk44Hh2Fz4IYnhkBycKKkD+zzks6iJSWZpaBpbdfXbJDSwICHgAIwQ4AygmJiwCVDz4AHdpAAt4PpV-DBecZAIXvhTTLreYAInuj2G61BnCAA)
## Interfaces
An _interface declaration_ is another way to name an object type:
    ts
    interface Point {
      x: number;
      y: number;
    }
    function printCoord(pt: Point) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    printCoord({ x: 100, y: 100 });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwLABQyyAHgFzIgCuAtgEbQDchxAnhdfU4QL6GEwqIBGGDoQyAA5QsAYXTooAEwAUksBQxYAlLhbIE4gM7oANhAB0p9AHMVAIgAqACxSHFS0HEgByI6WQANzhTKhRgf3tkAGopMAsSbWYiA2MzS2s7J1dUjy9ff1YgkLDkCOQo2PULViTefgJpOQVlFRxSCgBGAAZugBpkdmQe7uQeJKA)
Just like when we used a type alias above, the example works just as if we had
used an anonymous object type. TypeScript is only concerned with the
_structure_ of the value we passed to `printCoord` \- it only cares that it
has the expected properties. Being concerned only with the structure and
capabilities of types is why we call TypeScript a _structurally typed_ type
system.
### Differences Between Type Aliases and Interfaces
Type aliases and interfaces are very similar, and in many cases you can choose
between them freely. Almost all features of an `interface` are available in
`type`, the key distinction is that a type cannot be re-opened to add new
properties vs an interface which is always extendable.
`Interface` | `Type`  
---|---  
Extending an interface `
    interface Animal {
      name: string;
    }  
    interface Bear extends Animal {
      honey: boolean;
    }  
    const bear = getBear();
    bear.name;
    bear.honey;
` |  Extending a type via intersections `
    type Animal = {
      name: string;
    }  
    type Bear = Animal & { 
      honey: boolean;
    }  
    const bear = getBear();
    bear.name;
    bear.honey;
`  
Adding new fields to an existing interface `
    interface Window {
      title: string;
    }  
    interface Window {
      ts: TypeScriptAPI;
    }  
    const src = 'const a = "Hello World"';
    window.ts.transpileModule(src, {});
` |  A type cannot be changed after being created `
    type Window = {
      title: string;
    }  
    type Window = {
      ts: TypeScriptAPI;
    }  
     // Error: Duplicate identifier 'Window'.  
`  
You‚Äôll learn more about these concepts in later chapters, so don‚Äôt worry if
you don‚Äôt understand all of these right away.
  * Prior to TypeScript version 4.2, type alias names [_may_ appear in error messages](/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA), sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.
  * Type aliases may not participate [in declaration merging, but interfaces can](/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA).
  * Interfaces may only be used to [declare the shapes of objects, not rename primitives](/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA).
  * Interface names will [_always_ appear in their original form](/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA) in error messages, but _only_ when they are used by name.
  * Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections) than type aliases with intersections
For the most part, you can choose based on personal preference, and TypeScript
will tell you if it needs something to be the other kind of declaration. If
you would like a heuristic, use `interface` until you need to use features
from `type`.
## Type Assertions
Sometimes you will have information about the type of a value that TypeScript
can‚Äôt know about.
For example, if you‚Äôre using `document.getElementById`, TypeScript only knows
that this will return _some_ kind of `HTMLElement`, but you might know that
your page will always have an `HTMLCanvasElement` with a given ID.
In this situation, you can use a _type assertion_ to specify a more specific
type:
    ts
    const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgExGAFc4BTMKAOgHMyoBRAGzPMoCEEBJfACgCI4KAJZgA+sDSYI-AJQwsMABIAVALIAZVBizNWFKAG4gA)
Like a type annotation, type assertions are removed by the compiler and won‚Äôt
affect the runtime behavior of your code.
You can also use the angle-bracket syntax (except if the code is in a `.tsx`
file), which is equivalent:
    ts
    const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgHgAkAVAWQBlUMsBRAGwFM4GwoA+AExGAFdnWAdAHMGUekxZQAQggCSHABQAiOCgCWYAPrA0mCEoCUAbiA)
> Reminder: Because type assertions are removed at compile-time, there is no
> runtime checking associated with a type assertion. There won‚Äôt be an
> exception or `null` generated if the type assertion is wrong.
TypeScript only allows type assertions which convert to a _more specific_ or
_less specific_ version of a type. This rule prevents ‚Äúimpossible‚Äù coercions
like:
    ts
    const x = "hello" as number;
    Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.2352Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCsaCwAoAYzgDtEAXUAD1AF5QAiAC0gBtW4HQBDRUEgK4BbAEYwA3EA)
Sometimes this rule can be too conservative and will disallow more complex
coercions that might be valid. If this happens, you can use two assertions,
first to `any` (or `unknown`, which we‚Äôll introduce later), then to the
desired type:
    ts
    const a = expr as any as T;
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iAHgBxgC54oUBPAbgFgAoDMvBAFXgF54BvE4gRgvgBGxAEz8wxAMzwAvtRoB6efAC0qsAFcMq5bWTosUNtnwwSaEuTPwmFIA)
## Literal Types
In addition to the general types `string` and `number`, we can refer to
_specific_ strings and numbers in type positions.
One way to think about this is to consider how JavaScript comes with different
ways to declare a variable. Both `var` and `let` allow for changing what is
held inside the variable, and `const` does not. This is reflected in how
TypeScript creates types for literals.
    ts
    let changingString = "Hello World";
    changingString = "Ol√° Mundo";
    // Because `changingString` can represent any possible string, that
    // is how TypeScript describes it in the type system
    changingString;
    let changingString: string
    const constantString = "Hello World";
    // Because `constantString` can only represent 1 possible string, it
    // has a literal type representation
    constantString;
    const constantString: "Hello World"
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxgFghgOwOYEtkGUwCc1IgXggCIAJEYYAewgHVKtgATIgbgFgAoWRVDbXAsQDywAIcQAsgFcEjSq04B6RRABCIKHCkBnEBAAG3ZLkw5k+6IghYQABxu6EkRAE8Itytu0oARqAja-MgANBBg8GBKKijaEDCUAO4QACoutiDoUDi2kIwg2lm++RAokGhhMHpgaXraLoEgALacRrxIprjsHMoQAHoA-JwtlAiB0COBiGAdyIKk5FS09EwK3Srqmjp6hhNgUzNIFpoIECPAbjb2+SBOEACM7p7efrVBSKGlUXFwsXAQwKUQFg4MAwjVrHYHDc9mAUCNhqM9k4Dl0egMgA)
By themselves, literal types aren‚Äôt very valuable:
    ts
    let x: "hello" = "hello";
    // OK
    x = "hello";
    // ...
    x = "howdy";
    Type '"howdy"' is not assignable to type '"hello"'.2322Type '"howdy"' is not assignable to type '"hello"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UAiAC0gILktAF5Qa6HKBufEUAeQDS+Miza16jHnj4A6eSLE04AdwAmAT25A)
It‚Äôs not much use to have a variable that can only have one value!
But by _combining_ literals into unions, you can express a much more useful
concept - for example, functions that only accept a certain set of known
values:
    ts
    function printText(s: string, alignment: "left" | "right" | "center") {
      // ...
    }
    printText("Hello, world", "left");
    printText("G'day, mate", "centre");
    Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.2345Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAKpAB5UAUKoRFRZkA5gBpQAQwA2NUWQC2kNqgBEMyESprQAH1BqWogBY79hiiqow1ASlABvQqFAhQAOi+EAvoWasHNx8agASkDIycJIA7ggyACZqkhpaOnYA3P4iQTy8agDiAOQJUgCekopSNsmW1tCQ9hlAA)
Numeric literal types work the same way:
    ts
    function compare(a: string, b: string): -1 | 0 | 1 {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbADgQwE4FMAUmAXIgM5TYxgDmANIgEYnmU0CUJAtAIyIA+iAAz9EvAN4BYAFCJEeKCGxJMiALzrGiAPxDEJFQD5NO3l24BuaQF8gA)
Of course, you can combine these with non-literal types:
    ts
    interface Options {
      width: number;
    }
    function configure(x: Options | "auto") {
      // ...
    }
    configure({ width: 100 });
    configure("auto");
    configure("automatic");
    Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.2345Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACWAdgC4wBmAhgMaSgDyADmUXCYqAN6GigB3IgBMyAC1QkArgFsARjADchAL6FKUkrTYdQtDpSIBzKdEgAKAB6oWOzqAA+oAETUpZOM4CUPPqBCgAHTBqoT6JIYmZubcgiLiqACMAAzJoCpeygThkaYWru6emWEGxnnmBR4y1Gy03opAA)
There‚Äôs one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.
### Literal Inference
When you initialize a variable with an object, TypeScript assumes that the
properties of that object might change values later. For example, if you wrote
code like this:
    ts
    const obj = { counter: 0 };
    if (someCondition) {
      obj.counter = 1;
    }
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEAwqsAJYYmoBc8ARkkhCFCgNwCwAUAPRfwC0AsAFcMAvp2TosSGgCt4AXngBvREiEoMIGNQAM8AL7sOJAGbwAFDnxEUpcqgCUKzvHgzZAOmQatMRfAAjMYGQA)
TypeScript doesn‚Äôt assume the assignment of `1` to a field which previously
had `0` is an error. Another way of saying this is that `obj.counter` must
have the type `number`, not `0`, because types are used to determine both
_reading_ and _writing_ behavior.
The same applies to strings:
    ts
    declare function handleRequest(url: string, method: "GET" | "POST"): void;
    const req = { url: "https://example.com", method: "GET" };
    handleRequest(req.url, req.method);
    Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.2345Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgAWlTRcpABKkAI4NIiVgAoG0cqmnR2TAOYAaUAFtIrHnCKoARAHEAogBVjoAD6hjABQDyAZWsBKVADc47IgDchISkXNKgNGKgALygAN6g8ooOPKysAA4oIJAAHpTa6UIAdKHaxlq6+oYmFtagAL5BBHwCQqISUrKRRUla3ZUGRB4BQA)
In the above example `req.method` is inferred to be `string`, not `"GET"`.
Because code can be evaluated between the creation of `req` and the call of
`handleRequest` which could assign a new string like `"GUESS"` to
`req.method`, TypeScript considers this code to have an error.
There are two ways to work around this.
  1. You can change the inference by adding a type assertion in either location:
        ts
    // Change 1:
    const req = { url: "https://example.com", method: "GET" as "GET" };
    // Change 2
    handleRequest(req.url, req.method as "GET");
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm-fgBhInwQARjYbMDwGeDgqeABeeABveBZ2dQIMDAAHOjZ7EAAPKCEMsgA6MKEpQRExCWl5JXgoOnV65QBfKzsHP2JeBAAmG39SCmpaBkYokuTBKerxYEbm2UUpfXMgA)
Change 1 means ‚ÄúI intend for `req.method` to always have the _literal type_
`"GET"`‚Äù, preventing the possible assignment of `"GUESS"` to that field after.
Change 2 means ‚ÄúI know for other reasons that `req.method` has the value
`"GET"`‚Äú.
  2. You can use `as const` to convert the entire object to be type literals:
        ts
    const req = { url: "https://example.com", method: "GET" } as const;
    handleRequest(req.url, req.method);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm2DwN4cKvAAvPAA3vAs7OoEGBgADnRs9iAAHlBCsWQAdN5CUoIiYhLS8krwAL7wUHTw3qgMVtZEJGSUNPRM-pkRgp0F4sD65kA)
The `as const` suffix acts like `const` but for the type system, ensuring that
all properties are assigned the literal type instead of a more general version
like `string` or `number`.
## `null` and `undefined`
JavaScript has two primitive values used to signal absent or uninitialized
value: `null` and `undefined`.
TypeScript has two corresponding _types_ by the same names. How these types
behave depends on whether you have the
[`strictNullChecks`](/tsconfig#strictNullChecks) option on.
### `strictNullChecks` off
With [`strictNullChecks`](/tsconfig#strictNullChecks) _off_ , values that
might be `null` or `undefined` can still be accessed normally, and the values
`null` and `undefined` can be assigned to a property of any type. This is
similar to how languages without null checks (e.g. C#, Java) behave. The lack
of checking for these values tends to be a major source of bugs; we always
recommend people turn [`strictNullChecks`](/tsconfig#strictNullChecks) on if
it‚Äôs practical to do so in their codebase.
### `strictNullChecks` on
With [`strictNullChecks`](/tsconfig#strictNullChecks) _on_ , when a value is
`null` or `undefined`, you will need to test for those values before using
methods or properties on that value. Just like checking for `undefined` before
using an optional property, we can use _narrowing_ to check for values that
might be `null`:
    ts
    function doSomething(x: string | null) {
      if (x === null) {
        // do nothing
      } else {
        console.log("Hello, " + x.toUpperCase());
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAB4BciAzlAE6FGIA+iYIANhwJSIDeAWABQiRDGCJyiALyy2nHv2GjRAelUo4bOPkbLEAX0TYO1bEpEqICanA7YAdBzikARAAkTzgDSJXiAGpEMgcoOABVAAdI7DoAYQBDMxJubgBufQNhAyA)
### Non-null Assertion Operator (Postfix `!`)
TypeScript also has a special syntax for removing `null` and `undefined` from
a type without doing any explicit checking. Writing `!` after any expression
is effectively a type assertion that the value isn‚Äôt `null` or `undefined`:
    ts
    function liveDangerously(x?: number | null) {
      // No error
      console.log(x!.toFixed());
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGxgNwKYBECGYDmGATnCAM7ICeAFAB4D8AXImCALYBGxiAPiyMmQBKRAG8AsAChEiAPSzEAOTiJiJIlJkQEZOMgwA6ZHHx0AhAahwAYjFoYAJtSFCA3FIC+QA)
Just like other type assertions, this doesn‚Äôt change the runtime behavior of
your code, so it‚Äôs important to only use `!` when you know that the value
_can‚Äôt_ be `null` or `undefined`.
## Enums
Enums are a feature added to JavaScript by TypeScript which allows for
describing a value which could be one of a set of possible named constants.
Unlike most TypeScript features, this is _not_ a type-level addition to
JavaScript but something added to the language and runtime. Because of this,
it‚Äôs a feature which you should know exists, but maybe hold off on using
unless you are sure. You can read more about enums in the [Enum reference
page](/docs/handbook/enums.html).
## Less Common Primitives
It‚Äôs worth mentioning the rest of the primitives in JavaScript which are
represented in the type system. Though we will not go into depth here.
#### `bigint`
From ES2020 onwards, there is a primitive in JavaScript used for very large
integers, `BigInt`:
    ts
    // Creating a bigint via the BigInt function
    const oneHundred: bigint = BigInt(100);
    // Creating a BigInt via the literal syntax
    const anotherHundred: bigint = 100n;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGXBYAKCJFAGFZFpIBLAO3lGlACMb57JQA3G5yABaJQAIXYBJOlwBmAVzoBjWgHs6RBaoxdViABLyAJpQNo2HKaAC8oiVIAUARhw4AlAG4iJMBSq0GTG3hJLl5+IVAAGxpIRFhoCNAMAE8paAAPdU0uaDplQVj9OiNEE1Z2TitQJxw6NyA)
You can learn more about BigInt in [the TypeScript 3.2 release
notes](/docs/handbook/release-notes/typescript-3-2.html#bigint).
#### `symbol`
There is a primitive in JavaScript used to create a globally unique reference
via the function `Symbol()`:
    ts
    const firstName = Symbol("name");
    const secondName = Symbol("name");
    if (firstName === secondName) {
    This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.2367This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.
      // Can't ever happen
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AsAFADGcAdogC6gBmAlkhQHICGAtpKALygDKAnqwBGcADYAKAESk2kCQEoA3IRLkqiSCoAmLdl14Dh4qTPlKChWtVBi6DHR06PQ6rfbmgA3oVCgQoAMLMpADkVJAAbjCgABbMAA5xkKSEAL5AA)
You can learn more about them in [Symbols reference
page](/docs/handbook/symbols.html).
### [The BasicsStep one in learning TypeScript: The basic
types.](/docs/handbook/2/basic-types.html)
### [NarrowingUnderstand how TypeScript uses JavaScript knowledge to reduce
the amount of type syntax in your projects.](/docs/handbook/2/narrowing.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Everyday Types.md)
‚ù§
Contributors to this page:  
RC
OT
UG
AB
DR
30+
Last updated: Sep 16, 2024  
Was this page helpful?
# More on Functions
Functions are the basic building block of any application, whether they‚Äôre
local functions, imported from another module, or methods on a class. They‚Äôre
also values, and just like other values, TypeScript has many ways to describe
how functions can be called. Let‚Äôs learn about how to write types that
describe functions.
## Function Type Expressions
The simplest way to describe a function is with a _function type expression_.
These types are syntactically similar to arrow functions:
    ts
    function greeter(fn: (a: string) => void) {
      fn("Hello, World");
    }
    function printToConsole(s: string) {
      console.log(s);
    }
    greeter(printToConsole);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA)
The syntax `(a: string) => void` means ‚Äúa function with one parameter, named
`a`, of type `string`, that doesn‚Äôt have a return value‚Äù. Just like with
function declarations, if a parameter type isn‚Äôt specified, it‚Äôs implicitly
`any`.
> Note that the parameter name is **required**. The function type `(string) =>
> void` means ‚Äúa function with a parameter named `string` of type `any`‚Äú!
Of course, we can use a type alias to name a function type:
    ts
    type GreetFunction = (a: string) => void;
    function greeter(fn: GreetFunction) {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA)
## Call Signatures
In JavaScript, functions can have properties in addition to being callable.
However, the function type expression syntax doesn‚Äôt allow for declaring
properties. If we want to describe something callable with properties, we can
write a _call signature_ in an object type:
    ts
    type DescribableFunction = {
      description: string;
      (someArg: number): boolean;
    };
    function doSomething(fn: DescribableFunction) {
      console.log(fn.description + " returned " + fn(6));
    }
    function myFunc(someArg: number) {
      return someArg > 3;
    }
    myFunc.description = "default description";
    doSomething(myFunc);
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA)
Note that the syntax is slightly different compared to a function type
expression - use `:` between the parameter list and the return type rather
than `=>`.
## Construct Signatures
JavaScript functions can also be invoked with the `new` operator. TypeScript
refers to these as _constructors_ because they usually create a new object.
You can write a _construct signature_ by adding the `new` keyword in front of
a call signature:
    ts
    type SomeConstructor = {
      new (s: string): SomeObject;
    };
    function fn(ctor: SomeConstructor) {
      return new ctor("hello");
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA)
Some objects, like JavaScript‚Äôs `Date` object, can be called with or without
`new`. You can combine call and construct signatures in the same type
arbitrarily:
    ts
    interface CallOrConstruct {
      (n?: number): string;
      new (s: string): Date;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfIA)
## Generic Functions
It‚Äôs common to write a function where the types of the input relate to the
type of the output, or where the types of two inputs are related in some way.
Let‚Äôs consider for a moment a function that returns the first element of an
array:
    ts
    function firstElement(arr: any[]) {
      return arr[0];
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA)
This function does its job, but unfortunately has the return type `any`. It‚Äôd
be better if the function returned the type of the array element.
In TypeScript, _generics_ are used when we want to describe a correspondence
between two values. We do this by declaring a _type parameter_ in the function
signature:
    ts
    function firstElement<Type>(arr: Type[]): Type | undefined {
      return arr[0];
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA)
By adding a type parameter `Type` to this function and using it in two places,
we‚Äôve created a link between the input of the function (the array) and the
output (the return value). Now when we call it, a more specific type comes
out:
    ts
    // s is of type 'string'
    const s = firstElement(["a", "b", "c"]);
    // n is of type 'number'
    const n = firstElement([1, 2, 3]);
    // u is of type undefined
    const u = firstElement([]);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA)
### Inference
Note that we didn‚Äôt have to specify `Type` in this sample. The type was
_inferred_ \- chosen automatically - by TypeScript.
We can use multiple type parameters as well. For example, a standalone version
of `map` would look like this:
    ts
    function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
      return arr.map(func);
    }
    // Parameter 'n' is of type 'string'
    // 'parsed' is of type 'number[]'
    const parsed = map(["1", "2", "3"], (n) => parseInt(n));
    [Try](https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA)
Note that in this example, TypeScript could infer both the type of the `Input`
type parameter (from the given `string` array), as well as the `Output` type
parameter based on the return value of the function expression (`number`).
### Constraints
We‚Äôve written some generic functions that can work on _any_ kind of value.
Sometimes we want to relate two values, but can only operate on a certain
subset of values. In this case, we can use a _constraint_ to limit the kinds
of types that a type parameter can accept.
Let‚Äôs write a function that returns the longer of two values. To do this, we
need a `length` property that‚Äôs a number. We _constrain_ the type parameter to
that type by writing an `extends` clause:
    ts
    function longest<Type extends { length: number }>(a: Type, b: Type) {
      if (a.length >= b.length) {
        return a;
      } else {
        return b;
      }
    }
    // longerArray is of type 'number[]'
    const longerArray = longest([1, 2], [1, 2, 3]);
    // longerString is of type 'alice' | 'bob'
    const longerString = longest("alice", "bob");
    // Error! Numbers don't have a 'length' property
    const notOK = longest(10, 100);
    Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA)
There are a few interesting things to note in this example. We allowed
TypeScript to _infer_ the return type of `longest`. Return type inference also
works on generic functions.
Because we constrained `Type` to `{ length: number }`, we were allowed to
access the `.length` property of the `a` and `b` parameters. Without the type
constraint, we wouldn‚Äôt be able to access those properties because the values
might have been some other type without a length property.
The types of `longerArray` and `longerString` were inferred based on the
arguments. Remember, generics are all about relating two or more values with
the same type!
Finally, just as we‚Äôd like, the call to `longest(10, 100)` is rejected because
the `number` type doesn‚Äôt have a `.length` property.
### Working with Constrained Values
Here‚Äôs a common error when working with generic constraints:
    ts
    function minimumLength<Type extends { length: number }>(
      obj: Type,
      minimum: number
    ): Type {
      if (obj.length >= minimum) {
        return obj;
      } else {
        return { length: minimum };
    Type '{ length: number; }' is not assignable to type 'Type'.
      '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.
      '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA)
It might look like this function is OK - `Type` is constrained to `{ length:
number }`, and the function either returns `Type` or a value matching that
constraint. The problem is that the function promises to return the _same_
kind of object as was passed in, not just _some_ object matching the
constraint. If this code were legal, you could write code that definitely
wouldn‚Äôt work:
    ts
    // 'arr' gets value { length: 6 }
    const arr = minimumLength([1, 2, 3], 6);
    // and crashes here because arrays have
    // a 'slice' method, but not the returned object!
    console.log(arr.slice(0));
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA)
### Specifying Type Arguments
TypeScript can usually infer the intended type arguments in a generic call,
but not always. For example, let‚Äôs say you wrote a function to combine two
arrays:
    ts
    function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
      return arr1.concat(arr2);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A)
Normally it would be an error to call this function with mismatched arrays:
    ts
    const arr = combine([1, 2, 3], ["hello"]);
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA)
If you intended to do this, however, you could manually specify `Type`:
    ts
    const arr = combine<string | number>([1, 2, 3], ["hello"]);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA)
### Guidelines for Writing Good Generic Functions
Writing generic functions is fun, and it can be easy to get carried away with
type parameters. Having too many type parameters or using constraints where
they aren‚Äôt needed can make inference less successful, frustrating callers of
your function.
#### Push Type Parameters Down
Here are two ways of writing a function that appear similar:
    ts
    function firstElement1<Type>(arr: Type[]) {
      return arr[0];
    }
    function firstElement2<Type extends any[]>(arr: Type) {
      return arr[0];
    }
    // a: number (good)
    const a = firstElement1([1, 2, 3]);
    // b: any (bad)
    const b = firstElement2([1, 2, 3]);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA)
These might seem identical at first glance, but `firstElement1` is a much
better way to write this function. Its inferred return type is `Type`, but
`firstElement2`‚Äôs inferred return type is `any` because TypeScript has to
resolve the `arr[0]` expression using the constraint type, rather than
‚Äúwaiting‚Äù to resolve the element during a call.
> **Rule** : When possible, use the type parameter itself rather than
> constraining it
#### Use Fewer Type Parameters
Here‚Äôs another pair of similar functions:
    ts
    function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
      return arr.filter(func);
    }
    function filter2<Type, Func extends (arg: Type) => boolean>(
      arr: Type[],
      func: Func
    ): Type[] {
      return arr.filter(func);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA)
We‚Äôve created a type parameter `Func` that _doesn‚Äôt relate two values_. That‚Äôs
always a red flag, because it means callers wanting to specify type arguments
have to manually specify an extra type argument for no reason. `Func` doesn‚Äôt
do anything but make the function harder to read and reason about!
> **Rule** : Always use as few type parameters as possible
#### Type Parameters Should Appear Twice
Sometimes we forget that a function might not need to be generic:
    ts
    function greet<Str extends string>(s: Str) {
      console.log("Hello, " + s);
    }
    greet("world");
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA)
We could just as easily have written a simpler version:
    ts
    function greet(s: string) {
      console.log("Hello, " + s);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA)
Remember, type parameters are for _relating the types of multiple values_. If
a type parameter is only used once in the function signature, it‚Äôs not
relating anything. This includes the inferred return type; for example, if
`Str` was part of the inferred return type of `greet`, it would be relating
the argument and return types, so would be used _twice_ despite appearing only
once in the written code.
> **Rule** : If a type parameter only appears in one location, strongly
> reconsider if you actually need it
## Optional Parameters
Functions in JavaScript often take a variable number of arguments. For
example, the `toFixed` method of `number` takes an optional digit count:
    ts
    function f(n: number) {
      console.log(n.toFixed()); // 0 arguments
      console.log(n.toFixed(3)); // 1 argument
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA)
We can model this in TypeScript by marking the parameter as _optional_ with
`?`:
    ts
    function f(x?: number) {
      // ...
    }
    f(); // OK
    f(10); // OK
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA)
Although the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.
You can also provide a parameter _default_ :
    ts
    function f(x = 10) {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA)
Now in the body of `f`, `x` will have type `number` because any `undefined`
argument will be replaced with `10`. Note that when a parameter is optional,
callers can always pass `undefined`, as this simply simulates a ‚Äúmissing‚Äù
argument:
    ts
    // All OK
    f();
    f(10);
    f(undefined);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA)
### Optional Parameters in Callbacks
Once you‚Äôve learned about optional parameters and function type expressions,
it‚Äôs very easy to make the following mistakes when writing functions that
invoke callbacks:
    ts
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
      for (let i = 0; i < arr.length; i++) {
        callback(arr[i], i);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA)
What people usually intend when writing `index?` as an optional parameter is
that they want both of these calls to be legal:
    ts
    myForEach([1, 2, 3], (a) => console.log(a));
    myForEach([1, 2, 3], (a, i) => console.log(a, i));
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA)
What this _actually_ means is that _`callback` might get invoked with one
argument_. In other words, the function definition says that the
implementation might look like this:
    ts
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
      for (let i = 0; i < arr.length; i++) {
        // I don't feel like providing the index today
        callback(arr[i]);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA)
In turn, TypeScript will enforce this meaning and issue errors that aren‚Äôt
really possible:
    ts
    myForEach([1, 2, 3], (a, i) => {
      console.log(i.toFixed());
    'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA)
In JavaScript, if you call a function with more arguments than there are
parameters, the extra arguments are simply ignored. TypeScript behaves the
same way. Functions with fewer parameters (of the same types) can always take
the place of functions with more parameters.
> **Rule** : When writing a function type for a callback, _never_ write an
> optional parameter unless you intend to _call_ the function without passing
> that argument
## Function Overloads
Some JavaScript functions can be called in a variety of argument counts and
types. For example, you might write a function to produce a `Date` that takes
either a timestamp (one argument) or a month/day/year specification (three
arguments).
In TypeScript, we can specify a function that can be called in different ways
by writing _overload signatures_. To do this, write some number of function
signatures (usually two or more), followed by the body of the function:
    ts
    function makeDate(timestamp: number): Date;
    function makeDate(m: number, d: number, y: number): Date;
    function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
      if (d !== undefined && y !== undefined) {
        return new Date(y, mOrTimestamp, d);
      } else {
        return new Date(mOrTimestamp);
      }
    }
    const d1 = makeDate(12345678);
    const d2 = makeDate(5, 5, 5);
    const d3 = makeDate(1, 3);
    No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA)
In this example, we wrote two overloads: one accepting one argument, and
another accepting three arguments. These first two signatures are called the
_overload signatures_.
Then, we wrote a function implementation with a compatible signature.
Functions have an _implementation_ signature, but this signature can‚Äôt be
called directly. Even though we wrote a function with two optional parameters
after the required one, it can‚Äôt be called with two parameters!
### Overload Signatures and the Implementation Signature
This is a common source of confusion. Often people will write code like this
and not understand why there is an error:
    ts
    function fn(x: string): void;
    function fn() {
      // ...
    }
    // Expected to be able to call with zero arguments
    fn();
    Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA)
Again, the signature used to write the function body can‚Äôt be ‚Äúseen‚Äù from the
outside.
> The signature of the _implementation_ is not visible from the outside. When
> writing an overloaded function, you should always have _two_ or more
> signatures above the implementation of the function.
The implementation signature must also be _compatible_ with the overload
signatures. For example, these functions have errors because the
implementation signature doesn‚Äôt match the overloads in a correct way:
    ts
    function fn(x: boolean): void;
    // Argument type isn't right
    function fn(x: string): void;
    This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.
    function fn(x: boolean) {}
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA)
    ts
    function fn(x: string): string;
    // Return type isn't right
    function fn(x: number): boolean;
    This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.
    function fn(x: string | number) {
      return "oops";
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA)
### Writing Good Overloads
Like generics, there are a few guidelines you should follow when using
function overloads. Following these principles will make your function easier
to call, easier to understand, and easier to implement.
Let‚Äôs consider a function that returns the length of a string or an array:
    ts
    function len(s: string): number;
    function len(arr: any[]): number;
    function len(x: any) {
      return x.length;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A)
This function is fine; we can invoke it with strings or arrays. However, we
can‚Äôt invoke it with a value that might be a string _or_ an array, because
TypeScript can only resolve a function call to a single overload:
    ts
    len(""); // OK
    len([0]); // OK
    len(Math.random() > 0.5 ? "hello" : [0]);
    No overload matches this call.
      Overload 1 of 2, '(s: string): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
          Type 'number[]' is not assignable to type 'string'.
      Overload 2 of 2, '(arr: any[]): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
          Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.
      Overload 1 of 2, '(s: string): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
          Type 'number[]' is not assignable to type 'string'.
      Overload 2 of 2, '(arr: any[]): number', gave the following error.
        Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
          Type 'string' is not assignable to type 'any[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA)
Because both overloads have the same argument count and same return type, we
can instead write a non-overloaded version of the function:
    ts
    function len(x: any[] | string) {
      return x.length;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA)
This is much better! Callers can invoke this with either sort of value, and as
an added bonus, we don‚Äôt have to figure out a correct implementation
signature.
> Always prefer parameters with union types instead of overloads when possible
## Declaring `this` in a Function
TypeScript will infer what the `this` should be in a function via code flow
analysis, for example in the following:
    ts
    const user = {
      id: 123,
      admin: false,
      becomeAdmin: function () {
        this.admin = true;
      },
    };
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA)
TypeScript understands that the function `user.becomeAdmin` has a
corresponding `this` which is the outer object `user`. `this`, _heh_ , can be
enough for a lot of cases, but there are a lot of cases where you need more
control over what object `this` represents. The JavaScript specification
states that you cannot have a parameter called `this`, and so TypeScript uses
that syntax space to let you declare the type for `this` in the function body.
    ts
    interface DB {
      filterUsers(filter: (this: User) => boolean): User[];
    }
    const db = getDB();
    const admins = db.filterUsers(function (this: User) {
      return this.admin;
    });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA)
This pattern is common with callback-style APIs, where another object
typically controls when your function is called. Note that you need to use
`function` and not arrow functions to get this behavior:
    ts
    interface DB {
      filterUsers(filter: (this: User) => boolean): User[];
    }
    const db = getDB();
    const admins = db.filterUsers(() => this.admin);
    The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.7041  
    7017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXv0QBBAWMqoJcOABtI9CrJIBfUgMiNN9aC0ZwKiKqADmkKgBEAQqgAUASlABeAD5Qd30QUABaSMYRKkjw0koaaAZmYLduOVoyTST2GERPLJyYLyoACzIUNg5oX0DQdS0dCm9UPOgAbQBdfSMSUmtbewEJf0dndx99QbtQemVKRDGRgDoi3JqCn38g8sqV+ZUW6SA)
## Other Types to Know About
There are some additional types you‚Äôll want to recognize that appear often
when working with function types. Like all types, you can use them everywhere,
but these are especially relevant in the context of functions.
### `void`
`void` represents the return value of functions which don‚Äôt return a value.
It‚Äôs the inferred type any time a function doesn‚Äôt have any `return`
statements, or doesn‚Äôt return any explicit value from those return statements:
    ts
    // The inferred return type is void
    function noop() {
      return;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA)
In JavaScript, a function that doesn‚Äôt return any value will implicitly return
the value `undefined`. However, `void` and `undefined` are not the same thing
in TypeScript. There are further details at the end of this chapter.
> `void` is not the same as `undefined`.
### `object`
The special type `object` refers to any value that isn‚Äôt a primitive
(`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`).
This is different from the _empty object type_ `{ }`, and also different from
the global type `Object`. It‚Äôs very likely you will never use `Object`.
> `object` is not `Object`. **Always** use `object`!
Note that in JavaScript, function values are objects: They have properties,
have `Object.prototype` in their prototype chain, are `instanceof Object`, you
can call `Object.keys` on them, and so on. For this reason, function types are
considered to be `object`s in TypeScript.
### `unknown`
The `unknown` type represents _any_ value. This is similar to the `any` type,
but is safer because it‚Äôs not legal to do anything with an `unknown` value:
    ts
    function f1(a: any) {
      a.b(); // OK
    }
    function f2(a: unknown) {
      a.b();
    'a' is of type 'unknown'.18046'a' is of type 'unknown'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA)
This is useful when describing function types because you can describe
functions that accept any value without having `any` values in your function
body.
Conversely, you can describe a function that returns a value of unknown type:
    ts
    function safeParse(s: string): unknown {
      return JSON.parse(s);
    }
    // Need to be careful with 'obj'!
    const obj = safeParse(someRandomString);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA)
### `never`
Some functions _never_ return a value:
    ts
    function fail(msg: string): never {
      throw new Error(msg);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA)
The `never` type represents values which are _never_ observed. In a return
type, this means that the function throws an exception or terminates execution
of the program.
`never` also appears when TypeScript determines there‚Äôs nothing left in a
union.
    ts
    function fn(x: string | number) {
      if (typeof x === "string") {
        // do something
      } else if (typeof x === "number") {
        // do something else
      } else {
        x; // has type 'never'!
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA)
### `Function`
The global type `Function` describes properties like `bind`, `call`, `apply`,
and others present on all function values in JavaScript. It also has the
special property that values of type `Function` can always be called; these
calls return `any`:
    ts
    function doSomething(f: Function) {
      return f(1, 2, 3);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA)
This is an _untyped function call_ and is generally best avoided because of
the unsafe `any` return type.
If you need to accept an arbitrary function but don‚Äôt intend to call it, the
type `() => void` is generally safer.
## Rest Parameters and Arguments
> Background Reading:  
>  [Rest Parameters](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  
>  [Spread Syntax](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  
>
### Rest Parameters
In addition to using optional parameters or overloads to make functions that
can accept a variety of fixed argument counts, we can also define functions
that take an _unbounded_ number of arguments using _rest parameters_.
A rest parameter appears after all other parameters, and uses the `...`
syntax:
    ts
    function multiply(n: number, ...m: number[]) {
      return m.map((x) => n * x);
    }
    // 'a' gets value [10, 20, 30, 40]
    const a = multiply(10, 1, 2, 3, 4);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA)
In TypeScript, the type annotation on these parameters is implicitly `any[]`
instead of `any`, and any type annotation given must be of the form `Array<T>`
or `T[]`, or a tuple type (which we‚Äôll learn about later).
### Rest Arguments
Conversely, we can _provide_ a variable number of arguments from an iterable
object (for example, an array) using the spread syntax. For example, the
`push` method of arrays takes any number of arguments:
    ts
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5, 6];
    arr1.push(...arr2);
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA)
Note that in general, TypeScript does not assume that arrays are immutable.
This can lead to some surprising behavior:
    ts
    // Inferred type is number[] -- "an array with zero or more numbers",
    // not specifically two numbers
    const args = [8, 5];
    const angle = Math.atan2(...args);
    A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA)
The best fix for this situation depends a bit on your code, but in general a
`const` context is the most straightforward solution:
    ts
    // Inferred as 2-length tuple
    const args = [8, 5] as const;
    // OK
    const angle = Math.atan2(...args);
    [Try](https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA)
Using rest arguments may require turning on
[`downlevelIteration`](/tsconfig#downlevelIteration) when targeting older
runtimes.
## Parameter Destructuring
> Background Reading:  
>  [Destructuring Assignment](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  
>
You can use parameter destructuring to conveniently unpack objects provided as
an argument into one or more local variables in the function body. In
JavaScript, it looks like this:
    js
    function sum({ a, b, c }) {
      console.log(a + b + c);
    }
    sum({ a: 10, b: 3, c: 9 });
The type annotation for the object goes after the destructuring syntax:
    ts
    function sum({ a, b, c }: { a: number; b: number; c: number }) {
      console.log(a + b + c);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA)
This can look a bit verbose, but you can use a named type here as well:
    ts
    // Same as prior example
    type ABC = { a: number; b: number; c: number };
    function sum({ a, b, c }: ABC) {
      console.log(a + b + c);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA)
## Assignability of Functions
### Return type `void`
The `void` return type for functions can produce some unusual, but expected
behavior.
Contextual typing with a return type of `void` does **not** force functions to
**not** return something. Another way to say this is a contextual function
type with a `void` return type (`type voidFunc = () => void`), when
implemented, can return _any_ other value, but it will be ignored.
Thus, the following implementations of the type `() => void` are valid:
    ts
    type voidFunc = () => void;
    const f1: voidFunc = () => {
      return true;
    };
    const f2: voidFunc = () => true;
    const f3: voidFunc = function () {
      return true;
    };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA)
And when the return value of one of these functions is assigned to another
variable, it will retain the type of `void`:
    ts
    const v1 = f1();
    const v2 = f2();
    const v3 = f3();
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA)
This behavior exists so that the following code is valid even though
`Array.prototype.push` returns a number and the `Array.prototype.forEach`
method expects a function with a return type of `void`.
    ts
    const src = [1, 2, 3];
    const dst = [0];
    src.forEach((el) => dst.push(el));
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA)
There is one other special case to be aware of, when a literal function
definition has a `void` return type, that function must **not** return
anything.
    ts
    function f2(): void {
      // @ts-expect-error
      return true;
    }
    const f3 = function (): void {
      // @ts-expect-error
      return true;
    };
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA)
For more on `void` please refer to these other documentation entries:
  * [v2 handbook](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
  * [FAQ - ‚ÄúWhy are functions returning non-void assignable to function returning void?‚Äù](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)
### [NarrowingUnderstand how TypeScript uses JavaScript knowledge to reduce
the amount of type syntax in your projects.](/docs/handbook/2/narrowing.html)
### [Object TypesHow TypeScript describes the shapes of JavaScript
objects.](/docs/handbook/2/objects.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/More on
Functions.md) ‚ù§
Contributors to this page:  
RC
OT
HA
JW
SB
35+
Last updated: Sep 16, 2024  
Was this page helpful?
# Generics
A major part of software engineering is building components that not only have
well-defined and consistent APIs, but are also reusable. Components that are
capable of working on the data of today as well as the data of tomorrow will
give you the most flexible capabilities for building up large software
systems.
In languages like C# and Java, one of the main tools in the toolbox for
creating reusable components is _generics_ , that is, being able to create a
component that can work over a variety of types rather than a single one. This
allows users to consume these components and use their own types.
## Hello World of Generics
To start off, let‚Äôs do the ‚Äúhello world‚Äù of generics: the identity function.
The identity function is a function that will return back whatever is passed
in. You can think of this in a similar way to the `echo` command.
Without generics, we would either have to give the identity function a
specific type:
    ts
    function identity(arg: number): number {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)
Or, we could describe the identity function using the `any` type:
    ts
    function identity(arg: any): any {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)
While using `any` is certainly generic in that it will cause the function to
accept any and all types for the type of `arg`, we actually are losing the
information about what that type was when the function returns. If we passed
in a number, the only information we have is that any type could be returned.
Instead, we need a way of capturing the type of the argument in such a way
that we can also use it to denote what is being returned. Here, we will use a
_type variable_ , a special kind of variable that works on types rather than
values.
    ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)
We‚Äôve now added a type variable `Type` to the identity function. This `Type`
allows us to capture the type the user provides (e.g. `number`), so that we
can use that information later. Here, we use `Type` again as the return type.
On inspection, we can now see the same type is used for the argument and the
return type. This allows us to traffic that type information in one side of
the function and out the other.
We say that this version of the `identity` function is generic, as it works
over a range of types. Unlike using `any`, it‚Äôs also just as precise (i.e., it
doesn‚Äôt lose any information) as the first `identity` function that used
numbers for the argument and return type.
Once we‚Äôve written the generic identity function, we can call it in one of two
ways. The first way is to pass all of the arguments, including the type
argument, to the function:
    ts
    let output = identity<string>("myString");
    let output: string
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA)
Here we explicitly set `Type` to be `string` as one of the arguments to the
function call, denoted using the `<>` around the arguments rather than `()`.
The second way is also perhaps the most common. Here we use _type argument
inference_ ‚Äî that is, we want the compiler to set the value of `Type` for us
automatically based on the type of the argument we pass in:
    ts
    let output = identity("myString");
    let output: string
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA)
Notice that we didn‚Äôt have to explicitly pass the type in the angle brackets
(`<>`); the compiler just looked at the value `"myString"`, and set `Type` to
its type. While type argument inference can be a helpful tool to keep code
shorter and more readable, you may need to explicitly pass in the type
arguments as we did in the previous example when the compiler fails to infer
the type, as may happen in more complex examples.
## Working with Generic Type Variables
When you begin to use generics, you‚Äôll notice that when you create generic
functions like `identity`, the compiler will enforce that you use any
generically typed parameters in the body of the function correctly. That is,
that you actually treat these parameters as if they could be any and all
types.
Let‚Äôs take our `identity` function from earlier:
    ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)
What if we want to also log the length of the argument `arg` to the console
with each call? We might be tempted to write this:
    ts
    function loggingIdentity<Type>(arg: Type): Type {
      console.log(arg.length);
    Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)
When we do, the compiler will give us an error that we‚Äôre using the `.length`
member of `arg`, but nowhere have we said that `arg` has this member.
Remember, we said earlier that these type variables stand in for any and all
types, so someone using this function could have passed in a `number` instead,
which does not have a `.length` member.
Let‚Äôs say that we‚Äôve actually intended this function to work on arrays of
`Type` rather than `Type` directly. Since we‚Äôre working with arrays, the
`.length` member should be available. We can describe this just like we would
create arrays of other types:
    ts
    function loggingIdentity<Type>(arg: Type[]): Type[] {
      console.log(arg.length);
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA)
You can read the type of `loggingIdentity` as ‚Äúthe generic function
`loggingIdentity` takes a type parameter `Type`, and an argument `arg` which
is an array of `Type`s, and returns an array of `Type`s.‚Äù If we passed in an
array of numbers, we‚Äôd get an array of numbers back out, as `Type` would bind
to `number`. This allows us to use our generic type variable `Type` as part of
the types we‚Äôre working with, rather than the whole type, giving us greater
flexibility.
We can alternatively write the sample example this way:
    ts
    function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
      console.log(arg.length); // Array has a .length, so no more error
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA)
You may already be familiar with this style of type from other languages. In
the next section, we‚Äôll cover how you can create your own generic types like
`Array<Type>`.
## Generic Types
In previous sections, we created generic identity functions that worked over a
range of types. In this section, we‚Äôll explore the type of the functions
themselves and how to create generic interfaces.
The type of generic functions is just like those of non-generic functions,
with the type parameters listed first, similarly to function declarations:
    ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    let myIdentity: <Type>(arg: Type) => Type = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA)
We could also have used a different name for the generic type parameter in the
type, so long as the number of type variables and how the type variables are
used line up.
    ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    let myIdentity: <Input>(arg: Input) => Input = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA)
We can also write the generic type as a call signature of an object literal
type:
    ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    let myIdentity: { <Type>(arg: Type): Type } = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA)
Which leads us to writing our first generic interface. Let‚Äôs take the object
literal from the previous example and move it to an interface:
    ts
    interface GenericIdentityFn {
      <Type>(arg: Type): Type;
    }
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    let myIdentity: GenericIdentityFn = identity;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA)
In a similar example, we may want to move the generic parameter to be a
parameter of the whole interface. This lets us see what type(s) we‚Äôre generic
over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the
type parameter visible to all the other members of the interface.
    ts
    interface GenericIdentityFn<Type> {
      (arg: Type): Type;
    }
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    let myIdentity: GenericIdentityFn<number> = identity;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA)
Notice that our example has changed to be something slightly different.
Instead of describing a generic function, we now have a non-generic function
signature that is a part of a generic type. When we use `GenericIdentityFn`,
we now will also need to specify the corresponding type argument (here:
`number`), effectively locking in what the underlying call signature will use.
Understanding when to put the type parameter directly on the call signature
and when to put it on the interface itself will be helpful in describing what
aspects of a type are generic.
In addition to generic interfaces, we can also create generic classes. Note
that it is not possible to create generic enums and namespaces.
## Generic Classes
A generic class has a similar shape to a generic interface. Generic classes
have a generic type parameter list in angle brackets (`<>`) following the name
of the class.
    ts
    class GenericNumber<NumType> {
      zeroValue: NumType;
      add: (x: NumType, y: NumType) => NumType;
    }
    let myGenericNumber = new GenericNumber<number>();
    myGenericNumber.zeroValue = 0;
    myGenericNumber.add = function (x, y) {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA)
This is a pretty literal use of the `GenericNumber` class, but you may have
noticed that nothing is restricting it to only use the `number` type. We could
have instead used `string` or even more complex objects.
    ts
    let stringNumeric = new GenericNumber<string>();
    stringNumeric.zeroValue = "";
    stringNumeric.add = function (x, y) {
      return x + y;
    };
    console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA)
Just as with interface, putting the type parameter on the class itself lets us
make sure all of the properties of the class are working with the same type.
As we cover in [our section on classes](/docs/handbook/2/classes.html), a
class has two sides to its type: the static side and the instance side.
Generic classes are only generic over their instance side rather than their
static side, so when working with classes, static members can not use the
class‚Äôs type parameter.
## Generic Constraints
If you remember from an earlier example, you may sometimes want to write a
generic function that works on a set of types where you have _some_ knowledge
about what capabilities that set of types will have. In our `loggingIdentity`
example, we wanted to be able to access the `.length` property of `arg`, but
the compiler could not prove that every type had a `.length` property, so it
warns us that we can‚Äôt make this assumption.
    ts
    function loggingIdentity<Type>(arg: Type): Type {
      console.log(arg.length);
    Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)
Instead of working with any and all types, we‚Äôd like to constrain this
function to work with any and all types that _also_ have the `.length`
property. As long as the type has this member, we‚Äôll allow it, but it‚Äôs
required to have at least this member. To do so, we must list our requirement
as a constraint on what `Type` can be.
To do so, we‚Äôll create an interface that describes our constraint. Here, we‚Äôll
create an interface that has a single `.length` property and then we‚Äôll use
this interface and the `extends` keyword to denote our constraint:
    ts
    interface Lengthwise {
      length: number;
    }
    function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
      console.log(arg.length); // Now we know it has a .length property, so no more error
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA)
Because the generic function is now constrained, it will no longer work over
any and all types:
    ts
    loggingIdentity(3);
    Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA)
Instead, we need to pass in values whose type has all the required properties:
    ts
    loggingIdentity({ length: 10, value: 3 });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA)
## Using Type Parameters in Generic Constraints
You can declare a type parameter that is constrained by another type
parameter. For example, here we‚Äôd like to get a property from an object given
its name. We‚Äôd like to ensure that we‚Äôre not accidentally grabbing a property
that does not exist on the `obj`, so we‚Äôll place a constraint between the two
types:
    ts
    function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
      return obj[key];
    }
    let x = { a: 1, b: 2, c: 3, d: 4 };
    getProperty(x, "a");
    getProperty(x, "m");
    Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.2345Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA)
## Using Class Types in Generics
When creating factories in TypeScript using generics, it is necessary to refer
to class types by their constructor functions. For example,
    ts
    function create<Type>(c: { new (): Type }): Type {
      return new c();
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA)
A more advanced example uses the prototype property to infer and constrain
relationships between the constructor function and the instance side of class
types.
    ts
    class BeeKeeper {
      hasMask: boolean = true;
    }
    class ZooKeeper {
      nametag: string = "Mikle";
    }
    class Animal {
      numLegs: number = 4;
    }
    class Bee extends Animal {
      numLegs = 6;
      keeper: BeeKeeper = new BeeKeeper();
    }
    class Lion extends Animal {
      keeper: ZooKeeper = new ZooKeeper();
    }
    function createInstance<A extends Animal>(c: new () => A): A {
      return new c();
    }
    createInstance(Lion).keeper.nametag;
    createInstance(Bee).keeper.hasMask;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA)
This pattern is used to power the [mixins](/docs/handbook/mixins.html) design
pattern.
## Generic Parameter Defaults
By declaring a default for a generic type parameter, you make it optional to
specify the corresponding type argument. For example, a function which creates
a new `HTMLElement`. Calling the function with no arguments generates a
`HTMLDivElement`; calling the function with an element as the first argument
generates an element of the argument‚Äôs type. You can optionally pass a list of
children as well. Previously you would have to define the function as:
    ts
    declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;
    declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;
    declare function create<T extends HTMLElement, U extends HTMLElement>(
      element: T,
      children: U[]
    ): Container<T, U[]>;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA)
With generic parameter defaults we can reduce it to:
    ts
    declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(
      element?: T,
      children?: U
    ): Container<T, U>;
    const div = create();
    const div: Container<HTMLDivElement, HTMLDivElement[]>
    const p = create(new HTMLParagraphElement());
    const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA)
A generic parameter default follows the following rules:
  * A type parameter is deemed optional if it has a default.
  * Required type parameters must not follow optional type parameters.
  * Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.
  * When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.
  * If a default type is specified and inference cannot choose a candidate, the default type is inferred.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.
  * A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.
## Variance Annotations
> This is an advanced feature for solving a very specific problem, and should
> only be used in situations where you‚Äôve identified a reason to use it
[Covariance and
contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\))
are type theory terms that describe what the relationship between two generic
types is. Here‚Äôs a brief primer on the concept.
For example, if you have an interface representing an object that can `make` a
certain type:
    ts
    interface Producer<T> {
      make(): T;
    }
We can use a `Producer<Cat>` where a `Producer<Animal>` is expected, because a
`Cat` is an `Animal`. This relationship is called _covariance_ : the
relationship from `Producer<T>` to `Producer<U>` is the same as the
relationship from `T` to `U`.
Conversely, if you have an interface that can `consume` a certain type:
    ts
    interface Consumer<T> {
      consume: (arg: T) => void;
    }
Then we can use a `Consumer<Animal>` where a `Consumer<Cat>` is expected,
because any function that is capable of accepting a `Cat` must also be capable
of accepting an `Animal`. This relationship is called _contravariance_ : the
relationship from `Consumer<T>` to `Consumer<U>` is the same as the
relationship from `U` to `T`. Note the reveral of direction as compared to
covariance! This is why contravariance ‚Äúcancels itself out‚Äù but covariance
doesn‚Äôt.
In a structural type system like TypeScript‚Äôs, covariance and contravariance
are naturally emergent behaviors that follow from the definition of types.
Even in the absence of generics, we would see covariant (and contravariant)
relationships:
    ts
    interface AnimalProducer {
      make(): Animal;
    }
    // A CatProducer can be used anywhere an
    // Animal producer is expected
    interface CatProducer {
      make(): Cat;
    }
TypeScript has a structural type system, so when comparing two types, e.g. to
see if a `Producer<Cat>` can be used where a `Producer<Animal>` is expected,
the usual algorithm would be structurally expand both of those definitions,
and compare their structures. However, variance allows for an extremely useful
optimization: if `Producer<T>` is covariant on `T`, then we can simply check
`Cat` and `Animal` instead, as we know they‚Äôll have the same relationship as
`Producer<Cat>` and `Producer<Animal>`.
Note that this logic can only be used when we‚Äôre examining two instantiations
of the same type. If we have a `Producer<T>` and a `FastProducer<U>`, there‚Äôs
no guarantee that `T` and `U` necessarily refer to the same positions in these
types, so this check will always be performed structurally.
Because variance is a naturally emergent property of structural types,
TypeScript automatically _infers_ the variance of every generic type. **In
extremely rare cases** involving certain kinds of circular types, this
measurement can be inaccurate. If this happens, you can add a variance
annotation to a type parameter to force a particular variance:
    ts
    // Contravariant annotation
    interface Consumer<in T> {
      consume: (arg: T) => void;
    }
    // Covariant annotation
    interface Producer<out T> {
      make(): T;
    }
    // Invariant annotation
    interface ProducerConsumer<in out T> {
      consume: (arg: T) => void;
      make(): T;
    }
Only do this if you are writing the same variance that _should_ occur
structurally.
> Never write a variance annotation that doesn‚Äôt match the structural
> variance!
It‚Äôs critical to reinforce that variance annotations are only in effect during
an instantiation-based comparison. They have no effect during a structural
comparison. For example, you can‚Äôt use variance annotations to ‚Äúforce‚Äù a type
to be actually invariant:
    ts
    // DON'T DO THIS - variance annotation
    // does not match structural behavior
    interface Producer<in out T> {
      make(): T;
    }
    // Not a type error -- this is a structural
    // comparison, so variance annotations are
    // not in effect
    const p: Producer<string | number> = {
        make(): number {
            return 42;
        }
    }
Here, the object literal‚Äôs `make` function returns `number`, which we might expect to cause an error because `number` isn‚Äôt `string | number`. However, this isn‚Äôt an instantiation-based comparison, because the object literal is an anonymous type, not a `Producer<string | number>`.
> Variance annotations don‚Äôt change structural behavior and are only consulted
> in specific situations
It‚Äôs very important to only write variance annotations if you absolutely know
why you‚Äôre doing it, what their limitations are, and when they aren‚Äôt in
effect. Whether TypeScript uses an instantiation-based comparison or
structural comparison is not a specified behavior and may change from version
to version for correctness or performance reasons, so you should only ever
write variance annotations when they match the structural behavior of a type.
Don‚Äôt use variance annotations to try to ‚Äúforce‚Äù a particular variance; this
will cause unpredictable behavior in your code.
> Do NOT write variance annotations unless they match the structural behavior
> of a type
Rmember, TypeScript can automatically infer variance from your generic types.
It‚Äôs almost never necessary to write a variance annotation, and you should
only do so when you‚Äôve identified a specific need. Variance annotations _do
not_ change the structural behavior of a type, and depending on the situation,
you might see a structural comparison made when you expected an instantiation-
based comparison. Variance annotations can‚Äôt be used to modify how types
behave in these structural contexts, and shouldn‚Äôt be written unless the
annotation is the same as the structural definition. Because this is difficult
to get right, and TypeScript can correctly infer variance in the vast majority
of cases, you should not find yourself writing variance annotations in normal
code.
> Don‚Äôt try to use variance annotations to change typechecking behavior; this
> is not what they are for
You _may_ find temporary variance annotations useful in a ‚Äútype debugging‚Äù
situation, because variance annotations are checked. TypeScript will issue an
error if the annotated variance is identifiably wrong:
    ts
    // Error, this interface is definitely contravariant on T
    interface Foo<out T> {
      consume: (arg: T) => void;
    }
However, variance annotations are allowed to be stricter (e.g. `in out` is
valid if the actual variance is covariant). Be sure to remove your variance
annotations once you‚Äôre done debugging.
Lastly, if you‚Äôre trying to maximize your typechecking performance, _and_ have
run a profiler, _and_ have identified a specific type that‚Äôs slow, _and_ have
identified variance inference specifically is slow, _and_ have carefully
validated the variance annotation you want to write, you _may_ see a small
performance benefit in extraordinarily complex types by adding variance
annotations.
> Don‚Äôt try to use variance annotations to change typechecking behavior; this
> is not what they are for
### [Creating Types from TypesAn overview of the ways in which you can create
more types from existing types.](/docs/handbook/2/types-from-types.html)
### [Keyof Type OperatorUsing the keyof operator in type
contexts.](/docs/handbook/2/keyof-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Generics.md) ‚ù§
Contributors to this page:  
OT
NK
RC
G
PS
9+
Last updated: Sep 16, 2024  
Was this page helpful?
# Indexed Access Types
We can use an _indexed access type_ to look up a specific property on another
type:
    ts
    type Person = { age: number; name: string; alive: boolean };
    type Age = Person["age"];
    type Age = number
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6AfiA)
The indexing type is itself a type, so we can use unions, `keyof`, or other
types entirely:
    ts
    type I1 = Person["age" | "name"];
    type I1 = string | number
    type I2 = Person[keyof Person];
    type I2 = string | number | boolean
    type AliveOrName = "alive" | "name";
    type I3 = Person[AliveOrName];
    type I3 = string | boolean
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBJAIyZYCFKgDaAIkIQbUAD5QbqJg4C68pVD8A9AH45PXBoQwAmMzgkNCsAawgQZAAzc1jUb0VlAODQgwBBAWEAeXgAOQ8zO2KHZ1d3Zht5fXCAZmiLOKKhCDLK5izfXKA)
You‚Äôll even see an error if you try to index a property that doesn‚Äôt exist:
    ts
    type I1 = Person["alve"];
    Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQAFGROAO1AF5QBvUAQwHNJUaBXAWwBGMANygarPl1CJ80AJY12o1gBs5ANykC4cFZFZ0AvsNwhQAWksBjHvkvmCJMgEkAjAwpVaAbQBEqzV8AXWEgA)
Another example of indexing with an arbitrary type is using `number` to get
the type of an array‚Äôs elements. We can combine this with `typeof` to
conveniently capture the element type of an array literal:
    ts
    const MyArray = [
      { name: "Alice", age: 15 },
      { name: "Bob", age: 23 },
      { name: "Eve", age: 38 },
    ];
    type Person = typeof MyArray[number];
    type Person = {
        name: string;
        age: number;
    }
    type Age = typeof MyArray[number]["age"];
    type Age = number
    // Or
    type Age2 = Person["age"];
    type Age2 = number
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAsgTwIICcUEMEwLwwNoBQMMA3jGOgLYCmAXDAERIA2AlsNQwDQzoDmdGAEYArDAC+XIqXJVBDAEIgARt14D6AJgDMEqcTIUa9BgFEAbpx79B2gBx6CAXQDcBAlAQAHajAAK1CgQ4Dgwnj4gAGbwyGiYeGAArpTKga4EAPQZxDAAegD8Ht6+SAKh4dRRMagYCAnJqShOeAw2DOlZOQWZ2QDyKEU+MKXUmqEBQeAtbR3ZxAVAA)
You can only use types when indexing, meaning you can‚Äôt use a `const` to make
a variable reference:
    ts
    const key = "age";
    type Age = Person[key];
    Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?2538  
    2749Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMAOdB2AFgE4AoAFwE8AHSUABRkTgDtQBeUAb1AEMBzSKhYBXALYAjGAG5QLXmKGhE5aAEsW-WbwA2agG5KJcODsi82AX2mkQoALSOAxiPKP7pJ6xWgA1pEoOUAAiAUhgmypaUABBQSDGJFYAbX9KAF1pIA)
However, you can use a type alias for a similar style of refactor:
    ts
    type key = "age";
    type Age = Person[key];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBrCCExQARIQjn5+6AEEiZuEjQBtYyAC6dIA)
### [Typeof Type OperatorUsing the typeof operator in type
contexts.](/docs/handbook/2/typeof-types.html)
### [Conditional TypesCreate types which act like if statements in the type
system.](/docs/handbook/2/conditional-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Indexed Access Types.md) ‚ù§
Contributors to this page:  
OT
Last updated: Sep 16, 2024  
Was this page helpful?
# Keyof Type Operator
## The `keyof` type operator
The `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = "x" | "y"`:
    ts
    type Point = { x: number; y: number };
    type P = keyof Point;
    type P = keyof Point
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbygDwFxRICuAtgEYQBOA3FCAceVVAL7UBQoks6UA1hBBwAZrEQoOAeklRZAPQD8QA)
If the type has a `string` or `number` index signature, `keyof` will return
those types instead:
    ts
    type Arrayish = { [n: number]: unknown };
    type A = keyof Arrayish;
    type A = number
    type Mapish = { [k: string]: boolean };
    type M = keyof Mapish;
    type M = string | number
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnAhiAlgZwBZQLxQN5QDaAdgFxTECuAtgEYRwC65lxA1sQPYDuxUAvgG4AUKEiwcUNhBCcAZrATJ0GEQHo1ULQD0A-MNHhoAWURgVkgoTbk0wOCmIBzZlFqdOAGwiI+Qw+LGktKyCqbmmOqaOrpAA)
Note that in this example, `M` is `string | number` ‚Äî this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj["0"]`.
`keyof` types become especially useful when combined with mapped types, which
we‚Äôll learn more about later.
### [GenericsTypes which take parameters](/docs/handbook/2/generics.html)
### [Typeof Type OperatorUsing the typeof operator in type
contexts.](/docs/handbook/2/typeof-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Keyof Type Operator.md) ‚ù§
Contributors to this page:  
OT
RM
MM
S
Last updated: Sep 16, 2024  
Was this page helpful?
# Mapped Types
When you don‚Äôt want to repeat yourself, sometimes a type needs to be based on
another type.
Mapped types build on the syntax for index signatures, which are used to
declare the types of properties which have not been declared ahead of time:
    ts
    type OnlyBoolsAndHorses = {
      [key: string]: boolean | Horse;
    };
    const conforms: OnlyBoolsAndHorses = {
      del: true,
      rodney: false,
    };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAEg9gJwM7QLxQN4F8DcAoAegKgFoyBjAV2DJL1EigHkA7AGxACE442kBBFgBN4yCEijoMeKFADaAawggAXFCTAEASxYBzALpqARjzYQAhiygAfWIhT5cePOTgsNUVywBmiALZIaqwc3LwCwqIoElIyUEIQbGqalBAANLEIcEIsymre5nxpeLhAA)
A mapped type is a generic type which uses a union of `PropertyKey`s
(frequently created [via a `keyof`](/docs/handbook/2/indexed-access-
types.html)) to iterate through keys to create a type:
    ts
    type OptionsFlags<Type> = {
      [Property in keyof Type]: boolean;
    };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+GoA)
In this example, `OptionsFlags` will take all the properties from the type
`Type` and change their values to be a boolean.
    ts
    type Features = {
      darkMode: () => void;
      newUserProfile: () => void;
    };
    type FeatureOptions = OptionsFlags<Features>;
    type FeatureOptions = {
        darkMode: boolean;
        newUserProfile: boolean;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+WgPR6oAWhMBjAK7ATR+qEhQMa4OfYQ01OoygATHO0EAskjeEPIAFACU1JQAbkgI3lpMKBAA7gCqaBDsHOIIquFRVLHxiTpatmQOTi4QcIio7jT1yOjY+ESOOM6uaOT6hkwAegD8QA)
### Mapping Modifiers
There are two additional modifiers which can be applied during mapping:
`readonly` and `?` which affect mutability and optionality respectively.
You can remove or add these modifiers by prefixing with `-` or `+`. If you
don‚Äôt add a prefix, then `+` is assumed.
    ts
    // Removes 'readonly' attributes from a type's properties
    type CreateMutable<Type> = {
      -readonly [Property in keyof Type]: Type[Property];
    };
    type LockedAccount = {
      readonly id: string;
      readonly name: string;
    };
    type UnlockedAccount = CreateMutable<LockedAccount>;
    type UnlockedAccount = {
        id: string;
        name: string;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHIBOkCGATWA7AGwE9VQsAXC9ASwCMBXC5UAM3VmnNAuIAdIqFHw4D0FGsgBQvAaADCmSpACyTLHUKQAPABV+kAHygAvKADeU0KAC0SvEWKgA2gAVRkcU5r5QAa0hiWFZQfQEAXQAuUIM3Dy9wgG4pAF9kmQNQABlYAGMAnABBXNzYBnwKUwsrUHsCElAaHGikah8Ac2TrOsdQfCxoSBa2-E7U9NlIUABVIjyC4tLyyrNFbGY1Cg0tbRz8yCKSsorDZJBrUAA9AH4gA)
    ts
    // Removes 'optional' attributes from a type's properties
    type Concrete<Type> = {
      [Property in keyof Type]-?: Type[Property];
    };
    type MaybeUser = {
      id: string;
      name?: string;
      age?: number;
    };
    type User = Concrete<MaybeUser>;
    type User = {
        id: string;
        name: string;
        age: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHJYAcAuBLWA7AQwBtVRCssAnHAIwFctlQAzK2ac0LATw0lQoM7flVzIAUL36gAwgQDGVSEwA8AFT6QAfKAC8oAN4TQoANoAFEZDE9QOfKADWkHrBahN-ALoBaAPwAXJ5alta23gDcEgC+0VJaoACyhDy0kACqSDb6Rib2ACbBSNQOAObRpkTQkEGgJTT4FfmEZbXB+PTQ6VTRcRIJMlk5BvL4SiqQqilpmdlU2tEgpqAAev5AA)
## Key Remapping via `as`
In TypeScript 4.1 and onwards, you can re-map keys in mapped types with an
`as` clause in a mapped type:
    ts
    type MappedTypeWithNewProperties<Type> = {
        [Properties in keyof Type as NewKeyType]: Type[Properties]
    }
You can leverage features like [template literal
types](/docs/handbook/2/template-literal-types.html) to create new property
names from prior ones:
    ts
    type Getters<Type> = {
        [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
    };
    interface Person {
        name: string;
        age: number;
        location: string;
    }
    type LazyPerson = Getters<Person>;
    type LazyPerson = {
        getName: () => string;
        getAge: () => number;
        getLocation: () => string;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4Aq4ID4oF4oBvAKCnKgG0AFJAe0iVCgEsA7KAawhDoDMoWSFACGKKAAMA5vAAkRAMIiwLYCIA2LAF4Q0KYEnZSoAMii0GyUDgC+EgLoAuKAAoAlATxCINeo1D2JDYA3CQk7IhIfCIAxtDUyCh0HKQUUGwiALYQzvqGbFKhaSIyzmwArpkARshFFOp0MSLALMm5BkahNmGgwgAyIlogCajJBLDwkegjSWw4oQD0CxQAegD8QA)
You can filter out keys by producing `never` via a conditional type:
    ts
    // Remove the 'kind' property
    type RemoveKindField<Type> = {
        [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]
    };
    interface Circle {
        kind: "circle";
        radius: number;
    }
    type KindlessCircle = RemoveKindField<Circle>;
    type KindlessCircle = {
        radius: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVWlQB8oALygA3vVBLQAbQAKFKjVqh8oLJFqwAZqDHMAhgGdQAUQAeAY34BXApCEbK1OgBpQAES4hAESALoAXGbikOqaPrRh9AC+ANz09PjI1MYWjkgAwjhkzkgKyvpcUQGOxaUB6RVkFgQ4LlZReC7QAEbU6ckZTEichPyQVlZFJeMyLHCIozx8gkLTpRLpIMoAegD8QA)
You can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:
    ts
    type EventConfig<Events extends { kind: string }> = {
        [E in Events as E["kind"]]: (event: E) => void;
    }
    type SquareEvent = { kind: "square", x: number, y: number };
    type CircleEvent = { kind: "circle", radius: number };
    type Config = EventConfig<SquareEvent | CircleEvent>
    type Config = {
        square: (event: SquareEvent) => void;
        circle: (event: CircleEvent) => void;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogbhAdsAwge0QMwJYHMA88SwAzlBAB7BIAmZA3lANbaI0BcUJwATq7lAC+APigBeKPQBQUWVADaMKK1gJkZAIZkY8gEQs2ugLpHOACghrgnGAEpxouGmw0A3FMFSpoSFADKAI4Arho8EETI4pLMrBxQuiTBoRC6ADRQFJyIQQC2AEYQPOkgWbkFPELuPtAo2DwAxgA24VZRjAZxuvV1TSnpPBo02EEkpfmFlV7VUOhYeFERqBg4BIEhYYtQAD4zPc2LwlIA9EdyAHoA-EA)
### Further Exploration
Mapped types work well with other features in this type manipulation section,
for example here is [a mapped type using a conditional
type](/docs/handbook/2/conditional-types.html) which returns either a `true`
or `false` depending on whether an object has the property `pii` set to the
literal `true`:
    ts
    type ExtractPII<Type> = {
      [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;
    };
    type DBFields = {
      id: { format: "incrementing" };
      name: { type: string; pii: true };
    };
    type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;
    type ObjectsNeedingGDPRDeletion = {
        id: false;
        name: true;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogHsATgQwMbAAoEksB4Aq4EAfFALxQDeAUFFANoaID2kioUAlgHZQDWEEMwBmUQpAC6ALjFFGLNqAlQICCNwAmAZypQwnTjKQBXaAF8oAfignoM4cgA2WiAG5qZ99VCQoAEQAhADFOCEdtcipaLg0ZSihhZkQAW2RgGQAiHlRECGT1YB4AcwyoT2juZHy4myIZLSRi1z0DI0RTMvdy7yIoAHkAIwArCHQtADkICA1igHE-DAAlPzCIQuZeCngkNEwcXECQsO1idwB6M7ooAD1LIA)
### [Conditional TypesCreate types which act like if statements in the type
system.](/docs/handbook/2/conditional-types.html)
### [Template Literal TypesGenerating mapping types which change properties
via template literal strings.](/docs/handbook/2/template-literal-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Mapped Types.md) ‚ù§
Contributors to this page:  
OT
SF
L
W
SGH
5+
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules
JavaScript has a long history of different ways to handle modularizing code.
Having been around since 2012, TypeScript has implemented support for a lot of
these formats, but over time the community and the JavaScript specification
has converged on a format called ES Modules (or ES6 modules). You might know
it as the `import`/`export` syntax.
ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad
support in most web browsers and JavaScript runtimes.
For focus, the handbook will cover both ES Modules and its popular pre-cursor
CommonJS `module.exports =` syntax, and you can find information about the
other module patterns in the reference section under
[Modules](/docs/handbook/modules.html).
## How JavaScript Modules are Defined
In TypeScript, just as in ECMAScript 2015, any file containing a top-level
`import` or `export` is considered a module.
Conversely, a file without any top-level import or export declarations is
treated as a script whose contents are available in the global scope (and
therefore to modules as well).
Modules are executed within their own scope, not in the global scope. This
means that variables, functions, classes, etc. declared in a module are not
visible outside the module unless they are explicitly exported using one of
the export forms. Conversely, to consume a variable, function, class,
interface, etc. exported from a different module, it has to be imported using
one of the import forms.
## Non-modules
Before we start, it‚Äôs important to understand what TypeScript considers a
module. The JavaScript specification declares that any JavaScript files
without an `import` declaration, `export`, or top-level `await` should be
considered a script and not a module.
Inside a script file variables and types are declared to be in the shared
global scope, and it‚Äôs assumed that you‚Äôll either use the
[`outFile`](/tsconfig#outFile) compiler option to join multiple input files
into one output file, or use multiple `<script>` tags in your HTML to load
these files (in the correct order!).
If you have a file that doesn‚Äôt currently have any `import`s or `export`s, but
you want to be treated as a module, add the line:
    ts
    export {};
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g)
which will change the file to be a module exporting nothing. This syntax works
regardless of your module target.
## Modules in TypeScript
> Additional Reading:  
>  [Impatient JS (Modules)](https://exploringjs.com/impatient-
> js/ch_modules.html#overview-syntax-of-ecmascript-modules)  
>  [MDN: JavaScript Modules](https://developer.mozilla.org/en-
> US/docs/Web/JavaScript/Guide/Modules)  
>
There are three main things to consider when writing module-based code in
TypeScript:
  * **Syntax** : What syntax do I want to use to import and export things?
  * **Module Resolution** : What is the relationship between module names (or paths) and files on disk?
  * **Module Output Target** : What should my emitted JavaScript module look like?
### ES Module Syntax
A file can declare a main export via `export default`:
    ts
    // @filename: hello.ts
    export default function helloWorld() {
      console.log("Hello, world!");
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA)
This is then imported via:
    ts
    import helloWorld from "./hello.js";
    helloWorld();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA)
In addition to the default export, you can have more than one export of
variables and functions via the `export` by omitting `default`:
    ts
    // @filename: maths.ts
    export var pi = 3.14;
    export let squareTwo = 1.41;
    export const phi = 1.61;
    export class RandomNumberGenerator {}
    export function absolute(num: number) {
      if (num < 0) return num * -1;
      return num;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA)
These can be used in another file via the `import` syntax:
    ts
    import { pi, phi, absolute } from "./maths.js";
    console.log(pi);
    const absPhi = absolute(phi);
    const absPhi: number
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA)
### Additional Import Syntax
An import can be renamed using a format like `import {old as new}`:
    ts
    import { pi as œÄ } from "./maths.js";
    console.log(œÄ);
    (alias) var œÄ: number
    import œÄ
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA)
You can mix and match the above syntax into a single `import`:
    ts
    // @filename: maths.ts
    export const pi = 3.14;
    export default class RandomNumberGenerator {}
    // @filename: app.ts
    import RandomNumberGenerator, { pi as œÄ } from "./maths.js";
    RandomNumberGenerator;
    (alias) class RandomNumberGenerator
    import RandomNumberGenerator
    console.log(œÄ);
    (alias) const œÄ: 3.14
    import œÄ
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A)
You can take all of the exported objects and put them into a single namespace
using `* as name`:
    ts
    // @filename: app.ts
    import * as math from "./maths.js";
    console.log(math.pi);
    const positivePhi = math.absolute(math.phi);
    const positivePhi: number
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA)
You can import a file and _not_ include any variables into your current module
via `import "./file"`:
    ts
    // @filename: app.ts
    import "./maths.js";
    console.log("3.14");
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA)
In this case, the `import` does nothing. However, all of the code in
`maths.ts` was evaluated, which could trigger side-effects which affect other
objects.
#### TypeScript Specific ES Module Syntax
Types can be exported and imported using the same syntax as JavaScript values:
    ts
    // @filename: animal.ts
    export type Cat = { breed: string; yearOfBirth: number };
    export interface Dog {
      breeds: string[];
      yearOfBirth: number;
    }
    // @filename: app.ts
    import { Cat, Dog } from "./animal.js";
    type Animals = Cat | Dog;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA)
TypeScript has extended the `import` syntax with two concepts for declaring an
import of a type:
###### `import type`
Which is an import statement which can _only_ import types:
    ts
    // @filename: animal.ts
    export type Cat = { breed: string; yearOfBirth: number };
    export type Dog = { breeds: string[]; yearOfBirth: number };
    export const createCatName = () => "fluffy";
    // @filename: valid.ts
    import type { Cat, Dog } from "./animal.js";
    export type Animals = Cat | Dog;
    // @filename: app.ts
    import type { createCatName } from "./animal.js";
    const name = createCatName();
    'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA)
###### Inline `type` imports
TypeScript 4.5 also allows for individual imports to be prefixed with `type`
to indicate that the imported reference is a type:
    ts
    // @filename: app.ts
    import { createCatName, type Cat, type Dog } from "./animal.js";
    export type Animals = Cat | Dog;
    const name = createCatName();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA)
Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to
know what imports can be safely removed.
#### ES Module Syntax with CommonJS Behavior
TypeScript has ES Module syntax which _directly_ correlates to a CommonJS and
AMD `require`. Imports using ES Module are _for most cases_ the same as the
`require` from those environments, but this syntax ensures you have a 1 to 1
match in your TypeScript file with the CommonJS output:
    ts
    import fs = require("fs");
    const code = fs.readFileSync("hello.ts", "utf8");
    [Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA)
You can learn more about this syntax in the [modules reference
page](/docs/handbook/modules.html#export--and-import--require).
## CommonJS Syntax
CommonJS is the format which most modules on npm are delivered in. Even if you
are writing using the ES Modules syntax above, having a brief understanding of
how CommonJS syntax works will help you debug easier.
#### Exporting
Identifiers are exported via setting the `exports` property on a global called
`module`.
    ts
    function absolute(num: number) {
      if (num < 0) return num * -1;
      return num;
    }
    module.exports = {
      pi: 3.14,
      squareTwo: 1.41,
      phi: 1.61,
      absolute,
    };
    [Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA)
Then these files can be imported via a `require` statement:
    ts
    const maths = require("./maths");
    maths.pi;
    any
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA)
Or you can simplify a bit using the destructuring feature in JavaScript:
    ts
    const { squareTwo } = require("./maths");
    squareTwo;
    const squareTwo: any
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA)
### CommonJS and ES Modules interop
There is a mis-match in features between CommonJS and ES Modules regarding the
distinction between a default import and a module namespace object import.
TypeScript has a compiler flag to reduce the friction between the two
different sets of constraints with
[`esModuleInterop`](/tsconfig#esModuleInterop).
## TypeScript‚Äôs Module Resolution Options
Module resolution is the process of taking a string from the `import` or
`require` statement, and determining what file that string refers to.
TypeScript includes two resolution strategies: Classic and Node. Classic, the
default when the compiler option [`module`](/tsconfig#module) is not
`commonjs`, is included for backwards compatibility. The Node strategy
replicates how Node.js works in CommonJS mode, with additional checks for
`.ts` and `.d.ts`.
There are many TSConfig flags which influence the module strategy within
TypeScript: [`moduleResolution`](/tsconfig#moduleResolution),
[`baseUrl`](/tsconfig#baseUrl), [`paths`](/tsconfig#paths),
[`rootDirs`](/tsconfig#rootDirs).
For the full details on how these strategies work, you can consult the [Module
Resolution](/docs/handbook/modules/reference.html#the-moduleresolution-
compiler-option) reference page.
## TypeScript‚Äôs Module Output Options
There are two options which affect the emitted JavaScript output:
  * [`target`](/tsconfig#target) which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact
  * [`module`](/tsconfig#module) which determines what code is used for modules to interact with each other
Which [`target`](/tsconfig#target) you use is determined by the features
available in the JavaScript runtime you expect to run the TypeScript code in.
That could be: the oldest web browser you support, the lowest version of
Node.js you expect to run on or could come from unique constraints from your
runtime - like Electron for example.
All communication between modules happens via a module loader, the compiler
option [`module`](/tsconfig#module) determines which one is used. At runtime
the module loader is responsible for locating and executing all dependencies
of a module before executing it.
For example, here is a TypeScript file using ES Modules syntax, showcasing a
few different options for [`module`](/tsconfig#module):
    ts
    import { valueOfPi } from "./constants.js";
    export const twoPi = valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA)
#### `ES2020`
    ts
    import { valueOfPi } from "./constants.js";
    export const twoPi = valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA)
#### `CommonJS`
    ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_js_1 = require("./constants.js");
    exports.twoPi = constants_js_1.valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA)
#### `UMD`
    ts
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "./constants.js"], factory);
        }
    })(function (require, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        const constants_js_1 = require("./constants.js");
        exports.twoPi = constants_js_1.valueOfPi * 2;
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA)
> Note that ES2020 is effectively the same as the original `index.ts`.
You can see all of the available options and what their emitted JavaScript
code looks like in the [TSConfig Reference for `module`](/tsconfig#module).
## TypeScript namespaces
TypeScript has its own module format called `namespaces` which pre-dates the
ES Modules standard. This syntax has a lot of useful features for creating
complex definition files, and still sees active use [in
DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). While
not deprecated, the majority of the features in namespaces exist in ES Modules
and we recommend you use that to align with JavaScript‚Äôs direction. You can
learn more about namespaces in [the namespaces reference
page](/docs/handbook/namespaces.html).
### [ClassesHow classes work in TypeScript](/docs/handbook/2/classes.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Modules.md) ‚ù§
Contributors to this page:  
RC
OT
M
AB
HA
18+
Last updated: Sep 16, 2024  
Was this page helpful?
# Narrowing
Imagine we have a function called `padLeft`.
    ts
    function padLeft(padding: number | string, input: string): string {
      throw new Error("Not implemented yet!");
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkRQAFkzgB3ath0BRJpqb4ARADk4UQbWQAbbLWxgo2dIgCe2KAEJTkgG5FAF8gA)
If `padding` is a `number`, it will treat that as the number of spaces we want
to prepend to `input`. If `padding` is a `string`, it should just prepend
`padding` to `input`. Let‚Äôs try to implement the logic for when `padLeft` is
passed a `number` for `padding`.
    ts
    function padLeft(padding: number | string, input: string): string {
      return " ".repeat(padding) + input;
    Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.2345Argument of type 'string | number' is not assignable to parameter of type 'number'.
      Type 'string' is not assignable to type 'number'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAA4CGAJgDKQEUAUTzzVJAOaoSRALYAjGKAA+oRBWgDBAGlAD6RCqgVKhASh2LloAN55QoaJApFodAESgHAOmv1Ijbr34HQAanUSTQoAbjwAXyA)
Uh-oh, we‚Äôre getting an error on `padding`. TypeScript is warning us that we‚Äôre passing a value with type `number | string` to the `repeat` function, which only accepts a `number`, and it‚Äôs right. In other words, we haven‚Äôt explicitly checked if `padding` is a `number` first, nor are we handling the case where it‚Äôs a `string`, so let‚Äôs do exactly that.
    ts
    function padLeft(padding: number | string, input: string): string {
      if (typeof padding === "number") {
        return " ".repeat(padding) + input;
      }
      return padding + input;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBwBfB2dXdxQMQzJEUKERaJigA)
If this mostly looks like uninteresting JavaScript code, that‚Äôs sort of the
point. Apart from the annotations we put in place, this TypeScript code looks
like JavaScript. The idea is that TypeScript‚Äôs type system aims to make it as
easy as possible to write typical JavaScript code without bending over
backwards to get type safety.
While it might not look like much, there‚Äôs actually a lot going on under the
covers here. Much like how TypeScript analyzes runtime values using static
types, it overlays type analysis on JavaScript‚Äôs runtime control flow
constructs like `if/else`, conditional ternaries, loops, truthiness checks,
etc., which can all affect those types.
Within our `if` check, TypeScript sees `typeof padding === "number"` and
understands that as a special form of code called a _type guard_. TypeScript
follows possible paths of execution that our programs can take to analyze the
most specific possible type of a value at a given position. It looks at these
special checks (called _type guards_) and assignments, and the process of
refining types to more specific types than declared is called _narrowing_. In
many editors we can observe these types as they change, and we‚Äôll even do so
in our examples.
    ts
    function padLeft(padding: number | string, input: string): string {
      if (typeof padding === "number") {
        return " ".repeat(padding) + input;
    (parameter) padding: number
      }
      return padding + input;
    (parameter) padding: string
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBxUAeljHRKTEgD0AfgcAXwdnV3cUDEMyRFChEWi4hNSMzKA)
There are a couple of different constructs TypeScript understands for
narrowing.
## `typeof` type guards
As we‚Äôve seen, JavaScript supports a `typeof` operator which can give very
basic information about the type of values we have at runtime. TypeScript
expects this to return a certain set of strings:
  * `"string"`
  * `"number"`
  * `"bigint"`
  * `"boolean"`
  * `"symbol"`
  * `"undefined"`
  * `"object"`
  * `"function"`
Like we saw with `padLeft`, this operator comes up pretty often in a number of
JavaScript libraries, and TypeScript can understand it to narrow types in
different branches.
In TypeScript, checking against the value returned by `typeof` is a type
guard. Because TypeScript encodes how `typeof` operates on different values,
it knows about some of its quirks in JavaScript. For example, notice that in
the list above, `typeof` doesn‚Äôt return the string `null`. Check out the
following example:
    ts
    function printAll(strs: string | string[] | null) {
      if (typeof strs === "object") {
        for (const s of strs) {
    'strs' is possibly 'null'.18047'strs' is possibly 'null'.
          console.log(s);
        }
      } else if (typeof strs === "string") {
        console.log(strs);
      } else {
        // do nothing
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMBGUOAOABgBYB2AKADMBXAOwGMAXASzjtAAdoW6mBBADaCAFIiZJU4nnQDmoAD6hpvWQG0AuotB0awgJSgA3hVCgWVUCKYBPTpDiXpiUAF53oAERwARgCtIZk9DEzMzKgQrBnZxZVBHZQlEENMws2i6RDhBSAA6QThZMX0AblSzAF9UitBIQURIc0trOwcnJLcPTxU5YONy0AysnPzCsSTS6tr6xtCwkFAAEzgdOCYAC1VqigqgA)
In the `printAll` function, we try to check if `strs` is an object to see if
it‚Äôs an array type (now might be a good time to reinforce that arrays are
object types in JavaScript). But it turns out that in JavaScript, `typeof
null` is actually `"object"`! This is one of those unfortunate accidents of
history.
Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.
This might be a good segue into what we‚Äôll call ‚Äútruthiness‚Äù checking.
# Truthiness narrowing
Truthiness might not be a word you‚Äôll find in the dictionary, but it‚Äôs very
much something you‚Äôll hear about in JavaScript.
In JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if`
statements, Boolean negations (`!`), and more. As an example, `if` statements
don‚Äôt expect their condition to always have the type `boolean`.
    ts
    function getUsersOnlineMessage(numUsersOnline: number) {
      if (numUsersOnline) {
        return `There are ${numUsersOnline} online now!`;
      }
      return "Nobody's here. :(";
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQKoGdUCcsDyYANjGKgLKpZYCGaAFGCALbZ6ElmoBcizLAEZ4AlIgDeAKESIYwRE1bt8RUuTFSZM3OhC4kAAwAqACzypEtHYgAk4gcs5rUAX0QJn-OAHcAhAYBuaUQXYJ0oPSQAIgA5OEE4ABMATwByLEQzHQA6RB4GKKCXIA)
In JavaScript, constructs like `if` first ‚Äúcoerce‚Äù their conditions to
`boolean`s to make sense of them, and then choose their branches depending on
whether the result is `true` or `false`. Values like
  * `0`
  * `NaN`
  * `""` (the empty string)
  * `0n` (the `bigint` version of zero)
  * `null`
  * `undefined`
all coerce to `false`, and other values get coerced to `true`. You can always
coerce values to `boolean`s by running them through the `Boolean` function, or
by using the shorter double-Boolean negation. (The latter has the advantage
that TypeScript infers a narrow literal boolean type `true`, while inferring
the first as type `boolean`.)
    ts
    // both of these result in 'true'
    Boolean("hello"); // type: boolean, value: true
    !!"world"; // type: true,    value: true
    This kind of expression is always truthy.2872This kind of expression is always truthy.[Try](https://www.typescriptlang.org/play/#code/PTAECMHsBcAtUgM1HApgZ1aAThgrgDbSgCWAdqAOTTZ6qUBQAQpJAagIZkAUARLKgIFIvAJQBuUCBQBPAA6oAXBFbsuAGlAA3DgTrKadBgEJjvAO6RsBACa9J06PKUpaqTaE869Lw6iA)
It‚Äôs fairly popular to leverage this behavior, especially for guarding against
values like `null` or `undefined`. As an example, let‚Äôs try using it for our
`printAll` function.
    ts
    function printAll(strs: string | string[] | null) {
      if (strs && typeof strs === "object") {
        for (const s of strs) {
          console.log(s);
        }
      } else if (typeof strs === "string") {
        console.log(strs);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogBkcxFACeyAKZxJVWQF49iAERwARgCs10AwJFixwOKikQExSok1NS10bbHOwhHA4agB0OHA0RHwA3D5iAL4+8YhqOIRq4pL4Kuoe2oh6OoZULFZCcYj+gcFhEdJesQnC8UA)
You‚Äôll notice that we‚Äôve gotten rid of the error above by checking if `strs`
is truthy. This at least prevents us from dreaded errors when we run our code
like:
    txt
    TypeError: null is not iterable
Keep in mind though that truthiness checking on primitives can often be error
prone. As an example, consider a different attempt at writing `printAll`
    ts
    function printAll(strs: string | string[] | null) {
      // !!!!!!!!!!!!!!!!
      //  DON'T DO THIS!
      //   KEEP READING
      // !!!!!!!!!!!!!!!!
      if (strs) {
        if (typeof strs === "object") {
          for (const s of strs) {
            console.log(s);
          }
        } else if (typeof strs === "string") {
          console.log(strs);
        }
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRAHpxiAISy58hdNESpiACIB5AHIByACrqNiPQAkAkgGUlYyWMQBpAKKOACogBKjrGrNaA4sq2isFyyjDAiEQkhAIidojhkVAAnsgApnARVISIALz5iABEcABGAFZp0IWxyvHAcKiREAjElIiZTKQ18fHNYIRwOGkAdDhwNER8ANy1dgC+s3OIaTiEaQkR+CnpHdl5BYVULNVCs2J9A0Oj41FdM-ELYgtzQA)
We wrapped the entire body of the function in a truthy check, but this has a
subtle downside: we may no longer be handling the empty string case correctly.
TypeScript doesn‚Äôt hurt us here at all, but this behavior is worth noting if
you‚Äôre less familiar with JavaScript. TypeScript can often help you catch bugs
early on, but if you choose to do _nothing_ with a value, there‚Äôs only so much
that it can do without being overly prescriptive. If you want, you can make
sure you handle situations like these with a linter.
One last word on narrowing by truthiness is that Boolean negations with `!`
filter out from negated branches.
    ts
    function multiplyAll(
      values: number[] | undefined,
      factor: number
    ): number[] | undefined {
      if (!values) {
        return values;
      } else {
        return values.map((x) => x * factor);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwIJpoAUAUIogG4CGaIApgM4BciYIyARnQE4DaAuogA+icABM6wGGDpiANGUTAq0ONxZtOPEgEoN7Ln0Ejxk6bMQBvRTGCIiAQmq1GOq4vLc6UENyTP6BgBuRQBfRDo0Bjp3ck9vX38aQIA6ZCpMIiIADzcAXgA+RGzEAColFSg1HRDyUJJQoA)
## Equality narrowing
TypeScript also uses `switch` statements and equality checks like `===`,
`!==`, `==`, and `!=` to narrow types. For example:
    ts
    function example(x: string | number, y: string | boolean) {
      if (x === y) {
        // We can now call any 'string' method on 'x' or 'y'.
        x.toUpperCase();
    (method) String.toUpperCase(): string
        y.toLowerCase();
    (method) String.toLowerCase(): string
      } else {
        console.log(x);
    (parameter) x: string | number
        console.log(y);
    (parameter) y: string | boolean
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgClQC5EBnKAJxjAHNEAfRMETAI2UoBpEBPUitTqNEbOHHzowASkQBvAFCJEMYIiKIAvNr6zFy5QHpDiAOrJEEKczgB3S+ly5EU3ogDkgmrXeJMyKAALOAATRAQPVF84Sg9edwA6JQNUBKg4AFVsbE4AYXQyQmkAbmSjEwA9AH4yvjS4ABk7PIKi0oNEY0Rq5IBfFFxC+VqIBDIJZATcOFoiEtqujqWejtGwcfwpmYJeeY7FpYMVxF6FXqA)
When we checked that `x` and `y` are both equal in the above example,
TypeScript knew their types also had to be equal. Since `string` is the only
common type that both `x` and `y` could take on, TypeScript knows that `x` and
`y` must be `string`s in the first branch.
Checking against specific literal values (as opposed to variables) works also.
In our section about truthiness narrowing, we wrote a `printAll` function
which was error-prone because it accidentally didn‚Äôt handle empty strings
properly. Instead we could have done a specific check to block out `null`s,
and TypeScript still correctly removes `null` from the type of `strs`.
    ts
    function printAll(strs: string | string[] | null) {
      if (strs !== null) {
        if (typeof strs === "object") {
          for (const s of strs) {
    (parameter) strs: string[]
            console.log(s);
          }
        } else if (typeof strs === "string") {
          console.log(strs);
    (parameter) strs: string
        }
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogCEAXgXdeOASLFiJUqAE9kAUziSqspcoBEcAEYArA9AvrRmscDiopEBMUqJjTKTOrq4A9KEhkYgAegD8LpHeYIRwOAYAdDhwNER8ANwJmgC+hUWIBjiEBuKS+HqGAaaI5ogWVCxOQoViSSlpmdnSQQWR4VGacaUuJUVAA)
JavaScript‚Äôs looser equality checks with `==` and `!=` also get narrowed
correctly. If you‚Äôre unfamiliar, checking whether something `== null` actually
not only checks whether it is specifically the value `null` \- it also checks
whether it‚Äôs potentially `undefined`. The same applies to `== undefined`: it
checks whether a value is either `null` or `undefined`.
    ts
    interface Container {
      value: number | null | undefined;
    }
    function multiplyValue(container: Container, factor: number) {
      // Remove both 'null' and 'undefined' from the type.
      if (container.value != null) {
        console.log(container.value);
    (property) Container.value: number
        // Now we can safely multiply 'container.value'.
        container.value *= factor;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NZBvAKGWQDc4AbAVwgC5kRKBbAI1wB97LzzkPKQAJhBg4BAbgIBfAgRj8EYYJmSMuigA7kAngDUK1ABQJMYbCGh0MWHFAA0yeAvRQ6DFtACU+IsgD0v5AAlCEZ0EhRmdDAAC2QAcgZuOOQ4QXj+IRFzAWSYKHRGZBiUMC11CAA6H2AYZCMTM2gKsioUAEIAXk5uL0JiYmMQAGd0ckrydABzeutzKGb9CA8Jfr8A1Y3N1YA9AH4ZVf9kADl0AHdkM5QEVOQhuBgIbRU1YE0teMHTGwXWuKrVl9GvMWtRkAAqLqOMDOFbIaSSIA)
## The `in` operator narrowing
JavaScript has an operator for determining if an object or its prototype chain
has a property with a name: the `in` operator. TypeScript takes this into
account as a way to narrow down potential types.
For example, with the code: `"value" in x`. where `"value"` is a string
literal and `x` is a union type. The ‚Äútrue‚Äù branch narrows `x`‚Äôs types which
have either an optional or required property `value`, and the ‚Äúfalse‚Äù branch
narrows to types which have an optional or missing property `value`.
    ts
    type Fish = { swim: () => void };
    type Bird = { fly: () => void };
    function move(animal: Fish | Bird) {
      if ("swim" in animal) {
        return animal.swim();
      }
      return animal.fly();
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw4dRAVwB2AY2Bw6aqPjo0IJAIZqCJ8cXjIoAHz6DGFDByhQ4o0gCJcBbx56ZhbiLm7uUAIQwCoCQeb4lgB0fvjknO4sSu5RMXFQwYniSRIg6RwsQA)
To reiterate, optional properties will exist in both sides for narrowing. For
example, a human could both swim and fly (with the right equipment) and thus
should show up in both sides of the `in` check:
    ts
    type Fish = { swim: () => void };
    type Bird = { fly: () => void };
    type Human = { swim?: () => void; fly?: () => void };
    function move(animal: Fish | Bird | Human) {
      if ("swim" in animal) {
        animal;
    (parameter) animal: Fish | Human
      } else {
        animal;
    (parameter) animal: Bird | Human
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuy7hoACQCu+AIYA7NJmx58AfmkVU1ekzZQJIE6TMX5rTh1FrtAY2Bw6u-HQ0ECQ6BJrixPDIUAA+fILMcepa2hQYHFBQcKKkAES4BLlZuqFa4mkZmVCl4ZwA9HWZAHpGlSxQEOII0OlV1dph4vWNUC1tHCxAA)
## `instanceof` narrowing
JavaScript has an operator for checking whether or not a value is an
‚Äúinstance‚Äù of another value. More specifically, in JavaScript `x instanceof
Foo` checks whether the _prototype chain_ of `x` contains `Foo.prototype`.
While we won‚Äôt dive deep here, and you‚Äôll see more of this when we get into
classes, they can still be useful for most values that can be constructed with
`new`. As you might have guessed, `instanceof` is also a type guard, and
TypeScript narrows in branches guarded by `instanceof`s.
    ts
    function logValue(x: Date | string) {
      if (x instanceof Date) {
        console.log(x.toUTCString());
    (parameter) x: Date
      } else {
        console.log(x.toUpperCase());
    (parameter) x: string
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgcwGoENkgKYAUAHgFyIAiWUeiAPogM5QBOMYaAlIgN4BQiiGMETFBYJlkh44wytS58BAiAgZxkeAHSo0xTVDgBVACoBhAMos2ujhwDc-JQHonSt0oB6AfkcBfRHjIDDSKSiri6lo6egaGAA5xeMymWMEEtg5uLu7u3n68vkA)
## Assignments
As we mentioned earlier, when we assign to any variable, TypeScript looks at
the right side of the assignment and narrows the left side appropriately.
    ts
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    let x: string | number
    x = 1;
    console.log(x);
    let x: number
    x = "goodbye!";
    console.log(x);
    let x: string
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EFkCGYAWA6ATkgdgEwHsBbACgEoIAeCABnQFYIB+CARhogC4IAiVEYMAIQA7gUzA8AQh4BuAFAB6RRAgA9JvJjxWC+QGMCOAM4FQ6IQHMSUMguWrHT9Zu29LBAngBGATxAyeoYmZiAWBNa29irOThpAA)
Notice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the _declared type_ of `x` \- the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.
If we‚Äôd assigned a `boolean` to `x`, we‚Äôd have seen an error since that wasn‚Äôt
part of the declared type.
    ts
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    let x: string | number
    x = 1;
    console.log(x);
    let x: number
    x = true;
    Type 'boolean' is not assignable to type 'string | number'.2322Type 'boolean' is not assignable to type 'string | number'.
    console.log(x);
    let x: string | number
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABtIAXUAD1AF5QBZAQ0IAsA6aGgOwBM4BbACgEpQAHlAAGRgFZQAflABGEaFQAiepDx44oAO4I87AIRKA3DhChQAPSk4ylWSZwBjOK0RwCjDQHMeJPibNzIOCrGwpQQmgAV0gHZ1d3SE84Hz8AsGDMqyA)
## Control flow analysis
Up until this point, we‚Äôve gone through some basic examples of how TypeScript
narrows within specific branches. But there‚Äôs a bit more going on than just
walking up from every variable and looking for type guards in `if`s, `while`s,
conditionals, etc. For example
    ts
    function padLeft(padding: number | string, input: string) {
      if (typeof padding === "number") {
        return " ".repeat(padding) + input;
      }
      return padding + input;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJSIA3gChEg4InxQAnsmxxlREuUQBeI4gBENBsxPT5ixU2xQQTJCdMA6e5tQFdvaQGpBMGEoAG4FRABfCPtHZxQMPTJEQKERcMigA)
`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is _unreachable_ in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.
This analysis of code based on reachability is called _control flow analysis_
, and TypeScript uses this flow analysis to narrow types as it encounters type
guards and assignments. When a variable is analyzed, control flow can split
off and re-merge over and over again, and that variable can be observed to
have a different type at each point.
    ts
    function example() {
      let x: string | number | boolean;
      x = Math.random() < 0.5;
      console.log(x);
    let x: boolean
      if (Math.random() < 0.5) {
        x = "hello";
        console.log(x);
    let x: string
      } else {
        x = 100;
        console.log(x);
    let x: number
      }
      return x;
    let x: string | number
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgCgEpEBvAKEUXykVQC5EBnKAJxjAHNEAfRMEJgBGyVr0RC4cfOjABucpTqIAvIgCy6KAAsAdK1kATOJmKIAPIgAMugKwKlEBE2nJduOJwKoiCqgHp-KmCQxAA9AH5FKhhgRAJNHX0jEzNLG1sSChDUVUQAIm1kXA98v2CnMBd8d09vXyUAoNCQyKUAXxRcJmQyRuU1AEYrK3KqSuq3Dy8fMcRAltaoqnboxFZkKBBWJFRyhaXydqA)
## Using type predicates
We‚Äôve worked with existing JavaScript constructs to handle narrowing so far,
however sometimes you want more direct control over how types change
throughout your code.
To define a user-defined type guard, we simply need to define a function whose
return type is a _type predicate_ :
    ts
    function isFish(pet: Fish | Bird): pet is Fish {
      return (pet as Fish).swim !== undefined;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTgHo-KABaEJUdYBCgjl0DIxMoRDckEkhgV0QUL34hMmJUhIRYDMwOKCgtYB0BUxTLKHVCpLIAOlwCKABCVHR9ZVE4PQhfDhYgA)
`pet is Fish` is our type predicate in this example. A predicate takes the
form `parameterName is Type`, where `parameterName` must be the name of a
parameter from the current function signature.
Any time `isFish` is called with some variable, TypeScript will _narrow_ that
variable to that specific type if the original type is compatible.
    ts
    // Both calls to 'swim' and 'fly' are now okay.
    let pet = getSmallPet();
    if (isFish(pet)) {
      pet.swim();
    } else {
      pet.fly();
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTroNGJlCIbkgkkMCuiChe-EJkxBHBCLDRmBxQUFrAOgKm4ZZQ6imhZAB0uARQAISo6PrKonB6EL4cLBwA9J1QALT9KjrA-b1dPbx0wCgqduIpwHRQAOSV+EtFesxLEiDrmtB6dDhQdADW6iBlHOKFSegW1rb2TsDknBxwoqQh0QXAZBQMBkoBEKnh8G92lAIHNoEDMqCdpCWEA)
Notice that TypeScript not only knows that `pet` is a `Fish` in the `if`
branch; it also knows that in the `else` branch, you _don‚Äôt_ have a `Fish`, so
you must have a `Bird`.
You may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:
    ts
    const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
    const underWater1: Fish[] = zoo.filter(isFish);
    // or, equivalently
    const underWater2: Fish[] = zoo.filter(isFish) as Fish[];
    // The predicate may need repeating for more complex examples
    const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
      if (pet.name === "sharkey") return false;
      return isFish(pet);
    });
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMBuKAOwEN8JiFgAnOGwDmUAL7MAUKEhQAQnH6M0mKADMANiGLkqtBi3Zce2AUNETJjCAGMNHftDUBXNjeBw6bKMIjAAyvgcGhoACn7kxPDIUAA+8ooski5uHl5QiNFIJJDAUYgo8QpKZMS5GQiwBZiSUFCOwM783jl+UByVWWQAdLgEUACEqOiu1mpCEElikgD0M1AAtEs2zsBLC5I2XnxQAF50dDpZcQklANoAuipnvgFBIeHA5AA0Pn6BwWERZK+3Hw-fC5SLZsHajCD8ADqHGAEIAjPlkJcVPs6N1xhpYfwSJkCmQpHMoHR+K8IABHZxwGjBCBsYBaTbbYBQcFQmEQgBMiKQyPQqPRcExEJxCC67U6BUuUlm8wAKkhoGBHIw4DZ2VAgiB2BBJvUIJAYeZ1MSNcToFt8GANBAAB5QW1cK0QBCM0HM1nQrEAZm5vL2BwFQuxrWApSg5UQVRiqGoGFqGTUpFy3U43DQwygACJkA4ANYQECZigNJreNTBBAQKR1EvNCpZEP4yRifFAA)
In addition, classes can [use `this is
Type`](/docs/handbook/2/classes.html#this-based-type-guards) to narrow their
type.
## Assertion functions
Types can also be narrowed using [Assertion functions](/docs/handbook/release-
notes/typescript-3-7.html#assertion-functions).
# Discriminated unions
Most of the examples we‚Äôve looked at so far have focused around narrowing
single variables with simple types like `string`, `boolean`, and `number`.
While this is common, most of the time in JavaScript we‚Äôll be dealing with
slightly more complex structures.
For some motivation, let‚Äôs imagine we‚Äôre trying to encode shapes like circles
and squares. Circles keep track of their radiuses and squares keep track of
their side lengths. We‚Äôll use a field called `kind` to tell which shape we‚Äôre
dealing with. Here‚Äôs a first attempt at defining `Shape`.
    ts
    interface Shape {
      kind: "circle" | "square";
      radius?: number;
      sideLength?: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AXyA)
Notice we‚Äôre using a union of string literal types: `"circle"` and `"square"` to tell us whether we should treat the shape as a circle or square respectively. By using `"circle" | "square"` instead of `string`, we can avoid misspelling issues.
    ts
    function handleShape(shape: Shape) {
      // oops!
      if (shape.kind === "rect") {
    This comparison appears to be unintentional because the types '"circle" | "square"' and '"rect"' have no overlap.2367This comparison appears to be unintentional because the types '"circle" | "square"' and '"rect"' have no overlap.
        // ...
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAJYB2ALjAGYCGAxpKAMoAWlADnQN56igDWxAJqgBE1AtGoAbSENAAfUEMQBHAK6Vo0gNxdQ0SvwIrEAflREVAWwBGMbd0QF+kADKQiAcxKNToc9dt4AL54eCCgALSR1CokkeF45CpE1CQEcESgzET8UkyskAAUiMxsqHlsAJSgnNxhcHAsiACEOgTkoEUlkAB0fNmgALxDChopQlU13KBh3bM6wYFAA)
We can write a `getArea` function that applies the right logic based on if
it‚Äôs dealing with a circle or square. We‚Äôll first try dealing with circles.
    ts
    function getArea(shape: Shape) {
      return Math.PI * shape.radius ** 2;
    'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIoa0utCFALJMwQB0AAoAkqAAVKA1jQPmltYTk2gmUUA)
Under [`strictNullChecks`](/tsconfig#strictNullChecks) that gives us an error
- which is appropriate since `radius` might not be defined. But what if we
perform the appropriate checks on the `kind` property?
    ts
    function getArea(shape: Shape) {
      if (shape.kind === "circle") {
        return Math.PI * shape.radius ** 2;
    'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIpQMoNW1kAB04tQSoAC8o5pyCsrSLW0iZiW60IUAskzBvQAKAJKgAFSgNY295pbWe-to7qAxUUA)
Hmm, TypeScript still doesn‚Äôt know what to do here. We‚Äôve hit a point where we
know more about our values than the type checker does. We could try to use a
non-null assertion (a `!` after `shape.radius`) to say that `radius` is
definitely present.
    ts
    function getArea(shape: Shape) {
      if (shape.kind === "circle") {
        return Math.PI * shape.radius! ** 2;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AX3z4A9HeQBaFwl5gXT-DF4gEYYAB7EGQDCDAAQUE4AApOTBwqDGwIAEpkAiJgGGQ4hIgAOlIQMmQAXgqaOgZmanTMojFw3igQgFk4YwKABQBJZAAqZHiUgvFJaQBCQaGAJnVkGysgA)
But this doesn‚Äôt feel ideal. We had to shout a bit at the type-checker with
those non-null assertions (`!`) to convince it that `shape.radius` was
defined, but those assertions are error-prone if we start to move code around.
Additionally, outside of [`strictNullChecks`](/tsconfig#strictNullChecks)
we‚Äôre able to accidentally access any of those fields anyway (since optional
properties are just assumed to always be present when reading them). We can
definitely do better.
The problem with this encoding of `Shape` is that the type-checker doesn‚Äôt
have any way to know whether or not `radius` or `sideLength` are present based
on the `kind` property. We need to communicate what _we_ know to the type
checker. With that in mind, let‚Äôs take another swing at defining `Shape`.
    ts
    interface Circle {
      kind: "circle";
      radius: number;
    }
    interface Square {
      kind: "square";
      sideLength: number;
    }
    type Shape = Circle | Square;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1JiA)
Here, we‚Äôve properly separated `Shape` out into two types with different
values for the `kind` property, but `radius` and `sideLength` are declared as
required properties in their respective types.
Let‚Äôs see what happens here when we try to access the `radius` of a `Shape`.
    ts
    function getArea(shape: Shape) {
      return Math.PI * shape.radius ** 2;
    Property 'radius' does not exist on type 'Shape'.
      Property 'radius' does not exist on type 'Square'.2339Property 'radius' does not exist on type 'Shape'.
      Property 'radius' does not exist on type 'Square'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBLAOwBcYAzAQwGNJQBhfaKgG1oG9dRQBrIgE1QAiKoxaRBAbk6hoFPvgCuKUIQUBbAEYwpAX1wES5arQDKARwUVo7ab0IDQgxBavipXRPj6QAMpEIA5sQAFqiqmtq4erjEAJ4ADqbBFImgALz0oqygAD6g5pbWUrggoAC0FVQKxBVluGQKhFTE+HCEoAGQxACC1hQAFIjJiagmw5AAlKAcXNbECtDtALIUIQB0AAoAkqAAVKBDKZBrsvJKe-toukA)
Like with our first definition of `Shape`, this is still an error. When
`radius` was optional, we got an error (with
[`strictNullChecks`](/tsconfig#strictNullChecks) enabled) because TypeScript
couldn‚Äôt tell whether the property was present. Now that `Shape` is a union,
TypeScript is telling us that `shape` might be a `Square`, and `Square`s don‚Äôt
have `radius` defined on them! Both interpretations are correct, but only the
union encoding of `Shape` will cause an error regardless of how
[`strictNullChecks`](/tsconfig#strictNullChecks) is configured.
But what if we tried checking the `kind` property again?
    ts
    function getArea(shape: Shape) {
      if (shape.kind === "circle") {
        return Math.PI * shape.radius ** 2;
    (parameter) shape: Circle
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCImAYZDqWgDotMkCAoNoQxnbOojZyrigSgFk4e36ABQBJZAAqZHq-CH72Tl4d3YAmIxmEmdu7mYA9AH5WSXEgA)
That got rid of the error! When every type in a union contains a common
property with literal types, TypeScript considers that to be a _discriminated
union_ , and can narrow out the members of the union.
In this case, `kind` was that common property (which is what‚Äôs considered a
_discriminant_ property of `Shape`). Checking whether the `kind` property was
`"circle"` got rid of every type in `Shape` that didn‚Äôt have a `kind` property
with the type `"circle"`. That narrowed `shape` down to the type `Circle`.
The same checking works with `switch` statements as well. Now we can try to
write our complete `getArea` without any pesky `!` non-null assertions.
    ts
    function getArea(shape: Shape) {
      switch (shape.kind) {
        case "circle":
          return Math.PI * shape.radius ** 2;
    (parameter) shape: Circle
        case "square":
          return shape.sideLength ** 2;
    (parameter) shape: Square
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFoQxgpWKbZyrigSgFk4e2GABQBJZAAqZHq-CGH2Tl5Ts4AmIymE1bf3ogA9AH4V6dn5npoks-kR1GANiULt5hiYzJYbPZ7sgnn9Xu8fqxJOIgA)
The important thing here was the encoding of `Shape`. Communicating the right
information to TypeScript - that `Circle` and `Square` were really two
separate types with specific `kind` fields - was crucial. Doing that lets us
write type-safe TypeScript code that looks no different than the JavaScript we
would‚Äôve written otherwise. From there, the type system was able to do the
‚Äúright‚Äù thing and figure out the types in each branch of our `switch`
statement.
> As an aside, try playing around with the above example and remove some of
> the return keywords. You‚Äôll see that type-checking can help avoid bugs when
> accidentally falling through different clauses in a `switch` statement.
Discriminated unions are useful for more than just talking about circles and
squares. They‚Äôre good for representing any sort of messaging scheme in
JavaScript, like when sending messages over the network (client/server
communication), or encoding mutations in a state management framework.
# The `never` type
When narrowing, you can reduce the options of a union to a point where you
have removed all possibilities and have nothing left. In those cases,
TypeScript will use a `never` type to represent a state which shouldn‚Äôt exist.
# Exhaustiveness checking
The `never` type is assignable to every type; however, no type is assignable
to `never` (except `never` itself). This means you can use narrowing and rely
on `never` turning up to do exhaustive checking in a `switch` statement.
For example, adding a `default` to our `getArea` function which tries to
assign the shape to `never` will not raise an error when every possible case
has been handled.
    ts
    type Shape = Circle | Square;
    function getArea(shape: Shape) {
      switch (shape.kind) {
        case "circle":
          return Math.PI * shape.radius ** 2;
        case "square":
          return shape.sideLength ** 2;
        default:
          const _exhaustiveCheck: never = shape;
          return _exhaustiveCheck;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJ+APRvkAWh8IuYHy98MABPAAdFOzgI5ABeNHocZAAfZGVVdRZ8GC4QBDBgAHsQZGsIMABBdTgACh4oiKoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFpExgpWKbZyrigSgFk4e2GABQBJZAAqZHroiGH2Tl5Ts4AmIymZud19dWpl1aJ1MA2ShcIsMTGZLDZ7PdkE8VsgzPAuFgwN8fghijwwMgAPoQAAeUV4BQAbhBUHYIAhiPwICSoHFzi1nqs-gDsXiCRjgCSyRTiM9JOIgA)
Adding a new member to the `Shape` union, will cause a TypeScript error:
    ts
    interface Triangle {
      kind: "triangle";
      sideLength: number;
    }
    type Shape = Circle | Square | Triangle;
    function getArea(shape: Shape) {
      switch (shape.kind) {
        case "circle":
          return Math.PI * shape.radius ** 2;
        case "square":
          return shape.sideLength ** 2;
        default:
          const _exhaustiveCheck: never = shape;
    Type 'Triangle' is not assignable to type 'never'.2322Type 'Triangle' is not assignable to type 'never'.
          return _exhaustiveCheck;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGE9pKAbGgbx1FAGtCATVAESUGzSAIDcHUNHK88AVxSgC8gLYAjGJIC+OfMTJUaAZQCO88tDZSeBfqAGJzlsZM6I8vSABlIBAOZEABaoKhpaOLogoAC0cZTyRHEx+iTQFNSgACrQeOQBLKDsnLb2AkS5+f4sElIeXr4BwaFqmtA6ekQAngAOJkHkfaAAvHQihQA+oGYWVqBTOXkFkJI4pPIElER4cASg-pBEAIJW5AAUiAN9qMZXkACURXUA7nhElEGgF3cAdKWPxU4oEo5EQNCE4zEyCkQOkh3k0D2AFlyMEfgAFACSoAAVKBLoNID8ZHJFLi8Wg3ECQWCHE5ZlCYUCrEQEXsCX0fvUfH5Ap8cRSqZwvBR5EwiNDYZxKLtEERQAB9SAADwGim2ADdILQgpBKFxQpAtdARvi7kLmfDEYqVWq5XgtTq9VwqbptEA)
### [Everyday TypesThe language primitives.](/docs/handbook/2/everyday-
types.html)
### [More on FunctionsLearn about how Functions work in
TypeScript.](/docs/handbook/2/functions.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Narrowing.md) ‚ù§
Contributors to this page:  
RC
OT
SB
AB
DR
27+
Last updated: Sep 16, 2024  
Was this page helpful?
# Object Types
In JavaScript, the fundamental way that we group and pass around data is
through objects. In TypeScript, we represent those through _object types_.
As we‚Äôve seen, they can be anonymous:
    ts
    function greet(person: { name: string; age: number }) {
      return "Hello " + person.name;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA)
or they can be named by using either an interface:
    ts
    interface Person {
      name: string;
      age: number;
    }
    function greet(person: Person) {
      return "Hello " + person.name;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA)
or a type alias:
    ts
    type Person = {
      name: string;
      age: number;
    };
    function greet(person: Person) {
      return "Hello " + person.name;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA)
In all three examples above, we‚Äôve written functions that take objects that
contain the property `name` (which must be a `string`) and `age` (which must
be a `number`).
## Quick Reference
We have cheat-sheets available for both [`type` and
`interface`](https://www.typescriptlang.org/cheatsheets), if you want a quick
look at the important every-day syntax at a glance.
## Property Modifiers
Each property in an object type can specify a couple of things: the type,
whether the property is optional, and whether the property can be written to.
### Optional Properties
Much of the time, we‚Äôll find ourselves dealing with objects that _might_ have
a property set. In those cases, we can mark those properties as _optional_ by
adding a question mark (`?`) to the end of their names.
    ts
    interface PaintOptions {
      shape: Shape;
      xPos?: number;
      yPos?: number;
    }
    function paintShape(opts: PaintOptions) {
      // ...
    }
    const shape = getShape();
    paintShape({ shape });
    paintShape({ shape, xPos: 100 });
    paintShape({ shape, yPos: 100 });
    paintShape({ shape, xPos: 100, yPos: 100 });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA)
In this example, both `xPos` and `yPos` are considered optional. We can choose
to provide either of them, so every call above to `paintShape` is valid. All
optionality really says is that if the property _is_ set, it better have a
specific type.
We can also read from those properties - but when we do under
[`strictNullChecks`](/tsconfig#strictNullChecks), TypeScript will tell us
they‚Äôre potentially `undefined`.
    ts
    function paintShape(opts: PaintOptions) {
      let xPos = opts.xPos;
    (property) PaintOptions.xPos?: number | undefined
      let yPos = opts.yPos;
    (property) PaintOptions.yPos?: number | undefined
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA)
In JavaScript, even if the property has never been set, we can still access it
- it‚Äôs just going to give us the value `undefined`. We can just handle
`undefined` specially by checking for it.
    ts
    function paintShape(opts: PaintOptions) {
      let xPos = opts.xPos === undefined ? 0 : opts.xPos;
    let xPos: number
      let yPos = opts.yPos === undefined ? 0 : opts.yPos;
    let yPos: number
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA)
Note that this pattern of setting defaults for unspecified values is so common
that JavaScript has syntax to support it.
    ts
    function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
      console.log("x coordinate at", xPos);
    (parameter) xPos: number
      console.log("y coordinate at", yPos);
    (parameter) yPos: number
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA)
Here we used [a destructuring pattern](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for
`paintShape`‚Äôs parameter, and provided [default
values](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values)
for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present
within the body of `paintShape`, but optional for any callers to `paintShape`.
> Note that there is currently no way to place type annotations within
> destructuring patterns. This is because the following syntax already means
> something different in JavaScript.
>  
>  
>     ts
>  
>     function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {
>  
>       render(shape);
>  
>     Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name
> 'shape'. Did you mean 'Shape'?
>  
>       render(xPos);
>  
>     Cannot find name 'xPos'.2304Cannot find name 'xPos'.
>  
>     }
>  
>
> [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA)
>
> In an object destructuring pattern, `shape: Shape` means ‚Äúgrab the property
> `shape` and redefine it locally as a variable named `Shape`.‚Äù Likewise
> `xPos: number` creates a variable named `number` whose value is based on the
> parameter‚Äôs `xPos`.
### `readonly` Properties
Properties can also be marked as `readonly` for TypeScript. While it won‚Äôt
change any behavior at runtime, a property marked as `readonly` can‚Äôt be
written to during type-checking.
    ts
    interface SomeType {
      readonly prop: string;
    }
    function doSomething(obj: SomeType) {
      // We can read from 'obj.prop'.
      console.log(`prop has the value '${obj.prop}'.`);
      // But we can't re-assign it.
      obj.prop = "hello";
    Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA)
Using the `readonly` modifier doesn‚Äôt necessarily imply that a value is
totally immutable - or in other words, that its internal contents can‚Äôt be
changed. It just means the property itself can‚Äôt be re-written to.
    ts
    interface Home {
      readonly resident: { name: string; age: number };
    }
    function visitForBirthday(home: Home) {
      // We can read and update properties from 'home.resident'.
      console.log(`Happy birthday ${home.resident.name}!`);
      home.resident.age++;
    }
    function evict(home: Home) {
      // But we can't write to the 'resident' property itself on a 'Home'.
      home.resident = {
    Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.
        name: "Victor the Evictor",
        age: 42,
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA)
It‚Äôs important to manage expectations of what `readonly` implies. It‚Äôs useful
to signal intent during development time for TypeScript on how an object
should be used. TypeScript doesn‚Äôt factor in whether properties on two types
are `readonly` when checking whether those types are compatible, so `readonly`
properties can also change via aliasing.
    ts
    interface Person {
      name: string;
      age: number;
    }
    interface ReadonlyPerson {
      readonly name: string;
      readonly age: number;
    }
    let writablePerson: Person = {
      name: "Person McPersonface",
      age: 42,
    };
    // works
    let readonlyPerson: ReadonlyPerson = writablePerson;
    console.log(readonlyPerson.age); // prints '42'
    writablePerson.age++;
    console.log(readonlyPerson.age); // prints '43'
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA)
Using [mapping modifiers](/docs/handbook/2/mapped-types.html#mapping-
modifiers), you can remove `readonly` attributes.
### Index Signatures
Sometimes you don‚Äôt know all the names of a type‚Äôs properties ahead of time,
but you do know the shape of the values.
In those cases you can use an index signature to describe the types of
possible values, for example:
    ts
    interface StringArray {
      [index: number]: string;
    }
    const myArray: StringArray = getStringArray();
    const secondItem = myArray[1];
    const secondItem: string
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA)
Above, we have a `StringArray` interface which has an index signature. This
index signature states that when a `StringArray` is indexed with a `number`,
it will return a `string`.
Only some types are allowed for index signature properties: `string`,
`number`, `symbol`, template string patterns, and union types consisting only
of these.
It is possible to support multiple types of indexers...
It is possible to support multiple types of indexers. Note that when using
both `number` and `string` indexers, the type returned from a numeric indexer
must be a subtype of the type returned from the string indexer. This is
because when indexing with a `number`, JavaScript will actually convert that
to a `string` before indexing into an object. That means that indexing with
`100` (a `number`) is the same thing as indexing with `"100"` (a `string`), so
the two need to be consistent.
    ts
    interface Animal {
      name: string;
    }
    interface Dog extends Animal {
      breed: string;
    }
    // Error: indexing with a numeric string might get you a completely separate type of Animal!
    interface NotOkay {
      [x: number]: Animal;
    'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
      [x: string]: Dog;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)
While string index signatures are a powerful way to describe the ‚Äúdictionary‚Äù
pattern, they also enforce that all properties match their return type. This
is because a string index declares that `obj.property` is also available as
`obj["property"]`. In the following example, `name`‚Äôs type does not match the
string index‚Äôs type, and the type checker gives an error:
    ts
    interface NumberDictionary {
      [index: string]: number;
      length: number; // ok
      name: string;
    Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA)
However, properties of different types are acceptable if the index signature
is a union of the property types:
    ts
    interface NumberOrStringDictionary {
      [index: string]: number | string;
      length: number; // ok, length is a number
      name: string; // ok, name is a string
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA)
Finally, you can make index signatures `readonly` in order to prevent
assignment to their indices:
    ts
    interface ReadonlyStringArray {
      readonly [index: number]: string;
    }
    let myArray: ReadonlyStringArray = getReadOnlyStringArray();
    myArray[2] = "Mallory";
    Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA)
You can‚Äôt set `myArray[2]` because the index signature is `readonly`.
## Excess Property Checks
Where and how an object is assigned a type can make a difference in the type
system. One of the key examples of this is in excess property checking, which
validates the object more thoroughly when it is created and assigned to an
object type during creation.
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
    }
    function createSquare(config: SquareConfig): { color: string; area: number } {
      return {
        color: config.color || "red",
        area: config.width ? config.width * config.width : 20,
      };
    }
    let mySquare = createSquare({ colour: "red", width: 100 });
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)
Notice the given argument to `createSquare` is spelled _`colour`_ instead of
`color`. In plain JavaScript, this sort of thing fails silently.
You could argue that this program is correctly typed, since the `width`
properties are compatible, there‚Äôs no `color` property present, and the extra
`colour` property is insignificant.
However, TypeScript takes the stance that there‚Äôs probably a bug in this code.
Object literals get special treatment and undergo _excess property checking_
when assigning them to other variables, or passing them as arguments. If an
object literal has any properties that the ‚Äútarget type‚Äù doesn‚Äôt have, you‚Äôll
get an error:
    ts
    let mySquare = createSquare({ colour: "red", width: 100 });
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)
Getting around these checks is actually really simple. The easiest method is
to just use a type assertion:
    ts
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)
However, a better approach might be to add a string index signature if you‚Äôre
sure that the object can have some extra properties that are used in some
special way. If `SquareConfig` can have `color` and `width` properties with
the above types, but could _also_ have any number of other properties, then we
could define it like so:
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
      [propName: string]: any;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXyA)
Here we‚Äôre saying that `SquareConfig` can have any number of properties, and
as long as they aren‚Äôt `color` or `width`, their types don‚Äôt matter.
One final way to get around these checks, which might be a bit surprising, is
to assign the object to another variable: Since assigning `squareOptions`
won‚Äôt undergo excess property checks, the compiler won‚Äôt give you an error:
    ts
    let squareOptions = { colour: "red", width: 100 };
    let mySquare = createSquare(squareOptions);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXypUYmEAjDAidXHEgZsuAAU9MRkHP44+EQkpACUHBR0jMzGPHz8yJFwHHJK0Mj2lEK4YJhQIEW0tPRMUBwhMQB0NczIAD5tyABEuGJdADRCtFn10WSNohKSyCxJoaQT4lLIAFRzTZPLHABMAAyDtPYOVAD0J8gAtFcImGBXF1QMEGBcWJEA8hoeRJzIALyUJJMMocHoQPr9ERLSQcACMu12BUETxe8hsEVw-28EF8EAxEECnDeuE+3xAnFi-CAA)
The above workaround will work as long as you have a common property between
`squareOptions` and `SquareConfig`. In this example, it was the property
`width`. It will however, fail if the variable does not have any common object
property. For example:
    ts
    let squareOptions = { colour: "red" };
    let mySquare = createSquare(squareOptions);
    Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)
Keep in mind that for simple code like above, you probably shouldn‚Äôt be trying
to ‚Äúget around‚Äù these checks. For more complex object literals that have
methods and hold state, you might need to keep these techniques in mind, but a
majority of excess property errors are actually bugs.
That means if you‚Äôre running into excess property checking problems for
something like option bags, you might need to revise some of your type
declarations. In this instance, if it‚Äôs okay to pass an object with both a
`color` or `colour` property to `createSquare`, you should fix up the
definition of `SquareConfig` to reflect that.
## Extending Types
It‚Äôs pretty common to have types that might be more specific versions of other
types. For example, we might have a `BasicAddress` type that describes the
fields necessary for sending letters and packages in the U.S.
    ts
    interface BasicAddress {
      name?: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA)
In some situations that‚Äôs enough, but addresses often have a unit number
associated with them if the building at an address has multiple units. We can
then describe an `AddressWithUnit`.
    ts
    interface AddressWithUnit {
      name?: string;
      unit: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA)
This does the job, but the downside here is that we had to repeat all the
other fields from `BasicAddress` when our changes were purely additive.
Instead, we can extend the original `BasicAddress` type and just add the new
fields that are unique to `AddressWithUnit`.
    ts
    interface BasicAddress {
      name?: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
    interface AddressWithUnit extends BasicAddress {
      unit: string;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA)
The `extends` keyword on an `interface` allows us to effectively copy members
from other named types, and add whatever new members we want. This can be
useful for cutting down the amount of type declaration boilerplate we have to
write, and for signaling intent that several different declarations of the
same property might be related. For example, `AddressWithUnit` didn‚Äôt need to
repeat the `street` property, and because `street` originates from
`BasicAddress`, a reader will know that those two types are related in some
way.
`interface`s can also extend from multiple types.
    ts
    interface Colorful {
      color: string;
    }
    interface Circle {
      radius: number;
    }
    interface ColorfulCircle extends Colorful, Circle {}
    const cc: ColorfulCircle = {
      color: "red",
      radius: 42,
    };
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA)
## Intersection Types
`interface`s allowed us to build up new types from other types by extending
them. TypeScript provides another construct called _intersection types_ that
is mainly used to combine existing object types.
An intersection type is defined using the `&` operator.
    ts
    interface Colorful {
      color: string;
    }
    interface Circle {
      radius: number;
    }
    type ColorfulCircle = Colorful & Circle;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA)
Here, we‚Äôve intersected `Colorful` and `Circle` to produce a new type that has
all the members of `Colorful` _and_ `Circle`.
    ts
    function draw(circle: Colorful & Circle) {
      console.log(`Color was ${circle.color}`);
      console.log(`Radius was ${circle.radius}`);
    }
    // okay
    draw({ color: "blue", radius: 42 });
    // oops
    draw({ color: "red", raidus: 42 });
    Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA)
## Interfaces vs. Intersections
We just looked at two ways to combine types which are similar, but are
actually subtly different. With interfaces, we could use an `extends` clause
to extend from other types, and we were able to do something similar with
intersections and name the result with a type alias. The principal difference
between the two is how conflicts are handled, and that difference is typically
one of the main reasons why you‚Äôd pick one over the other between an interface
and a type alias of an intersection type.
If interfaces are defined with the same name, TypeScript will attempt to merge
them if the properties are compatible. If the properties are not compatible
(i.e., they have the same property name but different types), TypeScript will
raise an error.
In the case of intersection types, properties with different types will be
merged automatically. When the type is used later, TypeScript will expect the
property to satisfy both types simultaneously, which may produce unexpected
results.
For example, the following code will throw an error because the properties are
incompatible:
    ts
    interface Person {
      name: string;
    }
    interface Person {
      name: number;
    }
In contrast, the following code will compile, but it results in a `never`
type:
    ts
    interface Person1 {
      name: string;
    }
    interface Person2 {
      name: number;
    }
    type Staff = Person1 & Person2
    declare const staffer: Staff;
    staffer.name;
    (property) name: never
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsQEZkDeAUMsiHALYQBcyGYUoA5gNxEC+RRoksiK6KNhAAmQiTKUaZAK4UARtDaciYAJ4AHFAGUwcGDGQBeNJhz4AZKaE4RXACYQEAGzhQUCHPTp6D0Wrr6MGz0QdAAdORUbAD0MaQJpAB6APxAA)
In this case, Staff would require the name property to be both a string and a
number, which results in property being of type `never`.
## Generic Object Types
Let‚Äôs imagine a `Box` type that can contain any value - `string`s, `number`s,
`Giraffe`s, whatever.
    ts
    interface Box {
      contents: any;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g)
Right now, the `contents` property is typed as `any`, which works, but can
lead to accidents down the line.
We could instead use `unknown`, but that would mean that in cases where we
already know the type of `contents`, we‚Äôd need to do precautionary checks, or
use error-prone type assertions.
    ts
    interface Box {
      contents: unknown;
    }
    let x: Box = {
      contents: "hello world",
    };
    // we could check 'x.contents'
    if (typeof x.contents === "string") {
      console.log(x.contents.toLowerCase());
    }
    // or we could use a type assertion
    console.log((x.contents as string).toLowerCase());
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA)
One type safe approach would be to instead scaffold out different `Box` types
for every type of `contents`.
    ts
    interface NumberBox {
      contents: number;
    }
    interface StringBox {
      contents: string;
    }
    interface BooleanBox {
      contents: boolean;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA)
But that means we‚Äôll have to create different functions, or overloads of
functions, to operate on these types.
    ts
    function setContents(box: StringBox, newContents: string): void;
    function setContents(box: NumberBox, newContents: number): void;
    function setContents(box: BooleanBox, newContents: boolean): void;
    function setContents(box: { contents: any }, newContents: any) {
      box.contents = newContents;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA)
That‚Äôs a lot of boilerplate. Moreover, we might later need to introduce new
types and overloads. This is frustrating, since our box types and overloads
are all effectively the same.
Instead, we can make a _generic_ `Box` type which declares a _type parameter_.
    ts
    interface Box<Type> {
      contents: Type;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)
You might read this as ‚ÄúA `Box` of `Type` is something whose `contents` have
type `Type`‚Äù. Later on, when we refer to `Box`, we have to give a _type
argument_ in place of `Type`.
    ts
    let box: Box<string>;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA)
Think of `Box` as a template for a real type, where `Type` is a placeholder
that will get replaced with some other type. When TypeScript sees
`Box<string>`, it will replace every instance of `Type` in `Box<Type>` with
`string`, and end up working with something like `{ contents: string }`. In
other words, `Box<string>` and our earlier `StringBox` work identically.
    ts
    interface Box<Type> {
      contents: Type;
    }
    interface StringBox {
      contents: string;
    }
    let boxA: Box<string> = { contents: "hello" };
    boxA.contents;
    (property) Box<string>.contents: string
    let boxB: StringBox = { contents: "world" };
    boxB.contents;
    (property) StringBox.contents: string
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA)
`Box` is reusable in that `Type` can be substituted with anything. That means
that when we need a box for a new type, we don‚Äôt need to declare a new `Box`
type at all (though we certainly could if we wanted to).
    ts
    interface Box<Type> {
      contents: Type;
    }
    interface Apple {
      // ....
    }
    // Same as '{ contents: Apple }'.
    type AppleBox = Box<Apple>;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA)
This also means that we can avoid overloads entirely by instead using [generic
functions](/docs/handbook/2/functions.html#generic-functions).
    ts
    function setContents<Type>(box: Box<Type>, newContents: Type) {
      box.contents = newContents;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA)
It is worth noting that type aliases can also be generic. We could have
defined our new `Box<Type>` interface, which was:
    ts
    interface Box<Type> {
      contents: Type;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)
by using a type alias instead:
    ts
    type Box<Type> = {
      contents: Type;
    };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA)
Since type aliases, unlike interfaces, can describe more than just object
types, we can also use them to write other kinds of generic helper types.
    ts
    type OrNull<Type> = Type | null;
    type OneOrMany<Type> = Type | Type[];
    type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;
    type OneOrManyOrNull<Type> = OneOrMany<Type> | null
    type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
    type OneOrManyOrNullStrings = OneOrMany<string> | null
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA)
We‚Äôll circle back to type aliases in just a little bit.
### The `Array` Type
Generic object types are often some sort of container type that work
independently of the type of elements they contain. It‚Äôs ideal for data
structures to work this way so that they‚Äôre re-usable across different data
types.
It turns out we‚Äôve been working with a type just like that throughout this
handbook: the `Array` type. Whenever we write out types like `number[]` or
`string[]`, that‚Äôs really just a shorthand for `Array<number>` and
`Array<string>`.
    ts
    function doSomething(value: Array<string>) {
      // ...
    }
    let myArray: string[] = ["hello", "world"];
    // either of these work!
    doSomething(myArray);
    doSomething(new Array("hello", "world"));
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA)
Much like the `Box` type above, `Array` itself is a generic type.
    ts
    interface Array<Type> {
    Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters.2317  
    2428Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters.
      /**
       * Gets or sets the length of the array.
       */
      length: number;
      /**
       * Removes the last element from an array and returns it.
       */
      pop(): Type | undefined;
      /**
       * Appends new elements to an array, and returns the new length of the array.
       */
      push(...items: Type[]): number;
    A rest parameter must be of an array type.2370A rest parameter must be of an array type.
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA)
Modern JavaScript also provides other data structures which are generic, like
`Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because
of how `Map`, `Set`, and `Promise` behave, they can work with any sets of
types.
### The `ReadonlyArray` Type
The `ReadonlyArray` is a special type that describes arrays that shouldn‚Äôt be
changed.
    ts
    function doStuff(values: ReadonlyArray<string>) {
      // We can read from 'values'...
      const copy = values.slice();
      console.log(`The first value is ${values[0]}`);
      // ...but we can't mutate 'values'.
      values.push("hello!");
    Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA)
Much like the `readonly` modifier for properties, it‚Äôs mainly a tool we can
use for intent. When we see a function that returns `ReadonlyArray`s, it tells
us we‚Äôre not meant to change the contents at all, and when we see a function
that consumes `ReadonlyArray`s, it tells us that we can pass any array into
that function without worrying that it will change its contents.
Unlike `Array`, there isn‚Äôt a `ReadonlyArray` constructor that we can use.
    ts
    new ReadonlyArray("red", "green", "blue");
    'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA)
Instead, we can assign regular `Array`s to `ReadonlyArray`s.
    ts
    const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA)
Just as TypeScript provides a shorthand syntax for `Array<Type>` with
`Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with
`readonly Type[]`.
    ts
    function doStuff(values: readonly string[]) {
      // We can read from 'values'...
      const copy = values.slice();
      console.log(`The first value is ${values[0]}`);
      // ...but we can't mutate 'values'.
      values.push("hello!");
    Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA)
One last thing to note is that unlike the `readonly` property modifier,
assignability isn‚Äôt bidirectional between regular `Array`s and
`ReadonlyArray`s.
    ts
    let x: readonly string[] = [];
    let y: string[] = [];
    x = y;
    y = x;
    The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA)
### Tuple Types
A _tuple type_ is another sort of `Array` type that knows exactly how many
elements it contains, and exactly which types it contains at specific
positions.
    ts
    type StringNumberPair = [string, number];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA)
Here, `StringNumberPair` is a tuple type of `string` and `number`. Like
`ReadonlyArray`, it has no representation at runtime, but is significant to
TypeScript. To the type system, `StringNumberPair` describes arrays whose `0`
index contains a `string` and whose `1` index contains a `number`.
    ts
    function doSomething(pair: [string, number]) {
      const a = pair[0];
    const a: string
      const b = pair[1];
    const b: number
      // ...
    }
    doSomething(["hello", 42]);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA)
If we try to index past the number of elements, we‚Äôll get an error.
    ts
    function doSomething(pair: [string, number]) {
      // ...
      const c = pair[2];
    Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA)
We can also [destructure tuples](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)
using JavaScript‚Äôs array destructuring.
    ts
    function doSomething(stringHash: [string, number]) {
      const [inputString, hash] = stringHash;
      console.log(inputString);
    const inputString: string
      console.log(hash);
    const hash: number
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA)
> Tuple types are useful in heavily convention-based APIs, where each
> element‚Äôs meaning is ‚Äúobvious‚Äù. This gives us flexibility in whatever we
> want to name our variables when we destructure them. In the above example,
> we were able to name elements `0` and `1` to whatever we wanted.
>
> However, since not every user holds the same view of what‚Äôs obvious, it may
> be worth reconsidering whether using objects with descriptive property names
> may be better for your API.
Other than those length checks, simple tuple types like these are equivalent
to types which are versions of `Array`s that declare properties for specific
indexes, and that declare `length` with a numeric literal type.
    ts
    interface StringNumberPair {
      // specialized properties
      length: 2;
      0: string;
      1: number;
      // Other 'Array<string | number>' members...
      slice(start?: number, end?: number): Array<string | number>;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA)
Another thing you may be interested in is that tuples can have optional
properties by writing out a question mark (`?` after an element‚Äôs type).
Optional tuple elements can only come at the end, and also affect the type of
`length`.
    ts
    type Either2dOr3d = [number, number, number?];
    function setCoordinate(coord: Either2dOr3d) {
      const [x, y, z] = coord;
    const z: number | undefined
      console.log(`Provided coordinates had ${coord.length} dimensions`);
    (property) length: 2 | 3
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA)
Tuples can also have rest elements, which have to be an array/tuple type.
    ts
    type StringNumberBooleans = [string, number, ...boolean[]];
    type StringBooleansNumber = [string, ...boolean[], number];
    type BooleansStringNumber = [...boolean[], string, number];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA)
  * `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.
  * `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.
  * `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.
A tuple with a rest element has no set ‚Äúlength‚Äù - it only has a set of well-
known elements in different positions.
    ts
    const a: StringNumberBooleans = ["hello", 1];
    const b: StringNumberBooleans = ["beautiful", 2, true];
    const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA)
Why might optional and rest elements be useful? Well, it allows TypeScript to
correspond tuples with parameter lists. Tuples types can be used in [rest
parameters and arguments](/docs/handbook/2/functions.html#rest-parameters-and-
arguments), so that the following:
    ts
    function readButtonInput(...args: [string, number, ...boolean[]]) {
      const [name, version, ...input] = args;
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA)
is basically equivalent to:
    ts
    function readButtonInput(name: string, version: number, ...input: boolean[]) {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA)
This is handy when you want to take a variable number of arguments with a rest
parameter, and you need a minimum number of elements, but you don‚Äôt want to
introduce intermediate variables.
### `readonly` Tuple Types
One final note about tuple types - tuple types have `readonly` variants, and
can be specified by sticking a `readonly` modifier in front of them - just
like with array shorthand syntax.
    ts
    function doSomething(pair: readonly [string, number]) {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA)
As you might expect, writing to any property of a `readonly` tuple isn‚Äôt
allowed in TypeScript.
    ts
    function doSomething(pair: readonly [string, number]) {
      pair[0] = "hello!";
    Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA)
Tuples tend to be created and left un-modified in most code, so annotating
types as `readonly` tuples when possible is a good default. This is also
important given that array literals with `const` assertions will be inferred
with `readonly` tuple types.
    ts
    let point = [3, 4] as const;
    function distanceFromOrigin([x, y]: [number, number]) {
      return Math.sqrt(x ** 2 + y ** 2);
    }
    distanceFromOrigin(point);
    Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
      The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
      The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA)
Here, `distanceFromOrigin` never modifies its elements, but expects a mutable
tuple. Since `point`‚Äôs type was inferred as `readonly [3, 4]`, it won‚Äôt be
compatible with `[number, number]` since that type can‚Äôt guarantee `point`‚Äôs
elements won‚Äôt be mutated.
### [More on FunctionsLearn about how Functions work in
TypeScript.](/docs/handbook/2/functions.html)
### [Creating Types from TypesAn overview of the ways in which you can create
more types from existing types.](/docs/handbook/2/types-from-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Object Types.md) ‚ù§
Contributors to this page:  
DR
OT
3
BR
AR
21+
Last updated: Sep 16, 2024  
Was this page helpful?
# Template Literal Types
Template literal types build on [string literal
types](/docs/handbook/2/everyday-types.html#literal-types), and have the
ability to expand into many strings via unions.
They have the same syntax as [template literal strings in
JavaScript](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Template_literals), but are used in type
positions. When used with concrete literal types, a template literal produces
a new string literal type by concatenating the contents.
    ts
    type World = "world";
    type Greeting = `hello ${World}`;
    type Greeting = "hello world"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)
When a union is used in the interpolated position, the type is the set of
every possible string literal that could be represented by each union member:
    ts
    type EmailLocaleIDs = "welcome_email" | "email_heading";
    type FooterLocaleIDs = "footer_title" | "footer_sendoff";
    type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
    type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnzF4aAEEUdGxcAhJyKAADABIAb3h+XVCDblVHHRD9EgBfZiRRSIUAeiKoMoA9AH4gA)
For each interpolated position in the template literal, the unions are cross
multiplied:
    ts
    type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
    type Lang = "en" | "ja" | "pt";
    type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
    type LocaleMessageIDs = "en_welcome_email_id" | "en_email_heading_id" | "en_footer_title_id" | "en_footer_sendoff_id" | "ja_welcome_email_id" | "ja_email_heading_id" | "ja_footer_title_id" | "ja_footer_sendoff_id" | "pt_welcome_email_id" | "pt_email_heading_id" | "pt_footer_title_id" | "pt_footer_sendoff_id"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnyA9D6gAtEFYAK7AQQGK4NAAgijo2LgEJORQAAYAJADe8Py6SQbcqo46ifokAL7MSKJpCkrQaAjSqZSudlQAVggdlGDA3lHK+XgAshDExAhSyYbp2U3SVdlxCXqzFXW+-lBQAHoA-EA)
We generally recommend that people use ahead-of-time generation for large
string unions, but this is useful in smaller cases.
### String Unions in Types
The power in template literals comes when defining a new string based on
information inside a type.
Consider the case where a function (`makeWatchedObject`) adds a new function
called `on()` to a passed object. In JavaScript, its call might look like:
`makeWatchedObject(baseObject)`. We can imagine the base object as looking
like:
    ts
    const passedObject = {
      firstName: "Saoirse",
      lastName: "Ronan",
      age: 26,
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AA4CGKKApgCYDyARgFZkb4C8oA3mqKAGYCWquAHJEAtmQBcoAEQBlItH7kpAGk6gANiSGiJ0gErYikFWqIBzXQCYAbKoC+AbiA)
The `on` function that will be added to the base object expects two arguments,
an `eventName` (a `string`) and a `callback` (a `function`).
The `eventName` should be of the form `attributeInThePassedObject +
"Changed"`; thus, `firstNameChanged` as derived from the attribute `firstName`
in the base object.
The `callback` function, when called:
  * Should be passed a value of the type associated with the name `attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument
  * Should have `void` return type (for simplicity of demonstration)
The naive function signature of `on()` might thus be: `on(eventName: string,
callback: (newValue: any) => void)`. However, in the preceding description, we
identified important type constraints that we‚Äôd like to document in our code.
Template Literal types let us bring these constraints into our code.
    ts
    const person = makeWatchedObject({
      firstName: "Saoirse",
      lastName: "Ronan",
      age: 26,
    });
    // makeWatchedObject has added `on` to the anonymous Object
    person.on("firstNameChanged", (newValue) => {
      console.log(`firstName was changed to ${newValue}!`);
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagBmArpDgC4CW0koAtgQNZYDqB1OAFlhgDyAIwBWuagApoYgFygCkAJ4BKeYqUBuNCFABaAznLUDetDgYpqoAA5ZUDUAF5mbTtz4CR4mpIDeaKBktKjUAHIETFjyAEQAygTQIShYMQA0gaCEVhFRsQBKDIrpmQQA5tGgAEwAbBkAviraOmAs7Fw8-EJiEqC8BCgKGNgYoAAGDGOg1NDT-AowykzQ5IPeEmhodg6QAHQMkjGkyeGRWADC-ZAVGOmgkpBYAO4AagR45FgqzgB8oAFBCyQFDQPBYXZ4aBlSRjY6hXIkJ4DUB8RQ3aazAAkfker3en3qAEIxk00I1NEA)
Notice that `on` listens on the event `"firstNameChanged"`, not just
`"firstName"`. Our naive specification of `on()` could be made more robust if
we were to ensure that the set of eligible event names was constrained by the
union of attribute names in the watched object with ‚ÄúChanged‚Äù added at the
end. While we are comfortable with doing such a calculation in JavaScript i.e.
`Object.keys(passedObject).map(x => `${x}Changed`)`, template literals _inside
the type system_ provide a similar approach to string manipulation:
    ts
    type PropEventSource<Type> = {
        on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;
    };
    /// Create a "watched object" with an `on` method
    /// so that you can watch for changes to properties.
    declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGAFBOlgHIBDALYQAXFAAGAEgYBnYHACWGAOZQAZFADWEEAgBmUCpAC+AYQAWA1RAAmEgDRRCAgDauARgMJbxnDBAA7gBqbnhiUNYgAJR0NKgIirbR4glJANxMJplMAPT5UGZwEALA0AJQAESBpYQWduweAFYQhMCVUIGKwBaRGJIcElAiPQi2eQWyCFA9pVB6eM7WnbW9+ghwzlY2sjPTYIiQcMCKELIAdEy2ra4CxVD6eBhtihzDAjoA6qt2APLNrWA5EoVE4CGa4mMEBSRkoGlghzQmBw+CIpChVHSQA)
With this, we can build something that errors when given the wrong property:
    ts
    const person = makeWatchedObject({
      firstName: "Saoirse",
      lastName: "Ronan",
      age: 26
    });
    person.on("firstNameChanged", () => {});
    // Prevent easy human error (using the key instead of the event name)
    person.on("firstName", () => {});
    Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.
    // It's typo-resistant
    person.on("frstNameChanged", () => {});
    Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKqUgA+UAF5QAbzyhZoOIwAUkBswByAQwC2kVAAMAJJMQFoAS0YBzUADJQAa0hE4AM1CCyAXwDCACw1WkAAmegA0oFwaADZRAEYaXPaoioyQAO4AatHsuqABRACU4qJ0cGZBBail5QDceJ51eEGQXFEa0OQu7IxcBGYKoFoajgDqGgRcvsEA8rEAVi0EAsKKcPOo-JXutpTU9EysHNx8-MJ1IKAAtNdc7ATXl3hcCiagZEgDEkOj45Mz84tFNJZC4zEgCJodKgAEQsDRlJCQaGhGSgNomSG5aEAJQUAWRqI0llyaAAbPUCo13ogFAA6BSKaGg8GYvwBYlBZGgRRFMSiSSeSl4PAXKgqA6gSAaRBEUC+dhDRiS2AIbnsRAWawEKYOJygCwmKVBeRubXkcXMUCMbSQAp4al0hlMsEYm1cnnFKSCxoXACSBAA5IhQMQSHBLh0NSYAgR7TAaYx6UomSybWzApzwh6+V7KUA)
### Inference with Template Literals
Notice that we did not benefit from all the information provided in the
original passed object. Given change of a `firstName` (i.e. a
`firstNameChanged` event), we should expect that the callback will receive an
argument of type `string`. Similarly, the callback for a change to `age`
should receive a `number` argument. We‚Äôre naively using `any` to type the
`callback`‚Äôs argument. Again, template literal types make it possible to
ensure an attribute‚Äôs data type will be the same type as that attribute‚Äôs
callback‚Äôs first argument.
The key insight that makes this possible is this: we can use a function with a
generic such that:
  1. The literal used in the first argument is captured as a literal type
  2. That literal type can be validated as being in the union of valid attributes in the generic
  3. The type of the validated attribute can be looked up in the generic‚Äôs structure using Indexed Access
  4. This typing information can _then_ be applied to ensure the argument to the callback function is of the same type
    ts
    type PropEventSource<Type> = {
        on<Key extends string & keyof Type>
            (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;
    };
    declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;
    const person = makeWatchedObject({
      firstName: "Saoirse",
      lastName: "Ronan",
      age: 26
    });
    person.on("firstNameChanged", newName => {
    (parameter) newName: string
        console.log(`new name is ${newName.toUpperCase()}`);
    });
    person.on("ageChanged", newAge => {
    (parameter) newAge: number
        if (newAge < 0) {
            console.warn("warning! negative age");
        }
    })
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGJA0hCFBAA9gmACYBnKGOBwAlhgDmUAGRQA1rwQAzKBUhUWbQwAoI6LADkAhgFsIALigADACQMeIAL4BhABaWFECKOADRQhJYANhEARpaEqg5GGBAA7gBqkXj2OpQA2u4AugCUdDSoCDIiRQ7llQDcTB4NTCIQhBGWcNCaeBiEwDIcUNaW6gDqlsCEPoEA8tEAVm3A5JRURgiLDroQ1TmQyrCIKGY4+ESkO1TNhBxSUJBwYkP0I+OT03OLy0bMrJoyJ7AKy2BwAImwlgqTwgYOCBg6UhB2TBACUOP44QZLPJsgAmABsjSKzUezwwADoOEYwQCgcjfP5cSI4VBkilkaVGAZWAB6XmGQVC4WsAB6AH4eWE7ggIhAKREEPIjI52WybNAZBJXOzkRTgAgAKpgR5eSxiCBGIoeRwk4mkiBPDhUjA0nEQRkBFmhdkAQVxXL+bH5ItDUAlUpk2iSqX90BIUAADCUg0LbhhnnKKSlOq6wTm4Bg5PIAIRsiDySYydBQd1gu2GDzEoA)
Here we made `on` into a generic method.
When a user calls with the string `"firstNameChanged"`, TypeScript will try to
infer the right type for `Key`. To do that, it will match `Key` against the
content before `"Changed"` and infer the string `"firstName"`. Once TypeScript
figures that out, the `on` method can fetch the type of `firstName` on the
original object, which is `string` in this case. Similarly, when called with
`"ageChanged"`, TypeScript finds the type for the property `age` which is
`number`.
Inference can be combined in different ways, often to deconstruct strings, and
reconstruct them in different ways.
## Intrinsic String Manipulation Types
To help with string manipulation, TypeScript includes a set of types which can
be used in string manipulation. These types come built-in to the compiler for
performance and can‚Äôt be found in the `.d.ts` files included with TypeScript.
### `Uppercase<StringType>`
Converts each character in the string to the uppercase version.
##### Example
    ts
    type Greeting = "Hello, world"
    type ShoutyGreeting = Uppercase<Greeting>
    type ShoutyGreeting = "HELLO, WORLD"
    type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`
    type MainID = ASCIICacheKey<"my_app">
    type MainID = "ID-MY_APP"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigGUALUgV1HkQoM2KAFUwkOAGMAhgGcIAHgFI06AHxMA9Fqh6AegH4mLcNACC7AMIBJG1ZlTOEANIQQi9sDhQIAD2AIVHo5KDlvNXURAAMbABEAWgASAG9xSVkFT291AF9o0zYAWRk0eJFLW3tHZzcPXABbEAB9GQlcTR09KCMgA)
### `Lowercase<StringType>`
Converts each character in the string to the lowercase equivalent.
##### Example
    ts
    type Greeting = "Hello, world"
    type QuietGreeting = Lowercase<Greeting>
    type QuietGreeting = "hello, world"
    type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`
    type MainID = ASCIICacheKey<"MY_APP">
    type MainID = "id-my_app"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigEUBXZJeRFDNigAZUlQhwAxgEMAzhAA8fJGnQA+JgHpNUXQD0A-ExbhoAQQDKAYQCSNq9MkALCAGkIIBReBwoEAB7AEKj0slCyPqpqQgAGyPQAtAAkAN6i4lJyit5wagC+MSZsALLSaDYAIkKWtvaOLu6euMUAmgD6ZgAKnbga2rpQhkA)
### `Capitalize<StringType>`
Converts the first character in the string to an uppercase equivalent.
##### Example
    ts
    type LowercaseGreeting = "hello, world";
    type Greeting = Capitalize<LowercaseGreeting>;
    type Greeting = "Hello, world"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAMg9gdwgJwMYEMDOEDiyITACWAdgOZQC8UARABYQA2jcANFAnMowCY0DcAKFCQoeAsXJUoAYXRgiwdIyIAvCAB54SNFlz5CpMgD4hAejNQrAPQD8QA)
### `Uncapitalize<StringType>`
Converts the first character in the string to a lowercase equivalent.
##### Example
    ts
    type UppercaseGreeting = "HELLO WORLD";
    type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;
    type UncomfortableGreeting = "hELLO WORLD"
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAqmkCcDGBDAzhA4giFgEsA7AcygF4oAiACQFEAZegeSgHUmAlegEUoG4AUKEixCSAPYBbAGbiEwFACMANlhx4ipCjDEow+BcvwAvCAB44iVBmy4CJAHyCA9M6juAegH4gA)
Technical details on the intrinsic string manipulation types
The code, as of TypeScript 4.1, for these intrinsic functions uses the
JavaScript string runtime functions directly for manipulation and are not
locale aware.
`
    function applyStringMapping(symbol: Symbol, str: string) {
        switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
            case IntrinsicTypeKind.Uppercase: return str.toUpperCase();
            case IntrinsicTypeKind.Lowercase: return str.toLowerCase();
            case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);
            case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);
        }
        return str;
    }
`
### [Mapped TypesGenerating types by re-using an existing
type.](/docs/handbook/2/mapped-types.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Template Literal Types.md) ‚ù§
Contributors to this page:  
SH
OT
SGH
SP
P
6+
Last updated: Sep 16, 2024  
Was this page helpful?
# Typeof Type Operator
## The `typeof` type operator
JavaScript already has a `typeof` operator you can use in an _expression_
context:
    ts
    // Prints "string"
    console.log(typeof "Hello world");
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOoBEj41gcxQKAMYD2sihANgKYB0ZhWAFPAJ4AOFhAZqgBIVm2gA7oUhkAJigCUAbiA)
TypeScript adds a `typeof` operator you can use in a _type_ context to refer
to the _type_ of a variable or property:
    ts
    let s = "hello";
    let n: typeof s;
    let n: string
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECIAWJjAPYINwChSQDsAuCMATwAcR0AzaXAegYggD0B+IA)
This isn‚Äôt very useful for basic types, but combined with other type
operators, you can use `typeof` to conveniently express many patterns. For an
example, let‚Äôs start by looking at the predefined type `ReturnType<T>`. It
takes a _function type_ and produces its return type:
    ts
    type Predicate = (x: unknown) => boolean;
    type K = ReturnType<Predicate>;
    type K = boolean
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgThAJgSwMYENjQLxQBQAeAXFAK4B2A1uQPYDu5AlFNgHxQBGNNANhOuQDcAKFCQoAaRZQAShGCk45ACrgIAHnhI0mCKxEB6A1BMA9APxA)
If we try to use `ReturnType` on a function name, we see an instructive error:
    ts
    function f() {
      return { x: 10, y: 3 };
    }
    type P = ReturnType<f>;
    'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?2749'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBOAUAGYCuAdgMYAuAlnCaAQBQCUoA3nqKNJBUdHa1AAPVAEYADABpQAT1QBmUAF8A3HiV4KMgA6RQABVABeUACUefEgBUdkADwEAfCqA)
Remember that _values_ and _types_ aren‚Äôt the same thing. To refer to the
_type_ that the _value`f`_ has, we use `typeof`:
    ts
    function f() {
      return { x: 10, y: 3 };
    }
    type P = ReturnType<typeof f>;
    type P = {
        x: number;
        y: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFASkQbwFCMQJwFMoR8lNEAPALkQEYAGAGkQE9aBmRAXwG5tu2KKwAOhRAAVEAXkQAlYqTAAVUYQA8wsXGDIAfPwD0hvIgB6AfiA)
### Limitations
TypeScript intentionally limits the sorts of expressions you can use `typeof`
on.
Specifically, it‚Äôs only legal to use `typeof` on identifiers (i.e. variable
names) or their properties. This helps avoid the confusing trap of writing
code you think is executing, but isn‚Äôt:
    ts
    // Meant to use = ReturnType<typeof msgbox>
    let shouldContinue: typeof msgbox("Are you sure you want to continue?");
    ',' expected.1005',' expected.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQATSAYwBsBDaSUIuAO0QBdQBbRAcwCM4APVACgAO8ZgIapG0AJa02ASlABeAHygucEpDK0A3LhCgGATwFVWnHotBbDu-QFoHRAK4MHdvWACym2kwZxQJ0QqBVAAJUgGJ2haABVjSAAeIxM4ADMWdi5uJVwNJkQACzgnEnwAYToGaSdIVBTIdMzzbj4AIgBBSlBDEtBEaKpep1AAdy0-AJpfGsgAfjbZbSA)
### [Keyof Type OperatorUsing the keyof operator in type
contexts.](/docs/handbook/2/keyof-types.html)
### [Indexed Access TypesUsing Type['a'] syntax to access a subset of a
type.](/docs/handbook/2/indexed-access-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/Typeof Type Operator.md) ‚ù§
Contributors to this page:  
OT
JL
Last updated: Sep 16, 2024  
Was this page helpful?
# Creating Types from Types
TypeScript‚Äôs type system is very powerful because it allows expressing types
_in terms of other types_.
The simplest form of this idea is generics. Additionally, we have a wide
variety of _type operators_ available to use. It‚Äôs also possible to express
types in terms of _values_ that we already have.
By combining various type operators, we can express complex operations and
values in a succinct, maintainable way. In this section we‚Äôll cover ways to
express a new type in terms of an existing type or value.
  * [Generics](/docs/handbook/2/generics.html) \- Types which take parameters
  * [Keyof Type Operator](/docs/handbook/2/keyof-types.html) \- Using the `keyof` operator to create new types
  * [Typeof Type Operator](/docs/handbook/2/typeof-types.html) \- Using the `typeof` operator to create new types
  * [Indexed Access Types](/docs/handbook/2/indexed-access-types.html) \- Using `Type['a']` syntax to access a subset of a type
  * [Conditional Types](/docs/handbook/2/conditional-types.html) \- Types which act like if statements in the type system
  * [Mapped Types](/docs/handbook/2/mapped-types.html) \- Creating types by mapping each property in an existing type
  * [Template Literal Types](/docs/handbook/2/template-literal-types.html) \- Mapped types which change properties via template literal strings
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [GenericsTypes which take parameters](/docs/handbook/2/generics.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type
Manipulation/_Creating Types from Types.md) ‚ù§
Contributors to this page:  
OT
GF
AP
PC
Last updated: Sep 16, 2024  
Was this page helpful?
# ASP.NET Core
## Install ASP.NET Core and TypeScript
First, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet) if you
need it. This quick-start guide requires Visual Studio 2015 or 2017.
Next, if your version of Visual Studio does not already have the latest
TypeScript, you can [install
it](https://www.typescriptlang.org/index.html#download-links).
## Create a new project
  1. Choose **File**
  2. Choose **New Project** (Ctrl + Shift + N)
  3. Search for **.NET Core** in the project search bar
  4. Select **ASP.NET Core Web Application** and press the _Next_ button
  5. Name your project and solution. After select the _Create_ button
  6. In the last window, select the **Empty** template and press the _Create_ button
Run the application and make sure that it works.
### Set up the server
Open **Dependencies > Manage NuGet Packages > Browse.** Search and install
`Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:
Open up your `Startup.cs` file and edit your `Configure` function to look like
this:
    public void Configure(IApplicationBuilder app, IHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        app.UseDefaultFiles();
        app.UseStaticFiles();
    }
You may need to restart VS for the red squiggly lines below `UseDefaultFiles`
and `UseStaticFiles` to disappear.
## Add TypeScript
Next we will add a new folder and call it `scripts`.
## Add TypeScript code
Right click on `scripts` and click **New Item**. Then choose **TypeScript
File** and name the file `app.ts`
### Add example code
Add the following code to the `app.ts` file.
    ts
    function sayHello() {
      const compiler = (document.getElementById("compiler") as HTMLInputElement)
        .value;
      const framework = (document.getElementById("framework") as HTMLInputElement)
        .value;
      return `Hello from ${compiler} and ${framework}!`;
    }
## Set up the build
_Configure the TypeScript compiler_
First we need to tell TypeScript how to build. Right click on `scripts` and
click **New Item**. Then choose **TypeScript Configuration File** and use the
default name of `tsconfig.json`
Replace the contents of the `tsconfig.json` file with:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[noEmitOnError](https://www.typescriptlang.org/tsconfig#noEmitOnError)": true,
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es6"
      },
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["./app.ts"],
      "compileOnSave": true
    }
  * [`noEmitOnError`](/tsconfig#noEmitOnError) : Do not emit outputs if any errors were reported.
  * [`noImplicitAny`](/tsconfig#noImplicitAny) : Raise error on expressions and declarations with an implied `any` type.
  * [`sourceMap`](/tsconfig#sourceMap) : Generates corresponding `.map` file.
  * [`target`](/tsconfig#target) : Specify ECMAScript target version.
Note: `"ESNext"` targets latest supported
[`noImplicitAny`](/tsconfig#noImplicitAny) is good idea whenever you‚Äôre
writing new code ‚Äî you can make sure that you don‚Äôt write any untyped code by
mistake. `"compileOnSave"` makes it easy to update your code in a running web
app.
#### _Set up NPM_
We need to setup NPM so that JavaScript packages can be downloaded. Right
click on the project and select **New Item**. Then choose **NPM Configuration
File** and use the default name of `package.json`.
Inside the `"devDependencies"` section of the `package.json` file, add _gulp_
and _del_
    "devDependencies": {
        "gulp": "4.0.2",
        "del": "5.1.0"
    }
Visual Studio should start installing gulp and del as soon as you save the
file. If not, right-click package.json and then Restore Packages.
After you should see an `npm` folder in your solution explorer
#### _Set up gulp_
Right click on the project and click **New Item**. Then choose **JavaScript
File** and use the name of `gulpfile.js`
    js
    /// <binding AfterBuild='default' Clean='clean' />
    /*
    This file is the main entry point for defining Gulp tasks and using Gulp plugins.
    Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007
    */
    var gulp = require("gulp");
    var del = require("del");
    var paths = {
      scripts: ["scripts/**/*.js", "scripts/**/*.ts", "scripts/**/*.map"],
    };
    gulp.task("clean", function () {
      return del(["wwwroot/scripts/**/*"]);
    });
    gulp.task("default", function (done) {
        gulp.src(paths.scripts).pipe(gulp.dest("wwwroot/scripts"));
        done();
    });
The first line tells Visual Studio to run the task ‚Äòdefault‚Äô after the build
finishes. It will also run the ‚Äòclean‚Äô task when you ask Visual Studio to
clean the build.
Now right-click on `gulpfile.js` and click Task Runner Explorer.
If ‚Äòdefault‚Äô and ‚Äòclean‚Äô tasks don‚Äôt show up, refresh the explorer:
## Write a HTML page
Right click on the `wwwroot` folder (if you don‚Äôt see the folder try building
the project) and add a New Item named `index.html` inside. Use the following
code for `index.html`
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <script src="scripts/app.js"></script>
        <title></title>
    </head>
    <body>
        <div id="message"></div>
        <div>
            Compiler: <input id="compiler" value="TypeScript" onkeyup="document.getElementById('message').innerText = sayHello()" /><br />
            Framework: <input id="framework" value="ASP.NET" onkeyup="document.getElementById('message').innerText = sayHello()" />
        </div>
    </body>
    </html>
## Test
  1. Run the project
  2. As you type on the boxes you should see the message appear/change!
## Debug
  1. In Edge, press F12 and click the Debugger tab.
  2. Look in the first localhost folder, then scripts/app.ts
  3. Put a breakpoint on the line with return.
  4. Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.
Congrats you‚Äôve built your own .NET Core project with a TypeScript frontend.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/ASP.NET Core.md) ‚ù§
Contributors to this page:  
BK
OT
GC
DR
LZ
14+
Last updated: Sep 16, 2024  
Was this page helpful?
# Using Babel with TypeScript
## Babel vs `tsc` for TypeScript
When making a modern JavaScript project, you might ask yourself what is the
right way to convert files from TypeScript to JavaScript?
A lot of the time the answer is _‚Äúit depends‚Äù_ , or _‚Äúsomeone may have decided
for you‚Äù_ depending on the project. If you are building your project with an
existing framework like [tsdx](https://tsdx.io),
[Angular](https://angular.io/), [NestJS](https://nestjs.com/) or any framework
mentioned in the [Getting Started](/docs/home) then this decision is handled
for you.
However, a useful heuristic could be:
  * Is your build output mostly the same as your source input files? Use `tsc`
  * Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking
## Babel for transpiling, `tsc` for types
This is a common pattern for projects with existing build infrastructure which
may have been ported from a JavaScript codebase to TypeScript.
This technique is a hybrid approach, using Babel‚Äôs [preset-
typescript](https://babeljs.io/docs/en/babel-preset-typescript) to generate
your JS files, and then using TypeScript to do type checking and `.d.ts` file
generation.
By using babel‚Äôs support for TypeScript, you get the ability to work with
existing build pipelines and are more likely to have a faster JS emit time
because Babel does not type check your code.
#### Type Checking and d.ts file generation
The downside to using babel is that you don‚Äôt get type checking during the
transition from TS to JS. This can mean that type errors which you miss in
your editor could sneak through into production code.
In addition to that, Babel cannot create `.d.ts` files for your TypeScript
which can make it harder to work with your project if it is a library.
To fix these issues, you would probably want to set up a command to type check
your project using TSC. This likely means duplicating some of your babel
config into a corresponding [`tsconfig.json`](/tsconfig) and ensuring these
flags are enabled:
    "compilerOptions": {
      // Ensure that .d.ts files are created by tsc, but not .js files
      "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
      "[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)": true,
      // Ensure that Babel can safely transpile files in the TypeScript project
      "[isolatedModules](https://www.typescriptlang.org/tsconfig#isolatedModules)": true
    }
For more information on these flags:
  * [`isolatedModules`](/tsconfig#isolatedModules)
  * [`declaration`](/tsconfig#declaration), [`emitDeclarationOnly`](/tsconfig#emitDeclarationOnly)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Babel with
TypeScript.md) ‚ù§
Contributors to this page:  
OT
R
US
Last updated: Sep 16, 2024  
Was this page helpful?
### This page has been deprecated
This handbook page has been replaced, [go to the new
page](/docs/handbook/2/everyday-types.html)
[Go to new page](/docs/handbook/2/everyday-types.html)
# Basic Types
For programs to be useful, we need to be able to work with some of the
simplest units of data: numbers, strings, structures, boolean values, and the
like. In TypeScript, we support the same types as you would expect in
JavaScript, with an extra enumeration type thrown in to help things along.
## Boolean
The most basic datatype is the simple true/false value, which JavaScript and
TypeScript call a `boolean` value.
    ts
    let isDone: boolean = false;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAlgzgIgewHYgFwQEYIaAhkiAXggDNdgYQBuIA)
## Number
As in JavaScript, all numbers in TypeScript are either floating point values
or BigIntegers. These floating point numbers get the type `number`, while
BigIntegers get the type `bigint`. In addition to hexadecimal and decimal
literals, TypeScript also supports binary and octal literals introduced in
ECMAScript 2015.
    ts
    let decimal: number = 6;
    let hex: number = 0xf00d;
    let binary: number = 0b1010;
    let octal: number = 0o744;
    let big: bigint = 100n;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlATABjwFAA2yoAJogMYCWAttEWgHYCutARorKALygBsAbmKkAFogAezNp259cEgGa5cZYSUih21JnACe0jl16hc7AIy5L60gHtKMRqFZG5p2wHYALF5ubt8GgBOpp8lrhMgkA)
## String
Another fundamental part of creating programs in JavaScript for webpages and
servers alike is working with textual data. As in other languages, we use the
type `string` to refer to these textual datatypes. Just like JavaScript,
TypeScript also uses double quotes (`"`) or single quotes (`'`) to surround
string data.
    ts
    let color: string = "blue";
    color = 'red';
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxg9sMCcBcEDOYEEsB2BzCAvBAEQBGwAriMQNwBQA9AxAA4LhiYgIC0mu2RCDqx4CQhADk7ACaSaQA)
You can also use _template strings_ , which can span multiple lines and have
embedded expressions. These strings are surrounded by the backtick/backquote
(```) character, and embedded expressions are of the form `${ expr }`.
    ts
    let fullName: string = `Bob Bobbington`;
    let age: number = 37;
    let sentence: string = `Hello, my name is ${fullName}.
    I'll be ${age + 1} years old next month.`;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZgrswDkCGBbEAuCBnMAnAlgHYDmEAvBAAYBCA9gEYR331HFi2GUDcAUKJCTEMEQjBT0QuchADMAdj4DsIQmFUBjETgIkZlABIh4tADQQUAT1GoQEfFggASAN6x4yNAF8AdL14AkgDk8BCSzi5CdgDUEACMXhCWIEi4jrTAACaiIAAekCicYAAWPjxAA)
This is equivalent to declaring `sentence` like so:
    ts
    let sentence: string =
      "Hello, my name is " +
      fullName +
      ".\n\n" +
      "I'll be " +
      (age + 1) +
      " years old next month.";
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZgrswDkCGBbEAuCBnMAnAlgHYDmEAvBAAYBCA9gEYR331HFi2GUDcAUKJCTEMEQjBT0QuchADMAdj4B6JRAC0GgMYwwGtf3DYQhMMc0icBEuV4QIAIgASIeLQA0EFAE9RqEBHwsBwgAaltoOEQ-UPD7ADoAHUIk+xi7ewBJAHJ4CElgsLsACiF-EIgARgBKNOCvECRcINpgABNREAAPSBROMAALOPtuIA)
## Array
TypeScript, like JavaScript, allows you to work with arrays of values. Array
types can be written in one of two ways. In the first, you use the type of the
elements followed by `[]` to denote an array of that element type:
    ts
    let list: number[] = [1, 2, 3];
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMCWDOYC4IDsCuBbARiATgbQF0IBeCPARgBoIAmagZgIG4g)
The second way uses a generic array type, `Array<elemType>`:
    ts
    let list: Array<number> = [1, 2, 3];
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMCWDOYC4IEEBOqCGBPAPAOwFcBbAIxFQD4IBeCAbQEYAaCAJhYGYBdAbiA)
## Tuple
Tuple types allow you to express an array with a fixed number of elements
whose types are known, but need not be the same. For example, you may want to
represent a value as a pair of a `string` and a `number`:
    ts
    // Declare a tuple type
    let x: [string, number];
    // Initialize it
    x = ["hello", 10]; // OK
    // Initialize it incorrectly
    x = [10, "hello"]; // Error
    Type 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.2322  
    2322Type 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAlACKQDGANgIbSSjmgAuArgA6nV0CeTkOrdoAHqgDaiOtACWAOwDmAGlCSGAWwBGMALoBuPGACSk8XXHlS4gF7VDOfqAC8oIQCIAFpFKk4j+QEYADFtB8AHkAaR1QfUNjUwtQQzjJYgQqYjpSdms7Bz95FzcPRwD8AFFYBCA)
When accessing an element with a known index, the correct type is retrieved:
    ts
    // OK
    console.log(x[0].substring(1));
    console.log(x[1].substring(1));
    Property 'substring' does not exist on type 'number'.2339Property 'substring' does not exist on type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAbSAF1AA9UBtRI6ASwDsBzAGlHoFcBbAIxgF0A3LlKgAvKAoAiABaR8+OJNYBGAAyDQIUAHkA0rhBgAtCYDG7IiaMGwe3Kbj1EcQgDoFjABSkK614nZuajomT2UASnChe0dnNw9vCmU+f0Dghi8IqKA)
Accessing an element outside the set of known indices fails with an error:
    ts
    x[3] = "world";
    Tuple type '[string, number]' of length '2' has no element at index '3'.2493Tuple type '[string, number]' of length '2' has no element at index '3'.
    console.log(x[5].toString());
    Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.2532  
    2493Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmdBWHNdItAKABtIAXUAD1QG1FroBLAOwHMAaUDgK4BbAEYwAugG4ydUAF5QjAEQALSBQpwlfAIwAGKaBCgA8gGkyIMAFpbAYwHVb1mYxzj5oJQHcEFACZK0mR2cByIcFQAdJpcABR0jPjiUdRwAMqsnPEAlDmSQA)
## Enum
A helpful addition to the standard set of datatypes from JavaScript is the
`enum`. As in languages like C#, an enum is a way of giving more friendly
names to sets of numeric values.
    ts
    enum Color {
      Red,
      Green,
      Blue,
    }
    let c: Color = Color.Green;
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEwBosoBxZYUY7AIQTGGIF8MFgAXKAYwC5ZEUUALz8kyAHTlKIANxA)
By default, enums begin numbering their members starting at `0`. You can
change this by manually setting the value of one of its members. For example,
we can start the previous example at `1` instead of `0`:
    ts
    enum Color {
      Red = 1,
      Green,
      Blue,
    }
    let c: Color = Color.Green;
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRLsAhBMYSgXwwWABcoAxgC5YiFMVFJkAOlr0QAbiA)
Or, even manually set all the values in the enum:
    ts
    enum Color {
      Red = 1,
      Green = 2,
      Blue = 4,
    }
    let c: Color = Color.Green;
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRioAmS7AIQTGEYBZKBfDAmAAXKAGMAXLEQpG8JMgB0teiADcQA)
A handy feature of enums is that you can also go from a numeric value to the
name of that value in the enum. For example, if we had the value `2` but
weren‚Äôt sure what that mapped to in the `Color` enum above, we could look up
the corresponding name:
    ts
    enum Color {
      Red = 1,
      Green,
      Blue,
    }
    let colorName: string = Color[2];
    // Displays 'Green'
    console.log(colorName);
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAwg9gGzgJygbwFBSgJWAEygF4oBGAGiygHFlhRLsAhBMYSgXwwWABcoAxohQA5AIYRgALigBnXsgCWIAObFYw5AG0ATAF0A3BgwB6E1AAii2QAcEYgJ6yoAclr0QLjEJCzEwADokFQAKISRkcUkASgMgA)
## Unknown
We may need to describe the type of variables that we do not know when we are
writing an application. These values may come from dynamic content ‚Äì e.g. from
the user ‚Äì or we may want to intentionally accept all values in our API. In
these cases, we want to provide a type that tells the compiler and future
readers that this variable could be anything, so we give it the `unknown`
type.
    ts
    let notSure: unknown = 4;
    notSure = "maybe a string instead";
    // OK, definitely a boolean
    notSure = false;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAdg9mDKBXATiAXBRUDWsDuUEAvBACwDcAULAiiMRAEQC2AhgJ4BG9rEAzmGQBLKAHMIIgSFYATRlUoB6RRADyAaQA0EGSABmIoWBDB2EXpxgxQrKNThJUDPa2B8Q5IA)
If you have a variable with an unknown type, you can narrow it to something
more specific by doing `typeof` checks, comparison checks, or more advanced
type guards that will be discussed in a later chapter:
    ts
    declare const maybe: unknown;
    // 'maybe' could be a string, object, boolean, undefined, or other types
    const aNumber: number = maybe;
    Type 'unknown' is not assignable to type 'number'.2322Type 'unknown' is not assignable to type 'number'.
    if (maybe === true) {
      // TypeScript knows that maybe is a boolean now
      const aBoolean: boolean = maybe;
      // So, it cannot be a string
      const aString: string = maybe;
    Type 'boolean' is not assignable to type 'string'.2322Type 'boolean' is not assignable to type 'string'.
    }
    if (typeof maybe === "string") {
      // TypeScript knows that maybe is a string
      const aString: string = maybe;
      // So, it cannot be a boolean
      const aBoolean: boolean = maybe;
    Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vVnnsAoAE0gGMAbAQ2klDLgDtEAXUAWyoE8AjSVAK6MA1ozgB3RgG5CIUAHJOvSPPpwBFYqD6gqoVtACWjAOYAaUHB4Arciws84cCpCqMLQ0gDNjkYhYRLFgALGFAWLgAHSERCBmY2KgA5AXY+aFRGVPTQAF4Obj4ZQkMvUAAKJR1cmvDoAUgASlAAb0JQUDkAFSjIAGUyI0i2UQlEcOCqNiq6Q3G9R2dXRlAxcXa1BN0AIScXN1RF-ZX8mZkOuT64C0M2MjcxNh09A2MTDfjWXT6WI1NUV6mPIFZQyAC+hBKZXKEWicDKMzytQARICTMjmm0LmAetEBkMRmtxiEpiCdHNdPpfm8PkwvlQfn8TADqUDToVIOdOmArjc7g84E86As9staVsqLslgdtKK3MCzoQwUA)
## Any
In some situations, not all type information is available or its declaration
would take an inappropriate amount of effort. These may occur for values from
code that has been written without TypeScript or a 3rd party library. In these
cases, we might want to opt-out of type checking. To do so, we label these
values with the `any` type:
    ts
    declare function getValue(key: string): any;
    // OK, return value of 'getValue' is not checked
    const str: string = getValue("myString");
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMA1KCZEACgGsQBPALngGcMYtUCBKZqVegG4AUAHpR8APIBpADTw4GZDHwA3cpXg5E8AORFSGkLvhYW8VDgzwwAC3B1gwsHjat2zNhy7wAvIWIyCmoAIgBbegBldk4CEO5BIA)
The `any` type is a powerful way to work with existing JavaScript, allowing
you to gradually opt-in and opt-out of type checking during compilation.
Unlike `unknown`, variables of type `any` allow you to access arbitrary
properties, even ones that don‚Äôt exist. These properties include functions and
TypeScript will not check their existence or type:
    ts
    let looselyTyped: any = 4;
    // OK, ifItExists might exist at runtime
    looselyTyped.ifItExists();
    // OK, toFixed exists (but the compiler doesn't check)
    looselyTyped.toFixed();
    let strictlyTyped: unknown = 4;
    strictlyTyped.toFixed();
    'strictlyTyped' is of type 'unknown'.18046'strictlyTyped' is of type 'unknown'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABtIAXUKuORSKgTwBU2AHSAE1QBDAHZtQAXlAkA3BRCgA8gGkANKACWAMwCStAKIAPdYlqJQAW3UBzABb1IRk6EH1oAV2G115yNSYt2Ll4+ADotXUNjUwAKAEpZeWU1WjgAMXUDflAHKLNogCM3elobSFAAYzhzbnUaaFA+OEhEYQByenLS8oBrWL9mVk4efhCU9My+ONlqOlATaHVy2kDhgVAPbuE4AHdhCSlZecXloeDRtIz+KaA)
The `any` will continue to propagate through your objects:
    ts
    let looselyTyped: any = {};
    let d = looselyTyped.a.b.c.d;
    let d: any
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBMD20M4mATwCpIA4gCYC4IEMA7JCAXggG8BfAbgChRIsypYFk1MsA6fbgI24BjblnoB6cRAgA9APxA)
After all, remember that all the convenience of `any` comes at the cost of
losing type safety. Type safety is one of the main motivations for using
TypeScript and you should try to avoid using `any` when not necessary.
## Void
`void` is a little like the opposite of `any`: the absence of having any type
at all. You may commonly see this as the return type of functions that do not
return a value:
    ts
    function warnUser(): void {
      console.log("This is my warning message");
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwIYCcwFUDOBTdACgEoAuRANzhgBNEBvAKEUQgRzgBs8A6TuAOaEARABUAFjByIpiALYBPFBjAwwA+Xhw5UAvMOIBuRgF8gA)
Declaring variables of type `void` is not useful because you can only assign
`null` (only if [`strictNullChecks`](/tsconfig#strictNullChecks) is not
specified, see next section) or `undefined` to them:
    ts
    let unusable: void = undefined;
    // OK if `--strictNullChecks` is not given
    unusable = null;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgCuAdmZJgEbFoBuA9vACagC85Fbe68CnjYBuAiFAB5ANKh46UAAMAtMpgJkAOTLZsAYQAWeRAGtIiuZFAVmpAObxGeCgUrU6xLtZ3YRQA)
## Null and Undefined
In TypeScript, both `undefined` and `null` actually have their types named
`undefined` and `null` respectively. Much like `void`, they‚Äôre not extremely
useful on their own:
    ts
    // Not much else we can assign to these variables!
    let u: undefined = undefined;
    let n: null = null;
    [Try](https://www.typescriptlang.org/play/#code/PTAEDkHsBdQWwK4GMAWoCmAbAzu0B3PJAQwDtRjtsBLAc3OklGhXV1ADdiAna4gI0xsAhACghsBAC5QCUgBN0AM2ql080AF5ZC5avUBucelikZpBJkxbQFqwaA)
By default `null` and `undefined` are subtypes of all other types. That means
you can assign `null` and `undefined` to something like `number`.
However, when using the [`strictNullChecks`](/tsconfig#strictNullChecks) flag, `null` and `undefined` are only assignable to `unknown`, `any` and their respective types (the one exception being that `undefined` is also assignable to `void`). This helps avoid _many_ common errors. In cases where you want to pass in either a `string` or `null` or `undefined`, you can use the union type `string | null | undefined`.
Union types are an advanced topic that we‚Äôll cover in a later chapter.
> As a note: we encourage the use of
> [`strictNullChecks`](/tsconfig#strictNullChecks) when possible, but for the
> purposes of this handbook, we will assume it is turned off.
## Never
The `never` type represents the type of values that never occur. For instance,
`never` is the return type for a function expression or an arrow function
expression that always throws an exception or one that never returns.
Variables also acquire the type `never` when narrowed by any type guards that
can never be true.
The `never` type is a subtype of, and assignable to, every type; however, _no_
type is a subtype of, or assignable to, `never` (except `never` itself). Even
`any` isn‚Äôt assignable to `never`.
Some examples of functions returning `never`:
    ts
    // Function returning never must not have a reachable end point
    function error(message: string): never {
      throw new Error(message);
    }
    // Inferred return type is never
    function fail() {
      return error("Something failed");
    }
    // Function returning never must not have a reachable end point
    function infiniteLoop(): never {
      while (true) {}
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEDEFcDsGMBcCWB7aoBOBTel3UdAOajSYBum6oAtpAM7wnKMAWAhhaGxpm7OwCMANplCZoAE1AAHZAXgAoAGYwEKNJXTJ0ACmqY6dNoUwAuUA3QFCASnOkKVAN4LQoeCy0B3Eph8BRdC1dfUNjTBsAbgUAXwUFEFAASWglTUwpLBw8dwBPaVFEOl9HZVUkVFAlNkQhHRtQFzcs3A0g7R0AIgBlZH0PayqakQlOqNj4xKg4CrQWvEGHShp6RmhmUHZObiw+QRExSRk5aEUVGfVQAiUCRHhMABlkZGl6+3JlptAvFlrRHXg6EgEUacRiQA)
## Object
`object` is a type that represents the non-primitive type, i.e. anything that
is not `number`, `string`, `boolean`, `bigint`, `symbol`, `null`, or
`undefined`.
With `object` type, APIs like `Object.create` can be better represented. For
example:
    ts
    declare function create(o: object | null): void;
    // OK
    create({ prop: 0 });
    create(null);
    create(undefined); // with `--strictNullChecks` flag enabled, undefined is not a subtype of null
    Argument of type 'undefined' is not assignable to parameter of type 'object | null'.2345Argument of type 'undefined' is not assignable to parameter of type 'object | null'.
    create(42);
    Argument of type 'number' is not assignable to parameter of type 'object'.2345Argument of type 'number' is not assignable to parameter of type 'object'.
    create("string");
    Argument of type 'string' is not assignable to parameter of type 'object'.2345Argument of type 'string' is not assignable to parameter of type 'object'.
    create(false);
    Argument of type 'boolean' is not assignable to parameter of type 'object'.2345Argument of type 'boolean' is not assignable to parameter of type 'object'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6MVec5ABRxUcAEYArEs1AAfUAzqlSASlQA3OKwIBuPHhCgA8gGk83SLwEBvUAAd4N1AAZQAXyU6zF-vMXvTPPn5GIhpWBkgCd1B9AHdWZgALUAADAFpUxGZoVhYAOQVSAGEEkgBrRGTaCgBzUEgGchFSCIAaUGDIUPCCUFZEOTgpclBEOhFmAE8bajgaOQLdT0CsND8lgQAiTOyGao21gIEaclJESHcgA)
Generally, you won‚Äôt need to use this.
## Type assertions
Sometimes you‚Äôll end up in a situation where you‚Äôll know more about a value
than TypeScript does. Usually, this will happen when you know the type of some
entity could be more specific than its current type.
_Type assertions_ are a way to tell the compiler ‚Äútrust me, I know what I‚Äôm
doing.‚Äù A type assertion is like a type cast in other languages, but it
performs no special checking or restructuring of data. It has no runtime
impact and is used purely by the compiler. TypeScript assumes that you, the
programmer, have performed any special checks that you need.
Type assertions have two forms.
One is the `as`-syntax:
    ts
    let someValue: unknown = "this is a string";
    let strLength: number = (someValue as string).length;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzg9gtiAagQ2AVxALgmgdga1xgHdcIBeCAIjAAsBLKCRiZaMAJ3twHMqBuAFCDQkKJwAyIXnWy40cAEYgOFCAApYCFOhCsm4rrwCUAOlAza-IA)
The other version is the ‚Äúangle-bracket‚Äù syntax:
    ts
    let someValue: unknown = "this is a string";
    let strLength: number = (<string>someValue).length;
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzg9gtiAagQ2AVxALgmgdga1xgHdcIBeCAIjAAsBLKCRiZaMAJ3twHMqBuAFCDQkKJwAyIXnWy40cAEYgOFCAAoAPOK68AfLAQp0IAJQA6UDNr8gA)
The two samples are equivalent. Using one over the other is mostly a choice of
preference; however, when using TypeScript with JSX, only `as`-style
assertions are allowed.
## A note about `let`
You may have noticed that so far, we‚Äôve been using the `let` keyword instead
of JavaScript‚Äôs `var` keyword which you might be more familiar with. The `let`
keyword is actually a newer JavaScript construct that TypeScript makes
available. You can read in the Handbook Reference on [Variable
Declarations](/docs/handbook/variable-declarations.html) more about how `let`
and `const` fix a lot of the problems with `var`.
## About `Number`, `String`, `Boolean`, `Symbol` and `Object`
It can be tempting to think that the types `Number`, `String`, `Boolean`,
`Symbol`, or `Object` are the same as the lowercase versions recommended
above. These types do not refer to the language primitives however, and almost
never should be used as a type.
    ts
    function reverse(s: String): String {
      return s.split("").reverse().join("");
    }
    reverse("hello world");
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jRpIA3GRSAChVAGVzpLiBzAJSpuvAaADeuUHUjlC0WogB0iAA4AbSuVYAiXYOX0mSNoYBWcPnoMBuXAF9cuY8za6AFpA0a4oAO4IGgAmdkA)
Instead, use the types `number`, `string`, `boolean`, `object` and `symbol`.
    ts
    function reverse(s: string): string {
      return s.split("").reverse().join("");
    }
    reverse("hello world");
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYDdXIM6oBTYBci2UyMYA5gJTGnlWIDeAUIiqlCMktgHTYADgBsYUPACIJ1Pmkw58MgFZwKk6QG4WAXxYs5WXJIAWqYcLiIA7nGTCAJpqA)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Basic Types.md) ‚ù§
Contributors to this page:  
RC
OT
DR
NS
MZ
47+
Last updated: Sep 16, 2024  
Was this page helpful?
### This page has been deprecated
This handbook page has been replaced, [go to the new
page](/docs/handbook/2/classes.html)
[Go to new page](/docs/handbook/2/classes.html)
# Classes
Traditional JavaScript uses functions and prototype-based inheritance to build
up reusable components, but this may feel a bit awkward to programmers more
comfortable with an object-oriented approach, where classes inherit
functionality and objects are built from these classes. Starting with
ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build
their applications using this object-oriented class-based approach. In
TypeScript, we allow developers to use these techniques now, and compile them
down to JavaScript that works across all major browsers and platforms, without
having to wait for the next version of JavaScript.
## Classes
Let‚Äôs take a look at a simple class-based example:
    ts
    class Greeter {
      greeting: string;
      constructor(message: string) {
        this.greeting = message;
      }
      greet() {
        return "Hello, " + this.greeting;
      }
    }
    let greeter = new Greeter("world");
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8BQ1oHMlUBLAO3wC5oIV4z8BubXaYAe1JvgFdgU34ACgC2iKGHyIqXegEosLPCgAWxCADpCyFPWgBeaKPGSmeAL7M8W1IPk48eJCm7xS0AEQAJRCBBsANB7QANTQKmqaRDrkptAWFtggqARR6PrQpIgA7nCpQu5ZAiAAJu6yDEA)
The syntax should look familiar if you‚Äôve used C# or Java before. We declare a
new class `Greeter`. This class has three members: a property called
`greeting`, a constructor, and a method `greet`.
You‚Äôll notice that in the class when we refer to one of the members of the
class we prepend `this.`. This denotes that it‚Äôs a member access.
In the last line we construct an instance of the `Greeter` class using `new`.
This calls into the constructor we defined earlier, creating a new object with
the `Greeter` shape, and running the constructor to initialize it.
## Inheritance
In TypeScript, we can use common object-oriented patterns. One of the most
fundamental patterns in class-based programming is being able to extend
existing classes to create new ones using inheritance.
Let‚Äôs take a look at an example:
    ts
    class Animal {
      move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
      }
    }
    class Dog extends Animal {
      bark() {
        console.log("Woof! Woof!");
      }
    }
    const dog = new Dog();
    dog.bark();
    dog.move(10);
    dog.bark();
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa1kHsA3AUwAoATRCAFzHmGIEl4BZY64gJwgC5p4ArsgBGXaAF5oABgCUmHLmjB88CPhDEAdCHwBzUgAMEKNHiLFy0ACQZKNOg2ZsO3AL7JNBmQG4FrrP5YoJAwACJ60MQAHhzw5DDGqOjYuMJgnADWpHIpisqq6lo6+gBEAOr4+ABmAITQFdU1JT5+AVhBKjTQ5BGS8MQA7tDh+i09upppmdm+45oEJKQAjLKzepPpWT5AA)
This example shows the most basic inheritance feature: classes inherit
properties and methods from base classes. Here, `Dog` is a _derived_ class
that derives from the `Animal` _base_ class using the `extends` keyword.
Derived classes are often called _subclasses_ , and base classes are often
called _superclasses_.
Because `Dog` extends the functionality from `Animal`, we were able to create
an instance of `Dog` that could both `bark()` and `move()`.
Let‚Äôs now look at a more complex example.
    ts
    class Animal {
      name: string;
      constructor(theName: string) {
        this.name = theName;
      }
      move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
      }
    }
    class Snake extends Animal {
      constructor(name: string) {
        super(name);
      }
      move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
      }
    }
    class Horse extends Animal {
      constructor(name: string) {
        super(name);
      }
      move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
      }
    }
    let sam = new Snake("Sammy the Python");
    let tom: Animal = new Horse("Tommy the Palomino");
    sam.move();
    tom.move(34);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa15mQFMAuaCAFwCdF4BzAbh2mAHt4LKBXYclygCnIALQgDkCJMlRq0AlJia5hiCADp8RaAF5owsRMa4Avk2QsAboX4ATFeTDxghAJLwAsoXKFKEUvE7IAEbe2tAADPLYuLis7CwghKogLLT8AAYAJBjKahqERtBmltbQWbYUDk6uHl4+RsiqabKG0CYmWKCQMADK+ADWhNCEAB5e8NYwCChoCjFsHNy8AnmkHDKRimScAA7e-HnNTCa4RVbl9o4u7p7eMDoArBvRzPPxicmpAETdIIh61HRVEDPodnhAdt5VKcbHZKlcardQa0sO1OlBoAAJPgQQYjMYTOBIVDoKIvdhURZ8fYSVbSOhPaLg3bLCRI46FCxnWGXao3HyhAAsj1m0ViEDeSRS-E+AHE0MltjIgaoQS1cEzIdDznDebUIGyUVgsAlyGQCKF4IQAO7QXpgAbS7oEZAAT10ImgAAUXcI2KrjZ5dCxkKQpsSLdbMdirJ8ACrB13uwaetDBmgsf1YCAEKGc-iHXgNaEAZgFzSAA)
This example covers a few other features we didn‚Äôt previously mention. Again,
we see the `extends` keywords used to create two new subclasses of `Animal`:
`Horse` and `Snake`.
One difference from the prior example is that each derived class that contains
a constructor function _must_ call `super()` which will execute the
constructor of the base class. What‚Äôs more, before we _ever_ access a property
on `this` in a constructor body, we _have_ to call `super()`. This is an
important rule that TypeScript will enforce.
The example also shows how to override methods in the base class with methods
that are specialized for the subclass. Here both `Snake` and `Horse` create a
`move` method that overrides the `move` from `Animal`, giving it functionality
specific to each class. Note that even though `tom` is declared as an
`Animal`, since its value is a `Horse`, calling `tom.move(34)` will call the
overriding method in `Horse`:
    Slithering...
    Sammy the Python moved 5m.
    Galloping...
    Tommy the Palomino moved 34m.
## Public, private, and protected modifiers
### Public by default
In our examples, we‚Äôve been able to freely access the members that we declared
throughout our programs. If you‚Äôre familiar with classes in other languages,
you may have noticed in the above examples we haven‚Äôt had to use the word
`public` to accomplish this; for instance, C# requires that each member be
explicitly labeled `public` to be visible. In TypeScript, each member is
`public` by default.
You may still mark a member `public` explicitly. We could have written the
`Animal` class from the previous section in the following way:
    ts
    class Animal {
      public name: string;
      public constructor(theName: string) {
        this.name = theName;
      }
      public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeAoa0AOArgEYiLDTxjICmAXNBAC4BOi8A5gNxY77GnlgAe3hNmBYIyHMAFIwAW1AHJU6DFm3YBKTL1wLEEAHSUa0ALzQFy1d1wBfHrkIky0ZEIBu1GQBNDjGDwwNQAkvAAstSM1MwQ9PAEyESxOti4uMKiQiDURiBC7DIABgAkGAbGptT27l7UvtDl-kxBIeFRMXH2yEbFWnbQjvZAA)
### ECMAScript Private Fields
With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private
fields:
    ts
    class Animal {
      #name: string;
      constructor(theName: string) {
        this.#name = theName;
      }
    }
    new Animal("Cat").#name;
    Property '#name' is not accessible outside class 'Animal' because it has a private identifier.18013Property '#name' is not accessible outside class 'Animal' because it has a private identifier.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMaDMAoAYwBsBDRRUAQQDsBLAW1ONAG99RQBiG0hyVIgAu0OjQDmAbg6hCcGsOgBXQkIQAKIQAtIAOT4DQiseICUbGZ211EAOh4HQAXlDa9B6ZwC++H-hqQAO7U9EzE6gBEAMKkQhGm9rz8kkA)
This syntax is built into the JavaScript runtime and can have better
guarantees about the isolation of each private field. Right now, the best
documentation for these private fields is in the TypeScript 3.8 [release
notes](https://devblogs.microsoft.com/typescript/announcing-
typescript-3-8-beta/#ecmascript-private-fields).
### Understanding TypeScript‚Äôs `private`
TypeScript also has its own way to declare a member as being marked `private`,
it cannot be accessed from outside of its containing class. For example:
    ts
    class Animal {
      private name: string;
      constructor(theName: string) {
        this.name = theName;
      }
    }
    new Animal("Cat").name;
    Property 'name' is private and only accessible within class 'Animal'.2341Property 'name' is private and only accessible within class 'Animal'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUAMYA2AhooqAIIB2AlgLYlGgDeeooADtLQG4kAXSKGol6kVIgE9qAcwDcedqAJxqU6AFcCAhAAoBAC0gA5MRNAbacgJStlHI7UQA6UeNABeUEdPnFHAC+eMF41JAA7lR0jER6AEQAwoLxNm7+QA)
TypeScript is a structural type system. When we compare two different types,
regardless of where they came from, if the types of all members are
compatible, then we say the types themselves are compatible.
However, when comparing types that have `private` and `protected` members, we
treat these types differently. For two types to be considered compatible, if
one of them has a `private` member, then the other must have a `private`
member that originated in the same declaration. The same applies to
`protected` members.
Let‚Äôs look at an example to better see how this plays out in practice:
    ts
    class Animal {
      private name: string;
      constructor(theName: string) {
        this.name = theName;
      }
    }
    class Rhino extends Animal {
      constructor() {
        super("Rhino");
      }
    }
    class Employee {
      private name: string;
      constructor(theName: string) {
        this.name = theName;
      }
    }
    let animal = new Animal("Goat");
    let rhino = new Rhino();
    let employee = new Employee("Bob");
    animal = rhino;
    animal = employee;
    Type 'Employee' is not assignable to type 'Animal'.
      Types have separate declarations of a private property 'name'.2322Type 'Employee' is not assignable to type 'Animal'.
      Types have separate declarations of a private property 'name'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAGMAbAQ0UVAEEA7ASwFsiDQBvHUUAB2moDciAXSKEpFakVIj5dKAcwDcrUHjiUJ0AK54+CABR8AFpAByIsaFXUZASmYK2+6ogB0w0aAC8ofUZPy2AXxwA-GJSUAAlPQs4UEgADwFKABMyKjoGGzYlFUkNLWhtaxY2NkQ1dhhtACIIqMrLX1AAoMISMgBRWnYCOABPSEEiji5eASETcUkLOQUs1VydL2NRCalpQttPSKcXQQ9FnwUmnBwCSD5QIhp6Rg9KSAB3CiuGKoBxOH46+VPz6EjKaK3B7hf5wArfM4xTrdPq7ITAjpdXr9KoAITgACMvsdLmkbqA-lF5Ljru4oUjYbIgA)
In this example, we have an `Animal` and a `Rhino`, with `Rhino` being a
subclass of `Animal`. We also have a new class `Employee` that looks identical
to `Animal` in terms of shape. We create some instances of these classes and
then try to assign them to each other to see what will happen. Because
`Animal` and `Rhino` share the `private` side of their shape from the same
declaration of `private name: string` in `Animal`, they are compatible.
However, this is not the case for `Employee`. When we try to assign from an
`Employee` to `Animal` we get an error that these types are not compatible.
Even though `Employee` also has a `private` member called `name`, it‚Äôs not the
one we declared in `Animal`.
### Understanding `protected`
The `protected` modifier acts much like the `private` modifier with the
exception that members declared `protected` can also be accessed within
deriving classes. For example,
    ts
    class Person {
      protected name: string;
      constructor(name: string) {
        this.name = name;
      }
    }
    class Employee extends Person {
      private department: string;
      constructor(name: string, department: string) {
        super(name);
        this.department = department;
      }
      public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
      }
    }
    let howard = new Employee("Howard", "Sales");
    console.log(howard.getElevatorPitch());
    console.log(howard.name);
    Property 'name' is protected and only accessible within class 'Person' and its subclasses.2445Property 'name' is protected and only accessible within class 'Person' and its subclasses.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYBQBjAGwENFFQAFGROAO1AG9dRQAHeAF0ny4BNRaxALaRUiDtACWtAOYBuZqHx1x0AK48EACkEixE6TICUjRSw4ALSYgB0uyKAC8A4ZAUsAvri8ESZUACiQqyEcACekA6QAB5ctLzkVEh0pizskgBuxFygvJCsxNAcIrQc+lKyCorKtKoaHNr25YYANLn5hcWQpc2yJkwsLIhqrDA6rkbug5bWNnkFRSUcTu0LXaVTPmlqAEaEkvigMpAcAYSQWQ3QFJIc+BZa-Wag0Cdq0PQABgASkIShbSEYRcIlA1lAABIGDNbPYPKBiPFQABJUAAdwQAGswfQoTC5h1Ft0OB4bJ9Nt5cLhzssLHA0YV+M5aJA0YFgqEIpAtAAib70xk8to8gDKxHOiB5kwIKjg5xsoRkWjpDOgvBsx1O50uCBudweRmlNRo8sVyoFarsEzkQA)
Notice that while we can‚Äôt use `name` from outside of `Person`, we can still
use it from within an instance method of `Employee` because `Employee` derives
from `Person`.
A constructor may also be marked `protected`. This means that the class cannot
be instantiated outside of its containing class, but can be extended. For
example,
    ts
    class Person {
      protected name: string;
      protected constructor(theName: string) {
        this.name = theName;
      }
    }
    // Employee can extend Person
    class Employee extends Person {
      private department: string;
      constructor(name: string, department: string) {
        super(name);
        this.department = department;
      }
      public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
      }
    }
    let howard = new Employee("Howard", "Sales");
    let john = new Person("John");
    Constructor of class 'Person' is protected and only accessible within the class declaration.2674Constructor of class 'Person' is protected and only accessible within the class declaration.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYDsAWAUAMYA2AhooqAAoyJwB2oA3nqKAA7wAukB3AJqDokAtpFSJO0AJZ0A5gG4W7Lj36gC9CdACuvBAApOAC0gA5EWNBaZsgJRMlrY1MQA6IaNABeUMbMXFVgBfPBC8EFAAUWE2IjgAT0hIdRIGSAAPbjoBaiR6QlJyKJi4xOSMrL4KXNoGZlYOKQA3Em5QPkg2EmhOUTpOcUkbRSUNOi1dTgMPS2s5ABp2zu7eyH7B6Tl7etYrbTYYfRnbQN3nNw6unr7ObyWr1f7TsIbtACMiKQJQWUhOSKIkBaU2glCknAIRn020coGgf200AYAAMABKQIhxRbCeKCCygFygAAkjHO7gsQVAqQEAElQAB3BAAawJDBJZMuKxuQVcyOeoTweEBtyMcHp3QEPjokHpxViCSS+gARKixRKlYslQBlEiAxBKk5Cv6gABWcCMDClMqoNHoyoAUua6Ab5EA)
## Readonly modifier
You can make properties readonly by using the `readonly` keyword. Readonly
properties must be initialized at their declaration or in the constructor.
    ts
    class Octopus {
      readonly name: string;
      readonly numberOfLegs: number = 8;
      constructor(theName: string) {
        this.name = theName;
      }
    }
    let dad = new Octopus("Man with the 8 strong legs");
    dad.name = "Man with the 3-piece suit";
    Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAMYA2AhooqAPIEAucADgK4UDeeoo0kJAJnAHZEAnqH4kAtpFSIa0AJb8A5gG52nbn0Ej+jcQCMYlAGYAZSIpSjdB6KAC8oAByq1BATOiNaCABQ0AFpAAchJSoB4KigCUoGwcHAFyiAB0YpL2oAHBoaocAL54BXhEkDSgPLwZ-JAA7lTeTIg+AEQAsiT8oDVyAZmBTuGyAoqgJRbNUaoVPKmhGW0dXT3+fZCgAMwAtPRykARriIw9zcpAA)
## Parameter properties
In our last example, we had to declare a readonly member `name` and a
constructor parameter `theName` in the `Octopus` class. This is needed in
order to have the value of `theName` accessible after the `Octopus`
constructor is executed. _Parameter properties_ let you create and initialize
a member in one place. Here‚Äôs a further revision of the previous `Octopus`
class using a parameter property:
    ts
    class Octopus {
      readonly numberOfLegs: number = 8;
      constructor(readonly name: string) {}
    }
    let dad = new Octopus("Man with the 8 strong legs");
    dad.name;
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDywBcD2AHArjA3gKGtATgKZgAmSAdiAJ7TloC2ARofrAGYAyhA5hAFy0GzfNAC80ABwBuXNGAUICfGkRJ8ACiKkK1WmHqEBi-AEty3AJTRMAX2x3sIQgmglSY2oQDucVegjqAEQAsmDk0F4mCAAW0DGEktDGFNzQTryBFjJuJAB05PqEUkA)
Notice how we dropped `theName` altogether and just use the shortened
`readonly name: string` parameter on the constructor to create and initialize
the `name` member. We‚Äôve consolidated the declarations and assignment into one
location.
Parameter properties are declared by prefixing a constructor parameter with an
accessibility modifier or `readonly`, or both. Using `private` for a parameter
property declares and initializes a private member; likewise, the same is done
for `public`, `protected`, and `readonly`.
## Accessors
TypeScript supports getters/setters as a way of intercepting accesses to a
member of an object. This gives you a way of having finer-grained control over
how a member is accessed on each object.
Let‚Äôs convert a simple class to use `get` and `set`. First, let‚Äôs start with
an example without getters and setters.
    ts
    class Employee {
      fullName: string;
    }
    let employee = new Employee();
    employee.fullName = "Bob Smith";
    if (employee.fullName) {
      console.log(employee.fullName);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCiAtgA7YD2AnnnqAN4GgYCu22Acpip40MBADsA5gG4CAXwIFseaKDy0GzVgF5Q4vAHdKGpiwAUASlnq6pvADp0vAUJ2gARACF6AI1ABlKnhoAAt3WQJ4dFAzG00WR2dBYQt2TlBEenFIemV7BklYky1EvmS8K3kgA)
While allowing people to randomly set `fullName` directly is pretty handy, we
may also want enforce some constraints when `fullName` is set.
In this version, we add a setter that checks the length of the `newName` to
make sure it‚Äôs compatible with the max-length of our backing database field.
If it isn‚Äôt we throw an error notifying client code that something went wrong.
To preserve existing functionality, we also add a simple getter that retrieves
`fullName` unmodified.
    ts
    const fullNameMaxLength = 10;
    class Employee {
      private _fullName: string = "";
      get fullName(): string {
        return this._fullName;
      }
      set fullName(newName: string) {
        if (newName && newName.length > fullNameMaxLength) {
          throw new Error("fullName has a max length of " + fullNameMaxLength);
        }
        this._fullName = newName;
      }
    }
    let employee = new Employee();
    employee.fullName = "Bob Smith";
    if (employee.fullName) {
      console.log(employee.fullName);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCID2AdjBgK7bYBymAtngLKYAeAMnqQObQAWoALygAjAAYA3ASLZMkSKACiDAA7ZiATzx5QAbwKhQqhADdM0XQH101OozxoYCXsNAAid9MOgeeaFQ09EwAFACUTnDwrgZGRrD+lLCkoALwkAB0NnbBeNJGAL4yRvgBtkEOIaR4AO65kS48Yfo+RvDooFW1uaAAZL2g1XUOGdjcfIIAfIH2TKyc4wLNsXFGArDENYO1yrAbsCHu5bO6-PKgmKAM7KBjvAKgxB3uoADUM7nzXPf8YflxRVaqX46Syxx6IiGuX+RUBYwCeDUGm0ukhOxU6i0OnC0kRmJRGXBDjc7gAQsQAEagADKDHgAi8MnanTxyJ0hJyDmWPhI5GIY1GxB4IVZWLwHIqTD+BAKQA)
To prove to ourselves that our accessor is now checking the length of values,
we can attempt to assign a name longer than 10 characters and verify that we
get an error.
A couple of things to note about accessors:
First, accessors require you to set the compiler to output ECMAScript 5 or
higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with
a `get` and no `set` are automatically inferred to be `readonly`. This is
helpful when generating a `.d.ts` file from your code, because users of your
property can see that they can‚Äôt change it.
## Static Properties
Up to this point, we‚Äôve only talked about the _instance_ members of the class,
those that show up on the object when it‚Äôs instantiated. We can also create
_static_ members of a class, those that are visible on the class itself rather
than on the instances. In this example, we use `static` on the origin, as it‚Äôs
a general value for all grids. Each instance accesses this value through
prepending the name of the class. Similarly to prepending `this.` in front of
instance accesses, here we prepend `Grid.` in front of static accesses.
    ts
    class Grid {
      static origin = { x: 0, y: 0 };
      calculateDistanceFromOrigin(point: { x: number; y: number }) {
        let xDist = point.x - Grid.origin.x;
        let yDist = point.y - Grid.origin.y;
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
      }
      constructor(public scale: number) {}
    }
    let grid1 = new Grid(1.0); // 1x scale
    let grid2 = new Grid(5.0); // 5x scale
    console.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));
    console.log(grid2.calculateDistanceFromOrigin({ x: 10, y: 10 }));
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBLAJtA3gKGtCAXMuiw0A9kgOaIB20AvOtAB4Bc0ADADTQCerb0AXwDcGLNGBgQwAK7hcAUwAiiPGCrB5AMXgkAtgHkK1ABQAHEtVys0TVlWm6ARvPhCedh8-iCAlOjHYIPK4TMp4dNDmlgB0jNAAtHBIyNFkiJRUsSLYgcE8YSH0UVS40dwJSSipRpnc2TnwwdLwNACyBAAW0RAAjvC4xowF0ABUoSohANT5E6MzeH4A9NC4HSrdEkH1AqLYwCRUePDSwLhkZtKOIEQ4m-IeTi5+aDs7GEEh5MkAjBFU8gB3SrIYzfaJsHxuRbLb5xCB3d55L4oABMf0BwOMAFZwZDoNDoFi4QiMPtDiQgtEQCRyMZkcgwZsZHIlBM1BptHpDOkTDYWNBvpx3AL+AIfJDSQcIBT5FSaXTkijokzZARWap1FodAYasY+axBVxeCLfJCgA)
## Abstract Classes
Abstract classes are base classes from which other classes may be derived.
They may not be instantiated directly. Unlike an interface, an abstract class
may contain implementation details for its members. The `abstract` keyword is
used to define abstract classes as well as abstract methods within an abstract
class.
    ts
    abstract class Animal {
      abstract makeSound(): void;
      move(): void {
        console.log("roaming the earth...");
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgggOwJYFthkEBvAKAQVEhngUIGsBTAZQHsBXbAEwAoBKAFwIAbm1zcA3GQr02IpgOFiJpWZVhtsYNsiYA6ZGwDmvAERQ2wfLmzGEEABZMETYFCf6vZ-tMoBfMn8gA)
Methods within an abstract class that are marked as abstract do not contain an
implementation and must be implemented in derived classes. Abstract methods
share a similar syntax to interface methods. Both define the signature of a
method without including a method body. However, abstract methods must include
the `abstract` keyword and may optionally include access modifiers.
    ts
    abstract class Department {
      constructor(public name: string) {}
      printName(): void {
        console.log("Department name: " + this.name);
      }
      abstract printMeeting(): void; // must be implemented in derived classes
    }
    class AccountingDepartment extends Department {
      constructor() {
        super("Accounting and Auditing"); // constructors in derived classes must call super()
      }
      printMeeting(): void {
        console.log("The Accounting Department meets each Monday at 10am.");
      }
      generateReports(): void {
        console.log("Generating accounting reports...");
      }
    }
    let department: Department; // ok to create a reference to an abstract type
    department = new Department(); // error: cannot create an instance of an abstract class
    Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.
    department = new AccountingDepartment(); // ok to create and assign a non-abstract subclass
    department.printName();
    department.printMeeting();
    department.generateReports(); // error: department is not of type AccountingDepartment, cannot access generateReports
    Property 'generateReports' does not exist on type 'Department'.2339Property 'generateReports' does not exist on type 'Department'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMX0GY8BOAKAEMAjRAF2lIGMrQ6AbUxRUAEUgAdToqAW0gA7RgG9ioJnBHVoAVwYIAFDwXlmASzqgRpYanlaRAcwCUocQF9iU0D2gmqAOQOQV51ADc4WgCZW9tJ0sohwzJAAdMxwpioARNx8AsJieu6oCaAA1KBUABZaiFH6wuYA3Pa29hTy9IyOzgCykJBUJvFeoL4BFaAgoIIK1KDkkKBagjyRaVSQgSag-jBa3gtMrOyQiMQ1LGwcAIJ0oQpincn8QqKMkAAe8yL+HFept0EhYTRKVKqWkmk0kQCh4MESJzOFzMoFIz1ARwU-i0HTMCUqAzAoTkP2USEmImWq3WgQO2w4w1GdFIzGYoBBYOgnmqdmkTTErXanU8Pj8gUBQOx4UiMTiiQAKgUJpC4OdUaYuLxrnMhm0qBxIPQCqBmrJ-KQAJ6wxhYAAMBii6Kq0hq0lMohgpHmACVeAh1TyenzPoKwhForF4gkAOIO2jy2GnWXQhXQN0CEpRS2VFk1SKMFYpG5iVBvbNUfqDOAAa3ycCYcadE1IoDjADMYKI6BM-rDCXUaA18gawcRM8qPgBePSQADuiqzc08hbAMHg0FQ1JEIjgjDolfmbYJ1DhzdAcDrW47tAYm0OfaV73Sw5EY4RUbll0v+enmP3pdb681m7hgUOWlMds9FkABaY8uxBcgyV2fsryoKJ2VcdxpwvSdbgQpwOTVbkU1g-MontW9w0gV0eHdRBX0GOcEFQPCVWKYDGAPbswXvKF5TzOYABomDhFdGHoZt2FAQjHRdeN1SAA)
## Advanced Techniques
## Constructor functions
When you declare a class in TypeScript, you are actually creating multiple
declarations at the same time. The first is the type of the _instance_ of the
class.
    ts
    class Greeter {
      greeting: string;
      constructor(message: string) {
        this.greeting = message;
      }
      greet() {
        return "Hello, " + this.greeting;
      }
    }
    let greeter: Greeter;
    greeter = new Greeter("world");
    console.log(greeter.greet()); // "Hello, world"
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8BQ1oHMlUBLAO3wC5oIV4z8BubXaYAe1JvgFdgU34ACgC2iKGHyIqXegEosLPCgAWxCADpCyFPWgBeaKPGSmeAL7M8W1IPk48eJCm7xS0AEQAJRCBBsANB7QANTQKmqaRDrkptAWFtggqARR6FQI2uhM1mgYBqSIAO5wqULuhQIgACbuskzsnGxJ6n74gjnokdq2ddAA9H0e3r4B0BXw1e5AA)
Here, when we say `let greeter: Greeter`, we‚Äôre using `Greeter` as the type of
instances of the class `Greeter`. This is almost second nature to programmers
from other object-oriented languages.
We‚Äôre also creating another value that we call the _constructor function_.
This is the function that is called when we `new` up instances of the class.
To see what this looks like in practice, let‚Äôs take a look at the JavaScript
created by the above example:
    ts
    let Greeter = (function () {
      function Greeter(message) {
        this.greeting = message;
      }
      Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
      };
      return Greeter;
    })();
    let greeter;
    greeter = new Greeter("world");
    console.log(greeter.greet()); // "Hello, world"
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgDiseJesoAvKABToCuAdsvAPZtMCUoAN4FQGdpx7lK1WIwC2eSJEwBzPAOGjR0ABbxIAOhXTo8NivqgFS1XgDcI0AF8CjilWg0DAB1hdo-gCe3nhGJpasHKaSjBqOopTQLLC8AEQAEnjY2FwANKCpoADUoLr6YR5mKg6iTg6Oicm87jIOTnyx9cSkxh40Dr0ylmx4AO5SfbKpo1yw2AAmqXwOiDyQXMQGOSqMg56wFSSxy6AgBZnZeaAzc4tAA)
Here, `let Greeter` is going to be assigned the constructor function. When we
call `new` and run this function, we get an instance of the class. The
constructor function also contains all of the static members of the class.
Another way to think of each class is that there is an _instance_ side and a
_static_ side.
Let‚Äôs modify the example a bit to show this difference:
    ts
    class Greeter {
      static standardGreeting = "Hello, there";
      greeting: string;
      greet() {
        if (this.greeting) {
          return "Hello, " + this.greeting;
        } else {
          return Greeter.standardGreeting;
        }
      }
    }
    let greeter1: Greeter;
    greeter1 = new Greeter();
    console.log(greeter1.greet()); // "Hello, there"
    let greeterMaker: typeof Greeter = Greeter;
    greeterMaker.standardGreeting = "Hey there!";
    let greeter2: Greeter = new greeterMaker();
    console.log(greeter2.greet()); // "Hey there!"
    let greeter3: Greeter;
    greeter3 = new Greeter();
    console.log(greeter3.greet()); // "Hey there!"
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDisee0esoA3gaKDJtEm9JgHYAmmWPyo1OvAOagAvKABEACTzZsAewA0oaAAt6eOQG4WoCdVrxJaGAklHWpsQAoAlE2Ot46UI53xIAOgdzSVdmVnDQamgAV1heeSUVDXlQAGotbT9As3EJO3CAX1BlfDcI1ijY+NFaen92ASERHIs891AC407OgmxaExz6AEY0GrpYIyDxoZlQXjwAd0pB2BcjRFVeSFU+-zUJRynh7KdnZwNQEATlNU0dPTkCXv6j2ABZTABrejRoAE8AA54VReMb0WZgiYEV4fb6weo8RrCMatWaKPB-DJ6ACEhiefWgAzE9AATKMVrN5ksYV96GsiJttrt9ocViSTrQXOdLmB0Zj7tRcfiXisAMzk4lQ16iymLZaS+kbLY7PB7VQHaUc6Bci5XPlYwVyIA)
In this example, `greeter1` works similarly to before. We instantiate the
`Greeter` class, and use this object. This we have seen before.
Next, we then use the class directly. Here we create a new variable called
`greeterMaker`. This variable will hold the class itself, or said another way
its constructor function. Here we use `typeof Greeter`, that is ‚Äúgive me the
type of the `Greeter` class itself‚Äù rather than the instance type. Or, more
precisely, ‚Äúgive me the type of the symbol called `Greeter`,‚Äù which is the
type of the constructor function. This type will contain all of the static
members of Greeter along with the constructor that creates instances of the
`Greeter` class. We show this by using `new` on `greeterMaker`, creating new
instances of `Greeter` and invoking them as before. It is also good to mention
that changing static property is frowned upon, here `greeter3` has `"Hey
there!"` instead of `"Hello, there"` on `standardGreeting`.
## Using a class as an interface
As we said in the previous section, a class declaration creates two things: a
type representing instances of the class and a constructor function. Because
classes create types, you can use them in the same places you would be able to
use interfaces.
    ts
    class Point {
      x: number;
      y: number;
    }
    interface Point3d extends Point {
      z: number;
    }
    let point3d: Point3d = { x: 1, y: 2, z: 3 };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgAKA9vAHbSgDeBooAHmrQK4C2ARnlgBuFqACenXgOEEAvgQJ1ogrIjyUa9AMwATUHjbLaO8tSVNRAL0n9BI+QWx4GAB03RdaM9r0BeJuxoAIwANOJoAExh1qBaoLJCQA)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Classes.md) ‚ù§
Contributors to this page:  
RC
DR
OT
NS
BW
25+
Last updated: Sep 16, 2024  
Was this page helpful?
# Compiler Options in MSBuild
## Overview
When you have an MSBuild based project which utilizes TypeScript such as an
ASP.NET Core project, you can configure TypeScript in two ways. Either via a
`tsconfig.json` or via the project settings.
## Using a `tsconfig.json`
We recommend using a `tsconfig.json` for your project when possible. To add
one to an existing project, add a new item to your project which is called a
‚ÄúTypeScript JSON Configuration File‚Äù in modern versions of Visual Studio.
The new `tsconfig.json` will then be used as the source of truth for
TypeScript-specific build information like files and configuration. You can
learn [about how TSConfigs works here](/docs/handbook/tsconfig-json.html) and
there is a [comprehensive reference here](/tsconfig).
## Using Project Settings
You can also define the configuration for TypeScript inside you project‚Äôs
settings. This is done by editing the XML in your `.csproj` to define
`PropertyGroups` which describe how the build can work:
    xml
    <PropertyGroup>
      <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>
      <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>
    </PropertyGroup>
There is a series of mappings for common TypeScript settings, these are
settings which map directly to [TypeScript cli
options](/docs/handbook/compiler-options.html) and are used to help you write
a more understandable project file. You can use the [TSConfig
reference](/tsconfig) to get more information on what values and defaults are
for each mapping.
### CLI Mappings
MSBuild Config Name | TSC Flag  
---|---  
`<TypeScriptAllowJS>` | `[--allowJs](/tsconfig/#allowJs)`  
Allow JavaScript files to be a part of your program. Use the `checkJS` option
to get errors from these files.  
`<TypeScriptRemoveComments>` | `[--removeComments](/tsconfig/#removeComments)`  
Disable emitting comments.  
`<TypeScriptNoImplicitAny>` | `[--noImplicitAny](/tsconfig/#noImplicitAny)`  
Enable error reporting for expressions and declarations with an implied `any`
type..  
`<TypeScriptGeneratesDeclarations>` | `[--declaration](/tsconfig/#declaration)`  
Generate .d.ts files from TypeScript and JavaScript files in your project.  
`<TypeScriptModuleKind>` | `[--module](/tsconfig/#module)`  
Specify what module code is generated.  
`<TypeScriptJSXEmit>` | `[--jsx](/tsconfig/#jsx)`  
Specify what JSX code is generated.  
`<TypeScriptOutDir>` | `[--outDir](/tsconfig/#outDir)`  
Specify an output folder for all emitted files.  
`<TypeScriptSourceMap>` | `[--sourcemap](/tsconfig/#sourcemap)`  
Create source map files for emitted JavaScript files.  
`<TypeScriptTarget>` | `[--target](/tsconfig/#target)`  
Set the JavaScript language version for emitted JavaScript and include
compatible library declarations.  
`<TypeScriptNoResolve>` | `[--noResolve](/tsconfig/#noResolve)`  
Disallow `import`s, `require`s or `<reference>`s from expanding the number of
files TypeScript should add to a project.  
`<TypeScriptMapRoot>` | `[--mapRoot](/tsconfig/#mapRoot)`  
Specify the location where debugger should locate map files instead of
generated locations.  
`<TypeScriptSourceRoot>` | `[--sourceRoot](/tsconfig/#sourceRoot)`  
Specify the root path for debuggers to find the reference source code.  
`<TypeScriptCharset>` | `[--charset](/tsconfig/#charset)`  
No longer supported. In early versions, manually set the text encoding for
reading files.  
`<TypeScriptEmitBOM>` | `[--emitBOM](/tsconfig/#emitBOM)`  
Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.  
`<TypeScriptNoLib>` | `[--noLib](/tsconfig/#noLib)`  
Disable including any library files, including the default lib.d.ts.  
`<TypeScriptPreserveConstEnums>` | `[--preserveConstEnums](/tsconfig/#preserveConstEnums)`  
Disable erasing `const enum` declarations in generated code.  
`<TypeScriptSuppressImplicitAnyIndexErrors>` | `[--suppressImplicitAnyIndexErrors](/tsconfig/#suppressImplicitAnyIndexErrors)`  
Suppress `noImplicitAny` errors when indexing objects that lack index
signatures.  
`<TypeScriptNoEmitHelpers>` | `[--noEmitHelpers](/tsconfig/#noEmitHelpers)`  
Disable generating custom helper functions like `__extends` in compiled
output.  
`<TypeScriptInlineSourceMap>` | `[--inlineSourceMap](/tsconfig/#inlineSourceMap)`  
Include sourcemap files inside the emitted JavaScript.  
`<TypeScriptInlineSources>` | `[--inlineSources](/tsconfig/#inlineSources)`  
Include source code in the sourcemaps inside the emitted JavaScript.  
`<TypeScriptNewLine>` | `[--newLine](/tsconfig/#newLine)`  
Set the newline character for emitting files.  
`<TypeScriptIsolatedModules>` | `[--isolatedModules](/tsconfig/#isolatedModules)`  
Ensure that each file can be safely transpiled without relying on other
imports.  
`<TypeScriptEmitDecoratorMetadata>` | `[--emitDecoratorMetadata](/tsconfig/#emitDecoratorMetadata)`  
Emit design-type metadata for decorated declarations in source files.  
`<TypeScriptRootDir>` | `[--rootDir](/tsconfig/#rootDir)`  
Specify the root folder within your source files.  
`<TypeScriptExperimentalDecorators>` | `[--experimentalDecorators](/tsconfig/#experimentalDecorators)`  
Enable experimental support for TC39 stage 2 draft decorators.  
`<TypeScriptModuleResolution>` | `[--moduleResolution](/tsconfig/#moduleResolution)`  
Specify how TypeScript looks up a file from a given module specifier.  
`<TypeScriptSuppressExcessPropertyErrors>` | `[--suppressExcessPropertyErrors](/tsconfig/#suppressExcessPropertyErrors)`  
Disable reporting of excess property errors during the creation of object
literals.  
`<TypeScriptReactNamespace>` | `[--reactNamespace](/tsconfig/#reactNamespace)`  
Specify the object invoked for `createElement`. This only applies when
targeting `react` JSX emit.  
`<TypeScriptSkipDefaultLibCheck>` | `[--skipDefaultLibCheck](/tsconfig/#skipDefaultLibCheck)`  
Skip type checking .d.ts files that are included with TypeScript.  
`<TypeScriptAllowUnusedLabels>` | `[--allowUnusedLabels](/tsconfig/#allowUnusedLabels)`  
Disable error reporting for unused labels.  
`<TypeScriptNoImplicitReturns>` | `[--noImplicitReturns](/tsconfig/#noImplicitReturns)`  
Enable error reporting for codepaths that do not explicitly return in a
function.  
`<TypeScriptNoFallthroughCasesInSwitch>` | `[--noFallthroughCasesInSwitch](/tsconfig/#noFallthroughCasesInSwitch)`  
Enable error reporting for fallthrough cases in switch statements.  
`<TypeScriptAllowUnreachableCode>` | `[--allowUnreachableCode](/tsconfig/#allowUnreachableCode)`  
Disable error reporting for unreachable code.  
`<TypeScriptForceConsistentCasingInFileNames>` | `[--forceConsistentCasingInFileNames](/tsconfig/#forceConsistentCasingInFileNames)`  
Ensure that casing is correct in imports.  
`<TypeScriptAllowSyntheticDefaultImports>` | `[--allowSyntheticDefaultImports](/tsconfig/#allowSyntheticDefaultImports)`  
Allow 'import x from y' when a module doesn't have a default export.  
`<TypeScriptNoImplicitUseStrict>` | `[--noImplicitUseStrict](/tsconfig/#noImplicitUseStrict)`  
Disable adding 'use strict' directives in emitted JavaScript files.  
`<TypeScriptLib>` | `[--lib](/tsconfig/#lib)`  
Specify a set of bundled library declaration files that describe the target
runtime environment.  
`<TypeScriptBaseUrl>` | `[--baseUrl](/tsconfig/#baseUrl)`  
Specify the base directory to resolve bare specifier module names.  
`<TypeScriptDeclarationDir>` | `[--declarationDir](/tsconfig/#declarationDir)`  
Specify the output directory for generated declaration files.  
`<TypeScriptNoImplicitThis>` | `[--noImplicitThis](/tsconfig/#noImplicitThis)`  
Enable error reporting when `this` is given the type `any`.  
`<TypeScriptSkipLibCheck>` | `[--skipLibCheck](/tsconfig/#skipLibCheck)`  
Skip type checking all .d.ts files.  
`<TypeScriptStrictNullChecks>` | `[--strictNullChecks](/tsconfig/#strictNullChecks)`  
When type checking, take into account `null` and `undefined`.  
`<TypeScriptNoUnusedLocals>` | `[--noUnusedLocals](/tsconfig/#noUnusedLocals)`  
Enable error reporting when a local variables aren't read.  
`<TypeScriptNoUnusedParameters>` | `[--noUnusedParameters](/tsconfig/#noUnusedParameters)`  
Raise an error when a function parameter isn't read  
`<TypeScriptAlwaysStrict>` | `[--alwaysStrict](/tsconfig/#alwaysStrict)`  
Ensure 'use strict' is always emitted.  
`<TypeScriptImportHelpers>` | `[--importHelpers](/tsconfig/#importHelpers)`  
Allow importing helper functions from tslib once per project, instead of
including them per-file.  
`<TypeScriptJSXFactory>` | `[--jsxFactory](/tsconfig/#jsxFactory)`  
Specify the JSX factory function used when targeting React JSX emit, e.g.
'React.createElement' or 'h'  
`<TypeScriptStripInternal>` | `[--stripInternal](/tsconfig/#stripInternal)`  
Disable emitting declarations that have `@internal` in their JSDoc comments.  
`<TypeScriptCheckJs>` | `[--checkJs](/tsconfig/#checkJs)`  
Enable error reporting in type-checked JavaScript files.  
`<TypeScriptDownlevelIteration>` | `[--downlevelIteration](/tsconfig/#downlevelIteration)`  
Emit more compliant, but verbose and less performant JavaScript for iteration.  
`<TypeScriptStrict>` | `[--strict](/tsconfig/#strict)`  
Enable all strict type checking options.  
`<TypeScriptNoStrictGenericChecks>` | `[--noStrictGenericChecks](/tsconfig/#noStrictGenericChecks)`  
Disable strict checking of generic signatures in function types.  
`<TypeScriptPreserveSymlinks>` | `[--preserveSymlinks](/tsconfig/#preserveSymlinks)`  
Disable resolving symlinks to their realpath. This correlates to the same flag
in node.  
`<TypeScriptStrictFunctionTypes>` | `[--strictFunctionTypes](/tsconfig/#strictFunctionTypes)`  
When assigning functions, check to ensure parameters and the return values are
subtype-compatible.  
`<TypeScriptStrictPropertyInitialization>` | `[--strictPropertyInitialization](/tsconfig/#strictPropertyInitialization)`  
Check for class properties that are declared but not set in the constructor.  
`<TypeScriptESModuleInterop>` | `[--esModuleInterop](/tsconfig/#esModuleInterop)`  
Emit additional JavaScript to ease support for importing CommonJS modules.
This enables `allowSyntheticDefaultImports` for type compatibility.  
`<TypeScriptEmitDeclarationOnly>` | `[--emitDeclarationOnly](/tsconfig/#emitDeclarationOnly)`  
Only output d.ts files and not JavaScript files.  
`<TypeScriptKeyofStringsOnly>` | `[--keyofStringsOnly](/tsconfig/#keyofStringsOnly)`  
Make keyof only return strings instead of string, numbers or symbols. Legacy
option.  
`<TypeScriptUseDefineForClassFields>` | `[--useDefineForClassFields](/tsconfig/#useDefineForClassFields)`  
Emit ECMAScript-standard-compliant class fields.  
`<TypeScriptDeclarationMap>` | `[--declarationMap](/tsconfig/#declarationMap)`  
Create sourcemaps for d.ts files.  
`<TypeScriptResolveJsonModule>` | `[--resolveJsonModule](/tsconfig/#resolveJsonModule)`  
Enable importing .json files  
`<TypeScriptStrictBindCallApply>` | `[--strictBindCallApply](/tsconfig/#strictBindCallApply)`  
Check that the arguments for `bind`, `call`, and `apply` methods match the
original function.  
`<TypeScriptNoEmitOnError>` | `[--noEmitOnError](/tsconfig/#noEmitOnError)`  
Disable emitting files if any type checking errors are reported.  
### Additional Flags
Because the MSBuild system passes arguments directly to the TypeScript CLI,
you can use the option `TypeScriptAdditionalFlags` to provide specific flags
which don‚Äôt have a mapping above.
For example, this would turn on
[`noPropertyAccessFromIndexSignature`](/tsconfig#noPropertyAccessFromIndexSignature):
    xml
    <TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>
### Debug and Release Builds
You can use PropertyGroup conditions to define different sets of
configurations. For example, a common task is stripping comments and
sourcemaps in production. In this example, we define a debug and release
property group which have different TypeScript configurations:
    xml
    <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
      <TypeScriptRemoveComments>false</TypeScriptRemoveComments>
      <TypeScriptSourceMap>true</TypeScriptSourceMap>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Configuration)' == 'Release'">
      <TypeScriptRemoveComments>true</TypeScriptRemoveComments>
      <TypeScriptSourceMap>false</TypeScriptSourceMap>
    </PropertyGroup>
    <Import
        Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
        Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" />
### ToolsVersion
The value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property
in the project file identifies the compiler version to use to build (1.7 in
this example). This allows a project to build against the same versions of the
compiler on different machines.
If `TypeScriptToolsVersion` is not specified, the latest compiler version
installed on the machine will be used to build.
Users using newer versions of TS, will see a prompt to upgrade their project
on first load.
### TypeScriptCompileBlocked
If you are using a different build tool to build your project (e.g. gulp,
grunt , etc.) and VS for the development and debugging experience, set
`<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project.
This should give you all the editing support, but not the build when you hit
F5.
### TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)
By default, MSBuild will attempt to only run the TypeScript compiler when the
project‚Äôs source files have been updated since the last compilation. However,
if this behavior is causing issues, such as when TypeScript‚Äôs
[`incremental`](/tsconfig#incremental) option is enabled, set
`<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>`
to ensure the TypeScript compiler is invoked with every run of MSBuild.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Compiler Options
in MSBuild.md) ‚ù§
Contributors to this page:  
MH
OT
Y
DR
BL
13+
Last updated: Sep 16, 2024  
Was this page helpful?
# tsc CLI Options
## Using the CLI
Running `tsc` locally will compile the closest project defined by a
`tsconfig.json`, or you can compile a set of TypeScript files by passing in a
glob of files you want. When input files are specified on the command line,
`tsconfig.json` files are ignored.
    sh
    # Run a compile based on a backwards look through the fs for a tsconfig.json
    tsc
    # Emit JS for just the index.ts with the compiler defaults
    tsc index.ts
    # Emit JS for any .ts files in the folder src, with the default settings
    tsc src/*.ts
    # Emit files referenced in with the compiler settings from tsconfig.production.json
    tsc --project tsconfig.production.json
    # Emit d.ts files for a js file with showing compiler options which are booleans
    tsc index.js --declaration --emitDeclarationOnly
    # Emit a single .js file from two files via compiler options which take string arguments
    tsc app.ts util.ts --target esnext --outfile index.js
## Compiler Options
**If you‚Äôre looking for more information about the compiler options in a
tsconfig, check out the[TSConfig Reference](/tsconfig)**
### CLI Commands
Flag | Type  
---|---  
`--all` | `boolean`  
Show all compiler options.  
`--help` | `boolean`  
Gives local information for help on the CLI.  
`--init` | `boolean`  
Initializes a TypeScript project and creates a tsconfig.json file.  
`--listFilesOnly` | `boolean`  
Print names of files that are part of the compilation and then stop
processing.  
`--locale` | `string`  
Set the language of the messaging from TypeScript. This does not affect emit.  
`--project` | `string`  
Compile the project given the path to its configuration file, or to a folder
with a 'tsconfig.json'.  
`--showConfig` | `boolean`  
Print the final configuration instead of building.  
`--version` | `boolean`  
Print the compiler's version.  
### Build Options
Flag | Type  
---|---  
`--build` | `boolean`  
Build one or more projects and their dependencies, if out of date  
`--clean` | `boolean`  
Delete the outputs of all projects.  
`--dry` | `boolean`  
Show what would be built (or deleted, if specified with '--clean')  
`[--force](/tsconfig/#force)` | `boolean`  
Build all projects, including those that appear to be up to date.  
`[--verbose](/tsconfig/#verbose)` | `boolean`  
Enable verbose logging.  
### Watch Options
Flag | Type  
---|---  
`[--excludeDirectories](/tsconfig/#excludeDirectories)` | `list`  
Remove a list of directories from the watch process.  
`[--excludeFiles](/tsconfig/#excludeFiles)` | `list`  
Remove a list of files from the watch mode's processing.  
`[--fallbackPolling](/tsconfig/#fallbackPolling)` | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize`  
Specify what approach the watcher should use if the system runs out of native
file watchers.  
`[--synchronousWatchDirectory](/tsconfig/#synchronousWatchDirectory)` | `boolean`  
Synchronously call callbacks and update the state of directory watchers on
platforms that don`t support recursive watching natively.  
`--watch` | `boolean`  
Watch input files.  
`[--watchDirectory](/tsconfig/#watchDirectory)` | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling`  
Specify how directories are watched on systems that lack recursive file-
watching functionality.  
`[--watchFile](/tsconfig/#watchFile)` | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory`  
Specify how the TypeScript watch mode works.  
### Compiler Flags
Flag | Type | Default  
---|---|---  
`[--allowArbitraryExtensions](/tsconfig/#allowArbitraryExtensions)` | `boolean` | `false`  
Enable importing files with any extension, provided a declaration file is
present.  
`[--allowImportingTsExtensions](/tsconfig/#allowImportingTsExtensions)` | `boolean` | `false`  
Allow imports to include TypeScript file extensions.  
`[--allowJs](/tsconfig/#allowJs)` | `boolean` | `false`  
Allow JavaScript files to be a part of your program. Use the `checkJS` option
to get errors from these files.  
`[--allowSyntheticDefaultImports](/tsconfig/#allowSyntheticDefaultImports)` | `boolean` | `true` if `esModuleInterop` is enabled, `module` is `system`, or `moduleResolution` is `bundler`; `false` otherwise.  
Allow 'import x from y' when a module doesn't have a default export.  
`[--allowUmdGlobalAccess](/tsconfig/#allowUmdGlobalAccess)` | `boolean` | `false`  
Allow accessing UMD globals from modules.  
`[--allowUnreachableCode](/tsconfig/#allowUnreachableCode)` | `boolean` |   
Disable error reporting for unreachable code.  
`[--allowUnusedLabels](/tsconfig/#allowUnusedLabels)` | `boolean` |   
Disable error reporting for unused labels.  
`[--alwaysStrict](/tsconfig/#alwaysStrict)` | `boolean` | `true` if `strict`; `false` otherwise.  
Ensure 'use strict' is always emitted.  
`[--assumeChangesOnlyAffectDirectDependencies](/tsconfig/#assumeChangesOnlyAffectDirectDependencies)` | `boolean` | `false`  
Have recompiles in projects that use `incremental` and `watch` mode assume
that changes within a file will only affect files directly depending on it.  
`[--baseUrl](/tsconfig/#baseUrl)` | `string` |   
Specify the base directory to resolve bare specifier module names.  
`[--charset](/tsconfig/#charset)` | `string` | `utf8`  
No longer supported. In early versions, manually set the text encoding for
reading files.  
`[--checkJs](/tsconfig/#checkJs)` | `boolean` | `false`  
Enable error reporting in type-checked JavaScript files.  
`[--composite](/tsconfig/#composite)` | `boolean` | `false`  
Enable constraints that allow a TypeScript project to be used with project
references.  
`[--customConditions](/tsconfig/#customConditions)` | `list` |   
Conditions to set in addition to the resolver-specific defaults when resolving
imports.  
`[--declaration](/tsconfig/#declaration)` | `boolean` | `true` if `composite`; `false` otherwise.  
Generate .d.ts files from TypeScript and JavaScript files in your project.  
`[--declarationDir](/tsconfig/#declarationDir)` | `string` |   
Specify the output directory for generated declaration files.  
`[--declarationMap](/tsconfig/#declarationMap)` | `boolean` | `false`  
Create sourcemaps for d.ts files.  
`[--diagnostics](/tsconfig/#diagnostics)` | `boolean` | `false`  
Output compiler performance information after building.  
`[--disableReferencedProjectLoad](/tsconfig/#disableReferencedProjectLoad)` | `boolean` | `false`  
Reduce the number of projects loaded automatically by TypeScript.  
`[--disableSizeLimit](/tsconfig/#disableSizeLimit)` | `boolean` | `false`  
Remove the 20mb cap on total source code size for JavaScript files in the
TypeScript language server.  
`[--disableSolutionSearching](/tsconfig/#disableSolutionSearching)` | `boolean` | `false`  
Opt a project out of multi-project reference checking when editing.  
`[--disableSourceOfProjectReferenceRedirect](/tsconfig/#disableSourceOfProjectReferenceRedirect)` | `boolean` | `false`  
Disable preferring source files instead of declaration files when referencing
composite projects.  
`[--downlevelIteration](/tsconfig/#downlevelIteration)` | `boolean` | `false`  
Emit more compliant, but verbose and less performant JavaScript for iteration.  
`[--emitBOM](/tsconfig/#emitBOM)` | `boolean` | `false`  
Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.  
`[--emitDeclarationOnly](/tsconfig/#emitDeclarationOnly)` | `boolean` | `false`  
Only output d.ts files and not JavaScript files.  
`[--emitDecoratorMetadata](/tsconfig/#emitDecoratorMetadata)` | `boolean` | `false`  
Emit design-type metadata for decorated declarations in source files.  
`[--esModuleInterop](/tsconfig/#esModuleInterop)` | `boolean` | `true` if `module` is `node16` or `nodenext`; `false` otherwise.  
Emit additional JavaScript to ease support for importing CommonJS modules.
This enables `allowSyntheticDefaultImports` for type compatibility.  
`[--exactOptionalPropertyTypes](/tsconfig/#exactOptionalPropertyTypes)` | `boolean` | `false`  
Interpret optional property types as written, rather than adding `undefined`.  
`[--experimentalDecorators](/tsconfig/#experimentalDecorators)` | `boolean` | `false`  
Enable experimental support for TC39 stage 2 draft decorators.  
`[--explainFiles](/tsconfig/#explainFiles)` | `boolean` | `false`  
Print files read during the compilation including why it was included.  
`[--extendedDiagnostics](/tsconfig/#extendedDiagnostics)` | `boolean` | `false`  
Output more detailed compiler performance information after building.  
`[--forceConsistentCasingInFileNames](/tsconfig/#forceConsistentCasingInFileNames)` | `boolean` | `true`  
Ensure that casing is correct in imports.  
`[--generateCpuProfile](/tsconfig/#generateCpuProfile)` | `string` | `profile.cpuprofile`  
Emit a v8 CPU profile of the compiler run for debugging.  
`[--generateTrace](/tsconfig/#generateTrace)` | `string` |   
Generates an event trace and a list of types.  
`[--importHelpers](/tsconfig/#importHelpers)` | `boolean` | `false`  
Allow importing helper functions from tslib once per project, instead of
including them per-file.  
`[--importsNotUsedAsValues](/tsconfig/#importsNotUsedAsValues)` | `remove`, `preserve`, or `error` | `remove`  
Specify emit/checking behavior for imports that are only used for types.  
`[--incremental](/tsconfig/#incremental)` | `boolean` | `true` if `composite`; `false` otherwise.  
Save .tsbuildinfo files to allow for incremental compilation of projects.  
`[--inlineSourceMap](/tsconfig/#inlineSourceMap)` | `boolean` | `false`  
Include sourcemap files inside the emitted JavaScript.  
`[--inlineSources](/tsconfig/#inlineSources)` | `boolean` | `false`  
Include source code in the sourcemaps inside the emitted JavaScript.  
`[--isolatedDeclarations](/tsconfig/#isolatedDeclarations)` | `boolean` | `false`  
Require sufficient annotation on exports so other tools can trivially generate
declaration files.  
`[--isolatedModules](/tsconfig/#isolatedModules)` | `boolean` | `true` if `verbatimModuleSyntax`; `false` otherwise.  
Ensure that each file can be safely transpiled without relying on other
imports.  
`[--jsx](/tsconfig/#jsx)` | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev` |   
Specify what JSX code is generated.  
`[--jsxFactory](/tsconfig/#jsxFactory)` | `string` | `React.createElement`  
Specify the JSX factory function used when targeting React JSX emit, e.g.
'React.createElement' or 'h'.  
`[--jsxFragmentFactory](/tsconfig/#jsxFragmentFactory)` | `string` | `React.Fragment`  
Specify the JSX Fragment reference used for fragments when targeting React JSX
emit e.g. 'React.Fragment' or 'Fragment'.  
`[--jsxImportSource](/tsconfig/#jsxImportSource)` | `string` | `react`  
Specify module specifier used to import the JSX factory functions when using
`jsx: react-jsx*`.  
`[--keyofStringsOnly](/tsconfig/#keyofStringsOnly)` | `boolean` | `false`  
Make keyof only return strings instead of string, numbers or symbols. Legacy
option.  
`[--lib](/tsconfig/#lib)` | `list` |   
Specify a set of bundled library declaration files that describe the target
runtime environment.  
`[--listEmittedFiles](/tsconfig/#listEmittedFiles)` | `boolean` | `false`  
Print the names of emitted files after a compilation.  
`[--listFiles](/tsconfig/#listFiles)` | `boolean` | `false`  
Print all of the files read during the compilation.  
`[--mapRoot](/tsconfig/#mapRoot)` | `string` |   
Specify the location where debugger should locate map files instead of
generated locations.  
`[--maxNodeModuleJsDepth](/tsconfig/#maxNodeModuleJsDepth)` | `number` | `0`  
Specify the maximum folder depth used for checking JavaScript files from
`node_modules`. Only applicable with `allowJs`.  
`[--module](/tsconfig/#module)` | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `nodenext`, or `preserve` | `CommonJS` if `target` is `ES5`; `ES6`/`ES2015` otherwise.  
Specify what module code is generated.  
`[--moduleDetection](/tsconfig/#moduleDetection)` | `legacy`, `auto`, or `force` | "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.  
Specify what method is used to detect whether a file is a script or a module.  
`[--moduleResolution](/tsconfig/#moduleResolution)` | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler` | `Classic` if `module` is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if `module` is `node16` or `nodenext`; `Node` otherwise.  
Specify how TypeScript looks up a file from a given module specifier.  
`[--moduleSuffixes](/tsconfig/#moduleSuffixes)` | `list` |   
List of file name suffixes to search when resolving a module.  
`[--newLine](/tsconfig/#newLine)` | `crlf` or `lf` | `lf`  
Set the newline character for emitting files.  
`[--noCheck](/tsconfig/#noCheck)` | `boolean` | `false`  
Disable full type checking (only critical parse and emit errors will be
reported).  
`[--noEmit](/tsconfig/#noEmit)` | `boolean` | `false`  
Disable emitting files from a compilation.  
`[--noEmitHelpers](/tsconfig/#noEmitHelpers)` | `boolean` | `false`  
Disable generating custom helper functions like `__extends` in compiled
output.  
`[--noEmitOnError](/tsconfig/#noEmitOnError)` | `boolean` | `false`  
Disable emitting files if any type checking errors are reported.  
`[--noErrorTruncation](/tsconfig/#noErrorTruncation)` | `boolean` | `false`  
Disable truncating types in error messages.  
`[--noFallthroughCasesInSwitch](/tsconfig/#noFallthroughCasesInSwitch)` | `boolean` | `false`  
Enable error reporting for fallthrough cases in switch statements.  
`[--noImplicitAny](/tsconfig/#noImplicitAny)` | `boolean` | `true` if `strict`; `false` otherwise.  
Enable error reporting for expressions and declarations with an implied `any`
type.  
`[--noImplicitOverride](/tsconfig/#noImplicitOverride)` | `boolean` | `false`  
Ensure overriding members in derived classes are marked with an override
modifier.  
`[--noImplicitReturns](/tsconfig/#noImplicitReturns)` | `boolean` | `false`  
Enable error reporting for codepaths that do not explicitly return in a
function.  
`[--noImplicitThis](/tsconfig/#noImplicitThis)` | `boolean` | `true` if `strict`; `false` otherwise.  
Enable error reporting when `this` is given the type `any`.  
`[--noImplicitUseStrict](/tsconfig/#noImplicitUseStrict)` | `boolean` | `false`  
Disable adding 'use strict' directives in emitted JavaScript files.  
`[--noLib](/tsconfig/#noLib)` | `boolean` | `false`  
Disable including any library files, including the default lib.d.ts.  
`[--noPropertyAccessFromIndexSignature](/tsconfig/#noPropertyAccessFromIndexSignature)` | `boolean` | `false`  
Enforces using indexed accessors for keys declared using an indexed type.  
`[--noResolve](/tsconfig/#noResolve)` | `boolean` | `false`  
Disallow `import`s, `require`s or `<reference>`s from expanding the number of
files TypeScript should add to a project.  
`[--noStrictGenericChecks](/tsconfig/#noStrictGenericChecks)` | `boolean` | `false`  
Disable strict checking of generic signatures in function types.  
`[--noUncheckedIndexedAccess](/tsconfig/#noUncheckedIndexedAccess)` | `boolean` | `false`  
Add `undefined` to a type when accessed using an index.  
`[--noUncheckedSideEffectImports](/tsconfig/#noUncheckedSideEffectImports)` | `boolean` | `false`  
Check side effect imports.  
`[--noUnusedLocals](/tsconfig/#noUnusedLocals)` | `boolean` | `false`  
Enable error reporting when local variables aren't read.  
`[--noUnusedParameters](/tsconfig/#noUnusedParameters)` | `boolean` | `false`  
Raise an error when a function parameter isn't read.  
`[--out](/tsconfig/#out)` | `string` |   
Deprecated setting. Use `outFile` instead.  
`[--outDir](/tsconfig/#outDir)` | `string` |   
Specify an output folder for all emitted files.  
`[--outFile](/tsconfig/#outFile)` | `string` |   
Specify a file that bundles all outputs into one JavaScript file. If
`declaration` is true, also designates a file that bundles all .d.ts output.  
`[--paths](/tsconfig/#paths)` | `object` |   
Specify a set of entries that re-map imports to additional lookup locations.  
`[--plugins](/tsconfig/#plugins)` | `list` |   
Specify a list of language service plugins to include.  
`[--preserveConstEnums](/tsconfig/#preserveConstEnums)` | `boolean` | `true` if `isolatedModules`; `false` otherwise.  
Disable erasing `const enum` declarations in generated code.  
`[--preserveSymlinks](/tsconfig/#preserveSymlinks)` | `boolean` | `false`  
Disable resolving symlinks to their realpath. This correlates to the same flag
in node.  
`[--preserveValueImports](/tsconfig/#preserveValueImports)` | `boolean` | `false`  
Preserve unused imported values in the JavaScript output that would otherwise
be removed.  
`[--preserveWatchOutput](/tsconfig/#preserveWatchOutput)` | `boolean` | `false`  
Disable wiping the console in watch mode.  
`[--pretty](/tsconfig/#pretty)` | `boolean` | `true`  
Enable color and formatting in TypeScript's output to make compiler errors
easier to read.  
`[--reactNamespace](/tsconfig/#reactNamespace)` | `string` | `React`  
Specify the object invoked for `createElement`. This only applies when
targeting `react` JSX emit.  
`[--removeComments](/tsconfig/#removeComments)` | `boolean` | `false`  
Disable emitting comments.  
`[--resolveJsonModule](/tsconfig/#resolveJsonModule)` | `boolean` | `false`  
Enable importing .json files.  
`[--resolvePackageJsonExports](/tsconfig/#resolvePackageJsonExports)` | `boolean` | `true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`; otherwise `false`  
Use the package.json 'exports' field when resolving package imports.  
`[--resolvePackageJsonImports](/tsconfig/#resolvePackageJsonImports)` | `boolean` | `true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`; otherwise `false`  
Use the package.json 'imports' field when resolving imports.  
`[--rootDir](/tsconfig/#rootDir)` | `string` | Computed from the list of input files.  
Specify the root folder within your source files.  
`[--rootDirs](/tsconfig/#rootDirs)` | `list` | Computed from the list of input files.  
Allow multiple folders to be treated as one when resolving modules.  
`[--skipDefaultLibCheck](/tsconfig/#skipDefaultLibCheck)` | `boolean` | `false`  
Skip type checking .d.ts files that are included with TypeScript.  
`[--skipLibCheck](/tsconfig/#skipLibCheck)` | `boolean` | `false`  
Skip type checking all .d.ts files.  
`[--sourceMap](/tsconfig/#sourceMap)` | `boolean` | `false`  
Create source map files for emitted JavaScript files.  
`[--sourceRoot](/tsconfig/#sourceRoot)` | `string` |   
Specify the root path for debuggers to find the reference source code.  
`[--stopBuildOnErrors](/tsconfig/#stopBuildOnErrors)` | `boolean` |   
Skip building downstream projects on error in upstream project.  
`[--strict](/tsconfig/#strict)` | `boolean` | `false`  
Enable all strict type-checking options.  
`[--strictBindCallApply](/tsconfig/#strictBindCallApply)` | `boolean` | `true` if `strict`; `false` otherwise.  
Check that the arguments for `bind`, `call`, and `apply` methods match the
original function.  
`[--strictBuiltinIteratorReturn](/tsconfig/#strictBuiltinIteratorReturn)` | `boolean` | `false`, unless `strict` is set  
Built-in iterators are instantiated with a TReturn type of undefined instead
of any.  
`[--strictFunctionTypes](/tsconfig/#strictFunctionTypes)` | `boolean` | `true` if `strict`; `false` otherwise.  
When assigning functions, check to ensure parameters and the return values are
subtype-compatible.  
`[--strictNullChecks](/tsconfig/#strictNullChecks)` | `boolean` | `true` if `strict`; `false` otherwise.  
When type checking, take into account `null` and `undefined`.  
`[--strictPropertyInitialization](/tsconfig/#strictPropertyInitialization)` | `boolean` | `true` if `strict`; `false` otherwise.  
Check for class properties that are declared but not set in the constructor.  
`[--stripInternal](/tsconfig/#stripInternal)` | `boolean` | `false`  
Disable emitting declarations that have `@internal` in their JSDoc comments.  
`[--suppressExcessPropertyErrors](/tsconfig/#suppressExcessPropertyErrors)` | `boolean` | `false`  
Disable reporting of excess property errors during the creation of object
literals.  
`[--suppressImplicitAnyIndexErrors](/tsconfig/#suppressImplicitAnyIndexErrors)` | `boolean` | `false`  
Suppress `noImplicitAny` errors when indexing objects that lack index
signatures.  
`[--target](/tsconfig/#target)` | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, or `esnext` | `ES5`  
Set the JavaScript language version for emitted JavaScript and include
compatible library declarations.  
`[--traceResolution](/tsconfig/#traceResolution)` | `boolean` | `false`  
Log paths used during the `moduleResolution` process.  
`[--tsBuildInfoFile](/tsconfig/#tsBuildInfoFile)` | `string` | `.tsbuildinfo`  
The file to store `.tsbuildinfo` incremental build information in.  
`[--typeRoots](/tsconfig/#typeRoots)` | `list` |   
Specify multiple folders that act like `./node_modules/@types`.  
`[--types](/tsconfig/#types)` | `list` |   
Specify type package names to be included without being referenced in a source
file.  
`[--useDefineForClassFields](/tsconfig/#useDefineForClassFields)` | `boolean` | `true` if `target` is `ES2022` or higher, including `ESNext`; `false` otherwise.  
Emit ECMAScript-standard-compliant class fields.  
`[--useUnknownInCatchVariables](/tsconfig/#useUnknownInCatchVariables)` | `boolean` | `true` if `strict`; `false` otherwise.  
Default catch clause variables as `unknown` instead of `any`.  
`[--verbatimModuleSyntax](/tsconfig/#verbatimModuleSyntax)` | `boolean` | `false`  
Do not transform or elide any imports or exports not marked as type-only,
ensuring they are written in the output file's format based on the 'module'
setting.  
## Related
  * Every option is fully explained in the [TSConfig Reference](/tsconfig).
  * Learn how to use a [`tsconfig.json`](/docs/handbook/tsconfig-json.html) file.
  * Learn how to work in an [MSBuild project](/docs/handbook/compiler-options-in-msbuild.html).
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Compiler
Options.md) ‚ù§
Contributors to this page:  
MH
OT
DR
AD
AG
62+
Last updated: Sep 16, 2024  
Was this page helpful?
# Configuring Watch
As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration
which controls how it watches files and directories. Prior to this version,
configuration required the use of environment variables which are still
available.
## Background
The `--watch` implementation of the compiler relies on Node‚Äôs `fs.watch` and
`fs.watchFile`. Each of these methods has pros and cons.
`fs.watch` relies on file system events to broadcast changes in the watched
files and directories. The implementation of this command is OS dependent and
unreliable - on many operating systems, it does not work as expected.
Additionally, some operating systems limit the number of watches which can
exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-
pages/man7/inotify.7.html)). Heavy use of `fs.watch` in large codebases has
the potential to exceed these limits and result in undesirable behavior.
However, because this implementation relies on an events-based model, CPU use
is comparatively light. The compiler typically uses `fs.watch` to watch
directories (e.g. source directories included by compiler configuration files
and directories in which module resolution failed, among others). TypeScript
uses these to augment potential failures in individual file watchers. However,
there is a key limitation of this strategy: recursive watching of directories
is supported on Windows and macOS, but not on Linux. This suggested a need for
additional strategies for file and directory watching.
`fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile`
is by far the most reliable mechanism available to subscribe to the events
from files and directories of interest. Under this strategy, the TypeScript
compiler typically uses `fs.watchFile` to watch source files, config files,
and files which appear missing based on reference statements. This means that
the degree to which CPU usage will be higher when using `fs.watchFile` depends
directly on number of files watched in the codebase.
## Configuring file watching using a `tsconfig.json`
The suggested method of configuring watch behavior is through the new
`watchOptions` section of `tsconfig.json`. We provide an example configuration
below. See the following section for detailed descriptions of the settings
available.
    {
      // Some typical compiler options
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2020",
        "[moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution)": "node"
        // ...
      },
      // NEW: Options for file/directory watching
      "watchOptions": {
        // Use native file system events for files and directories
        "[watchFile](https://www.typescriptlang.org/tsconfig#watchFile)": "useFsEvents",
        "[watchDirectory](https://www.typescriptlang.org/tsconfig#watchDirectory)": "useFsEvents",
        // Poll files for updates more frequently
        // when they're updated a lot.
        "[fallbackPolling](https://www.typescriptlang.org/tsconfig#fallbackPolling)": "dynamicPriority",
        // Don't coalesce watch notification
        "[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory)": true,
        // Finally, two additional settings for reducing the amount of possible
        // files to track  work from these directories
        "[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories)": ["**/node_modules", "_build"],
        "[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles)": ["build/fileWhichChangesOften.ts"]
      }
    }
For further details, see [the release notes for Typescript
3.8](/docs/handbook/release-notes/typescript-3-8.html#better-directory-
watching-on-linux-and-watchoptions).
## Configuring file watching using environment variable `TSC_WATCHFILE`
Option | Description  
---|---  
`PriorityPollingInterval` | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files  
`DynamicPriorityPolling` | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently  
`UseFsEvents` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created.  
`UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`)  
`UseFsEventsOnParentDirectory` | Use `fs.watch` on the _parent_ directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy).  
default (no value specified) | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file.  
## Configuring directory watching using environment variable
`TSC_WATCHDIRECTORY`
For directory watches on platforms which don‚Äôt natively allow recursive
directory watching (i.e. non macOS and Windows operating systems) is supported
through recursively creating directory watchers for each child directory using
different options selected by `TSC_WATCHDIRECTORY`.
**NOTE:** On platforms which support native recursive directory watching, the
value of `TSC_WATCHDIRECTORY` is ignored.
Option | Description  
---|---  
`RecursiveDirectoryUsingFsWatchFile` | Use `fs.watchFile` to watch included directories and child directories.  
`RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories.  
default (no value specified) | Use `fs.watch` to watch included directories and child directories.  
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Configuring
Watch.md) ‚ù§
Contributors to this page:  
SN
OT
BS
JM
IO
8+
Last updated: Sep 16, 2024  
Was this page helpful?
# Declaration Reference
The purpose of this guide is to teach you how to write a high-quality
definition file. This guide is structured by showing documentation for some
API, along with sample usage of that API, and explaining how to write the
corresponding declaration.
These examples are ordered in approximately increasing order of complexity.
## Objects with Properties
_Documentation_
> The global variable `myLib` has a function `makeGreeting` for creating
> greetings, and a property `numberOfGreetings` indicating the number of
> greetings made so far.
_Code_
    ts
    let result = myLib.makeGreeting("hello, world");
    console.log("The computed greeting is:" + result);
    let count = myLib.numberOfGreetings;
_Declaration_
Use `declare namespace` to describe types or values accessed by dotted
notation.
    ts
    declare namespace myLib {
      function makeGreeting(s: string): string;
      let numberOfGreetings: number;
    }
## Overloaded Functions
_Documentation_
The `getWidget` function accepts a number and returns a Widget, or accepts a
string and returns a Widget array.
_Code_
    ts
    let x: Widget = getWidget(43);
    let arr: Widget[] = getWidget("all of them");
_Declaration_
    ts
    declare function getWidget(n: number): Widget;
    declare function getWidget(s: string): Widget[];
## Reusable Types (Interfaces)
_Documentation_
> When specifying a greeting, you must pass a `GreetingSettings` object. This
> object has the following properties:
>
> 1 - greeting: Mandatory string
>
> 2 - duration: Optional length of time (in milliseconds)
>
> 3 - color: Optional string, e.g. ‚Äò#ff00ff‚Äô
_Code_
    ts
    greet({
      greeting: "hello world",
      duration: 4000
    });
_Declaration_
Use an `interface` to define a type with properties.
    ts
    interface GreetingSettings {
      greeting: string;
      duration?: number;
      color?: string;
    }
    declare function greet(setting: GreetingSettings): void;
## Reusable Types (Type Aliases)
_Documentation_
> Anywhere a greeting is expected, you can provide a `string`, a function
> returning a `string`, or a `Greeter` instance.
_Code_
    ts
    function getGreeting() {
      return "howdy";
    }
    class MyGreeter extends Greeter {}
    greet("hello");
    greet(getGreeting);
    greet(new MyGreeter());
_Declaration_
You can use a type alias to make a shorthand for a type:
    ts
    type GreetingLike = string | (() => string) | MyGreeter;
    declare function greet(g: GreetingLike): void;
## Organizing Types
_Documentation_
> The `greeter` object can log to a file or display an alert. You can provide
> LogOptions to `.log(...)` and alert options to `.alert(...)`
_Code_
    ts
    const g = new Greeter("Hello");
    g.log({ verbose: true });
    g.alert({ modal: false, title: "Current Greeting" });
_Declaration_
Use namespaces to organize types.
    ts
    declare namespace GreetingLib {
      interface LogOptions {
        verbose?: boolean;
      }
      interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
      }
    }
You can also create nested namespaces in one declaration:
    ts
    declare namespace GreetingLib.Options {
      // Refer to via GreetingLib.Options.Log
      interface Log {
        verbose?: boolean;
      }
      interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
      }
    }
## Classes
_Documentation_
> You can create a greeter by instantiating the `Greeter` object, or create a
> customized greeter by extending from it.
_Code_
    ts
    const myGreeter = new Greeter("hello, world");
    myGreeter.greeting = "howdy";
    myGreeter.showGreeting();
    class SpecialGreeter extends Greeter {
      constructor() {
        super("Very special greetings");
      }
    }
_Declaration_
Use `declare class` to describe a class or class-like object. Classes can have
properties and methods as well as a constructor.
    ts
    declare class Greeter {
      constructor(greeting: string);
      greeting: string;
      showGreeting(): void;
    }
## Global Variables
_Documentation_
> The global variable `foo` contains the number of widgets present.
_Code_
    ts
    console.log("Half the number of widgets is " + foo / 2);
_Declaration_
Use `declare var` to declare variables. If the variable is read-only, you can
use `declare const`. You can also use `declare let` if the variable is block-
scoped.
    ts
    /** The number of widgets present */
    declare var foo: number;
## Global Functions
_Documentation_
> You can call the function `greet` with a string to show a greeting to the
> user.
_Code_
    ts
    greet("hello, world");
_Declaration_
Use `declare function` to declare functions.
    ts
    declare function greet(greeting: string): void;
### [IntroductionHow to write a high-quality TypeScript Declaration (d.ts)
file](/docs/handbook/declaration-files/introduction.html)
### [Library StructuresHow to structure your d.ts
files](/docs/handbook/declaration-files/library-structures.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/By
Example.md) ‚ù§
Contributors to this page:  
MH
OT
Y
PB
RK
7+
Last updated: Sep 16, 2024  
Was this page helpful?
# Consumption
## Downloading
Getting type declarations requires no tools apart from npm.
As an example, getting the declarations for a library like lodash takes
nothing more than the following command
    cmd
    npm install --save-dev @types/lodash
It is worth noting that if the npm package already includes its declaration
file as described in [Publishing](/docs/handbook/declaration-
files/publishing.html), downloading the corresponding `@types` package is not
needed.
## Consuming
From there you‚Äôll be able to use lodash in your TypeScript code with no fuss.
This works for both modules and global code.
For example, once you‚Äôve `npm install`-ed your type declarations, you can use
imports and write
    ts
    import * as _ from "lodash";
    _.padStart("Hello TypeScript!", 20, " ");
or if you‚Äôre not using modules, you can just use the global variable `_`.
    ts
    _.padStart("Hello TypeScript!", 20, " ");
## Searching
For the most part, type declaration packages should always have the same name
as the package name on `npm`, but prefixed with `@types/`, but if you need,
you can use the [Yarn package search](https://yarnpkg.com/) to find the
package for your favorite library.
> Note: if the declaration file you are searching for is not present, you can
> always contribute one back and help out the next developer looking for it.
> Please see the DefinitelyTyped [contribution guidelines
> page](https://definitelytyped.org/guides/contributing.html) for details.
### [PublishingHow to get your d.ts files to
users](/docs/handbook/declaration-files/publishing.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Consumption.md) ‚ù§
Contributors to this page:  
MH
OT
IO
KO
EB
5+
Last updated: Sep 16, 2024  
Was this page helpful?
# Deep Dive
## Declaration File Theory: A Deep Dive
Structuring modules to give the exact API shape you want can be tricky. For
example, we might want a module that can be invoked with or without `new` to
produce different types, has a variety of named types exposed in a hierarchy,
and has some properties on the module object as well.
By reading this guide, you‚Äôll have the tools to write complex declaration
files that expose a friendly API surface. This guide focuses on module (or
UMD) libraries because the options here are more varied.
## Key Concepts
You can fully understand how to make any shape of declaration by understanding
some key concepts of how TypeScript works.
### Types
If you‚Äôre reading this guide, you probably already roughly know what a type in
TypeScript is. To be more explicit, though, a _type_ is introduced with:
  * A type alias declaration (`type sn = number | string;`)
  * An interface declaration (`interface I { x: number[]; }`)
  * A class declaration (`class C { }`)
  * An enum declaration (`enum E { A, B, C }`)
  * An `import` declaration which refers to a type
Each of these declaration forms creates a new type name.
### Values
As with types, you probably already understand what a value is. Values are
runtime names that we can reference in expressions. For example `let x = 5;`
creates a value called `x`.
Again, being explicit, the following things create values:
  * `let`, `const`, and `var` declarations
  * A `namespace` or `module` declaration which contains a value
  * An `enum` declaration
  * A `class` declaration
  * An `import` declaration which refers to a value
  * A `function` declaration
### Namespaces
Types can exist in _namespaces_. For example, if we have the declaration `let
x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.
This distinction is subtle and important ‚Äî here, `A.B` is not necessarily a
type or a value.
## Simple Combinations: One name, multiple meanings
Given a name `A`, we might find up to three different meanings for `A`: a
type, a value or a namespace. How the name is interpreted depends on the
context in which it is used. For example, in the declaration `let m: A.A =
A;`, `A` is used first as a namespace, then as a type name, then as a value.
These meanings might end up referring to entirely different declarations!
This may seem confusing, but it‚Äôs actually very convenient as long as we don‚Äôt
excessively overload things. Let‚Äôs look at some useful aspects of this
combining behavior.
### Built-in Combinations
Astute readers will notice that, for example, `class` appeared in both the
_type_ and _value_ lists. The declaration `class C { }` creates two things: a
_type_ `C` which refers to the instance shape of the class, and a _value_ `C`
which refers to the constructor function of the class. Enum declarations
behave similarly.
### User Combinations
Let‚Äôs say we wrote a module file `foo.d.ts`:
    ts
    export var SomeVar: { a: SomeType };
    export interface SomeType {
      count: number;
    }
Then consumed it:
    ts
    import * as foo from "./foo";
    let x: foo.SomeType = foo.SomeVar.a;
    console.log(x.count);
This works well enough, but we might imagine that `SomeType` and `SomeVar`
were very closely related such that you‚Äôd like them to have the same name. We
can use combining to present these two different objects (the value and the
type) under the same name `Bar`:
    ts
    export var Bar: { a: Bar };
    export interface Bar {
      count: number;
    }
This presents a very good opportunity for destructuring in the consuming code:
    ts
    import { Bar } from "./foo";
    let x: Bar = Bar.a;
    console.log(x.count);
Again, we‚Äôve used `Bar` as both a type and a value here. Note that we didn‚Äôt
have to declare the `Bar` value as being of the `Bar` type ‚Äî they‚Äôre
independent.
## Advanced Combinations
Some kinds of declarations can be combined across multiple declarations. For
example, `class C { }` and `interface C { }` can co-exist and both contribute
properties to the `C` types.
This is legal as long as it does not create a conflict. A general rule of
thumb is that values always conflict with other values of the same name unless
they are declared as `namespace`s, types will conflict if they are declared
with a type alias declaration (`type s = string`), and namespaces never
conflict.
Let‚Äôs see how this can be used.
### Adding using an `interface`
We can add additional members to an `interface` with another `interface`
declaration:
    ts
    interface Foo {
      x: number;
    }
    // ... elsewhere ...
    interface Foo {
      y: number;
    }
    let a: Foo = ...;
    console.log(a.x + a.y); // OK
This also works with classes:
    ts
    class Foo {
      x: number;
    }
    // ... elsewhere ...
    interface Foo {
      y: number;
    }
    let a: Foo = ...;
    console.log(a.x + a.y); // OK
Note that we cannot add to type aliases (`type s = string;`) using an
interface.
### Adding using a `namespace`
A `namespace` declaration can be used to add new types, values, and namespaces
in any way which does not create a conflict.
For example, we can add a static member to a class:
    ts
    class C {}
    // ... elsewhere ...
    namespace C {
      export let x: number;
    }
    let y = C.x; // OK
Note that in this example, we added a value to the _static_ side of `C` (its
constructor function). This is because we added a _value_ , and the container
for all values is another value (types are contained by namespaces, and
namespaces are contained by other namespaces).
We could also add a namespaced type to a class:
    ts
    class C {}
    // ... elsewhere ...
    namespace C {
      export interface D {}
    }
    let y: C.D; // OK
In this example, there wasn‚Äôt a namespace `C` until we wrote the `namespace`
declaration for it. The meaning `C` as a namespace doesn‚Äôt conflict with the
value or type meanings of `C` created by the class.
Finally, we could perform many different merges using `namespace`
declarations. This isn‚Äôt a particularly realistic example, but shows all sorts
of interesting behavior:
    ts
    namespace X {
      export interface Y {}
      export class Z {}
    }
    // ... elsewhere ...
    namespace X {
      export var Y: number;
      export namespace Z {
        export class C {}
      }
    }
    type X = string;
In this example, the first block creates the following name meanings:
  * A value `X` (because the `namespace` declaration contains a value, `Z`)
  * A namespace `X` (because the `namespace` declaration contains a type, `Y`)
  * A type `Y` in the `X` namespace
  * A type `Z` in the `X` namespace (the instance shape of the class)
  * A value `Z` that is a property of the `X` value (the constructor function of the class)
The second block creates the following name meanings:
  * A value `Y` (of type `number`) that is a property of the `X` value
  * A namespace `Z`
  * A value `Z` that is a property of the `X` value
  * A type `C` in the `X.Z` namespace
  * A value `C` that is a property of the `X.Z` value
  * A type `X`
### [Do's and Don'tsRecommendations for writing d.ts
files](/docs/handbook/declaration-files/do-s-and-don-ts.html)
### [PublishingHow to get your d.ts files to
users](/docs/handbook/declaration-files/publishing.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Deep Dive.md)
‚ù§
Contributors to this page:  
MH
OT
1+
Last updated: Sep 16, 2024  
Was this page helpful?
# Do's and Don'ts
## General Types
### `Number`, `String`, `Boolean`, `Symbol` and `Object`
‚ùå **Don‚Äôt** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or
`Object` These types refer to non-primitive boxed objects that are almost
never used appropriately in JavaScript code.
    ts
    /* WRONG */
    function reverse(s: String): String;
‚úÖ **Do** use the types `number`, `string`, `boolean`, and `symbol`.
    ts
    /* OK */
    function reverse(s: string): string;
Instead of `Object`, use the non-primitive `object` type ([added in TypeScript
2.2](../release-notes/typescript-2-2.html#object-type)).
### Generics
‚ùå **Don‚Äôt** ever have a generic type which doesn‚Äôt use its type parameter. See
more details in [TypeScript FAQ
page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-
inference-work-on-this-interface-interface-foot--).
### any
‚ùå **Don‚Äôt** use `any` as a type unless you are in the process of migrating a
JavaScript project to TypeScript. The compiler _effectively_ treats `any` as
‚Äúplease turn off type checking for this thing‚Äù. It is similar to putting an
`@ts-ignore` comment around every usage of the variable. This can be very
helpful when you are first migrating a JavaScript project to TypeScript as you
can set the type for stuff you haven‚Äôt migrated yet as `any`, but in a full
TypeScript project you are disabling type checking for any parts of your
program that use it.
In cases where you don‚Äôt know what type you want to accept, or when you want
to accept anything because you will be blindly passing it through without
interacting with it, you can use [`unknown`](/play/#example/unknown-and-
never).
## Callback Types
### Return Types of Callbacks
‚ùå **Don‚Äôt** use the return type `any` for callbacks whose value will be
ignored:
    ts
    /* WRONG */
    function fn(x: () => any) {
      x();
    }
‚úÖ **Do** use the return type `void` for callbacks whose value will be ignored:
    ts
    /* OK */
    function fn(x: () => void) {
      x();
    }
‚ùî **Why:** Using `void` is safer because it prevents you from accidentally
using the return value of `x` in an unchecked way:
    ts
    function fn(x: () => void) {
      var k = x(); // oops! meant to do something else
      k.doSomething(); // error, but would be OK if the return type had been 'any'
    }
### Optional Parameters in Callbacks
‚ùå **Don‚Äôt** use optional parameters in callbacks unless you really mean it:
    ts
    /* WRONG */
    interface Fetcher {
      getObject(done: (data: unknown, elapsedTime?: number) => void): void;
    }
This has a very specific meaning: the `done` callback might be invoked with 1
argument or might be invoked with 2 arguments. The author probably intended to
say that the callback might not care about the `elapsedTime` parameter, but
there‚Äôs no need to make the parameter optional to accomplish this ‚Äî it‚Äôs
always legal to provide a callback that accepts fewer arguments.
‚úÖ **Do** write callback parameters as non-optional:
    ts
    /* OK */
    interface Fetcher {
      getObject(done: (data: unknown, elapsedTime: number) => void): void;
    }
### Overloads and Callbacks
‚ùå **Don‚Äôt** write separate overloads that differ only on callback arity:
    ts
    /* WRONG */
    declare function beforeAll(action: () => void, timeout?: number): void;
    declare function beforeAll(
      action: (done: DoneFn) => void,
      timeout?: number
    ): void;
‚úÖ **Do** write a single overload using the maximum arity:
    ts
    /* OK */
    declare function beforeAll(
      action: (done: DoneFn) => void,
      timeout?: number
    ): void;
‚ùî **Why:** It‚Äôs always legal for a callback to disregard a parameter, so
there‚Äôs no need for the shorter overload. Providing a shorter callback first
allows incorrectly-typed functions to be passed in because they match the
first overload.
## Function Overloads
### Ordering
‚ùå **Don‚Äôt** put more general overloads before more specific overloads:
    ts
    /* WRONG */
    declare function fn(x: unknown): unknown;
    declare function fn(x: HTMLElement): number;
    declare function fn(x: HTMLDivElement): string;
    var myElem: HTMLDivElement;
    var x = fn(myElem); // x: unknown, wat?
‚úÖ **Do** sort overloads by putting the more general signatures after more
specific signatures:
    ts
    /* OK */
    declare function fn(x: HTMLDivElement): string;
    declare function fn(x: HTMLElement): number;
    declare function fn(x: unknown): unknown;
    var myElem: HTMLDivElement;
    var x = fn(myElem); // x: string, :)
‚ùî **Why:** TypeScript chooses the _first matching overload_ when resolving
function calls. When an earlier overload is ‚Äúmore general‚Äù than a later one,
the later one is effectively hidden and cannot be called.
### Use Optional Parameters
‚ùå **Don‚Äôt** write several overloads that differ only in trailing parameters:
    ts
    /* WRONG */
    interface Example {
      diff(one: string): number;
      diff(one: string, two: string): number;
      diff(one: string, two: string, three: boolean): number;
    }
‚úÖ **Do** use optional parameters whenever possible:
    ts
    /* OK */
    interface Example {
      diff(one: string, two?: string, three?: boolean): number;
    }
Note that this collapsing should only occur when all overloads have the same
return type.
‚ùî **Why:** This is important for two reasons.
TypeScript resolves signature compatibility by seeing if any signature of the
target can be invoked with the arguments of the source, _and extraneous
arguments are allowed_. This code, for example, exposes a bug only when the
signature is correctly written using optional parameters:
    ts
    function fn(x: (a: string, b: number, c: number) => void) {}
    var x: Example;
    // When written with overloads, OK -- used first overload
    // When written with optionals, correctly an error
    fn(x.diff);
The second reason is when a consumer uses the ‚Äústrict null checking‚Äù feature
of TypeScript. Because unspecified parameters appear as `undefined` in
JavaScript, it‚Äôs usually fine to pass an explicit `undefined` to a function
with optional arguments. This code, for example, should be OK under strict
nulls:
    ts
    var x: Example;
    // When written with overloads, incorrectly an error because of passing 'undefined' to 'string'
    // When written with optionals, correctly OK
    x.diff("something", true ? undefined : "hour");
### Use Union Types
‚ùå **Don‚Äôt** write overloads that differ by type in only one argument position:
    ts
    /* WRONG */
    interface Moment {
      utcOffset(): number;
      utcOffset(b: number): Moment;
      utcOffset(b: string): Moment;
    }
‚úÖ **Do** use union types whenever possible:
    ts
    /* OK */
    interface Moment {
      utcOffset(): number;
      utcOffset(b: number | string): Moment;
    }
Note that we didn‚Äôt make `b` optional here because the return types of the
signatures differ.
‚ùî **Why:** This is important for people who are ‚Äúpassing through‚Äù a value to
your function:
    ts
    function fn(x: string): Moment;
    function fn(x: number): Moment;
    function fn(x: number | string) {
      // When written with separate overloads, incorrectly an error
      // When written with union types, correctly OK
      return moment().utcOffset(x);
    }
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Deep DiveHow do d.ts files work, a deep dive](/docs/handbook/declaration-
files/deep-dive.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Do's and
Don'ts.md) ‚ù§
Contributors to this page:  
MH
OT
MZ
MF
J
15+
Last updated: Sep 16, 2024  
Was this page helpful?
# Creating .d.ts Files from .js files
[With TypeScript 3.7](/docs/handbook/release-
notes/typescript-3-7.html#--declaration-and---allowjs), TypeScript added
support for generating .d.ts files from JavaScript using JSDoc syntax.
This set up means you can own the editor experience of TypeScript-powered
editors without porting your project to TypeScript, or having to maintain
.d.ts files in your codebase. TypeScript supports most JSDoc tags, you can
find [the reference here](/docs/handbook/type-checking-javascript-
files.html#supported-jsdoc).
## Setting up your Project to emit .d.ts files
To add creation of .d.ts files in your project, you will need to do up-to four
steps:
  * Add TypeScript to your dev dependencies
  * Add a `tsconfig.json` to configure TypeScript
  * Run the TypeScript compiler to generate the corresponding d.ts files for JS files
  * (optional) Edit your package.json to reference the types
### Adding TypeScript
You can learn how to do this in our [installation page](/download).
### TSConfig
The TSConfig is a jsonc file which configures both your compiler flags, and
declare where to find files. In this case, you will want a file like the
following:
    {
      // Change this to match your project
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        // Tells TypeScript to read JS files, as
        // normally they are ignored as source files
        "[allowJs](https://www.typescriptlang.org/tsconfig#allowJs)": true,
        // Generate d.ts files
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
        // This compiler run should
        // only output d.ts files
        "[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)": true,
        // Types should go into this directory.
        // Removing this would place the .d.ts files
        // next to the .js files
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "dist",
        // go to js file when using IDE functions like
        // "Go to Definition" in VSCode
        "[declarationMap](https://www.typescriptlang.org/tsconfig#declarationMap)": true
      }
    }
You can learn more about the options in the [tsconfig reference](/tsconfig).
An alternative to using a TSConfig file is the CLI, this is the same behavior
as a CLI command.
    sh
    npx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types
## Run the compiler
You can learn how to do this in our [installation page](/download). You want
to make sure these files are included in your package if you have the files in
your project‚Äôs `.gitignore`.
## Editing the package.json
TypeScript replicates the node resolution for modules in a `package.json`,
with an additional step for finding .d.ts files. Roughly, the resolution will
first check the optional `types` field, then the `"main"` field, and finally
will try `index.d.ts` in the root.
Package.json | Location of default .d.ts  
---|---  
No ‚Äútypes‚Äù field | checks ‚Äúmain‚Äù, then index.d.ts  
‚Äútypes‚Äù: ‚Äúmain.d.ts‚Äù | main.d.ts  
‚Äútypes‚Äù: ‚Äú./dist/main.js‚Äù | ./dist/main.d.ts  
If absent, then ‚Äúmain‚Äù is used
Package.json | Location of default .d.ts  
---|---  
No ‚Äúmain‚Äù field | index.d.ts  
‚Äúmain‚Äù:‚Äúindex.js‚Äù | index.d.ts  
‚Äúmain‚Äù:‚Äú./dist/index.js‚Äù | ./dist/index.d.ts  
## Tips
If you‚Äôd like to write tests for your .d.ts files, try
[tsd](https://github.com/SamVerschueren/tsd).
### [JSDoc ReferenceWhat JSDoc does TypeScript-powered JavaScript
support?](/docs/handbook/jsdoc-supported-types.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Creating DTS files
From JS.md) ‚ù§
Contributors to this page:  
OT
SG
JB
SW
JS
2+
Last updated: Sep 16, 2024  
Was this page helpful?
# Introduction
The Declaration Files section is designed to teach you how to write a high-
quality TypeScript Declaration File. We need to assume basic familiarity with
the TypeScript language in order to get started.
If you haven‚Äôt already, you should read the [TypeScript
Handbook](/docs/handbook/2/basic-types.html) to familiarize yourself with
basic concepts, especially types and modules.
The most common case for learning how .d.ts files work is that you‚Äôre typing
an npm package with no types. In that case, you can jump straight to [Modules
.d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html).
The Declaration Files section is broken down into the following sections.
## [Declaration Reference](/docs/handbook/declaration-files/by-example.html)
We are often faced with writing a declaration file when we only have examples
of the underlying library to guide us. The [Declaration
Reference](/docs/handbook/declaration-files/by-example.html) section shows
many common API patterns and how to write declarations for each of them. This
guide is aimed at the TypeScript novice who may not yet be familiar with every
language construct in TypeScript.
## [Library Structures](/docs/handbook/declaration-files/library-
structures.html)
The [Library Structures](/docs/handbook/declaration-files/library-
structures.html) guide helps you understand common library formats and how to
write a proper declaration file for each format. If you‚Äôre editing an existing
file, you probably don‚Äôt need to read this section. Authors of new declaration
files are strongly encouraged to read this section to properly understand how
the format of the library influences the writing of the declaration file.
In the Template section you‚Äôll find a number of declaration files that serve
as a useful starting point when writing a new file. If you already know what
your structure is, see the d.ts Template section in the sidebar.
## [Do‚Äôs and Don‚Äôts](/docs/handbook/declaration-files/do-s-and-don-ts.html)
Many common mistakes in declaration files can be easily avoided. The [Do‚Äôs and
Don‚Äôts](/docs/handbook/declaration-files/do-s-and-don-ts.html) section
identifies common errors, describes how to detect them, and how to fix them.
Everyone should read this section to help themselves avoid common mistakes.
## [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
For seasoned authors interested in the underlying mechanics of how declaration
files work, the [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
section explains many advanced concepts in declaration writing, and shows how
to leverage these concepts to create cleaner and more intuitive declaration
files.
## [Publish to npm](/docs/handbook/declaration-files/publishing.html)
The [Publishing](/docs/handbook/declaration-files/publishing.html) section
explains how to publish your declaration files to an npm package, and shows
how to manage your dependent packages.
## [Find and Install Declaration Files](/docs/handbook/declaration-
files/consumption.html)
For JavaScript library users, the [Consumption](/docs/handbook/declaration-
files/consumption.html) section offers a few simple steps to locate and
install corresponding declaration files.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Declaration ReferenceHow to create a d.ts file for a
module](/docs/handbook/declaration-files/by-example.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Introduction.md) ‚ù§
Contributors to this page:  
MH
OT
JW
NR
DK
11+
Last updated: Sep 16, 2024  
Was this page helpful?
# Library Structures
Broadly speaking, the way you _structure_ your declaration file depends on how
the library is consumed. There are many ways of offering a library for
consumption in JavaScript, and you‚Äôll need to write your declaration file to
match it. This guide covers how to identify common library patterns, and how
to write declaration files which correspond to that pattern.
Each type of major library structuring pattern has a corresponding file in the
[Templates](/docs/handbook/declaration-files/templates.html) section. You can
start with these templates to help you get going faster.
## Identifying Kinds of Libraries
First, we‚Äôll review the kinds of libraries TypeScript declaration files can
represent. We‚Äôll briefly show how each kind of library is _used_ , how it is
_written_ , and list some example libraries from the real world.
Identifying the structure of a library is the first step in writing its
declaration file. We‚Äôll give hints on how to identify structure both based on
its _usage_ and its _code_. Depending on the library‚Äôs documentation and
organization, one might be easier than the other. We recommend using whichever
is more comfortable to you.
### What should you look for?
Question to ask yourself while looking at a library you are trying to type.
  1. How do you obtain the library?
For example, can you _only_ get it through npm or only from a CDN?
  2. How would you import it?
Does it add a global object? Does it use `require` or `import`/`export`
statements?
### Smaller samples for different types of libraries
### Modular Libraries
Almost every modern Node.js library falls into the module family. These type
of libraries only work in a JS environment with a module loader. For example,
`express` only works in Node.js and must be loaded using the CommonJS
`require` function.
ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and
RequireJS have similar notions of _importing_ a _module_. In JavaScript
CommonJS (Node.js), for example, you would write
    js
    var fs = require("fs");
In TypeScript or ES6, the `import` keyword serves the same purpose:
    ts
    import * as fs from "fs";
You‚Äôll typically see modular libraries include one of these lines in their
documentation:
    js
    var someLib = require("someLib");
or
    js
    define(..., ['someLib'], function(someLib) {
    });
As with global modules, you might see these examples in the documentation of a
UMD module, so be sure to check the code or documentation.
#### Identifying a Module Library from Code
Modular libraries will typically have at least some of the following:
  * Unconditional calls to `require` or `define`
  * Declarations like `import * as a from 'b';` or `export c;`
  * Assignments to `exports` or `module.exports`
They will rarely have:
  * Assignments to properties of `window` or `global`
#### Templates For Modules
There are four templates available for modules,
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html),
[`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-class-
d-ts.html), [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) and [`module-
plugin.d.ts`](/docs/handbook/declaration-files/templates/module-plugin-d-
ts.html).
You should first read [`module.d.ts`](/docs/handbook/declaration-
files/templates/module-d-ts.html) for an overview on the way they all work.
Then use the template [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) if your module can be _called_ like
a function:
    js
    const x = require("foo");
    // Note: calling 'x' as a function
    const y = x(42);
Use the template [`module-class.d.ts`](/docs/handbook/declaration-
files/templates/module-class-d-ts.html) if your module can be _constructed_
using `new`:
    js
    const x = require("bar");
    // Note: using 'new' operator on the imported variable
    const y = new x("hello");
If you have a module which when imported, makes changes to other modules use
template [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html):
    js
    const jest = require("jest");
    require("jest-matchers-files");
### Global Libraries
A _global_ library is one that can be accessed from the global scope (i.e.
without using any form of `import`). Many libraries simply expose one or more
global variables for use. For example, if you were using
[jQuery](https://jquery.com/), the `$` variable can be used by simply
referring to it:
    ts
    $(() => {
      console.log("hello!");
    });
You‚Äôll usually see guidance in the documentation of a global library of how to
use the library in an HTML script tag:
    html
    <script src="http://a.great.cdn.for/someLib.js"></script>
Today, most popular globally-accessible libraries are actually written as UMD
libraries (see below). UMD library documentation is hard to distinguish from
global library documentation. Before writing a global declaration file, make
sure the library isn‚Äôt actually UMD.
#### Identifying a Global Library from Code
Global library code is usually extremely simple. A global ‚ÄúHello, world‚Äù
library might look like this:
    js
    function createGreeting(s) {
      return "Hello, " + s;
    }
or like this:
    js
    // Web
    window.createGreeting = function (s) {
      return "Hello, " + s;
    };
    // Node
    global.createGreeting = function (s) {
      return "Hello, " + s;
    };
    // Potentially any runtime
    globalThis.createGreeting = function (s) {
      return "Hello, " + s;
    };
When looking at the code of a global library, you‚Äôll usually see:
  * Top-level `var` statements or `function` declarations
  * One or more assignments to `window.someName`
  * Assumptions that DOM primitives like `document` or `window` exist
You _won‚Äôt_ see:
  * Checks for, or usage of, module loaders like `require` or `define`
  * CommonJS/Node.js-style imports of the form `var fs = require("fs");`
  * Calls to `define(...)`
  * Documentation describing how to `require` or import the library
#### Examples of Global Libraries
Because it‚Äôs usually easy to turn a global library into a UMD library, very
few popular libraries are still written in the global style. However,
libraries that are small and require the DOM (or have _no_ dependencies) may
still be global.
#### Global Library Template
The template file [`global.d.ts`](/docs/handbook/declaration-
files/templates/global-d-ts.html) defines an example library `myLib`. Be sure
to read the ‚ÄúPreventing Name Conflicts‚Äù footnote.
### _UMD_
A _UMD_ module is one that can _either_ be used as module (through an import),
or as a global (when run in an environment without a module loader). Many
popular libraries, such as [Moment.js](https://momentjs.com/), are written
this way. For example, in Node.js or using RequireJS, you would write:
    ts
    import moment = require("moment");
    console.log(moment.format());
whereas in a vanilla browser environment you would write:
    js
    console.log(moment.format());
#### Identifying a UMD library
[UMD modules](https://github.com/umdjs/umd) check for the existence of a
module loader environment. This is an easy-to-spot pattern that looks
something like this:
    js
    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            define(["libName"], factory);
        } else if (typeof module === "object" && module.exports) {
            module.exports = factory(require("libName"));
        } else {
            root.returnExports = factory(root.libName);
        }
    }(this, function (b) {
If you see tests for `typeof define`, `typeof window`, or `typeof module` in
the code of a library, especially at the top of the file, it‚Äôs almost always a
UMD library.
Documentation for UMD libraries will also often demonstrate a ‚ÄúUsing in
Node.js‚Äù example showing `require`, and a ‚ÄúUsing in the browser‚Äù example
showing using a `<script>` tag to load the script.
#### Examples of UMD libraries
Most popular libraries are now available as UMD packages. Examples include
[jQuery](https://jquery.com/), [Moment.js](https://momentjs.com/),
[lodash](https://lodash.com/), and many more.
#### Template
Use the [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html) template.
## Consuming Dependencies
There are several kinds of dependencies your library might have. This section
shows how to import them into the declaration file.
### Dependencies on Global Libraries
If your library depends on a global library, use a `/// <reference types="..."
/>` directive:
    ts
    /// <reference types="someLib" />
    function getThing(): someLib.thing;
### Dependencies on Modules
If your library depends on a module, use an `import` statement:
    ts
    import * as moment from "moment";
    function getThing(): moment;
### Dependencies on UMD libraries
#### From a Global Library
If your global library depends on a UMD module, use a `/// <reference types`
directive:
    ts
    /// <reference types="moment" />
    function getThing(): moment;
#### From a Module or UMD Library
If your module or UMD library depends on a UMD library, use an `import`
statement:
    ts
    import * as someLib from "someLib";
Do _not_ use a `/// <reference` directive to declare a dependency to a UMD
library!
## Footnotes
### Preventing Name Conflicts
Note that it‚Äôs possible to define many types in the global scope when writing
a global declaration file. We strongly discourage this as it leads to possible
unresolvable name conflicts when many declaration files are in a project.
A simple rule to follow is to only declare types _namespaced_ by whatever
global variable the library defines. For example, if the library defines the
global value ‚Äòcats‚Äô, you should write
    ts
    declare namespace cats {
      interface KittySettings {}
    }
But _not_
    ts
    // at top-level
    interface CatsKittySettings {}
This guidance also ensures that the library can be transitioned to UMD without
breaking declaration file users.
### The Impact of ES6 on Module Call Signatures
Many popular libraries, such as Express, expose themselves as a callable
function when imported. For example, the typical Express usage looks like
this:
    ts
    import exp = require("express");
    var app = exp();
In ES6-compliant module loaders, the top-level object (here imported as `exp`)
can only have properties; the top-level module object can _never_ be callable.
The most common solution here is to define a `default` export for a
callable/constructable object; module loaders commonly detect this situation
automatically and replace the top-level object with the `default` export.
TypeScript can handle this for you, if you have [`"esModuleInterop":
true`](/tsconfig/#esModuleInterop) in your tsconfig.json.
### [Declaration ReferenceHow to create a d.ts file for a
module](/docs/handbook/declaration-files/by-example.html)
### [Modules .d.ts](/docs/handbook/declaration-files/templates/module-d-
ts.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Library
Structures.md) ‚ù§
Contributors to this page:  
MH
OT
DR
L
MF
12+
Last updated: Sep 16, 2024  
Was this page helpful?
# Publishing
Now that you have authored a declaration file following the steps of this
guide, it is time to publish it to npm. There are two main ways you can
publish your declaration files to npm:
  1. bundling with your npm package
  2. publishing to the [@types organization](https://www.npmjs.com/~types) on npm.
If your types are generated by your source code, publish the types with your
source code. Both TypeScript and JavaScript projects can generate types via
[`declaration`](/tsconfig#declaration).
Otherwise, we recommend submitting the types to DefinitelyTyped, which will
publish them to the `@types` organization on npm.
## Including declarations in your npm package
If your package has a main `.js` file, you will need to indicate the main
declaration file in your `package.json` file as well. Set the `types` property
to point to your bundled declaration file. For example:
    json
    {
      "name": "awesome",
      "author": "Vandelay Industries",
      "version": "1.0.0",
      "main": "./lib/main.js",
      "types": "./lib/main.d.ts"
    }
Note that the `"typings"` field is synonymous with `types`, and could be used
as well.
## Dependencies
All dependencies are managed by npm. Make sure all the declaration packages
you depend on are marked appropriately in the `"dependencies"` section in your
`package.json`. For example, imagine we authored a package that used
Browserify and TypeScript.
    json
    {
      "name": "browserify-typescript-extension",
      "author": "Vandelay Industries",
      "version": "1.0.0",
      "main": "./lib/main.js",
      "types": "./lib/main.d.ts",
      "dependencies": {
        "browserify": "latest",
        "@types/browserify": "latest",
        "typescript": "next"
      }
    }
Here, our package depends on the `browserify` and `typescript` packages.
`browserify` does not bundle its declaration files with its npm packages, so
we needed to depend on `@types/browserify` for its declarations. `typescript`,
on the other hand, packages its declaration files, so there was no need for
any additional dependencies.
Our package exposes declarations from each of those, so any user of our
`browserify-typescript-extension` package needs to have these dependencies as
well. For that reason, we used `"dependencies"` and not `"devDependencies"`,
because otherwise our consumers would have needed to manually install those
packages. If we had just written a command line application and not expected
our package to be used as a library, we might have used `devDependencies`.
## Red flags
### `/// <reference path="..." />`
_Don‚Äôt_ use `/// <reference path="..." />` in your declaration files.
    ts
    /// <reference path="../typescript/lib/typescriptServices.d.ts" />
    ....
_Do_ use `/// <reference types="..." />` instead.
    ts
    /// <reference types="typescript" />
    ....
Make sure to revisit the [Consuming dependencies](/docs/handbook/declaration-
files/library-structures.html#consuming-dependencies) section for more
information.
### Packaging dependent declarations
If your type definitions depend on another package:
  * _Don‚Äôt_ combine it with yours, keep each in their own file.
  * _Don‚Äôt_ copy the declarations in your package either.
  * _Do_ depend on the npm type declaration package if it doesn‚Äôt package its declaration files.
## Version selection with `typesVersions`
When TypeScript opens a `package.json` file to figure out which files it needs
to read, it first looks at a field called `typesVersions`.
#### Folder redirects (using `*`)
A `package.json` with a `typesVersions` field might look like this:
    json
    {
      "name": "package-name",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        ">=3.1": { "*": ["ts3.1/*"] }
      }
    }
This `package.json` tells TypeScript to first check the current version of
TypeScript. If it‚Äôs 3.1 or later, TypeScript figures out the path you‚Äôve
imported relative to the package, and reads from the package‚Äôs `ts3.1` folder.
That‚Äôs what that `{ "*": ["ts3.1/*"] }` means - if you‚Äôre familiar with [path
mapping](/tsconfig#paths), it works exactly like that.
In the above example, if we‚Äôre importing from `"package-name"`, TypeScript
will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts`
(and other relevant paths) when running in TypeScript 3.1. If we import from
`package-name/foo`, we‚Äôll try to look for `[...]/node_modules/package-
name/ts3.1/foo.d.ts` and `[...]/node_modules/package-
name/ts3.1/foo/index.d.ts`.
What if we‚Äôre not running in TypeScript 3.1 in this example? Well, if none of
the fields in `typesVersions` get matched, TypeScript falls back to the
`types` field, so here TypeScript 3.0 and earlier will be redirected to
`[...]/node_modules/package-name/index.d.ts`.
#### File redirects
When you want to only change the resolution for a single file at a time, you
can tell TypeScript the file to resolve differently by passing in the exact
filenames:
    json
    {
      "name": "package-name",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
      }
    }
On TypeScript 4.0 and above, an import for `"package-name"` would resolve to
`./index.d.ts` and for 3.9 and below `"./index.v3.d.ts`.
Note that redirections only affect the _external_ API of a package; import
resolution within a project is not affected by `typesVersions`. For example, a
`d.ts` file in the previous example containing `import * as foo from
"./index"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas
another package importing `import * as foo from "package-name"` _will_ get
`index.v3.d.ts`.
## Matching behavior
The way that TypeScript decides on whether a version of the compiler &
language matches is by using Node‚Äôs [semver
ranges](https://github.com/npm/node-semver#ranges).
## Multiple fields
`typesVersions` can support multiple fields where each field name is specified
by the range to match on.
    {
      "name": "package-name",
      "version": "1.0",
      "[types](https://www.typescriptlang.org/tsconfig#types)": "./index.d.ts",
      "typesVersions": {
        ">=3.2": { "*": ["ts3.2/*"] },
        ">=3.1": { "*": ["ts3.1/*"] }
      }
    }
Since ranges have the potential to overlap, determining which redirect applies
is order-specific. That means in the above example, even though both the
`>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing
the order could have different behavior, so the above sample would not be
equivalent to the following.
    {
      "name": "package-name",
      "version": "1.0",
      "[types](https://www.typescriptlang.org/tsconfig#types)": "./index.d.ts",
      "typesVersions": {
        // NOTE: this doesn't work!
        ">=3.1": { "*": ["ts3.1/*"] },
        ">=3.2": { "*": ["ts3.2/*"] }
      }
    }
## Publish to [@types](https://www.npmjs.com/~types)
Packages under the [@types](https://www.npmjs.com/~types) organization are
published automatically from
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) using
the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-
tools/tree/master/packages/publisher). To get your declarations published as
an @types package, please submit a pull request to
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). You can
find more details in the [contribution guidelines
page](https://definitelytyped.github.io/guides/contributing.html).
### [Deep DiveHow do d.ts files work, a deep dive](/docs/handbook/declaration-
files/deep-dive.html)
### [ConsumptionHow to download d.ts files for your
project](/docs/handbook/declaration-files/consumption.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/Publishing.md) ‚ù§
Contributors to this page:  
MH
OT
MB
RV
RC
19+
Last updated: Sep 16, 2024  
Was this page helpful?
# Templates
[global-modifying-module.d.ts](/3ed761a6c3f38d73aadf745e7454f74d/global-
modifying-module.d.ts.md)
  * [global-plugin.d.ts](/docs/handbook/declaration-files/templates/global-plugin-d-ts.html)
  * [global.d.ts](/docs/handbook/declaration-files/templates/global-d-ts.html)
  * [module-class.d.ts](/docs/handbook/declaration-files/templates/module-class-d-ts.html)
  * [module-function.d.ts](/docs/handbook/declaration-files/templates/module-function-d-ts.html)
  * [module-plugin.d.ts](/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)
  * [module.d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-files/Templates.md)
‚ù§
Contributors to this page:  
MH
OT
1+
Last updated: Sep 16, 2024  
Was this page helpful?
# Global .d.ts
## Global Libraries
A _global_ library is one that can be accessed from the global scope (i.e.
without using any form of `import`). Many libraries simply expose one or more
global variables for use. For example, if you were using
[jQuery](https://jquery.com/), the `$` variable can be used by simply
referring to it:
    ts
    $(() => {
      console.log("hello!");
    });
You‚Äôll usually see guidance in the documentation of a global library of how to
use the library in an HTML script tag:
    html
    <script src="http://a.great.cdn.for/someLib.js"></script>
Today, most popular globally-accessible libraries are actually written as UMD
libraries (see below). UMD library documentation is hard to distinguish from
global library documentation. Before writing a global declaration file, make
sure the library isn‚Äôt actually UMD.
## Identifying a Global Library from Code
Global library code is usually extremely simple. A global ‚ÄúHello, world‚Äù
library might look like this:
    js
    function createGreeting(s) {
      return "Hello, " + s;
    }
or like this:
    js
    window.createGreeting = function (s) {
      return "Hello, " + s;
    };
When looking at the code of a global library, you‚Äôll usually see:
  * Top-level `var` statements or `function` declarations
  * One or more assignments to `window.someName`
  * Assumptions that DOM primitives like `document` or `window` exist
You _won‚Äôt_ see:
  * Checks for, or usage of, module loaders like `require` or `define`
  * CommonJS/Node.js-style imports of the form `var fs = require("fs");`
  * Calls to `define(...)`
  * Documentation describing how to `require` or import the library
## Examples of Global Libraries
Because it‚Äôs usually easy to turn a global library into a UMD library, very
few popular libraries are still written in the global style. However,
libraries that are small and require the DOM (or have _no_ dependencies) may
still be global.
## Global Library Template
You can see an example DTS below:
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ If this library is callable (e.g. can be invoked as myLib(3)),
     *~ include those call signatures here.
     *~ Otherwise, delete this section.
     */
    declare function myLib(a: string): string;
    declare function myLib(a: number): number;
    /*~ If you want the name of this library to be a valid type name,
     *~ you can do so here.
     *~
     *~ For example, this allows us to write 'var x: myLib';
     *~ Be sure this actually makes sense! If it doesn't, just
     *~ delete this declaration and add types inside the namespace below.
     */
    interface myLib {
      name: string;
      length: number;
      extras?: string[];
    }
    /*~ If your library has properties exposed on a global variable,
     *~ place them here.
     *~ You should also place types (interfaces and type alias) here.
     */
    declare namespace myLib {
      //~ We can write 'myLib.timeout = 50;'
      let timeout: number;
      //~ We can access 'myLib.version', but not change it
      const version: string;
      //~ There's some class we can create via 'let c = new myLib.Cat(42)'
      //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }
      class Cat {
        constructor(n: number);
        //~ We can read 'c.age' from a 'Cat' instance
        readonly age: number;
        //~ We can invoke 'c.purr()' from a 'Cat' instance
        purr(): void;
      }
      //~ We can declare a variable as
      //~   'var s: myLib.CatSettings = { weight: 5, name: "Maru" };'
      interface CatSettings {
        weight: number;
        name: string;
        tailLength?: number;
      }
      //~ We can write 'const v: myLib.VetID = 42;'
      //~  or 'const v: myLib.VetID = "bob";'
      type VetID = string | number;
      //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'
      function checkCat(c: Cat, s?: VetID);
    }
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
1+
Last updated: Sep 16, 2024  
Was this page helpful?
# Global: Modifying Module
##  _Global-modifying Modules_
A _global-modifying module_ alters existing values in the global scope when
they are imported. For example, there might exist a library which adds new
members to `String.prototype` when imported. This pattern is somewhat
dangerous due to the possibility of runtime conflicts, but we can still write
a declaration file for it.
## Identifying global-modifying modules
Global-modifying modules are generally easy to identify from their
documentation. In general, they‚Äôre similar to global plugins, but need a
`require` call to activate their effects.
You might see documentation like this:
    js
    // 'require' call that doesn't use its return value
    var unused = require("magic-string-time");
    /* or */
    require("magic-string-time");
    var x = "hello, world";
    // Creates new methods on built-in types
    console.log(x.startsWithHello());
    var y = [1, 2, 3];
    // Creates new methods on built-in types
    console.log(y.reverseAndSort());
Here is an example
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This is the global-modifying module template file. You should rename it to index.d.ts
     *~ and place it in a folder with the same name as the module.
     *~ For example, if you were writing a file for "super-greeter", this
     *~ file should be 'super-greeter/index.d.ts'
     */
    /*~ Note: If your global-modifying module is callable or constructable, you'll
     *~ need to combine the patterns here with those in the module-class or module-function
     *~ template files
     */
    declare global {
      /*~ Here, declare things that go in the global namespace, or augment
       *~ existing declarations in the global namespace
       */
      interface String {
        fancyFormat(opts: StringFormatOptions): string;
      }
    }
    /*~ If your module exports types or values, write them as usual */
    export interface StringFormatOptions {
      fancinessLevel: number;
    }
    /*~ For example, declaring a method on the module (in addition to its global side effects) */
    export function doSomething(): void;
    /*~ If your module exports nothing, you'll need this line. Otherwise, delete it */
    export {};
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global-modifying-module.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
1+
Last updated: Sep 16, 2024  
Was this page helpful?
# Global: Plugin
##  _UMD_
A _UMD_ module is one that can _either_ be used as module (through an import),
or as a global (when run in an environment without a module loader). Many
popular libraries, such as [Moment.js](http://momentjs.com/), are written this
way. For example, in Node.js or using RequireJS, you would write:
    ts
    import moment = require("moment");
    console.log(moment.format());
whereas in a vanilla browser environment you would write:
    js
    console.log(moment.format());
### Identifying a UMD library
[UMD modules](https://github.com/umdjs/umd) check for the existence of a
module loader environment. This is an easy-to-spot pattern that looks
something like this:
    js
    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            define(["libName"], factory);
        } else if (typeof module === "object" && module.exports) {
            module.exports = factory(require("libName"));
        } else {
            root.returnExports = factory(root.libName);
        }
    }(this, function (b) {
If you see tests for `typeof define`, `typeof window`, or `typeof module` in
the code of a library, especially at the top of the file, it‚Äôs almost always a
UMD library.
Documentation for UMD libraries will also often demonstrate a ‚ÄúUsing in
Node.js‚Äù example showing `require`, and a ‚ÄúUsing in the browser‚Äù example
showing using a `<script>` tag to load the script.
### Examples of UMD libraries
Most popular libraries are now available as UMD packages. Examples include
[jQuery](https://jquery.com/), [Moment.js](http://momentjs.com/),
[lodash](https://lodash.com/), and many more.
### Template
There are three templates available for modules,
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html),
[`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-class-
d-ts.html) and [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html).
Use [`module-function.d.ts`](/docs/handbook/declaration-
files/templates/module-function-d-ts.html) if your module can be _called_ like
a function:
    js
    var x = require("foo");
    // Note: calling 'x' as a function
    var y = x(42);
Be sure to read the footnote ‚ÄúThe Impact of ES6 on Module Call Signatures‚Äù
Use [`module-class.d.ts`](/docs/handbook/declaration-files/templates/module-
class-d-ts.html) if your module can be _constructed_ using `new`:
    js
    var x = require("bar");
    // Note: using 'new' operator on the imported variable
    var y = new x("hello");
The same footnote applies to these modules.
If your module is not callable or constructable, use the
[`module.d.ts`](/docs/handbook/declaration-files/templates/module-d-ts.html)
file.
## _Module Plugin_ or _UMD Plugin_
A _module plugin_ changes the shape of another module (either UMD or module).
For example, in Moment.js, `moment-range` adds a new `range` method to the
`moment` object.
For the purposes of writing a declaration file, you‚Äôll write the same code
whether the module being changed is a plain module or UMD module.
### Template
Use the [`module-plugin.d.ts`](/docs/handbook/declaration-
files/templates/module-plugin-d-ts.html) template.
## _Global Plugin_
A _global plugin_ is global code that changes the shape of some global. As
with _global-modifying modules_ , these raise the possibility of runtime
conflict.
For example, some libraries add new functions to `Array.prototype` or
`String.prototype`.
### Identifying global plugins
Global plugins are generally easy to identify from their documentation.
You‚Äôll see examples that look like this:
    js
    var x = "hello, world";
    // Creates new methods on built-in types
    console.log(x.startsWithHello());
    var y = [1, 2, 3];
    // Creates new methods on built-in types
    console.log(y.reverseAndSort());
### Template
Use the [`global-plugin.d.ts`](/docs/handbook/declaration-
files/templates/global-plugin-d-ts.html) template.
## _Global-modifying Modules_
A _global-modifying module_ alters existing values in the global scope when
they are imported. For example, there might exist a library which adds new
members to `String.prototype` when imported. This pattern is somewhat
dangerous due to the possibility of runtime conflicts, but we can still write
a declaration file for it.
### Identifying global-modifying modules
Global-modifying modules are generally easy to identify from their
documentation. In general, they‚Äôre similar to global plugins, but need a
`require` call to activate their effects.
You might see documentation like this:
    js
    // 'require' call that doesn't use its return value
    var unused = require("magic-string-time");
    /* or */
    require("magic-string-time");
    var x = "hello, world";
    // Creates new methods on built-in types
    console.log(x.startsWithHello());
    var y = [1, 2, 3];
    // Creates new methods on built-in types
    console.log(y.reverseAndSort());
### Template
Use the [`global-modifying-module.d.ts`](/docs/handbook/declaration-
files/templates/global-modifying-module-d-ts.html) template.
## Consuming Dependencies
There are several kinds of dependencies your library might have. This section
shows how to import them into the declaration file.
### Dependencies on Global Libraries
If your library depends on a global library, use a `/// <reference types="..."
/>` directive:
    ts
    /// <reference types="someLib" />
    function getThing(): someLib.thing;
### Dependencies on Modules
If your library depends on a module, use an `import` statement:
    ts
    import * as moment from "moment";
    function getThing(): moment;
### Dependencies on UMD libraries
#### From a Global Library
If your global library depends on a UMD module, use a `/// <reference types`
directive:
    ts
    /// <reference types="moment" />
    function getThing(): moment;
#### From a Module or UMD Library
If your module or UMD library depends on a UMD library, use an `import`
statement:
    ts
    import * as someLib from "someLib";
Do _not_ use a `/// <reference` directive to declare a dependency to a UMD
library!
## Footnotes
### Preventing Name Conflicts
Note that it‚Äôs possible to define many types in the global scope when writing
a global declaration file. We strongly discourage this as it leads to possible
unresolvable name conflicts when many declaration files are in a project.
A simple rule to follow is to only declare types _namespaced_ by whatever
global variable the library defines. For example, if the library defines the
global value ‚Äòcats‚Äô, you should write
    ts
    declare namespace cats {
      interface KittySettings {}
    }
But _not_
    ts
    // at top-level
    interface CatsKittySettings {}
This guidance also ensures that the library can be transitioned to UMD without
breaking declaration file users.
### The Impact of ES6 on Module Plugins
Some plugins add or modify top-level exports on existing modules. While this
is legal in CommonJS and other loaders, ES6 modules are considered immutable
and this pattern will not be possible. Because TypeScript is loader-agnostic,
there is no compile-time enforcement of this policy, but developers intending
to transition to an ES6 module loader should be aware of this.
### The Impact of ES6 on Module Call Signatures
Many popular libraries, such as Express, expose themselves as a callable
function when imported. For example, the typical Express usage looks like
this:
    ts
    import exp = require("express");
    var app = exp();
In ES6 module loaders, the top-level object (here imported as `exp`) can only
have properties; the top-level module object is _never_ callable. The most
common solution here is to define a `default` export for a
callable/constructable object; some module loader shims will automatically
detect this situation and replace the top-level object with the `default`
export.
### Library file layout
The layout of your declaration files should mirror the layout of the library.
A library can consist of multiple modules, such as
    myLib
      +---- index.js
      +---- foo.js
      +---- bar
             +---- index.js
             +---- baz.js
These could be imported as
    js
    var a = require("myLib");
    var b = require("myLib/foo");
    var c = require("myLib/bar");
    var d = require("myLib/bar/baz");
Your declaration files should thus be
    @types/myLib
      +---- index.d.ts
      +---- foo.d.ts
      +---- bar
             +---- index.d.ts
             +---- baz.d.ts
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This template shows how to write a global plugin. */
    /*~ Write a declaration for the original type and add new members.
     *~ For example, this adds a 'toBinaryString' method with overloads to
     *~ the built-in number type.
     */
    interface Number {
      toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;
      toBinaryString(
        callback: MyLibrary.BinaryFormatCallback,
        opts?: MyLibrary.BinaryFormatOptions
      ): string;
    }
    /*~ If you need to declare several types, place them inside a namespace
     *~ to avoid adding too many things to the global namespace.
     */
    declare namespace MyLibrary {
      type BinaryFormatCallback = (n: number) => string;
      interface BinaryFormatOptions {
        prefix?: string;
        padding: number;
      }
    }
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/global-plugin.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
MF
JH
J
2+
Last updated: Sep 16, 2024  
Was this page helpful?
# Module: Class
For example, when you want to work with JavaScript code which looks like:
    ts
    const Greeter = require("super-greeter");
    const greeter = new Greeter();
    greeter.greet();
To handle both importing via UMD and modules:
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This is the module template file for class modules.
     *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.
     *~ For example, if you were writing a file for "super-greeter", this
     *~ file should be 'super-greeter/index.d.ts'
     */
    // Note that ES6 modules cannot directly export class objects.
    // This file should be imported using the CommonJS-style:
    //   import x = require('[~THE MODULE~]');
    //
    // Alternatively, if --allowSyntheticDefaultImports or
    // --esModuleInterop is turned on, this file can also be
    // imported as a default import:
    //   import x from '[~THE MODULE~]';
    //
    // Refer to the TypeScript documentation at
    // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require
    // to understand common workarounds for this limitation of ES6 modules.
    /*~ If this module is a UMD module that exposes a global variable 'myClassLib' when
     *~ loaded outside a module loader environment, declare that global here.
     *~ Otherwise, delete this declaration.
     */
    export as namespace "super-greeter";
    /*~ This declaration specifies that the class constructor function
     *~ is the exported object from the file
     */
    export = Greeter;
    /*~ Write your module's methods and properties in this class */
    declare class Greeter {
      constructor(customGreeting?: string);
      greet: void;
      myMethod(opts: MyClass.MyClassMethodOptions): number;
    }
    /*~ If you want to expose types from your module as well, you can
     *~ place them in this block.
     *~
     *~ Note that if you decide to include this namespace, the module can be
     *~ incorrectly imported as a namespace object, unless
     *~ --esModuleInterop is turned on:
     *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!
     */
    declare namespace MyClass {
      export interface MyClassMethodOptions {
        width?: number;
        height?: number;
      }
    }
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-class.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
AC
DR
2+
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules .d.ts
## Comparing JavaScript to an example DTS
## Common CommonJS Patterns
A module using CommonJS patterns uses `module.exports` to describe the
exported values. For example, here is a module which exports a function and a
numerical constant:
    js
    const maxInterval = 12;
    function getArrayLength(arr) {
      return arr.length;
    }
    module.exports = {
      getArrayLength,
      maxInterval,
    };
This can be described by the following `.d.ts`:
    ts
    export function getArrayLength(arr: any[]): number;
    export const maxInterval: 12;
The TypeScript playground can show you the `.d.ts` equivalent for JavaScript
code. You can [try it yourself
here](/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA).
The `.d.ts` syntax intentionally looks like [ES
Modules](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Statements/import) syntax. ES Modules was
ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available
via transpilers for a long time, however if you have a JavaScript codebase
using ES Modules:
    js
    export function getArrayLength(arr) {
      return arr.length;
    }
This would have the following `.d.ts` equivalent:
    ts
    export function getArrayLength(arr: any[]): number;
### Default Exports
In CommonJS you can export any value as the default export, for example here
is a regular expression module:
    js
    module.exports = /hello( world)?/;
Which can be described by the following .d.ts:
    ts
    declare const helloWorld: RegExp;
    export default helloWorld;
Or a number:
    js
    module.exports = 3.142;
    ts
    declare const pi: number;
    export default pi;
One style of exporting in CommonJS is to export a function. Because a function
is also an object, then extra fields can be added and are included in the
export.
    js
    function getArrayLength(arr) {
      return arr.length;
    }
    getArrayLength.maxInterval = 12;
    module.exports = getArrayLength;
Which can be described with:
    ts
    export default function getArrayLength(arr: any[]): number;
    export const maxInterval: 12;
Note that using `export default` in your .d.ts files requires
[`esModuleInterop: true`](/tsconfig#esModuleInterop) to work. If you can‚Äôt
have `esModuleInterop: true` in your project, such as when you‚Äôre submitting a
PR to Definitely Typed, you‚Äôll have to use the `export=` syntax instead. This
older syntax is harder to use but works everywhere. Here‚Äôs how the above
example would have to be written using `export=`:
    ts
    declare function getArrayLength(arr: any[]): number;
    declare namespace getArrayLength {
      declare const maxInterval: 12;
    }
    export = getArrayLength;
See [Module: Functions](/docs/handbook/declaration-files/templates/module-
function-d-ts.html) for details of how that works, and the [Modules
reference](/docs/handbook/modules.html) page.
## Handling Many Consuming Import
There are many ways to import a module in modern consuming code:
    ts
    const fastify = require("fastify");
    const { fastify } = require("fastify");
    import fastify = require("fastify");
    import * as Fastify from "fastify";
    import { fastify, FastifyInstance } from "fastify";
    import fastify from "fastify";
    import fastify, { FastifyInstance } from "fastify";
Covering all of these cases requires the JavaScript code to actually support
all of these patterns. To support many of these patterns, a CommonJS module
would need to look something like:
    js
    class FastifyInstance {}
    function fastify() {
      return new FastifyInstance();
    }
    fastify.FastifyInstance = FastifyInstance;
    // Allows for { fastify }
    fastify.fastify = fastify;
    // Allows for strict ES Module support
    fastify.default = fastify;
    // Sets the default export
    module.exports = fastify;
## Types in Modules
You may want to provide a type for JavaScript code which does not exist
    js
    function getArrayMetadata(arr) {
      return {
        length: getArrayLength(arr),
        firstObject: arr[0],
      };
    }
    module.exports = {
      getArrayMetadata,
    };
This can be described with:
    ts
    export type ArrayMetadata = {
      length: number;
      firstObject: any | undefined;
    };
    export function getArrayMetadata(arr: any[]): ArrayMetadata;
This example is a good case for [using
generics](/docs/handbook/generics.html#generic-types) to provide richer type
information:
    ts
    export type ArrayMetadata<ArrType> = {
      length: number;
      firstObject: ArrType | undefined;
    };
    export function getArrayMetadata<ArrType>(
      arr: ArrType[]
    ): ArrayMetadata<ArrType>;
Now the type of the array propagates into the `ArrayMetadata` type.
The types which are exported can then be re-used by consumers of the modules
using either `import` or `import type` in TypeScript code or [JSDoc
imports](/docs/handbook/jsdoc-supported-types.html#import-types).
### Namespaces in Module Code
Trying to describe the runtime relationship of JavaScript code can be tricky.
When the ES Module-like syntax doesn‚Äôt provide enough tools to describe the
exports then you can use `namespaces`.
For example, you may have complex enough types to describe that you choose to
namespace them inside your `.d.ts`:
    ts
    // This represents the JavaScript class which would be available at runtime
    export class API {
      constructor(baseURL: string);
      getInfo(opts: API.InfoRequest): API.InfoResponse;
    }
    // This namespace is merged with the API class and allows for consumers, and this file
    // to have types which are nested away in their own sections.
    declare namespace API {
      export interface InfoRequest {
        id: string;
      }
      export interface InfoResponse {
        width: number;
        height: number;
      }
    }
To understand how namespaces work in `.d.ts` files read the [`.d.ts` deep
dive](/docs/handbook/declaration-files/deep-dive.html).
### Optional Global Usage
You can use `export as namespace` to declare that your module will be
available in the global scope in UMD contexts:
    ts
    export as namespace moduleName;
## Reference Example
To give you an idea of how all these pieces can come together, here is a
reference `.d.ts` to start with when making a new module
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This is the module template file. You should rename it to index.d.ts
     *~ and place it in a folder with the same name as the module.
     *~ For example, if you were writing a file for "super-greeter", this
     *~ file should be 'super-greeter/index.d.ts'
     */
    /*~ If this module is a UMD module that exposes a global variable 'myLib' when
     *~ loaded outside a module loader environment, declare that global here.
     *~ Otherwise, delete this declaration.
     */
    export as namespace myLib;
    /*~ If this module exports functions, declare them like so.
     */
    export function myFunction(a: string): string;
    export function myOtherFunction(a: number): number;
    /*~ You can declare types that are available via importing the module */
    export interface SomeType {
      name: string;
      length: number;
      extras?: string[];
    }
    /*~ You can declare properties of the module using const, let, or var */
    export const myField: number;
### Library file layout
The layout of your declaration files should mirror the layout of the library.
A library can consist of multiple modules, such as
    myLib
      +---- index.js
      +---- foo.js
      +---- bar
             +---- index.js
             +---- baz.js
These could be imported as
    js
    var a = require("myLib");
    var b = require("myLib/foo");
    var c = require("myLib/bar");
    var d = require("myLib/bar/baz");
Your declaration files should thus be
    @types/myLib
      +---- index.d.ts
      +---- foo.d.ts
      +---- bar
             +---- index.d.ts
             +---- baz.d.ts
### Testing your types
If you are planning on submitting these changes to DefinitelyTyped for
everyone to also use, then we recommend you:
>   1. Create a new folder in `node_modules/@types/[libname]`
>   2. Create an `index.d.ts` in that folder, and copy the example in
>   3. See where your usage of the module breaks, and start to fill out the
> index.d.ts
>   4. When you‚Äôre happy, clone
> [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped) and
> follow the instructions in the README.
>
Otherwise
>   1. Create a new file in the root of your source tree: `[libname].d.ts`
>   2. Add `declare module "[libname]" { }`
>   3. Add the template inside the braces of the declare module, and see where
> your usage breaks
>
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
MF
H
GS
4+
Last updated: Sep 16, 2024  
Was this page helpful?
# Module: Function
For example, when you want to work with JavaScript code which looks like:
    ts
    import greeter from "super-greeter";
    greeter(2);
    greeter("Hello world");
To handle both importing via UMD and modules:
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This is the module template file for function modules.
     *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.
     *~ For example, if you were writing a file for "super-greeter", this
     *~ file should be 'super-greeter/index.d.ts'
     */
    // Note that ES6 modules cannot directly export class objects.
    // This file should be imported using the CommonJS-style:
    //   import x = require('[~THE MODULE~]');
    //
    // Alternatively, if --allowSyntheticDefaultImports or
    // --esModuleInterop is turned on, this file can also be
    // imported as a default import:
    //   import x from '[~THE MODULE~]';
    //
    // Refer to the TypeScript documentation at
    // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require
    // to understand common workarounds for this limitation of ES6 modules.
    /*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when
     *~ loaded outside a module loader environment, declare that global here.
     *~ Otherwise, delete this declaration.
     */
    export as namespace myFuncLib;
    /*~ This declaration specifies that the function
     *~ is the exported object from the file
     */
    export = Greeter;
    /*~ This example shows how to have multiple overloads for your function */
    declare function Greeter(name: string): Greeter.NamedReturnType;
    declare function Greeter(length: number): Greeter.LengthReturnType;
    /*~ If you want to expose types from your module as well, you can
     *~ place them in this block. Often you will want to describe the
     *~ shape of the return type of the function; that type should
     *~ be declared in here, as this example shows.
     *~
     *~ Note that if you decide to include this namespace, the module can be
     *~ incorrectly imported as a namespace object, unless
     *~ --esModuleInterop is turned on:
     *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!
     */
    declare namespace Greeter {
      export interface LengthReturnType {
        width: number;
        height: number;
      }
      export interface NamedReturnType {
        firstName: string;
        lastName: string;
      }
      /*~ If the module also has properties, declare them here. For example,
       *~ this declaration says that this code is legal:
       *~   import f = require('super-greeter');
       *~   console.log(f.defaultName);
       */
      export const defaultName: string;
      export let defaultLength: number;
    }
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-function.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
DR
2+
Last updated: Sep 16, 2024  
Was this page helpful?
# Module: Plugin
For example, when you want to work with JavaScript code which extends another
library.
    ts
    import { greeter } from "super-greeter";
    // Normal Greeter API
    greeter(2);
    greeter("Hello world");
    // Now we extend the object with a new function at runtime
    import "hyper-super-greeter";
    greeter.hyperGreet();
The definition for ‚Äúsuper-greeter‚Äù:
    ts
    /*~ This example shows how to have multiple overloads for your function */
    export interface GreeterFunction {
      (name: string): void
      (time: number): void
    }
    /*~ This example shows how to export a function specified by an interface */
    export const greeter: GreeterFunction;
We can extend the existing module like the following:
    ts
    // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
    // Project: [~THE PROJECT NAME~]
    // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>
    /*~ This is the module plugin template file. You should rename it to index.d.ts
     *~ and place it in a folder with the same name as the module.
     *~ For example, if you were writing a file for "super-greeter", this
     *~ file should be 'super-greeter/index.d.ts'
     */
    /*~ On this line, import the module which this module adds to */
    import { greeter } from "super-greeter";
    /*~ Here, declare the same module as the one you imported above
     *~ then we expand the existing declaration of the greeter function
     */
    export module "super-greeter" {
      export interface GreeterFunction {
        /** Greets even better! */
        hyperGreet(): void;
      }
    }
This uses [declaration merging](/docs/handbook/declaration-merging.html)
## The Impact of ES6 on Module Plugins
Some plugins add or modify top-level exports on existing modules. While this
is legal in CommonJS and other loaders, ES6 modules are considered immutable
and this pattern will not be possible. Because TypeScript is loader-agnostic,
there is no compile-time enforcement of this policy, but developers intending
to transition to an ES6 module loader should be aware of this.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/declaration-
files/templates/module-plugin.d.ts.md) ‚ù§
Contributors to this page:  
MH
OT
B
1+
Last updated: Sep 16, 2024  
Was this page helpful?
# Declaration Merging
## Introduction
Some of the unique concepts in TypeScript describe the shape of JavaScript
objects at the type level. One example that is especially unique to TypeScript
is the concept of ‚Äòdeclaration merging‚Äô. Understanding this concept will give
you an advantage when working with existing JavaScript. It also opens the door
to more advanced abstraction concepts.
For the purposes of this article, ‚Äúdeclaration merging‚Äù means that the
compiler merges two separate declarations declared with the same name into a
single definition. This merged definition has the features of both of the
original declarations. Any number of declarations can be merged; it‚Äôs not
limited to just two declarations.
## Basic Concepts
In TypeScript, a declaration creates entities in at least one of three groups:
namespace, type, or value. Namespace-creating declarations create a namespace,
which contains names that are accessed using a dotted notation. Type-creating
declarations do just that: they create a type that is visible with the
declared shape and bound to the given name. Lastly, value-creating
declarations create values that are visible in the output JavaScript.
Declaration Type | Namespace | Type | Value  
---|---|---|---  
Namespace | X |  | X  
Class |  | X | X  
Enum |  | X | X  
Interface |  | X |   
Type Alias |  | X |   
Function |  |  | X  
Variable |  |  | X  
Understanding what is created with each declaration will help you understand
what is merged when you perform a declaration merge.
## Merging Interfaces
The simplest, and perhaps most common, type of declaration merging is
interface merging. At the most basic level, the merge mechanically joins the
members of both declarations into a single interface with the same name.
    ts
    interface Box {
      height: number;
      width: number;
    }
    interface Box {
      scale: number;
    }
    let box: Box = { height: 5, width: 6, scale: 10 };
Non-function members of the interfaces should be unique. If they are not
unique, they must be of the same type. The compiler will issue an error if the
interfaces both declare a non-function member of the same name, but of
different types.
For function members, each function member of the same name is treated as
describing an overload of the same function. Of note, too, is that in the case
of interface `A` merging with later interface `A`, the second interface will
have a higher precedence than the first.
That is, in the example:
    ts
    interface Cloner {
      clone(animal: Animal): Animal;
    }
    interface Cloner {
      clone(animal: Sheep): Sheep;
    }
    interface Cloner {
      clone(animal: Dog): Dog;
      clone(animal: Cat): Cat;
    }
The three interfaces will merge to create a single declaration as so:
    ts
    interface Cloner {
      clone(animal: Dog): Dog;
      clone(animal: Cat): Cat;
      clone(animal: Sheep): Sheep;
      clone(animal: Animal): Animal;
    }
Notice that the elements of each group maintains the same order, but the
groups themselves are merged with later overload sets ordered first.
One exception to this rule is specialized signatures. If a signature has a
parameter whose type is a _single_ string literal type (e.g. not a union of
string literals), then it will be bubbled toward the top of its merged
overload list.
For instance, the following interfaces will merge together:
    ts
    interface Document {
      createElement(tagName: any): Element;
    }
    interface Document {
      createElement(tagName: "div"): HTMLDivElement;
      createElement(tagName: "span"): HTMLSpanElement;
    }
    interface Document {
      createElement(tagName: string): HTMLElement;
      createElement(tagName: "canvas"): HTMLCanvasElement;
    }
The resulting merged declaration of `Document` will be the following:
    ts
    interface Document {
      createElement(tagName: "canvas"): HTMLCanvasElement;
      createElement(tagName: "div"): HTMLDivElement;
      createElement(tagName: "span"): HTMLSpanElement;
      createElement(tagName: string): HTMLElement;
      createElement(tagName: any): Element;
    }
## Merging Namespaces
Similarly to interfaces, namespaces of the same name will also merge their
members. Since namespaces create both a namespace and a value, we need to
understand how both merge.
To merge the namespaces, type definitions from exported interfaces declared in
each namespace are themselves merged, forming a single namespace with merged
interface definitions inside.
To merge the namespace value, at each declaration site, if a namespace already
exists with the given name, it is further extended by taking the existing
namespace and adding the exported members of the second namespace to the
first.
The declaration merge of `Animals` in this example:
    ts
    namespace Animals {
      export class Zebra {}
    }
    namespace Animals {
      export interface Legged {
        numberOfLegs: number;
      }
      export class Dog {}
    }
is equivalent to:
    ts
    namespace Animals {
      export interface Legged {
        numberOfLegs: number;
      }
      export class Zebra {}
      export class Dog {}
    }
This model of namespace merging is a helpful starting place, but we also need
to understand what happens with non-exported members. Non-exported members are
only visible in the original (un-merged) namespace. This means that after
merging, merged members that came from other declarations cannot see non-
exported members.
We can see this more clearly in this example:
    ts
    namespace Animal {
      let haveMuscles = true;
      export function animalsHaveMuscles() {
        return haveMuscles;
      }
    }
    namespace Animal {
      export function doAnimalsHaveMuscles() {
        return haveMuscles; // Error, because haveMuscles is not accessible here
      }
    }
Because `haveMuscles` is not exported, only the `animalsHaveMuscles` function
that shares the same un-merged namespace can see the symbol. The
`doAnimalsHaveMuscles` function, even though it‚Äôs part of the merged `Animal`
namespace can not see this un-exported member.
## Merging Namespaces with Classes, Functions, and Enums
Namespaces are flexible enough to also merge with other types of declarations.
To do so, the namespace declaration must follow the declaration it will merge
with. The resulting declaration has properties of both declaration types.
TypeScript uses this capability to model some of the patterns in JavaScript as
well as other programming languages.
### Merging Namespaces with Classes
This gives the user a way of describing inner classes.
    ts
    class Album {
      label: Album.AlbumLabel;
    }
    namespace Album {
      export class AlbumLabel {}
    }
The visibility rules for merged members is the same as described in the
[Merging Namespaces](./declaration-merging.html#merging-namespaces) section,
so we must export the `AlbumLabel` class for the merged class to see it. The
end result is a class managed inside of another class. You can also use
namespaces to add more static members to an existing class.
In addition to the pattern of inner classes, you may also be familiar with the
JavaScript practice of creating a function and then extending the function
further by adding properties onto the function. TypeScript uses declaration
merging to build up definitions like this in a type-safe way.
    ts
    function buildLabel(name: string): string {
      return buildLabel.prefix + name + buildLabel.suffix;
    }
    namespace buildLabel {
      export let suffix = "";
      export let prefix = "Hello, ";
    }
    console.log(buildLabel("Sam Smith"));
Similarly, namespaces can be used to extend enums with static members:
    ts
    enum Color {
      red = 1,
      green = 2,
      blue = 4,
    }
    namespace Color {
      export function mixColor(colorName: string) {
        if (colorName == "yellow") {
          return Color.red + Color.green;
        } else if (colorName == "white") {
          return Color.red + Color.green + Color.blue;
        } else if (colorName == "magenta") {
          return Color.red + Color.blue;
        } else if (colorName == "cyan") {
          return Color.green + Color.blue;
        }
      }
    }
## Disallowed Merges
Not all merges are allowed in TypeScript. Currently, classes can not merge
with other classes or with variables. For information on mimicking class
merging, see the [Mixins in TypeScript](/docs/handbook/mixins.html) section.
## Module Augmentation
Although JavaScript modules do not support merging, you can patch existing
objects by importing and then updating them. Let‚Äôs look at a toy Observable
example:
    ts
    // observable.ts
    export class Observable<T> {
      // ... implementation left as an exercise for the reader ...
    }
    // map.ts
    import { Observable } from "./observable";
    Observable.prototype.map = function (f) {
      // ... another exercise for the reader
    };
This works fine in TypeScript too, but the compiler doesn‚Äôt know about
`Observable.prototype.map`. You can use module augmentation to tell the
compiler about it:
    ts
    // observable.ts
    export class Observable<T> {
      // ... implementation left as an exercise for the reader ...
    }
    // map.ts
    import { Observable } from "./observable";
    declare module "./observable" {
      interface Observable<T> {
        map<U>(f: (x: T) => U): Observable<U>;
      }
    }
    Observable.prototype.map = function (f) {
      // ... another exercise for the reader
    };
    // consumer.ts
    import { Observable } from "./observable";
    import "./map";
    let o: Observable<number>;
    o.map((x) => x.toFixed());
The module name is resolved the same way as module specifiers in
`import`/`export`. See [Modules](/docs/handbook/modules.html) for more
information. Then the declarations in an augmentation are merged as if they
were declared in the same file as the original.
However, there are two limitations to keep in mind:
  1. You can‚Äôt declare new top-level declarations in the augmentation ‚Äî just patches to existing declarations.
  2. Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [#14080](https://github.com/Microsoft/TypeScript/issues/14080) for details)
### Global augmentation
You can also add declarations to the global scope from inside a module:
    ts
    // observable.ts
    export class Observable<T> {
      // ... still no implementation ...
    }
    declare global {
      interface Array<T> {
        toObservable(): Observable<T>;
      }
    }
    Array.prototype.toObservable = function () {
      // ...
    };
Global augmentations have the same behavior and limits as module
augmentations.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Declaration
Merging.md) ‚ù§
Contributors to this page:  
RC
DR
OT
NS
MF
15+
Last updated: Sep 16, 2024  
Was this page helpful?
# Decorators
> NOTE This document refers to an experimental stage 2 decorators
> implementation. Stage 3 decorator support is available since Typescript 5.0.
> See: [Decorators in Typescript
> 5.0](https://devblogs.microsoft.com/typescript/announcing-
> typescript-5-0/#decorators)
## Introduction
With the introduction of Classes in TypeScript and ES6, there now exist
certain scenarios that require additional features to support annotating or
modifying classes and class members. Decorators provide a way to add both
annotations and a meta-programming syntax for class declarations and members.
> Further Reading (stage 2): [A Complete Guide to TypeScript
> Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-
> decorator/)
To enable experimental support for decorators, you must enable the
[`experimentalDecorators`](/tsconfig#experimentalDecorators) compiler option
either on the command line or in your `tsconfig.json`:
**Command Line** :
    shell
    tsc --target ES5 --experimentalDecorators
**tsconfig.json** :
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "ES5",
        "[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators)": true
      }
    }
## Decorators
A _Decorator_ is a special kind of declaration that can be attached to a class
declaration, method, accessor, property, or parameter. Decorators use the form
`@expression`, where `expression` must evaluate to a function that will be
called at runtime with information about the decorated declaration.
For example, given the decorator `@sealed` we might write the `sealed`
function as follows:
    ts
    function sealed(target) {
      // do something with 'target' ...
    }
## Decorator Factories
If we want to customize how a decorator is applied to a declaration, we can
write a decorator factory. A _Decorator Factory_ is simply a function that
returns the expression that will be called by the decorator at runtime.
We can write a decorator factory in the following fashion:
    ts
    function color(value: string) {
      // this is the decorator factory, it sets up
      // the returned decorator function
      return function (target) {
        // this is the decorator
        // do something with 'target' and 'value'...
      };
    }
## Decorator Composition
Multiple decorators can be applied to a declaration, for example on a single
line:
    ts
    @f @g x
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAcIS0NCA)
On multiple lines:
    ts
    @f
    @g
    x
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAdDSmtCA)
When multiple decorators apply to a single declaration, their evaluation is
similar to [function composition in
mathematics](https://wikipedia.org/wiki/Function_composition). In this model,
when composing functions _f_ and _g_ , the resulting composite (_f_ ‚àò
_g_)(_x_) is equivalent to _f_(_g_(_x_)).
As such, the following steps are performed when evaluating multiple decorators
on a single declaration in TypeScript:
  1. The expressions for each decorator are evaluated top-to-bottom.
  2. The results are then called as functions from bottom-to-top.
If we were to use decorator factories, we can observe this evaluation order
with the following example:
    ts
    function first() {
      console.log("first(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("first(): called");
      };
    }
    function second() {
      console.log("second(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("second(): called");
      };
    }
    class ExampleClass {
      @first()
      @second()
      method() {}
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqh1IJWYAUASlABvGqFCl0VErkgA6XCQDmfAERce-AQC5O2FmQCeoSADc8DCpAAmqgQG4xoBJEwMEHRs1btQfHAhKrrrY6IYANKCwCCTwCJiGANKQhrq8yOhKkdaQVETIsJQIugAKMXEJhHkFRUKi4uKS0rIKymoavIK6RHiytg5OAL6OgzT0TCxsHFTE7NaCIk5NMvKKKqozkvM6egYIxmYWVv2O4i5uHpwTPhz+2IHBoKERUeWICcmpoOlImdm5+SQhTIpTe8UMVUBwIQdScjXYzVWbQ2s3Q226vRsdlOoGGNFGNCIuGwVCooAAotBsChYLIAMLE0mLcTgDpaJzgTZzQRONCYAAWJG2IlGgyAA)
Which would print this output to the console:
    shell
    first(): factory evaluated
    second(): factory evaluated
    second(): called
    first(): called
## Decorator Evaluation
There is a well defined order to how decorators applied to various
declarations inside of a class are applied:
  1. _Parameter Decorators_ , followed by _Method_ , _Accessor_ , or _Property Decorators_ are applied for each instance member.
  2. _Parameter Decorators_ , followed by _Method_ , _Accessor_ , or _Property Decorators_ are applied for each static member.
  3. _Parameter Decorators_ are applied for the constructor.
  4. _Class Decorators_ are applied for the class.
## Class Decorators
A _Class Decorator_ is declared just before a class declaration. The class
decorator is applied to the constructor of the class and can be used to
observe, modify, or replace a class definition. A class decorator cannot be
used in a declaration file, or in any other ambient context (such as on a
`declare` class).
The expression for the class decorator will be called as a function at
runtime, with the constructor of the decorated class as its only argument.
If the class decorator returns a value, it will replace the class declaration
with the provided constructor function.
> NOTE Should you choose to return a new constructor function, you must take
> care to maintain the original prototype. The logic that applies decorators
> at runtime will **not** do this for you.
The following is an example of a class decorator (`@sealed`) applied to a
`BugReport` class:
    ts
    @sealed
    class BugReport {
      type = "report";
      title: string;
      constructor(t: string) {
        this.title = t;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqhWR6QAmAFKXRVMCBizIAuUADEmLNugCUoAN41QoAPIAjAFbFMAOi55B7EWIkIlAbg3b9hk91znho8ZQRHYCEpSYAJ7wdjQAvjQgoAC0cUQMmHExNOCmuHw0RLjYVFSgAEIMAOYASpCwZJhqDsHwoAC8oABECBVVzfaarJgZ0pZI6MX2DkKWXmT8mP2ig8Uq6prdABZIVEY9GY2gmF2gkeFAA)
We can define the `@sealed` decorator using the following function
declaration:
    ts
    function sealed(constructor: Function) {
      Object.seal(constructor);
      Object.seal(constructor.prototype);
    }
When `@sealed` is executed, it will seal both the constructor and its
prototype, and will therefore prevent any further functionality from being
added to or removed from this class during runtime by accessing
`BugReport.prototype` or by defining properties on `BugReport` itself (note
that ES2015 classes are really just syntactic sugar to prototype-based
constructor functions). This decorator does **not** prevent classes from sub-
classing `BugReport`.
Next we have an example of how to override the constructor to set new
defaults.
    ts
    function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
      return class extends constructor {
        reportingURL = "http://www...";
      };
    }
    @reportableClassDecorator
    class BugReport {
      type = "report";
      title: string;
      constructor(t: string) {
        this.title = t;
      }
    }
    const bug = new BugReport("Needs dark mode");
    console.log(bug.title); // Prints "Needs dark mode"
    console.log(bug.type); // Prints "report"
    // Note that the decorator _does not_ change the TypeScript type
    // and so the new property `reportingURL` is not known
    // to the type system:
    bug.reportingURL;
    Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQIJIAPABxgEsBbSAOwBcBDAGwBFIBjBBuhRXAMwCuNdnXJwaoaJBIJGAIyaQAwkwaJEbTtG4IAPABVQxOrQAmiUAG9QNSAHdQACgB0bhtADmKUAxoBPAG0AXQBKVCsAX1BIgD4nThpEOmhBUQRUA1DrXFApSDpBaEl2NQ1jIlMaC1BE5NT06By8vOlZaDEaTwBVACUAGVAAXlAAIgALOjoSZBB7ebcXUYBuXJjVyNxccDa5BkUVMs0OLh5oXFL1SwAhQU9emTlm0Dp-MmGx3Y6VtbE6JVQ9XIXVWazqKTSZycdEBKWBnmyVjWeTo43IiBcfyUHzoqzym02FwkyVA8juHzsjlu90eHScowAcpBIDUzB4ANagShwMyQUahVZ1OBKFxMOCeJxkzyY8j-SAC0AEAAK0GBdEsjOZrI5XJ5fKJSWFkFF4sld0xb3ly0VYBVao1Xzooy2BAZcFML3G3E9kFAvO0uiaAH0zHBIJYaO6g7UvV1fajfQZLQBldiqkh0F6W-BgPxmUCIOA+2wOUAkeBkDr+UAAA0d8L6-RroHRtndoHZkfsNBzLyLCaz70Q-mSkEoyFwUpc9a6jeWQA)
## Method Decorators
A _Method Decorator_ is declared just before a method declaration. The
decorator is applied to the _Property Descriptor_ for the method, and can be
used to observe, modify, or replace a method definition. A method decorator
cannot be used in a declaration file, on an overload, or in any other ambient
context (such as in a `declare` class).
The expression for the method decorator will be called as a function at
runtime, with the following three arguments:
  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The _Property Descriptor_ for the member.
> NOTE The _Property Descriptor_ will be `undefined` if your script target is
> less than `ES5`.
If the method decorator returns a value, it will be used as the _Property
Descriptor_ for the method.
> NOTE The return value is ignored if your script target is less than `ES5`.
The following is an example of a method decorator (`@enumerable`) applied to a
method on the `Greeter` class:
    ts
    class Greeter {
      greeting: string;
      constructor(message: string) {
        this.greeting = message;
      }
      @enumerable(false)
      greet() {
        return "Hello, " + this.greeting;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgYNrkBGukABQA3PA0gAuULxIkB2dAEpQAbxqhQCSJgYIOjZq3ahBOBAHNtUhQE8ANLAQl4CTDYDSkG1KqZk6czsAE0gqImRYSgQpAAUnFzdCMIio5TUNDRDkpEiyADouHmx+SFAAXlBRXHEAbnVQAF86hpoQUABaTqIGTE72miJcbCoqUABxLW1EVXrzSdYAnz8kALqNUnRfBAYWMkE0EexLJf9zNPqNTAALJCo8uchtFfNy0AOqI8g1xpp6qHRuIhigJBHQ8FRIIpZvNBOcMpptLoOAAiAASkFwuBIdlAyNAAGpQNdbvd5s9vi0GkA)
We can define the `@enumerable` decorator using the following function
declaration:
    ts
    function enumerable(value: boolean) {
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUzCAtsgTgQwEYA2yAFAG44EjIBcieccROYAlIgN4BQiiWyUILElCRYCRMSg4sAc361mATwA0iAA5Y4a7FEUBpZItoBnKFhhgZqgCbJjEc2qhwstAAqbtWXQBE7DmCcXNi4eHlt7R2csADpUDGx8IkQAXkRySmQAbm5EAF8cvKA)
The `@enumerable(false)` decorator here is a decorator factory. When the
`@enumerable(false)` decorator is called, it modifies the `enumerable`
property of the property descriptor.
## Accessor Decorators
An _Accessor Decorator_ is declared just before an accessor declaration. The
accessor decorator is applied to the _Property Descriptor_ for the accessor
and can be used to observe, modify, or replace an accessor‚Äôs definitions. An
accessor decorator cannot be used in a declaration file, or in any other
ambient context (such as in a `declare` class).
> NOTE TypeScript disallows decorating both the `get` and `set` accessor for a
> single member. Instead, all decorators for the member must be applied to the
> first accessor specified in document order. This is because decorators apply
> to a _Property Descriptor_ , which combines both the `get` and `set`
> accessor, not each declaration separately.
The expression for the accessor decorator will be called as a function at
runtime, with the following three arguments:
  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The _Property Descriptor_ for the member.
> NOTE The _Property Descriptor_ will be `undefined` if your script target is
> less than `ES5`.
If the accessor decorator returns a value, it will be used as the _Property
Descriptor_ for the member.
> NOTE The return value is ignored if your script target is less than `ES5`.
The following is an example of an accessor decorator (`@configurable`) applied
to a member of the `Point` class:
    ts
    class Point {
      private _x: number;
      private _y: number;
      constructor(x: number, y: number) {
        this._x = x;
        this._y = y;
      }
      @configurable(false)
      get x() {
        return this._x;
      }
      @configurable(false)
      get y() {
        return this._y;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqinp1IDmD5AEa5IACgBueBpABcoQSRIjs6AJSgA3jVCgEkTAI6NmrdqFHadoHAl765KgJ4AaSztgIS8BJkcBpSEc5KkxkdF5XK1AAE0gqImRYSgQ5AAVPb19CeMTky3UtKNicpCSyADouHn4hEVAAXlBJXGkAbksAX3aOmhBQAFpBogZMQf6aIlxsKipQVJIkLE1LDyRJTEhQAH1oOXQGFEFEdvdkdc2toNB9w+PLLhCEBhYyUV3rg6OEZ1Arm6+Cm5rAALJBUco7BqgaAnKyYUHgy5QxywnqWcBVPgCbDCMR0PBUSCqSx2TDQ0SAqJ6AwIDjwsEQmGdGjozE1HEiUT43CE4k6Um-CnLKn6QwghmXVE0DpAA)
We can define the `@configurable` decorator using the following function
declaration:
    ts
    function configurable(value: boolean) {
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
      };
    }
## Property Decorators
A _Property Decorator_ is declared just before a property declaration. A
property decorator cannot be used in a declaration file, or in any other
ambient context (such as in a `declare` class).
The expression for the property decorator will be called as a function at
runtime, with the following two arguments:
  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
> NOTE A _Property Descriptor_ is not provided as an argument to a property
> decorator due to how property decorators are initialized in TypeScript. This
> is because there is currently no mechanism to describe an instance property
> when defining members of a prototype, and no way to observe or modify the
> initializer for a property. The return value is ignored too. As such, a
> property decorator can only be used to observe that a property of a specific
> name has been declared for a class.
We can use this information to record metadata about the property, as in the
following example:
    ts
    class Greeter {
      @format("Hello, %s")
      greeting: string;
      constructor(message: string) {
        this.greeting = message;
      }
      greet() {
        let formatString = getFormat(this, "greeting");
        return formatString.replace("%s", this.greeting);
      }
    }
We can then define the `@format` decorator and `getFormat` functions using the
following function declarations:
    ts
    import "reflect-metadata";
    const formatMetadataKey = Symbol("format");
    function format(formatString: string) {
      return Reflect.metadata(formatMetadataKey, formatString);
    }
    function getFormat(target: any, propertyKey: string) {
      return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
    }
The `@format("Hello, %s")` decorator here is a decorator factory. When
`@format("Hello, %s")` is called, it adds a metadata entry for the property
using the `Reflect.metadata` function from the `reflect-metadata` library.
When `getFormat` is called, it reads the metadata value for the format.
> NOTE This example requires the `reflect-metadata` library. See Metadata for
> more information about the `reflect-metadata` library.
## Parameter Decorators
A _Parameter Decorator_ is declared just before a parameter declaration. The
parameter decorator is applied to the function for a class constructor or
method declaration. A parameter decorator cannot be used in a declaration
file, an overload, or in any other ambient context (such as in a `declare`
class).
The expression for the parameter decorator will be called as a function at
runtime, with the following three arguments:
  1. Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
  2. The name of the member.
  3. The ordinal index of the parameter in the function‚Äôs parameter list.
> NOTE A parameter decorator can only be used to observe that a parameter has
> been declared on a method.
The return value of the parameter decorator is ignored.
The following is an example of a parameter decorator (`@required`) applied to
parameter of a member of the `BugReport` class:
    ts
    class BugReport {
      type = "report";
      title: string;
      constructor(t: string) {
        this.title = t;
      }
      @validate
      print(@required verbose: boolean) {
        if (verbose) {
          return `type: ${this.type}\ntitle: ${this.title}`;
        } else {
         return this.title; 
        }
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgBueSAJhZAAUOBAHNImAFyhs6AJ4AaULAQl4CTHIBy2NNKqZk6UUt6QqRZLEoJpAFTnxeABVXrNhC1ZsAeWXIA+AEpQAG8AX3omFjYOBEgARwYkeN5hbDEJaQB5ACMAK2JMJRU1RE0AaUg5fUMkY1AAH1AqORRcklwSjN0JRABJdDNoaXQGdsQQiJoQUABaBaIGTAW5miJcbCoqUAAhBlEAJUhYMkwwmlBQTXhQAF5QACJ4041HgG5L66RMXEhaoyiT5fUjoAwIBgsMjCAH1URTL5XTAACyQVAAdKxfpB7tdPldIl9wNxcHwBF8VPVMIJwPEkilILwuIgOlR-qAOp1ILIEVcrkg6KBBJwWSQ2by+Vd4pgGAgOAADG7sgAkoRRaMxjkg4QAOlgfn9pKr1RisX9wvL8XzwqBILg2RdJaBpbKOCbMQbIO9QIjQJECTRwkA)
We can then define the `@required` and `@validate` decorators using the
following function declarations:
    ts
    import "reflect-metadata";
    const requiredMetadataKey = Symbol("required");
    function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
      let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
      existingRequiredParameters.push(parameterIndex);
      Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);
    }
    function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
      let method = descriptor.value!;
      descriptor.value = function () {
        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
        if (requiredParameters) {
          for (let parameterIndex of requiredParameters) {
            if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {
              throw new Error("Missing required argument.");
            }
          }
        }
        return method.apply(this, arguments);
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEkKSmhp5lCAspDgCYXYaqWGUygARAkgAzXMUwBaNHwHiA3DVLoqYqQEcArkim9uKnAGlIAT1ABeUAGVrKAEYlcACkmRDxyLziAJQaNNIG6ESYSCTooPpGJp44CADmPABcoADyrgBW8gA0oLAIJPAImNZW1lk6yOipoAA+oFQu7rjFsNjkyogAkui8MFnoBm6IQaAA3jSgoHJiMEg6SI0ASr6JAQAKvdj9CFRjE66IANoAuvagW7LyAHTpmNkA7uhm2Pw4ngn+ph43wENWKKRe3TKFSqNWmzVa1w0CxWa022wB+z6PEQVEesAMVAAFp4eljMINhjAQvM7jI5FFHiNpOtIF8fthPPF0SY2SCbMUUdE0X4TJjDtjjmDehCSlDEDCbNSAL40MIRKIxOIANzwSB+kGS0syoGw6GskPK8usADlxXVMA1UsURlQiMhYBwsgAVazwXi7OWVayEV3ujgAHgAYurorEAHzTOYLJagZSEki8W4ut1ID1kR463AGSAAQlCC2zYfzheLt3CkVjcU8iZpyZ4XJFewORxOoHGkwQ11u93pmGePHenyB7L+3ICvMs-NA4J4FuhNvF1IWCyQ0lAs87-u7EqoLe32+kZH3KdJ4vJCCGI2goBIe-+ouP99Ps1b59Au-3W8jkfGBQDjBxpQmDBMFxORGkwQkWlaSC0CwKgLiAiUQOgG47Dw0AIiZFleDPP9zwQso3j7SAqIAUQQMoEG8ThViodYmnfAITTSKCsEeYIkTI0AVTIkTtzEhYpEwAwEDiNMM0ebBYFgXBrGSQlVmKFDoNPQSlQ0JUgA)
The `@required` decorator adds a metadata entry that marks the parameter as
required. The `@validate` decorator then wraps the existing `print` method in
a function that validates the arguments before invoking the original method.
> NOTE This example requires the `reflect-metadata` library. See Metadata for
> more information about the `reflect-metadata` library.
## Metadata
Some examples use the `reflect-metadata` library which adds a polyfill for an
[experimental metadata API](https://github.com/rbuckton/ReflectDecorators).
This library is not yet part of the ECMAScript (JavaScript) standard. However,
once decorators are officially adopted as part of the ECMAScript standard
these extensions will be proposed for adoption.
You can install this library via npm:
    shell
    npm i reflect-metadata --save
TypeScript includes experimental support for emitting certain types of
metadata for declarations that have decorators. To enable this experimental
support, you must set the
[`emitDecoratorMetadata`](/tsconfig#emitDecoratorMetadata) compiler option
either on the command line or in your `tsconfig.json`:
**Command Line** :
    shell
    tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata
**tsconfig.json** :
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "ES5",
        "[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators)": true,
        "[emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata)": true
      }
    }
When enabled, as long as the `reflect-metadata` library has been imported,
additional design-time type information will be exposed at runtime.
We can see this in action in the following example:
    ts
    import "reflect-metadata";
    class Point {
      constructor(public x: number, public y: number) {}
    }
    class Line {
      private _start: Point;
      private _end: Point;
      @validate
      set start(value: Point) {
        this._start = value;
      }
      get start() {
        return this._start;
      }
      @validate
      set end(value: Point) {
        this._end = value;
      }
      get end() {
        return this._end;
      }
    }
    function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {
      let set = descriptor.set!;
      descriptor.set = function (value: T) {
        let type = Reflect.getMetadata("design:type", target, propertyKey);
        if (!(value instanceof type)) {
          throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);
        }
        set.call(this, value);
      };
    }
    const line = new Line()
    line.start = new Point(0, 0)
    // @ts-ignore
    // line.end = {}
    // Fails at runtime with:
    // > Invalid type, got object not Point
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMFsEsBcAikDGB7ATgQ3pgspPFgCY5YBQIEkAHgA6QazSQB2RANsutrhgM6Uw4fvCYp4ABQxoGGeAE8AkqwSwsHWAC8csNKwBcoAGYb+kcszqZ4oAEQZIxjqngBaFkVJE7AbnLkKBxY-Pygkmiw7KAA3uSgoOisohgArhKYABR0qQBGmiigNEasqdC5jAA0oDn5sIUKJWUVGACUsQC+5F2BwaGgADJRkLHxNUwAbjgjAPqiWPJGEVHw-gl0k9OgM2zES5Hs-mPgU5reFgnmtvPymaepkPsr7XEJCfAAFrD8AHRzRPJQABeUD3SBrUA9BIAc0IoBu8EyLzGCUc8FSGFYoE+3z+CIhUIgp1g5zGV1AuzuGgeT3YyLe2K+vx2rGIwNB1PBY0JsNslPpbzRGKxOOZuwJ3QCxlSrAkeixxPOAB4ACoAPkyAN5RiwrAU1Q2skYigA0pBGvCxFFodViJB+CgmHQ+EYVQoGMRpEb5ApkA6nXxVWqBS5rnCQXb-bBnZgflcAIQQsaRx3Rvhx8MmGVy-SgKkcGmgFUChKh7HukYggBKThcEh+vIIXjImTskdg0MMigYdmqWsIBpkclN5taRwZsGMefj+YeoCi81lkDQU+7kFaJbenxkAHdQKxIHu3QwAKIYGQYTIAAxUivLDGq0LQtgAJDE1yuOQXIB198-QG+a4-KwWAsB0PxXmOKKQgEDJXD8KAaBwmpMtUYJQQkHT+D0SSiKAmgHuyB57kMB5IuQBGQHGAK2CCxHhAciIAAzVExrQBFQ4DwPwbgdqwmAWFQlE-Ls7IxD0VAAGJYLAHBhDgoBpOwzAjDuCAfAYQigGqoC3hoJL3pAj7-mguQAFauH+tjLOw5BAA)
The TypeScript compiler will inject design-time type information using the
`@Reflect.metadata` decorator. You could consider it the equivalent of the
following TypeScript:
    ts
    class Line {
      private _start: Point;
      private _end: Point;
      @validate
      @Reflect.metadata("design:type", Point)
      set start(value: Point) {
        this._start = value;
      }
      get start() {
        return this._start;
      }
      @validate
      @Reflect.metadata("design:type", Point)
      set end(value: Point) {
        this._end = value;
      }
      get end() {
        return this._end;
      }
    }
> NOTE Decorator metadata is an experimental feature and may introduce
> breaking changes in future releases.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Decorators.md) ‚ù§
Contributors to this page:  
RB
OT
MH
DR
HA
22+
Last updated: Sep 16, 2024  
Was this page helpful?
# DOM Manipulation
## DOM Manipulation
### _An exploration into the`HTMLElement` type_
In the 20+ years since its standardization, JavaScript has come a very long
way. While in 2020, JavaScript can be used on servers, in data science, and
even on IoT devices, it is important to remember its most popular use case:
web browsers.
Websites are made up of HTML and/or XML documents. These documents are static,
they do not change. The _Document Object Model (DOM)_ is a programming
interface implemented by browsers to make static websites functional. The DOM
API can be used to change the document structure, style, and content. The API
is so powerful that countless frontend frameworks (jQuery, React, Angular,
etc.) have been developed around it to make dynamic websites even easier to
develop.
TypeScript is a typed superset of JavaScript, and it ships type definitions
for the DOM API. These definitions are readily available in any default
TypeScript project. Of the 20,000+ lines of definitions in _lib.dom.d.ts_ ,
one stands out among the rest: `HTMLElement`. This type is the backbone for
DOM manipulation with TypeScript.
> You can explore the source code for the [DOM type
> definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)
## Basic Example
Given a simplified _index.html_ file:
    html
    <!DOCTYPE html>
    <html lang="en">
      <head><title>TypeScript Dom Manipulation</title></head>
      <body>
        <div id="app"></div>
        <!-- Assume index.js is the compiled output of index.ts -->
        <script src="index.js"></script>
      </body>
    </html>
Let‚Äôs explore a TypeScript script that adds a `<p>Hello, World!</p>` element
to the `#app` element.
    ts
    // 1. Select the div element using the id property
    const app = document.getElementById("app");
    // 2. Create a new <p></p> element programmatically
    const p = document.createElement("p");
    // 3. Add the text content
    p.textContent = "Hello, World!";
    // 4. Append the p element to the div element
    app?.appendChild(p);
After compiling and running the _index.html_ page, the resulting HTML will be:
    html
    <div id="app">
      <p>Hello, World!</p>
    </div>
## The `Document` Interface
The first line of the TypeScript code uses a global variable `document`.
Inspecting the variable shows it is defined by the `Document` interface from
the _lib.dom.d.ts_ file. The code snippet contains calls to two methods,
`getElementById` and `createElement`.
### `Document.getElementById`
The definition for this method is as follows:
    ts
    getElementById(elementId: string): HTMLElement | null;
Pass it an element id string and it will return either `HTMLElement` or
`null`. This method introduces one of the most important types, `HTMLElement`.
It serves as the base interface for every other element interface. For
example, the `p` variable in the code example is of type
`HTMLParagraphElement`. Also, take note that this method can return `null`.
This is because the method can‚Äôt be certain pre-runtime if it will be able to
actually find the specified element or not. In the last line of the code
snippet, the new _optional chaining_ operator is used to call `appendChild`.
### `Document.createElement`
The definition for this method is (I have omitted the _deprecated_
definition):
    ts
    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];
    createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;
This is an overloaded function definition. The second overload is simplest and
works a lot like the `getElementById` method does. Pass it any `string` and it
will return a standard HTMLElement. This definition is what enables developers
to create unique HTML element tags.
For example `document.createElement('xyz')` returns a `<xyz></xyz>` element,
clearly not an element that is specified by the HTML specification.
> For those interested, you can interact with custom tag elements using the
> `document.getElementsByTagName`
For the first definition of `createElement`, it is using some advanced generic
patterns. It is best understood broken down into chunks, starting with the
generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression
defines a generic parameter `K` that is _constrained_ to the keys of the
interface `HTMLElementTagNameMap`. The map interface contains every specified
HTML tag name and its corresponding type interface. For example here are the
first 5 mapped values:
    ts
    interface HTMLElementTagNameMap {
        "a": HTMLAnchorElement;
        "abbr": HTMLElement;
        "address": HTMLElement;
        "applet": HTMLAppletElement;
        "area": HTMLAreaElement;
            ...
    }
Some elements do not exhibit unique properties and so they just return
`HTMLElement`, but other types do have unique properties and methods so they
return their specific interface (which will extend from or implement
`HTMLElement`).
Now, for the remainder of the `createElement` definition: `(tagName: K,
options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first
argument `tagName` is defined as the generic parameter `K`. The TypeScript
interpreter is smart enough to _infer_ the generic parameter from this
argument. This means that the developer does not have to specify the generic
parameter when using the method; whatever value is passed to the `tagName`
argument will be inferred as `K` and thus can be used throughout the remainder
of the definition. This is exactly what happens; the return value
`HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return
the corresponding type. This definition is how the `p` variable from the code
snippet gets a type of `HTMLParagraphElement`. And if the code was
`document.createElement('a')`, then it would be an element of type
`HTMLAnchorElement`.
## The `Node` interface
The `document.getElementById` function returns an `HTMLElement`. `HTMLElement`
interface extends the `Element` interface which extends the `Node` interface.
This prototypal extension allows for all `HTMLElements` to utilize a subset of
standard methods. In the code snippet, we use a property defined on the `Node`
interface to append the new `p` element to the website.
### `Node.appendChild`
The last line of the code snippet is `app?.appendChild(p)`. The previous,
`document.getElementById`, section detailed that the _optional chaining_
operator is used here because `app` can potentially be null at runtime. The
`appendChild` method is defined by:
    ts
    appendChild<T extends Node>(newChild: T): T;
This method works similarly to the `createElement` method as the generic
parameter `T` is inferred from the `newChild` argument. `T` is _constrained_
to another base interface `Node`.
## Difference between `children` and `childNodes`
Previously, this document details the `HTMLElement` interface extends from
`Element` which extends from `Node`. In the DOM API there is a concept of
_children_ elements. For example in the following HTML, the `p` tags are
children of the `div` element
    tsx
    <div>
      <p>Hello, World</p>
      <p>TypeScript!</p>
    </div>;
    const div = document.getElementsByTagName("div")[0];
    div.children;
    // HTMLCollection(2) [p, p]
    div.childNodes;
    // NodeList(2) [p, p]
After capturing the `div` element, the `children` prop will return an
`HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes`
property will return a similar `NodeList` list of nodes. Each `p` tag will
still be of type `HTMLParagraphElements`, but the `NodeList` can contain
additional _HTML nodes_ that the `HTMLCollection` list cannot.
Modify the HTML by removing one of the `p` tags, but keep the text.
    tsx
    <div>
      <p>Hello, World</p>
      TypeScript!
    </div>;
    const div = document.getElementsByTagName("div")[0];
    div.children;
    // HTMLCollection(1) [p]
    div.childNodes;
    // NodeList(2) [p, text]
See how both lists change. `children` now only contains the `<p>Hello,
World</p>` element, and the `childNodes` contains a `text` node rather than
two `p` nodes. The `text` part of the `NodeList` is the literal `Node`
containing the text `TypeScript!`. The `children` list does not contain this
`Node` because it is not considered an `HTMLElement`.
## The `querySelector` and `querySelectorAll` methods
Both of these methods are great tools for getting lists of dom elements that
fit a more unique set of constraints. They are defined in _lib.dom.d.ts_ as:
    ts
    /**
     * Returns the first element that is a descendant of node that matches selectors.
     */
    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
    querySelector<E extends Element = Element>(selectors: string): E | null;
    /**
     * Returns all element descendants of node that match selectors.
     */
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
The `querySelectorAll` definition is similar to `getElementsByTagName`, except
it returns a new type: `NodeListOf`. This return type is essentially a custom
implementation of the standard JavaScript list element. Arguably, replacing
`NodeListOf<E>` with `E[]` would result in a very similar user experience.
`NodeListOf` only implements the following properties and methods: `length`,
`item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing.
Additionally, this method returns a list of _elements_ , not _nodes_ , which
is what `NodeList` was returning from the `.childNodes` method. While this may
appear as a discrepancy, take note that interface `Element` extends from
`Node`.
To see these methods in action modify the existing code to:
    tsx
    <ul>
      <li>First :)</li>
      <li>Second!</li>
      <li>Third times a charm.</li>
    </ul>;
    const first = document.querySelector("li"); // returns the first li element
    const all = document.querySelectorAll("li"); // returns the list of all li elements
## Interested in learning more?
The best part about the _lib.dom.d.ts_ type definitions is that they are
reflective of the types annotated in the Mozilla Developer Network (MDN)
documentation site. For example, the `HTMLElement` interface is documented by
this [HTMLElement
page](https://developer.mozilla.org/docs/Web/API/HTMLElement) on MDN. These
pages list all available properties, methods, and sometimes even examples.
Another great aspect of the pages is that they provide links to the
corresponding standard documents. Here is the link to the [W3C Recommendation
for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement).
Sources:
  * [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)
  * [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/DOM Manipulation.md)
‚ù§
Contributors to this page:  
EA
OT
SA
M
IO
6+
Last updated: Sep 16, 2024  
Was this page helpful?
# Enums
Enums are one of the few features TypeScript has which is not a type-level
extension of JavaScript.
Enums allow a developer to define a set of named constants. Using enums can
make it easier to document intent, or create a set of distinct cases.
TypeScript provides both numeric and string-based enums.
## Numeric enums
We‚Äôll first start off with numeric enums, which are probably more familiar if
you‚Äôre coming from other languages. An enum can be defined using the `enum`
keyword.
    ts
    enum Direction {
      Up = 1,
      Down,
      Left,
      Right,
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQCMANAbBgO4h2EAywAZqq1AEpwA5gAseeAL5A)
Above, we have a numeric enum where `Up` is initialized with `1`. All of the
following members are auto-incremented from that point on. In other words,
`Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right`
has `4`.
If we wanted, we could leave off the initializers entirely:
    ts
    enum Direction {
      Up,
      Down,
      Left,
      Right,
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBZt4AvkA)
Here, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-
incrementing behavior is useful for cases where we might not care about the
member values themselves, but do care that each value is distinct from other
values in the same enum.
Using an enum is simple: just access any member as a property off of the enum
itself, and declare types using the name of the enum:
    ts
    enum UserResponse {
      No = 0,
      Yes = 1,
    }
    function respond(recipient: string, message: UserResponse): void {
      // ...
    }
    respond("Princess Caroline", UserResponse.Yes);
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAqgzsATgJWHADgexAqBvAKCigDlMoBeKABgBoioBNNSqARnoF8CCAzMEAGMALgEtsURGiwgAJgAopg0elGhhALihxhiUSADmtKBDRwAhgeBb4SVBmwIAlFoBumUbPwMA9D6gAdEEE3ARSDnLyAEQACnpCZlAAwuaImAA2+sBRxrYo0o7AAcxwTgDcQA)
Numeric enums can be mixed in computed and constant members (see below). The
short story is, enums without initializers either need to be first, or have to
come after numeric enums initialized with numeric constants or other constant
enum members. In other words, the following isn‚Äôt allowed:
    ts
    enum E {
      A = getSomeValue(),
      B,
    Enum member must have initializer.1061Enum member must have initializer.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYBsaBQBjOAO0QBdQBzSUgZTgFtIA1AQwBsBXSUAXlAAoAlLwB8oAEwBmANy4QoALRL8HUkoW5IRDvVABRUAG9coUAEFelanUatOkIQBoToAELOAvkA)
## String enums
String enums are a similar concept, but have some subtle runtime differences
as documented below. In a string enum, each member has to be constant-
initialized with a string literal, or with another string enum member.
    ts
    enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQBERAClQDQGwYDu2lVMA8gOoByjZgBlgAM1QVqwgKIAxACpDCAJTgBzABaTOKgJIBxABJKmAXyA)
While string enums don‚Äôt have auto-incrementing behavior, string enums have
the benefit that they ‚Äúserialize‚Äù well. In other words, if you were debugging
and had to read the runtime value of a numeric enum, the value is often opaque
- it doesn‚Äôt convey any useful meaning on its own (though reverse mapping can
often help). String enums allow you to give a meaningful and readable value
when your code runs, independent of the name of the enum member itself.
## Heterogeneous enums
Technically enums can be mixed with string and numeric members, but it‚Äôs not
clear why you would ever want to do so:
    ts
    enum BooleanLikeHeterogeneousEnum {
      No = 0,
      Yes = "YES",
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAQg9nANsAhiAMgSwNbABLAAuwATnAOajBxgDOAouNAN4BQUUAcnFALxQAGADTsoATWC0+UAERj6AZRkiAvkA)
Unless you‚Äôre really trying to take advantage of JavaScript‚Äôs runtime behavior
in a clever way, it‚Äôs advised that you don‚Äôt do this.
## Computed and constant members
Each enum member has a value associated with it which can be either _constant_
or _computed_. An enum member is considered constant if:
  * It is the first member in the enum and it has no initializer, in which case it‚Äôs assigned the value `0`:
        ts
    // E.X is constant:
    enum E {
      X,
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEFEDoA1QSwM6gMYHsB2CAuBDdWAuAKAFN0BXAWwlAG8jRRoAaIgXyA)
  * It does not have an initializer and the preceding enum member was a _numeric_ constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.
        ts
    // All enum members in 'E1' and 'E2' are constant.
    enum E1 {
      X,
      Y,
      Z,
    }
    enum E2 {
      A = 1,
      B,
      C,
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEEEBtNBTA7ArgW1M2yBGsBOBnUAS3lAHIBRARlNAEN4ATM8gJhtp1lAGMB7ePABd6ggHQAocQhSgqoAN7jQoABoAaJaACaG5QC0NAX0nTUrBZvCgAvKEq7QAIQcBhI0A)
  * The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:
    1. a literal enum expression (basically a string literal or a numeric literal)
    2. a reference to previously defined constant enum member (which can originate from a different enum)
    3. a parenthesized constant enum expression
    4. one of the `+`, `-`, `~` unary operators applied to constant enum expression
    5. `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands
It is a compile time error for constant enum expressions to be evaluated to
`NaN` or `Infinity`.
In all other cases enum member is considered computed.
    ts
    enum FileAccess {
      // constant members
      None,
      Read = 1 << 1,
      Write = 1 << 2,
      ReadWrite = Read | Write,
      // computed member
      G = "123".length,
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAYglgG2AQQMauAZ01A3gKCigHpipUB7ETAFwEMQaoJgIAjYAJ00KgDkqwADS8ASsDoATKAF4oARigAeJQpFEA6pzg1gshctUAmdVHFStOvXPPSAPlEu7TpchQgAHMLukt2XXgBxfQAieSMAZhCAOiQQAHMaAAsRAF8gA)
## Union enums and enum member types
There is a special subset of constant enum members that aren‚Äôt calculated:
literal enum members. A literal enum member is a constant enum member with no
initialized value, or with values that are initialized to
  * any string literal (e.g. `"foo"`, `"bar"`, `"baz"`)
  * any numeric literal (e.g. `1`, `100`)
  * a unary minus applied to any numeric literal (e.g. `-1`, `-100`)
When all members in an enum have literal enum values, some special semantics
come into play.
The first is that enum members also become types as well! For example, we can
say that certain members can _only_ have the value of an enum member:
    ts
    enum ShapeKind {
      Circle,
      Square,
    }
    interface Circle {
      kind: ShapeKind.Circle;
      radius: number;
    }
    interface Square {
      kind: ShapeKind.Square;
      sideLength: number;
    }
    let c: Circle = {
      kind: ShapeKind.Square,
    Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
      radius: 100,
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFCQHYCuAtqAMoAWAhgA6QDSAlvgCagDeOooAwo9AGMANpAA0XcgEdCVaGJwBfHDmYAXGADMqAyL37DdnbgGtmLVJVoMzAOj6CRAbgnQqLRoRSgixAEYxnJRV8dWgtHSkZOQ4JU1YLajomVhsyaVlIZ25ERhZIABkCAHNVClQff2hA5RFVUAFUewNQAF4YkzMEq2SWVPS5cW5Xd09UAEYABgnxBUcgA)
The other change is that enum types themselves effectively become a _union_ of
each enum member. With union enums, the type system is able to leverage the
fact that it knows the exact set of values that exist in the enum itself.
Because of that, TypeScript can catch bugs where we might be comparing values
incorrectly. For example:
    ts
    enum E {
      Foo,
      Bar,
    }
    function f(x: E) {
      if (x !== E.Foo || x !== E.Bar) {
    This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.
        //
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUJAHYCuAtqAKKgDeeooAYnHADR2gBCAhtGwL548AM2KEAxgBcAlnEKghACgAeqCgEoa7KUNDLQAQgC8hygDomcUAB8roJQeNnu0DbXr0Q7AXyA)
In that example, we first checked whether `x` was _not_ `E.Foo`. If that check
succeeds, then our `||` will short-circuit, and the body of the ‚Äòif‚Äô will run.
However, if the check didn‚Äôt succeed, then `x` can _only_ be `E.Foo`, so it
doesn‚Äôt make sense to see whether it‚Äôs _not_ equal to `E.Bar`.
## Enums at runtime
Enums are real objects that exist at runtime. For example, the following enum
    ts
    enum E {
      X,
      Y,
      Z,
    }
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfIA)
can actually be passed around to functions
    ts
    enum E {
      X,
      Y,
      Z,
    }
    function f(obj: { X: number }) {
      return obj.X;
    }
    // Works, since 'E' has a property named 'X' which is a number.
    f(E);
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfRRAMzBAGMAXASwHsQoyAKBgIwCsAuBNPuAgdgAJyhEAlAiyjgNMKOacuAOlQBuRCUQB6XVADqDUQGsAzuijm61YFADkMB1AAWAQ3NR3UAA6iGXzEaAE8oEHcIYAATR1QXAHdXOipXKDovHyERUVVyVhhJDSA)
## Enums at compile time
Even though Enums are real objects that exist at runtime, the `keyof` keyword
works differently than you might expect for typical objects. Instead, use
`keyof typeof` to get a Type that represents all Enum keys as strings.
    ts
    enum LogLevel {
      ERROR,
      WARN,
      INFO,
      DEBUG,
    }
    /**
     * This is equivalent to:
     * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
     */
    type LogLevelStrings = keyof typeof LogLevel;
    function printImportant(key: LogLevelStrings, message: string) {
      const num = LogLevel[key];
      if (num <= LogLevel.WARN) {
        console.log("Log level key is:", key);
        console.log("Log level value is:", num);
        console.log("Log level message is:", message);
      }
    }
    printImportant("ERROR", "This is a message");
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAMg9gcxsAbsANlA3gKClAUQCUiB5IgGjygHUBBIgOSvwElGAxUlqAEQIBCAVQDiVAL44cAegBUsvLKgAVABYBLAM5QtUYAEcw6lAEN0oAC5QLcAFyLrATwAOwWImRp0AZQsAndRAEbQBeKAByYjIicKgAHwj6JliE8PYuFIj+YRFwgG5FaRwLFzd4JFQMXwCg0KgAa2BHOAAzJ1dW9wqvApwWsBAAYwt1OBAoZxqLVghnOD8LExALAApGx1suzyr-QOCKKAhgTU0TBGBNzV2ggEpsakGxq6hwaDDy7fQAbXWAXQL8Oo2itXlAADzvDyVdAAOiSjDuuHw+EeIE0cHMMPQiBWACJylBzF4Gk0dJpbLiDusbgDkaj0ZjsQg8QSiRgoKZ0GA3FoKQdXjTqCinhjgFicfjEIToYdjqdzmS+bKTmdgIL8JJJJNAtNZvNFss8VFyJSoLi1LpdCZlfLgLiaUA)
### Reverse mappings
In addition to creating an object with property names for members, numeric
enums members also get a _reverse mapping_ from enum values to enum names. For
example, in this example:
    ts
    enum Enum {
      A,
    }
    let a = Enum.A;
    let nameOfA = Enum[a]; // "A"
    [Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAou0G8BQUoEEA0SC+SkBtgAXKAQygF5Z4A6NAbgOKhFImAHkAzNS6yANqkAuvSgB6cVABEaaUA)
TypeScript compiles this down to the following JavaScript:
    ts
    "use strict";
    var Enum;
    (function (Enum) {
        Enum[Enum["A"] = 0] = "A";
    })(Enum || (Enum = {}));
    let a = Enum.A;
    let nameOfA = Enum[a]; // "A"
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMB2BXZURAogb01FAEEAaTAX00wBtt1QBDUAXmNIB01ANyt2oXJ2TYA8gDNqvfoQDanALrDQIUACJquoA)
In this generated code, an enum is compiled into an object that stores both
forward (`name` -> `value`) and reverse (`value` -> `name`) mappings.
References to other enum members are always emitted as property accesses and
never inlined.
Keep in mind that string enum members _do not_ get a reverse mapping generated
at all.
### `const` enums
In most cases, enums are a perfectly valid solution. However sometimes
requirements are tighter. To avoid paying the cost of extra generated code and
additional indirection when accessing enum values, it‚Äôs possible to use
`const` enums. Const enums are defined using the `const` modifier on our
enums:
    ts
    const enum Enum {
      A = 1,
      B = A * 2,
    }
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUSag3gKBjAQRgF4YBGAGjxgCETCYAqGAJioF8g)
Const enums can only use constant enum expressions and unlike regular enums
they are completely removed during compilation. Const enum members are inlined
at use sites. This is possible since const enums cannot have computed members.
    ts
    const enum Direction {
      Up,
      Down,
      Left,
      Right,
    }
    let directions = [
      Direction.Up,
      Direction.Down,
      Direction.Left,
      Direction.Right,
    ];
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgEQJYCc7Ch8GAbwCgYYBVABwBoz0QB3MO8gGTgDMpWYAlDAHMAFjxIBfEiQA2cWABNsufOAgwAvDADa9TDjwEwAOmq89yw0bRMWupQfBGO3M-ZXGBIsQF0A3EA)
in generated code will become
    ts
    "use strict";
    let directions = [
        0 /* Direction.Up */,
        1 /* Direction.Down */,
        2 /* Direction.Left */,
        3 /* Direction.Right */,
    ];
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VABFUAnY7dVfUAb01FAFUAHAGg7UEeAZwAyxAGbpRoAEqoA5tBmYAvpkwAbYkQAmdBk3yRQAXlABtQTXqNmeAHS9Ztow8dVhrw-fyOJaR87YycFZVUAXQBuIA)
#### Const enum pitfalls
Inlining enum values is straightforward at first, but comes with subtle
implications. These pitfalls pertain to _ambient_ const enums only (basically
const enums in `.d.ts` files) and sharing them between projects, but if you
are publishing or consuming `.d.ts` files, these pitfalls likely apply to you,
because `tsc --declaration` transforms `.ts` files into `.d.ts` files.
  1. For the reasons laid out in the [`isolatedModules` documentation](/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](/tsconfig#isolatedModules) and those enum values at the same time.
  2. You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B‚Äôs enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.
  3. [`importsNotUsedAsValues: "preserve"`](/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](/docs/handbook/modules/reference.html#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.
Here are two approaches to avoiding these pitfalls:
  1. Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project‚Äôs own enums is not problematic and has performance implications.
  2. Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [`preserveConstEnums`](/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).
This way downstream consumers will not inline enums from your project,
avoiding the pitfalls above, but a project can still inline its own enums,
unlike banning const enums entirely.
## Ambient enums
Ambient enums are used to describe the shape of already existing enum types.
    ts
    declare enum Enum {
      A = 1,
      B,
      C = 2,
    }
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEIB2BXAtvAoqjBvAUPPAILwC88AjADSHwBCtRAwufAEy0C+QA)
One important difference between ambient and non-ambient enums is that, in
regular enums, members that don‚Äôt have an initializer will be considered
constant if its preceding enum member is considered constant. By contrast, an
ambient (and non-const) enum member that does not have an initializer is
_always_ considered computed.
## Objects vs Enums
In modern TypeScript, you may not need an enum when an object with `as const`
could suffice:
    ts
    const enum EDirection {
      Up,
      Down,
      Left,
      Right,
    }
    const ODirection = {
      Up: 0,
      Down: 1,
      Left: 2,
      Right: 3,
    } as const;
    EDirection.Up;
    (enum member) EDirection.Up = 0
    ODirection.Up;
    (property) Up: 0
    // Using the enum as a parameter
    function walk(dir: EDirection) {}
    // It requires an extra line to pull out the values
    type Direction = typeof ODirection[keyof typeof ODirection];
    function run(dir: Direction) {}
    walk(EDirection.Left);
    run(ODirection.Right);
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUQCIEsBOdhRbgwDeAUDDAKoAOANBTBiAO5gOUAycAZlBzABKWAOYALfmQC+ZMqEiwA8tjwEiYGAF5SjWgC4YABgHM2BgIwDufAwCYBw8VAMBmBlJgBDCDHnQA3LKYuPiE4AB0tIEA9NGU8QkAegD8ssohahFRZLEJeSmyuVQQWGAiMFBicPBIqN5eMDSeOJ7IcFBwOGQ8iGCZGiyeADYA1gAUACa4BsGqYWAAlKQyOXEAkrB4AI6IIT6eGnAAHlAtMEOl1VAgjYhDQzAgiLCV1QBuw4hwEGRQAJ40aoqULqLQVAFwEA8GDpObqADaIzgfyh4MBqNhIPAAF1Aj0+vMYDhepNpkwMvMliQVoNRmNZliwOFrFAFoFiWAxpj+uFHBI2UA)
The biggest argument in favour of this format over TypeScript‚Äôs `enum` is that
it keeps your codebase aligned with the state of JavaScript, and
[when/if](https://github.com/rbuckton/proposal-enum) enums are added to
JavaScript then you can move to the additional syntax.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Enums.md) ‚ù§
Contributors to this page:  
OT
AG
FDG-S
G
TA
11+
Last updated: Sep 16, 2024  

Was this page helpful?
### This page has been deprecated
This handbook page has been replaced, [go to the new
page](/docs/handbook/2/functions.html)
[Go to new page](/docs/handbook/2/functions.html)
# Functions
Functions are the fundamental building block of any application in JavaScript.
They‚Äôre how you build up layers of abstraction, mimicking classes, information
hiding, and modules. In TypeScript, while there are classes, namespaces, and
modules, functions still play the key role in describing how to _do_ things.
TypeScript also adds some new capabilities to the standard JavaScript
functions to make them easier to work with.
## Functions
To begin, just as in JavaScript, TypeScript functions can be created both as a
named function or as an anonymous function. This allows you to choose the most
appropriate approach for your application, whether you‚Äôre building a list of
functions in an API or a one-off function to hand off to another function.
To quickly recap what these two approaches look like in JavaScript:
    ts
    // Named function
    function add(x, y) {
      return x + y;
    }
    // Anonymous function
    let myAdd = function (x, y) {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigBymAtngCYYCuAdsvAPb0HoNOuiZVUAUADwA0oAJ4BKUAG8CoULDzRaseqEGgA1OIDcBAL4EiYAIL1WY8s1qQ6jaCzbYlocmJN9QAXjtc1Q0UkZOQUlFTUNbTE9fR0gA)
Just as in JavaScript, functions can refer to variables outside of the
function body. When they do so, they‚Äôre said to _capture_ these variables.
While understanding how this works (and the trade-offs when using this
technique) is outside of the scope of this article, having a firm
understanding how this mechanic works is an important piece of working with
JavaScript and TypeScript.
    ts
    let z = 100;
    function addToZ(x, y) {
      return x + y + z;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgBeoAvKAIwAMdA3AQegK4B2y8A9h6JgAmggCo8AWgAoAHgBpQATwCUoAN4FQoWCTax+00AGpFR8swC+QA)
## Function Types
### Typing the function
Let‚Äôs add types to our simple examples from earlier:
    ts
    function add(x: number, y: number): number {
      return x + y;
    }
    let myAdd = function (x: number, y: number): number {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAQwCaoBQA8BciwgC2ARgKYBOANIgJ54EkUCU9RZ5iA3gFCKLmkoIckiyIA1LQDc3AL7duAG0GJCNAILpEAXkShIsBImytGVWqfYt8bCl179Bw0ROlypQA)
We can add types to each of the parameters and then to the function itself to
add a return type. TypeScript can figure the return type out by looking at the
return statements, so we can also optionally leave this off in many cases.
### Writing the function type
Now that we‚Äôve typed the function, let‚Äôs write the full type of the function
out by looking at each piece of the function type.
    ts
    let myAdd: (x: number, y: number) => number = function (
      x: number,
      y: number
    ): number {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngggEwQLggCgB6oHYFcoBGIATgDQQw75HECUEAvAHwR6EmMQBmu2AxmACWAe2zoAUBAhZW1EqUkUq7YuNrKaEAN6Li4XMTEYIAagoBucQF9zQA)
A function‚Äôs type has the same two parts: the type of the arguments and the
return type. When writing out the whole function type, both parts are
required. We write out the parameter types just like a parameter list, giving
each parameter a name and a type. This name is just to help with readability.
We could have instead written:
    ts
    let myAdd: (baseValue: number, increment: number) => number = function (
      x: number,
      y: number
    ): number {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngggEwQLggCgEYEMDOIBqWwAriKgHbFQYgBOANBAJbkDGtIUI5YFVNtAJQQAvAD4IlanVEQAZsTZgmAe3LoAUBAgAPPtIZaIMfQI2DTMgN5GOYYrXU6IAamMBuDQF93QA)
As long as the parameter types line up, it‚Äôs considered a valid type for the
function, regardless of the names you give the parameters in the function
type.
The second part is the return type. We make it clear which is the return type
by using an arrow (`=>`) between the parameters and the return type. As
mentioned before, this is a required part of the function type, so if the
function doesn‚Äôt return a value, you would use `void` instead of leaving it
off.
Of note, only the parameters and the return type make up the function type.
Captured variables are not reflected in the type. In effect, captured
variables are part of the ‚Äúhidden state‚Äù of any function and do not make up
its API.
### Inferring the types
In playing with the example, you may notice that the TypeScript compiler can
figure out the type even if you only have types on one side of the equation:
    ts
    // The parameters 'x' and 'y' have the type number
    let myAdd = function (x: number, y: number): number {
      return x + y;
    };
    // myAdd has the full function type
    let myAdd2: (baseValue: number, increment: number) => number = function (x, y) {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIM6gOQAe+oCAdgCYECeJkCAbrBjKBtXLGQK6oBG2AFAAbTKFTUAghSoBeUADNuZAMYYAlgHsyoABSEAXKB79sAGlDUjJgUgCU13rdABvQaFBJM3JDsKgAaksAbkEAX1DBEHEpGVB6PBZYJWFhRWU1LR12ThExCWkKACYjXT4EHGgANQRhbmhHUyQLdVUvdDIMRts7UFkAPmMnbD701Q1tPUILal63Dy8MHz9AkPDgoA)
This is called ‚Äúcontextual typing‚Äù, a form of type inference. This helps cut
down on the amount of effort to keep your program typed.
## Optional and Default Parameters
In TypeScript, every parameter is assumed to be required by the function. This
doesn‚Äôt mean that it can‚Äôt be given `null` or `undefined`, but rather, when
the function is called, the compiler will check that the user has provided a
value for each parameter. The compiler also assumes that these parameters are
the only parameters that will be passed to the function. In short, the number
of arguments given to a function has to match the number of parameters the
function expects.
    ts
    function buildName(firstName: string, lastName: string) {
      return firstName + " " + lastName;
    }
    let result1 = buildName("Bob"); // error, too few parameters
    Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.
    let result3 = buildName("Bob", "Adams"); // ah, just right
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIYiVOkBKUAG9coUNEjlC0WgKErQAalAAiezYVLh3SAG5cAX1y4mxw0hEQiZyAEZQAF56RlYVXjsAITg6O013UBBQGHhoeXI4OFB8SAB3UAAHDmg3chhEPwCjYNC0KJjmdjcE5NT5OwBBFm5EO36AZWgAOjSMrJyEfMLQLg5iAE9K6tr6xvJAlvIAZnaGTviklLH7IZHZzLAOAAt5ACtCcUNKaSfyIA)
In JavaScript, every parameter is optional, and users may leave them off as
they see fit. When they do, their value is `undefined`. We can get this
functionality in TypeScript by adding a `?` to the end of parameters we want
to be optional. For example, let‚Äôs say we want the last name parameter from
above to be optional:
    ts
    function buildName(firstName: string, lastName?: string) {
      if (lastName) return firstName + " " + lastName;
      else return firstName;
    }
    let result1 = buildName("Bob"); // works correctly now
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    Expected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.
    let result3 = buildName("Bob", "Adams"); // ah, just right
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIAfjESp0gJSgA3rlChK+UL0XLukXdEjlC0WgKErQAalAAiL+4VLhVgDchqCQTIiQoLb2jqDOljzBAL64uEx2UZCIhEzkAIygALz0jKwqvJ4AQnB0ntqBoCCgAO4IANaIoKQIthRMAJ6gxHDNaRm22bloRSXM7FYV1bXyngCCLNyInisAytAAdHUNTTDw0PLkcHCgXBzEgwAOHNBW5DCIY+SZk+QAzDMMOblKo1bZedabI6NMAcAAW8gAVoRxFFKNJYeQgA)
Any optional parameters must follow required parameters. Had we wanted to make
the first name optional, rather than the last name, we would need to change
the order of parameters in the function, putting the first name last in the
list.
In TypeScript, we can also set a value that a parameter will be assigned if
the user does not provide one, or if the user passes `undefined` in its place.
These are called default-initialized parameters. Let‚Äôs take the previous
example and default the last name to `"Smith"`.
    ts
    function buildName(firstName: string, lastName = "Smith") {
      return firstName + " " + lastName;
    }
    let result1 = buildName("Bob"); // works correctly now, returns "Bob Smith"
    let result2 = buildName("Bob", undefined); // still works, also returns "Bob Smith"
    let result3 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    Expected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.
    let result4 = buildName("Bob", "Adams"); // ah, just right
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceqROWiViAcwA0oJh3EjIoALygARAGUulcgAtNASlABvXKFDRI5QtFoChK0AGotH94uXdIAblwAX1xcJltrSERCJnIARnV6RlYVXk0AITg6Ez9QEFAAdwQAa0RQUgQbCiYAT1BiOHz5GzsHUvTM0F19I1DwmyiYtASGZnZfVIys+RIWSAFiSBZjHLzxZiYC4sR5DiZEOAiW4jbJzr1DTV7yCIHyAGZhpLGeCczNeU0AQRZuRHetbTQAB02VyYBg8Gg8nIcAOXA4xFqAAcONBfOQYIgrjdouRsI9Ril2lMtN9fqC8hwDPIAFaEcTWSjSAzkIA)
Default-initialized parameters that come after all required parameters are
treated as optional, and just like optional parameters, can be omitted when
calling their respective function. This means optional parameters and trailing
default parameters will share commonality in their types, so both
    ts
    function buildName(firstName: string, lastName?: string) {
      // ...
    }
and
    ts
    function buildName(firstName: string, lastName = "Smith") {
      // ...
    }
share the same type `(firstName: string, lastName?: string) => string`. The
default value of `lastName` disappears in the type, only leaving behind the
fact that the parameter is optional.
Unlike plain optional parameters, default-initialized parameters don‚Äôt _need_
to occur after required parameters. If a default-initialized parameter comes
before a required parameter, users need to explicitly pass `undefined` to get
the default initialized value. For example, we could write our last example
with only a default initializer on `firstName`:
    ts
    function buildName(firstName = "Will", lastName: string) {
      return firstName + " " + lastName;
    }
    let result1 = buildName("Bob"); // error, too few parameters
    Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.
    let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameters
    Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.
    let result3 = buildName("Bob", "Adams"); // okay and returns "Bob Adams"
    let result4 = buildName(undefined, "Adams"); // okay and returns "Will Adams"
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jQAjQygGwBMA5AQwFtIAKfSknKceoALygARAHVmTSQBpQTDomHdIqNdErEA5gEpQAb1yhQ0SOULRaAoSMigA1FLeuVaxwG5cAX1xcJisLSERCJnIARnF6RlZHXkkAITg6SQNvUBBQGHhoJXI4OFB8SAB3UAAHDmgNchhEIJDLcMi0WIZmdg0k1PSlSQBBFm5ERSkAZWgAOgysnLyEQuLQLg5iAE9q2vrG5vJQtvIAZk74np4+tInh0a5xzOywOABrDm2NllDrW0QpfqgEZjSQHI4RcjYc7dRIkFiQATESAsQbAh7zZ6gN4fUBfH42Yj-GRyIH3cZAA)
### Rest Parameters
Required, optional, and default parameters all have one thing in common: they
talk about one parameter at a time. Sometimes, you want to work with multiple
parameters as a group, or you may not know how many parameters a function will
ultimately take. In JavaScript, you can work with the arguments directly using
the `arguments` variable that is visible inside every function body.
In TypeScript, you can gather these arguments together into a variable:
    ts
    function buildName(firstName: string, ...restOfName: string[]) {
      return firstName + " " + restOfName.join(" ");
    }
    // employeeName will be "Joseph Samuel Lucas MacKinzie"
    let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIxDANgEwHIEMC2ApgBTAwBOAzlHkQFyLXkxgDmANIgHQ-mHUB5YLUIMmLVgG0AugEpEAbwBQiRHyghySMlRoFCiANSIARKaNr+UISK4ArOC2JmTsgNxKAvkqUB6X4iE+AAO6HAAnoSEIogA7hjoKAYmAFJwlITBABaIAMoEIISJADIgELiUiACyuBAA0iwAXjCEJkrohFCBIWGR0fqIALwoaFgizmkZ2SacJvn4hegzpqXllMsmNfVNLa5uQA)
_Rest parameters_ are treated as a boundless number of optional parameters.
When passing arguments for a rest parameter, you can use as many as you want;
you can even pass none. The compiler will build an array of the arguments
passed in with the name given after the ellipsis (`...`), allowing you to use
it in your function.
The ellipsis is also used in the type of the function with rest parameters:
    ts
    function buildName(firstName: string, ...restOfName: string[]) {
      return firstName + " " + restOfName.join(" ");
    }
    let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIxDANgEwHIEMC2ApgBTAwBOAzlHkQFyLXkxgDmANIgHQ-mHUB5YLUIMmLVgG0AugEpEAbwBQiRHyghySMlRoFCiANSIARKaNr+UISK4ArOC2JmTsgNxKAvkqXpCUFDQsEQAxcAZSMH0xKGY2Th4uPmoYuKk5RABeAD5GWIkswIwcfTcgA)
## `this`
Learning how to use `this` in JavaScript is something of a rite of passage.
Since TypeScript is a superset of JavaScript, TypeScript developers also need
to learn how to use `this` and how to spot when it‚Äôs not being used correctly.
Fortunately, TypeScript lets you catch incorrect uses of `this` with a couple
of techniques. If you need to learn how `this` works in JavaScript, though,
first read Yehuda Katz‚Äôs [Understanding JavaScript Function Invocation and
‚Äúthis‚Äù](http://yehudakatz.com/2011/08/11/understanding-javascript-function-
invocation-and-this/). Yehuda‚Äôs article explains the inner workings of `this`
very well, so we‚Äôll just cover the basics here.
### `this` and arrow functions
In JavaScript, `this` is a variable that‚Äôs set when a function is called. This
makes it a very powerful and flexible feature, but it comes at the cost of
always having to know about the context that a function is executing in. This
is notoriously confusing, especially when returning a function or passing a
function as an argument.
Let‚Äôs look at an example:
    ts
    let deck = {
      suits: ["hearts", "spades", "clubs", "diamonds"],
      cards: Array(52),
      createCardPicker: function () {
        return function () {
          let pickedCard = Math.floor(Math.random() * 52);
          let pickedSuit = Math.floor(pickedCard / 13);
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
        };
      },
    };
    let cardPicker = deck.createCardPicker();
    let pickedCard = cardPicker();
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgAmeiA1qALygDeBookArvNJGgNoBEACzyZYXPgBpQfSAAdMFSBKmJsbAEaLJfMvEwBbAPYA7MooC645qEQjTaAIKxYmAJ4AKAKwAmAJSWWiLDC0HgAwrYACkhUeLBo6GxGyPDGoG4+jFYsQdBssEYYicmp6Zks5aDEpDLReGThsGR0oACymNACAHTo2AYGsG5tHZ3OJgZ6pQBUoN4+ANxZ5VWgNdR1AMocpPRDXT19A6sx9bagYACMAMzzBIvZJHkFDKxbaB3wkJ3snJA8RxtbCzWWxof4nRqgACkoCuoAAvgsKgirHDLMiiCRgY0omtYM0KNROoFgmFIrUBjdlmCGk16DZseT0gsCDhYtA3Hx6WQ0HxQABqFa1cFkImnAW8gzoKT8wVrYVfLbzIA)
Notice that `createCardPicker` is a function that itself returns a function.
If we tried to run the example, we would get an error instead of the expected
alert box. This is because the `this` being used in the function created by
`createCardPicker` will be set to `window` instead of our `deck` object.
That‚Äôs because we call `cardPicker()` on its own. A top-level non-method
syntax call like this will use `window` for `this`. (Note: under strict mode,
`this` will be `undefined` rather than `window`).
We can fix this by making sure the function is bound to the correct `this`
before we return the function to be used later. This way, regardless of how
it‚Äôs later used, it will still be able to see the original `deck` object. To
do this, we change the function expression to use the ECMAScript 6 arrow
syntax. Arrow functions capture the `this` where the function is created
rather than where it is invoked:
    ts
    let deck = {
      suits: ["hearts", "spades", "clubs", "diamonds"],
      cards: Array(52),
      createCardPicker: function () {
        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here
        return () => {
          let pickedCard = Math.floor(Math.random() * 52);
          let pickedSuit = Math.floor(pickedCard / 13);
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
        };
      },
    };
    let cardPicker = deck.createCardPicker();
    let pickedCard = cardPicker();
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SgAmeiA1qALygDeBookArvNJGgNoBEACzyZYXPgBpQfSAAdMFSBKmJsbAEaLJfMvEwBbAPYA7MooC645qEQjTaAIKxYmAJ4AKAKwAmAJSWWiLDC0HgAwrYACkhUeLBo6GxGyPDGoG4+jFYsIKAAcgDyACoAomjQQqDY8EZ4oGp42AYA7qDwkKBGzaCYRt1OXQlJ0ClGkjiNTdUA5qBs7dAG1pgy0GxBoADk5W0boAhTAqRCQVl7JGu96XQAfJks95UkoDLReGThsGR0oACymOUAOnQjQMsDcf0BzhMBj0VwAVKBvD4ANynFjEUgvahvADKHFI9AhAiBILBWJi71soDAAEYAMwoghos6rWC9BisfFlARtAHsTiQHjk3H4ixLT5oYWUz6gACkoHpoAAvqiHiqrErLOqiE8bJ8otjYN8KNQAYFgmFIq8wYyMc9XtKvvQ9WQDTEbaiCDhYtA3HwXWg+KAANT27GOs1U0NBgzoKQhsMUj5kPn4lFAA)
Even better, TypeScript will warn you when you make this mistake if you pass
the [`noImplicitThis`](/tsconfig#noImplicitThis) flag to the compiler. It will
point out that `this` in `this.suits[pickedSuit]` is of type `any`.
### `this` parameters
Unfortunately, the type of `this.suits[pickedSuit]` is still `any`. That‚Äôs
because `this` comes from the function expression inside the object literal.
To fix this, you can provide an explicit `this` parameter. `this` parameters
are fake parameters that come first in the parameter list of a function:
    ts
    function f(this: void) {
      // make sure `this` is unusable in this standalone function
    }
Let‚Äôs add a couple of interfaces to our example above, `Card` and `Deck`, to
make the types clearer and easier to reuse:
    ts
    interface Card {
      suit: string;
      card: number;
    }
    interface Deck {
      suits: string[];
      cards: number[];
      createCardPicker(this: Deck): () => Card;
    }
    let deck: Deck = {
      suits: ["hearts", "spades", "clubs", "diamonds"],
      cards: Array(52),
      // NOTE: The function now explicitly specifies that its callee must be of type Deck
      createCardPicker: function (this: Deck) {
        return () => {
          let pickedCard = Math.floor(Math.random() * 52);
          let pickedSuit = Math.floor(pickedCard / 13);
          return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
        };
      },
    };
    let cardPicker = deck.createCardPicker();
    let pickedCard = cardPicker();
    alert("card: " + pickedCard.card + " of " + pickedCard.suit);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJygE2QbwFDLIDOArsGAFzFhSgDmA3AcghplSCQLYBG0TAXzx5QkWIhQARCAgDWuZqXJEqRGvQDaAXSaFWWFck69o23SygQ4kdFgAKwOdAAUYABbBD0uQEoqzn2QAXgA+NDZBYQAbCDBkTBlZKm95IIVCJTBDDQAiNysoLJyAGmQcogAHOASiErKEKJIeWtKczGA4LgB7EExarWLmfT6qAEEoKDgAT2cAVgAmH0HCAHoV5AA5AHkAFQBRKh385BgSEAQwYB6jLoB3ZAgADwqox3IoqeIKmWAYYAgiMh3NZkMoWHAojEUFwSGpkHxkF0YECpt9kCkhpZrBBbJgHE4oFRTudLtdXB4vIlAvhCIRLGASFAQMgAsEwjTaYQYnEKo5ZBBMLjgsgALLWNwAOhgUS6XSgzjF7glk16XS4rIAVMgFj5zJzucheU5MABlMhxNKKyXS2Xyo38wVsZDrACMAGZdcJOXTYozmThiOaqO5PBLMkQNPaBWbyANwVgqFHHVhkABSZDu5ACPVZ8wCQbZ6KxeN4vnQYUJOQShBYmxsfH8+Weg1JoVpYYNlyevAQ6BgZw5YZUHLIADUhrLycw1ad45HSLKY4nxtxYfNuqAA)
Now TypeScript knows that `createCardPicker` expects to be called on a `Deck`
object. That means that `this` is of type `Deck` now, not `any`, so
[`noImplicitThis`](/tsconfig#noImplicitThis) will not cause any errors.
#### `this` parameters in callbacks
You can also run into errors with `this` in callbacks, when you pass functions
to a library that will later call them. Because the library that calls your
callback will call it like a normal function, `this` will be `undefined`. With
some work you can use `this` parameters to prevent errors with callbacks too.
First, the library author needs to annotate the callback type with `this`:
    ts
    interface UIElement {
      addClickListener(onclick: (this: void, e: Event) => void): void;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoEkCiAbCBbCcZAbwChlk4ATKgYW2AQGsAZYAZ0hGgAoB7EAgbMAXMh5gAFhzEA3PsCoAaZBDGZZhMAEpkAXgB8yeYu1yFVANykAvkA)
`this: void` means that `addClickListener` expects `onclick` to be a function
that does not require a `this` type. Second, annotate your calling code with
`this`:
    ts
    class Handler {
      info: string;
      onClickBad(this: Handler, e: Event) {
        // oops, used `this` here. using this callback would crash at runtime
        this.info = e.message;
      }
    }
    let h = new Handler();
    uiElement.addClickListener(h.onClickBad); // error!
    Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.
      The 'this' types of each signature are incompatible.
        Type 'void' is not assignable to type 'Handler'.2345Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.
      The 'this' types of each signature are incompatible.
        Type 'void' is not assignable to type 'Handler'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAgR6ywD2skaATAMwAsArAfAHbSlaJ6gCqASQCi2PAFs8HUAG8CoUJgAmigMLYkAawAy8GJNIAKcm0TrEGtAegALXWgBu5eIoA0oPGiH3J0AJSgAXgA+UEdnXwcnRQBuAgBfVg4uTB5QLx8ZOVAJSEhMAHMPUBgENnzYhMU8U0xYXkRjGFAAV3gRcR80QXaJDljiAFohxGboIYGCGtzQAAlMNkVRWEz5dnRyNBL2cqzjNU0AISUrW2pZ+cXSNyL0jn9ZeXlicnIAB0g3ZvxFUAADG10v1A1lIeAAdC1INtQADIKBEDhsAAjFIaUAAd3IzWwP0QsEwkGsCmgoFgzQ48AkWXksLBa3IgXcYJyeUKsXkCQSBFEJKJAVAbDw6POCyWBl8sVaPR8YKUqjM2l0nEFsAM1jBewVR0UEtAxFIFFgAEIgA)
With `this` annotated, you make it explicit that `onClickBad` must be called
on an instance of `Handler`. Then TypeScript will detect that
`addClickListener` requires a function that has `this: void`. To fix the
error, change the type of `this`:
    ts
    class Handler {
      info: string;
      onClickGood(this: void, e: Event) {
        // can't use `this` here because it's of type void!
        console.log("clicked!");
      }
    }
    let h = new Handler();
    uiElement.addClickListener(h.onClickGood);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDwB20esWieoAqgJICi2eAtnqaAN4GiiYAm-AMLYkAawAy8GO3IAKAPbFEoxGLRzoAC2loAbgvj8ANKDxoGe9tACUoALwA+UAaM39h-gG4CAXyKk5JTUltZcPKBskJCYAObmoDAIxLE+-vx4Kpiw1IhKMKAArvBMrNZo9KVspD4goAC0jYiF0I31BFnRoAASmMT8zLDhvCToCmhJJKkRSiLiAOIKCvyaOpAeRqYJoaR23Ly8dYh9AOTQRfigAAba0legWuTUAEaZmIWX8NAnkKAK6KBoABPAAO1Fc-AAhBFeHliJAFMwAHTYBSxOQAIhU4jwUIxNh8vH8-gIzHOWgcoGIeAA7j0+gN5ASCMUqtYkQJhKpJNIyNTYHItEjZtzFssCUA)
Because `onClickGood` specifies its `this` type as `void`, it is legal to pass
to `addClickListener`. Of course, this also means that it can‚Äôt use
`this.info`. If you want both then you‚Äôll have to use an arrow function:
    ts
    class Handler {
      info: string;
      onClickGood = (e: Event) => {
        this.info = e.message;
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDwB20esWieoAqgJICi2eAtnqaAN4GiiYAm-AMLYkAawAy8GO3IAKAPbFEoxGLRzoAC2loAbgvj8ANKDxoGe9tACUoALwA+UAaM39h-gG4CAXyKk5JTUltZcPKBskJCYAObmoDAIxLE+-vx4Kpiw1IhKMKAArvBMrNZo9KVspD4goAC0jYiF0I31BFnRoAASmMT8zLDhvCToCmhJJKkRSiLiAOIKCvwOoHIJoaR2TsO8oNrSAHSjCqt4h1Ex8T68vmlAA)
This works because arrow functions use the outer `this`, so you can always
pass them to something that expects `this: void`. The downside is that one
arrow function is created per object of type Handler. Methods, on the other
hand, are only created once and attached to Handler‚Äôs prototype. They are
shared between all objects of type Handler.
## Overloads
JavaScript is inherently a very dynamic language. It‚Äôs not uncommon for a
single JavaScript function to return different types of objects based on the
shape of the arguments passed in.
    ts
    let suits = ["hearts", "spades", "clubs", "diamonds"];
    function pickCard(x: any): any {
      // Check to see if we're working with an object/array
      // if so, they gave us the deck and we'll pick the card
      if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
      }
      // Otherwise just let them pick the card
      else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
      }
    }
    let myDeck = [
      { suit: "diamonds", card: 2 },
      { suit: "spades", card: 10 },
      { suit: "hearts", card: 4 },
    ];
    let pickedCard1 = myDeck[pickCard(myDeck)];
    alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
    let pickedCard2 = pickCard(15);
    alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFDZ7SiQCu80koAvKANoBEAFnprNUwDShOQAHTABM8kHn0TZyAI3G8mw+JgC2AewB2w8QF0A3AQLpyG5PE2gBSANYBhDsIAUADzSYNATwCUbz6ADeBKCgIKC2bIjWoNBqZHh4oPDooADueADksAkparDW8BoA5qlULKDuoGoyAFZ4yMAcsJgeQSFgSWRqvNBsHqCFmABuCeQ0PQmikeVaqRnY2JY20WygiA6tHY7QHgJ4asnOdPRMVbXITF4BrcHEpFaReML2sMJ0oACymD0AdOjYarlHJ8fk0tGoVI5LgAqUDOb7EIo9LwGYLBLLQciwDSLB5PBwo0AAX1aoQA8uNYCl4PhQNVRqRbss8CocVFxqt1sE8LgEpttrt9rCjnwNOQVDI8LALldUaBGfdrI8AMqUUj0YEsX7-QGHMAARgAzMjrqB0Zjsf4yKq0BQqJAGArlaqdLw1i80IcAKSgQ1EgnE4lEEigFQeAAidSi9AYrUtttQfCUqk02gkbuEaAATETuLGrVQ0PwhKJ5Bz3T6AAw5vPxwtsDhcV0ONAAFmr+kM8psj2ewj1b1DEciDpsvccg8jXg7OEl0EcTHThdAAGpWT2HHrvumV3xKskmDvHXiXpv48ag3du8fhNn6Aqx3qAKzGmeceeL3ero+9zNbhw7g9BQPL8rx-b4zz0IA)
Here, the `pickCard` function will return two different things based on what
the user has passed in. If the users passes in an object that represents the
deck, the function will pick the card. If the user picks the card, we tell
them which card they‚Äôve picked. But how do we describe this to the type
system?
The answer is to supply multiple function types for the same function as a
list of overloads. This list is what the compiler will use to resolve function
calls. Let‚Äôs create a list of overloads that describe what our `pickCard`
accepts and what it returns.
    ts
    let suits = ["hearts", "spades", "clubs", "diamonds"];
    function pickCard(x: { suit: string; card: number }[]): number;
    function pickCard(x: number): { suit: string; card: number };
    function pickCard(x: any): any {
      // Check to see if we're working with an object/array
      // if so, they gave us the deck and we'll pick the card
      if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
      }
      // Otherwise just let them pick the card
      else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
      }
    }
    let myDeck = [
      { suit: "diamonds", card: 2 },
      { suit: "spades", card: 10 },
      { suit: "hearts", card: 4 },
    ];
    let pickedCard1 = myDeck[pickCard(myDeck)];
    alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
    let pickedCard2 = pickCard(15);
    alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzgrglmKEC8EDaAiAFiAhgJ0QwBoIMoAHXAExChLIGNgYAje0jauXAWwHsAdtXoBdANwAoSQDMYgxmDhCIFOIwDWAYQLUAFAA8AXBADe0eGBNQw+OIIDm4iI10nBMXqxD4IAXzRRAEp3T298KTkFJRU1TR18fWMIDy8fELMLBGtbeycXNxSwn39I+UVlQVV1bV1DE1xBAE8MxqazSQgIAHpuiC0cTQgwfmgQEAg4GQgAdxAAcnwJmf58DTzZhCwIRoh+VgArEEVugnxcJs6evqnoflIwHHaHXAA3CZgkR4naIcbqWYLYDAapDb4FRJXW56MBNCggfjTAwoVAYfZHRQYIIdLpdUCQOIaEDUBIA1AAWVwjwAdDJgPxVnpKTTzsJ+Lw9NiAFQQAzU0COR5BKS4iBLMAwfBVQnE0ki-xXXoQADy33wMzgUAmB0+kHxwxwvFBGgNE1ckK6IGAWsm0xhcIRSJRZFS4SxONx+pl1AAypYUBBmVhafTGci+gBGADMwquXXFkqq5lg2SyiDQ3r9CFEpHN1BMyIApBBo6Urn5JBXJPreE0ACLHE2oNBXZOWExcHgCYQcCH5iAAJn8xFbaY7lBodAYeZMEYADMPRymrGQcAQiLnCgAWRcSaRemqy3QRgO1huaDM1Ul6M+NoJ73CgQh6DAzsgQADUxqPiQj1Lzn7voi75ft6pJ-susbVuA34kroQ6oIS14RgArLGj4+GAL5vhggFgfB-66IBuHAbhoGHnBiQDtSkHiEAA)
With this change, the overloads now give us type checked calls to the
`pickCard` function.
In order for the compiler to pick the correct type check, it follows a similar
process to the underlying JavaScript. It looks at the overload list and,
proceeding with the first overload, attempts to call the function with the
provided parameters. If it finds a match, it picks this overload as the
correct overload. For this reason, it‚Äôs customary to order overloads from most
specific to least specific.
Note that the `function pickCard(x): any` piece is not part of the overload
list, so it only has two overloads: one that takes an object and one that
takes a number. Calling `pickCard` with any other parameter types would cause
an error.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Functions.md) ‚ù§
Contributors to this page:  
RC
DR
OT
NS
MF
24+
Last updated: Sep 16, 2024  
Was this page helpful?
### This page has been deprecated
This handbook page has been replaced, [go to the new
page](/docs/handbook/2/generics.html)
[Go to new page](/docs/handbook/2/generics.html)
# Generics
A major part of software engineering is building components that not only have
well-defined and consistent APIs, but are also reusable. Components that are
capable of working on the data of today as well as the data of tomorrow will
give you the most flexible capabilities for building up large software
systems.
In languages like C# and Java, one of the main tools in the toolbox for
creating reusable components is _generics_ , that is, being able to create a
component that can work over a variety of types rather than a single one. This
allows users to consume these components and use their own types.
## Hello World of Generics
To start off, let‚Äôs do the ‚Äúhello world‚Äù of generics: the identity function.
The identity function is a function that will return back whatever is passed
in. You can think of this in a similar way to the `echo` command.
Without generics, we would either have to give the identity function a
specific type:
    ts
    function identity(arg: number): number {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)
Or, we could describe the identity function using the `any` type:
    ts
    function identity(arg: any): any {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)
While using `any` is certainly generic in that it will cause the function to
accept any and all types for the type of `arg`, we actually are losing the
information about what that type was when the function returns. If we passed
in a number, the only information we have is that any type could be returned.
Instead, we need a way of capturing the type of the argument in such a way
that we can also use it to denote what is being returned. Here, we will use a
_type variable_ , a special kind of variable that works on types rather than
values.
    ts
    function identity<T>(arg: T): T {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+QA)
We‚Äôve now added a type variable `T` to the identity function. This `T` allows
us to capture the type the user provides (e.g. `number`), so that we can use
that information later. Here, we use `T` again as the return type. On
inspection, we can now see the same type is used for the argument and the
return type. This allows us to traffic that type information in one side of
the function and out the other.
We say that this version of the `identity` function is generic, as it works
over a range of types. Unlike using `any`, it‚Äôs also just as precise (ie, it
doesn‚Äôt lose any information) as the first `identity` function that used
numbers for the argument and return type.
Once we‚Äôve written the generic identity function, we can call it in one of two
ways. The first way is to pass all of the arguments, including the type
argument, to the function:
    ts
    let output = identity<string>("myString");
    let output: string
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bAPQTEAWjkQQUOTLYAbHojiKADosQBeZOkwwcuAM5RyMMJRIAiALbYAylZuV79EVM5-OAHoA-EA)
Here we explicitly set `T` to be `string` as one of the arguments to the
function call, denoted using the `<>` around the arguments rather than `()`.
The second way is also perhaps the most common. Here we use _type argument
inference_ ‚Äî that is, we want the compiler to set the value of `T` for us
automatically based on the type of the argument we pass in:
    ts
    let output = identity("myString");
    let output: string
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bAPQTEAWjkQQUOTLYAbHojiKADosQBeZOkwwcxAEQBbbAGUo5GGErn6IqZw+cAegH4gA)
Notice that we didn‚Äôt have to explicitly pass the type in the angle brackets
(`<>`); the compiler just looked at the value `"myString"`, and set `T` to its
type. While type argument inference can be a helpful tool to keep code shorter
and more readable, you may need to explicitly pass in the type arguments as we
did in the previous example when the compiler fails to infer the type, as may
happen in more complex examples.
## Working with Generic Type Variables
When you begin to use generics, you‚Äôll notice that when you create generic
functions like `identity`, the compiler will enforce that you use any
generically typed parameters in the body of the function correctly. That is,
that you actually treat these parameters as if they could be any and all
types.
Let‚Äôs take our `identity` function from earlier:
    ts
    function identity<T>(arg: T): T {
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+QA)
What if we want to also log the length of the argument `arg` to the console
with each call? We might be tempted to write this:
    ts
    function loggingIdentity<T>(arg: T): T {
      console.log(arg.length);
    Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFQB8ACgCG0RqmEBKOaADeuUKFI1EcOpAB0DRlJkGejcgAt5AbjWhokcoWi1pjWwF8gA)
When we do, the compiler will give us an error that we‚Äôre using the `.length`
member of `arg`, but nowhere have we said that `arg` has this member.
Remember, we said earlier that these type variables stand in for any and all
types, so someone using this function could have passed in a `number` instead,
which does not have a `.length` member.
Let‚Äôs say that we‚Äôve actually intended this function to work on arrays of `T`
rather than `T` directly. Since we‚Äôre working with arrays, the `.length`
member should be available. We can describe this just like we would create
arrays of other types:
    ts
    function loggingIdentity<T>(arg: T[]): T[] {
      console.log(arg.length);
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFQD4AKAQwCc0AuRSgbQF0BKNzrogDeAKESIICAM5xkBAHSo0DZoqJooACx4BuMYkYEoIRkiZo9AXyA)
You can read the type of `loggingIdentity` as ‚Äúthe generic function
`loggingIdentity` takes a type parameter `T`, and an argument `arg` which is
an array of `T`s, and returns an array of `T`s.‚Äù If we passed in an array of
numbers, we‚Äôd get an array of numbers back out, as `T` would bind to `number`.
This allows us to use our generic type variable `T` as part of the types we‚Äôre
working with, rather than the whole type, giving us greater flexibility.
We can alternatively write the sample example this way:
    ts
    function loggingIdentity<T>(arg: Array<T>): Array<T> {
      console.log(arg.length); // Array has a .length, so no more error
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFQD4AKAQwCc0AuRAQUcfopoEo2nbr2qIA3gChEiCAgDOcZAQB0qNA2aqiaKAAs+AbkQB6Yxy49Eu+nMT1EW7HoA0iBYjBxEAWziMCiARcflKI-lAgjEhMaAYSAL5AA)
You may already be familiar with this style of type from other languages. In
the next section, we‚Äôll cover how you can create your own generic types like
`Array<T>`.
## Generic Types
In previous sections, we created generic identity functions that worked over a
range of types. In this section, we‚Äôll explore the type of the functions
themselves and how to create generic interfaces.
The type of generic functions is just like those of non-generic functions,
with the type parameters listed first, similarly to function declarations:
    ts
    function identity<T>(arg: T): T {
      return arg;
    }
    let myIdentity: <T>(arg: T) => T = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctAiUFN6iALyE6e5MqzYhQA)
We could also have used a different name for the generic type parameter in the
type, so long as the number of type variables and how the type variables are
used line up.
    ts
    function identity<T>(arg: T): T {
      return arg;
    }
    let myIdentity: <U>(arg: U) => U = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctXAFUSg2hvqIAvIUQbDyZVmxCgA)
We can also write the generic type as a call signature of an object literal
type:
    ts
    function identity<T>(arg: T): T {
      return arg;
    }
    let myIdentity: { <T>(arg: T): T } = identity;
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFQD4AKAQwCcBzALkXwEpb9EBvAKEUXLShHKQqUA3GwC+bNgBseiALbYAkukwwctFogIlBTRnUSjEAXmTKs2IUA)
Which leads us to writing our first generic interface. Let‚Äôs take the object
literal from the previous example and move it to an interface:
    ts
    interface GenericIdentityFn {
      <T>(arg: T): T;
    }
    function identity<T>(arg: T): T {
      return arg;
    }
    let myIdentity: GenericIdentityFn = identity;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVAPgAo4oBzALmSYCUfJgG4aAXxo0YAVxAIiAe0rAC4YiWbtOvfkP7U6yKBDAyolHWMk0ANqeQBbEvkIa+6TFGyv1pCsgAvMiqbqQiQA)
In a similar example, we may want to move the generic parameter to be a
parameter of the whole interface. This lets us see what type(s) we‚Äôre generic
over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the
type parameter visible to all the other members of the interface.
    ts
    interface GenericIdentityFn<T> {
      (arg: T): T;
    }
    function identity<T>(arg: T): T {
      return arg;
    }
    let myIdentity: GenericIdentityFn<number> = identity;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFQD5kBvAKGWQAo4oBzALmWoCUfagG4mAXyZMYAVxAIiAexDJgBcMRI1aHbsKH9GLZFAhgZUFZy5jJTADZnkAWxL5CmvukxRs7jaQUlCAyzgBG0PQAvKrqRKQiQA)
Notice that our example has changed to be something slightly different.
Instead of describing a generic function, we now have a non-generic function
signature that is a part of a generic type. When we use `GenericIdentityFn`,
we now will also need to specify the corresponding type argument (here:
`number`), effectively locking in what the underlying call signature will use.
Understanding when to put the type parameter directly on the call signature
and when to put it on the interface itself will be helpful in describing what
aspects of a type are generic.
In addition to generic interfaces, we can also create generic classes. Note
that it is not possible to create generic enums and namespaces.
## Generic Classes
A generic class has a similar shape to a generic interface. Generic classes
have a generic type parameter list in angle brackets (`<>`) following the name
of the class.
    ts
    class GenericNumber<T> {
      zeroValue: T;
      add: (x: T, y: T) => T;
    }
    let myGenericNumber = new GenericNumber<number>();
    myGenericNumber.zeroValue = 0;
    myGenericNumber.add = function (x, y) {
      return x + y;
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8AKgHygBvAqFAAvOgHsAajiZ403ANzDQmACZq0ACgAeCgDSgAngoCUoALz8lBAL4EC2PNFAsjVWvWbs6l0LQB3Sho6JG8OWE5qVgjeLVNlNw9Qxhi6ADpxWGlZPD8ABkT3EK802HT1NT90JmpkeAlqUF1DI3MhEVhnJlgmnVAAamNlW0UgA)
This is a pretty literal use of the `GenericNumber` class, but you may have
noticed that nothing is restricting it to only use the `number` type. We could
have instead used `string` or even more complex objects.
    ts
    let stringNumeric = new GenericNumber<string>();
    stringNumeric.zeroValue = "";
    stringNumeric.add = function (x, y) {
      return x + y;
    };
    console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8AKgHygBvAqFAAvOgHsAajiZ403ANzDQmACZq0ACgAeCgDSgAngoCUoALz8lBAL4EQoALQvETaC6cFseaKBgI1ADmzCx0SJagtADulDThjKwcsJwB8MG8WqbKacGhCQB04rDSsniRAEQVOXDpIayF6mqR6EzUyPAS1KC6hkbmQiKwvkyw3TqgANTGyrbKRF2QEj4F2BJBWrn1YfQFTZu1eQ27xaXYcoYV0HgwFabZQA)
Just as with interface, putting the type parameter on the class itself lets us
make sure all of the properties of the class are working with the same type.
As we covered in [our section on classes](/docs/handbook/classes.html), a
class has two sides to its type: the static side and the instance side.
Generic classes are only generic over their instance side rather than their
static side, so when working with classes, static members can not use the
class‚Äôs type parameter.
## Generic Constraints
If you remember from an earlier example, you may sometimes want to write a
generic function that works on a set of types where you have some knowledge
about what capabilities that set of types will have. In our `loggingIdentity`
example, we wanted to be able to access the `.length` property of `arg`, but
the compiler could not prove that every type had a `.length` property, so it
warns us that we can‚Äôt make this assumption.
    ts
    function loggingIdentity<T>(arg: T): T {
      console.log(arg.length);
    Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFQB8ACgCG0RqmEBKOaADeuUKFI1EcOpAB0DRlJkGejcgAt5AbjWhokcoWi1pjWwF8gA)
Instead of working with any and all types, we‚Äôd like to constrain this
function to work with any and all types that also have the `.length` property.
As long as the type has this member, we‚Äôll allow it, but it‚Äôs required to have
at least this member. To do so, we must list our requirement as a constraint
on what T can be.
To do so, we‚Äôll create an interface that describes our constraint. Here, we‚Äôll
create an interface that has a single `.length` property and then we‚Äôll use
this interface and the `extends` keyword to denote our constraint:
    ts
    interface Lengthwise {
      length: number;
    }
    function loggingIdentity<T extends Lengthwise>(arg: T): T {
      console.log(arg.length); // Now we know it has a .length property, so no more error
      return arg;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABVkEAB6QQSwmlq4CxAHwAKOFEyNtASifJylBJMLiaAOioZOwcA8xxnLmQAeijkADlxPGQ8FABrEETkYDBkHDhTOGRQrFxkAAcocTLoDQAaZB8mcWRWcSgUaEqoCmR2sGYoKXtMHl4gA)
Because the generic function is now constrained, it will no longer work over
any and all types:
    ts
    loggingIdentity(3);
    Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVUJAAeZIucQNR7LjwB8ABSU0MyoDgCU4aD8gtR6iHAiAHRChsGhqT5sEUqC0JAkktD6IcxKqiCgALS11JIktdV4aUYmFlYEtoEYuUA)
Instead, we need to pass in values whose type has all the required properties:
    ts
    loggingIdentity({ length: 10, value: 3 });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABVkEAB6QQSwmlq4CxAHwAKOFEyNtASifJylBJMLiaAOioZOwcA8xxnHkooCDBmKCl7TB5+AHoU5ABaLIRmMCyMskDZeWVVYA0bEmowxgBGAAYAGmQANzgqZghGAGZkXgigA)
### Using Type Parameters in Generic Constraints
You can declare a type parameter that is constrained by another type
parameter. For example, here we‚Äôd like to get a property from an object given
its name. We‚Äôd like to ensure that we‚Äôre not accidentally grabbing a property
that does not exist on the `obj`, so we‚Äôll place a constraint between the two
types:
    ts
    function getProperty<T, K extends keyof T>(obj: T, key: K) {
      return obj[key];
    }
    let x = { a: 1, b: 2, c: 3, d: 4 };
    getProperty(x, "a");
    getProperty(x, "m");
    Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.2345Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKgBpQAaVCQAHhUgkAJolABrSFzgFQfAHwAKOACMAVqkGLlqYQEpQAbzyhQ0JkWh09+gNpKuAXQDceAL54eAA2TKDioAC81qAAhqgAjEK6qGhCZKgYQjKoWKD+fniMLOycXFriQgBEsVXmfsWscBzQ3BXVALZ1PkA)
### Using Class Types in Generics
When creating factories in TypeScript using generics, it is necessary to refer
to class types by their constructor functions. For example,
    ts
    function create<T>(c: { new (): T }): T {
      return new c();
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoB8AFBAFyIDeiYaA7okQJTl6IC+zirFAUIouiggUSGvQhMA3DzZA)
A more advanced example uses the prototype property to infer and constrain
relationships between the constructor function and the instance side of class
types.
    ts
    class BeeKeeper {
      hasMask: boolean;
    }
    class ZooKeeper {
      nametag: string;
    }
    class Animal {
      numLegs: number;
    }
    class Bee extends Animal {
      keeper: BeeKeeper;
    }
    class Lion extends Animal {
      keeper: ZooKeeper;
    }
    function createInstance<A extends Animal>(c: new () => A): A {
      return new c();
    }
    createInstance(Lion).keeper.nametag;
    createInstance(Bee).keeper.hasMask;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdgG4CAXwJESZUAC0xdPI2ZsOUzAFs80TAHM0MBFLNzFy0uQCCU+IZyt2oKQFdDAGTwzSDRfQyEmOyViR0pqUDwAD2g8KQATZ1d3bE8OfgYmNCpaAtgoh1V-eBEpBOTUjNAXNw89UHztQvVNUvL0HylkatrEWEkUgEkpGGlEPAAeJzqU9MyW7AA+AApEULwAd1AtgEpQAF4NpuO0Jbax6B9YWqkD0EQT8tHxvCmZwbwtlUascAHQdHQggzGUy2IhjTCTaamf5bYqg8FMEHcSB8SD8GRAA)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Generics.md) ‚ù§
Contributors to this page:  
RC
OT
DR
MH
RC
15+
Last updated: Sep 16, 2024  
Was this page helpful?
# Gulp
This quick start guide will teach you how to build TypeScript with
[gulp](https://gulpjs.com) and then add [Browserify](https://browserify.org),
[terser](https://terser.org), or
[Watchify](https://github.com/substack/watchify) to the gulp pipeline. This
guide also shows how to add [Babel](https://babeljs.io/) functionality using
[Babelify](https://github.com/babel/babelify).
We assume that you‚Äôre already using [Node.js](https://nodejs.org/) with
[npm](https://www.npmjs.com/).
## Minimal project
Let‚Äôs start out with a new directory. We‚Äôll name it `proj` for now, but you
can change it to whatever you want.
    shell
    mkdir proj
    cd proj
To start, we‚Äôre going to structure our project in the following way:
    proj/
       ‚îú‚îÄ src/
       ‚îî‚îÄ dist/
TypeScript files will start out in your `src` folder, run through the
TypeScript compiler and end up in `dist`.
Let‚Äôs scaffold this out:
    shell
    mkdir src
    mkdir dist
### Initialize the project
Now we‚Äôll turn this folder into an npm package.
    shell
    npm init
You‚Äôll be given a series of prompts. You can use the defaults except for your
entry point. For your entry point, use `./dist/main.js`. You can always go
back and change these in the `package.json` file that‚Äôs been generated for
you.
### Install our dependencies
Now we can use `npm install` to install packages. First install `gulp-cli`
globally (if you use a Unix system, you may need to prefix the `npm install`
commands in this guide with `sudo`).
    shell
    npm install -g gulp-cli
Then install `typescript`, `gulp` and `gulp-typescript` in your project‚Äôs dev
dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript)
is a gulp plugin for TypeScript.
    shell
    npm install --save-dev typescript gulp@4.0.0 gulp-typescript
### Write a simple example
Let‚Äôs write a Hello World program. In `src`, create the file `main.ts`:
    ts
    function hello(compiler: string) {
      console.log(`Hello from ${compiler}`);
    }
    hello("TypeScript");
In the project root, `proj`, create the file `tsconfig.json`:
    {
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts"],
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es5"
      }
    }
### Create a `gulpfile.js`
In the project root, create the file `gulpfile.js`:
    js
    var gulp = require("gulp");
    var ts = require("gulp-typescript");
    var tsProject = ts.createProject("tsconfig.json");
    gulp.task("default", function () {
      return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist"));
    });
### Test the resulting app
    shell
    gulp
    node dist/main.js
The program should print ‚ÄúHello from TypeScript!‚Äú.
## Add modules to the code
Before we get to Browserify, let‚Äôs build our code out and add modules to the
mix. This is the structure you‚Äôre more likely to use for a real app.
Create a file called `src/greet.ts`:
    ts
    export function sayHello(name: string) {
      return `Hello from ${name}`;
    }
Now change the code in `src/main.ts` to import `sayHello` from `greet.ts`:
    ts
    import { sayHello } from "./greet";
    console.log(sayHello("TypeScript"));
Finally, add `src/greet.ts` to `tsconfig.json`:
    {
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts", "src/greet.ts"],
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es5"
      }
    }
Make sure that the modules work by running `gulp` and then testing in Node:
    shell
    gulp
    node dist/main.js
Notice that even though we used ES2015 module syntax, TypeScript emitted
CommonJS modules that Node uses. We‚Äôll stick with CommonJS for this tutorial,
but you could set `module` in the options object to change this.
## Browserify
Now let‚Äôs move this project from Node to the browser. To do this, we‚Äôd like to
bundle all our modules into one JavaScript file. Fortunately, that‚Äôs exactly
what Browserify does. Even better, it lets us use the CommonJS module system
used by Node, which is the default TypeScript emit. That means our TypeScript
and Node setup will transfer to the browser basically unchanged.
First, install browserify, [tsify](https://www.npmjs.com/package/tsify), and
vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript,
gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the
file output of Browserify back into a format that gulp understands called
[vinyl](https://github.com/gulpjs/vinyl).
    shell
    npm install --save-dev browserify tsify vinyl-source-stream
### Create a page
Create a file in `src` named `index.html`:
    html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8" />
        <title>Hello World!</title>
      </head>
      <body>
        <p id="greeting">Loading ...</p>
        <script src="bundle.js"></script>
      </body>
    </html>
Now change `main.ts` to update the page:
    ts
    import { sayHello } from "./greet";
    function showHello(divName: string, name: string) {
      const elt = document.getElementById(divName);
      elt.innerText = sayHello(name);
    }
    showHello("greeting", "TypeScript");
Calling `showHello` calls `sayHello` to change the paragraph‚Äôs text. Now
change your gulpfile to the following:
    js
    var gulp = require("gulp");
    var browserify = require("browserify");
    var source = require("vinyl-source-stream");
    var tsify = require("tsify");
    var paths = {
      pages: ["src/*.html"],
    };
    gulp.task("copy-html", function () {
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    });
    gulp.task(
      "default",
      gulp.series(gulp.parallel("copy-html"), function () {
        return browserify({
          basedir: ".",
          debug: true,
          entries: ["src/main.ts"],
          cache: {},
          packageCache: {},
        })
          .plugin(tsify)
          .bundle()
          .pipe(source("bundle.js"))
          .pipe(gulp.dest("dist"));
      })
    );
This adds the `copy-html` task and adds it as a dependency of `default`. That
means any time `default` is run, `copy-html` has to run first. We‚Äôve also
changed `default` to call Browserify with the tsify plugin instead of gulp-
typescript. Conveniently, they both allow us to pass the same options object
to the TypeScript compiler.
After calling `bundle` we use `source` (our alias for vinyl-source-stream) to
name our output bundle `bundle.js`.
Test the page by running gulp and then opening `dist/index.html` in a browser.
You should see ‚ÄúHello from TypeScript‚Äù on the page.
Notice that we specified `debug: true` to Browserify. This causes tsify to
emit source maps inside the bundled JavaScript file. Source maps let you debug
your original TypeScript code in the browser instead of the bundled
JavaScript. You can test that source maps are working by opening the debugger
for your browser and putting a breakpoint inside `main.ts`. When you refresh
the page the breakpoint should pause the page and let you debug `greet.ts`.
## Watchify, Babel, and Terser
Now that we are bundling our code with Browserify and tsify, we can add
various features to our build with browserify plugins.
  * Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.
  * Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn‚Äôt support.
  * Terser compacts your code so that it takes less time to download.
### Watchify
We‚Äôll start with Watchify to provide background compilation:
    shell
    npm install --save-dev watchify fancy-log
Now change your gulpfile to the following:
    js
    var gulp = require("gulp");
    var browserify = require("browserify");
    var source = require("vinyl-source-stream");
    var watchify = require("watchify");
    var tsify = require("tsify");
    var fancy_log = require("fancy-log");
    var paths = {
      pages: ["src/*.html"],
    };
    var watchedBrowserify = watchify(
      browserify({
        basedir: ".",
        debug: true,
        entries: ["src/main.ts"],
        cache: {},
        packageCache: {},
      }).plugin(tsify)
    );
    gulp.task("copy-html", function () {
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    });
    function bundle() {
      return watchedBrowserify
        .bundle()
        .on("error", fancy_log)
        .pipe(source("bundle.js"))
        .pipe(gulp.dest("dist"));
    }
    gulp.task("default", gulp.series(gulp.parallel("copy-html"), bundle));
    watchedBrowserify.on("update", bundle);
    watchedBrowserify.on("log", fancy_log);
There are basically three changes here, but they require you to refactor your
code a bit.
  1. We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.
  2. We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.
  3. We called `watchedBrowserify.on('log', fancy_log);` to log to the console.
Together (1) and (2) mean that we have to move our call to `browserify` out of
the `default` task. And we have to give the function for `default` a name
since both Watchify and Gulp need to call it. Adding logging with (3) is
optional but very useful for debugging your setup.
Now when you run Gulp, it should start and stay running. Try changing the code
for `showHello` in `main.ts` and saving it. You should see output that looks
like this:
    shell
    proj$ gulp
    [10:34:20] Using gulpfile ~/src/proj/gulpfile.js
    [10:34:20] Starting 'copy-html'...
    [10:34:20] Finished 'copy-html' after 26 ms
    [10:34:20] Starting 'default'...
    [10:34:21] 2824 bytes written (0.13 seconds)
    [10:34:21] Finished 'default' after 1.36 s
    [10:35:22] 2261 bytes written (0.02 seconds)
    [10:35:24] 2808 bytes written (0.05 seconds)
### Terser
First install Terser. Since the point of Terser is to mangle your code, we
also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps
working.
    shell
    npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps
Now change your gulpfile to the following:
    js
    var gulp = require("gulp");
    var browserify = require("browserify");
    var source = require("vinyl-source-stream");
    var terser = require("gulp-terser");
    var tsify = require("tsify");
    var sourcemaps = require("gulp-sourcemaps");
    var buffer = require("vinyl-buffer");
    var paths = {
      pages: ["src/*.html"],
    };
    gulp.task("copy-html", function () {
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    });
    gulp.task(
      "default",
      gulp.series(gulp.parallel("copy-html"), function () {
        return browserify({
          basedir: ".",
          debug: true,
          entries: ["src/main.ts"],
          cache: {},
          packageCache: {},
        })
          .plugin(tsify)
          .bundle()
          .pipe(source("bundle.js"))
          .pipe(buffer())
          .pipe(sourcemaps.init({ loadMaps: true }))
          .pipe(terser())
          .pipe(sourcemaps.write("./"))
          .pipe(gulp.dest("dist"));
      })
    );
Notice that `terser` itself has just one call ‚Äî the calls to `buffer` and
`sourcemaps` exist to make sure sourcemaps keep working. These calls give us a
separate sourcemap file instead of using inline sourcemaps like before. Now
you can run Gulp and check that `bundle.js` does get minified into an
unreadable mess:
    shell
    gulp
    cat dist/bundle.js
### Babel
First install Babelify and the Babel preset for ES2015. Like Terser, Babelify
mangles code, so we‚Äôll need vinyl-buffer and gulp-sourcemaps. By default
Babelify will only process files with extensions of `.js`, `.es`, `.es6` and
`.jsx` so we need to add the `.ts` extension as an option to Babelify.
    shell
    npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps
Now change your gulpfile to the following:
    js
    var gulp = require("gulp");
    var browserify = require("browserify");
    var source = require("vinyl-source-stream");
    var tsify = require("tsify");
    var sourcemaps = require("gulp-sourcemaps");
    var buffer = require("vinyl-buffer");
    var paths = {
      pages: ["src/*.html"],
    };
    gulp.task("copy-html", function () {
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    });
    gulp.task(
      "default",
      gulp.series(gulp.parallel("copy-html"), function () {
        return browserify({
          basedir: ".",
          debug: true,
          entries: ["src/main.ts"],
          cache: {},
          packageCache: {},
        })
          .plugin(tsify)
          .transform("babelify", {
            presets: ["es2015"],
            extensions: [".ts"],
          })
          .bundle()
          .pipe(source("bundle.js"))
          .pipe(buffer())
          .pipe(sourcemaps.init({ loadMaps: true }))
          .pipe(sourcemaps.write("./"))
          .pipe(gulp.dest("dist"));
      })
    );
We also need to have TypeScript target ES2015. Babel will then produce ES5
from the ES2015 code that TypeScript emits. Let‚Äôs modify `tsconfig.json`:
    {
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["src/main.ts"],
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[target](https://www.typescriptlang.org/tsconfig#target)": "es2015"
      }
    }
Babel‚Äôs ES5 output should be very similar to TypeScript‚Äôs output for such a
simple script.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Gulp.md) ‚ù§
Contributors to this page:  
BK
OT
DR
RC
MF
19+
Last updated: Sep 16, 2024  
Was this page helpful?
# Integrating with Build Tools
## Babel
### Install
    sh
    npm install @babel/cli @babel/core @babel/preset-typescript --save-dev
### .babelrc
    js
    {
      "presets": ["@babel/preset-typescript"]
    }
### Using Command Line Interface
    sh
    ./node_modules/.bin/babel --out-file bundle.js src/index.ts
### package.json
    js
    {
      "scripts": {
        "build": "babel --out-file bundle.js main.ts"
      },
    }
### Execute Babel from the command line
    sh
    npm run build
## Browserify
### Install
    sh
    npm install tsify
### Using Command Line Interface
    sh
    browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js
### Using API
    js
    var browserify = require("browserify");
    var tsify = require("tsify");
    browserify()
      .add("main.ts")
      .plugin("tsify", { noImplicitAny: true })
      .bundle()
      .pipe(process.stdout);
More details: [smrq/tsify](https://github.com/smrq/tsify)
## Grunt
### Using `grunt-ts` (no longer maintained)
#### Install
    sh
    npm install grunt-ts --save-dev
#### Basic Gruntfile.js
    js
    module.exports = function (grunt) {
      grunt.initConfig({
        ts: {
          default: {
            src: ["**/*.ts", "!node_modules/**/*.ts"],
          },
        },
      });
      grunt.loadNpmTasks("grunt-ts");
      grunt.registerTask("default", ["ts"]);
    };
More details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)
### Using `grunt-browserify` combined with `tsify`
#### Install
    sh
    npm install grunt-browserify tsify --save-dev
#### Basic Gruntfile.js
    js
    module.exports = function (grunt) {
      grunt.initConfig({
        browserify: {
          all: {
            src: "src/main.ts",
            dest: "dist/main.js",
            options: {
              plugin: ["tsify"],
            },
          },
        },
      });
      grunt.loadNpmTasks("grunt-browserify");
      grunt.registerTask("default", ["browserify"]);
    };
More details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-
browserify), [TypeStrong/tsify](https://github.com/TypeStrong/tsify)
## Gulp
### Install
    sh
    npm install gulp-typescript
### Basic gulpfile.js
    js
    var gulp = require("gulp");
    var ts = require("gulp-typescript");
    gulp.task("default", function () {
      var tsResult = gulp.src("src/*.ts").pipe(
        ts({
          noImplicitAny: true,
          out: "output.js",
        })
      );
      return tsResult.js.pipe(gulp.dest("built/local"));
    });
More details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-
typescript)
## Jspm
### Install
    sh
    npm install -g jspm@beta
_Note: Currently TypeScript support in jspm is in 0.16beta_
More details:
[TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)
## MSBuild
Update project file to include locally installed
`Microsoft.TypeScript.Default.props` (at the top) and
`Microsoft.TypeScript.targets` (at the bottom) files:
    xml
    <?xml version="1.0" encoding="utf-8"?>
    <Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
      <!-- Include default props at the top -->
      <Import
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props"
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props')" />
      <!-- TypeScript configurations go here -->
      <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
        <TypeScriptRemoveComments>false</TypeScriptRemoveComments>
        <TypeScriptSourceMap>true</TypeScriptSourceMap>
      </PropertyGroup>
      <PropertyGroup Condition="'$(Configuration)' == 'Release'">
        <TypeScriptRemoveComments>true</TypeScriptRemoveComments>
        <TypeScriptSourceMap>false</TypeScriptSourceMap>
      </PropertyGroup>
      <!-- Include default targets at the bottom -->
      <Import
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" />
    </Project>
More details about defining MSBuild compiler options: [Setting Compiler
Options in MSBuild projects](/docs/handbook/compiler-options-in-msbuild.html)
## NuGet
  * Right-Click -> Manage NuGet Packages
  * Search for `Microsoft.TypeScript.MSBuild`
  * Hit `Install`
  * When install is complete, rebuild!
More details can be found at [Package Manager
Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog) and [using
nightly builds with
NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-
with-msbuild)
## Rollup
### Install
    npm install @rollup/plugin-typescript --save-dev
Note that both `typescript` and `tslib` are peer dependencies of this plugin
that need to be installed separately.
### Usage
Create a `rollup.config.js` [configuration
file](https://www.rollupjs.org/guide/en/#configuration-files) and import the
plugin:
    js
    // rollup.config.js
    import typescript from '@rollup/plugin-typescript';
    export default {
      input: 'src/index.ts',
      output: {
        dir: 'output',
        format: 'cjs'
      },
      plugins: [typescript()]
    };
## Svelte Compiler
### Install
    npm install --save-dev svelte-preprocess
Note that `typescript` is an optional peer dependencies of this plugin and
needs to be installed separately. `tslib` is not provided either.
You may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-
check) for CLI type checking.
### Usage
Create a `svelte.config.js` configuration file and import the plugin:
    js
    // svelte.config.js
    import preprocess from 'svelte-preprocess';
    const config = {
      // Consult https://github.com/sveltejs/svelte-preprocess
      // for more information about preprocessors
      preprocess: preprocess()
    };
    export default config;
You can now specify that script blocks are written in TypeScript:
    <script lang="ts">
## Vite
Vite supports importing `.ts` files out-of-the-box. It only performs
transpilation and not type checking. It also requires that some
`compilerOptions` have certain values. See the [Vite
docs](https://vitejs.dev/guide/features.html#typescript) for more details.
## Webpack
### Install
    sh
    npm install ts-loader --save-dev
### Basic webpack.config.js when using Webpack 5 or 4
    js
    const path = require('path');
    module.exports = {
      entry: './src/index.ts',
      module: {
        rules: [
          {
            test: /\.tsx?$/,
            use: 'ts-loader',
            exclude: /node_modules/,
          },
        ],
      },
      resolve: {
        extensions: ['.tsx', '.ts', '.js'],
      },
      output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist'),
      },
    };
See [more details on ts-loader here](https://www.npmjs.com/package/ts-loader).
Alternatives:
  * [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Integrating with
Build Tools.md) ‚ù§
Contributors to this page:  
MH
OT
MDB
RC
DR
15+
Last updated: Sep 16, 2024  
Was this page helpful?
### This page has been deprecated
This handbook page has been replaced, [go to the new
page](/docs/handbook/2/objects.html)
[Go to new page](/docs/handbook/2/objects.html)
# Interfaces
One of TypeScript‚Äôs core principles is that type checking focuses on the
_shape_ that values have. This is sometimes called ‚Äúduck typing‚Äù or
‚Äústructural subtyping‚Äù. In TypeScript, interfaces fill the role of naming
these types, and are a powerful way of defining contracts within your code as
well as contracts with code outside of your project.
## Our First Interface
The easiest way to see how interfaces work is to start with a simple example:
    ts
    function printLabel(labeledObj: { label: string }) {
      console.log(labeledObj.label);
    }
    let myObj = { size: 10, label: "Size 10 Object" };
    printLabel(myObj);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAMgQwEYCmANgBRH7EEAmA8ngFYBciA3ouYUcwM5TpgBzRAF8AlKwBQiRBATc4RAgDoicAWQqLaDFZtEBuCcIkTFURAFsAnnXqIAvK0TcYALwLMAjAAYANO01mACIAZTcCRB9EWwJoIJFDNAxsTRJrWwMgA)
The type checker checks the call to `printLabel`. The `printLabel` function
has a single parameter that requires that the object passed in has a property
called `label` of type `string`. Notice that our object actually has more
properties than this, but the compiler only checks that _at least_ the ones
required are present and match the types required. There are some cases where
TypeScript isn‚Äôt as lenient, which we‚Äôll cover in a bit.
We can write the same example again, this time using an interface to describe
the requirement of having the `label` property that is a string:
    ts
    interface LabeledValue {
      label: string;
    }
    function printLabel(labeledObj: LabeledValue) {
      console.log(labeledObj.label);
    }
    let myObj = { size: 10, label: "Size 10 Object" };
    printLabel(myObj);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDJwEYQDYQCYBqc2ArigN4BQyy2mOAXMgM5hSgDmA3JQL6WUYJEAjDAA9iGQAHduHRZsACjqL8AeQwArJgpz4ipCAEpkVGgknNxuAHTZxHFfVx5NW+y+M9+lXGGQAWwBPd2QAXjMWYAAvCCYARgAGABpaFyYAIgBlWJRk5HcIUUzkXh5ZUDA9ZRD3byA)
The interface `LabeledValue` is a name we can now use to describe the
requirement in the previous example. It still represents having a single
property called `label` that is of type `string`. Notice we didn‚Äôt have to
explicitly say that the object we pass to `printLabel` implements this
interface like we might have to in other languages. Here, it‚Äôs only the shape
that matters. If the object we pass to the function meets the requirements
listed, then it‚Äôs allowed.
It‚Äôs worth pointing out that the type checker does not require that these
properties come in any sort of order, only that the properties the interface
requires are present and have the required type.
## Optional Properties
Not all properties of an interface may be required. Some exist under certain
conditions or may not be there at all. These optional properties are popular
when creating patterns like ‚Äúoption bags‚Äù where you pass an object to a
function that only has a couple of properties filled in.
Here‚Äôs an example of this pattern:
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
    }
    function createSquare(config: SquareConfig): { color: string; area: number } {
      let newSquare = { color: "white", area: 100 };
      if (config.color) {
        newSquare.color = config.color;
      }
      if (config.width) {
        newSquare.area = config.width * config.width;
      }
      return newSquare;
    }
    let mySquare = createSquare({ color: "black" });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iCAvlSoxMIBGGBE6uOJAzZcACnrEyHUznxESpAJQcKdRsw7deIAcns4DjklaGRVSiEGCDBZCGE7XGQAXkoPJigOACJhSWBILIAaAKMOAEYABgrwwVpgGGRLRzIAOnoM50jaWhB4xIg2zygUj2tSQYza8KF6xqsnFtEJSU7qbriErHsWwJH51qWpZAAqUYXDySn1WlwwTCgQDf61DWjY+QBPfr2jEy2LdztLzILKKBiIADWWXCzn4QA)
Interfaces with optional properties are written similar to other interfaces,
with each optional property denoted by a `?` at the end of the property name
in the declaration.
The advantage of optional properties is that you can describe these possibly
available properties while still also preventing use of properties that are
not part of the interface. For example, had we mistyped the name of the
`color` property in `createSquare`, we would get an error message letting us
know:
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
    }
    function createSquare(config: SquareConfig): { color: string; area: number } {
      let newSquare = { color: "white", area: 100 };
      if (config.clor) {
    Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?
      }
      if (config.width) {
        newSquare.area = config.width * config.width;
      }
      return newSquare;
    }
    let mySquare = createSquare({ color: "black" });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCquKQxAaQaoFsoAC8gtGS0KgARGo6+KQ1ADRJrqjYAAydmSoi+GSgPiF8AHRUVWHZIiIgoACisLGgAArwAA4wxACeoADkEwh7oJpwkIgGcPmQAB74cqDOO5v7xcF+vHuqIoSFb+MxaBlaIfcZVPqZVQDIa+UKjDTaHRTIQzApFZhBUbJYGwsYI3SgABUILh+J0EKsIjYxCY0EIaLelmsuXyRm2bxxrncGO8UTEVVqJnE1AA1jVMmElEA)
## Readonly properties
Some properties should only be modifiable when an object is first created. You
can specify this by putting `readonly` before the name of the property:
    ts
    interface Point {
      readonly x: number;
      readonly y: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLJQRwAm6IANgJ7IAeAXMiAK4C2ARtANwFEnkqtak1aceeAL5A)
You can construct a `Point` by assigning an object literal. After the
assignment, `x` and `y` can‚Äôt be changed.
    ts
    let p1: Point = { x: 10, y: 20 };
    p1.x = 5; // error!
    Cannot assign to 'x' because it is a read-only property.2540Cannot assign to 'x' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAApzEmgDeeoo0klAJnEQA2AT1AAPVEQCuAWwBGMANwcuPfkNHDJshdGUBfPCFABaM9SkkzJvIMgsADgEZUjZqAC8bcaic4ANKBa6Dig+srOAHRinqAYiqDGMPDQAIRAA)
TypeScript comes with a `ReadonlyArray<T>` type that is the same as `Array<T>`
with all mutating methods removed, so you can make sure you don‚Äôt change your
arrays after creation:
    ts
    let a: number[] = [1, 2, 3, 4];
    let ro: ReadonlyArray<number> = a;
    ro[0] = 12; // error!
    Index signature in type 'readonly number[]' only permits reading.2542Index signature in type 'readonly number[]' only permits reading.
    ro.push(5); // error!
    Property 'push' does not exist on type 'readonly number[]'.2339Property 'push' does not exist on type 'readonly number[]'.
    ro.length = 100; // error!
    Cannot assign to 'length' because it is a read-only property.2540Cannot assign to 'length' because it is a read-only property.
    a = ro; // error!
    The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.4104The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsb0GY8BOdbABlCwEZSsAoAG0gBdQBDVAOwFcBbAIxgBtALqgAvKEGUANOll5ZWYQG4GzUPFQAlSKwAmcDvQCeAQVitjAHm78YAPnFtVteINKiJlNMtAhQMPDQAISucAB0AA5ciAAWABQYAJS+-oEIofDhjBwA5kyxTtSkqWDpIbSsTvClAbAZQA)
On the last line of the snippet you can see that even assigning the entire
`ReadonlyArray` back to a normal array is illegal. You can still override it
with a type assertion, though:
    ts
    let a: number[] = [1, 2, 3, 4];
    let ro: ReadonlyArray<number> = a;
    a = ro as number[];
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAhgXBB2BXAtgIxAJwNoF0IF4IsBGAGggCZyBmcgFhwG4AoUSDAezgCUQoATDvGABPAIIYMUEQB4kaTAD4C0FsygrO0AM4IU6bEyA)
### `readonly` vs `const`
The easiest way to remember whether to use `readonly` or `const` is to ask
whether you‚Äôre using it on a variable or a property. Variables use `const`
whereas properties use `readonly`.
## Excess Property Checks
In our first example using interfaces, TypeScript lets us pass `{ size:
number; label: string; }` to something that only expected a `{ label: string;
}`. We also just learned about optional properties, and how they‚Äôre useful
when describing so-called ‚Äúoption bags‚Äù.
However, combining the two naively would allow an error to sneak in. For
example, taking our last example using `createSquare`:
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
    }
    function createSquare(config: SquareConfig): { color: string; area: number } {
      return {
        color: config.color || "red",
        area: config.width ? config.width * config.width : 20,
      };
    }
    let mySquare = createSquare({ colour: "red", width: 100 });
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)
Notice the given argument to `createSquare` is spelled _`colour`_ instead of
`color`. In plain JavaScript, this sort of thing fails silently.
You could argue that this program is correctly typed, since the `width`
properties are compatible, there‚Äôs no `color` property present, and the extra
`colour` property is insignificant.
However, TypeScript takes the stance that there‚Äôs probably a bug in this code.
Object literals get special treatment and undergo _excess property checking_
when assigning them to other variables, or passing them as arguments. If an
object literal has any properties that the ‚Äútarget type‚Äù doesn‚Äôt have, you‚Äôll
get an error:
    ts
    let mySquare = createSquare({ colour: "red", width: 100 });
    Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)
Getting around these checks is actually really simple. The easiest method is
to just use a type assertion:
    ts
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)
However, a better approach might be to add a string index signature if you‚Äôre
sure that the object can have some extra properties that are used in some
special way. If `SquareConfig` can have `color` and `width` properties with
the above types, but could _also_ have any number of other properties, then we
could define it like so:
    ts
    interface SquareConfig {
      color?: string;
      width?: number;
      [propName: string]: any;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXyA)
We‚Äôll discuss index signatures in a bit, but here we‚Äôre saying a
`SquareConfig` can have any number of properties, and as long as they aren‚Äôt
`color` or `width`, their types don‚Äôt matter.
One final way to get around these checks, which might be a bit surprising, is
to assign the object to another variable: Since `squareOptions` won‚Äôt undergo
excess property checks, the compiler won‚Äôt give you an error.
    ts
    let squareOptions = { colour: "red", width: 100 };
    let mySquare = createSquare(squareOptions);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXypUYmEAjDAidXHEgZsuAAU9MRkHP44+EQkpACUHBR0jMzGPHz8yJFwHHJK0Mj2lEK4YJhQIEW0tPRMUBwhMQB0NczIAD5tyABEuGJdADRCtFn10WSNohKSyCxJoaQT4lLIAFRzTZPLHABMAAyDtPYOVAD0J8gAtFcImGBXF1QMEGBcWJEA8hoeRJzIALyUJJMMocHoQPr9ERLSQcACMu12BUETxe8hsEVw-28EF8EAxEECnDeuE+3xAnFi-CAA)
The above workaround will work as long as you have a common property between
`squareOptions` and `SquareConfig`. In this example, it was the property
`width`. It will however, fail if the variable does not have any common object
property. For example:
    ts
    let squareOptions = { colour: "red" };
    let mySquare = createSquare(squareOptions);
    Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)
Keep in mind that for simple code like above, you probably shouldn‚Äôt be trying
to ‚Äúget around‚Äù these checks. For more complex object literals that have
methods and hold state, you might need to keep these techniques in mind, but a
majority of excess property errors are actually bugs. That means if you‚Äôre
running into excess property checking problems for something like option bags,
you might need to revise some of your type declarations. In this instance, if
it‚Äôs okay to pass an object with both a `color` or `colour` property to
`createSquare`, you should fix up the definition of `SquareConfig` to reflect
that.
## Function Types
Interfaces are capable of describing the wide range of shapes that JavaScript
objects can take. In addition to describing an object with properties,
interfaces are also capable of describing function types.
To describe a function type with an interface, we give the interface a call
signature. This is like a function declaration with only the parameter list
and return type given. Each parameter in the parameter list requires both name
and type.
    ts
    interface SearchFunc {
      (source: string, subString: string): boolean;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfIA)
Once defined, we can use this function type interface like we would other
interfaces. Here, we show how you can create a variable of a function type and
assign it a function value of the same type.
    ts
    let mySearch: SearchFunc;
    mySearch = function (source: string, subString: string): boolean {
      let result = source.search(subString);
      return result > -1;
    };
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGp6RiQxEUk+GkFhCS5opJlkOUVlUgpkC2QoCHiFS38IpgA6GgwXWgSY6TVKArBGMIKiywA+fQBGNXUVIA)
For function types to correctly type check, the names of the parameters do not
need to match. We could have, for example, written the above example like
this:
    ts
    let mySearch: SearchFunc;
    mySearch = function (src: string, sub: string): boolean {
      let result = src.search(sub);
      return result > -1;
    };
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGoaLDERST4aQSiJaVl5JTgw8koLZCgIOIVLfwiEADoaDBdaQSk1ShywRjCcvMsAPn0ARjV1FSA)
Function parameters are checked one at a time, with the type in each
corresponding parameter position checked against each other. If you do not
want to specify types at all, TypeScript‚Äôs contextual typing can infer the
argument types since the function value is assigned directly to a variable of
type `SearchFunc`. Here, also, the return type of our function expression is
implied by the values it returns (here `false` and `true`).
    ts
    let mySearch: SearchFunc;
    mySearch = function (src, sub) {
      let result = src.search(sub);
      return result > -1;
    };
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoTlBALAYgVxAWQG8AoZZACgGcB7fLCALmRrClAHMAaN-AEaoO3Vu04guASlYC6dADYYQAbjIBfMgHotyALQGE+MAb1klYZAFsAnukw5W9rHkII1ZW85zIAvMhg3MGA6EGoaLD4aQSlSCmQLZCgIaIVLfwiEADoaDBdaGLVKZLBGMOTUywA+fQBGNXUVIA)
Had the function expression returned numbers or strings, the type checker
would have made an error that indicates return type doesn‚Äôt match the return
type described in the `SearchFunc` interface.
    ts
    let mySearch: SearchFunc;
    mySearch = function (src, sub) {
    Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
      Type 'string' is not assignable to type 'boolean'.2322Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
      Type 'string' is not assignable to type 'boolean'.
      let result = src.search(sub);
      return "string";
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGVJzpKALAMQFcDLQBvHUUAApEcdk0ipERaIQDmAGlCJ2AI1rS5kjQVkBKVCrhwANgwIBuHAF8cIUAFpHldkUf2cpoqAC2AT3qMLKgBTGyclJY4fiEsoAC8oKThRHhwBEKITIrKKrq8-KCeoNCQysZeCZmUAHSIDKHCqrqWAiVEYukARFIyOp2WVuZAA)
## Indexable Types
Similarly to how we can use interfaces to describe function types, we can also
describe types that we can ‚Äúindex into‚Äù like `a[10]`, or `ageMap["daniel"]`.
Indexable types have an _index signature_ that describes the types we can use
to index into the object, along with the corresponding return types when
indexing.
Let‚Äôs take an example:
    ts
    interface StringArray {
      [index: number]: string;
    }
    let myArray: StringArray;
    myArray = ["Bob", "Fred"];
    let myStr: string = myArray[0];
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gQSlOAT2QG8AoZZAbVABMIAPALmRAFcBbAI2gF0WAzhmwBuMgF8yZADYQwyDoTwFCLdJhC58RMYuVFkAXmoAiAEIB7LiYA0yEwDEoEWid5iZchYXWDhmo299QioABncgA)
Above, we have a `StringArray` interface that has an index signature. This
index signature states that when a `StringArray` is indexed with a `number`,
it will return a `string`.
There are four types of supported index signatures: string, number, symbol and
template strings. It is possible to support many types of indexers, but the
type returned from a numeric indexer must be a subtype of the type returned
from the string indexer.
This is because when indexing with a `number`, JavaScript will actually
convert that to a `string` before indexing into an object. That means that
indexing with `100` (a `number`) is the same thing as indexing with `"100"` (a
`string`), so the two need to be consistent.
    ts
    interface Animal {
      name: string;
    }
    interface Dog extends Animal {
      breed: string;
    }
    // Error: indexing with a numeric string might get you a completely separate type of Animal!
    interface NotOkay {
      [x: number]: Animal;
    'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
      [x: string]: Dog;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)
While string index signatures are a powerful way to describe the ‚Äúdictionary‚Äù
pattern, they also enforce that all properties match their return type. This
is because a string index declares that `obj.property` is also available as
`obj["property"]`. In the following example, `name`‚Äôs type does not match the
string index‚Äôs type, and the type checker gives an error:
    ts
    interface NumberDictionary {
      [index: string]: number;
      length: number; // ok, length is a number
      name: string; // error, the type of 'name' is not a subtype of the indexer
    Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQBLAOwBcYAzAQwGNJQA5AVwFsAjGAEXyuPzkIugBPUAG9coUAG0iAE0gAPVImLQiAcwC6qQszbQA3LnGgANpEJriAC226Y+0CFBwA1gBpT5y1dD5EoClAdVhhjfiZIJRV1BycYeGgPa1piQQAHWjgyUABycMgc339COGIA0EQGFlSM52zk30I5eVCAXyA)
However, properties of different types are acceptable if the index signature
is a union of the property types:
    ts
    interface NumberOrStringDictionary {
      [index: string]: number | string;
      length: number; // ok, length is a number
      name: string; // ok, name is a string
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbg5dkAGwgawACzkLom5AHoryOgGsANPsNkTyYOORxk8nNF1GTAgxSVINSxs7J184YI8vHzDyDgBfIA)
Finally, you can make index signatures `readonly` in order to prevent
assignment to their indices:
    ts
    interface ReadonlyStringArray {
      readonly [index: number]: string;
    }
    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
    myArray[2] = "Mallory"; // error!
    Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsaBQBLAOwBcYAzAQwGNJQAlSCgEzkIBsBPAZWOiIHMAgrAodQAb1yhQ0Ri3ZiA2kSaQAHqkIBXALYAjGAF1UiXgIDcuAL65cbSMVA6Ow6KNQNmrTjz6EhImIAvKCKAESCbPg0YQA0oGEAQnB6YYaWzq6iimiGoCFhALIUbGwIHGHmoCCgMPDQAIRAA)
You can‚Äôt set `myArray[2]` because the index signature is `readonly`.
### Indexable Types with Template Strings
A template string can be used to indicate that a particular pattern is
allowed, but not all. For example, a HTTP headers object may have a set list
of known headers and support any [custom defined
properties](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) which
are prefixed with `x-`.
    ts
    interface HeadersResponse {
      "content-type": string,
      date: string,
      "content-length": string
      // Permit any property starting with 'x-'.
      [headerName: `x-${string}`]: string;
    }
    function handleResponse(r: HeadersResponse) {
      // Handle known, and x- prefixed
      const type = r["content-type"]
      const poweredBy = r["x-powered-by"]
      // Unknown keys without the prefix raise errors
      const origin = r.origin
    Property 'origin' does not exist on type 'HeadersResponse'.2339Property 'origin' does not exist on type 'HeadersResponse'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQuBLAOwBcYAzAQwGNJQAJSSgExkQCVJEAHOIxOgG9coUACJqfMqQC0JAJ7dIY1IhLRiAcwA0I0M0plV6rbtESpkWQBsrmkgAsVoNRqKb8okKAAKMALYEJKCURPKg3PBK0AouJJQxWqAA7kEOoADkAB4yGQB0egDaDkys0ABylP6QqAAGOQAkgq5aAL61ALrGbpoA3Lit+OQArkTUJAR8oA6hzLacPHwCABTQqIwsbAu8-JAAlKDCXmD0s7agANZEcMlE2iFEzKA5EdCQ5ARZkMx6kvzBCiUoAAvKBoIULKQrCQ5IplB1fktgrxkjBvgAhcKg8FiHIotHMGQAI3kYgRem8AFUiFcbkRLpB5IgUmk4MMASVXu9PmDKAQBKAYPAkIj-qAEARNMQQWC8hKpUQBkA)
## Class Types
### Implementing an interface
One of the most common uses of interfaces in languages like C# and Java, that
of explicitly enforcing that a class meets a particular contract, is also
possible in TypeScript.
    ts
    interface ClockInterface {
      currentTime: Date;
    }
    class Clock implements ClockInterface {
      currentTime: Date = new Date();
      constructor(h: number, m: number) {}
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIBsD2CDWBJcaeJZAbwChlkEBXKKCcAFWAFsIAuZAETkgG5yAX3LkE6OAGdJaLLmRsADugjtwMjNnyFYiFBSq16jMC3ZdekZAF5kICAHcefCAAoAlIMOYQksFBoEMEwoVwALLhAaVgAjaAAaZFZI6LiodzIRISA)
You can also describe methods in an interface that are implemented in the
class, as we do with `setTime` in the below example:
    ts
    interface ClockInterface {
      currentTime: Date;
      setTime(d: Date): void;
    }
    class Clock implements ClockInterface {
      currentTime: Date = new Date();
      setTime(d: Date) {
        this.currentTime = d;
      }
      constructor(h: number, m: number) {}
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwCh5jpcHRNlABhKukQBrEgNhCRAb26hQiAK6xY2fgBV4AW2ysAIg2wBuFaC7R9RgBQATU+YCUrAG7p4TqwF9ubkQqCkhIMQlpUENMKmwjfgjxSRl+QQphUGVVDS0dO0NjUDMBUABeUGJsAHcS8wc3K1Vbe2xnVwE3bOtVaAALeEgAOjztPSKK0D9rQNymGFh1ZHRYB37WYnUDACNcABpQA03tvdhuxUD-IA)
Interfaces describe the public side of the class, rather than both the public
and private side. This prohibits you from using them to check that a class
also has particular types for the private side of the class instance.
### Difference between the static and instance sides of classes
When working with classes and interfaces, it helps to keep in mind that a
class has _two_ types: the type of the static side and the type of the
instance side. You may notice that if you create an interface with a construct
signature and try to create a class that implements this interface you get an
error:
    ts
    interface ClockConstructor {
      new (hour: number, minute: number);
    }
    class Clock implements ClockConstructor {
    Class 'Clock' incorrectly implements interface 'ClockConstructor'.
      Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.2420Class 'Clock' incorrectly implements interface 'ClockConstructor'.
      Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.
      currentTime: Date;
      constructor(h: number, m: number) {}
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYCMBmUAmAFnwwIFYA2QgKBAkQBdoBLAYwYAV4AHGBgTwCSAO2YNmAQwA2zAF4TxcYagBm0xJFphwwuIIC23GazEBBYf1XrNzYQxhrWkUAGEpcVgGsXSxtACu7AigAN7UoKDCkADuoAAUABZw-tCowv76AEYwADSg+rb+9mkZ2dAAlADc1AC+1NSsUhKIiK7uXqDMhlKQ+pB2rW4e3r5MgQzBYRGsKdD9DAAqXZCoACIKkNXTowFB0IklWbn5h2XloXU1QA)
This is because when a class implements an interface, only the instance side
of the class is checked. Since the constructor sits in the static side, it is
not included in this check.
Instead, you would need to work with the static side of the class directly. In
this example, we define two interfaces, `ClockConstructor` for the constructor
and `ClockInterface` for the instance methods. Then, for convenience, we
define a constructor function `createClock` that creates instances of the type
that is passed to it:
    ts
    interface ClockConstructor {
      new (hour: number, minute: number): ClockInterface;
    }
    interface ClockInterface {
      tick(): void;
    }
    function createClock(
      ctor: ClockConstructor,
      hour: number,
      minute: number
    ): ClockInterface {
      return new ctor(hour, minute);
    }
    class DigitalClock implements ClockInterface {
      constructor(h: number, m: number) {}
      tick() {
        console.log("beep beep");
      }
    }
    class AnalogClock implements ClockInterface {
      constructor(h: number, m: number) {}
      tick() {
        console.log("tick tock");
      }
    }
    let digital = createClock(DigitalClock, 12, 17);
    let analog = createClock(AnalogClock, 7, 32);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIBsD2CDWrMgDOYUArgmJlMgN4BQyyIEA7sgBQAWmpUAXE1IBbAEbQANMiGhSkASGFioASgEZsOAJLho8JAG46AXzp1QkWIhTrc2i3pT1GYYLnarkAN0zAAJoZM6GFIQCmACZAQoCDhIGxx2BkjKfjQsXHwiEnIU8STuXnlFCSTpBTlBUWg6D3i7XStaJOiwXhAmVmSqLh4oSTLZCGUA0wR0OEJCZAARYABzYDA4dHjkYCEAB3QIIQhwKbqdSyQmxgQCYjIKbs4iqr6pO6VlWhNnVwSXp0ZIi8xtgB0WDm7AARGIIBtkBCNqDhkkTIExhMpgBBEDLTBzVbrLY7PZgA7pLRHBynX5ZK4pLhPCSPSrPV5JFxuL5JM5-QHAsEsnDISi4OGGRiI0zbMDIXzzRbLZAAXki0ViEHi7FmCyWK2JkgAjAAmXUAdnh4uQcAxwPlipicWJ7HRmOx2uQhskAGY9cMgA)
Because `createClock`‚Äôs first parameter is of type `ClockConstructor`, in
`createClock(AnalogClock, 7, 32)`, it checks that `AnalogClock` has the
correct constructor signature.
Another simple way is to use class expressions:
    ts
    interface ClockConstructor {
      new (hour: number, minute: number): ClockInterface;
    }
    interface ClockInterface {
      tick(): void;
    }
    const Clock: ClockConstructor = class Clock implements ClockInterface {
      constructor(h: number, m: number) {}
      tick() {
        console.log("beep beep");
      }
    };
    let clock = new Clock(12, 17);
    clock.tick();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwCgQJj0hALaYaiMgEFi+Vhypdu8YtFwdE2UAGEq6RAGtNTGLACuydLFABvbqFDFsAd1AAKABboTsVsRNCARrgANKBCSiYqPn6BsACUrNq6eiQqsGrYANzcAL7cisqqFOpaOvophcU2duT6LvGgAG7o8AAmWbnciEbQJUkJpQbdpuaWALygiFQUkJC9+qDwIlTYQtjKs4llBWlFGlUTQ2bQFu5RAcGhZzGx1rnVSHp11rZ2B8SQ6MsAdDoA5i4AIkC2EwoGBmABsSydly2Sy3GWPUmSVA4wczk2jwAjAAmEJYgDsUM6Ay+NUeUKAA)
## Extending Interfaces
Like classes, interfaces can extend each other. This allows you to copy the
members of one interface into another, which gives you more flexibility in how
you separate your interfaces into reusable components.
    ts
    interface Shape {
      color: string;
    }
    interface Square extends Shape {
      sideLength: number;
    }
    let square = {} as Square;
    square.color = "blue";
    square.sideLength = 10;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyCA9gDYlQBcyAzmFKAOYDc+AvvvqJLIiqgCOAVzhQUEAB6QQAE1ppMOZASK1gsiABkIIJmHQ0QwgLYAjaG074yEMHRFiUAXhXtkcBUNHi2tR+IAdKQUUMiuAERmZMIQEX4BEIHqmjp6BuHIAIwADCxAA)
An interface can extend multiple interfaces, creating a combination of all of
the interfaces.
    ts
    interface Shape {
      color: string;
    }
    interface PenStroke {
      penWidth: number;
    }
    interface Square extends Shape, PenStroke {
      sideLength: number;
    }
    let square = {} as Square;
    square.color = "blue";
    square.sideLength = 10;
    square.penWidth = 5.0;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyCA9gDYlQBcyAzmFKAOYDc+AvvvqJLIigAUIIVAxIBrPIWQ4QAdWAATMOhogArgFsARtDadu4aPCRoAjurhQUEAB6QQi2mkw4ANMiEixk5ASK0ShAAMsJMKmpaulD6XGQQYHQWVigAvH7syHDOqMnWbLR5EAB0pBRQyOkARNpk6hBVBUXFgYohYSqVyACMAAxNltbFsgrK6F0ArMX9QA)
## Hybrid Types
As we mentioned earlier, interfaces can describe the rich types present in
real world JavaScript. Because of JavaScript‚Äôs dynamic and flexible nature,
you may occasionally encounter an object that works as a combination of some
of the types described above.
One such example is an object that acts as both a function and an object, with
additional properties:
    ts
    interface Counter {
      (start: number): string;
      interval: number;
      reset(): void;
    }
    function getCounter(): Counter {
      let counter = function (start: number) {} as Counter;
      counter.interval = 123;
      counter.reset = function () {};
      return counter;
    }
    let c = getCounter();
    c(10);
    c.reset();
    c.interval = 5.0;
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsCu5rIN4BQyyAFAM5hxRgBcyImAtgEbQCUdFUoA5gNxFkoSFABucADZ0GLaAOJQIZCGBIdko9MAAmAgL4ECMbAjDB0IZDxUZsItXVs4o+QRJXIEWZ8gC8yYxBTc0tySmppJlYoNnw9ZDgyNG8ReU8U6AA6YWhxCT9kAEYAJgBmNK87LMVlMALA4ItSWLw9NMUwTChLSud9Q3c6hALrMCd7NgEEEkKABkmCBEyalTUp7Oc8goBWTNm+IA)
When interacting with 3rd-party JavaScript, you may need to use patterns like
the above to fully describe the shape of the type.
## Interfaces Extending Classes
When an interface type extends a class type it inherits the members of the
class but not their implementations. It is as if the interface had declared
all of the members of the class without providing an implementation.
Interfaces inherit even the private and protected members of a base class.
This means that when you create an interface that extends a class with private
or protected members, that interface type can only be implemented by that
class or a subclass of it.
This is useful when you have a large inheritance hierarchy, but want to
specify that your code works with only subclasses that have certain
properties. The subclasses don‚Äôt have to be related besides inheriting from
the base class. For example:
    ts
    class Control {
      private state: any;
    }
    interface SelectableControl extends Control {
      select(): void;
    }
    class Button extends Control implements SelectableControl {
      select() {}
    }
    class TextBox extends Control {
      select() {}
    }
    class ImageControl implements SelectableControl {
    Class 'ImageControl' incorrectly implements interface 'SelectableControl'.
      Types have separate declarations of a private property 'state'.2420Class 'ImageControl' incorrectly implements interface 'SelectableControl'.
      Types have separate declarations of a private property 'state'.
      private state: any;
      select() {}
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMX0BY1dMcAoAYwBsBDRRUAYTgDsAXeC0AbxNFAAdoASwBuVFpFCIWYyKipMAngG4SAXxIlBrGADMqZCQGVIFSGWkAjU41btQkAB7imAEzo22cDt16ITZlgAKAEpUYThBFxV1cmpaUAAhAFcWFmZ7J0hXd2ZPDkEAWz5TAqyWOmNTcyorSA87H0l-cxCudRjKGjoAFUcWBLgHDOc3BlyGniaqoOC2tQ1O+IBJAqoAczrxr1BC4shS1grmy2st70mBERlJaXE5RRVfY9bOdqA)
In the above example, `SelectableControl` contains all of the members of
`Control`, including the private `state` property. Since `state` is a private
member it is only possible for descendants of `Control` to implement
`SelectableControl`. This is because only descendants of `Control` will have a
`state` private member that originates in the same declaration, which is a
requirement for private members to be compatible.
Within the `Control` class it is possible to access the `state` private member
through an instance of `SelectableControl`. Effectively, a `SelectableControl`
acts like a `Control` that is known to have a `select` method. The `Button`
and `TextBox` classes are subtypes of `SelectableControl` (because they both
inherit from `Control` and have a `select` method). The `ImageControl` class
has its own `state` private member rather than extending `Control`, so it
cannot implement `SelectableControl`.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v1/Interfaces.md) ‚ù§
Contributors to this page:  
RC
DR
OT
J
MH
44+
Last updated: Sep 16, 2024  
Was this page helpful?
# JS Projects Utilizing TypeScript
The type system in TypeScript has different levels of strictness when working
with a codebase:
  * A type-system based only on inference with JavaScript code
  * Incremental typing in JavaScript [via JSDoc](/docs/handbook/jsdoc-supported-types.html)
  * Using `// @ts-check` in a JavaScript file
  * TypeScript code
  * TypeScript with [`strict`](/tsconfig#strict) enabled
Each step represents a move towards a safer type-system, but not every project
needs that level of verification.
## TypeScript with JavaScript
This is when you use an editor which uses TypeScript to provide tooling like
auto-complete, jump to symbol and refactoring tools like rename. The
[homepage](/) has a list of editors which have TypeScript plugins.
## Providing Type Hints in JS via JSDoc
In a `.js` file, types can often be inferred. When types can‚Äôt be inferred,
they can be specified using JSDoc syntax.
JSDoc annotations come before a declaration will be used to set the type of
that declaration. For example:
    js
    /** @type {number} */
    var x;
    x = 0; // OK
    x = false; // OK?!
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4C+4IwAUAG4CG+4AHgNxll3gC84ADA+MMOAHkA0i3bgAZlQA2AZ0Q8+goQH4AhEA)
You can find the full list of supported JSDoc patterns [in JSDoc Supported
Types](/docs/handbook/jsdoc-supported-types.html).
## `@ts-check`
The last line of the previous code sample would raise an error in TypeScript,
but it doesn‚Äôt by default in a JS project. To enable errors in your JavaScript
files add: `// @ts-check` to the first line in your `.js` files to have
TypeScript raise it as an error.
    js
    // @ts-check
    /** @type {number} */
    var x;
    x = 0; // OK
    x = false; // Not OK
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUCCyBOuB7XaALlACYBmc8rAKjokgE8AHZUAbwDsBXAWwBGeAL6g6wDADcAhrlAAPANwYMC0AF5QABiWhsAeQDSazaABmMgDbRke7ADkCkUMaA)
If you have a lot of JavaScript files you want to add errors to then you can
switch to using a [`jsconfig.json`](/docs/handbook/tsconfig-json.html). You
can skip checking some files by adding a `// @ts-nocheck` comment to files.
TypeScript may offer you errors which you disagree with, in those cases you
can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-
expect-error` on the preceding line.
    js
    // @ts-check
    /** @type {number} */
    var x;
    x = 0; // OK
    // @ts-expect-error
    x = false; // Not OK
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNikBPAB2VAG8A7AVwFsAjZAJwF9RtgMA3AQ0dAA8A3Bgz9QAXlAAGQaBCgA8gGksYKHGT8S8SLCaMA9o1ETQAM24AbaMlnyAcgciKlQA)
To learn more about how JavaScript is interpreted by TypeScript read [How TS
Type Checks JS](/docs/handbook/type-checking-javascript-files.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Type Checking JavaScript FilesHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/type-checking-javascript-files.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Intro to JS with
TS.md) ‚ù§
Contributors to this page:  
OT
Last updated: Sep 16, 2024  
Was this page helpful?
# The TypeScript Handbook
## About this Handbook
Over 20 years after its introduction to the programming community, JavaScript
is now one of the most widespread cross-platform languages ever created.
Starting as a small scripting language for adding trivial interactivity to
webpages, JavaScript has grown to be a language of choice for both frontend
and backend applications of every size. While the size, scope, and complexity
of programs written in JavaScript has grown exponentially, the ability of the
JavaScript language to express the relationships between different units of
code has not. Combined with JavaScript‚Äôs rather peculiar runtime semantics,
this mismatch between language and program complexity has made JavaScript
development a difficult task to manage at scale.
The most common kinds of errors that programmers write can be described as
type errors: a certain kind of value was used where a different kind of value
was expected. This could be due to simple typos, a failure to understand the
API surface of a library, incorrect assumptions about runtime behavior, or
other errors. The goal of TypeScript is to be a static typechecker for
JavaScript programs - in other words, a tool that runs before your code runs
(static) and ensures that the types of the program are correct (typechecked).
If you are coming to TypeScript without a JavaScript background, with the
intention of TypeScript being your first language, we recommend you first
start reading the documentation on either the [Microsoft Learn JavaScript
tutorial](https://developer.microsoft.com/javascript/) or read [JavaScript at
the Mozilla Web
Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide). If you have
experience in other languages, you should be able to pick up JavaScript syntax
quite quickly by reading the handbook.
## How is this Handbook Structured
The handbook is split into two sections:
  * **The Handbook**
The TypeScript Handbook is intended to be a comprehensive document that
explains TypeScript to everyday programmers. You can read the handbook by
going from top to bottom in the left-hand navigation.
You should expect each chapter or page to provide you with a strong
understanding of the given concepts. The TypeScript Handbook is not a complete
language specification, but it is intended to be a comprehensive guide to all
of the language‚Äôs features and behaviors.
A reader who completes the walkthrough should be able to:
    * Read and understand commonly-used TypeScript syntax and patterns
    * Explain the effects of important compiler options
    * Correctly predict type system behavior in most cases
In the interests of clarity and brevity, the main content of the Handbook will
not explore every edge case or minutiae of the features being covered. You can
find more details on particular concepts in the reference articles.
  * **Reference Files**
The reference section below the handbook in the navigation is built to provide
a richer understanding of how a particular part of TypeScript works. You can
read it top-to-bottom, but each section aims to provide a deeper explanation
of a single concept - meaning there is no aim for continuity.
### Non-Goals
The Handbook is also intended to be a concise document that can be comfortably
read in a few hours. Certain topics won‚Äôt be covered in order to keep things
short.
Specifically, the Handbook does not fully introduce core JavaScript basics
like functions, classes, and closures. Where appropriate, we‚Äôll include links
to background reading that you can use to read up on those concepts.
The Handbook also isn‚Äôt intended to be a replacement for a language
specification. In some cases, edge cases or formal descriptions of behavior
will be skipped in favor of high-level, easier-to-understand explanations.
Instead, there are separate reference pages that more precisely and formally
describe many aspects of TypeScript‚Äôs behavior. The reference pages are not
intended for readers unfamiliar with TypeScript, so they may use advanced
terminology or reference topics you haven‚Äôt read about yet.
Finally, the Handbook won‚Äôt cover how TypeScript interacts with other tools,
except where necessary. Topics like how to configure TypeScript with webpack,
rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue,
angular, svelte, jquery, yarn, or npm are out of scope - you can find these
resources elsewhere on the web.
## Get Started
Before getting started with [The Basics](/docs/handbook/2/basic-types.html),
we recommend reading one of the following introductory pages. These
introductions are intended to highlight key similarities and differences
between TypeScript and your favored programming language, and clear up common
misconceptions specific to those languages.
  * [TypeScript for the New Programmer](/docs/handbook/typescript-from-scratch.html)
  * [TypeScript for JavaScript Programmers](/docs/handbook/typescript-in-5-minutes.html)
  * [TypeScript for Java/C# Programmers](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [TypeScript for Functional Programmers](/docs/handbook/typescript-in-5-minutes-func.html)
Otherwise, jump to [The Basics](/docs/handbook/2/basic-types.html).
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [The BasicsStep one in learning TypeScript: The basic
types.](/docs/handbook/2/basic-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/handbook-v2/The Handbook.md) ‚ù§
Contributors to this page:  
OT
MW
M
N
Ë∞≠
5+
Last updated: Sep 16, 2024  
Was this page helpful?
# Iterators and Generators
## Iterables
An object is deemed iterable if it has an implementation for the
[`Symbol.iterator`](symbols.html#symboliterator) property. Some built-in types
like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have
their `Symbol.iterator` property already implemented. `Symbol.iterator`
function on an object is responsible for returning the list of values to
iterate on.
### `Iterable` interface
`Iterable` is a type we can use if we want to take in types listed above which
are iterable. Here is an example:
    ts
    function toArray<X>(xs: Iterable<X>): X[] {
      return [...xs]
    }
### `for..of` statements
`for..of` loops over an iterable object, invoking the `Symbol.iterator`
property on the object. Here is a simple `for..of` loop on an array:
    ts
    let someArray = [1, "string", false];
    for (let entry of someArray) {
      console.log(entry); // 1, "string", false
    }
### `for..of` vs. `for..in` statements
Both `for..of` and `for..in` statements iterate over lists; the values
iterated on are different though, `for..in` returns a list of _keys_ on the
object being iterated, whereas `for..of` returns a list of _values_ of the
numeric properties of the object being iterated.
Here is an example that demonstrates this distinction:
    ts
    let list = [4, 5, 6];
    for (let i in list) {
      console.log(i); // "0", "1", "2",
    }
    for (let i of list) {
      console.log(i); // 4, 5, 6
    }
Another distinction is that `for..in` operates on any object; it serves as a
way to inspect properties on this object. `for..of` on the other hand, is
mainly interested in values of iterable objects. Built-in objects like `Map`
and `Set` implement `Symbol.iterator` property allowing access to stored
values.
    ts
    let pets = new Set(["Cat", "Dog", "Hamster"]);
    pets["species"] = "mammals";
    for (let pet in pets) {
      console.log(pet); // "species"
    }
    for (let pet of pets) {
      console.log(pet); // "Cat", "Dog", "Hamster"
    }
### Code generation
#### Targeting ES5
When targeting an ES5-compliant engine, iterators are only allowed on values
of `Array` type. It is an error to use `for..of` loops on non-Array values,
even if these non-Array values implement the `Symbol.iterator` property.
The compiler will generate a simple `for` loop for a `for..of` loop, for
instance:
    ts
    let numbers = [1, 2, 3];
    for (let num of numbers) {
      console.log(num);
    }
will be generated as:
    js
    var numbers = [1, 2, 3];
    for (var _i = 0; _i < numbers.length; _i++) {
      var num = numbers[_i];
      console.log(num);
    }
#### Targeting ECMAScript 2015 and higher
When targeting an ECMAScript 2015-compliant engine, the compiler will generate
`for..of` loops to target the built-in iterator implementation in the engine.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Iterators and
Generators.md) ‚ù§
Contributors to this page:  
MH
OT
GB
JB
NS
12+
Last updated: Sep 16, 2024  
Was this page helpful?
# JSDoc Reference
The list below outlines which constructs are currently supported when using
JSDoc annotations to provide type information in JavaScript files.
Note:
  * Any tags which are not explicitly listed below (such as `@async`) are not yet supported.
  * Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files.
#### Types
  * `@type`
  * `@param` (or `@arg` or `@argument`)
  * `@returns` (or `@return`)
  * `@typedef`
  * `@callback`
  * `@template`
  * `@satisfies`
#### Classes
  * Property Modifiers `@public`, `@private`, `@protected`, `@readonly`
  * `@override`
  * `@extends` (or `@augments`)
  * `@implements`
  * `@class` (or `@constructor`)
  * `@this`
#### Documentation
Documentation tags work in both TypeScript and JavaScript.
  * `@deprecated`
  * `@see`
  * `@link`
#### Other
  * `@enum`
  * `@author`
  * Other supported patterns
  * Unsupported patterns
  * Unsupported tags
The meaning is usually the same, or a superset, of the meaning of the tag
given at [jsdoc.app](https://jsdoc.app). The code below describes the
differences and gives some example usage of each tag.
**Note:** You can use [the playground to explore JSDoc
support](/play?useJavaScript=truee=4#example/jsdoc-support).
## Types
### `@type`
You can reference types with the ‚Äú@type‚Äù tag. The type can be:
  1. Primitive, like `string` or `number`.
  2. Declared in a TypeScript declaration, either global or imported.
  3. Declared in a JSDoc `@typedef` tag.
You can use most JSDoc type syntax and any TypeScript syntax, from [the most
basic like `string`](/docs/handbook/2/basic-types.html) to [the most advanced,
like conditional types](/docs/handbook/2/conditional-types.html).
    js
    /**
     * @type {string}
     */
    var s;
    /** @type {Window} */
    var win;
    /** @type {PromiseLike<string>} */
    var promisedString;
    // You can specify an HTML Element with DOM properties
    /** @type {HTMLElement} */
    var myElement = document.querySelector(selector);
    element.dataset.myData = "";
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOYC+UIw4AbgIa6RYDc44oMCK6GA6kQCYB7AO6loVOg2FEWbMHCRpMABVyCAtviyoAMvgDWqADw4CJAHxjKNepGRrN2-gGU8RYrODBIATUEBXSABjWkJGNCD8ADNESFDIAAkAFQBZHUgAUQAbVHVUQnhIaXgAC0gAEQB5FLs1NFx4fFQsOQ5FbmS07Nz8+CsJW3VEbryCyABeSCEg-1H4ADoAR39UXERnVByg+EFcAAptLZ3cAEoWTZ6C+f5aeFptBaHy29oJyAAid6YgA)
`@type` can specify a union type ‚Äî for example, something can be either a
string or a boolean.
    js
    /**
     * @type {string | boolean}
     */
    var sb;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOaQA+kARgPbUA2qAhoQL5QjDgBujukWlANxA)
You can specify array types using a variety of syntaxes:
    js
    /** @type {number[]} */
    var ns;
    /** @type {Array.<number>} */
    var jsdoc;
    /** @type {Array<number>} */
    var nas;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4DaAugL7gjABQAbgIb7hoDOA3FaBDAsigIL58dWADoAPJlwEAfOUq0G4AFbMAJgHsAxu05Q4SVAKGwJ2PPlkVq9RmjpsgA)
You can also specify object literal types. For example, an object with
properties ‚Äòa‚Äô (string) and ‚Äòb‚Äô (number) uses the following syntax:
    js
    /** @type {{ a: string, b: number }} */
    var var9;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeLwEMBc4DO0AnASwDsBzAGnACMcSBXAW2sQPAF93wRgAoANwxtBBAJwBuIA)
You can specify map-like and array-like objects using string and number index
signatures, using either standard JSDoc syntax or TypeScript syntax.
    js
    /**
     * A map-like object that maps arbitrary `string` properties to `number`s.
     *
     * @type {Object.<string, number>}
     */
    var stringToNumber;
    /** @type {Object.<number, object>} */
    var arrayLike;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUhBSC2BDADgWgDYEsDWBTSAewCMArPAYwBdIqALJG5FAZ0iQCdisqPOBPSAAMWvLADsA5kMgoOhFHg5UseNlULDxAVwTElIgHRQI0SAAEq-RZADeAeTKUqhgDyiOEyQBpIOvUoAfAC+JsDgAG6ckB5eACqEAHK6+hwA3ODgoDCW1gQOTtRu-qm+JOTUIdDhURzsHHz8ADK4eGlAA)
The preceding two types are equivalent to the TypeScript types `{ [x: string]:
number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.
You can specify function types using either TypeScript or Google Closure
syntax:
    js
    /** @type {function(string, boolean): number} Closure syntax */
    var sbn;
    /** @type {(s: string, b: boolean) => number} TypeScript syntax */
    var sbn2;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAzArgOwMbQJYD2WAFAM7QBO+WA5gDTgBGhhANogIZYCUAXOCwYAtk0SUAvuADCbQmQyVkZWFmicAHuBDAAUADdOlcGSZYA3LtAQYCZCnICK1OoyYCW7Lr3ABeAHyCImKS4AAqdgDKONTw0Caq6lo6BkYmZgBM5kA)
Or you can just use the unspecified `Function` type:
    js
    /** @type {Function} */
    var fn7;
    /** @type {function} */
    var fn6;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAxArgOwMbQJYD2WAvuCMAFABuAhgE7gBmWA7ANyWgQwLIpNseIqXJU6jFgDZ2QA)
Other types from Closure also work:
    js
    /**
     * @type {*} - can be 'any' type
     */
    var star;
    /**
     * @type {?} - unknown type (same as 'any')
     */
    var question;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4gL6QLSQDGAhgHaQBG6A5GYtZEmlCMOAG7EBOkAzvNwDc4UBGhwm6DAH5cBAK6kA1qQD2Ad3KTIACl7EAtumK9ItUvQCULNpx4BHean4BLVaUFA)
#### Casts
TypeScript borrows cast syntax from Google Closure. This lets you cast types
to other types by adding a `@type` tag before any parenthesized expression.
    js
    /**
     * @type {number | string}
     */
    var numberOrString = Math.random() < 0.5 ? "hello" : 100;
    var typeAssertedNumber = /** @type {number} */ (numberOrString);
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSAZ3mIEssBzAXyhGHADcBDU3QkgPLEAyjXoNIAXkgBZLvAAWAOmJcsAEwD2eABQBKSAB5IABiUBWSAH5IAIgWoANo823IALkgBGEyYDcnDyQSGgAgpSUJPCo6gBy+ESk0qAwCCjo2AkkTNDAkDp8iUKidIx6fkA)
You can even cast to `const` just like TypeScript:
    js
    let one = /** @type {const} */(1);
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gdiEF4IHoBUqIAEwE8AO8A3gMawDOYAvhKsgBQCMAlANxA)
#### Import types
You can import declarations from other files using import types. This syntax
is TypeScript-specific and differs from the JSDoc standard:
    js
    // @filename: types.d.ts
    export type Pet = {
      name: string,
    };
    // @filename: main.js
    /**
     * @param {import("./types").Pet} p
     */
    function walk(p) {
      console.log(`Walking ${p.name}...`);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NWogIMBOMyhUyWSQBWNYACoLIixHzJmaIdFRNWACgBEJYHkJFPAEoSHmxlUHwbYGpIAFdEAGNsaEZEUAB3ZFgAa3d8QKERUATUokYEElhGOXcAAwB1LOzZOVAAEkF8Ej1lEj7awPVlIA)
import types can be used in type alias declarations:
    js
    /**
     * @typedef {import("./types").Pet} Pet
     */
    /**
     * @type {Pet}
     */
    var myPet;
    myPet.name;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NRAQYCcZlCpkskgCsamgLSWAxgFdsl8xoBUTkU4h5CZeJCHRUTKwAFABEJMCexCEAlCQ82MrcvG7A1M6uoO7gkULxyinUAG7IzPq48eqo5bwkuqpAA)
import types can be used to get the type of a value from a module if you don‚Äôt
know the type, or if it has a large type that is annoying to type:
    js
    /**
     * @type {typeof import("./accounts").userAccount}
     */
    var x = require("./accounts").userAccount;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZBjHB7AV0QBcBnAOgBMLyAoeADwAd8AnE0AxMzws+GwCCeIqVABeUAG86oUCnRYARADk08ZQBo52KlTbwyZFUMR6DRstt2teyWAGF8VTKGU35BYiTYBPFU9QZlhkRHgSQJ15Mj9eeFQo3QBzB2RGAPcg4mgAN0EBJIBfAG46EAgYBEU3VGRoRAoAKzJysABaTpxCEk728oAqAbkBiBI-ZngZccn8SFBoVFYOAAplCmBcb1JrAEoKfkERbZIikeA6XOQ2UEZJUEMAR0JoQzWNrbFyZX3D4VEfCUgA)
### `@param` and `@returns`
`@param` uses the same type syntax as `@type`, but adds a parameter name. The
parameter may also be declared optional by surrounding the name with square
brackets:
    js
    // Parameters may be declared in a variety of syntactic forms
    /**
     * @param {string}  p1 - A string param.
     * @param {string=} p2 - An optional param (Google Closure syntax)
     * @param {string} [p3] - Another optional param (JSDoc syntax).
     * @param {string} [p4="test"] - An optional param with a default value
     * @returns {string} This is the result
     */
    function stringsStringStrings(p1, p2, p3, p4) {
      // TODO
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHQM6jpAnqARgqACYIDGANjAkaAJYB2okoAbjLcrgPYBmoa2ekkikktUqB5docNAChgAKkVzQi0AAEADjHigA3miTQGAcwC+oUFoCMoALSgAgv2NnruuADpV67Z4MjE3pTAF5LLQAmB2dGLi0xLnpIcg9YOFAACgBxLi5TckIAYXIuNABXaEIBIUgADwBKX00ddMC3EMsAbS0AZgBdGKd6LiQAC1RQeMTk1Na9TIApAGUAES4JGuFGnzUWgMMOi1AegBZQgCIUIwvBx2GphNoklLS9AHdacaZiBB5IcrkJCsFLlBDNDRVJCVegYQ7BY4AFTGtAwqNA40IVQqQN8wDkPHK9FEz0YQTMaGWRypCLQmVsABprJEmX1WacGgZVKAQKBEQB5Vb8uTmIA)
Likewise, for the return type of a function:
    js
    /**
     * @return {PromiseLike<string>}
     */
    function ps() {}
    /**
     * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'
     */
    function ab() {}
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAnApgFwK7wHaQN4AV4D2AtgJYDOiAMiQNaIA8Zy8JGA5gHwC+UIw4AM1QYAxshIEsABzIAKAJQ4e4UBGhwkaTGRzZIAQwBckJi3YAaSACNjGVESuJ4kLl0gBaSAFl9AT0ioFJAA5Ago6BhkwQY6AO6IADYJMSFhWhjBvPxCouKSBlYKSkA)
### `@typedef`, `@callback`, and `@param`
You can define complex types with `@typedef`. Similar syntax works with
`@param`.
    js
    /**
     * @typedef {Object} SpecialType - creates a new type named 'SpecialType'
     * @property {string} prop1 - a string property of SpecialType
     * @property {number} prop2 - a number property of SpecialType
     * @property {number=} prop3 - an optional number property of SpecialType
     * @prop {number} [prop4] - an optional number property of SpecialType
     * @prop {number} [prop5=42] - an optional number property of SpecialType with default
     */
    /** @type {SpecialType} */
    var specialTypeObject;
    specialTypeObject.prop3;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8DyARgFaoDG8AvpAMppkCWAhgDYAqKqkAtJGQE6om8VAGdITSADtUAd0hI00pgFsMkAOR1yzdpw1QYsZPwD2afkjyj4-BlIDm1E+YCMPCZBt3HkFxatTHG1GVg40Qzh-VEtEPCkAVxVCGOczZAAmD0lE5Ji-dJjA4PpdcNRI40LY+KSU-gBeNPMAZmypSHN4BlMpVmk6-OiaoNpSsM5K-1q8-moAbX8AFgBdds7kbt7+3PqC8yK40ZCyyego9Jn6hf8AVgaljLXeJg6unr6WAdn9gKOSnQTJSyBjwAAWkEwWCYCRY8EMwHA4FARkUXFwJyBqGoIERADcmPwvOM9GgiKQKABucCiEnlcnkeAAOn8LUpQA)
You can use either `object` or `Object` on the first line.
    js
    /**
     * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'
     * @property {string} prop1 - a string property of SpecialType1
     * @property {number} prop2 - a number property of SpecialType1
     * @property {number=} prop3 - an optional number property of SpecialType1
     */
    /** @type {SpecialType1} */
    var specialTypeObject1;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8D2ARgFaoDG8AvpAMppkCWAhgDYAqKqAjJALSRkATqibxUAZ0hNIAO1QB3SEjSymAWwyQA5HXLN2nLlqgxYyQfjSCkecfEEMZAc2rnLPftLsPnkN1Zt8HF1GVg40LhM4f1RrRDwZAFc1QljXC2QAJj4pWWTUwT8M2MDg+n1w7iizYriE-NiAXnTLAGYcphlIS3gGfBlWPJTYossS+KDacrDDE2BwcFBTZVQ8EIrDahB5gDcmQvFpgzQAeRJyeC4AbiA)
`@param` allows a similar syntax for one-off type specifications. Note that
the nested property names must be prefixed with the name of the parameter:
    js
    /**
     * @param {Object} options - The shape is the same as SpecialType above
     * @param {string} options.prop1
     * @param {number} options.prop2
     * @param {number=} options.prop3
     * @param {number} [options.prop4]
     * @param {number} [options.prop5=42]
     */
    function special(options) {
      return (options.prop4 || 1001) + options.prop5;
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwPICMBWApgMYAuAvpAPbykCWVAdgM6QC0kAKgBaGTPdE8PnVale-dH0SsAysOJ1EAG04BPYZES4qAN0JQYCFOizNSyOowDmlGvSbMAdPGQ0AjIbhJUGTIwBXNFxCZDtaBhYXN3gAJi9jXyxA4NCAXnCHKNcaAGYEn1N-IJCwyABte0jnHPgAFgBdApM-FNLKSojHaJoAVjS62KboYHAAMwDGMkj+BSVlAAoqxwBKLChIZEJSAORGSCWu7Ji6yAAfM8h3AAZr9zWAamojmpjegG5wciA)
`@callback` is similar to `@typedef`, but it specifies a function type instead
of an object type:
    js
    /**
     * @callback Predicate
     * @param {string} data
     * @param {number} [index]
     * @returns {boolean}
     */
    /** @type {Predicate} */
    const ok = (s) => !(s.length % 2);
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBBjAhgG2QI0fA1pACgJwFMATASyQBdCoZYAHRfRAW0gG8BnC-UgOwHMAvpGKIKiGnAZNWbXgFdmaQvmEBtPsUIAPALqTYRCvPy8O7NAHtLyQol6CawcOFC0KATzqF2BEuTFCYRBneEszCkhLHABeSAAKDgBKSBiAPkgAQkSAOlsBCgALSABSSAAmJIBuIA)
Of course, any of these types can be declared using TypeScript syntax in a
single-line `@typedef`:
    js
    /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */
    /** @typedef {(data: string, index?: number) => boolean} Predicate */
### `@template`
You can declare type parameters with the `@template` tag. This lets you make
functions, classes, or types that are generic:
    js
    /**
     * @template T
     * @param {T} x - A generic parameter that flows through to the return type
     * @returns {T}
     */
    function id(x) {
      return x;
    }
    const a = id("string");
    const b = id(123);
    const c = id({});
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyqYBOmykA3rgL6QAekAtJAIKQDmiAdoiQJYBjSMTLJESEpHgALbJABm6APYB3AM7SZJZQFcOM6cq2JIJCbpLdpAT1SICcc-EvdN1GgWDgFu7oPh+ZWt+ABMACnoASiooMwsrBgBucE9wQWD1eEhMSABeSDDwgCIsgW4OYqiUjLdsgCN8woiARgAmAGZq9Mzs4QKiyhpqoA)
Use comma or multiple tags to declare multiple type parameters:
    js
    /**
     * @template T,U,V
     * @template W,X
     */
You can also specify a type constraint before the type parameter name. Only
the first type parameter in a list is constrained:
    js
    /**
     * @template {string} K - K must be a string or string literal
     * @template {{ serious(): string }} Seriousalizable - must have a serious method
     * @param {K} key
     * @param {Seriousalizable} object
     */
    function seriousalize(key, object) {
      // ????
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIG8DO8ATgJYB2A5gL6QDSkAtHZMgK6GQBGikmkhpSpAD2RfsXIVI6EkiKZ0UGAhQZsPXLn6JSw9gAoAlAC5xgqVRoBlHST34FJAF6ZO6HkzYcAFpgBuPHz4tvYsiPDewgAmSnComPLIeLQ0ANaIAJ6xsPGJeDa67I4ubog0wpwAVogAxvBKwOAAZqxkdXZk2oUOMk6I+ukZADQiVbXwhnhQkMDAkAD8i-PgVEA)
Finally, you can specify a default for a type parameter:
    js
    /** @template [T=object] */
    class Cache {
        /** @param {T} initial */
        constructor(initial) {
        }
    }
    let c = new Cache()
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcFMFsAOAbAhncBtAKgXgPYBGAVrAMbQC64IwAUGWgM5PgDCqZAFrOAN51wQ8KAiREqAE6p4-bAF9wASwB2S6EtTIa9YeDL4VTaJICuFfJIAUq9ZuQBKfoOHy6b5LGj7wucCtgAd3ZOHisHIA)
### `@satisfies`
`@satisfies` provides access to the postfix [operator
`satisfies`](/docs/handbook/release-notes/typescript-4-9.html) in TypeScript.
Satisfies is used to declare that a value implements a type but does not
affect the type of the value.
    js
    // @ts-check
    /**
     * @typedef {"hello world" | "Hello, world"} WelcomeMessage
     */
    /** @satisfies {WelcomeMessage} */
    const message = "hello world"
    const message: "hello world"
    /** @satisfies {WelcomeMessage} */
    Type '"Hello world!"' does not satisfy the expected type 'WelcomeMessage'.1360Type '"Hello world!"' does not satisfy the expected type 'WelcomeMessage'.
    const failingMessage = "Hello world!"
    /** @type {WelcomeMessage} */
    const messageUsingType = "hello world"
    const messageUsingType: WelcomeMessage
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYBsAGAUCBAC6IC0AxgBaTkDWBAVA3qA8QJ4AOkAJpAGagA3gCJqAG3FxQAdwTieI0AB9QIgBKRJcADSz5igL6gA6lvJwAtpACykRIgCGAc0gsGwPIzbgnRAJaI-P72wmbiFtZ2Di6Qxh54FgB2iESg1jGuoAC8ahJS+tAKIgRgoOWgAHoA-F7ATBB+gcGhQuGRtvZOrvGeyamg-I7+4v5JztHdkDlqmtqFCgCEJd4c3GHmVp2Zcax9cClpGVMAqohjzgAqXNO5YloFckWKpRXlNUA)
## Classes
Classes can be declared as ES6 classes.
    js
    class C {
      /**
       * @param {number} data
       */
      constructor(data) {
        // property types can be inferred
        this.name = "foo";
        // or set explicitly
        /** @type {string | null} */
        this.title = null;
        // or simply annotated, if they're set elsewhere
        /** @type {number} */
        this.size;
        this.initialize(data); // Should error, initializer expects a string
      }
      /**
       * @param {string} s
       */
      initialize = function (s) {
        this.size = s.length;
      };
    }
    var c = new C(0);
    // C should only be called with new, but
    // because it is JavaScript, this is allowed and
    // considered an 'any'.
    var result = C(1);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8BQ1oHoBUGWo9AAgA5gBOYAtogHYCu5ARgKYkC+0AJmAC5g7QZocwAPZUIXEjWBdhJABSceASkR90aaIRLDCzLgE9oB3TGBgq0JtACWVAGbMSjdmq4ALaxAB0VCo2gAvNAARHbCwsEA3EhqaBqy0BCMXNCMAB6EINbA1lwg+rFYBMb+COIktgDm0AA+0LQgIGwCrh7eXLkg-kENINGx8SSJ1uSZhuZUwjxczgA0NnZGboz6AOROicmpIEkA7stOhXj4JdR0TKz8gqio7p5eENYAXoz9N0v3trnWYFkvCtwwEpIupoABlNzCGggdipEjaEjzL4dX7PZipDKMaQwMCJCRVHAsHCYbA3Y7EMiUMr4qiVNgQPgtVDIn5-brQOw0KjSayiaByCAqZDvO7eR4vQKJLxdWnuaKoFjRIlIABupGgwElVEYuzgcgADMCYnE4IlIdDYaJ8pZ-GZGs5oLtcm56jr5vQaFwkCamGYaEkbClPNAAFJgNVg4AVQhceaimw4xrCXYO8wuE0iMTWdjMVMWVbmNZeVXqpwQaEpIKwOQARmBQA)
They can also be declared as constructor functions; use `@constructor` along
with `@this` for this.
### Property Modifiers
`@public`, `@private`, and `@protected` work exactly like `public`, `private`,
and `protected` in TypeScript:
    js
    // @ts-check
    class Car {
      constructor() {
        /** @private */
        this.identifier = 100;
      }
      printIdentifier() {
        console.log(this.identifier);
      }
    }
    const c = new Car();
    console.log(c.identifier);
    Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0QADtACWANxZFIoDcFVCilfYgB0+gCaRRRfQDN9MUAF5QOAAMgQDcqgC+DEJ6+m4Aki5unt7QSipqwmKIcEyQ9kxwAObyNnaOie5eMIphQpGRjFlEwn6gopAA7lw8SmEi4jl5BcXk5a6VKTVAA)
  * `@public` is always implied and can be left off, but means that a property can be reached from anywhere.
  * `@private` means that a property can only be used within the containing class.
  * `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.
`@public`, `@private`, and `@protected` do not work in constructor functions.
### `@readonly`
The `@readonly` modifier ensures that a property is only ever written to
during initialization.
    js
    // @ts-check
    class Car {
      constructor() {
        /** @readonly */
        this.identifier = 100;
      }
      printIdentifier() {
        console.log(this.identifier);
      }
    }
    const c = new Car();
    console.log(c.identifier);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0RokFgBMxTAJ6gNwVUKKUAlogB0N-ZFFEbAMxsxQAXlABGHBwAblUAXwYhAAdoG1cASWdXDy9oJRU1YTFEOCZIeyY4AHN5aztHJLdPGEVQoQiIxmyiYV9QUUgAdy4eJVCRcVz8wpLyCpcq1NqgA)
### `@override`
`@override` works the same way as in TypeScript; use it on methods that
override a method from a base class:
    js
    export class C {
      m() { }
    }
    class D extends C {
      /** @override */
      m() { }
    }
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAYwDYEMDOa4GE4G8BQccAtgBQCUecAvvrcupgCJygzAB2AJpjgUQHoAVELgABCADdgUKAEsuwOEIGESFKrWpA)
Set `noImplicitOverride: true` in tsconfig to check overrides.
### `@extends`
When JavaScript classes extend a generic base class, there is no JavaScript
syntax for passing a type argument. The `@extends` tag allows this:
    js
    /**
     * @template T
     * @extends {Set<T>}
     */
    class SortableSet extends Set {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyIAeSAdgCYDOkA3gMqLwA8uAfAL4HDgDGWVGvQD2AJ3iYARukSN4kEuWqQ5dKJGDBIAOl3gOQA)
Note that `@extends` only works with classes. Currently, there is no way for a
constructor function to extend a class.
### `@implements`
In the same way, there is no JavaScript syntax for implementing a TypeScript
interface. The `@implements` tag works just like in TypeScript:
    js
    /** @implements {Print} */
    class TextBook {
      print() {
        // TODO
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEEsFsAcA2BTWyB2AXAzuA3gAoBO0WAvuCMAFADGiAhtrgCrIAemAQgPY8DW+auHDwSWABQBKISJHBg4FgHkAIsuHgy1MkA)
### `@constructor`
The compiler infers constructor functions based on this-property assignments,
but you can make checking stricter and suggestions better if you add a
`@constructor` tag:
    js
    /**
     * @constructor
     * @param {number} data
     */
    function C(data) {
      // property types can be inferred
      this.name = "foo";
      // or set explicitly
      /** @type {string | null} */
      this.title = null;
      // or simply annotated, if they're set elsewhere
      /** @type {number} */
      this.size;
      this.initialize(data);
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    }
    /**
     * @param {string} s
     */
    C.prototype.initialize = function (s) {
      this.size = s.length;
    };
    var c = new C(0);
    c.size;
    var result = C(1);
    Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGYAWAVjKoA4MAqJtUJiSPAOxQBdsAV0h8CbDuAAOAQ2zSAtqADe3QfIBGOAL6gAJtL7TxwNADNB3EQEseoAMIAKfYYCUytqEyT8knHwCeoAG+KKCQ0tygmqBW3KY42LC6HnzQVigAdNwKsKAAvKAARKZ4eIUA3GgemASgKLB8oLAAHpIANlaQVnxt-tUsEMG5SvzYsQDmoAA+oKptbTpMJqBBaZl83W25BXNtldVgtShW8u2BEdx4hnxJADQxpquw-gDkiXUNTW31AO5wif0JENlKoNNp2MtVukMscAF6wfYrVLQ2LdKzSDrwpwGaQuSpaZisdgQGRyRQjAQTHToCFoOwZbxXK7+XwZVEbDFWeH5UDmSwbWwOFBuJQpNYwrnbOoZLbccapfH7ABusjCPO4sB+9gcAAY8WhIBL4crVYkUII2o0Co4AIx4oA)
> Note: Error messages only show up in JS codebases with [a
> JSConfig](/docs/handbook/tsconfig-json.html) and
> [`checkJs`](/tsconfig#checkJs) enabled.
With `@constructor`, `this` is checked inside the constructor function `C`, so
you will get suggestions for the `initialize` method and an error if you pass
it a number. Your editor may also show warnings if you call `C` instead of
constructing it.
Unfortunately, this means that constructor functions that are also callable
cannot use `@constructor`.
### `@this`
The compiler can usually figure out the type of `this` when it has some
context to work with. When it doesn‚Äôt, you can explicitly specify the type of
`this` with `@this`:
    js
    /**
     * @this {HTMLElement}
     * @param {*} e
     */
    function callbackForLater(e) {
      this.clientHeight = parseInt(e); // should be fine!
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAFgSwM6QN4AkAqBZAGQFEAbAUwFsyA7eAXyhlgAcBDAJ1YsxDsjMbBwAMwCu1AMbxkAe2qQJrEiQBGrCQGsAYjPYFW8MuwAUZAJSYokJGgB0EkshrwsZZAHNE8SAF5IbdlQyAElaUzMAbkhgYEhURBlREgATSBUySGFkajIAQnA6IA)
## Documentation
### `@deprecated`
When a function, method, or property is deprecated you can let users know by
marking it with a `/** @deprecated */` JSDoc comment. That information is
surfaced in completion lists and as a suggestion diagnostic that editors can
handle specially. In an editor like VS Code, deprecated values are typically
displayed in a strike-through style ~~like this~~.
    js
    /** @deprecated */
    const apiV1 = {};
    const apiV2 = {};
    apiV;
      * apiV1
      * apiV2
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFDAFSYgEwKYAO8+AxgIYAu+uomwap0kKlo5hAlgGoCMoAXlABvAL4BuRs1bsu3AEyCREtGg49JIUAD0APqqA)
### `@see`
`@see` lets you link to other names in your program:
    ts
    type Box<T> = { t: T }
    /** @see Box for implementation details */
    type Boxify<T> = { [K in keyof T]: Box<T> };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIDOE08CUAZnAE5QCWAWzAAbCAIgA7YAENgfOBKgATCDL7DGUapXKhIsRHw4hUGbHgDaAaX6KA1hBBwOxALpE2psgG4gA)
Some editors will turn `Box` into a link to make it easy to jump there and
back.
### `@link`
`@link` is like `@see`, except that it can be used inside other tags:
    ts
    type Box<T> = { t: T }
    /** @returns A {@link Box} containing the parameter. */
    function box<U>(u: U): Box<U> {
      return { t: u };
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIBOEwArowHYDOUAgrvQA2ASw4BrWIlJQAxnA7AAhqNEBzfAAtoYRY0UBbFhEYA6KNUrkAZqw4zgw+VABGiJAFU0AClZF3ASiJ4ZE9ccigoZjZOXHwiVjIAbnJSIA)
## Other
### `@enum`
The `@enum` tag allows you to create an object literal whose members are all
of a specified type. Unlike most object literals in JavaScript, it does not
allow other members. `@enum` is intended for compatibility with Google
Closure‚Äôs `@enum` tag.
    js
    /** @enum {number} */
    const JSDocState = {
      BeginningOfLine: 0,
      SawAsterisk: 1,
      SavingComments: 2,
    };
    JSDocState.SawAsterisk;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeDECNoCcC+4RgAoAYwHtYBnAF3ACkBlAETJIeoENrpwBeVIuHAAhaAHMAlrFhSxAeQBmAGSnQAXOAAMAGkHgGHAO4BBGjgmUA1hoCMuoQYBusgMJlEiONUoaATLtwAbiIiRhY2Tm4AOgMTM2wLS0CgA)
Note that `@enum` is quite different from, and much simpler than, TypeScript‚Äôs
`enum`. However, unlike TypeScript‚Äôs enums, `@enum` can have any type:
    js
    /** @enum {function(number): number} */
    const MathFuncs = {
      add1: (n) => n + 1,
      id: (n) => -n,
      sub1: (n) => n - 1,
    };
    MathFuncs.add1;
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeAzesDGAXAlgPawAUCiARtAE4CUAXOGZVQL7gjABQWRAzjuACyAQxwALAGKYsvcAF5UncOGEATVQEYGpGvIB8jcAGpwGgDRLweVdti65BgLSwLy3vHJbwO-YcemLFgBuTk4RcSlsXgA6NU0goA)
### `@author`
You can specify the author of an item with `@author`:
    ts
    /**
     * Welcome to awesome.ts
     * @author Ian Awesome <i.am.awesome@example.com>
     */
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUh1BTANgYwPYFt6QC6sgQwHd4BnDeAOmxKhgAF8BXbAC1QCdIBJfAO0gCCxMpkgAeAJYV86acPJ14ADxkAHRJTToAfLWBA)
Remember to surround the email address with angle brackets. Otherwise,
`@example` will be parsed as a new tag.
### Other supported patterns
    js
    var someObj = {
      /**
       * @param {string} param1 - JSDocs on property assignments work
       */
      x: function (param1) {},
    };
    /**
     * As do jsdocs on variable assignments
     * @return {Window}
     */
    let someFunc = function () {};
    /**
     * And class methods
     * @param {string} greeting The greeting to use
     */
    Foo.prototype.sayHi = (greeting) => console.log("Hi!");
    /**
     * And arrow function expressions
     * @param {number} x - A multiplier
     */
    let myArrow = (x) => x * x;
    /**
     * Which means it works for function components in JSX too
     * @param {{a: string, b: number}} props - Some param
     */
    var fc = (props) => <div>{props.a.charAt(0)}</div>;
    /**
     * A parameter can be a class constructor, using Google Closure syntax.
     *
     * @param {{new(...args: any[]): object}} C - The class to register
     */
    function registerClass(C) {}
    /**
     * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
     */
    function fn10(p1) {}
    /**
     * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
     */
    function fn9(p1) {
      return p1.join();
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBiD29oG8C+AoA9J6BafwArgC767oBuYATtBPALYCmA8gEYBW0AvCutNEwAqIfwFDoAAQAONMAxQRi1AJYA7AOapos6vICMeaACkAygBF4wGPDU7q8aU2rEAntEgQVGtczXEYAHd4agBrMWghTDEADwAuaAAzQjVgYhVbaAAKXQMAShRUABp0VABudCwRfgkAQRgAEyQOCCbraEyqVTA2ECYPKG9fJn8IGqlqJmJCajtkAHV1JsCMSOi+4jpGJlgU4B4kvfTMrIK0CqrRSOhatQboUE9oZmIAC3gGseuZOQVkJVUmm0GkmU3UGmgABVXv0QUwwZpoMQkIQIEwatEEPAAHTSBzItxObEQMCuAASKgOWThCI0BW4AD4HrZ6H1sSB4BosgAiCkAQm5eQuwiudTuHmoDkCh1SxzsTBieKYgxZ4x+ej+akIDDYzm0MSMtWehBA6WkIBUzgx6A2z1ctUl8GlvCyMXpTINEhiwuq13mrxUwFezyYYDUMBUm2CYRgiRCMrSGTswEY0lsIwC0HUJlMAA0kYg1bk-sgwAkAeCitA2AktTq9do8Y4YLhoKZtjpftaukl9i6m9IIO7oAAeBoqCgM5ADiDYsDYoM0WrELIABjyqBHmHHk59opunY1U2cDzD1f6YAe4CgzPDykIaRCVdR4OgAHFEBo+tAAMIciAzP0ECuP4YAxNiNRFr8KDIGoTCBFk2JITQGgQAkYauAA2gAunkCTwJwTBpKg2g-kY0L9I8N7ItAkwaCoShWms6DJLKSa0Uw9GMdQf6eFkP5nBglxQRqKBIcSyjgo2hitkaADkkxKHJEoQlkNB6K4BTwIkdCSZos7ZMoobEEw9yQNAckYXJeTWqxiaZIkaj6KuOT6IJlQiiJ8hiUhFZAjoMkHgpyrEMpKHZOppJaTpfmodihmTGAJlmTAllqK41m2Uc7GOQAnK5ZxiJM0yzAF2IcPA6inBUqBAA)
### Unsupported patterns
Postfix equals on a property type in an object literal type doesn‚Äôt specify an
optional property:
    js
    /**
     * @type {{ a: string, b: number= }}
     */
    var wrong;
    /**
     * Use postfix question on the property name instead:
     * @type {{ a: string, b?: number }}
     */
    var right;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4cgQwFyQDO8ATgJYB2A5gDSQBGBFArgLb2okC8kAvr1BDBwANxwlIAdxIB7agG5woCNEgBVQumQziAMzIAPSAEdmqYmTmQr8ABZbZaEkkgUcrdJWKocAEzyCcEhomNj4RKSUtAwA-ExsHBL8gsJiEuRUtvDyQA)
Nullable types only have meaning if
[`strictNullChecks`](/tsconfig#strictNullChecks) is on:
    js
    /**
     * @type {?number}
     * With strictNullChecks: true  -- number | null
     * With strictNullChecks: false -- number
     */
    var nullable;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4H4B2BXAWwCNUAnAXyhgHUBLeAC0gGd5TaBjeAOTwBs+AYQaoOAa2YAuSGzzpIAWgWR8xMpAA+K-nyqQ6jFm048dw0ROkAzAIZ9m6JdrWkqwcADcbpbQJtE+VABuIA)
The TypeScript-native syntax is a union type:
    js
    /**
     * @type {number | null}
     * With strictNullChecks: true  -- number | null
     * With strictNullChecks: false -- number
     */
    var unionNullable;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSXAGyoF8oYB1AS3gAtIBneY5gY3gA5HDQDCbVHwDWnAFyQeOdJAC0KyviKkK1Kg0gt2XHvyEiq4yTPkAzAIZVO6NRsIkGwcADc7pHFmYAeyxhGjsCKlQAbiA)
Non-nullable types have no meaning and are treated just as their original
type:
    js
    /**
     * @type {!number}
     * Just has type number
     */
    var normal;
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4EIB2BXAWwCNUAnAXyhgCk8BneSACwEM7Ik1J9iyrhwANxaluAe1IEWAGwDcQA)
Unlike JSDoc‚Äôs type system, TypeScript only allows you to mark types as
containing null or not. There is no explicit non-nullability ‚Äî if
strictNullChecks is on, then `number` is not nullable. If it is off, then
`number` is nullable.
### Unsupported tags
TypeScript ignores any unsupported JSDoc tags.
The following tags have open issues to support them:
  * `@memberof` ([issue #7237](https://github.com/Microsoft/TypeScript/issues/7237))
  * `@yields` ([issue #23857](https://github.com/Microsoft/TypeScript/issues/23857))
  * `@member` ([issue #56674](https://github.com/microsoft/TypeScript/issues/56674))
### Legacy type synonyms
A number of common types are given aliases for compatibility with old
JavaScript code. Some of the aliases are the same as existing types, although
most of those are rarely used. For example, `String` is treated as an alias
for `string`. Even though `String` is a type in TypeScript, old JSDoc often
uses it to mean `string`. Besides, in TypeScript, the capitalized versions of
primitive types are wrapper types ‚Äî almost always a mistake to use. So the
compiler treats these types as synonyms based on usage in old JSDoc:
  * `String -> string`
  * `Number -> number`
  * `Boolean -> boolean`
  * `Void -> void`
  * `Undefined -> undefined`
  * `Null -> null`
  * `function -> Function`
  * `array -> Array<any>`
  * `promise -> Promise<any>`
  * `Object -> any`
  * `object -> any`
The last four aliases are turned off when `noImplicitAny: true`:
  * `object` and `Object` are built-in types, although `Object` is rarely used.
  * `array` and `promise` are not built-in, but might be declared somewhere in your program.
### [Type Checking JavaScript FilesHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/type-checking-javascript-files.html)
### [Creating .d.ts Files from .js filesHow to add d.ts generation to
JavaScript projects](/docs/handbook/declaration-files/dts-from-js.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/JSDoc Reference.md)
‚ù§
Contributors to this page:  
OT
NS
RG
L
K
8+
Last updated: Sep 16, 2024  
Was this page helpful?
# JSX
[JSX](https://facebook.github.io/jsx/) is an embeddable XML-like syntax. It is
meant to be transformed into valid JavaScript, though the semantics of that
transformation are implementation-specific. JSX rose to popularity with the
[React](https://reactjs.org/) framework, but has since seen other
implementations as well. TypeScript supports embedding, type checking, and
compiling JSX directly to JavaScript.
## Basic usage
In order to use JSX you must do two things.
  1. Name your files with a `.tsx` extension
  2. Enable the [`jsx`](/tsconfig#jsx) option
TypeScript ships with several JSX modes: `preserve`, `react` (classic
runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic
development runtime), and `react-native`. The `preserve` mode will keep the
JSX as part of the output to be further consumed by another transform step
(e.g. [Babel](https://babeljs.io/)). Additionally the output will have a
`.jsx` file extension. The `react` mode will emit `React.createElement`, does
not need to go through a JSX transformation before use, and the output will
have a `.js` file extension. The `react-native` mode is the equivalent of
`preserve` in that it keeps all JSX, but the output will instead have a `.js`
file extension.
Mode | Input | Output | Output File Extension  
---|---|---|---  
`preserve` | `<div />` | `<div />` | `.jsx`  
`react` | `<div />` | `React.createElement("div")` | `.js`  
`react-native` | `<div />` | `<div />` | `.js`  
`react-jsx` | `<div />` | `_jsx("div", {}, void 0);` | `.js`  
`react-jsxdev` | `<div />` | `_jsxDEV("div", {}, void 0, false, {...}, this);` | `.js`  
You can specify this mode using either the [`jsx`](/tsconfig#jsx) command line
flag or the corresponding option [`jsx` in your tsconfig.json](/tsconfig#jsx)
file.
> *Note: You can specify the JSX factory function to use when targeting react
> JSX emit with [`jsxFactory`](/tsconfig#jsxFactory) option (defaults to
> `React.createElement`)
## The `as` operator
Recall how to write a type assertion:
    ts
    const foo = <foo>bar;
This asserts the variable `bar` to have the type `foo`. Since TypeScript also
uses angle brackets for type assertions, combining it with JSX‚Äôs syntax would
introduce certain parsing difficulties. As a result, TypeScript disallows
angle bracket type assertions in `.tsx` files.
Since the above syntax cannot be used in `.tsx` files, an alternate type
assertion operator should be used: `as`. The example can easily be rewritten
with the `as` operator.
    ts
    const foo = bar as foo;
The `as` operator is available in both `.ts` and `.tsx` files, and is
identical in behavior to the angle-bracket type assertion style.
## Type Checking
In order to understand type checking with JSX, you must first understand the
difference between intrinsic elements and value-based elements. Given a JSX
expression `<expr />`, `expr` may either refer to something intrinsic to the
environment (e.g. a `div` or `span` in a DOM environment) or to a custom
component that you‚Äôve created. This is important for two reasons:
  1. For React, intrinsic elements are emitted as strings (`React.createElement("div")`), whereas a component you‚Äôve created is not (`React.createElement(MyComponent)`).
  2. The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known _intrinsically_ whereas components will likely want to specify their own set of attributes.
TypeScript uses the [same convention that React
does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-
vs.-react-components) for distinguishing between these. An intrinsic element
always begins with a lowercase letter, and a value-based element always begins
with an uppercase letter.
### The `JSX` namespace
JSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be
defined in various places, depending on the `jsx` compiler option.
The `jsx` options `preserve`, `react`, and `react-native` use the type
definitions for classic runtime. This means a variable needs to be in scope
that‚Äôs determined by the `jsxFactory` compiler option. The `JSX` namespace
should be specified on the top-most identifier of the JSX factory. For
example, React uses the default factory `React.createElement`. This means its
`JSX` namespace should be defined as `React.JSX`.
    ts
    export function createElement(): any;
    export namespace JSX {
      // ‚Ä¶
    }
And the user should always import React as `React`.
    ts
    import * as React from 'react';
Preact uses the JSX factory `h`. That means its types should be defined as the
`h.JSX`.
    ts
    export function h(props: any): any;
    export namespace h.JSX {
      // ‚Ä¶
    }
The user should use a named import to import `h`.
    ts
    import { h } from 'preact';
For the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace
should be exported from the matching entry points. For `react-jsx` this is
`${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is
`${jsxImportSource}/jsx-dev-runtime`. Since these don‚Äôt use a file extension,
you must use the [`exports`](https://nodejs.org/api/packages.html#exports)
field in `package.json` map in order to support ESM users.
    json
    {
      "exports": {
        "./jsx-runtime": "./jsx-runtime.js",
        "./jsx-dev-runtime": "./jsx-dev-runtime.js",
      }
    }
Then in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:
    ts
    export namespace JSX {
      // ‚Ä¶
    }
Note that while exporting the `JSX` namespace is sufficient for type checking,
the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at
runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally
you add types for those too.
If the `JSX` namespace isn‚Äôt available in the appropriate location, both the
classic and the automatic runtime fall back to the global `JSX` namespace.
### Intrinsic elements
Intrinsic elements are looked up on the special interface
`JSX.IntrinsicElements`. By default, if this interface is not specified, then
anything goes and intrinsic elements will not be type checked. However, if
this interface _is_ present, then the name of the intrinsic element is looked
up as a property on the `JSX.IntrinsicElements` interface. For example:
    tsx
    declare namespace JSX {
      interface IntrinsicElements {
        foo: any;
      }
    }
    <foo />; // ok
    <bar />; // error
In the above example, `<foo />` will work fine but `<bar />` will result in an
error since it has not been specified on `JSX.IntrinsicElements`.
> Note: You can also specify a catch-all string indexer on
> `JSX.IntrinsicElements` as follows:
    ts
    declare namespace JSX {
      interface IntrinsicElements {
        [elemName: string]: any;
      }
    }
### Value-based elements
Value-based elements are simply looked up by identifiers that are in scope.
    tsx
    import MyComponent from "./myComponent";
    <MyComponent />; // ok
    <SomeOtherComponent />; // error
There are two ways to define a value-based element:
  1. Function Component (FC)
  2. Class Component
Because these two types of value-based elements are indistinguishable from
each other in a JSX expression, first TS tries to resolve the expression as a
Function Component using overload resolution. If the process succeeds, then TS
finishes resolving the expression to its declaration. If the value fails to
resolve as a Function Component, TS will then try to resolve it as a class
component. If that fails, TS will report an error.
#### Function Component
As the name suggests, the component is defined as a JavaScript function where
its first argument is a `props` object. TS enforces that its return type must
be assignable to `JSX.Element`.
    tsx
    interface FooProp {
      name: string;
      X: number;
      Y: number;
    }
    declare function AnotherComponent(prop: { name: string });
    function ComponentFoo(prop: FooProp) {
      return <AnotherComponent name={prop.name} />;
    }
    const Button = (prop: { value: string }, context: { color: string }) => (
      <button />
    );
Because a Function Component is simply a JavaScript function, function
overloads may be used here as well:
    ts
    interface ClickableProps {
      children: JSX.Element[] | JSX.Element;
    }
    interface HomeProps extends ClickableProps {
      home: JSX.Element;
    }
    interface SideProps extends ClickableProps {
      side: JSX.Element | string;
    }
    function MainButton(prop: HomeProps): JSX.Element;
    function MainButton(prop: SideProps): JSX.Element;
    function MainButton(prop: ClickableProps): JSX.Element {
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagC20GArniQFIDKAGqAN5qigCWkALlvADMCOErBqksvVgF92XXvyEjQASV7xuKTjjFYJvFKzkcA2igBcoFDw2QA5gF1LBSAE8A3HNmyQoALQBOJQ8AX5o3HyCwiQAwnjaANYEAEY0AApIAA6GbBw4ABaceBjEkJYMjAB0uvo8Jg6gAD6gFdXikjyesuEKUcoAEtASGdDZoFgAHnyQGIZxiSnpWTly+UNY5Uxteh1daD2RSiT0nNgjY5PTs6DzOEmpWOcrHFrYm1U1HU1WNtx2e2gBJRIDgeJxoJBQABZAjcABCwR4EIAFJkspZBsNlgBKd7bWqeIEgsEQ6GwyAInhIyCo9GgE5nHF4z68QnA0HgyEw+GIlFo0aWW73JajFC4lpbFk8IwcXyVeVoaRAA)
> Note: Function Components were formerly known as Stateless Function
> Components (SFC). As Function Components can no longer be considered
> stateless in recent versions of react, the type `SFC` and its alias
> `StatelessComponent` were deprecated.
#### Class Component
It is possible to define the type of a class component. However, to do so it
is best to understand two new terms: the _element class type_ and the _element
instance type_.
Given `<Expr />`, the _element class type_ is the type of `Expr`. So in the
example above, if `MyComponent` was an ES6 class the class type would be that
class‚Äôs constructor and statics. If `MyComponent` was a factory function, the
class type would be that function.
Once the class type is established, the instance type is determined by the
union of the return types of the class type‚Äôs construct or call signatures
(whichever is present). So again, in the case of an ES6 class, the instance
type would be the type of an instance of that class, and in the case of a
factory function, it would be the type of the value returned from the
function.
    ts
    class MyComponent {
      render() {}
    }
    // use a construct signature
    const myComponent = new MyComponent();
    // element class type => MyComponent
    // element instance type => { render: () => void }
    function MyFactoryFunction() {
      return {
        render: () => {},
      };
    }
    // use a call signature
    const myComponent = MyFactoryFunction();
    // element class type => MyFactoryFunction
    // element instance type => { render: () => void }
The element instance type is interesting because it must be assignable to
`JSX.ElementClass` or it will result in an error. By default
`JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to
only those types that conform to the proper interface.
    tsx
    declare namespace JSX {
      interface ElementClass {
        render: any;
      }
    }
    class MyComponent {
      render() {}
    }
    function MyFactoryFunction() {
      return { render: () => {} };
    }
    <MyComponent />; // ok
    <MyFactoryFunction />; // ok
    class NotAValidComponent {}
    function NotAValidFactoryFunction() {
      return {};
    }
    <NotAValidComponent />; // error
    <NotAValidFactoryFunction />; // error
### Attribute type checking
The first step to type checking attributes is to determine the _element
attributes type_. This is slightly different between intrinsic and value-based
elements.
For intrinsic elements, it is the type of the property on
`JSX.IntrinsicElements`
    tsx
    declare namespace JSX {
      interface IntrinsicElements {
        foo: { bar?: boolean };
      }
    }
    // element attributes type for 'foo' is '{bar?: boolean}'
    <foo bar />;
For value-based elements, it is a bit more complex. It is determined by the
type of a property on the _element instance type_ that was previously
determined. Which property to use is determined by
`JSX.ElementAttributesProperty`. It should be declared with a single property.
The name of that property is then used. As of TypeScript 2.8, if
`JSX.ElementAttributesProperty` is not provided, the type of first parameter
of the class element‚Äôs constructor or Function Component‚Äôs call will be used
instead.
    tsx
    declare namespace JSX {
      interface ElementAttributesProperty {
        props; // specify the property name to use
      }
    }
    class MyComponent {
      // specify the property on the element instance type
      props: {
        foo?: string;
      };
    }
    // element attributes type for 'MyComponent' is '{foo?: string}'
    <MyComponent foo="bar" />;
The element attribute type is used to type check the attributes in the JSX.
Optional and required properties are supported.
    tsx
    declare namespace JSX {
      interface IntrinsicElements {
        foo: { requiredProp: string; optionalProp?: number };
      }
    }
    <foo requiredProp="bar" />; // ok
    <foo requiredProp="bar" optionalProp={0} />; // ok
    <foo />; // error, requiredProp is missing
    <foo requiredProp={0} />; // error, requiredProp should be a string
    <foo requiredProp="bar" unknownProp />; // error, unknownProp does not exist
    <foo requiredProp="bar" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier
> Note: If an attribute name is not a valid JS identifier (like a `data-*`
> attribute), it is not considered to be an error if it is not found in the
> element attributes type.
Additionally, the `JSX.IntrinsicAttributes` interface can be used to specify
extra properties used by the JSX framework which are not generally used by the
components‚Äô props or arguments - for instance `key` in React. Specializing
further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used
to specify the same kind of extra attributes just for class components (and
not Function Components). In this type, the generic parameter corresponds to
the class instance type. In React, this is used to allow the `ref` attribute
of type `Ref<T>`. Generally speaking, all of the properties on these
interfaces should be optional, unless you intend that users of your JSX
framework need to provide some attribute on every tag.
The spread operator also works:
    tsx
    const props = { requiredProp: "bar" };
    <foo {...props} />; // ok
    const badProps = {};
    <foo {...badProps} />; // error
### Children Type Checking
In TypeScript 2.3, TS introduced type checking of _children_. _children_ is a
special property in an _element attributes type_ where child _JSXExpression_ s
are taken to be inserted into the attributes. Similar to how TS uses
`JSX.ElementAttributesProperty` to determine the name of _props_ , TS uses
`JSX.ElementChildrenAttribute` to determine the name of _children_ within
those props. `JSX.ElementChildrenAttribute` should be declared with a single
property.
    ts
    declare namespace JSX {
      interface ElementChildrenAttribute {
        children: {}; // specify children name to use
      }
    }
    tsx
    <div>
      <h1>Hello</h1>
    </div>;
    <div>
      <h1>Hello</h1>
      World
    </div>;
    const CustomComp = (props) => <div>{props.children}</div>
    <CustomComp>
      <div>Hello World</div>
      {"This is just a JS expression..." + 1000}
    </CustomComp>
You can specify the type of _children_ like any other attribute. This will
override the default type from, e.g. the [React
typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)
if you use them.
    tsx
    interface PropsType {
      children: JSX.Element
      name: string
    }
    class Component extends React.Component<PropsType, {}> {
      render() {
        return (
          <h2>
            {this.props.children}
          </h2>
        )
      }
    }
    // OK
    <Component name="foo">
      <h1>Hello World</h1>
    </Component>
    // Error: children is of type JSX.Element not array of JSX.Element
    <Component name="bar">
      <h1>Hello World</h1>
      <h2>Hello World</h2>
    </Component>
    // Error: children is of type JSX.Element not array of JSX.Element or string.
    <Component name="baz">
      <h1>Hello</h1>
      World
    </Component>
## The JSX result type
By default the result of a JSX expression is typed as `any`. You can customize
the type by specifying the `JSX.Element` interface. However, it is not
possible to retrieve type information about the element, attributes or
children of the JSX from this interface. It is a black box.
## The JSX function return type
By default, function components must return `JSX.Element | null`. However, this doesn‚Äôt always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn‚Äôt define what props are valid. The type of props is always defined by the first argument of the component that‚Äôs passed. The default looks something like this:
    ts
    namespace JSX {
        export type ElementType =
            // All the valid lowercase tags
            keyof IntrinsicAttributes
            // Function components
            (props: any) => Element
            // Class components
            new (props: any) => ElementClass;
        export interface IntrinsicAttributes extends /*...*/ {}
        export type Element = /*...*/;
        export type ElementClass = /*...*/;
    }
## Embedding Expressions
JSX allows you to embed expressions between tags by surrounding the
expressions with curly braces (`{ }`).
    tsx
    const a = (
      <div>
        {["foo", "bar"].map((i) => (
          <span>{i / 2}</span>
        ))}
      </div>
    );
The above code will result in an error since you cannot divide a string by a
number. The output, when using the `preserve` option, looks like:
    tsx
    const a = (
      <div>
        {["foo", "bar"].map(function (i) {
          return <span>{i / 2}</span>;
        })}
      </div>
    );
## React integration
To use JSX with React you should use the [React
typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react).
These typings define the `JSX` namespace appropriately for use with React.
    tsx
    /// <reference path="react.d.ts" />
    interface Props {
      foo: string;
    }
    class MyComponent extends React.Component<Props, {}> {
      render() {
        return <span>{this.props.foo}</span>;
      }
    }
    <MyComponent foo="bar" />; // ok
    <MyComponent foo={0} />; // error
### Configuring JSX
There are multiple compiler flags which can be used to customize your JSX,
which work as both a compiler flag and via inline per-file pragmas. To learn
more see their tsconfig reference pages:
  * [`jsxFactory`](/tsconfig#jsxFactory)
  * [`jsxFragmentFactory`](/tsconfig#jsxFragmentFactory)
  * [`jsxImportSource`](/tsconfig#jsxImportSource)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/JSX.md) ‚ù§
Contributors to this page:  
MH
OT
RC
DZ
KT
33+
Last updated: Sep 16, 2024  
Was this page helpful?
# Migrating from JavaScript
TypeScript doesn‚Äôt exist in a vacuum. It was built with the JavaScript
ecosystem in mind, and a lot of JavaScript exists today. Converting a
JavaScript codebase over to TypeScript is, while somewhat tedious, usually not
challenging. In this tutorial, we‚Äôre going to look at how you might start out.
We assume you‚Äôve read enough of the handbook to write new TypeScript code.
If you‚Äôre looking to convert a React project, we recommend looking at the
[React Conversion Guide](https://github.com/Microsoft/TypeScript-React-
Conversion-Guide#typescript-react-conversion-guide) first.
## Setting up your Directories
If you‚Äôre writing in plain JavaScript, it‚Äôs likely that you‚Äôre running your
JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist`
directory, and then run as desired.
If that‚Äôs the case, the files that you‚Äôve written are going to be used as
inputs to TypeScript, and you‚Äôll run the outputs it produces. During our JS to
TS migration, we‚Äôll need to separate our input files to prevent TypeScript
from overwriting them. If your output files need to reside in a specific
directory, then that will be your output directory.
You might also be running some intermediate steps on your JavaScript, such as
bundling or using another transpiler like Babel. In this case, you might
already have a folder structure like this set up.
From this point on, we‚Äôre going to assume that your directory is set up
something like this:
    projectRoot
    ‚îú‚îÄ‚îÄ src
    ‚îÇ   ‚îú‚îÄ‚îÄ file1.js
    ‚îÇ   ‚îî‚îÄ‚îÄ file2.js
    ‚îú‚îÄ‚îÄ built
    ‚îî‚îÄ‚îÄ tsconfig.json
If you have a `tests` folder outside of your `src` directory, you might have
one `tsconfig.json` in `src`, and one in `tests` as well.
## Writing a Configuration File
TypeScript uses a file called `tsconfig.json` for managing your project‚Äôs
options, such as which files you want to include, and what sorts of checking
you want to perform. Let‚Äôs create a bare-bones one for our project:
    json
    {
      "compilerOptions": {
        "outDir": "./built",
        "allowJs": true,
        "target": "es5"
      },
      "include": ["./src/**/*"]
    }
Here we‚Äôre specifying a few things to TypeScript:
  1. Read in any files it understands in the `src` directory (with [`include`](/tsconfig#include)).
  2. Accept JavaScript files as inputs (with [`allowJs`](/tsconfig#allowJs)).
  3. Emit all of the output files in `built` (with [`outDir`](/tsconfig#outDir)).
  4. Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](/tsconfig#target)).
At this point, if you try running `tsc` at the root of your project, you
should see output files in the `built` directory. The layout of files in
`built` should look identical to the layout of `src`. You should now have
TypeScript working with your project.
## Early Benefits
Even at this point you can get some great benefits from TypeScript
understanding your project. If you open up an editor like [VS
Code](https://code.visualstudio.com) or [Visual
Studio](https://visualstudio.com), you‚Äôll see that you can often get some
tooling support like completion. You can also catch certain bugs with options
like:
  * [`noImplicitReturns`](/tsconfig#noImplicitReturns) which prevents you from forgetting to return at the end of a function.
  * [`noFallthroughCasesInSwitch`](/tsconfig#noFallthroughCasesInSwitch) which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.
TypeScript will also warn about unreachable code and labels, which you can
disable with [`allowUnreachableCode`](/tsconfig#allowUnreachableCode) and
[`allowUnusedLabels`](/tsconfig#allowUnusedLabels) respectively.
## Integrating with Build Tools
You might have some more build steps in your pipeline. Perhaps you concatenate
something to each of your files. Each build tool is different, but we‚Äôll do
our best to cover the gist of things.
### Gulp
If you‚Äôre using Gulp in some fashion, we have a tutorial on [using
Gulp](/docs/handbook/gulp.html) with TypeScript, and integrating with common
build tools like Browserify, Babelify, and Uglify. You can read more there.
### Webpack
Webpack integration is pretty simple. You can use `ts-loader`, a TypeScript
loader, combined with `source-map-loader` for easier debugging. Simply run
    shell
    npm install ts-loader source-map-loader
and merge in options from the following into your `webpack.config.js` file:
    js
    module.exports = {
      entry: "./src/index.ts",
      output: {
        filename: "./dist/bundle.js",
      },
      // Enable sourcemaps for debugging webpack's output.
      devtool: "source-map",
      resolve: {
        // Add '.ts' and '.tsx' as resolvable extensions.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"],
      },
      module: {
        rules: [
          // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.
          { test: /\.tsx?$/, loader: "ts-loader" },
          // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
          { test: /\.js$/, loader: "source-map-loader" },
        ],
      },
      // Other options...
    };
It‚Äôs important to note that ts-loader will need to run before any other loader
that deals with `.js` files.
You can see an example of using Webpack in our [tutorial on React and
Webpack](/docs/handbook/react-&-webpack.html).
## Moving to TypeScript Files
At this point, you‚Äôre probably ready to start using TypeScript files. The
first step is to rename one of your `.js` files to `.ts`. If your file uses
JSX, you‚Äôll need to rename it to `.tsx`.
Finished with that step? Great! You‚Äôve successfully migrated a file from
JavaScript to TypeScript!
Of course, that might not feel right. If you open that file in an editor with
TypeScript support (or if you run `tsc --pretty`), you might see red squiggles
on certain lines. You should think of these the same way you‚Äôd think of red
squiggles in an editor like Microsoft Word. TypeScript will still translate
your code, just like Word will still let you print your documents.
If that sounds too lax for you, you can tighten that behavior up. If, for
instance, you _don‚Äôt_ want TypeScript to compile to JavaScript in the face of
errors, you can use the [`noEmitOnError`](/tsconfig#noEmitOnError) option. In
that sense, TypeScript has a dial on its strictness, and you can turn that
knob up as high as you want.
If you plan on using the stricter settings that are available, it‚Äôs best to
turn them on now (see Getting Stricter Checks below). For instance, if you
never want TypeScript to silently infer `any` for a type without you
explicitly saying so, you can use [`noImplicitAny`](/tsconfig#noImplicitAny)
before you start modifying your files. While it might feel somewhat
overwhelming, the long-term gains become apparent much more quickly.
### Weeding out Errors
Like we mentioned, it‚Äôs not unexpected to get error messages after conversion.
The important thing is to actually go one by one through these and decide how
to deal with the errors. Often these will be legitimate bugs, but sometimes
you‚Äôll have to explain what you‚Äôre trying to do a little better to TypeScript.
#### Importing from Modules
You might start out getting a bunch of errors like `Cannot find name
'require'.`, and `Cannot find name 'define'.`. In these cases, it‚Äôs likely
that you‚Äôre using modules. While you can just convince TypeScript that these
exist by writing out
    ts
    // For Node/CommonJS
    declare function require(path: string): any;
or
    ts
    // For RequireJS/AMD
    declare function define(...args: any[]): any;
it‚Äôs better to get rid of those calls and use TypeScript syntax for imports.
First, you‚Äôll need to enable some module system by setting TypeScript‚Äôs
[`module`](/tsconfig#module) option. Valid options are `commonjs`, `amd`,
`system`, and `umd`.
If you had the following Node/CommonJS code:
    js
    var foo = require("foo");
    foo.doStuff();
or the following RequireJS/AMD code:
    js
    define(["foo"], function (foo) {
      foo.doStuff();
    });
then you would write the following TypeScript code:
    ts
    import foo = require("foo");
    foo.doStuff();
#### Getting Declaration Files
If you started converting over to TypeScript imports, you‚Äôll probably run into
errors like `Cannot find module 'foo'.`. The issue here is that you likely
don‚Äôt have _declaration files_ to describe your library. Luckily this is
pretty easy. If TypeScript complains about a package like `lodash`, you can
just write
    shell
    npm install -S @types/lodash
If you‚Äôre using a module option other than `commonjs`, you‚Äôll need to set your
[`moduleResolution`](/tsconfig#moduleResolution) option to `node`.
After that, you‚Äôll be able to import lodash with no issues, and get accurate
completions.
#### Exporting from Modules
Typically, exporting from a module involves adding properties to a value like
`exports` or `module.exports`. TypeScript allows you to use top-level export
statements. For instance, if you exported a function like so:
    js
    module.exports.feedPets = function (pets) {
      // ...
    };
you could write that out as the following:
    ts
    export function feedPets(pets) {
      // ...
    }
Sometimes you‚Äôll entirely overwrite the exports object. This is a common
pattern people use to make their modules immediately callable like in this
snippet:
    js
    var express = require("express");
    var app = express();
You might have previously written that like so:
    js
    function foo() {
      // ...
    }
    module.exports = foo;
In TypeScript, you can model this with the `export =` construct.
    ts
    function foo() {
      // ...
    }
    export = foo;
#### Too many/too few arguments
You‚Äôll sometimes find yourself calling a function with too many/few arguments.
Typically, this is a bug, but in some cases, you might have declared a
function that uses the `arguments` object instead of writing out any
parameters:
    js
    function myCoolFunction() {
      if (arguments.length == 2 && !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
      }
      // ...
    }
    myCoolFunction(
      function (x) {
        console.log(x);
      },
      [1, 2, 3, 4]
    );
    myCoolFunction(
      function (x) {
        console.log(x);
      },
      1,
      2,
      3,
      4
    );
In this case, we need to use TypeScript to tell any of our callers about the
ways `myCoolFunction` can be called using function overloads.
    ts
    function myCoolFunction(f: (x: number) => void, nums: number[]): void;
    function myCoolFunction(f: (x: number) => void, ...nums: number[]): void;
    function myCoolFunction() {
      if (arguments.length == 2 && !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
      }
      // ...
    }
We added two overload signatures to `myCoolFunction`. The first checks states
that `myCoolFunction` takes a function (which takes a `number`), and then a
list of `number`s. The second one says that it will take a function as well,
and then uses a rest parameter (`...nums`) to state that any number of
arguments after that need to be `number`s.
#### Sequentially Added Properties
Some people find it more aesthetically pleasing to create an object and add
properties immediately after like so:
    js
    var options = {};
    options.color = "red";
    options.volume = 11;
TypeScript will say that you can‚Äôt assign to `color` and `volume` because it
first figured out the type of `options` as `{}` which doesn‚Äôt have any
properties. If you instead moved the declarations into the object literal
themselves, you‚Äôd get no errors:
    ts
    let options = {
      color: "red",
      volume: 11,
    };
You could also define the type of `options` and add a type assertion on the
object literal.
    ts
    interface Options {
      color: string;
      volume: number;
    }
    let options = {} as Options;
    options.color = "red";
    options.volume = 11;
Alternatively, you can just say `options` has the type `any` which is the
easiest thing to do, but which will benefit you the least.
#### `any`, `Object`, and `{}`
You might be tempted to use `Object` or `{}` to say that a value can have any
property on it because `Object` is, for most purposes, the most general type.
However **`any` is actually the type you want to use** in those situations,
since it‚Äôs the most _flexible_ type.
For instance, if you have something that‚Äôs typed as `Object` you won‚Äôt be able
to call methods like `toLowerCase()` on it. Being more general usually means
you can do less with a type, but `any` is special in that it is the most
general type while still allowing you to do anything with it. That means you
can call it, construct it, access properties on it, etc. Keep in mind though,
whenever you use `any`, you lose out on most of the error checking and editor
support that TypeScript gives you.
If a decision ever comes down to `Object` and `{}`, you should prefer `{}`.
While they are mostly the same, technically `{}` is a more general type than
`Object` in certain esoteric cases.
### Getting Stricter Checks
TypeScript comes with certain checks to give you more safety and analysis of
your program. Once you‚Äôve converted your codebase to TypeScript, you can start
enabling these checks for greater safety.
#### No Implicit `any`
There are certain cases where TypeScript can‚Äôt figure out what certain types
should be. To be as lenient as possible, it will decide to use the type `any`
in its place. While this is great for migration, using `any` means that you‚Äôre
not getting any type safety, and you won‚Äôt get the same tooling support you‚Äôd
get elsewhere. You can tell TypeScript to flag these locations down and give
an error with the [`noImplicitAny`](/tsconfig#noImplicitAny) option.
#### Strict `null` & `undefined` Checks
By default, TypeScript assumes that `null` and `undefined` are in the domain
of every type. That means anything declared with the type `number` could be
`null` or `undefined`. Since `null` and `undefined` are such a frequent source
of bugs in JavaScript and TypeScript, TypeScript has the
[`strictNullChecks`](/tsconfig#strictNullChecks) option to spare you the
stress of worrying about these issues.
When [`strictNullChecks`](/tsconfig#strictNullChecks) is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is _possibly_ `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you‚Äôd write the type out as `number | null`.
If you ever have a value that TypeScript thinks is possibly
`null`/`undefined`, but you know better, you can use the postfix `!` operator
to tell it otherwise.
    ts
    declare var foo: string[] | null;
    foo.length; // error - 'foo' is possibly 'null'
    foo!.length; // okay - 'foo!' just has type 'string[]'
As a heads up, when using [`strictNullChecks`](/tsconfig#strictNullChecks),
your dependencies may need to be updated to use
[`strictNullChecks`](/tsconfig#strictNullChecks) as well.
#### No Implicit `any` for `this`
When you use the `this` keyword outside of classes, it has the type `any` by
default. For instance, imagine a `Point` class, and imagine a function that we
wish to add as a method:
    ts
    class Point {
      constructor(public x, public y) {}
      getDistance(p: Point) {
        let dx = p.x - this.x;
        let dy = p.y - this.y;
        return Math.sqrt(dx ** 2 + dy ** 2);
      }
    }
    // ...
    // Reopen the interface.
    interface Point {
      distanceFromOrigin(): number;
    }
    Point.prototype.distanceFromOrigin = function () {
      return this.getDistance({ x: 0, y: 0 });
    };
This has the same problems we mentioned above - we could easily have
misspelled `getDistance` and not gotten an error. For this reason, TypeScript
has the [`noImplicitThis`](/tsconfig#noImplicitThis) option. When that option
is set, TypeScript will issue an error when `this` is used without an explicit
(or inferred) type. The fix is to use a `this`-parameter to give an explicit
type in the interface or in the function itself:
    ts
    Point.prototype.distanceFromOrigin = function (this: Point) {
      return this.getDistance({ x: 0, y: 0 });
    };
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/Migrating from
JavaScript.md) ‚ù§
Contributors to this page:  
DR
OT
TA
MG
MF
19+
Last updated: Sep 16, 2024  
Was this page helpful?
# Mixins
Along with traditional OO hierarchies, another popular way of building up
classes from reusable components is to build them by combining simpler partial
classes. You may be familiar with the idea of mixins or traits for languages
like Scala, and the pattern has also reached some popularity in the JavaScript
community.
## How Does A Mixin Work?
The pattern relies on using generics with class inheritance to extend a base
class. TypeScript‚Äôs best mixin support is done via the class expression
pattern. You can read more about how this pattern works in JavaScript
[here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-
classes/).
To get started, we‚Äôll need a class which will have the mixins applied on top
of:
    ts
    class Sprite {
      name = "";
      x = 0;
      y = 0;
      constructor(name: string) {
        this.name = name;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHNaA)
Then you need a type and a factory function which returns a class expression
extending the base class.
    ts
    // To get started, we need a type which we'll use to extend
    // other classes from. The main responsibility is to declare
    // that the type being passed in is a class.
    type Constructor = new (...args: any[]) => {};
    // This mixin adds a scale property, with getters and setters
    // for changing it with an encapsulated private property:
    function Scale<TBase extends Constructor>(Base: TBase) {
      return class Scaling extends Base {
        // Mixins may not declare private/protected properties
        // however, you can use ES2020 private fields
        _scale = 1;
        setScale(scale: number) {
          this._scale = scale;
        }
        get scale(): number {
          return this._scale;
        }
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUHtQcwUwC6gM4IIYCcFwCYBpQB3OUAOzl1DVAQE8AHEwgCwEsBjZouAcgBs+oAK7ISCaHAAe2UjgBQIUJATM4GUOz5pko5KABmGSAFsAdBFWhjaVqVAY4yepFLJWAI1Z9WdUKz3ioDhwmphwCmAqaEgqYgwk7nC2MKD02qI4fnb+VBpaOqZycnSMoADCLqgYQuzi6gC8ZHCEoAAUph2YMMgAXFSktADaALoAlKD1AHygAN4AvgDcRYrgbHrGrJK2VDg4etTI7Gh8JPRGjFi0BIQ+XPAI2Bj7siiIj8gRBpDqnGikMMk-Egbip+qA4KQjvRkEItNhMmdWAA3aKnc5qOg9Ir6ISQhCsFygADKRxOAB5wAAhbQkKQyPblSoIaq1b6TVrU0R9Kk08YzOSgeyIIQYOyhHTE0mAukQhmckj8wWCxQAWU2tnWaFoZGUQRCWgcqQwyNRwDOyhC8KNkAu+McAqVimYkGISLUBFokCEGj+wlEoAAokSAEwABjDRpN2AMrDgfD2DsFAH1DscSI0AIxLROvBAktOtVMnPqkITGRIYPk5wUqfymFOk9MoRtLJWgOZFNv3ZsF0YlssV2bVoUIEV2WvIetFuCtpUdwWLORzIA)
With these all set up, then you can create a class which represents the base
class with mixins applied:
    ts
    // Compose a new class from the Sprite class,
    // with the Mixin Scale applier:
    const EightBitSprite = Scale(Sprite);
    const flappySprite = new EightBitSprite("Bird");
    flappySprite.setScale(0.8);
    console.log(flappySprite.scale);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHLdQd4mAMJCVEqYm4F0Ad2gyRkFgiGoQSmAEHADaALpaZAB82NZ0AGZiBJLIQnDAYCDoADwAKgBCkJjoDBgEACYwrsKiHtKJMhUQ6ErllVq4+IjoqGKIBNCgkDCw+SDI6tDVtQ3QnZgD+NAA9FvQALLIDPMwxGBcBAKo0HXok0PQSMgAbmAYW0iXtxh1D4gCTohUMh0BAdNtdnoBL50E90IgADTQDgCMQTSLQMRdaAAUVgACYWATfs9Xpg0sCQA0wQB9CCzMwARjoYK6qBmBXQMjpHKUBDExAARnD+mDdAZjLT6dxuYUrPhbGC1MNlPSZBpefyhV4NptoEMRmNoPpDEZJRy5TZ6Kk7DgdtAALSO4BiVCO+223auYjwARYsCEPwTcBQaBpP7EI16TAIFAYINTeEe6C+NB6SOYA5HcbswrQMDweBzOEKHCCZo45BqPSoMpoGNoMw5zn1jAaZllkSh8AFjgtsw+fzYyvV2tsx4YGSUWuIOqUNs4NLd+C98foIyspsyFhGAAc847AkKRhAAjUMkX+eXffX9LbQA)
## Constrained Mixins
In the above form, the mixin‚Äôs have no underlying knowledge of the class which
can make it hard to create the design you want.
To model this, we modify the original constructor type to accept a generic
argument.
    ts
    // This was our previous constructor:
    type Constructor = new (...args: any[]) => {};
    // Now we use a generic version which can apply a constraint on
    // the class which this mixin is applied to
    type GConstructor<T = {}> = new (...args: any[]) => T;
    [Try](https://www.typescriptlang.org/play/#code/PTAEBUAsEsGdQO4EN4HsCuAnUAHTBTAN2g3gGNUA7WAF03TJtUwC4AoGgTx31AGEqteo2agAvKEr4EoABQA6RUkwBzWC1BJKnANoBdAJTiAfKADeAXwDcbEKAByqGQl7pYvJKBX4pmaGVBCfExYEkpEGDJIUDItTRwcABtOTRjBOiRoShpQKlswGkheMkSUeARI6MK4UABbaAAPLNAapATE6HwAE1AmDm5eAHEBajoGJkwAHnBxcwtTCSkZBSVVdU1tfSMxU3ArIA)
This allows for creating classes which only work with constrained base
classes:
    ts
    type Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;
    type Spritable = GConstructor<Sprite>;
    type Loggable = GConstructor<{ print: () => void }>;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUcgHo8qABaEuxMYBKixVBIKAAFBBQDPWQuACMVK1hEVAwcPEIKKBQIYAbBNgchJExzNoh0ABp3adn59BlSOgA3BD0AEyhaJRroHX1gds76eD8+wMJzgwgaE-BoABkEXl4rrtvegEBgQhrpIsAhKxNjs9odjkA)
Then you can create mixins which only work when you have a particular base to
build on:
    ts
    function Jumpable<TBase extends Positionable>(Base: TBase) {
      return class Jumpable extends Base {
        jump() {
          // This mixin will only work if it is passed a base
          // class which has setPos defined because of the
          // Positionable constraint.
          this.setPos(0, 20);
        }
      };
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUc0EgoAAUEFAM9ZC4AIxUrWERUDBw8QgooFAhgYsE2ByEkTHNKiHQAGnc+gaH0GVI6ADcEPQATKFolfOgdfWAqmvp4P0bAwi2DCBp18GgAGQReXl3ag4aA5oJW3UjgIVYZ+cWVmtFAB6YFQAC0kOwmGAkPBikUADNMEhcOUkFAAFIDMCPYgAIXU0AgDkMSCWmi6ZQq1XOrEJ7SERAZEBi3nQHUw6AxqnUmmx5lxtKgJLJFKgLMo3lMACscb8pXE4qCoEQkppzHoHJEoEw9CoVFBkCoPEx8ABrKB6RFW4BWzS4jQQFZcKCVInS5Vg3kaXVJbAJKAJdRtDpdKBLCCIyLOt0QbBcTDtI02xIQT2mFVU4Dox4+Q7oLhfdgZqCJZLsdqdEqsZxjABMzikblMOVbSioQA)
## Alternative Pattern
Previous versions of this document recommended a way to write mixins where you
created both the runtime and type hierarchies separately, then merged them at
the end:
    ts
    // Each mixin is a traditional ES class
    class Jumpable {
      jump() {}
    }
    class Duckable {
      duck() {}
    }
    // Including the base
    class Sprite {
      x = 0;
      y = 0;
    }
    // Then you create an interface which merges
    // the expected mixins with the same name as your base
    interface Sprite extends Jumpable, Duckable {}
    // Apply the mixins into the base class via
    // the JS at runtime
    applyMixins(Sprite, [Jumpable, Duckable]);
    let player = new Sprite();
    player.jump();
    console.log(player.x, player.y);
    // This can live anywhere in your codebase:
    function applyMixins(derivedCtor: any, constructors: any[]) {
      constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
          Object.defineProperty(
            derivedCtor.prototype,
            name,
            Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||
              Object.create(null)
          );
        });
      });
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigCimiAFqALbwAe8AdqPJKJqHJgCbzTwB7RjlIBlUImyZIkApOlsAUgFdqAB0wAjbHlABvAqFAArVWoAUASn0BfAnblSZoACLLEAay079h0N3cPK1t7AiIwAElGSWVeRgBzTgpdTWlCeWdRNQRoXQMjOlAAXlAABgBuPwBPYrLKh2IAFWTmKoFlCVg8TFz2ZiZc2CxEXQB3CiQqajxYeLxZYmhk0Dw6NTxkPG4aeiY2Ub4qJd1ITGnQYXPpUDblWFBU-AIBmeHdLJzdVdzGbiUzbx4AA0rkCgJCxAAgmo1NgascdgxGGwBgIkik0hInGwAG7wTDhdGgRTiHqgWDKRj8aYETAwuEAWV2yPMHz4wNAAG0VOpASC3J5AQBdSyVAg6aCgWGYKozWqMPCjUBs3JWSrS2WwAB0pnUarkQkgAh0WuwAni5g1My1dBBVu1VVFYSaEzYiEwzGw8Bxug9VXGM10TBu7XuiAE3DwjzwKAI6EpyEEzDpsKqTKRkHMkYQPu4AGFoAJYGg-SDw8i4O5C7BICXGFVOSLfEZyzAKcgi5Ategi2RKOZzNGC0XrEUAHzNoygADymmMG2gWrm0Gno0YAAVYAJ1rBoFUAHJneaDtLD7XZASFvfrSzd3vkCgDy54UcT-JToyz+fILWR9BMPBN23GY93MPwPyMbNvS2M8tQvK8qnWIFwIg59kIgqcvwXJc8BXNcgJ3PcXHmRAEDUasT3wWD4MvRCOWfawAB9GJQjCsJ-UjulVRhlGwbBLFY0AnQ-GxhNAUT6iAA)
This pattern relies less on the compiler, and more on your codebase to ensure
both runtime and type-system are correctly kept in sync.
## Constraints
The mixin pattern is supported natively inside the TypeScript compiler by code
flow analysis. There are a few cases where you can hit the edges of the native
support.
#### Decorators and Mixins
[`#4881`](https://github.com/microsoft/TypeScript/issues/4881)
You cannot use decorators to provide mixins via code flow analysis:
    ts
    // A decorator function which replicates the mixin pattern:
    const Pausable = (target: typeof Player) => {
      return class Pausable extends target {
        shouldFreeze = false;
      };
    };
    @Pausable
    class Player {
      x = 0;
      y = 0;
    }
    // The Player class does not have the decorator's type merged:
    const player = new Player();
    player.shouldFreeze;
    Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.
    // The runtime aspect could be manually replicated via
    // type composition or interface merging.
    type FreezablePlayer = Player & { shouldFreeze: boolean };
    const playerTwo = (new Player() as unknown) as FreezablePlayer;
    playerTwo.shouldFreeze;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEiC1AXKAEwDMHAnHWAIKgAJsTIUyoAGYBXdEUxIS6UAHcAFkiJrQCSLFyaKkKqExrIoFEmhJlsCpkTpmNUuiqZQABWzSq2ACNcCwBeUAAKHAQAc0hMVkwAT3gSSW9cbETEAEpQEIA+UABvGlAdOOkEZSIMqhMfP0Dg0BhHdCETKNjPErKyqjUSaVwhADFdSAAvUKk8KkgAblLQAF8ltZoacAb-IMhXWvqMrIRi5eg80AAGJbLEy5uaFc36ABVzdMzEUBrsOuESMZQOgSJ41NgAG4WMwWESkciUBAAck6yQsaBikCELjcHlA+i+pzC6EgKk+J3C2SWBJOADoBkMRuNIFNFi8wO8LAhZAo0KA-vB5D9GUJQAF0dh0NI8Lh7rp9IZHKKIUhsHxTGjhShYCQqEgFEpQBJbI4EJJsER0YhorZorSaEl4KBmVMmpAvMdvmEPYTQAAyYqgBnDMYTaasAIkEjBSWrJauJR4mmIV4qEiXcIksk+im5P6gWQAaxBKnQeZMLsmbpziGpnoQqZI9MGIcriyAA)
#### Static Property Mixins
[`#17829`](https://github.com/microsoft/TypeScript/issues/17829)
More of a gotcha than a constraint. The class expression pattern creates
singletons, so they can‚Äôt be mapped at the type system to support different
variable types.
You can work around this by using functions to return your classes which
differ based on a generic:
    ts
    function base<T>() {
      class Base {
        static prop: T;
      }
      return Base;
    }
    function derived<T>() {
      class Derived extends base<T>() {
        static anotherProp: T;
      }
      return Derived;
    }
    class Spec extends derived<string>() {}
    Spec.prop; // string
    Spec.anotherProp; // string
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIwIYGcCmAeAKgPgAoBKRAbwChFEIAbDdRAIQ03KusXSlVgkQAOAJzgCAXIlwBuDgF8OQzFBBCkLLDPkVQkWAkQATTEJgA3TAbxFSlanQaIAIsbMXEmAB5RMYA4zRYViTsnFw8fIioYHBQABbGAAoi4pIy1PLUisqqTi7mBpoUFPbojADKApj8nt6+jEYm+djcJmAA5tbkWhVVAHTColKIAPTDYa1tFD0QvVEx8UJJgyNjLTDtQA)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Mixins.md) ‚ù§
Contributors to this page:  
OT
GM
IO
DE
O
5+
Last updated: Sep 16, 2024  

Was this page helpful?
# Modules - ESM/CJS Interoperability
It‚Äôs 2015, and you‚Äôre writing an ESM-to-CJS transpiler. There‚Äôs no
specification for how to do this; all you have is a specification of how ES
modules are supposed to interact with each other, knowledge of how CommonJS
modules interact with each other, and a knack for figuring things out.
Consider an exporting ES module:
    ts
    export const A = {};
    export const B = {};
    export default "Hello, world!";
How would you turn this into a CommonJS module? Recalling that default exports
are just named exports with special syntax, there seems to be only one choice:
    ts
    exports.A = {};
    exports.B = {};
    exports.default = "Hello, world!";
This is a nice analog, and it lets you implement a similar on the importing
side:
    ts
    import hello, { A, B } from "./module";
    console.log(hello, A, B);
    // transpiles to:
    const module_1 = require("./module");
    console.log(module_1.default, module_1.A, module_1.B);
So far, everything in CJS-world matches up one-to-one with everything in ESM-
world. Extending the equivalence above one step further, we can see that we
also have:
    ts
    import * as mod from "./module";
    console.log(mod.default, mod.A, mod.B);
    // transpiles to:
    const mod = require("./module");
    console.log(mod.default, mod.A, mod.B);
You might notice that in this scheme, there‚Äôs no way to write an ESM export
that produces an output where `exports` is assigned a function, class, or
primitive:
    ts
    // @Filename: exports-function.js
    module.exports = function hello() {
      console.log("Hello, world!");
    };
But existing CommonJS modules frequently take this form. How might an ESM
import, processed with our transpiler, access this module? We just established
that a namespace import (`import *`) transpiles to a plain `require` call, so
we can support an input like:
    ts
    import * as hello from "./exports-function";
    hello();
    // transpiles to:
    const hello = require("./exports-function");
    hello();
Our output works at runtime, but we have a compliance problem: according to
the JavaScript specification, a namespace import always resolves to a [_Module
Namespace Object_](https://tc39.es/ecma262/#sec-module-namespace-objects),
that is, an object whose members are the exports of the module. In this case,
`require` would return the function `hello`, but `import *` can never return a
function. The correspondence we assumed appears invalid.
It‚Äôs worth taking a step back here and clarifying what the _goal_ is. As soon
as modules landed in the ES2015 specification, transpilers emerged with
support for downleveling ESM to CJS, allowing users to adopt the new syntax
long before runtimes implemented support for it. There was even a sense that
writing ESM code was a good way to ‚Äúfuture-proof‚Äù new projects. For this to be
true, there needed to be a seamless migration path from executing the
transpilers‚Äô CJS output to executing the ESM input natively once runtimes
developed support for it. The goal was to find a way to downlevel ESM to CJS
that would allow any or all of those transpiled outputs to be replaced by
their true ESM inputs in a future runtime, with no observable change in
behavior.
By following the specification, it was easy enough for transpilers to find a
set of transformations that made the semantics of their transpiled CommonJS
outputs match the specified semantics of their ESM inputs (arrows represent
imports):
However, CommonJS modules (written as CommonJS, not as ESM transpiled to
CommonJS) were already well-established in the Node.js ecosystem, so it was
inevitable that modules written as ESM and transpiled to CJS would start
‚Äúimporting‚Äù modules written as CommonJS. The behavior for this
interoperability, though, was not specified by ES2015, and didn‚Äôt yet exist in
any real runtime.
Even if transpiler authors did nothing, a behavior would emerge from the
existing semantics between the `require` calls they emitted in transpiled code
and the `exports` defined in existing CJS modules. And to allow users to
transition seamlessly from transpiled ESM to true ESM once their runtime
supported it, that behavior would have to match the one the runtime chose to
implement.
Guessing what interop behavior runtimes would support wasn‚Äôt limited to ESM
importing ‚Äútrue CJS‚Äù modules either. Whether ESM would be able to recognize
ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to
`require` ES modules, were also unspecified. Even whether ESM imports would
use the same module resolution algorithm as CJS `require` calls was
unknowable. All these variables would have to be predicted correctly in order
to give transpiler users a seamless migration path toward native ESM.
## `allowSyntheticDefaultImports` and `esModuleInterop`
Let‚Äôs return to our specification compliance problem, where `import *`
transpiles to `require`:
    ts
    // Invalid according to the spec:
    import * as hello from "./exports-function";
    hello();
    // but the transpilation works:
    const hello = require("./exports-function");
    hello();
When TypeScript first added support for writing and transpiling ES modules,
the compiler addressed this problem by issuing an error on any namespace
import of a module whose `exports` was not a namespace-like object:
    ts
    import * as hello from "./exports-function";
    // TS2497              ^^^^^^^^^^^^^^^^^^^^
    // External module '"./exports-function"' resolves to a non-module entity
    // and cannot be imported using this construct.
The only workaround was for users to go back to using the older TypeScript
import syntax representing a CommonJS `require`:
    ts
    import hello = require("./exports-function");
Forcing users to revert to non-ESM syntax was essentially an admission that
‚Äúwe don‚Äôt know how or if a CJS module like `"./exports-function"` will be
accessible with ESM imports in the future, but we know it _can‚Äôt_ be with
`import *`, even though it will work at runtime in the transpilation scheme
we‚Äôre using.‚Äù It doesn‚Äôt meet the goal of allowing this file to be migrated to
real ESM without changes, but neither does the alternative of allowing the
`import *` to link to a function. This is still the behavior in TypeScript
today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.
> Unfortunately, this is a slight oversimplification‚ÄîTypeScript didn‚Äôt fully
> avoid the compliance issue with this error, because it allowed namespace
> imports of functions to work, and retain their call signatures, as long as
> the function declaration merged with a namespace declaration‚Äîeven if the
> namespace was empty. So while a module exporting a bare function was
> recognized as a ‚Äúnon-module entity‚Äù:
>  
>  
>     ts
>  
>     declare function $(selector: string): any;
>  
>     export = $; // Cannot `import *` this üëç
>
> A should-be-meaningless change allowed the invalid import to type check
> without errors:
>  
>  
>     ts
>  
>     declare namespace $ {}
>  
>     declare function $(selector: string): any;
>  
>     export = $; // Allowed to `import *` this and call it üò±
Meanwhile, other transpilers were coming up with a way to solve the same
problem. The thought process went something like this:
  1. To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don‚Äôt make sense here.
  2. Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules _always_ link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.
  3. So, a default import of a true CJS module should work just like a `require` call. But we‚Äôll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default "hello"` to `exports.default = "hello"` and have a default import of _that_ module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).
  4. When we transpile an ES module to CJS, let‚Äôs add a special extra field to the output: 
        ts
    exports.A = {};
    exports.B = {};
    exports.default = "Hello, world!";
    // Extra special flag!
    exports.__esModule = true;
that we can check for when we transpile a default import:
        ts
    // import hello from "./module";
    const _mod = require("./module");
    const hello = _mod.__esModule ? _mod.default : _mod;
The `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and
Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in
1.8 to allow the type checker to link default imports directly to the
`exports`, rather than the `exports.default`, of any module types that lacked
an `export default` declaration. The flag didn‚Äôt modify how imports or exports
were emitted, but it allowed default imports to reflect how other transpilers
would treat them. Namely, it allowed a default import to be used to resolve to
‚Äúnon-module entities,‚Äù where `import *` was an error:
    ts
    // Error:
    import * as hello from "./exports-function";
    // Old workaround:
    import hello = require("./exports-function");
    // New way, with `allowSyntheticDefaultImports`:
    import hello from "./exports-function";
This was usually enough to let Babel and Webpack users write code that already
worked in those systems without TypeScript complaining, but it was only a
partial solution, leaving a few issues unsolved:
  1. Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a _fallback_ behavior when no default export was found in the target module‚Äôs types. This created an inconsistency if the target module had an `__esModule` flag but _no_ default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can‚Äôt be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.
  2. `allowSyntheticDefaultImports` didn‚Äôt change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type: 
        ts
    // @Filename: exportEqualsObject.d.ts
    declare const obj: object;
    export = obj;
    // @Filename: main.ts
    import objDefault from "./exportEqualsObject";
    import * as objNamespace from "./exportEqualsObject";
    // This should be true at runtime, but TypeScript gives an error:
    objNamespace.default === objDefault;
    //           ^^^^^^^ Property 'default' does not exist on type 'typeof import("./exportEqualsObject")'.
  3. Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.
TypeScript introduced the `esModuleInterop` flag in 2.7, which refined the
type checking of imports to address the remaining inconsistencies between
TypeScript‚Äôs analysis and the interop behavior used in existing transpilers
and bundlers, and critically, adopted the same `__esModule`-conditional
CommonJS emit that transpilers had adopted years before. (Another new emit
helper for `import *` ensured the result was always an object, with call
signatures stripped, fully resolving the specification compliance issue that
the aforementioned ‚Äúresolves to a non-module entity‚Äù error didn‚Äôt quite
sidestep.) Finally, with the new flag enabled, TypeScript‚Äôs type checking,
TypeScript‚Äôs emit, and the rest of the transpiling and bundling ecosystem were
in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps,
plausibly adoptable by Node.
## Interop in Node.js
Node.js shipped support for ES modules unflagged in v12. Like the bundlers and
transpilers began doing years before, Node.js gave CommonJS modules a
‚Äúsynthetic default export‚Äù of their `exports` object, allowing the entire
module contents to be accessed with a default import from ESM:
    ts
    // @Filename: export.cjs
    module.exports = { hello: "world" };
    // @Filename: import.mjs
    import greeting from "./export.cjs";
    greeting.hello; // "world"
That‚Äôs one win for seamless migration! Unfortunately, the similarities mostly
end there.
### No `__esModule` detection (the ‚Äúdouble default‚Äù problem)
Node.js wasn‚Äôt able to respect the `__esModule` marker to vary its default
import behavior. So a transpiled module with a ‚Äúdefault export‚Äù behaves one
way when ‚Äúimported‚Äù by another transpiled module, and another way when
imported by a true ES module in Node.js:
    ts
    // @Filename: node_modules/dependency/index.js
    exports.__esModule = true;
    exports.default = function doSomething() { /*...*/ }
    // @Filename: transpile-vs-run-directly.{js/mjs}
    import doSomething from "dependency";
    // Works after transpilation, but not a function in Node.js ESM:
    doSomething();
    // Doesn't exist after trasnpilation, but works in Node.js ESM:
    doSomething.default();
While the transpiled default import only makes the synthetic default export if
the target module lacks an `__esModule` flag, Node.js _always_ synthesizes a
default export, creating a ‚Äúdouble default‚Äù on the transpiled module.
### Unreliable named exports
In addition to making a CommonJS module‚Äôs `exports` object available as a
default import, Node.js attempts to find properties of `exports` to make
available as named imports. This behavior matches bundlers and transpilers
when it works; however, Node.js uses [syntactic
analysis](https://github.com/nodejs/cjs-module-lexer) to synthesize named
exports before any code executes, whereas transpiled modules resolve their
named imports at runtime. The result is that imports from CJS modules that
work in transpiled modules may not work in Node.js:
    ts
    // @Filename: named-exports.cjs
    exports.hello = "world";
    exports["worl" + "d"] = "hello";
    // @Filename: transpile-vs-run-directly.{js/mjs}
    import { hello, world } from "./named-exports.cjs";
    // `hello` works, but `world` is missing in Node.js üí•
    import mod from "./named-exports.cjs";
    mod.world;
    // Accessing properties from the default always works ‚úÖ
### Cannot `require` a true ES module
True CommonJS modules can `require` an ESM-transpiled-to-CJS module, since
they‚Äôre both CommonJS at runtime. But in Node.js, `require` crashes if it
resolves to an ES module. This means published libraries cannot migrate from
transpiled modules to true ESM without breaking their CommonJS (true or
transpiled) consumers:
    ts
    // @Filename: node_modules/dependency/index.js
    export function doSomething() { /* ... */ }
    // @Filename: dependent.js
    import { doSomething } from "dependency";
    // ‚úÖ Works if dependent and dependency are both transpiled
    // ‚úÖ Works if dependent and dependency are both true ESM
    // ‚úÖ Works if dependent is true ESM and dependency is transpiled
    // üí• Crashes if dependent is transpiled and dependency is true ESM
### Different module resolution algorithms
Node.js introduced a new module resolution algorithm for resolving ESM imports
that differed significantly from the long-standing algorithm for resolving
`require` calls. While not directly related to interop between CJS and ES
modules, this difference was one more reason why a seamless migration from
transpiled modules to true ESM might not be possible:
    ts
    // @Filename: add.js
    export function add(a, b) {
      return a + b;
    }
    // @Filename: math.js
    export * from "./add";
    //            ^^^^^^^
    // Works when transpiled to CJS,
    // but would have to be "./add.js"
    // in Node.js ESM.
## Conclusions
Clearly, a seamless migration from transpiled modules to ESM isn‚Äôt possible,
at least in Node.js. Where does this leave us?
### Setting the right `module` compiler option is critical
Since interoperability rules differ between hosts, TypeScript can‚Äôt offer
correct checking behavior unless it understands what kind of module is
represented by each file it sees, and what set of rules to apply to them. This
is the purpose of the `module` compiler option. (In particular, code that is
intended to run in Node.js is subject to stricter rules than code that will be
processed by a bundler. The compiler‚Äôs output is not checked for Node.js
compatibility unless `module` is set to `node16` or `nodenext`.)
### Applications with CommonJS code should always enable `esModuleInterop`
In a TypeScript _application_ (as opposed to a library that others may
consume) where `tsc` is used to emit JavaScript files, whether
`esModuleInterop` is enabled doesn‚Äôt have major consequences. The way you
write imports for certain kinds of modules will change, but TypeScript‚Äôs
checking and emit are in sync, so error-free code should be safe to run in
either mode. The downside of leaving `esModuleInterop` disabled in this case
is that it allows you to write JavaScript code with semantics that clearly
violate the ECMAScript specification, confusing intuitions about namespace
imports and making it harder to migrate to running ES modules in the future.
In an application that gets processed by a third-party transpiler or bundler,
on the other hand, enabling `esModuleInterop` is more important. All major
bundlers and transpilers use an `esModuleInterop`-like emit strategy, so
TypeScript needs to adjust its checking to match. (The compiler always reasons
about what will happen in the JavaScript files that `tsc` would emit, so even
if another tool is being used in place of `tsc`, emit-affecting compiler
options should still be set to match the output of that tool as closely as
possible.)
`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It
changes the compiler‚Äôs checking behavior without changing the code emitted by
`tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the
checking changes it introduces are an incomplete version of the ones
introduced by `esModuleInterop`. Even if `tsc` isn‚Äôt being used for emit, it‚Äôs
better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.
Some people object to the inclusion of the `__importDefault` and
`__importStar` helper functions included in `tsc`‚Äôs JavaScript output when
`esModuleInterop` is enabled, either because it marginally increases the
output size on disk or because the interop algorithm employed by the helpers
seems to misrepresent Node.js‚Äôs interop behavior by checking for `__esModule`,
leading to the hazards discussed earlier. Both of these objections can be
addressed, at least partially, without accepting the flawed checking behavior
exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler
option can be used to import the helper functions from `tslib` rather than
inlining them into each file that needs them. To discuss the second objection,
let‚Äôs look at a final example:
    ts
    // @Filename: node_modules/transpiled-dependency/index.js
    exports.__esModule = true;
    exports.default = function doSomething() { /* ... */ };
    exports.something = "something";
    // @Filename: node_modules/true-cjs-dependency/index.js
    module.exports = function doSomethingElse() { /* ... */ };
    // @Filename: src/sayHello.ts
    export default function sayHello() { /* ... */ }
    export const hello = "hello";
    // @Filename: src/main.ts
    import doSomething from "transpiled-dependency";
    import doSomethingElse from "true-cjs-dependency";
    import sayHello from "./sayHello.js";
Assume we‚Äôre compiling `src` to CommonJS for use in Node.js. Without
`allowSyntheticDefaultImports` or `esModuleInterop`, the import of
`doSomethingElse` from `"true-cjs-dependency"` is an error, and the others are
not. To fix the error without changing any compiler options, you could change
the import to `import doSomethingElse = require("true-cjs-dependency")`.
However, depending on how the types for the module (not shown) are written,
you may also be able to write and call a namespace import, which would be a
language-level specification violation. With `esModuleInterop`, none of the
imports shown are errors (and all are callable), but the invalid namespace
import would be caught.
What would change if we decided to migrate `src` to true ESM in Node.js (say,
add `"type": "module"` to our root package.json)? The first import,
`doSomething` from `"transpiled-dependency"`, would no longer be callable‚Äîit
exhibits the ‚Äúdouble default‚Äù problem, where we‚Äôd have to call
`doSomething.default()` rather than `doSomething()`. (TypeScript understands
and catches this under `--module node16` and `nodenext`.) But notably, the
_second_ import of `doSomethingElse`, which needed `esModuleInterop` to work
when compiling to CommonJS, works fine in true ESM.
If there‚Äôs something to complain about here, it‚Äôs not what `esModuleInterop`
does with the second import. The changes it makes, both allowing the default
import and preventing callable namespace imports, are exactly in line with
Node.js‚Äôs real ESM/CJS interop strategy, and made migration to real ESM
easier. The problem, if there is one, is that `esModuleInterop` seems to fail
at giving us a seamless migration path for the _first_ import. But this
problem was not introduced by enabling `esModuleInterop`; the first import was
completely unaffected by it. Unfortunately, this problem cannot be solved
without breaking the semantic contract between `main.ts` and `sayHello.ts`,
because the CommonJS output of `sayHello.ts` looks structurally identical to
`transpiled-dependency/index.js`. If `esModuleInterop` changed the way the
transpiled import of `doSomething` works to be identical to the way it would
work in Node.js ESM, it would change the behavior of the `sayHello` import in
the same way, making the input code violate ESM semantics (thus still
preventing the `src` directory from being migrated to ESM without changes).
As we‚Äôve seen, there is no seamless migration path from transpiled modules to
true ESM. But `esModuleInterop` is one step in the right direction. For those
who still prefer to minimize module syntax transformations and the inclusion
of the import helper functions, enabling `verbatimModuleSyntax` is a better
choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that
the `import mod = require("mod")` and `export = ns` syntax be used in
CommonJS-emitting files, avoiding all the kinds of import ambiguity we‚Äôve
discussed, at the cost of ease of migration to true ESM.
### Library code needs special considerations
Libraries that ship as CommonJS should avoid using default exports, since the
way those transpiled exports can be accessed varies between different tools
and runtimes, and some of those ways will look confusing to users. A default
export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the
default property of a default import:
    js
    import pkg from "pkg";
    pkg.default();
in most bundlers or transpiled ESM as the default import itself:
    js
    import pkg from "pkg";
    pkg();
and in vanilla CommonJS as the default property of a `require` call:
    js
    const pkg = require("pkg");
    pkg.default();
Users will detect a misconfigured module smell if they have to access the
`.default` property of a default import, and if they‚Äôre trying to write code
that will run both in Node.js and a bundler, they might be stuck. Some third-
party TypeScript transpilers expose options that change the way default
exports are emitted to mitigate this difference, but they don‚Äôt produce their
own declaration (`.d.ts`) files, so that creates a mismatch between the
runtime behavior and the type checking, further confusing and frustrating
users. Instead of using default exports, libraries that need to ship as
CommonJS should use `export =` for modules that have a single main export, or
named exports for modules that have multiple exports:
    diff
    - export default function doSomething() { /* ... */ }
    + export = function doSomething() { /* ... */ }
Libraries (that ship declaration files) should also take extra care to ensure
the types they write are error-free under a wide range of compiler options.
For example, it‚Äôs possible to write one interface that extends another in such
a way that it only compiles successfully when `strictNullChecks` is disabled.
If a library were to publish types like that, it would force all their users
to disable `strictNullChecks` too. `esModuleInterop` can allow type
declarations to contain similarly ‚Äúinfectious‚Äù default imports:
    ts
    // @Filename: /node_modules/dependency/index.d.ts
    import express from "express";
    declare function doSomething(req: express.Request): any;
    export = doSomething;
Suppose this default import _only_ works with `esModuleInterop` enabled, and
causes an error when a user without that option references this file. The user
should _probably_ enable `esModuleInterop` anyway, but it‚Äôs generally seen as
bad form for libraries to make their configurations infectious like this. It
would be much better for the library to ship a declaration file like:
    ts
    import express = require("express");
    // ...
Examples like this have led to conventional wisdom that says libraries should
_not_ enable `esModuleInterop`. This advice is a reasonable start, but we‚Äôve
looked at examples where the type of a namespace import changes, potentially
_introducing_ an error, when enabling `esModuleInterop`. So whether libraries
compile with or without `esModuleInterop`, they run the risk of writing syntax
that makes their choice infectious.
Library authors who want to go above and beyond to ensure maximum
compatibility would do well to validate their declaration files against a
matrix of compiler options. But using `verbatimModuleSyntax` completely
sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files
to use CommonJS-style import and export syntax. Additionally, since
`esModuleInterop` only affects CommonJS, as more libraries move to ESM-only
publishing over time, the relevance of this issue will decline.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/appendices/ESM-CJS-Interop.md) ‚ù§
Contributors to this page:  
AB
DR
K
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules - Choosing Compiler Options
## I‚Äôm writing an app
A single tsconfig.json can only represent a single environment, both in terms
of what globals are available and in terms of how modules behave. If your app
contains server code, DOM code, web worker code, test code, and code to be
shared by all of those, each of those should have its own tsconfig.json,
connected with [project
references](https://www.typescriptlang.org/docs/handbook/project-
references.html#handbook-content). Then, use this guide once for each
tsconfig.json. For library-like projects within an app, especially ones that
need to run in multiple runtime environments, use the ‚ÄúI‚Äôm writing a library‚Äù
section.
### I‚Äôm using a bundler
In addition to adopting the following settings, it‚Äôs also recommended _not_ to
set `{ "type": "module" }` or use `.mts` files in bundler projects for now.
[Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-
default-exports-for-cjs-modules) adopt different ESM/CJS interop behavior
under these circumstances, which TypeScript cannot currently analyze with
`"moduleResolution": "bundler"`. See [issue
#54102](https://github.com/microsoft/TypeScript/issues/54102) for more
information.
    json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.
        // Required
        "module": "esnext",
        "moduleResolution": "bundler",
        "esModuleInterop": true,
        // Consult your bundler‚Äôs documentation
        "customConditions": ["module"],
        // Recommended
        "noEmit": true, // or `emitDeclarationOnly`
        "allowImportingTsExtensions": true,
        "allowArbitraryExtensions": true,
        "verbatimModuleSyntax": true, // or `isolatedModules`
      }
    }
### I‚Äôm compiling and running the outputs in Node.js
Remember to set `"type": "module"` or use `.mts` files if you intend to emit
ES modules.
    json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.
        // Required
        "module": "nodenext",
        // Implied by `"module": "nodenext"`:
        // "moduleResolution": "nodenext",
        // "esModuleInterop": true,
        // "target": "esnext",
        // Recommended
        "verbatimModuleSyntax": true,
      }
    }
### I‚Äôm using ts-node
ts-node attempts to be compatible with the same code and the same
tsconfig.json settings that can be used to compile and run the JS outputs in
Node.js. Refer to [ts-node documentation](https://typestrong.org/ts-node/) for
more details.
### I‚Äôm using tsx
Whereas ts-node makes minimal modifications to Node.js‚Äôs module system by
default, [tsx](https://github.com/esbuild-kit/tsx) behaves more like a
bundler, allowing extensionless/index module specifiers and arbitrary mixing
of ESM and CJS. Use the same settings for tsx as you would for a bundler.
### I‚Äôm writing ES modules for the browser, with no bundler or module compiler
TypeScript does not currently have options dedicated to this scenario, but you
can approximate them by using a combination of the `nodenext` ESM module
resolution algorithm and `paths` as a substitute for URL and import map
support.
    json
    // tsconfig.json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.
        // Combined with `"type": "module"` in a local package.json,
        // this enforces including file extensions on relative path imports.
        "module": "nodenext",
        "paths": {
          // Point TS to local types for remote URLs:
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"],
          // Optional: point bare specifier imports to an empty file
          // to prohibit importing from node_modules specifiers not listed here:
          "*": ["./empty-file.ts"]
        }
      }
    }
This setup allows explicitly listed HTTPS imports to use locally-installed
type declaration files, while erroring on imports that would normally resolve
in node_modules:
    ts
    import {} from "lodash";
    //             ^^^^^^^^
    // File '/project/empty-file.ts' is not a module. ts(2306)
Alternatively, you can use [import maps](https://github.com/WICG/import-maps)
to explicitly map a list of bare specifiers to URLs in the browser, while
relying on `nodenext`‚Äôs default node_modules lookups, or on `paths`, to direct
TypeScript to type declaration files for those bare specifier imports:
    html
    <script type="importmap">
    {
      "imports": {
        "lodash": "https://esm.sh/lodash@4.17.21"
      }
    }
    </script>
    ts
    import {} from "lodash";
    // Browser: https://esm.sh/lodash@4.17.21
    // TypeScript: ./node_modules/@types/lodash/index.d.ts
## I‚Äôm writing a library
Choosing compilation settings as a library author is a fundamentally different
process from choosing settings as an app author. When writing an app, settings
are chosen that reflect the runtime environment or bundler‚Äîtypically a single
entity with known behavior. When writing a library, you would ideally check
your code under _all possible_ library consumer compilation settings. Since
this is impractical, you can instead use the strictest possible settings,
since satisfying those tends to satisfy all others.
    json
    {
      "compilerOptions": {
        "module": "node16",
        "target": "es2020", // set to the *lowest* target you support
        "strict": true,
        "verbatimModuleSyntax": true,
        "declaration": true,
        "sourceMap": true,
        "declarationMap": true
      }
    }
Let‚Äôs examine why we picked each of these settings:
  * **`module: "node16"`**. When a codebase is compatible with Node.js‚Äôs module system, it almost always works in bundlers as well. If you‚Äôre using a third-party emitter to emit ESM outputs, ensure that you set `"type": "module"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let‚Äôs look at what would happen if a library were to compile with `"moduleResolution": "bundler"`:
        ts
    export * from "./utils";
Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine
with this code, so `"moduleResolution": "bundler"` doesn‚Äôt complain. Compiled
with `"module": "esnext"`, the output JavaScript for this export statement
will look exactly the same as the input. If that JavaScript were published to
npm, it would be usable by projects that use a bundler, but it would cause an
error when run in Node.js:
        Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js
    Did you mean to import ./utils.js?
On the other hand, if we had written:
        ts
    export * from "./utils.js";
This would produce output that works both in Node.js _and_ in bundlers.
In short, `"moduleResolution": "bundler"` is infectious, allowing code that
only works in bundlers to be produced. Likewise, `"moduleResolution":
"nodenext"` is only checking that the output works in Node.js, but in most
cases, module code that works in Node.js will work in other runtimes and in
bundlers.
  * **`target: "es2020"`**. Setting this value to the _lowest_ ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don‚Äôt access globals that may not be available in older environments.
  * **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:
        ts
    export interface Super {
      foo: string;
    }
    export interface Sub extends Super {
      foo: string | undefined;
    }
is only an error under `strictNullChecks`. On the other hand, it‚Äôs very
difficult to write code that errors only when `strict` is _disabled_ , so it‚Äôs
highly recommended for libraries to compile with `strict`.
  * **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user‚Äôs value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it‚Äôs also possible to write imports that only work _without_ `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.1 Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](/docs/handbook/modules/appendices/esm-cjs-interop.html#library-code-needs-special-considerations) for more details.
  * **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.
  * **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it‚Äôs up to you whether to include them.
### Considerations for bundling libraries
If you‚Äôre using a bundler to emit your library, then all your (non-
externalized) imports will be processed by the bundler with known behavior,
not by your users‚Äô unknowable environments. In this case, you can use
`"module": "esnext"` and `"moduleResolution": "bundler"`, but only with two
caveats:
  1. TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it‚Äôs common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user‚Äôs environment. To model this in TypeScript, you would want to process bundled imports with `"moduleResolution": "bundler"` and externalized imports with `"moduleResolution": "nodenext"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `"moduleResolution": "bundler"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `"moduleResolution": "nodenext"` may impose overly strict requirements on bundled imports.
  2. You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](/docs/handbook/modules/theory.html#the-role-of-declaration-files): every declaration file represents exactly one JavaScript file. If you use `"moduleResolution": "bundler"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `"module": "nodenext"`. For example, an input file like:
        ts
    import { Component } from "./extensionless-relative-import";
will have its import erased by the JS bundler, but produce a declaration file
with an identical import statement. That import statement, however, will
contain an invalid module specifier in Node.js, since it‚Äôs missing a file
extension. For Node.js users, TypeScript will error on the declaration file
and infect types referencing `Component` with `any`, assuming the dependency
will crash at runtime.
If your TypeScript bundler does not produce bundled declaration files, use
`"moduleResolution": "nodenext"` to ensure that the imports preserved in your
declaration files will be compatible with end-users‚Äô TypeScript settings. Even
better, consider not bundling your library.
### Notes on dual-emit solutions
A single TypeScript compilation (whether emitting or just type checking)
assumes that each input file will only produce one output file. Even if `tsc`
isn‚Äôt emitting anything, the type checking it performs on imported names rely
on knowledge about how the output file will behave at runtime, based on the
module- and emit-related options set in the tsconfig.json. While third-party
emitters are generally safe to use in combination with `tsc` type checking as
long as `tsc` can be configured to understand what the other emitter will
emit, any solution that emits two different sets of outputs with different
module formats while only type checking once leaves (at least) one of the
outputs unchecked. Because external dependencies may expose different APIs to
CommonJS and ESM consumers, there‚Äôs no configuration you can use to guarantee
in a single compilation that both outputs will be type-safe. In practice, most
dependencies follow best practices and dual-emit outputs work. Running tests
and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli) against
all output bundles before publishing significantly reduces the chance of a
serious problem going unnoticed.
* * *
  1. `verbatimModuleSyntax` can only work when the JS emitter emits the same module kind as `tsc` would given the tsconfig.json, source file extension, and package.json `"type"`. The option works by enforcing that the `import`/`require` written is identical to the `import`/`require` emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with `verbatimModuleSyntax`, since its whole purpose is to prevent you from writing `import` anywhere that a `require` would be emitted. `verbatimModuleSyntax` can also be defeated by configuring a third-party emitter to emit a different module kind than `tsc` would‚Äîfor example, by setting `"module": "esnext"` in tsconfig.json while configuring Babel to emit CommonJS.‚Ü©
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/guides/Choosing Compiler Options.md) ‚ù§
Contributors to this page:  
AB
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules - Introduction
This document is divided into four sections:
  1. The first section develops the [**theory**](/docs/handbook/modules/theory.html) behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.
  2. The [**guides**](/docs/handbook/modules/guides/choosing-compiler-options.html) show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.
  3. The [**reference**](/docs/handbook/modules/reference.html) section provides a more detailed look at the syntaxes and configurations presented in previous sections.
  4. The [**appendices**](/docs/handbook/modules/appendices/esm-cjs-interop.html) cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-
reference/Introduction.md) ‚ù§
Contributors to this page:  
AB
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules - Reference
## Module syntax
The TypeScript compiler recognizes standard [ECMAScript module
syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
in TypeScript and JavaScript files and many forms of [CommonJS
syntax](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-
files.html#commonjs-modules-are-supported) in JavaScript files.
There are also a few TypeScript-specific syntax extensions that can be used in
TypeScript files and/or JSDoc comments.
### Importing and exporting TypeScript-specific declarations
Type aliases, interfaces, enums, and namespaces can be exported from a module
with an `export` modifier, like any standard JavaScript declaration:
    ts
    // Standard JavaScript syntax...
    export function f() {}
    // ...extended to type declarations
    export type SomeType = /* ... */;
    export interface SomeInterface { /* ... */ }
They can also be referenced in named exports, even alongside references to
standard JavaScript declarations:
    ts
    export { f, SomeType, SomeInterface };
Exported types (and other TypeScript-specific declarations) can be imported
with standard ECMAScript imports:
    ts
    import { f, SomeType, SomeInterface } from "./module.js";
When using namespace imports or exports, exported types are available on the
namespace when referenced in a type position:
    ts
    import * as mod from "./module.js";
    mod.f();
    mod.SomeType; // Property 'SomeType' does not exist on type 'typeof import("./module.js")'
    let x: mod.SomeType; // Ok
### Type-only imports and exports
When emitting imports and exports to JavaScript, by default, TypeScript
automatically elides (does not emit) imports that are only used in type
positions and exports that only refer to types. Type-only imports and exports
can be used to force this behavior and make the elision explicit. Import
declarations written with `import type`, export declarations written with
`export type { ... }`, and import or export specifiers prefixed with the
`type` keyword are all guaranteed to be elided from the output JavaScript.
    ts
    // @Filename: main.ts
    import { f, type SomeInterface } from "./module.js";
    import type { SomeType } from "./module.js";
    class C implements SomeInterface {
      constructor(p: SomeType) {
        f();
      }
    }
    export type { C };
    // @Filename: main.js
    import { f } from "./module.js";
    class C {
      constructor(p) {
        f();
      }
    }
Even values can be imported with `import type`, but since they won‚Äôt exist in
the output JavaScript, they can only be used in non-emitting positions:
    ts
    import type { f } from "./module.js";
    f(); // 'f' cannot be used as a value because it was imported using 'import type'
    let otherFunction: typeof f = () => {}; // Ok
A type-only import declaration may not declare both a default import and named
bindings, since it appears ambiguous whether `type` applies to the default
import or to the entire import declaration. Instead, split the import
declaration into two, or use `default` as a named binding:
    ts
    import type fs, { BigIntOptions } from "fs";
    //          ^^^^^^^^^^^^^^^^^^^^^
    // Error: A type-only import can specify a default import or named bindings, but not both.
    import type { default as fs, BigIntOptions } from "fs"; // Ok
### `import()` types
TypeScript provides a type syntax similar to JavaScript‚Äôs dynamic `import` for
referencing the type of a module without writing an import declaration:
    ts
    // Access an exported type:
    type WriteFileOptions = import("fs").WriteFileOptions;
    // Access the type of an exported value:
    type WriteFileFunction = typeof import("fs").writeFile;
This is especially useful in JSDoc comments in JavaScript files, where it‚Äôs
not possible to import types otherwise:
    ts
    /** @type {import("webpack").Configuration} */
    module.exports = {
      // ...
    }
### `export =` and `import = require()`
When emitting CommonJS modules, TypeScript files can use a direct analog of
`module.exports = ...` and `const mod = require("...")` JavaScript syntax:
    ts
    // @Filename: main.ts
    import fs = require("fs");
    export = fs.readFileSync("...");
    // @Filename: main.js
    "use strict";
    const fs = require("fs");
    module.exports = fs.readFileSync("...");
This syntax was used over its JavaScript counterparts since variable
declarations and property assignments could not refer to TypeScript types,
whereas special TypeScript syntax could:
    ts
    // @Filename: a.ts
    interface Options { /* ... */ }
    module.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.
    export = Options; // Ok
    // @Filename: b.ts
    const Options = require("./a");
    const options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.
    // @Filename: c.ts
    import Options = require("./a");
    const options: Options = { /* ... */ }; // Ok
### Ambient modules
TypeScript supports a syntax in script (non-module) files for declaring a
module that exists in the runtime but has no corresponding file. These
_ambient modules_ usually represent runtime-provided modules, like `"fs"` or
`"path"` in Node.js:
    ts
    declare module "path" {
      export function normalize(p: string): string;
      export function join(...paths: any[]): string;
      export var sep: string;
    }
Once an ambient module is loaded into a TypeScript program, TypeScript will
recognize imports of the declared module in other files:
    ts
    // üëá Ensure the ambient module is loaded -
    //    may be unnecessary if path.d.ts is included
    //    by the project tsconfig.json somehow.
    /// <reference path="path.d.ts" />
    import { normalize, join } from "path";
Ambient module declarations are easy to confuse with [module
augmentations](https://www.typescriptlang.org/docs/handbook/declaration-
merging.html#module-augmentation) since they use identical syntax. This module
declaration syntax becomes a module augmentation when the file is a module,
meaning it has a top-level `import` or `export` statement (or is affected by
[`--moduleDetection force` or
`auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)):
    ts
    // Not an ambient module declaration anymore!
    export {};
    declare module "path" {
      export function normalize(p: string): string;
      export function join(...paths: any[]): string;
      export var sep: string;
    }
Ambient modules may use imports inside the module declaration body to refer to
other modules without turning the containing file into a module (which would
make the ambient module declaration a module augmentation):
    ts
    declare module "m" {
      // Moving this outside "m" would totally change the meaning of the file!
      import { SomeType } from "other";
      export function f(): SomeType;
    }
A _pattern_ ambient module contains a single `*` wildcard character in its
name, matching zero or more characters in import paths. This can be useful for
declaring modules provided by custom loaders:
    ts
    declare module "*.html" {
      const content: string;
      export default content;
    }
## The `module` compiler option
This section discusses the details of each `module` compiler option value. See
the [_Module output format_](/docs/handbook/modules/theory.html#the-module-
output-format) theory section for more background on what the option is and
how it fits into the overall compilation process. In brief, the `module`
compiler option was historically only used to control the output module format
of emitted JavaScript files. The more recent `node16` and `nodenext` values,
however, describe a wide range of characteristics of Node.js‚Äôs module system,
including what module formats are supported, how the module format of each
file is determined, and how different module formats interoperate.
### `node16`, `nodenext`
Node.js supports both CommonJS and ECMAScript modules, with specific rules for
which format each file can be and how the two formats are allowed to
interoperate. `node16` and `nodenext` describe the full range of behavior for
Node.js‚Äôs dual-format module system, and **emit files in either CommonJS or
ESM format**. This is different from every other `module` option, which are
runtime-agnostic and force all output files into a single format, leaving it
to the user to ensure the output is valid for their runtime.
> A common misconception is that `node16` and `nodenext` only emit ES modules.
> In reality, `node16` and `nodenext` describe versions of Node.js that
> _support_ ES modules, not just projects that _use_ ES modules. Both ESM and
> CommonJS emit are supported, based on the detected module format of each
> file. Because `node16` and `nodenext` are the only `module` options that
> reflect the complexities of Node.js‚Äôs dual module system, they are the
> **only correct`module` options** for all apps and libraries that are
> intended to run in Node.js v12 or later, whether they use ES modules or not.
`node16` and `nodenext` are currently identical, with the exception that they
imply different `target` option values. If Node.js makes significant changes
to its module system in the future, `node16` will be frozen while `nodenext`
will be updated to reflect the new behavior.
#### Module format detection
  * `.mts`/`.mjs`/`.d.mts` files are always ES modules.
  * `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.
  * `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `"type": "module"`, otherwise CommonJS modules.
The detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files
determines the module format of the emitted JavaScript files. So, for example,
a project consisting entirely of `.ts` files will emit all CommonJS modules by
default under `--module nodenext`, and can be made to emit all ES modules by
adding `"type": "module"` to the project package.json.
#### Interoperability rules
  * **When an ES module references a CommonJS module:**
    * The `module.exports` of the CommonJS module is available as a default import to the ES module.
    * Properties (other than `default`) of the CommonJS module‚Äôs `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer). TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript‚Äôs ability to catch named imports that may crash at runtime. See [#54018](https://github.com/microsoft/TypeScript/issues/54018) for more details.
  * **When a CommonJS module references an ES module:**
    * `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are detected to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.
    * A dynamic `import()` call may be used to import an ES module. It returns a Promise of the module‚Äôs Module Namespace Object (what you‚Äôd get from `import * as ns from "./module.js"` from another ES module).
#### Emit
The emit format of each file is determined by the detected module format of
each file. ESM emit is similar to `--module esnext`, but has a special
transformation for `import x = require("...")`, which is not allowed in
`--module esnext`:
    ts
    // @Filename: main.ts
    import x = require("mod");
    js
    // @Filename: main.js
    import { createRequire as _createRequire } from "module";
    const __require = _createRequire(import.meta.url);
    const x = __require("mod");
CommonJS emit is similar to `--module commonjs`, but dynamic `import()` calls
are not transformed. Emit here is shown with `esModuleInterop` enabled:
    ts
    // @Filename: main.ts
    import fs from "fs"; // transformed
    const dynamic = import("mod"); // not transformed
    js
    // @Filename: main.js
    "use strict";
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs_1 = __importDefault(require("fs")); // transformed
    const dynamic = import("mod"); // not transformed
#### Implied and enforced options
  * `--module nodenext` or `node16` implies and enforces the `moduleResolution` with the same name.
  * `--module nodenext` implies `--target esnext`.
  * `--module node16` implies `--target es2022`.
  * `--module nodenext` or `node16` implies `--esModuleInterop`.
#### Summary
  * `node16` and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.
  * `node16` and `nodenext` emit files in either CommonJS or ESM format, based on the detected module format of each file.
  * Node.js‚Äôs interoperability rules between ESM and CJS are reflected in type checking.
  * ESM emit transforms `import x = require("...")` to a `require` call constructed from a `createRequire` import.
  * CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.
### `preserve`
In `--module preserve`
([added](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-
bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and
exports written in input files are preserved in the output, and CommonJS-style
`import x = require("...")` and `export = ...` statements are emitted as
CommonJS `require` and `module.exports`. In other words, the format of each
individual import or export statement is preserved, rather than being coerced
into a single format for the whole compilation (or even a whole file).
While it‚Äôs rare to need to mix imports and require calls in the same file,
this `module` mode best reflects the capabilities of most modern bundlers, as
well as the Bun runtime.
> Why care about TypeScript‚Äôs `module` emit with a bundler or with Bun, where
> you‚Äôre likely also setting `noEmit`? TypeScript‚Äôs type checking and module
> resolution behavior are affected by the module format that it _would_ emit.
> Setting `module` gives TypeScript information about how your bundler or
> runtime will process imports and exports, which ensures that the types you
> see on imported values accurately reflect what will happen at runtime or
> after bundling. See `--moduleResolution bundler` for more discussion.
#### Examples
    ts
    import x, { y, z } from "mod";
    import mod = require("mod");
    const dynamic = import("mod");
    export const e1 = 0;
    export default "default export";
    js
    import x, { y, z } from "mod";
    const mod = require("mod");
    const dynamic = import("mod");
    export const e1 = 0;
    export default "default export";
#### Implied and enforced options
  * `--module preserve` implies `--moduleResolution bundler`.
  * `--module preserve` implies `--esModuleInterop`.
> The option `--esModuleInterop` is enabled by default in `--module preserve`
> only for its [type
> checking](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-
> cjs-interop.html#allowsyntheticdefaultimports-and-esmoduleinterop) behavior.
> Since imports never transform into require calls in `--module preserve`,
> `--esModuleInterop` does not affect the emitted JavaScript.
### `es2015`, `es2020`, `es2022`, `esnext`
#### Summary
  * Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.
  * Do not use for Node.js. Use `node16` or `nodenext` with `"type": "module"` in package.json to emit ES modules for Node.js.
  * `import mod = require("mod")` is not allowed in non-declaration files.
  * `es2020` adds support for `import.meta` properties.
  * `es2022` adds support for top-level `await`.
  * `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.
  * Emitted files are ES modules, but dependencies may be any format.
#### Examples
    ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
    js
    // @Filename: main.js
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
### `commonjs`
#### Summary
  * You probably shouldn‚Äôt use this. Use `node16` or `nodenext` to emit CommonJS modules for Node.js.
  * Emitted files are CommonJS modules, but dependencies may be any format.
  * Dynamic `import()` is transformed to a Promise of a `require()` call.
  * `esModuleInterop` affects the output code for default and namespace imports.
#### Examples
> Output is shown with `esModuleInterop: false`.
    ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
    js
    // @Filename: main.js
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.e1 = void 0;
    const mod_1 = require("mod");
    const mod = require("mod");
    const dynamic = Promise.resolve().then(() => require("mod"));
    console.log(mod_1.default, mod_1.y, mod_1.z, mod);
    exports.e1 = 0;
    exports.default = "default export";
    ts
    // @Filename: main.ts
    import mod = require("mod");
    console.log(mod);
    export = {
        p1: true,
        p2: false
    };
    js
    // @Filename: main.js
    "use strict";
    const mod = require("mod");
    console.log(mod);
    module.exports = {
        p1: true,
        p2: false
    };
### `system`
#### Summary
  * Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs).
#### Examples
    ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
    js
    // @Filename: main.js
    System.register(["mod"], function (exports_1, context_1) {
        "use strict";
        var mod_1, mod, dynamic, e1;
        var __moduleName = context_1 && context_1.id;
        return {
            setters: [
                function (mod_1_1) {
                    mod_1 = mod_1_1;
                    mod = mod_1_1;
                }
            ],
            execute: function () {
                dynamic = context_1.import("mod");
                console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
                exports_1("e1", e1 = 0);
                exports_1("default", "default export");
            }
        };
    });
### `amd`
#### Summary
  * Designed for AMD loaders like RequireJS.
  * You probably shouldn‚Äôt use this. Use a bundler instead.
  * Emitted files are AMD modules, but dependencies may be any format.
  * Supports `outFile`.
#### Examples
    ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
    js
    // @Filename: main.js
    define(["require", "exports", "mod", "mod"], function (require, exports, mod_1, mod) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.e1 = void 0;
        const dynamic = new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });
        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
        exports.e1 = 0;
        exports.default = "default export";
    });
### `umd`
#### Summary
  * Designed for AMD or CommonJS loaders.
  * Does not expose a global variable like most other UMD wrappers.
  * You probably shouldn‚Äôt use this. Use a bundler instead.
  * Emitted files are UMD modules, but dependencies may be any format.
#### Examples
    ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);
    export const e1 = 0;
    export default "default export";
    js
    // @Filename: main.js
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "mod", "mod"], factory);
        }
    })(function (require, exports) {
        "use strict";
        var __syncRequire = typeof module === "object" && typeof module.exports === "object";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.e1 = void 0;
        const mod_1 = require("mod");
        const mod = require("mod");
        const dynamic = __syncRequire ? Promise.resolve().then(() => require("mod")) : new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });
        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
        exports.e1 = 0;
        exports.default = "default export";
    });
## The `moduleResolution` compiler option
This section describes module resolution features and processes shared by
multiple `moduleResolution` modes, then specifies the details of each mode.
See the [_Module resolution_](/docs/handbook/modules/theory.html#module-
resolution) theory section for more background on what the option is and how
it fits into the overall compilation process. In brief, `moduleResolution`
controls how TypeScript resolves _module specifiers_ (string literals in
`import`/`export`/`require` statements) to files on disk, and should be set to
match the module resolver used by the target runtime or bundler.
### Common features and processes
#### File extension substitution
TypeScript always wants to resolve internally to a file that can provide type
information, while ensuring that the runtime or bundler can use the same path
to resolve to a file that provides a JavaScript implementation. For any module
specifier that would, according to the `moduleResolution` algorithm specified,
trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript
will first try to find a TypeScript implementation file or type declaration
file with the same name and analagous file extension.
Runtime lookup | TypeScript lookup #1 | TypeScript lookup #2 | TypeScript lookup #3 | TypeScript lookup #4 | TypeScript lookup #5  
---|---|---|---|---|---  
`/mod.js` | `/mod.ts` | `/mod.tsx` | `/mod.d.ts` | `/mod.js` | `./mod.jsx`  
`/mod.mjs` | `/mod.mts` | `/mod.d.mts` | `/mod.mjs` |  |   
`/mod.cjs` | `/mod.cts` | `/mod.d.cts` | `/mod.cjs` |  |   
Note that this behavior is independent of the actual module specifier written
in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts`
file even if the module specifier explicitly uses a `.js` file extension:
    ts
    import x from "./mod.js";
    // Runtime lookup: "./mod.js"
    // TypeScript lookup #1: "./mod.ts"
    // TypeScript lookup #2: "./mod.d.ts"
    // TypeScript lookup #3: "./mod.js"
See [_TypeScript imitates the host‚Äôs module resolution, but with
types_](/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-
module-resolution-but-with-types) for an explanation of why TypeScript‚Äôs
module resolution works this way.
#### Relative file path resolution
All of TypeScript‚Äôs `moduleResolution` algorithms support referencing a module
by a relative path that includes a file extension (which will be substituted
according to the rules above):
    ts
    // @Filename: a.ts
    export {};
    // @Filename: b.ts
    import {} from "./a.js"; // ‚úÖ Works in every `moduleResolution`
#### Extensionless relative paths
In some cases, the runtime or bundler allows omitting a `.js` file extension
from a relative path. TypeScript supports this behavior where the
`moduleResolution` setting and the context indicate that the runtime or
bundler supports it:
    ts
    // @Filename: a.ts
    export {};
    // @Filename: b.ts
    import {} from "./a";
If TypeScript determines that the runtime will perform a lookup for `./a.js`
given the module specifier `"./a"`, then `./a.js` will undergo extension
substitution, and resolve to the file `a.ts` in this example.
Extensionless relative paths are not supported in `import` paths in Node.js,
and are not always supported in file paths specified in package.json files.
TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts`
file extension, even though some runtimes and bundlers do.
#### Directory modules (index file resolution)
In some cases, a directory, rather than a file, can be referenced as a module.
In the simplest and most common case, this involves the runtime or bundler
looking for an `index.js` file in a directory. TypeScript supports this
behavior where the `moduleResolution` setting and the context indicate that
the runtime or bundler supports it:
    ts
    // @Filename: dir/index.ts
    export {};
    // @Filename: b.ts
    import {} from "./dir";
If TypeScript determines that the runtime will perform a lookup for
`./dir/index.js` given the module specifier `"./dir"`, then `./dir/index.js`
will undergo extension substitution, and resolve to the file `dir/index.ts` in
this example.
Directory modules may also contain a package.json file, where resolution of
the `"main"` and `"types"` fields are supported, and take precedence over
`index.js` lookups. The `"typesVersions"` field is also supported in directory
modules.
Note that directory modules are not the same as `node_modules` packages and
only support a subset of the features available to packages, and are not
supported at all in some contexts. Node.js considers them a [legacy
feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-
as-modules).
#### `paths`
##### Overview
TypeScript offers a way to override the compiler‚Äôs module resolution for bare
specifiers with the `paths` compiler option. While the feature was originally
designed to be used with the AMD module loader (a means of running modules in
the browser before ESM existed or bundlers were widely used), it still has
uses today when a runtime or bundler supports module resolution features that
TypeScript does not model. For example, when running Node.js with
`--experimental-network-imports`, you can manually specify a local type
definition file for a specific `https://` import:
    json
    {
      "compilerOptions": {
        "module": "nodenext",
        "paths": {
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"]
        }
      }
    }
    ts
    // Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry
    import { add } from "https://esm.sh/lodash@4.17.21";
It‚Äôs also common for apps built with bundlers to define convenience path
aliases in their bundler configuration, and then inform TypeScript of those
aliases with `paths`:
    json
    {
      "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "bundler",
        "paths": {
          "@app/*": ["./src/*"]
        }
      }
    }
##### `paths` does not affect emit
The `paths` option does _not_ change the import path in the code emitted by
TypeScript. Consequently, it‚Äôs very easy to create path aliases that appear to
work in TypeScript but will crash at runtime:
    json
    {
      "compilerOptions": {
        "module": "nodenext",
        "paths": {
          "node-has-no-idea-what-this-is": ["./oops.ts"]
        }
      }
    }
    ts
    // TypeScript: ‚úÖ
    // Node.js: üí•
    import {} from "node-has-no-idea-what-this-is";
While it‚Äôs ok for bundled apps to set up `paths`, it‚Äôs very important that
published libraries do _not_ , since the emitted JavaScript will not work for
consumers of the library without those users setting up the same aliases for
both TypeScript and their bundler. Both libraries and apps can consider
package.json `"imports"` as a standard replacement for convenience `paths`
aliases.
##### `paths` should not point to monorepo packages or node_modules packages
While module specifiers that match `paths` aliases are bare specifiers, once
the alias is resolved, module resolution proceeds on the resolved path as a
relative path. Consequently, resolution features that happen for
`node_modules` package lookups, including package.json `"exports"` field
support, do not take effect when a `paths` alias is matched. This can lead to
surprising behavior if `paths` is used to point to a `node_modules` package:
    ts
    {
      "compilerOptions": {
        "paths": {
          "pkg": ["./node_modules/pkg/dist/index.d.ts"],
          "pkg/*": ["./node_modules/pkg/*"]
        }
      }
    }
While this configuration may simulate some of the behavior of package
resolution, it overrides any `main`, `types`, `exports`, and `typesVersions`
the package‚Äôs `package.json` file defines, and imports from the package may
fail at runtime.
The same caveat applies to packages referencing each other in a monorepo.
Instead of using `paths` to make TypeScript artificially resolve `"@my-
scope/lib"` to a sibling package, it‚Äôs best to use workspaces via
[npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces),
[yarn](https://classic.yarnpkg.com/en/docs/workspaces/), or
[pnpm](https://pnpm.io/workspaces) to symlink your packages into
`node_modules`, so both TypeScript and the runtime or bundler perform real
`node_modules` package lookups. This is especially important if the monorepo
packages will be published to npm‚Äîthe packages will reference each other via
`node_modules` package lookups once installed by users, and using workspaces
allows you to test that behavior during local development.
##### Relationship to `baseUrl`
When `baseUrl` is provided, the values in each `paths` array are resolved
relative to the `baseUrl`. Otherwise, they are resolved relative to the
`tsconfig.json` file that defines them.
##### Wildcard substitutions
`paths` patterns can contain a single `*` wildcard, which matches any string.
The `*` token can then be used in the file path values to substitute the
matched string:
    json
    {
      "compilerOptions": {
        "paths": {
          "@app/*": ["./src/*"]
        }
      }
    }
When resolving an import of `"@app/components/Button"`, TypeScript will match
on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve
the path `./src/components/Button` relative to the `tsconfig.json` path. The
remainder of this lookup will follow the same rules as any other relative path
lookup according to the `moduleResolution` setting.
When multiple patterns match a module specifier, the pattern with the longest
matching prefix before any `*` token is used:
    json
    {
      "compilerOptions": {
        "paths": {
          "*": ["./src/foo/one.ts"],
          "foo/*": ["./src/foo/two.ts"],
          "foo/bar": ["./src/foo/three.ts"]
        }
      }
    }
When resolving an import of `"foo/bar"`, all three `paths` patterns match, but
the last is used because `"foo/bar"` is longer than `"foo/"` and `""`.
##### Fallbacks
Multiple file paths can be provided for a path mapping. If resolution fails
for one path, the next one in the array will be attempted until resolution
succeeds or the end of the array is reached.
    json
    {
      "compilerOptions": {
        "paths": {
          "*": ["./vendor/*", "./types/*"]
        }
      }
    }
#### `baseUrl`
> `baseUrl` was designed for use with AMD module loaders. If you aren‚Äôt using
> an AMD module loader, you probably shouldn‚Äôt use `baseUrl`. Since TypeScript
> 4.1, `baseUrl` is no longer required to use `paths` and should not be used
> just to set the directory `paths` values are resolved from.
The `baseUrl` compiler option can be combined with any `moduleResolution` mode
and specifies a directory that bare specifiers (module specifiers that don‚Äôt
begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher
precedence than `node_modules` package lookups in `moduleResolution` modes
that support them.
When performing a `baseUrl` lookup, resolution proceeds with the same rules as
other relative path resolutions. For example, in a `moduleResolution` mode
that supports extensionless relative paths a module specifier `"some-file"`
may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.
Resolution of relative module specifiers are never affected by the `baseUrl`
option.
#### `node_modules` package lookups
Node.js treats module specifiers that aren‚Äôt relative paths, absolute paths,
or URLs as references to packages that it looks up in `node_modules`
subdirectories. Bundlers conveniently adopted this behavior to allow their
users to use the same dependency management system, and often even the same
dependencies, as they would in Node.js. All of TypeScript‚Äôs `moduleResolution`
options except `classic` support `node_modules` lookups. (`classic` supports
lookups in `node_modules/@types` when other means of resolution fail, but
never looks for packages in `node_modules` directly.) Every `node_modules`
package lookup has the following structure (beginning after higher precedence
bare specifier rules, like `paths`, `baseUrl`, self-name imports, and
package.json `"imports"` lookups have been exhausted):
  1. For each ancestor directory of the importing file, if a `node_modules` directory exists within it: 
    1. If a directory with the same name as the package exists within `node_modules`: 
      1. Attempt to resolve types from the package directory.
      2. If a result is found, return it and stop the search.
    2. If a directory with the same name as the package exists within `node_modules/@types`: 
      1. Attempt to resolve types from the `@types` package directory.
      2. If a result is found, return it and stop the search.
  2. Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.
All `moduleResolution` modes (except `classic`) follow this pattern, while the
details of how they resolve from a package directory, once located, differ,
and are explained in the following sections.
#### package.json `"exports"`
When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and
`resolvePackageJsonExports` is not disabled, TypeScript follows Node.js‚Äôs
[package.json `"exports"`
spec](https://nodejs.org/api/packages.html#packages_package_entry_points) when
resolving from a package directory triggered by a bare specifier
`node_modules` package lookup.
TypeScript‚Äôs implementation for resolving a module specifier through
`"exports"` to a file path follows Node.js exactly. Once a file path is
resolved, however, TypeScript will still try multiple file extensions in order
to prioritize finding types.
When resolving through [conditional
`"exports"`](https://nodejs.org/api/packages.html#conditional-exports),
TypeScript always matches the `"types"` and `"default"` conditions if present.
Additionally, TypeScript will match a versioned types condition in the form
`"types@{selector}"` (where `{selector}` is a `"typesVersions"`-compatible
version selector) according to the same version-matching rules implemented in
`"typesVersions"`. Other non-configurable conditions are dependent on the
`moduleResolution` mode and specified in the following sections. Additional
conditions can be configured to match with the `customConditions` compiler
option.
Note that the presence of `"exports"` prevents any subpaths not explicitly
listed or matched by a pattern in `"exports"` from being resolved.
##### Example: subpaths, conditions, and extension substitution
Scenario: `"pkg/subpath"` is requested with conditions `["types", "node",
"require"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:
    json
    {
      "name": "pkg",
      "exports": {
        ".": {
          "import": "./index.mjs",
          "require": "./index.cjs"
        },
        "./subpath": {
          "import": "./subpath/index.mjs",
          "require": "./subpath/index.cjs"
        }
      }
    }
Resolution process within the package directory:
  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"import"` match this request? **No.**
  5. Does the second condition `"require"` match this request? **Yes.**
  6. Does the path `"./subpath/index.cjs"` have a recognized TypeScript file extension? **No, so use extension substitution.**
  7. Via extension substitution, try the following paths, returning the first one that exists, or `undefined` otherwise: 
    1. `./subpath/index.cts`
    2. `./subpath/index.d.cts`
    3. `./subpath/index.cjs`
If `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete.
Otherwise, resolution searches `node_modules/@types/pkg` and other
`node_modules` directories in an attempt to resolve types, according to the
`node_modules` package lookups rules. If no types are found, a second pass
through all `node_modules` resolves to `./subpath/index.cjs` (assuming it
exists), which counts as a successful resolution, but one that does not
provide types, leading to `any`-typed imports and a `noImplicitAny` error if
enabled.
##### Example: explicit `"types"` condition
Scenario: `"pkg/subpath"` is requested with conditions `["types", "node",
"import"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:
    json
    {
      "name": "pkg",
      "exports": {
        "./subpath": {
          "import": {
            "types": "./types/subpath/index.d.mts",
            "default": "./es/subpath/index.mjs"
          },
          "require": {
            "types": "./types/subpath/index.d.cts",
            "default": "./cjs/subpath/index.cjs"
          }
        }
      }
    }
Resolution process within the package directory:
  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"import"` match this request? **Yes.**
  5. The value at `exports["./subpath"].import` is an object‚Äîit must be specifying conditions.
  6. Does the first condition `"types"` match this request? **Yes.**
  7. Does the path `"./types/subpath/index.d.mts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `"./types/subpath/index.d.mts"` if the file exists, `undefined` otherwise.
##### Example: versioned `"types"` condition
Scenario: using TypeScript 4.7.5, `"pkg/subpath"` is requested with conditions
`["types", "node", "import"]` (determined by `moduleResolution` setting and
the context that triggered the module resolution request) in a package
directory with the following package.json:
    json
    {
      "name": "pkg",
      "exports": {
        "./subpath": {
          "types@>=5.2": "./ts5.2/subpath/index.d.ts",
          "types@>=4.6": "./ts4.6/subpath/index.d.ts",
          "types": "./tsold/subpath/index.d.ts",
          "default": "./dist/subpath/index.js"
        }
      }
    }
Resolution process within the package directory:
  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./subpath"` entry? **Yes.**
  3. The value at `exports["./subpath"]` is an object‚Äîit must be specifying conditions.
  4. Does the first condition `"types@>=5.2"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**
  5. Does the second condition `"types@>=4.6"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**
  6. Does the path `"./ts4.6/subpath/index.d.ts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  7. Return the path `"./ts4.6/subpath/index.d.ts"` if the file exists, `undefined` otherwise.
##### Example: subpath patterns
Scenario: `"pkg/wildcard.js"` is requested with conditions `["types", "node",
"import"]` (determined by `moduleResolution` setting and the context that
triggered the module resolution request) in a package directory with the
following package.json:
    json
    {
      "name": "pkg",
      "type": "module",
      "exports": {
        "./*.js": {
          "types": "./types/*.d.ts",
          "default": "./dist/*.js"
        }
      }
    }
Resolution process within the package directory:
  1. Does `"exports"` exist? **Yes.**
  2. Does `"exports"` have a `"./wildcard.js"` entry? **No.**
  3. Does any key with a `*` in it match `"./wildcard.js"`? **Yes,`"./*.js"` matches and sets `wildcard` to be the substitution.**
  4. The value at `exports["./*.js"]` is an object‚Äîit must be specifying conditions.
  5. Does the first condition `"types"` match this request? **Yes.**
  6. In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**
  7. Does the path `"./types/wildcard.d.ts"` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `"./types/wildcard.d.ts"` if the file exists, `undefined` otherwise.
##### Example: `"exports"` block other subpaths
Scenario: `"pkg/dist/index.js"` is requested in a package directory with the
following package.json:
    json
    {
      "name": "pkg",
      "main": "./dist/index.js",
      "exports": "./dist/index.js"
    }
Resolution process within the package directory:
  1. Does `"exports"` exist? **Yes.**
  2. The value at `exports` is a string‚Äîit must be a file path for the package root (`"."`).
  3. Is the request `"pkg/dist/index.js"` for the package root? **No, it has a subpath`dist/index.js`.**
  4. Resolution fails; return `undefined`.
Without `"exports"`, the request could have succeeded, but the presence of
`"exports"` prevents resolving any subpaths that cannot be matched through
`"exports"`.
#### package.json `"typesVersions"`
A `node_modules` package or directory module may specify a `"typesVersions"`
field in its package.json to redirect TypeScript‚Äôs resolution process
according to the TypeScript compiler version, and for `node_modules` packages,
according to the subpath being resolved. This allows package authors to
include new TypeScript syntax in one set of type definitions while providing
another set for backward compatibility with older TypeScript versions (through
a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)).
`"typesVersions"` is supported in all `moduleResolution` modes; however, the
field is not read in situations when package.json `"exports"` are read.
##### Example: redirect all requests to a subdirectory
Scenario: a module imports `"pkg"` using TypeScript 5.2, where
`node_modules/pkg/package.json` is:
    json
    {
      "name": "pkg",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        ">=3.1": {
          "*": ["ts3.1/*"]
        }
      }
    }
Resolution process:
  1. (Depending on compiler options) Does `"exports"` exist? **No.**
  2. Does `"typesVersions"` exist? **Yes.**
  3. Is the TypeScript version `>=3.1`? **Yes. Remember the mapping`"*": ["ts3.1/*"]`.**
  4. Are we resolving a subpath after the package name? **No, just the root`"pkg"`.**
  5. Does `"types"` exist? **Yes.**
  6. Does any key in `"typesVersions"` match `./index.d.ts`? **Yes,`"*"` matches and sets `index.d.ts` to be the substitution.**
  7. In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.
  8. Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  9. Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.
##### Example: redirect requests for a specific file
Scenario: a module imports `"pkg"` using TypeScript 3.9, where
`node_modules/pkg/package.json` is:
    json
    {
      "name": "pkg",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
      }
    }
Resolution process:
  1. (Depending on compiler options) Does `"exports"` exist? **No.**
  2. Does `"typesVersions"` exist? **Yes.**
  3. Is the TypeScript version `<4.0`? **Yes. Remember the mapping`"index.d.ts": ["index.v3.d.ts"]`.**
  4. Are we resolving a subpath after the package name? **No, just the root`"pkg"`.**
  5. Does `"types"` exist? **Yes.**
  6. Does any key in `"typesVersions"` match `./index.d.ts`? **Yes,`"index.d.ts"` matches.**
  7. Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don‚Äôt use extension substitution.**
  8. Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.
#### package.json `"main"` and `"types"`
If a directory‚Äôs package.json `"exports"` field is not read (either due to
compiler options, or because it is not present, or because the directory is
being resolved as a directory module instead of a `node_modules` package) and
the module specifier does not have a subpath after the package name or
package.json-containing directory, TypeScript will attempt to resolve from
these package.json fields, in order, in an attempt to find the main module for
the package or directory:
  * `"types"`
  * `"typings"` (legacy)
  * `"main"`
The declaration file found at `"types"` is assumed to be an accurate
representation of the implementation file found at `"main"`. If `"types"` and
`"typings"` are not present or cannot be resolved, TypeScript will read the
`"main"` field and perform extension substitution to find a declaration file.
When publishing a typed package to npm, it‚Äôs recommended to include a
`"types"` field even if extension substitution or package.json `"exports"`
make it unnecessary, because npm shows a TS icon on the package registry
listing only if the package.json contains a `"types"` field.
#### Package-relative file paths
If neither package.json `"exports"` nor package.json `"typesVersions"` apply,
subpaths of a bare package specifier resolve relative to the package
directory, according to applicable relative path resolution rules. In modes
that respect [package.json `"exports"`], this behavior is blocked by the mere
presence of the `"exports"` field in the package‚Äôs package.json, even if the
import fails to resolve through `"exports"`, as demonstrated in an example
above. On the other hand, if the import fails to resolve through
`"typesVersions"`, a package-relative file path resolution is attempted as a
fallback.
When package-relative paths are supported, they resolve under the same rules
as any other relative path considering the `moduleResolution` mode and
context. For example, in `--moduleResolution nodenext`, directory modules and
extensionless paths are only supported in `require` calls, not in `import`s:
    ts
    // @Filename: module.mts
    import "pkg/dist/foo";                // ‚ùå import, needs `.js` extension
    import "pkg/dist/foo.js";             // ‚úÖ
    import foo = require("pkg/dist/foo"); // ‚úÖ require, no extension needed
#### package.json `"imports"` and self-name imports
When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and
`resolvePackageJsonImports` is not disabled, TypeScript will attempt to
resolve import paths beginning with `#` through the `"imports"` field of the
nearest ancestor package.json of the importing file. Similarly, when
package.json `"exports"` lookups are enabled, TypeScript will attempt to
resolve import paths beginning with the current package name‚Äîthat is, the
value in the `"name"` field of the nearest ancestor package.json of the
importing file‚Äîthrough the `"exports"` field of that package.json. Both of
these features allow files in a package to import other files in the same
package, replacing a relative import path.
TypeScript follows Node.js‚Äôs resolution algorithm for
[`"imports"`](https://nodejs.org/api/packages.html#subpath-imports) and [self
references](https://nodejs.org/api/packages.html#self-referencing-a-package-
using-its-name) exactly up until a file path is resolved. At that point,
TypeScript‚Äôs resolution algorithm forks based on whether the package.json
containing the `"imports"` or `"exports"` being resolved belongs to a
`node_modules` dependency or the local project being compiled (i.e., its
directory contains the tsconfig.json file for the project that contains the
importing file):
  * If the package.json is in `node_modules`, TypeScript will apply extension substitution to the file path if it doesn‚Äôt already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.
  * If the package.json is part of the local project, an additional remapping step is performed in order to find the _input_ TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `"imports"`. Without this step, any compilation that resolves an `"imports"` path would be referencing output files from the _previous compilation_ instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `"imports"` usually requires an explicit `rootDir` to be set.
This variation allows package authors to write `"imports"` and `"exports"`
fields that reference only the compilation outputs that will be published to
npm, while still allowing local development to use the original TypeScript
source files.
##### Example: local project with conditions
Scenario: `"/src/main.mts"` imports `"#utils"` with conditions `["types",
"node", "import"]` (determined by `moduleResolution` setting and the context
that triggered the module resolution request) in a project directory with a
tsconfig.json and package.json:
    json
    // tsconfig.json
    {
      "compilerOptions": {
        "moduleResolution": "node16",
        "resolvePackageJsonImports": true,
        "rootDir": "./src",
        "outDir": "./dist"
      }
    }
    json
    // package.json
    {
      "name": "pkg",
      "imports": {
        "#utils": {
          "import": "./dist/utils.d.mts",
          "require": "./dist/utils.d.cts"
        }
      }
    }
Resolution process:
  1. Import path starts with `#`, try to resolve through `"imports"`.
  2. Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
  3. Does `"#utils"` exist in the `"imports"` object? **Yes.**
  4. The value at `imports["#utils"]` is an object‚Äîit must be specifying conditions.
  5. Does the first condition `"import"` match this request? **Yes.**
  6. Should we attempt to map the output path to an input path? **Yes, because:**
     * Is the package.json in `node_modules`? **No, it‚Äôs in the local project.**
     * Is the tsconfig.json within the package.json directory? **Yes.**
  7. In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**
  8. Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**
  9. Return the path `"./src/utils.mts"` if the file exists.
  10. Otherwise, return the path `"./dist/utils.d.mts"` if the file exists.
##### Example: `node_modules` dependency with subpath pattern
Scenario: `"/node_modules/pkg/main.mts"` imports `"#internal/utils"` with
conditions `["types", "node", "import"]` (determined by `moduleResolution`
setting and the context that triggered the module resolution request) with the
package.json:
    json
    // /node_modules/pkg/package.json
    {
      "name": "pkg",
      "imports": {
        "#internal/*": {
          "import": "./dist/internal/*.mjs",
          "require": "./dist/internal/*.cjs"
        }
      }
    }
Resolution process:
  1. Import path starts with `#`, try to resolve through `"imports"`.
  2. Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
  3. Does `"#internal/utils"` exist in the `"imports"` object? **No, check for pattern matches.**
  4. Does any key with a `*` match `"#internal/utils"`? **Yes,`"#internal/*"` matches and sets `utils` to be the substitution.**
  5. The value at `imports["#internal/*"]` is an object‚Äîit must be specifying conditions.
  6. Does the first condition `"import"` match this request? **Yes.**
  7. Should we attempt to map the output path to an input path? **No, because the package.json is in`node_modules`.**
  8. In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**
  9. Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**
  10. Via extension substitution, try the following paths, returning the first one that exists, or `undefined` otherwise: 
    1. `./dist/internal/utils.mts`
    2. `./dist/internal/utils.d.mts`
    3. `./dist/internal/utils.mjs`
### `node16`, `nodenext`
These modes reflect the module resolution behavior of Node.js v12 and later.
(`node16` and `nodenext` are currently identical, but if Node.js makes
significant changes to its module system in the future, `node16` will be
frozen while `nodenext` will be updated to reflect the new behavior.) In
Node.js, the resolution algorithm for ECMAScript imports is significantly
different from the algorithm for CommonJS `require` calls. For each module
specifier being resolved, the syntax and the module format of the importing
file are first used to determine whether the module specifier will be in an
`import` or `require` in the emitted JavaScript. That information is then
passed into the module resolver to determine which resolution algorithm to use
(and whether to use the `"import"` or `"require"` condition for package.json
`"exports"` or `"imports"`).
> TypeScript files that are determined to be in CommonJS format may still use
> `import` and `export` syntax by default, but the emitted JavaScript will use
> `require` and `module.exports` instead. This means that it‚Äôs common to see
> `import` statements that are resolved using the `require` algorithm. If this
> causes confusion, the `verbatimModuleSyntax` compiler option can be enabled,
> which prohibits the use of `import` statements that would be emitted as
> `require` calls.
Note that dynamic `import()` calls are always resolved using the `import`
algorithm, according to Node.js‚Äôs behavior. However, `import()` types are
resolved according to the format of the importing file (for backward
compatibility with existing CommonJS-format type declarations):
    ts
    // @Filename: module.mts
    import x from "./mod.js";             // `import` algorithm due to file format (emitted as-written)
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    type Mod = typeof import("./mod.js"); // `import` algorithm due to file format
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)
    // @Filename: commonjs.cts
    import x from "./mod";                // `require` algorithm due to file format (emitted as `require`)
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    type Mod = typeof import("./mod");    // `require` algorithm due to file format
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)
#### Implied and enforced options
  * `--moduleResolution node16` and `nodenext` must be paired with their corresponding `module` value.
#### Supported features
Features are listed in order of precedence.
| `import` | `require`  
---|---|---  
`paths` | ‚úÖ | ‚úÖ  
`baseUrl` | ‚úÖ | ‚úÖ  
`node_modules` package lookups | ‚úÖ | ‚úÖ  
package.json `"exports"` | ‚úÖ matches `types`, `node`, `import` | ‚úÖ matches `types`, `node`, `require`  
package.json `"imports"` and self-name imports | ‚úÖ matches `types`, `node`, `import` | ‚úÖ matches `types`, `node`, `require`  
package.json `"typesVersions"` | ‚úÖ | ‚úÖ  
Package-relative paths | ‚úÖ when `exports` not present | ‚úÖ when `exports` not present  
Full relative paths | ‚úÖ | ‚úÖ  
Extensionless relative paths | ‚ùå | ‚úÖ  
Directory modules | ‚ùå | ‚úÖ  
### `bundler`
`--moduleResolution bundler` attempts to model the module resolution behavior
common to most JavaScript bundlers. In short, this means supporting all the
behaviors traditionally associated with Node.js‚Äôs CommonJS `require`
resolution algorithm like `node_modules` lookups, directory modules, and
extensionless paths, while also supporting newer Node.js resolution features
like package.json `"exports"` and package.json `"imports"`.
It‚Äôs instructive to think about the similarities and differences between
`--moduleResolution bundler` and `--moduleResolution nodenext`, particularly
in how they decide what conditions to use when resolving package.json
`"exports"` or `"imports"`. Consider an import statement in a `.ts` file:
    ts
    // index.ts
    import { foo } from "pkg";
Recall that in `--module nodenext --moduleResolution nodenext`, the `--module`
setting first determines whether the import will be emitted to the `.js` file
as an `import` or `require` call, then passes that information to TypeScript‚Äôs
module resolver, which decides whether to match `"import"` or `"require"`
conditions in `"pkg"`‚Äôs package.json `"exports"` accordingly. Let‚Äôs assume
that there‚Äôs no package.json in scope of this file. The file extension is
`.ts`, so the output file extension will be `.js`, which Node.js will
interpret as CommonJS, so TypeScript will emit this `import` as a `require`
call. So, the module resolver will use the `require` condition as it resolves
`"exports"` from `"pkg"`.
The same process happens in `--moduleResolution bundler`, but the rules for
deciding whether to emit an `import` or `require` call for this import
statement will be different, since `--moduleResolution bundler` necessitates
using `--module esnext` or `--module preserve`. In both of those modes, ESM
`import` declarations always emit as ESM `import` declarations, so
TypeScript‚Äôs module resolver will receive that information and use the
`"import"` condition as it resolves `"exports"` from `"pkg"`.
This explanation may be somewhat unintuitive, since `--moduleResolution
bundler` is usually used in combination with `--noEmit`‚Äîbundlers typically
process raw `.ts` files and perform module resolution on untransformed
`import`s or `require`s. However, for consistency, TypeScript still uses the
hypothetical emit decided by `module` to inform module resolution and type
checking. This makes `--module preserve` the best choice whenever a runtime or
bundler is operating on raw `.ts` files, since it implies no transformation.
Under `--module preserve --moduleResolution bundler`, you can write imports
and requires in the same file that will resolve with the `import` and
`require` conditions, respectively:
    ts
    // index.ts
    import pkg1 from "pkg";       // Resolved with "import" condition
    import pkg2 = require("pkg"); // Resolved with "require" condition
#### Implied and enforced options
  * `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.
  * `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.
#### Supported features
  * `paths` ‚úÖ
  * `baseUrl` ‚úÖ
  * `node_modules` package lookups ‚úÖ
  * package.json `"exports"` ‚úÖ matches `types`, `import`/`require` depending on syntax
  * package.json `"imports"` and self-name imports ‚úÖ matches `types`, `import`/`require` depending on syntax
  * package.json `"typesVersions"` ‚úÖ
  * Package-relative paths ‚úÖ when `exports` not present
  * Full relative paths ‚úÖ
  * Extensionless relative paths ‚úÖ
  * Directory modules ‚úÖ
### `node10` (formerly known as `node`)
`--moduleResolution node` was renamed to `node10` (keeping `node` as an alias
for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module
resolution algorithm as it existed in Node.js versions earlier than v12. It
should no longer be used.
#### Supported features
  * `paths` ‚úÖ
  * `baseUrl` ‚úÖ
  * `node_modules` package lookups ‚úÖ
  * package.json `"exports"` ‚ùå
  * package.json `"imports"` and self-name imports ‚ùå
  * package.json `"typesVersions"` ‚úÖ
  * Package-relative paths ‚úÖ
  * Full relative paths ‚úÖ
  * Extensionless relative paths ‚úÖ
  * Directory modules ‚úÖ
### `classic`
Do not use `classic`.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-reference/Reference.md)
‚ù§
Contributors to this page:  
AB
SF
SF
Z
HCDC
Last updated: Sep 16, 2024  
Was this page helpful?
# Modules - Theory
## Scripts and modules in JavaScript
In the early days of JavaScript, when the language only ran in browsers, there
were no modules, but it was still possible to split the JavaScript for a web
page into multiple files by using multiple `script` tags in HTML:
    html
    <html>
      <head>
        <script src="a.js"></script>
        <script src="b.js"></script>
      </head>
      <body></body>
    </html>
This approach had some downsides, especially as web pages grew larger and more
complex. In particular, all scripts loaded onto the same page share the same
scope‚Äîappropriately called the ‚Äúglobal scope‚Äù‚Äîmeaning the scripts had to be
very careful not to overwrite each others‚Äô variables and functions.
Any system that solves this problem by giving files their own scope while
still providing a way to make bits of code available to other files can be
called a ‚Äúmodule system.‚Äù (It may sound obvious to say that each file in a
module system is called a ‚Äúmodule,‚Äù but the term is often used to contrast
with _script_ files, which run outside a module system, in a global scope.)
> There are [many module systems](https://github.com/myshov/history-of-
> javascript/tree/master/4_evolution_of_js_modularity), and TypeScript
> [supports emitting
> several](https://www.typescriptlang.org/tsconfig/#module), but this
> documentation will focus on the two most important systems today: ECMAScript
> modules (ESM) and CommonJS (CJS).
>
> ECMAScript Modules (ESM) is the module system built into the language,
> supported in modern browsers and in Node.js since v12. It uses dedicated
> `import` and `export` syntax:
>  
>  
>     js
>  
>     // a.js
>  
>     export default "Hello from a.js";
>  
>  
>     js
>  
>     // b.js
>  
>     import a from "./a.js";
>  
>     console.log(a); // 'Hello from a.js'
>
> CommonJS (CJS) is the module system that originally shipped in Node.js,
> before ESM was part of the language specification. It‚Äôs still supported in
> Node.js alongside ESM. It uses plain JavaScript objects and functions named
> `exports` and `require`:
>  
>  
>     js
>  
>     // a.js
>  
>     exports.message = "Hello from a.js";
>  
>  
>     js
>  
>     // b.js
>  
>     const a = require("./a");
>  
>     console.log(a.message); // 'Hello from a.js'
Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript
module, it starts by assuming that file will have its own scope. Beyond that,
though, the compiler‚Äôs job gets a little more complicated.
## TypeScript‚Äôs job concerning modules
The TypeScript compiler‚Äôs chief goal is to prevent certain kinds of runtime
errors by catching them at compile time. With or without modules involved, the
compiler needs to know about the code‚Äôs intended runtime environment‚Äîwhat
globals are available, for example. When modules are involved, there are
several additional questions the compiler needs to answer in order to do its
job. Let‚Äôs use a few lines of input code as an example to think about all the
information needed to analyze it:
    ts
    import sayHello from "greetings";
    sayHello("world");
To check this file, the compiler needs to know the type of `sayHello` (is it a
function that can accept one string argument?), which opens quite a few
additional questions:
  1. Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?
  2. What _kind_ of module does the module system expect to find, given the file name it will load and its location on disk?
  3. If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?
  4. Where will the module system look to find the module specified by `"greetings"`? Will the lookup succeed?
  5. What kind of module is the file resolved by that lookup?
  6. Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?
  7. Once the `"greetings"` module has been analyzed, what piece of that module is bound to `sayHello`?
Notice that all of these questions depend on characteristics of the _host_
‚Äîthe system that ultimately consumes the output JavaScript (or raw TypeScript,
as the case may be) to direct its module loading behavior, typically either a
runtime (like Node.js) or bundler (like Webpack).
The ECMAScript specification defines how ESM imports and exports link up with
each other, but it doesn‚Äôt specify how the file lookup in (4), known as
_module resolution_ , happens, and it doesn‚Äôt say anything about other module
systems like CommonJS. So runtimes and bundlers, especially those that want to
support both ESM and CJS, have a lot of freedom to design their own rules.
Consequently, the way TypeScript should answer the questions above can vary
dramatically depending on where the code is intended to run. There‚Äôs no single
right answer, so the compiler must be told the rules through configuration
options.
The other key idea to keep in mind is that TypeScript almost always thinks
about these questions in terms of its _output_ JavaScript files, not its
_input_ TypeScript (or JavaScript!) files. Today, some runtimes and bundlers
support loading TypeScript files directly, and in those cases, it doesn‚Äôt make
sense to think about separate input and output files. Most of this document
discusses cases where TypeScript files are compiled to JavaScript files, which
in turn are loaded by the runtime module system. Examining these cases is
essential for building an understanding of the compiler‚Äôs options and
behavior‚Äîit‚Äôs easier to start there and simplify when thinking about esbuild,
Bun, and other TypeScript-first runtimes and bundlers. So for now, we can
summarize TypeScript‚Äôs job when it comes to modules in terms of output files:
Understand the **rules of the host** enough
  1. to compile files into a valid **output module format** ,
  2. to ensure that imports in those **outputs** will **resolve successfully** , and
  3. to know what **type** to assign to **imported names**.
## Who is the host?
Before we move on, it‚Äôs worth making sure we‚Äôre on the same page about the
term _host_ , because it will come up frequently. We defined it before as ‚Äúthe
system that ultimately consumes the output code to direct its module loading
behavior.‚Äù In other words, it‚Äôs the system outside of TypeScript that
TypeScript‚Äôs module analysis tries to model:
  * When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.
  * When there is no ‚Äúoutput code‚Äù because a runtime consumes TypeScript files directly, the runtime is still the host.
  * When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn‚Äôt know about anything that happens post-bundler.)
  * If another transpiler, optimizer, or formatter runs on TypeScript‚Äôs outputs, it‚Äôs _not_ a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.
  * When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser‚Äôs JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.
  * The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.
## The module output format
In any project, the first question about modules we need to answer is what
kinds of modules the host expects, so TypeScript can set its output format for
each file to match. Sometimes, the host only _supports_ one kind of module‚ÄîESM
in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12
and later accepts both CJS and ES modules, but uses file extensions and
`package.json` files to determine what format each file should be, and throws
an error if the file‚Äôs contents don‚Äôt match the expected format.
The `module` compiler option provides this information to the compiler. Its
primary purpose is to control the module format of any JavaScript that gets
emitted during compilation, but it also serves to inform the compiler about
how the module kind of each file should be detected, how different module
kinds are allowed to import each other, and whether features like
`import.meta` and top-level `await` are available. So, even if a TypeScript
project is using `noEmit`, choosing the right setting for `module` still
matters. As we established earlier, the compiler needs an accurate
understanding of the module system so it can type check (and provide
IntelliSense for) imports. See [_Choosing compiler
options_](/docs/handbook/modules/guides/choosing-compiler-options.html) for
guidance on choosing the right `module` setting for your project.
The available `module` settings are
  * [**`node16`**](/docs/handbook/modules/reference.html#node16-nodenext): Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.
  * [**`nodenext`**](/docs/handbook/modules/reference.html#node16-nodenext): Currently identical to `node16`, but will be a moving target reflecting the latest Node.js versions as Node.js‚Äôs module system evolves.
  * [**`es2015`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).
  * [**`es2020`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for `import.meta` and `export * as ns from "mod"` to `es2015`.
  * [**`es2022`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for top-level `await` to `es2020`.
  * [**`esnext`**](/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.
  * **[`commonjs`](/docs/handbook/modules/reference.html#commonjs), [`system`](/docs/handbook/modules/reference.html#system), [`amd`](/docs/handbook/modules/reference.html#amd), and [`umd`](/docs/handbook/modules/reference.html#umd)**: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.
> Node.js‚Äôs rules for module format detection and interoperability make it
> incorrect to specify `module` as `esnext` or `commonjs` for projects that
> run in Node.js, even if all files emitted by `tsc` are ESM or CJS,
> respectively. The only correct `module` settings for projects that intend to
> run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for
> an all-ESM Node.js project might look identical between compilations using
> `esnext` and `nodenext`, the type checking can differ. See the [reference
> section on
> `nodenext`](/docs/handbook/modules/reference.html#node16-nodenext) for more
> details.
### Module format detection
Node.js understands both ES modules and CJS modules, but the format of each
file is determined by its file extension and the `type` field of the first
`package.json` file found in a search of the file‚Äôs directory and all ancestor
directories:
  * `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.
  * `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `"module"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.
If a file is determined to be an ES module by these rules, Node.js will not
inject the CommonJS `module` and `require` objects into the file‚Äôs scope
during evaluation, so a file that tries to use them will cause a crash.
Conversely, if a file is determined to be a CJS module, `import` and `export`
declarations in the file will cause a syntax error crash.
When the `module` compiler option is set to `node16` or `nodenext`, TypeScript
applies this same algorithm to the project‚Äôs _input_ files to determine the
module kind of each corresponding _output_ file. Let‚Äôs look at how module
formats are detected in an example project that uses `--module nodenext`:
Input file name | Contents | Output file name | Module kind | Reason  
---|---|---|---|---  
`/package.json` | `{}` |  |  |   
`/main.mts` |  | `/main.mjs` | ESM | File extension  
`/utils.cts` |  | `/utils.cjs` | CJS | File extension  
`/example.ts` |  | `/example.js` | CJS | No `"type": "module"` in `package.json`  
`/node_modules/pkg/package.json` | `{ "type": "module" }` |  |  |   
`/node_modules/pkg/index.d.ts` |  |  | ESM | `"type": "module"` in `package.json`  
`/node_modules/pkg/index.d.cts` |  |  | CJS | File extension  
When the input file extension is `.mts` or `.cts`, TypeScript knows to treat
that file as an ES module or CJS module, respectively, because Node.js will
treat the output `.mjs` file as an ES module or the output `.cjs` file as a
CJS module. When the input file extension is `.ts`, TypeScript has to consult
the nearest `package.json` file to determine the module format, because this
is what Node.js will do when it encounters the output `.js` file. (Notice that
the same rules apply to the `.d.cts` and `.d.ts` declaration files in the
`pkg` dependency: though they will not produce an output file as part of this
compilation, the presence of a `.d.ts` file _implies_ the existence of a
corresponding `.js` file‚Äîperhaps created when the author of the `pkg` library
ran `tsc` on an input `.ts` file of their own‚Äîwhich Node.js must interpret as
an ES module, due to its `.js` extension and the presence of the `"type":
"module"` field in `/node_modules/pkg/package.json`. Declaration files are
covered in more detail in a later section.)
The detected module format of input files is used by TypeScript to ensure it
emits the output syntax that Node.js expects in each output file. If
TypeScript were to emit `/example.js` with `import` and `export` statements in
it, Node.js would crash when parsing the file. If TypeScript were to emit
`/main.mjs` with `require` calls, Node.js would crash during evaluation.
Beyond emit, the module format is also used to determine rules for type
checking and module resolution, which we‚Äôll discuss in the following sections.
It‚Äôs worth mentioning again that TypeScript‚Äôs behavior in `--module node16`
and `--module nodenext` is entirely motivated by Node.js‚Äôs behavior. Since
TypeScript‚Äôs goal is to catch potential runtime errors at compile time, it
needs a very accurate model of what will happen at runtime. This fairly
complex set of rules for module kind detection is _necessary_ for checking
code that will run in Node.js, but may be overly strict or just incorrect if
applied to non-Node.js hosts.
### Input module syntax
It‚Äôs important to note that the _input_ module syntax seen in input source
files is somewhat decoupled from the output module syntax emitted to JS files.
That is, a file with an ESM import:
    ts
    import { sayHello } from "greetings";
    sayHello("world");
might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:
    ts
    Object.defineProperty(exports, "__esModule", { value: true });
    const greetings_1 = require("greetings");
    (0, greetings_1.sayHello)("world");
depending on the `module` compiler option (and any applicable module format
detection rules, if the `module` option supports more than one kind of
module). In general, this means that looking at the contents of an input file
isn‚Äôt enough to determine whether it‚Äôs an ES module or a CJS module.
> Today, most TypeScript files are authored using ESM syntax (`import` and
> `export` statements) regardless of the output format. This is largely a
> legacy of the long road ESM has taken to widespread support. ECMAScript
> modules were standardized in 2015, were supported in most browsers by 2017,
> and landed in Node.js v12 in 2019. During much of this window, it was clear
> that ESM was the future of JavaScript modules, but very few runtimes could
> consume it. Tools like Babel made it possible for JavaScript to be authored
> in ESM and downleveled to another module format that could be used in
> Node.js or browsers. TypeScript followed suit, adding support for ES module
> syntax and softly discouraging the use of the original CommonJS-inspired
> `import fs = require("fs")` syntax in [the 1.5
> release](https://devblogs.microsoft.com/typescript/announcing-
> typescript-1-5/).
>
> The upside of this ‚Äúauthor ESM, output anything‚Äù strategy was that
> TypeScript could use standard JavaScript syntax, making the authoring
> experience familiar to newcomers, and (theoretically) making it easy for
> projects to start targeting ESM outputs in the future. There are three
> significant downsides, which became fully apparent only after ESM and CJS
> modules were allowed to coexist and interoperate in Node.js:
>
>   1. Early assumptions about how ESM/CJS interoperability would work in
> Node.js turned out to be wrong, and today, interoperability rules differ
> between Node.js and bundlers. Consequently, the configuration space for
> modules in TypeScript is large.
>   2. When the syntax in input files all looks like ESM, it‚Äôs easy for an
> author or code reviewer to lose track of what kind of module a file is at
> runtime. And because of Node.js‚Äôs interoperability rules, what kind of
> module each file is became very important.
>   3. When input files are written in ESM, the syntax in type declaration
> outputs (`.d.ts` files) looks like ESM too. But because the corresponding
> JavaScript files could have been emitted in any module format, TypeScript
> can‚Äôt tell what kind of module a file is just by looking at the contents of
> its type declarations. And again, because of the nature of ESM/CJS
> interoperability, TypeScript _has_ to know what kind of module everything is
> in order to provide correct types and prevent imports that will crash.
>
>
> In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was
> introduced to help TypeScript authors know exactly how their `import` and
> `export` statements will be emitted. When enabled, the flag requires imports
> and exports in input files to be written in the form that will undergo the
> least amount of transformation before emit. So if a file will be emitted as
> ESM, imports and exports must be written in ESM syntax; if a file will be
> emitted as CJS, it must be written in the CommonJS-inspired TypeScript
> syntax (`import fs = require("fs")` and `export = {}`). This setting is
> particularly recommended for Node.js projects that use mostly ESM, but have
> a select few CJS files. It is not recommended for projects that currently
> target CJS, but may want to target ESM in the future.
### ESM and CJS interoperability
Can an ES module `import` a CommonJS module? If so, does a default import link
to `exports` or `exports.default`? Can a CommonJS module `require` an ES
module? CommonJS isn‚Äôt part of the ECMAScript specification, so runtimes,
bundlers, and transpilers have been free to make up their own answers to these
questions since ESM was standardized in 2015, and as such no standard set of
interoperability rules exist. Today, most runtimes and bundlers broadly fall
into one of three categories:
  1. **ESM-only.** Some runtimes, like browser engines, only support what‚Äôs actually a part of the language: ECMAScript Modules.
  2. **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.
  3. **Node.js.** In Node.js, CommonJS modules cannot load ES modules synchronously (with `require`); they can only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)
TypeScript needs to know which of these rule sets to assume in order to
provide correct types on (particularly `default`) imports and to error on
imports that will crash at runtime. When the `module` compiler option is set
to `node16` or `nodenext`, Node.js‚Äôs rules are enforced. All other `module`
settings, combined with the
[`esModuleInterop`](/docs/handbook/modules/reference.html#esModuleInterop)
option, result in bundler-like interop in TypeScript. (While using `--module
esnext` does prevent you from _writing_ CommonJS modules, it does not prevent
you from _importing_ them as dependencies. There‚Äôs currently no TypeScript
setting that can guard against an ES module importing a CommonJS module, as
would be appropriate for direct-to-browser code.)
### Module specifiers are not transformed
While the `module` compiler option can transform imports and exports in input
files to different module formats in output files, the module _specifier_ (the
string `from` which you `import`, or pass to `require`) is always emitted as-
written. For example, an input like:
    ts
    import { add } from "./math.mjs";
    add(1, 2);
might be emitted as either:
    ts
    import { add } from "./math.mjs";
    add(1, 2);
or:
    ts
    const math_1 = require("./math.mjs");
    math_1.add(1, 2);
depending on the `module` compiler option, but the module specifier will
always be `"./math.mjs"`. There is no compiler option that enables
transforming, substituting, or rewriting module specifiers. Consequently,
module specifiers must be written in a way that works for the code‚Äôs target
runtime or bundler, and it‚Äôs TypeScript‚Äôs job to understand those _output_
-relative specifiers. The process of finding the file referenced by a module
specifier is called _module resolution_.
## Module resolution
Let‚Äôs return to our first example and review what we‚Äôve learned about it so
far:
    ts
    import sayHello from "greetings";
    sayHello("world");
So far, we‚Äôve discussed how the host‚Äôs module system and TypeScript‚Äôs `module`
compiler option might impact this code. We know that the input syntax looks
like ESM, but the output format depends on the `module` compiler option,
potentially the file extension, and `package.json` `"type"` field. We also
know that what `sayHello` gets bound to, and even whether the import is even
allowed, may vary depending on the module kinds of this file and the target
file. But we haven‚Äôt yet discussed how to _find_ the target file.
### Module resolution is host-defined
While the ECMAScript specification defines how to parse and interpret `import`
and `export` statements, it leaves module resolution up to the host. If you‚Äôre
creating a hot new JavaScript runtime, you‚Äôre free to create a module
resolution scheme like:
    ts
    import monkey from "üêí"; // Looks for './eats/bananas.js'
    import cow from "üêÑ";    // Looks for './eats/grass.js'
    import lion from "ü¶Å";   // Looks for './eats/you.js'
and still claim to implement ‚Äústandards-compliant ESM.‚Äù Needless to say,
TypeScript would have no idea what types to assign to `monkey`, `cow`, and
`lion` without built-in knowledge of this runtime‚Äôs module resolution
algorithm. Just as `module` informs the compiler about the host‚Äôs expected
module format, `moduleResolution`, along with a few customization options,
specify the algorithm the host uses to resolve module specifiers to files.
This also clarifies why TypeScript doesn‚Äôt modify import specifiers during
emit: the relationship between an import specifier and a file on disk (if one
even exists) is host-defined, and TypeScript is not a host.
The available `moduleResolution` options are:
  * [**`classic`**](/docs/handbook/modules/reference.html#classic): TypeScript‚Äôs oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages) configurations. It should not be used for new projects (or even old projects that don‚Äôt use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.
  * [**`node10`**](/docs/handbook/modules/reference.html#node10-formerly-known-as-node): Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It‚Äôs a pretty good model of Node.js versions older than v12, and sometimes it‚Äôs a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it‚Äôs a very bad model of modern versions of Node.js. It should not be used for new projects.
  * [**`node16`**](/docs/handbook/modules/reference.html#node16-nodenext-1): This is the counterpart of `--module node16` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the module format detection rules instated by `--module node16`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else has unsupported behavior and may be an error in the future.)
  * [**`nodenext`**](/docs/handbook/modules/reference.html#node16-nodenext-1): Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It‚Äôs intended to be a forward-looking mode that will support new Node.js module resolution features as they‚Äôre added.
  * [**`bundler`**](/docs/handbook/modules/reference.html#bundler): Node.js v12 introduced some new module resolution features for importing npm packages‚Äîthe `"exports"` and `"imports"` fields of `package.json`‚Äîand many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `"exports"` and `"imports"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.
### TypeScript imitates the host‚Äôs module resolution, but with types
Remember the three components of TypeScript‚Äôs job concerning modules?
  1. Compile files into a valid **output module format**
  2. Ensure that imports in those **outputs** will **resolve successfully**
  3. Know what **type** to assign to **imported names**.
Module resolution is needed to accomplish last two. But when we spend most of
our time working in input files, it can be easy to forget about (2)‚Äîthat a key
component of module resolution is validating that the imports or `require`
calls in the output files, containing the same module specifiers as the input
files, will actually work at runtime. Let‚Äôs look at a new example with
multiple files:
    ts
    // @Filename: math.ts
    export function add(a: number, b: number) {
      return a + b;
    }
    // @Filename: main.ts
    import { add } from "./math";
    add(1, 2);
When we see the import from `"./math"`, it might be tempting to think, ‚ÄúThis
is how one TypeScript file refers to another. The compiler follows this
(extensionless) path in order to assign a type to `add`.‚Äù
This isn‚Äôt entirely wrong, but the reality is deeper. The resolution of
`"./math"` (and subsequently, the type of `add`) need to reflect the reality
of what happens at runtime to the _output_ files. A more robust way to think
about this process would look like this:
This model makes it clear that for TypeScript, module resolution is mostly a
matter of accurately modeling the host‚Äôs module resolution algorithm between
output files, with a little bit of remapping applied to find type information.
Let‚Äôs look at another example that appears unintuitive through the lens of the
simple model, but makes perfect sense with the robust model:
    ts
    // @moduleResolution: node16
    // @rootDir: src
    // @outDir: dist
    // @Filename: src/math.mts
    export function add(a: number, b: number) {
      return a + b;
    }
    // @Filename: src/main.mts
    import { add } from "./math.mjs";
    add(1, 2);
Node.js ESM `import` declarations use a strict module resolution algorithm
that requires relative paths to include file extensions. When we only think
about input files, it‚Äôs a little strange that `"./math.mjs"` seems to resolve
to `math.mts`. Since we‚Äôre using an `outDir` to put compiled outputs in a
different directory, `math.mjs` doesn‚Äôt even exist next to `main.mts`! Why
should this resolve? With our new mental model, it‚Äôs no problem:
Understanding this mental model may not immediately eliminate the strangeness
of seeing output file extensions in input files, and it‚Äôs natural to think in
terms of shortcuts: _`"./math.mjs"` refers to the input file `math.mts`. I
have to write the output extension, but the compiler knows to look for `.mts`
when I write `.mjs`._ This shortcut is even how the compiler works internally,
but the more robust mental model explains _why_ module resolution in
TypeScript works this way: given the constraint that the module specifier in
the output file will be the same as the module specifier in the input file,
this is the only process that accomplishes our two goals of validating output
files and assigning types.
### The role of declaration files
In the previous example, we saw the ‚Äúremapping‚Äù part of module resolution
working between input and output files. But what happens when we import
library code? Even if the library was written in TypeScript, it may not have
published its source code. If we can‚Äôt rely on mapping the library‚Äôs
JavaScript files back to a TypeScript file, we can verify that our import
works at runtime, but how do we accomplish our second goal of assigning types?
This is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The
best way to understand how declaration files are interpreted is to understand
where they come from. When you run `tsc --declaration` on an input file, you
get one output JavaScript file and one output declaration file:
Because of this relationship, the compiler _assumes_ that wherever it sees a
declaration file, there is a corresponding JavaScript file that is perfectly
described by the type information in the declaration file. For performance
reasons, in every module resolution mode, the compiler always looks for
TypeScript and declaration files first, and if it finds one, it doesn‚Äôt
continue looking for the corresponding JavaScript file. If it finds a
TypeScript input file, it knows a JavaScript file _will_ exist after
compilation, and if it finds a declaration file, it knows a compilation
(perhaps someone else‚Äôs) already happened and created a JavaScript file at the
same time as the declaration file.
The declaration file tells the compiler not only that a JavaScript file
exists, but also what its name and extension are:
Declaration file extension | JavaScript file extension | TypeScript file extension  
---|---|---  
`.d.ts` | `.js` | `.ts`  
`.d.ts` | `.js` | `.tsx`  
`.d.mts` | `.mjs` | `.mts`  
`.d.cts` | `.cjs` | `.cts`  
`.d.*.ts` | `.*` |   
The last row expresses that non-JS files can be typed with the
`allowArbitraryExtensions` compiler option to support cases where the module
system supports importing non-JS files as JavaScript objects. For example, a
file named `styles.css` can be represented by a declaration file named
`styles.d.css.ts`.
> ‚ÄúBut wait! Plenty of declaration files are written by hand, _not_ generated
> by `tsc`. Ever heard of DefinitelyTyped?‚Äù you might object. And it‚Äôs
> true‚Äîhand-writing declaration files, or even moving/copying/renaming them to
> represent outputs of an external build tool, is a dangerous, error-prone
> venture. DefinitelyTyped contributors and authors of typed libraries not
> using `tsc` to generate both JavaScript and declaration files should ensure
> that every JavaScript file has a sibling declaration file with the same name
> and matching extension. Breaking from this structure can lead to false-
> positive TypeScript errors for end users. The npm package
> [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli)
> can help catch and explain these errors before they‚Äôre published.
### Module resolution for bundlers, TypeScript runtimes, and Node.js loaders
So far, we‚Äôve really emphasized the distinction between _input files_ and
_output files_. Recall that when specifying a file extension on a relative
module specifier, TypeScript typically makes you use the _output_ file
extension:
    ts
    // @Filename: src/math.ts
    export function add(a: number, b: number) {
      return a + b;
    }
    // @Filename: src/main.ts
    import { add } from "./math.ts";
    //                  ^^^^^^^^^^^
    // An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.
This restriction applies since TypeScript won‚Äôt rewrite the extension to
`.js`, and if `"./math.ts"` appears in an output JS file, that import won‚Äôt
resolve to another JS file at runtime. TypeScript really wants to prevent you
from generating an unsafe output JS file. But what if there _is_ no output JS
file? What if you‚Äôre in one of these situations:
  * You‚Äôre bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you‚Äôve written to produce a bundle.
  * You‚Äôre running this code directly in a TypeScript runtime like Deno or Bun.
  * You‚Äôre using `ts-node`, `tsx`, or another transpiling loader for Node.
In these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and
`allowImportingTsExtensions` to disable emitting unsafe JavaScript files and
silence the error on `.ts`-extensioned imports.
With or without `allowImportingTsExtensions`, it‚Äôs still important to pick the
most appropriate `moduleResolution` setting for the module resolution host.
For bundlers and the Bun runtime, it‚Äôs `bundler`. These module resolvers were
inspired by Node.js, but didn‚Äôt adopt the strict ESM resolution algorithm that
disables extension searching that Node.js applies to imports. The `bundler`
module resolution setting reflects this, enabling `package.json` `"exports"`
support like `node16` and `nodenext`, while always allowing extensionless
imports. See [_Choosing compiler
options_](/docs/handbook/modules/guides/choosing-compiler-options.html) for
more guidance.
### Module resolution for libraries
When compiling an app, you choose the `moduleResolution` option for a
TypeScript project based on who the module resolution host is. When compiling
a library, you don‚Äôt know where the output code will run, but you‚Äôd like it to
run in as many places as possible. Using `"module": "nodenext"` (along with
the implied [`"moduleResolution":
"nodenext"`](/docs/handbook/modules/reference.html#node16-nodenext)) is the
best bet for maximizing the compatibility of the output JavaScript‚Äôs module
specifiers, since it will force you to comply with Node.js‚Äôs stricter rules
for `import` module resolution. Let‚Äôs look at what would happen if a library
were to compile with `"moduleResolution": "bundler"` (or worse, `"node10"`):
    ts
    export * from "./utils";
Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine
with this code, so `"moduleResolution": "bundler"` doesn‚Äôt complain. Compiled
with `"module": "esnext"`, the output JavaScript for this export statement
will look exactly the same as the input. If that JavaScript were published to
npm, it would be usable by projects that use a bundler, but it would cause an
error when run in Node.js:
    Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js
    Did you mean to import ./utils.js?
On the other hand, if we had written:
    ts
    export * from "./utils.js";
This would produce output that works both in Node.js _and_ in bundlers.
In short, `"moduleResolution": "bundler"` is infectious, allowing code that
only works in bundlers to be produced. Likewise, `"moduleResolution":
"nodenext"` is only checking that the output works in Node.js, but in most
cases, module code that works in Node.js will work in other runtimes and in
bundlers.
Of course, this guidance can only apply in cases where the library ships
outputs from `tsc`. If the library is being bundled _before_ shipping,
`"moduleResolution": "bundler"` may be acceptable. Any build tool that changes
the module format or module specifiers to produce the final build of the
library bears the responsibility of ensuring the safety and compatibility of
the product‚Äôs module code, and `tsc` can no longer contribute to that task,
since it can‚Äôt know what module code will exist at runtime.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/modules-reference/Theory.md) ‚ù§
Contributors to this page:  
AB
Last updated: Sep 16, 2024  
Was this page helpful?
# Namespaces and Modules
This post outlines the various ways to organize your code using modules and
namespaces in TypeScript. We‚Äôll also go over some advanced topics of how to
use namespaces and modules, and address some common pitfalls when using them
in TypeScript.
See the [Modules](/docs/handbook/modules.html) documentation for more
information about ES Modules. See the
[Namespaces](/docs/handbook/namespaces.html) documentation for more
information about TypeScript namespaces.
Note: In _very_ old versions of TypeScript namespaces were called ‚ÄòInternal
Modules‚Äô, these pre-date JavaScript module systems.
## Using Modules
Modules can contain both code and declarations.
Modules also have a dependency on a module loader (such as
CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide
for better code reuse, stronger isolation and better tooling support for
bundling.
It is also worth noting that, for Node.js applications, modules are the
default and **we recommended modules over namespaces in modern code**.
Starting with ECMAScript 2015, modules are native part of the language, and
should be supported by all compliant engine implementations. Thus, for new
projects modules would be the recommended code organization mechanism.
## Using Namespaces
Namespaces are a TypeScript-specific way to organize code.  
Namespaces are simply named JavaScript objects in the global namespace. This
makes namespaces a very simple construct to use. Unlike modules, they can span
multiple files, and can be concatenated using [`outFile`](/tsconfig#outFile).
Namespaces can be a good way to structure your code in a Web Application, with
all dependencies included as `<script>` tags in your HTML page.
Just like all global namespace pollution, it can be hard to identify component
dependencies, especially in a large application.
## Pitfalls of Namespaces and Modules
In this section we‚Äôll describe various common pitfalls in using namespaces and
modules, and how to avoid them.
### `/// <reference>`-ing a module
A common mistake is to try to use the `/// <reference ... />` syntax to refer
to a module file, rather than using an `import` statement. To understand the
distinction, we first need to understand how the compiler can locate the type
information for a module based on the path of an `import` (e.g. the `...` in
`import x from "...";`, `import x = require("...");`, etc.) path.
The compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the
appropriate path. If a specific file could not be found, then the compiler
will look for an _ambient module declaration_. Recall that these need to be
declared in a `.d.ts` file.
  * `myModules.d.ts`
        ts
    // In a .d.ts file or .ts file that is not a module:
    declare module "SomeModule" {
      export function fn(): string;
    }
  * `myOtherModule.ts`
        ts
    /// <reference path="myModules.d.ts" />
    import * as m from "SomeModule";
The reference tag here allows us to locate the declaration file that contains
the declaration for the ambient module. This is how the `node.d.ts` file that
several of the TypeScript samples use is consumed.
### Needless Namespacing
If you‚Äôre converting a program from namespaces to modules, it can be easy to
end up with a file that looks like this:
  * `shapes.ts`
        ts
    export namespace Shapes {
      export class Triangle {
        /* ... */
      }
      export class Square {
        /* ... */
      }
    }
The top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no
reason. This is confusing and annoying for consumers of your module:
  * `shapeConsumer.ts`
        ts
    import * as shapes from "./shapes";
    let t = new shapes.Shapes.Triangle(); // shapes.Shapes?
A key feature of modules in TypeScript is that two different modules will
never contribute names to the same scope. Because the consumer of a module
decides what name to assign it, there‚Äôs no need to proactively wrap up the
exported symbols in a namespace.
To reiterate why you shouldn‚Äôt try to namespace your module contents, the
general idea of namespacing is to provide logical grouping of constructs and
to prevent name collisions. Because the module file itself is already a
logical grouping, and its top-level name is defined by the code that imports
it, it‚Äôs unnecessary to use an additional module layer for exported objects.
Here‚Äôs a revised example:
  * `shapes.ts`
        ts
    export class Triangle {
      /* ... */
    }
    export class Square {
      /* ... */
    }
  * `shapeConsumer.ts`
        ts
    import * as shapes from "./shapes";
    let t = new shapes.Triangle();
### Trade-offs of Modules
Just as there is a one-to-one correspondence between JS files and modules,
TypeScript has a one-to-one correspondence between module source files and
their emitted JS files. One effect of this is that it‚Äôs not possible to
concatenate multiple module source files depending on the module system you
target. For instance, you can‚Äôt use the [`outFile`](/tsconfig#outFile) option
while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it‚Äôs
possible](./release-notes/typescript-1-8.html#concatenate-amd-and-system-
modules-with---outfile) to use [`outFile`](/tsconfig#outFile) when targeting
`amd` or `system`.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Namespaces and
Modules.md) ‚ù§
Contributors to this page:  
DR
OT
MH
B
MF
15+
Last updated: Sep 16, 2024  
Was this page helpful?
# Namespaces
> **A note about terminology:** It‚Äôs important to note that in TypeScript 1.5,
> the nomenclature has changed. ‚ÄúInternal modules‚Äù are now ‚Äúnamespaces‚Äù.
> ‚ÄúExternal modules‚Äù are now simply ‚Äúmodules‚Äù, as to align with [ECMAScript
> 2015](https://www.ecma-international.org/ecma-262/6.0/)‚Äôs terminology,
> (namely that `module X {` is equivalent to the now-preferred `namespace X
> {`).
This post outlines the various ways to organize your code using namespaces
(previously ‚Äúinternal modules‚Äù) in TypeScript. As we alluded in our note about
terminology, ‚Äúinternal modules‚Äù are now referred to as ‚Äúnamespaces‚Äù.
Additionally, anywhere the `module` keyword was used when declaring an
internal module, the `namespace` keyword can and should be used instead. This
avoids confusing new users by overloading them with similarly named terms.
## First steps
Let‚Äôs start with the program we‚Äôll be using as our example throughout this
page. We‚Äôve written a small set of simplistic string validators, as you might
write to check a user‚Äôs input on a form in a webpage or check the format of an
externally-provided data file.
## Validators in a single file
    ts
    interface StringValidator {
      isAcceptable(s: string): boolean;
    }
    let lettersRegexp = /^[A-Za-z]+$/;
    let numberRegexp = /^[0-9]+$/;
    class LettersOnlyValidator implements StringValidator {
      isAcceptable(s: string) {
        return lettersRegexp.test(s);
      }
    }
    class ZipCodeValidator implements StringValidator {
      isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
      }
    }
    // Some samples to try
    let strings = ["Hello", "98052", "101"];
    // Validators to use
    let validators: { [s: string]: StringValidator } = {};
    validators["ZIP code"] = new ZipCodeValidator();
    validators["Letters only"] = new LettersOnlyValidator();
    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${s}' ${isMatch ? "matches" : "does not match"} '${name}'.`);
      }
    }
## Namespacing
As we add more validators, we‚Äôre going to want to have some kind of
organization scheme so that we can keep track of our types and not worry about
name collisions with other objects. Instead of putting lots of different names
into the global namespace, let‚Äôs wrap up our objects into a namespace.
In this example, we‚Äôll move all validator-related entities into a namespace
called `Validation`. Because we want the interfaces and classes here to be
visible outside the namespace, we preface them with `export`. Conversely, the
variables `lettersRegexp` and `numberRegexp` are implementation details, so
they are left unexported and will not be visible to code outside the
namespace. In the test code at the bottom of the file, we now need to qualify
the names of the types when used outside the namespace, e.g.
`Validation.LettersOnlyValidator`.
## Namespaced Validators
    ts
    namespace Validation {
      export interface StringValidator {
        isAcceptable(s: string): boolean;
      }
      const lettersRegexp = /^[A-Za-z]+$/;
      const numberRegexp = /^[0-9]+$/;
      export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
          return lettersRegexp.test(s);
        }
      }
      export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
          return s.length === 5 && numberRegexp.test(s);
        }
      }
    }
    // Some samples to try
    let strings = ["Hello", "98052", "101"];
    // Validators to use
    let validators: { [s: string]: Validation.StringValidator } = {};
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    validators["Letters only"] = new Validation.LettersOnlyValidator();
    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        console.log(
          `"${s}" - ${
            validators[name].isAcceptable(s) ? "matches" : "does not match"
          } ${name}`
        );
      }
    }
## Splitting Across Files
As our application grows, we‚Äôll want to split the code across multiple files
to make it easier to maintain.
## Multi-file namespaces
Here, we‚Äôll split our `Validation` namespace across many files. Even though
the files are separate, they can each contribute to the same namespace and can
be consumed as if they were all defined in one place. Because there are
dependencies between files, we‚Äôll add reference tags to tell the compiler
about the relationships between the files. Our test code is otherwise
unchanged.
##### Validation.ts
    ts
    namespace Validation {
      export interface StringValidator {
        isAcceptable(s: string): boolean;
      }
    }
##### LettersOnlyValidator.ts
    ts
    /// <reference path="Validation.ts" />
    namespace Validation {
      const lettersRegexp = /^[A-Za-z]+$/;
      export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
          return lettersRegexp.test(s);
        }
      }
    }
##### ZipCodeValidator.ts
    ts
    /// <reference path="Validation.ts" />
    namespace Validation {
      const numberRegexp = /^[0-9]+$/;
      export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
          return s.length === 5 && numberRegexp.test(s);
        }
      }
    }
##### Test.ts
    ts
    /// <reference path="Validation.ts" />
    /// <reference path="LettersOnlyValidator.ts" />
    /// <reference path="ZipCodeValidator.ts" />
    // Some samples to try
    let strings = ["Hello", "98052", "101"];
    // Validators to use
    let validators: { [s: string]: Validation.StringValidator } = {};
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    validators["Letters only"] = new Validation.LettersOnlyValidator();
    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        console.log(
          `"${s}" - ${
            validators[name].isAcceptable(s) ? "matches" : "does not match"
          } ${name}`
        );
      }
    }
Once there are multiple files involved, we‚Äôll need to make sure all of the
compiled code gets loaded. There are two ways of doing this.
First, we can use concatenated output using the [`outFile`](/tsconfig#outFile)
option to compile all of the input files into a single JavaScript output file:
    tsc --outFile sample.js Test.ts
The compiler will automatically order the output file based on the reference
tags present in the files. You can also specify each file individually:
    tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
Alternatively, we can use per-file compilation (the default) to emit one
JavaScript file for each input file. If multiple JS files get produced, we‚Äôll
need to use `<script>` tags on our webpage to load each emitted file in the
appropriate order, for example:
##### MyTestPage.html (excerpt)
    html
    <script src="Validation.js" type="text/javascript" />
    <script src="LettersOnlyValidator.js" type="text/javascript" />
    <script src="ZipCodeValidator.js" type="text/javascript" />
    <script src="Test.js" type="text/javascript" />
## Aliases
Another way that you can simplify working with namespaces is to use `import q
= x.y.z` to create shorter names for commonly-used objects. Not to be confused
with the `import x = require("name")` syntax used to load modules, this syntax
simply creates an alias for the specified symbol. You can use these sorts of
imports (commonly referred to as aliases) for any kind of identifier,
including objects created from module imports.
    ts
    namespace Shapes {
      export namespace Polygons {
        export class Triangle {}
        export class Square {}
      }
    }
    import polygons = Shapes.Polygons;
    let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'
Notice that we don‚Äôt use the `require` keyword; instead we assign directly
from the qualified name of the symbol we‚Äôre importing. This is similar to
using `var`, but also works on the type and namespace meanings of the imported
symbol. Importantly, for values, `import` is a distinct reference from the
original symbol, so changes to an aliased `var` will not be reflected in the
original variable.
## Working with Other JavaScript Libraries
To describe the shape of libraries not written in TypeScript, we need to
declare the API that the library exposes. Because most JavaScript libraries
expose only a few top-level objects, namespaces are a good way to represent
them.
We call declarations that don‚Äôt define an implementation ‚Äúambient‚Äù. Typically
these are defined in `.d.ts` files. If you‚Äôre familiar with C/C++, you can
think of these as `.h` files. Let‚Äôs look at a few examples.
## Ambient Namespaces
The popular library D3 defines its functionality in a global object called
`d3`. Because this library is loaded through a `<script>` tag (instead of a
module loader), its declaration uses namespaces to define its shape. For the
TypeScript compiler to see this shape, we use an ambient namespace
declaration. For example, we could begin writing it as follows:
##### D3.d.ts (simplified excerpt)
    ts
    declare namespace D3 {
      export interface Selectors {
        select: {
          (selector: string): Selection;
          (element: EventTarget): Selection;
        };
      }
      export interface Event {
        x: number;
        y: number;
      }
      export interface Base extends Selectors {
        event: Event;
      }
    }
    declare var d3: D3.Base;
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Namespaces.md) ‚ù§
Contributors to this page:  
MH
OT
DR
IO
JB
14+
Last updated: Sep 16, 2024  
Was this page helpful?
# Nightly Builds
A nightly build from the [TypeScript‚Äôs
`main`](https://github.com/Microsoft/TypeScript/tree/main) branch is published
by midnight PST to npm. Here is how you can get it and use it with your tools.
## Using npm
    shell
    npm install -D typescript@next
## Updating your IDE to use the nightly builds
You can also update your editor/IDE to use the nightly drop. You will
typically need to install the package through npm. The rest of this section
mostly assumes `typescript@next` is already installed.
### Visual Studio Code
The VS Code website [has documentation on selecting a workspace version of
TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-
newer-typescript-versions). After installing a nightly version of TypeScript
in your workspace, you can follow directions there, or simply update your
workspace settings in the JSON view. A direct way to do this is to open or
create your workspace‚Äôs `.vscode/settings.json` and add the following
property:
    json
    "typescript.tsdk": "<path to your folder>/node_modules/typescript/lib"
Alternatively, if you simply want to run the nightly editing experience for
JavaScript and TypeScript in Visual Studio Code without changing your
workspace version, you can run the [JavaScript and TypeScript Nightly
Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-
vscode.vscode-typescript-next)
### Sublime Text
Update the `Settings - User` file with the following:
    json
    "typescript_tsdk": "<path to your folder>/node_modules/typescript/lib"
More information is available at the [TypeScript Plugin for Sublime Text
installation documentation](https://github.com/Microsoft/TypeScript-Sublime-
Plugin#installation).
### Visual Studio 2013 and 2015
> Note: Most changes do not require you to install a new version of the VS
> TypeScript plugin.
The nightly build currently does not include the full plugin setup, but we are
working on publishing an installer on a nightly basis as well.
  1. Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1) script.
> Also see our wiki page on [using a custom language service
> file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-
> Studio#using-a-custom-language-service-file).
  2. From a PowerShell command window, run:
For VS 2015:
    VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib
For VS 2013:
    VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib
### IntelliJ IDEA (Mac)
Go to `Preferences` > `Languages & Frameworks` > `TypeScript`:
> TypeScript Version: If you installed with npm:
> `/usr/local/lib/node_modules/typescript/lib`
### IntelliJ IDEA (Windows)
Go to `File` > `Settings` > `Languages & Frameworks` > `TypeScript`:
> TypeScript Version: If you installed with npm:
> `C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib`
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/Nightly Builds.md) ‚ù§
Contributors to this page:  
MH
OT
S
DR
NS
4+
Last updated: Sep 16, 2024  
Was this page helpful?
# Project References
Project references are a new feature in TypeScript 3.0 that allow you to
structure your TypeScript programs into smaller pieces.
By doing this, you can greatly improve build times, enforce logical separation
between components, and organize your code in new and better ways.
We‚Äôre also introducing a new mode for `tsc`, the `--build` flag, that works
hand in hand with project references to enable faster TypeScript builds.
## An Example Project
Let‚Äôs look at a fairly normal program and see how project references can help
us better organize it. Imagine you have a project with two modules,
`converter` and `units`, and a corresponding test file for each:
    /
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ converter.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ units.ts
    ‚îú‚îÄ‚îÄ test/
    ‚îÇ   ‚îú‚îÄ‚îÄ converter-tests.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ units-tests.ts
    ‚îî‚îÄ‚îÄ tsconfig.json
The test files import the implementation files and do some testing:
    ts
    // converter-tests.ts
    import * as converter from "../src/converter";
    assert.areEqual(converter.celsiusToFahrenheit(0), 32);
Previously, this structure was rather awkward to work with if you used a
single tsconfig file:
  * It was possible for the implementation files to import the test files
  * It wasn‚Äôt possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don‚Äôt want
  * Changing just the _internals_ in the implementation files required _typechecking_ the tests again, even though this wouldn‚Äôt ever cause new errors
  * Changing just the tests required typechecking the implementation again, even if nothing changed
You could use multiple tsconfig files to solve _some_ of those problems, but
new ones would appear:
  * There‚Äôs no built-in up-to-date checking, so you end up always running `tsc` twice
  * Invoking `tsc` twice incurs more startup time overhead
  * `tsc -w` can‚Äôt run on multiple config files at once
Project references can solve all of these problems and more.
## What is a Project Reference?
`tsconfig.json` files have a new top-level property,
[`references`](/tsconfig#references). It‚Äôs an array of objects that specifies
projects to reference:
    js
    {
        "compilerOptions": {
            // The usual
        },
        "references": [
            { "path": "../src" }
        ]
    }
The `path` property of each reference can point to a directory containing a
`tsconfig.json` file, or to the config file itself (which may have any name).
When you reference a project, new things happen:
  * Importing modules from a referenced project will instead load its _output_ declaration file (`.d.ts`)
  * If the referenced project produces an [`outFile`](/tsconfig#outFile), the output file `.d.ts` file‚Äôs declarations will be visible in this project
  * Build mode (see below) will automatically build the referenced project if needed
By separating into multiple projects, you can greatly improve the speed of
typechecking and compiling, reduce memory usage when using an editor, and
improve enforcement of the logical groupings of your program.
## `composite`
Referenced projects must have the new [`composite`](/tsconfig#composite)
setting enabled. This setting is needed to ensure TypeScript can quickly
determine where to find the outputs of the referenced project. Enabling the
[`composite`](/tsconfig#composite) flag changes a few things:
  * The [`rootDir`](/tsconfig#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig` file
  * All implementation files must be matched by an [`include`](/tsconfig#include) pattern or listed in the [`files`](/tsconfig#files) array. If this constraint is violated, `tsc` will inform you which files weren‚Äôt specified
  * [`declaration`](/tsconfig#declaration) must be turned on
## `declarationMap`
We‚Äôve also added support for [declaration source
maps](https://github.com/Microsoft/TypeScript/issues/14479). If you enable
[`declarationMap`](/tsconfig#declarationMap), you‚Äôll be able to use editor
features like ‚ÄúGo to Definition‚Äù and Rename to transparently navigate and edit
code across project boundaries in supported editors.
## `prepend` with `outFile`
You can also enable prepending the output of a dependency using the `prepend`
option in a reference:
    js
       "references": [
           { "path": "../utils", "prepend": true }
       ]
Prepending a project will include the project‚Äôs output above the output of the
current project. All output files (`.js`, `.d.ts`, `.js.map`, `.d.ts.map`)
will be emitted correctly.
`tsc` will only ever use existing files on disk to do this process, so it‚Äôs
possible to create a project where a correct output file can‚Äôt be generated
because some project‚Äôs output would be present more than once in the resulting
file. For example:
    txt
       A
      ^ ^
     /   \
    B     C
     ^   ^
      \ /
       D
It‚Äôs important in this situation to not prepend at each reference, because
you‚Äôll end up with two copies of `A` in the output of `D` \- this can lead to
unexpected results.
## Caveats for Project References
Project references have a few trade-offs you should be aware of.
Because dependent projects make use of `.d.ts` files that are built from their
dependencies, you‚Äôll either have to check in certain build outputs _or_ build
a project after cloning it before you can navigate the project in an editor
without seeing spurious errors.
When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory
`.d.ts` generation process that should be able to mitigate this, but it has
some perf implications. For very large composite projects you might want to
disable this using [disableSourceOfProjectReferenceRedirect
option](/tsconfig#disableSourceOfProjectReferenceRedirect).
Additionally, to preserve compatibility with existing build workflows, `tsc`
will _not_ automatically build dependencies unless invoked with the `--build`
switch. Let‚Äôs learn more about `--build`.
## Build Mode for TypeScript
A long-awaited feature is smart incremental builds for TypeScript projects. In
3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry
point for `tsc` that behaves more like a build orchestrator than a simple
compiler.
Running `tsc --build` (`tsc -b` for short) will do the following:
  * Find all referenced projects
  * Detect if they are up-to-date
  * Build out-of-date projects in the correct order
You can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src
test`). Just like `tsc -p`, specifying the config file name itself is
unnecessary if it‚Äôs named `tsconfig.json`.
### `tsc -b` Commandline
You can specify any number of config files:
    shell
     > tsc -b                            # Use the tsconfig.json in the current directory
     > tsc -b src                        # Use src/tsconfig.json
     > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json
Don‚Äôt worry about ordering the files you pass on the commandline - `tsc` will
re-order them if needed so that dependencies are always built first.
There are also some flags specific to `tsc -b`:
  * [`--verbose`](/tsconfig#verbose): Prints out verbose logging to explain what‚Äôs going on (may be combined with any other flag)
  * `--dry`: Shows what would be done but doesn‚Äôt actually build anything
  * `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)
  * [`--force`](/tsconfig#force): Act as if all projects are out of date
  * `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](/tsconfig#verbose))
## Caveats
Normally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of
syntax or type errors, unless [`noEmitOnError`](/tsconfig#noEmitOnError) is
on. Doing this in an incremental build system would be very bad - if one of
your out-of-date dependencies had a new error, you‚Äôd only see it _once_
because a subsequent build would skip building the now up-to-date project. For
this reason, `tsc -b` effectively acts as if
[`noEmitOnError`](/tsconfig#noEmitOnError) is enabled for all projects.
If you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may
need to run a [`--force`](/tsconfig#force) build after certain source control
operations depending on whether your source control tool preserves timestamps
between the local copy and the remote copy.
## MSBuild
If you have an msbuild project, you can enable build mode by adding
    xml
        <TypeScriptBuildMode>true</TypeScriptBuildMode>
to your proj file. This will enable automatic incremental build as well as
cleaning.
Note that as with `tsconfig.json` / `-p`, existing TypeScript project
properties will not be respected - all settings should be managed using your
tsconfig file.
Some teams have set up msbuild-based workflows wherein tsconfig files have the
same _implicit_ graph ordering as the managed projects they are paired with.
If your solution is like this, you can continue to use `msbuild` with `tsc -p`
along with project references; these are fully interoperable.
## Guidance
### Overall Structure
With more `tsconfig.json` files, you‚Äôll usually want to use [Configuration
file inheritance](/docs/handbook/tsconfig-json.html) to centralize your common
compiler options. This way you can change a setting in one file rather than
having to edit multiple files.
Another good practice is to have a ‚Äúsolution‚Äù `tsconfig.json` file that simply
has [`references`](/tsconfig#references) to all of your leaf-node projects and
sets [`files`](/tsconfig#files) to an empty array (otherwise the solution file
will cause double compilation of files). Note that starting with 3.0, it is no
longer an error to have an empty [`files`](/tsconfig#files) array if you have
at least one `reference` in a `tsconfig.json` file.
This presents a simple entry point; e.g. in the TypeScript repo we simply run
`tsc -b src` to build all endpoints because we list all the subprojects in
`src/tsconfig.json`
You can see these patterns in the TypeScript repo - see
`src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as
key examples.
### Structuring for relative modules
In general, not much is needed to transition a repo using relative modules.
Simply place a `tsconfig.json` file in each subdirectory of a given parent
folder, and add `reference`s to these config files to match the intended
layering of the program. You will need to either set the
[`outDir`](/tsconfig#outDir) to an explicit subfolder of the output folder, or
set the [`rootDir`](/tsconfig#rootDir) to the common root of all project
folders.
### Structuring for outFiles
Layout for compilations using [`outFile`](/tsconfig#outFile) is more flexible
because relative paths don‚Äôt matter as much. One thing to keep in mind is that
you‚Äôll generally want to not use `prepend` until the ‚Äúlast‚Äù project - this
will improve build times and reduce the amount of I/O needed in any given
build. The TypeScript repo itself is a good reference here - we have some
‚Äúlibrary‚Äù projects and some ‚Äúendpoint‚Äù projects; ‚Äúendpoint‚Äù projects are kept
as small as possible and pull in only the libraries they need.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-config/Project
References.md) ‚ù§
Contributors to this page:  
MH
OT
RC
G
MF
20+
Last updated: Sep 16, 2024  

Was this page helpful?
# Symbols
Starting with ECMAScript 2015, `symbol` is a primitive data type, just like
`number` and `string`.
`symbol` values are created by calling the `Symbol` constructor.
    ts
    let sym1 = Symbol();
    let sym2 = Symbol("key"); // optional string key
Symbols are immutable, and unique.
    ts
    let sym2 = Symbol("key");
    let sym3 = Symbol("key");
    sym2 === sym3; // false, symbols are unique
Just like strings, symbols can be used as keys for object properties.
    ts
    const sym = Symbol();
    let obj = {
      [sym]: "value",
    };
    console.log(obj[sym]); // "value"
Symbols can also be combined with computed property declarations to declare
object properties and class members.
    ts
    const getClassNameSymbol = Symbol();
    class C {
      [getClassNameSymbol]() {
        return "C";
      }
    }
    let c = new C();
    let className = c[getClassNameSymbol](); // "C"
## `unique symbol`
To enable treating symbols as unique literals a special type `unique symbol`
is available. `unique symbol` is a subtype of `symbol`, and are produced only
from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations.
This type is only allowed on `const` declarations and `readonly static`
properties, and in order to reference a specific unique symbol, you‚Äôll have to
use the `typeof` operator. Each reference to a unique symbol implies a
completely unique identity that‚Äôs tied to a given declaration.
    ts
    declare const sym1: unique symbol;
    // sym2 can only be a constant reference.
    let sym2: unique symbol = Symbol();
    A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.
    // Works - refers to a unique symbol, but its identity is tied to 'sym1'.
    let sym3: typeof sym1 = sym1;
    // Also works.
    class C {
      static readonly StaticSymbol: unique symbol = Symbol();
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYMCYBQATSAYwBsBDaSUIuAO0QBdREBPAWzVQFdaBLARy5VWbAEZwSAbly4QzdtmplaoOiRahRVMtTqNlTSgDMYkWkUgA6XCUhMR2bn0HD24kqAC8oAMpuJABQAlNKyYADqCADWiKAAtKDGMLEMcKA6PAJC8mISADSaXEy8DLG8hLQMJRq8KbyQ+KCpoADkImgt1rb27BioDCwADpBwRjloXuOhcgCCJIhpAO7RiNakZIixAMKgAN64oMwMZFVEiZBk+GoaPsenfrkkTlmuj5MP7sHSAL5AA)
Because each `unique symbol` has a completely separate identity, no two
`unique symbol` types are assignable or comparable to each other.
    ts
    const sym2 = Symbol();
    const sym3 = Symbol();
    if (sym2 === sym3) {
    This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.
      // ...
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqIgJ4C2aoAvKAMq0BGcANgBQCUA3IRLlKtDIxbsufQXgCWAM1DdqdRgyaqMvUAG88oUCFAA6M3gC+QA)
## Well-known Symbols
In addition to user-defined symbols, there are well-known built-in symbols.
Built-in symbols are used to represent internal language behaviors.
Here is a list of well-known symbols:
### `Symbol.asyncIterator`
A method that returns async iterator for an object, compatible to be used with
for await..of loop.
### `Symbol.hasInstance`
A method that determines if a constructor object recognizes an object as one
of the constructor‚Äôs instances. Called by the semantics of the instanceof
operator.
### `Symbol.isConcatSpreadable`
A Boolean value indicating that an object should be flattened to its array
elements by Array.prototype.concat.
### `Symbol.iterator`
A method that returns the default iterator for an object. Called by the
semantics of the for-of statement.
### `Symbol.match`
A regular expression method that matches the regular expression against a
string. Called by the `String.prototype.match` method.
### `Symbol.replace`
A regular expression method that replaces matched substrings of a string.
Called by the `String.prototype.replace` method.
### `Symbol.search`
A regular expression method that returns the index within a string that
matches the regular expression. Called by the `String.prototype.search`
method.
### `Symbol.species`
A function valued property that is the constructor function that is used to
create derived objects.
### `Symbol.split`
A regular expression method that splits a string at the indices that match the
regular expression. Called by the `String.prototype.split` method.
### `Symbol.toPrimitive`
A method that converts an object to a corresponding primitive value. Called by
the `ToPrimitive` abstract operation.
### `Symbol.toStringTag`
A String value that is used in the creation of the default string description
of an object. Called by the built-in method `Object.prototype.toString`.
### `Symbol.unscopables`
An Object whose own property names are property names that are excluded from
the ‚Äòwith‚Äô environment bindings of the associated objects.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Symbols.md) ‚ù§
Contributors to this page:  
MH
OT
GB
MF
MN
9+
Last updated: Sep 16, 2024  
Was this page helpful?
# Triple-Slash Directives
Triple-slash directives are single-line comments containing a single XML tag.
The contents of the comment are used as compiler directives.
Triple-slash directives are **only** valid at the top of their containing
file. A triple-slash directive can only be preceded by single or multi-line
comments, including other triple-slash directives. If they are encountered
following a statement or a declaration they are treated as regular single-line
comments, and hold no special meaning.
## `/// <reference path="..." />`
The `/// <reference path="..." />` directive is the most common of this group.
It serves as a declaration of _dependency_ between files.
Triple-slash references instruct the compiler to include additional files in
the compilation process.
They also serve as a method to order the output when using
[`out`](/tsconfig#out) or [`outFile`](/tsconfig#outFile). Files are emitted to
the output file location in the same order as the input after preprocessing
pass.
### Preprocessing input files
The compiler performs a preprocessing pass on input files to resolve all
triple-slash reference directives. During this process, additional files are
added to the compilation.
The process starts with a set of _root files_ ; these are the file names
specified on the command-line or in the [`files`](/tsconfig#files) list in the
`tsconfig.json` file. These root files are preprocessed in the same order they
are specified. Before a file is added to the list, all triple-slash references
in it are processed, and their targets included. Triple-slash references are
resolved in a depth-first manner, in the order they have been seen in the
file.
A triple-slash reference path is resolved relative to the containing file, if
a relative path is used.
### Errors
It is an error to reference a file that does not exist. It is an error for a
file to have a triple-slash reference to itself.
### Using `--noResolve`
If the compiler flag [`noResolve`](/tsconfig#noResolve) is specified, triple-
slash references are ignored; they neither result in adding new files, nor
change the order of the files provided.
## `/// <reference types="..." />`
Similar to a `/// <reference path="..." />` directive, which serves as a
declaration of _dependency_ , a `/// <reference types="..." />` directive
declares a dependency on a package.
The process of resolving these package names is similar to the process of
resolving module names in an `import` statement. An easy way to think of
triple-slash-reference-types directives are as an `import` for declaration
packages.
For example, including `/// <reference types="node" />` in a declaration file
declares that this file uses names declared in `@types/node/index.d.ts`; and
thus, this package needs to be included in the compilation along with the
declaration file.
Use these directives only when you‚Äôre authoring a `d.ts` file by hand.
For declaration files generated during compilation, the compiler will
automatically add `/// <reference types="..." />` for you; A `/// <reference
types="..." />` in a generated declaration file is added _if and only if_ the
resulting file uses any declarations from the referenced package.
For declaring a dependency on an `@types` package in a `.ts` file, use
[`types`](/tsconfig#types) on the command line or in your `tsconfig.json`
instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json`
files](/docs/handbook/tsconfig-json.html#types-typeroots-and-types) for more
details.
## `/// <reference lib="..." />`
This directive allows a file to explicitly include an existing built-in _lib_
file.
Built-in _lib_ files are referenced in the same fashion as the
[`lib`](/tsconfig#lib) compiler option in _tsconfig.json_ (e.g. use
`lib="es2015"` and not `lib="lib.es2015.d.ts"`, etc.).
For declaration file authors who rely on built-in types, e.g. DOM APIs or
built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-
reference lib directives are recommended. Previously these .d.ts files had to
add forward/duplicate declarations of such types.
For example, adding `/// <reference lib="es2017.string" />` to one of the
files in a compilation is equivalent to compiling with `--lib es2017.string`.
    ts
    /// <reference lib="es2017.string" />
    "foo".padStart(4);
## `/// <reference no-default-lib="true"/>`
This directive marks a file as a _default library_. You will see this comment
at the top of `lib.d.ts` and its different variants.
This directive instructs the compiler to _not_ include the default library
(i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing
[`noLib`](/tsconfig#noLib) on the command line.
Also note that when passing
[`skipDefaultLibCheck`](/tsconfig#skipDefaultLibCheck), the compiler will only
skip checking files with `/// <reference no-default-lib="true"/>`.
## `/// <amd-module />`
By default AMD modules are generated anonymous. This can lead to problems when
other tools are used to process the resulting modules, such as bundlers (e.g.
`r.js`).
The `amd-module` directive allows passing an optional module name to the
compiler:
##### amdModule.ts
    ts
    /// <amd-module name="NamedModule"/>
    export class C {}
Will result in assigning the name `NamedModule` to the module as part of
calling the AMD `define`:
##### amdModule.js
    js
    define("NamedModule", ["require", "exports"], function (require, exports) {
      var C = (function () {
        function C() {}
        return C;
      })();
      exports.C = C;
    });
## `/// <amd-dependency />`
> **Note** : this directive has been deprecated. Use `import "moduleName";`
> statements instead.
`/// <amd-dependency path="x" />` informs the compiler about a non-TS module
dependency that needs to be injected in the resulting module‚Äôs require call.
The `amd-dependency` directive can also have an optional `name` property; this
allows passing an optional name for an amd-dependency:
    ts
    /// <amd-dependency path="legacy/moduleA" name="moduleA"/>
    declare var moduleA: MyType;
    moduleA.callStuff();
Generated JS code:
    js
    define(["require", "exports", "legacy/moduleA"], function (
      require,
      exports,
      moduleA
    ) {
      moduleA.callStuff();
    });
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Triple-Slash
Directives.md) ‚ù§
Contributors to this page:  
MH
OT
JM
JB
GS
9+
Last updated: Sep 16, 2024  
Was this page helpful?
# What is a tsconfig.json
## Overview
The presence of a `tsconfig.json` file in a directory indicates that the
directory is the root of a TypeScript project. The `tsconfig.json` file
specifies the root files and the compiler options required to compile the
project.
JavaScript projects can use a `jsconfig.json` file instead, which acts almost
the same but has some JavaScript-related compiler flags enabled by default.
A project is compiled in one of the following ways:
## Using `tsconfig.json` or `jsconfig.json`
  * By invoking tsc with no input files, in which case the compiler searches for the `tsconfig.json` file starting in the current directory and continuing up the parent directory chain.
  * By invoking tsc with no input files and a `--project` (or just `-p`) command line option that specifies the path of a directory containing a `tsconfig.json` file, or a path to a valid `.json` file containing the configurations.
When input files are specified on the command line, `tsconfig.json` files are
ignored.
## Examples
Example `tsconfig.json` files:
  * Using the [`files`](/tsconfig#files) property
        {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[removeComments](https://www.typescriptlang.org/tsconfig#removeComments)": true,
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true,
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
      },
      "[files](https://www.typescriptlang.org/tsconfig#files)": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "emitter.ts",
        "program.ts",
        "commandLineParser.ts",
        "tsc.ts",
        "diagnosticInformationMap.generated.ts"
      ]
    }
  * Using the [`include`](/tsconfig#include) and [`exclude`](/tsconfig#exclude) properties
        {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[module](https://www.typescriptlang.org/tsconfig#module)": "system",
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[removeComments](https://www.typescriptlang.org/tsconfig#removeComments)": true,
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true,
        "[outFile](https://www.typescriptlang.org/tsconfig#outFile)": "../../built/local/tsc.js",
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true
      },
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["**/*.spec.ts"]
    }
## TSConfig Bases
Depending on the JavaScript runtime environment which you intend to run your
code in, there may be a base configuration which you can use at
[github.com/tsconfig/bases](https://github.com/tsconfig/bases/). These are
`tsconfig.json` files which your project extends from which simplifies your
`tsconfig.json` by handling the runtime support.
For example, if you were writing a project which uses Node.js version 12 and
above, then you could use the npm module
[`@tsconfig/node12`](https://www.npmjs.com/package/@tsconfig/node12):
    {
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "@tsconfig/node12/tsconfig.json",
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums)": true
      },
      "[include](https://www.typescriptlang.org/tsconfig#include)": ["src/**/*"],
      "[exclude](https://www.typescriptlang.org/tsconfig#exclude)": ["**/*.spec.ts"]
    }
This lets your `tsconfig.json` focus on the unique choices for your project,
and not all of the runtime mechanics. There are a few tsconfig bases already,
and we‚Äôre hoping the community can add more for different environments.
## Details
The `"compilerOptions"` property can be omitted, in which case the compiler‚Äôs
defaults are used. See our full list of supported [Compiler
Options](/tsconfig).
## TSConfig Reference
To learn more about the hundreds of configuration options in the [TSConfig
Reference](/tsconfig).
## Schema
The `tsconfig.json` Schema can be found at [the JSON Schema
Store](http://json.schemastore.org/tsconfig).
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/project-
config/tsconfig.json.md) ‚ù§
Contributors to this page:  
OT
JB
L‚ò∫
AG
CB
3+
Last updated: Sep 16, 2024  
Was this page helpful?
# Type Checking JavaScript Files
Here are some notable differences on how checking works in `.js` files
compared to `.ts` files.
## Properties are inferred from assignments in class bodies
ES2015 does not have a means for declaring properties on classes. Properties
are dynamically assigned, just like object literals.
In a `.js` file, the compiler infers properties from property assignments
inside the class body. The type of a property is the type given in the
constructor, unless it‚Äôs not defined there, or the type in the constructor is
undefined or null. In that case, the type is the union of the types of all the
right-hand values in these assignments. Properties defined in the constructor
are always assumed to exist, whereas ones defined just in methods, getters, or
setters are considered optional.
    js
    class C {
      constructor() {
        this.constructorOnly = 0;
        this.constructorUnknown = undefined;
      }
      method() {
        this.constructorOnly = false;
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.
        this.constructorUnknown = "plunkbat"; // ok, constructorUnknown is string | undefined
        this.methodOnly = "ok"; // ok, but methodOnly could also be undefined
      }
      method2() {
        this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQg6AEsUAOl4DhYidgDyfWgE9QAXlAAGANzzuS1Rv5DR4ggFU+CPngDufM6AifAAmsABmynywwTbcAL7yALawSnjBMnIKiirqms46BAbGAWH0tCiwsQr2uU7artgeXr7+5gBEAA60QQgARvSCbVagmHgIADQ8dS66Td5+oKqgzpEA5qAAPoEh4ZHRttkOyanBRSbtY0MjYGOTvSKCoMfQaWdTIrTBoGUoeKC9sG2oQiUWC8gS3GeaVIGU4WRqaihp0M50Uokq12+5Twk1uTxSL2RxgA5MxBEYOoClis+Ostr08HhaLB6P4tkFgXswfE0HEgA)
If properties are never set in the class body, they are considered unknown. If
your class has properties that are only read from, add and then annotate a
declaration in the constructor with JSDoc to specify the type. You don‚Äôt even
have to give a value if it will be initialized later:
    js
    class C {
      constructor() {
        /** @type {number | undefined} */
        this.prop = undefined;
        /** @type {number | undefined} */
        this.count;
      }
    }
    let c = new C();
    c.prop = 0; // OK
    c.count = "string";
    Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQwAFRKIggJ4AHWBz4iAtgCMcoAD6gRfACawAZgEs+sKwF9QS4PO6Do9lADpNfE1QAF4LaztHZwBuL0UVNS0ddj0jE3NLGwcnV3dPBVAfP39eS0E47hc0arRaWEEeMNAnAHdWGTjIQODmgAYYxTAAeQBpGlK8cuaAIiFsRwBzGZigA)
## Constructor functions are equivalent to classes
Before ES2015, JavaScript used constructor functions instead of classes. The
compiler supports this pattern and understands constructor functions as
equivalent to ES2015 classes. The property inference rules described above
work exactly the same way.
    js
    function C() {
      this.constructorOnly = 0;
      this.constructorUnknown = undefined;
    }
    C.prototype.method = function () {
      this.constructorOnly = false;
    Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.
      this.constructorUnknown = "plunkbat"; // OK, the type is string | undefined
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgDYAOAZjOtNLQDMBXAO0gBcBLPN0AMIAKAJSgA3mlChO0bigB0kPik7YWXAgHk2AGwCeoALygADAG4pMuYuVtV6zdgCqbBGzwB3fifYATWCZuNlg-SwBfNAEFAAd8TjxOfRjYBQBbWFk8P2NQVg4ePlBRCStZeSUVNQ0E7B0DXKYAQ10UWEtpctsqx1rXdy8fUAAiGN12BAAjJs5h81BMLQBpABprWBlkjflQB2CAc1AAH1B-QODQtHDzIA)
## CommonJS modules are supported
In a `.js` file, TypeScript understands the CommonJS module format.
Assignments to `exports` and `module.exports` are recognized as export
declarations. Similarly, `require` function calls are recognized as module
imports. For example:
    js
    // same as `import module "fs"`
    const fs = require("fs");
    // same as `export function readFile`
    module.exports.readFile = function (f) {
      return fs.readFileSync(f);
    };
The module support in JavaScript is much more syntactically forgiving than
TypeScript‚Äôs module support. Most combinations of assignments and declarations
are supported.
## Classes, functions, and object literals are namespaces
Classes are namespaces in `.js` files. This can be used to nest classes, for
example:
    js
    class C {}
    C.D = class {};
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8C+AoWA6AItAvNUkMyA3EA)
And, for pre-ES2015 code, it can be used to simulate static methods:
    js
    function Outer() {
      this.y = 2;
    }
    Outer.Inner = function () {
      this.yy = 2;
    };
    Outer.Inner();
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAeRFApgJwBQEpEDeAUIolABYwDOAdAJ6IC8iATANxEC+RRqGmNAJJgwWJolCRYCRHkIkylWnQbN2XDrzRYhIrHjZA)
It can also be used to create simple namespaces:
    js
    var ns = {};
    ns.C = class {};
    ns.func = function () {};
    ns;
    [Try](https://www.typescriptlang.org/play/#code/G4QwTgBAdgzhC8EDeBfA3AKFgOgMIIgGMAbEGOVTHAMwFcpCC6GAXASwHsoIAKASmToMWGGiA)
Other variants are allowed as well:
    js
    // IIFE
    var ns = (function (n) {
      return n || {};
    })();
    ns.CONST = 1;
    // defaulting to global
    var assign =
      assign ||
      function () {
        // code goes here
      };
    assign.extra = 1;
    [Try](https://www.typescriptlang.org/play/#code/PTAEElwMQUQKAG4EMBOoB2BnUBeUAKAMwFd0BjAFwEsB7dA9ASlAG85RQUBTC4le+gB9BrAL4BuOKMb5GkrADoAwgHkAcgGUAKrlABGSXBCgAJl0JJiAG2roA5qAo1QdqzQBGSK4lSgkmTCo7ehx2PwCgoUEwknJqOgJmNg4OYzIaMxcaLmwACy5uMIk4f0DghS4ADwoUJF0DIA)
## Object literals are open-ended
In a `.ts` file, an object literal that initializes a variable declaration
gives its type to the declaration. No new members can be added that were not
specified in the original literal. This rule is relaxed in a `.js` file;
object literals have an open-ended type (an index signature) that allows
adding and looking up properties that were not defined originally. For
instance:
    js
    var obj = { a: 1 };
    obj.b = 2; // Allowed
    [Try](https://www.typescriptlang.org/play/#code/G4QwTgBA9gRgVhAvBA3hEAuCBGCBfAbgChY4A6GJCAJgIgHp6IBBAG1agHcBTAEyA)
Object literals behave as if they have an index signature `[x:string]: any`
that allows them to be treated as open maps instead of closed objects.
Like other special JS checking behaviors, this behavior can be changed by
specifying a JSDoc type for the variable. For example:
    js
    /** @type {{a: number}} */
    var obj = { a: 1 };
    obj.b = 2;
    Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZyBODAKlogBcBPAB1lAG9OBDEgOwCuAWwBGOAL4TQtYGgBuPbKDyiAVqAC8XUH1ABGUBIDcaVWoB0orWWNA)
## null, undefined, and empty array initializers are of type any or any[]
Any variable, parameter or property that is initialized with null or undefined
will have type any, even if strict null checks is turned on. Any variable,
parameter or property that is initialized with [] will have type any[], even
if strict null checks is turned on. The only exception is for properties that
have multiple initializers as described above.
    js
    function Foo(i = null) {
      if (!i) i = 1;
      var j = undefined;
      j = 2;
      this.l = [];
    }
    var foo = new Foo();
    foo.l.push(foo.i);
    foo.l.push("end");
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAMTnAFDRBeRYQA2BAlIgN4BQiiMwi6AhDKVrgIwDcViAbgIYAnRACscicABMApsBhgpErtVG4ATEsRQAFjADOAOgJiA2gF0uAXwoV+Q4GjHyA7ijTpiXe3EP6ADiF0tdC99Zk80H39A9AAiKTAJGI8gA)
## Function parameters are optional by default
Since there is no way to specify optionality on parameters in pre-ES2015
JavaScript, all function parameters in `.js` file are considered optional.
Calls with fewer arguments than the declared number of parameters are allowed.
It is important to note that it is an error to call a function with too many
arguments.
For instance:
    js
    function bar(a, b) {
      console.log(a + " " + b);
    }
    bar(1); // OK, second argument considered optional
    bar(1, 2);
    bar(1, 2, 3); // Error, too many arguments
    Expected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEEUBcBOBLSbALlADMBDAGxVgzHFl1wHtcVSB2ABm4DZQPfqABMAVjEAWNGQCuAOyL4W80ACMKuABQUANOoCUoAN5pQoSCpQsqsAHRUWAcx2gA1KABEX94YDcaAC+aGga2gCMBn6gmADyANL6tJbyACagmk6yALaw8tgWVvipTLDpLAAO2Mry1KGaWuH6IlH1Ec36AMxRMWAAosxs+tgsLKDZFPIAnhm4Wbn5KEA)
JSDoc annotated functions are excluded from this rule. Use JSDoc optional
parameter syntax (`[` `]`) to express optionality. e.g.:
    js
    /**
     * @param {string} [somebody] - Somebody's name.
     */
    function sayHello(somebody) {
      if (!somebody) {
        somebody = "John Doe";
      }
      console.log("Hello " + somebody);
    }
    sayHello();
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwM4BdkCWAdgOYC+kA2tgPZoCmARjQCYCeAupALSQDKdJqzYBybJCLp6AOighg4AGYBXIgGNcBGkUjZEbABL0ANsZoAKWg2bsAlFiiQCiyOYCEVoXYeRfuwTZskAC8kABEAFI0ABY6ACI09GEA3I5kjmratMYyZiTmYUamNOGQANT+1sK2qengeoYmZuY1QA)
## Var-args parameter declaration inferred from use of `arguments`
A function whose body has a reference to the `arguments` reference is
implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) =>
any`). Use JSDoc var-arg syntax to specify the type of the arguments.
    js
    /** @param {...number} args */
    function sum(/* numbers */) {
      var total = 0;
      for (var i = 0; i < arguments.length; i++) {
        total += arguments[i];
      }
      return total;
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEAcEMCdYFtwG8B0mB2BXJAjAU3gF9wEBzAZ3BGACgAzHLAYwBcBLAey3CrwAKUOFwFiNOgEo09cOABuCcO27tYAG3ABecAAYA3HPCNu8cIKXnOO-QfA2APOXgU8hLOyroNHiuwALe04AahCZVGN5VXUtEN1Kd08qAG1OAF0jeRJjeEJ2HHg+GM0jEiA)
## Unspecified type parameters default to `any`
Since there is no natural syntax for specifying generic type parameters in
JavaScript, an unspecified type parameter defaults to `any`.
### In extends clause
For instance, `React.Component` is defined to have two type parameters,
`Props` and `State`. In a `.js` file, there is no legal way to specify these
in the extends clause. By default the type arguments will be `any`:
    js
    import { Component } from "react";
    class MyComponent extends Component {
      render() {
        this.props.b; // Allowed, since this.props is of type any
      }
    }
Use JSDoc `@augments` to specify the types explicitly. for instance:
    js
    import { Component } from "react";
    /**
     * @augments {Component<{a: number}, State>}
     */
    class MyComponent extends Component {
      render() {
        this.props.b; // Error: b does not exist on {a:number}
      }
    }
### In JSDoc references
An unspecified type argument in JSDoc defaults to any:
    js
    /** @type{Array} */
    var x = [];
    x.push(1); // OK
    x.push("string"); // OK, x is of type Array<any>
    /** @type{Array.<number>} */
    var y = [];
    y.push(1); // OK
    y.push("string"); // Error, string is not assignable to number
    [Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCmBvAggJ3QQ1gX3CMAFABuW64AHuALzgDaAugNxFGUB08ArgM4AWACgCMASmbhgwcAHkA0uy58hAIl7R0ASwB2AcxXjJ0+QBoq4Tb3AB7AGbg4ScBmywAPFm2wAfG1AQYBBQXHA43bW4AWwAjRHRvfEJScnBYWgYWNlglARFDKVkFbJ5ctQ0dfXzpAFFMa3QzdS09Cytta2hwLF5eTV1tLGiAG0QHa3AImLigA)
### In function calls
A call to a generic function uses the arguments to infer the type parameters.
Sometimes this process fails to infer any types, mainly because of lack of
inference sources; in these cases, the type parameters will default to `any`.
For example:
    js
    var p = new Promise((resolve, reject) => {
      reject();
    });
    p; // Promise<any>;
To learn all of the features available in JSDoc, see [the
reference](/docs/handbook/jsdoc-supported-types.html).
### [JS Projects Utilizing TypeScriptHow to add type checking to JavaScript
files using TypeScript](/docs/handbook/intro-to-js-ts.html)
### [JSDoc ReferenceWhat JSDoc does TypeScript-powered JavaScript
support?](/docs/handbook/jsdoc-supported-types.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/javascript/Type Checking
JavaScript Files.md) ‚ù§
Contributors to this page:  
HN
OT
RC
NS
MH
15+
Last updated: Sep 16, 2024  
Was this page helpful?
# Type Compatibility
Type compatibility in TypeScript is based on structural subtyping. Structural
typing is a way of relating types based solely on their members. This is in
contrast with nominal typing. Consider the following code:
    ts
    interface Pet {
      name: string;
    }
    class Dog {
      name: string;
    }
    let pet: Pet;
    // OK, because of structural typing
    pet = new Dog();
In nominally-typed languages like C# or Java, the equivalent code would be an
error because the `Dog` class does not explicitly describe itself as being an
implementer of the `Pet` interface.
TypeScript‚Äôs structural type system was designed based on how JavaScript code
is typically written. Because JavaScript widely uses anonymous objects like
function expressions and object literals, it‚Äôs much more natural to represent
the kinds of relationships found in JavaScript libraries with a structural
type system instead of a nominal one.
## A Note on Soundness
TypeScript‚Äôs type system allows certain operations that can‚Äôt be known at
compile-time to be safe. When a type system has this property, it is said to
not be ‚Äúsound‚Äù. The places where TypeScript allows unsound behavior were
carefully considered, and throughout this document we‚Äôll explain where these
happen and the motivating scenarios behind them.
## Starting out
The basic rule for TypeScript‚Äôs structural type system is that `x` is
compatible with `y` if `y` has at least the same members as `x`. For example
consider the following code involving an interface named `Pet` which has a
`name` property:
    ts
    interface Pet {
      name: string;
    }
    let pet: Pet;
    // dog's inferred type is { name: string; owner: string; }
    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
    pet = dog;
To check whether `dog` can be assigned to `pet`, the compiler checks each
property of `pet` to find a corresponding compatible property in `dog`. In
this case, `dog` must have a member called `name` that is a string. It does,
so the assignment is allowed.
The same rule for assignment is used when checking function call arguments:
    ts
    interface Pet {
      name: string;
    }
    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
    function greet(pet: Pet) {
      console.log("Hello, " + pet.name);
    }
    greet(dog); // OK
Note that `dog` has an extra `owner` property, but this does not create an
error. Only members of the target type (`Pet` in this case) are considered
when checking for compatibility. This comparison process proceeds recursively,
exploring the type of each member and sub-member.
Be aware, however, that object literals [may only specify known
properties](/docs/handbook/2/objects.html#excess-property-checks). For
example, because we have explicitly specified that `dog` is of type `Pet`, the
following code is invalid:
    ts
    let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" }; // Error
## Comparing two functions
While comparing primitive types and object types is relatively
straightforward, the question of what kinds of functions should be considered
compatible is a bit more involved. Let‚Äôs start with a basic example of two
functions that differ only in their parameter lists:
    ts
    let x = (a: number) => 0;
    let y = (b: number, s: string) => 0;
    y = x; // OK
    x = y; // Error
To check if `x` is assignable to `y`, we first look at the parameter list.
Each parameter in `x` must have a corresponding parameter in `y` with a
compatible type. Note that the names of the parameters are not considered,
only their types. In this case, every parameter of `x` has a corresponding
compatible parameter in `y`, so the assignment is allowed.
The second assignment is an error, because `y` has a required second parameter
that `x` does not have, so the assignment is disallowed.
You may be wondering why we allow ‚Äòdiscarding‚Äô parameters like in the example
`y = x`. The reason for this assignment to be allowed is that ignoring extra
function parameters is actually quite common in JavaScript. For example,
`Array#forEach` provides three parameters to the callback function: the array
element, its index, and the containing array. Nevertheless, it‚Äôs very useful
to provide a callback that only uses the first parameter:
    ts
    let items = [1, 2, 3];
    // Don't force these extra parameters
    items.forEach((item, index, array) => console.log(item));
    // Should be OK!
    items.forEach((item) => console.log(item));
Now let‚Äôs look at how return types are treated, using two functions that
differ only by their return type:
    ts
    let x = () => ({ name: "Alice" });
    let y = () => ({ name: "Alice", location: "Seattle" });
    x = y; // OK
    y = x; // Error, because x() lacks a location property
The type system enforces that the source function‚Äôs return type be a subtype
of the target type‚Äôs return type.
### Function Parameter Bivariance
When comparing the types of function parameters, assignment succeeds if either
the source parameter is assignable to the target parameter, or vice versa.
This is unsound because a caller might end up being given a function that
takes a more specialized type, but invokes the function with a less
specialized type. In practice, this sort of error is rare, and allowing this
enables many common JavaScript patterns. A brief example:
    ts
    enum EventType {
      Mouse,
      Keyboard,
    }
    interface Event {
      timestamp: number;
    }
    interface MyMouseEvent extends Event {
      x: number;
      y: number;
    }
    interface MyKeyEvent extends Event {
      keyCode: number;
    }
    function listenEvent(eventType: EventType, handler: (n: Event) => void) {
      /* ... */
    }
    // Unsound, but useful and common
    listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y));
    // Undesirable alternatives in presence of soundness
    listenEvent(EventType.Mouse, (e: Event) =>
      console.log((e as MyMouseEvent).x + "," + (e as MyMouseEvent).y)
    );
    listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>
      console.log(e.x + "," + e.y)) as (e: Event) => void);
    // Still disallowed (clear error). Type safety enforced for wholly incompatible types
    listenEvent(EventType.Mouse, (e: number) => console.log(e));
You can have TypeScript raise errors when this happens via the compiler flag
[`strictFunctionTypes`](/tsconfig#strictFunctionTypes).
### Optional Parameters and Rest Parameters
When comparing functions for compatibility, optional and required parameters
are interchangeable. Extra optional parameters of the source type are not an
error, and optional parameters of the target type without corresponding
parameters in the source type are not an error.
When a function has a rest parameter, it is treated as if it were an infinite
series of optional parameters.
This is unsound from a type system perspective, but from a runtime point of
view the idea of an optional parameter is generally not well-enforced since
passing `undefined` in that position is equivalent for most functions.
The motivating example is the common pattern of a function that takes a
callback and invokes it with some predictable (to the programmer) but unknown
(to the type system) number of arguments:
    ts
    function invokeLater(args: any[], callback: (...args: any[]) => void) {
      /* ... Invoke callback with 'args' ... */
    }
    // Unsound - invokeLater "might" provide any number of arguments
    invokeLater([1, 2], (x, y) => console.log(x + ", " + y));
    // Confusing (x and y are actually required) and undiscoverable
    invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y));
### Functions with overloads
When a function has overloads, each overload in the target type must be
matched by a compatible signature on the source type. This ensures that the
source function can be called in all the same cases as the target function.
## Enums
Enums are compatible with numbers, and numbers are compatible with enums. Enum
values from different enum types are considered incompatible. For example,
    ts
    enum Status {
      Ready,
      Waiting,
    }
    enum Color {
      Red,
      Blue,
      Green,
    }
    let status = Status.Ready;
    status = Color.Green; // Error
## Classes
Classes work similarly to object literal types and interfaces with one
exception: they have both a static and an instance type. When comparing two
objects of a class type, only members of the instance are compared. Static
members and constructors do not affect compatibility.
    ts
    class Animal {
      feet: number;
      constructor(name: string, numFeet: number) {}
    }
    class Size {
      feet: number;
      constructor(numFeet: number) {}
    }
    let a: Animal;
    let s: Size;
    a = s; // OK
    s = a; // OK
### Private and protected members in classes
Private and protected members in a class affect their compatibility. When an
instance of a class is checked for compatibility, if the target type contains
a private member, then the source type must also contain a private member that
originated from the same class. Likewise, the same applies for an instance
with a protected member. This allows a class to be assignment compatible with
its super class, but _not_ with classes from a different inheritance hierarchy
which otherwise have the same shape.
## Generics
Because TypeScript is a structural type system, type parameters only affect
the resulting type when consumed as part of the type of a member. For example,
    ts
    interface Empty<T> {}
    let x: Empty<number>;
    let y: Empty<string>;
    x = y; // OK, because y matches structure of x
In the above, `x` and `y` are compatible because their structures do not use
the type argument in a differentiating way. Changing this example by adding a
member to `Empty<T>` shows how this works:
    ts
    interface NotEmpty<T> {
      data: T;
    }
    let x: NotEmpty<number>;
    let y: NotEmpty<string>;
    x = y; // Error, because x and y are not compatible
In this way, a generic type that has its type arguments specified acts just
like a non-generic type.
For generic types that do not have their type arguments specified,
compatibility is checked by specifying `any` in place of all unspecified type
arguments. The resulting types are then checked for compatibility, just as in
the non-generic case.
For example,
    ts
    let identity = function <T>(x: T): T {
      // ...
    };
    let reverse = function <U>(y: U): U {
      // ...
    };
    identity = reverse; // OK, because (x: any) => any matches (y: any) => any
## Advanced Topics
### Subtype vs Assignment
So far, we‚Äôve used ‚Äúcompatible‚Äù, which is not a term defined in the language
spec. In TypeScript, there are two kinds of compatibility: subtype and
assignment. These differ only in that assignment extends subtype compatibility
with rules to allow assignment to and from `any`, and to and from `enum` with
corresponding numeric values.
Different places in the language use one of the two compatibility mechanisms,
depending on the situation. For practical purposes, type compatibility is
dictated by assignment compatibility, even in the cases of the `implements`
and `extends` clauses.
## `any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never`
assignability
The following table summarizes assignability between some abstract types. Rows
indicate what each is assignable to, columns indicate what is assignable to
them. A ‚Äù‚úì‚Äù indicates a combination that is compatible only when
[`strictNullChecks`](/tsconfig#strictNullChecks) is off.
| any | unknown | object | void | undefined | null | never  
---|---|---|---|---|---|---|---  
any ‚Üí |  | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì | ‚úï  
unknown ‚Üí | ‚úì |  | ‚úï | ‚úï | ‚úï | ‚úï | ‚úï  
object ‚Üí | ‚úì | ‚úì |  | ‚úï | ‚úï | ‚úï | ‚úï  
void ‚Üí | ‚úì | ‚úì | ‚úï |  | ‚úï | ‚úï | ‚úï  
undefined ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì |  | ‚úì | ‚úï  
null ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì |  | ‚úï  
never ‚Üí | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì | ‚úì |   
Reiterating [The Basics](/docs/handbook/2/basic-types.html):
  * Everything is assignable to itself.
  * `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.
  * `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).
  * `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](/tsconfig#strictNullChecks) is off, see table for details).
  * When [`strictNullChecks`](/tsconfig#strictNullChecks) is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.
  * When [`strictNullChecks`](/tsconfig#strictNullChecks) is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Type
Compatibility.md) ‚ù§
Contributors to this page:  
RC
DR
OT
MH
JB
26+
Last updated: Sep 16, 2024  
Was this page helpful?
# Type Inference
In TypeScript, there are several places where type inference is used to
provide type information when there is no explicit type annotation. For
example, in this code
    ts
    let x = 3;
    let x: number
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA)
The type of the `x` variable is inferred to be `number`. This kind of
inference takes place when initializing variables and members, setting
parameter default values, and determining function return types.
In most cases, type inference is straightforward. In the following sections,
we‚Äôll explore some of the nuances in how types are inferred.
## Best common type
When a type inference is made from several expressions, the types of those
expressions are used to calculate a ‚Äúbest common type‚Äù. For example,
    ts
    let x = [0, 1, null];
    let x: (number | null)[]
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA)
To infer the type of `x` in the example above, we must consider the type of
each array element. Here we are given two choices for the type of the array:
`number` and `null`. The best common type algorithm considers each candidate
type, and picks the type that is compatible with all the other candidates.
Because the best common type has to be chosen from the provided candidate
types, there are some cases where types share a common structure, but no one
type is the super type of all candidate types. For example:
    ts
    let zoo = [new Rhino(), new Elephant(), new Snake()];
    let zoo: (Rhino | Elephant | Snake)[]
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35BAF5QAG0qPAB3Ll4BAAoASgAaUE6e8ysbaCHR8cjo2KGAXQNixVAAPQB+IA)
Ideally, we may want `zoo` to be inferred as an `Animal[]`, but because there
is no object that is strictly of type `Animal` in the array, we make no
inference about the array element type. To correct this, explicitly provide
the type when no one type is a super type of all other candidates:
    ts
    let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
    let zoo: Animal[]
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35+NBlXAG0AXVAAXlA2qjwAdy5eAQAKAEoAGlAB4fMrG2hJmbnI6NjJjoNixVAAPQB+IA)
When no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.
## Contextual Typing
Type inference also works in ‚Äúthe other direction‚Äù in some cases in
TypeScript. This is known as ‚Äúcontextual typing‚Äù. Contextual typing occurs
when the type of an expression is implied by its location. For example:
    ts
    window.onmousedown = function (mouseEvent) {
      console.log(mouseEvent.button);
      console.log(mouseEvent.kangaroo);
    Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmIFs4BXRSc-Y0AXlADMHiBjAC6EaoABT0mkAKIA3SMUEBKUAG9coUPxqI4AG0iU9cAOYTGzOQsGUARg0GCaSgNwatO-YeNnJl+YqUANYAhsQmIfBwrrgAvi5AA)
Here, the TypeScript type checker used the type of the `Window.onmousedown`
function to infer the type of the function expression on the right hand side
of the assignment. When it did so, it was able to infer the
[type](https://developer.mozilla.org/docs/Web/API/MouseEvent) of the
`mouseEvent` parameter, which does contain a `button` property, but not a
`kangaroo` property.
This works because window already has `onmousedown` declared in its type:
    ts
    // Declares there is a global variable called 'window'
    declare var window: Window & typeof globalThis;
    // Which is declared as (simplified):
    interface Window extends GlobalEventHandlers {
      // ...
    }
    // Which defines a lot of known handler events
    interface GlobalEventHandlers {
      onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;
      // ...
    }
TypeScript is smart enough to infer types in other contexts as well:
    ts
    window.onscroll = function (uiEvent) {
      console.log(uiEvent.button);
    Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmMQGN4AbR0AXlADMBXYugF0I1QACi6EAogDdIxPgEpQAb1yhQdGojiNIlRnADmoidNmUARlz58acgNy4AvraA)
Based on the fact that the above function is being assigned to
`Window.onscroll`, TypeScript knows that `uiEvent` is a
[UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent), and not a
[MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent) like the
previous example. `UIEvent` objects contain no `button` property, and so
TypeScript will throw an error.
If this function were not in a contextually typed position, the function‚Äôs
argument would implicitly have type `any`, and no error would be issued
(unless you are using the [`noImplicitAny`](/tsconfig#noImplicitAny) option):
    ts
    const handler = function (uiEvent) {
      console.log(uiEvent.button); // <- OK
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFDrSSVagAWZkAJstQE6gBeUgFdI6LKkagAFMNQBRAG7VIWAJSgA3rVCgGTaDwB0yaAHNZC5aqMAjYViyM1AblAhQAHgC0oAPIA0rQAvi5AA)
We can also explicitly give type information to the function‚Äôs argument to
override any contextual type:
    ts
    window.onscroll = function (uiEvent: any) {
      console.log(uiEvent.button); // <- Now, no error is given
    };
    [Try](https://www.typescriptlang.org/play/#code/O4SwdgJg9sB0VgM4GMBOUA2GAEBebAZgK5jIAuIC2AFESAKIBuApmGQFzYCGYAngJTYA3gChs2ZAkSZmsDFADmtBizawARkTJkE-ANzYA9IewAeALTYAcjAA02MFGzNU6VNhCJsCkKpEBfPSA)
However, this code will log `undefined`, since `uiEvent` has no property
called `button`.
Contextual typing applies in many cases. Common cases include arguments to
function calls, right hand sides of assignments, type assertions, members of
object and array literals, and return statements. The contextual type also
acts as a candidate type in best common type. For example:
    ts
    function createZoo(): Animal[] {
      return [new Rhino(), new Elephant(), new Snake()];
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCdD9keH4qUERYPEwxAC1+fgAKAEo0GVcAbQBdd0U26G0NUBGqPAB3Ll4BAYAaUEWV8ysbaE3t5cjo2IGxg2YgA)
In this example, best common type has a set of four candidates: `Animal`,
`Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best
common type algorithm.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Type Inference.md) ‚ù§
Contributors to this page:  
RC
OT
DR
MH
TLAT
12+
Last updated: Sep 16, 2024  
Was this page helpful?
# TypeScript for the New Programmer
Congratulations on choosing TypeScript as one of your first languages ‚Äî you‚Äôre
already making good decisions!
You‚Äôve probably already heard that TypeScript is a ‚Äúflavor‚Äù or ‚Äúvariant‚Äù of
JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is
rather unique among modern programming languages, so learning more about this
relationship will help you understand how TypeScript adds to JavaScript.
## What is JavaScript? A Brief History
JavaScript (also known as ECMAScript) started its life as a simple scripting
language for browsers. At the time it was invented, it was expected to be used
for short snippets of code embedded in a web page ‚Äî writing more than a few
dozen lines of code would have been somewhat unusual. Due to this, early web
browsers executed such code pretty slowly. Over time, though, JS became more
and more popular, and web developers started using it to create interactive
experiences.
Web browser developers responded to this increased JS usage by optimizing
their execution engines (dynamic compilation) and extending what could be done
with it (adding APIs), which in turn made web developers use it even more. On
modern websites, your browser is frequently running applications that span
hundreds of thousands of lines of code. This is the long and gradual growth of
‚Äúthe web‚Äù, starting as a simple network of static pages, and evolving into a
platform for rich _applications_ of all kinds.
More than this, JS has become popular enough to be used outside the context of
browsers, such as implementing JS servers using node.js. The ‚Äúrun anywhere‚Äù
nature of JS makes it an attractive choice for cross-platform development.
There are many developers these days that use _only_ JavaScript to program
their entire stack!
To summarize, we have a language that was designed for quick uses, and then
grew to a full-fledged tool to write applications with millions of lines.
Every language has its own _quirks_ ‚Äî oddities and surprises, and JavaScript‚Äôs
humble beginning makes it have _many_ of these. Some examples:
  * JavaScript‚Äôs equality operator (`==`) _coerces_ its operands, leading to unexpected behavior:
        js
    if ("" == 0) {
      // It is! But why??
    }
    if (1 < x < 3) {
      // True for *any* value of x!
    }
  * JavaScript also allows accessing properties which aren‚Äôt present:
        js
    const obj = { width: 10, height: 15 };
    // Why is this NaN? Spelling is hard!
    const area = obj.width * obj.heigth;
Most programming languages would throw an error when these sorts of errors
occur, some would do so during compilation ‚Äî before any code is running. When
writing small programs, such quirks are annoying but manageable; when writing
applications with hundreds or thousands of lines of code, these constant
surprises are a serious problem.
## TypeScript: A Static Type Checker
We said earlier that some languages wouldn‚Äôt allow those buggy programs to run
at all. Detecting errors in code without running it is referred to as _static
checking_. Determining what‚Äôs an error and what‚Äôs not based on the kinds of
values being operated on is known as static _type_ checking.
TypeScript checks a program for errors before execution, and does so based on
the _kinds of values_ , making it a _static type checker_. For example, the
last example above has an error because of the _type_ of `obj`. Here‚Äôs the
error TypeScript found:
    ts
    const obj = { width: 10, height: 15 };
    const area = obj.width * obj.heigth;
    Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBjOAO0QBdQ4AjAK1AF5QBvUAdwEsATUgC1WwAYANKG6Q2Ac26k+GUAF8A3AWJlQAQ2iQ19CjQB07Lt1AAqXdT2iJPBUA)
### A Typed Superset of JavaScript
How does TypeScript relate to JavaScript, though?
#### Syntax
TypeScript is a language that is a _superset_ of JavaScript: JS syntax is
therefore legal TS. Syntax refers to the way we write text to form a program.
For example, this code has a _syntax_ error because it‚Äôs missing a `)`:
    ts
    let a = (4
    ')' expected.1005')' expected.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQAbSAF1AENQBeUACgBYg)
TypeScript doesn‚Äôt consider any JavaScript code to be an error because of its
syntax. This means you can take any working JavaScript code and put it in a
TypeScript file without worrying about exactly how it is written.
#### Types
However, TypeScript is a _typed_ superset, meaning that it adds rules about
how different kinds of values can be used. The earlier error about
`obj.heigth` was not a _syntax_ error: it is an error of using some kind of
value (a _type_) in an incorrect way.
As another example, this is JavaScript code that you can run in your browser,
and it _will_ log a value:
    js
    console.log(4 / []);
This syntactically-legal program logs `Infinity`. TypeScript, though,
considers division of number by an array to be a nonsensical operation, and
will issue an error:
    ts
    console.log(4 / []);
    The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsGBQBjOAO0TgBtIA6MuAcwAoAWUMAbQF0BKAbiA)
It‚Äôs possible you really _did_ intend to divide a number by an array, perhaps
just to see what happens, but most of the time, though, this is a programming
mistake. TypeScript‚Äôs type checker is designed to allow correct programs
through while still catching as many common errors as possible. (Later, we‚Äôll
learn about settings you can use to configure how strictly TypeScript checks
your code.)
If you move some code from a JavaScript file to a TypeScript file, you might
see _type errors_ depending on how the code is written. These may be
legitimate problems with the code, or TypeScript being overly conservative.
Throughout this guide we‚Äôll demonstrate how to add various TypeScript syntax
to eliminate such errors.
#### Runtime Behavior
TypeScript is also a programming language that preserves the _runtime
behavior_ of JavaScript. For example, dividing by zero in JavaScript produces
`Infinity` instead of throwing a runtime exception. As a principle, TypeScript
**never** changes the runtime behavior of JavaScript code.
This means that if you move code from JavaScript to TypeScript, it is
**guaranteed** to run the same way, even if TypeScript thinks that the code
has type errors.
Keeping the same runtime behavior as JavaScript is a foundational promise of
TypeScript because it means you can easily transition between the two
languages without worrying about subtle differences that might make your
program stop working.
#### Erased Types
Roughly speaking, once TypeScript‚Äôs compiler is done with checking your code,
it _erases_ the types to produce the resulting ‚Äúcompiled‚Äù code. This means
that once your code is compiled, the resulting plain JS code has no type
information.
This also means that TypeScript never changes the _behavior_ of your program
based on the types it inferred. The bottom line is that while you might see
type errors during compilation, the type system itself has no bearing on how
your program works when it runs.
Finally, TypeScript doesn‚Äôt provide any additional runtime libraries. Your
programs will use the same standard library (or external libraries) as
JavaScript programs, so there‚Äôs no additional TypeScript-specific framework to
learn.
## Learning JavaScript and TypeScript
We frequently see the question ‚ÄúShould I learn JavaScript or TypeScript?‚Äú.
The answer is that you can‚Äôt learn TypeScript without learning JavaScript!
TypeScript shares syntax and runtime behavior with JavaScript, so anything you
learn about JavaScript is helping you learn TypeScript at the same time.
There are many, many resources available for programmers to learn JavaScript;
you should _not_ ignore these resources if you‚Äôre writing TypeScript. For
example, there are about 20 times more StackOverflow questions tagged
`javascript` than `typescript`, but _all_ of the `javascript` questions also
apply to TypeScript.
If you find yourself searching for something like ‚Äúhow to sort a list in
TypeScript‚Äù, remember: **TypeScript is JavaScript‚Äôs runtime with a compile-
time type checker**. The way you sort a list in TypeScript is the same way you
do so in JavaScript. If you find a resource that uses TypeScript directly,
that‚Äôs great too, but don‚Äôt limit yourself to thinking you need TypeScript-
specific answers for everyday questions about how to accomplish runtime tasks.
## Next Steps
This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:
  * Learn some of the JavaScript fundamentals, we recommend either:
    * [Microsoft‚Äôs JavaScript Resources](https://developer.microsoft.com/javascript/) or
    * [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)
  * Continue to [TypeScript for JavaScript Programmers](/docs/handbook/typescript-in-5-minutes.html)
  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for the New
Programmer.md) ‚ù§
Contributors to this page:  
OT
EB
XL
NS
AO
8+
Last updated: Sep 16, 2024  
Was this page helpful?
# TypeScript for Functional Programmers
TypeScript began its life as an attempt to bring traditional object-oriented
types to JavaScript so that the programmers at Microsoft could bring
traditional object-oriented programs to the web. As it has developed,
TypeScript‚Äôs type system has evolved to model code written by native
JavaScripters. The resulting system is powerful, interesting and messy.
This introduction is designed for working Haskell or ML programmers who want
to learn TypeScript. It describes how the type system of TypeScript differs
from Haskell‚Äôs type system. It also describes unique features of TypeScript‚Äôs
type system that arise from its modelling of JavaScript code.
This introduction does not cover object-oriented programming. In practice,
object-oriented programs in TypeScript are similar to those in other popular
languages with OO features.
## Prerequisites
In this introduction, I assume you know the following:
  * How to program in JavaScript, the good parts.
  * Type syntax of a C-descended language.
If you need to learn the good parts of JavaScript, read [JavaScript: The Good
Parts](https://shop.oreilly.com/product/9780596517748.do). You may be able to
skip the book if you know how to write programs in a call-by-value lexically
scoped language with lots of mutability and not much else. [R4RS
Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf) is a good example.
[The C++ Programming Language](http://www.stroustrup.com/4th.html) is a good
place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix
types, like so: `x: string` instead of `string x`.
## Concepts not in Haskell
### Built-in types
JavaScript defines 8 built-in types:
Type | Explanation  
---|---  
`Number` | a double-precision IEEE 754 floating point.  
`String` | an immutable UTF-16 string.  
`BigInt` | integers in the arbitrary precision format.  
`Boolean` | `true` and `false`.  
`Symbol` | a unique value usually used as a key.  
`Null` | equivalent to the unit type.  
`Undefined` | also equivalent to the unit type.  
`Object` | similar to records.  
[See the MDN page for more
detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures).
TypeScript has corresponding primitive types for the built-in types:
  * `number`
  * `string`
  * `bigint`
  * `boolean`
  * `symbol`
  * `null`
  * `undefined`
  * `object`
#### Other important TypeScript types
Type | Explanation  
---|---  
`unknown` | the top type.  
`never` | the bottom type.  
object literal | e.g. `{ property: Type }`  
`void` | for functions with no documented return value  
`T[]` | mutable arrays, also written `Array<T>`  
`[T, T]` | tuples, which are fixed-length but mutable  
`(t: T) => U` | functions  
Notes:
  1. Function syntax includes parameter names. This is pretty hard to get used to!
        ts
    let fst: (a: any, b: any) => any = (a, b) => a;
    // or more precisely:
    let fst: <T, U>(a: T, b: U) => T = (a, b) => a;
  2. Object literal type syntax closely mirrors object literal value syntax:
        ts
    let o: { n: number; xs: object[] } = { n: 1, xs: [] };
  3. `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.
#### Boxed types
JavaScript has boxed equivalents of primitive types that contain the methods
that programmers associate with those types. TypeScript reflects this with,
for example, the difference between the primitive type `number` and the boxed
type `Number`. The boxed types are rarely needed, since their methods return
primitives.
    ts
    (1).toExponential();
    // equivalent to
    Number.prototype.toExponential.call(1);
Note that calling a method on a numeric literal requires it to be in
parentheses to aid the parser.
### Gradual typing
TypeScript uses the type `any` whenever it can‚Äôt tell what the type of an
expression should be. Compared to `Dynamic`, calling `any` a type is an
overstatement. It just turns off the type checker wherever it appears. For
example, you can push any value into an `any[]` without marking the value in
any way:
    ts
    // with "noImplicitAny": false in tsconfig.json, anys: any[]
    const anys = [];
    anys.push(1);
    anys.push("oh no");
    anys.push({ anything: "goes" });
    [Try](https://www.typescriptlang.org/play/#code/PTAEHcEsBcAtQEQDsD2BJAtgBwDaQMYwCCSAnggFygBmAhjgM4CmokSo0D+KS1kA5gDoAVgx4AaULTIMq00gG0AugChuSBtCkzQAXlDKA3CvkNBWAK4NYACgCMASmOnzV2whTxUCJyZmvrGwBvbVI4Nn4qBH4UJgYEUABfJyA)
And you can use an expression of type `any` anywhere:
    ts
    anys.map(anys[1]); // oh no, "oh no" is not a function
`any` is contagious, too ‚Äî if you initialize a variable with an expression of
type `any`, the variable has type `any` too.
    ts
    let sepsis = anys[0] + anys[1]; // this could mean anything
To get an error when TypeScript produces an `any`, use `"noImplicitAny":
true`, or `"strict": true` in `tsconfig.json`.
### Structural typing
Structural typing is a familiar concept to most functional programmers,
although Haskell and most MLs are not structurally typed. Its basic form is
pretty simple:
    ts
    // @strict: false
    let o = { x: "hi", extra: 1 }; // ok
    let o2: { x: string } = o; // ok
Here, the object literal `{ x: "hi", extra: 1 }` has a matching literal type
`{ x: string, extra: number }`. That type is assignable to `{ x: string }`
since it has all the required properties and those properties have assignable
types. The extra property doesn‚Äôt prevent assignment, it just makes it a
subtype of `{ x: string }`.
Named types just give a name to a type; for assignability purposes there‚Äôs no
difference between the type alias `One` and the interface type `Two` below.
They both have a property `p: string`. (Type aliases behave differently from
interfaces with respect to recursive definitions and type parameters,
however.)
    ts
    type One = { p: string };
    interface Two {
      p: string;
    }
    class Three {
      p = "Hello";
    }
    let x: One = { p: "hi" };
    let two: Two = x;
    two = new Three();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAHkA7UgXlAG9QjVE9oBLCgc1AF8BuHBzwwAZgEMAxqQAqAdzj0coRs1YdOAnjgkAbMYkShpAC2iRSdJY1C0ARAAlIOnXFuacOHZDygAHqkoaehVQW2M2W14BLx88eVQ5BVpfATik0CpZI1NzAAoASj4gA)
### Unions
In TypeScript, union types are untagged. In other words, they are not
discriminated unions like `data` in Haskell. However, you can often
discriminate types in a union using built-in tags or other properties.
    ts
    function start(
      arg: string | string[] | (() => string) | { s: string }
    ): string {
      // this is super common in JavaScript
      if (typeof arg === "string") {
        return commonCase(arg);
      } else if (Array.isArray(arg)) {
        return arg.map(commonCase).join(",");
      } else if (typeof arg === "function") {
        return commonCase(arg());
      } else {
        return commonCase(arg.s);
      }
      function commonCase(s: string): string {
        // finally, just convert a string to another string
        return s;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZygQwE5QBQChGKYDmAXClBjGEYgD7mXUDaAunYttgJSIC8AfAypEe9AN4oyqRjQC+uLlIrDEY-IgD0GxFAAWMZIgMoQABwCmGRBDgBbWwiNIAUmgBuaAMoRKpqOphgDigATws4IOI+Xl5EACJpYTieNQICDHMoEAwkG3sEAGE0ZHNsYi4AbnVZRHMAGxKjIOwAQQwMNBCAOgM2jpCyjBEU9XTM7KRiLts0U2w8hzAikq4ugCs4Kmw4gBpkqoIa+sbA4LDzCMIh6Ni40EhYBGTVUcQMrJzrO0Xl0uJuSrVWoNcwvNJvcafBaFYp-IZdZCAw64dT3aDwXLfGElbDIJQyRRCahgtJaRDAKhoOp1EI7RBrECoL5gNyWKCEIk0KBwQhgOB6Syc17vCYoA6IeSyIA)
`string`, `Array` and `Function` have built-in type predicates, conveniently
leaving the object type for the `else` branch. It is possible, however, to
generate unions that are difficult to differentiate at runtime. For new code,
it‚Äôs best to build only discriminated unions.
The following types have built-in predicates:
Type | Predicate  
---|---  
string | `typeof s === "string"`  
number | `typeof n === "number"`  
bigint | `typeof m === "bigint"`  
boolean | `typeof b === "boolean"`  
symbol | `typeof g === "symbol"`  
undefined | `typeof undefined === "undefined"`  
function | `typeof f === "function"`  
array | `Array.isArray(a)`  
object | `typeof o === "object"`  
Note that functions and arrays are objects at runtime, but have their own
predicates.
#### Intersections
In addition to unions, TypeScript also has intersections:
    ts
    type Combined = { a: number } & { b: string };
    type Conflicting = { a: number } & { a: string };
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gWwEYEsB2EAmUC8UDeUAhgFxRoCuyEATlAL5QBkBUSZAzsDegOYMBuAFChIsOGgBmAGxQBjYH1ytS5KkloNmKztyX0BQA)
`Combined` has two properties, `a` and `b`, just as if they had been written
as one object literal type. Intersection and union are recursive in case of
conflicts, so `Conflicting.a: number & string`.
### Unit types
Unit types are subtypes of primitive types that contain exactly one primitive
value. For example, the string `"foo"` has the type `"foo"`. Since JavaScript
has no built-in enums, it is common to use a set of well-known strings
instead. Unions of string literal types allow TypeScript to type this pattern:
    ts
    declare function pad(s: string, n: number, direction: "left" | "right"): string;
    pad("hi", 10, "left");
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFBFS4lVnEsAjAAYWk6Rt1A)
When needed, the compiler _widens_ ‚Äî converts to a supertype ‚Äî the unit type
to the primitive type, such as `"foo"` to `string`. This happens when using
mutability, which can hamper some uses of mutable variables:
    ts
    let s = "right";
    pad("hi", 10, s); // error: 'string' is not assignable to '"left" | "right"'
    Argument of type 'string' is not assignable to parameter of type '"left" | "right"'.2345Argument of type 'string' is not assignable to parameter of type '"left" | "right"'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6AA7kEAUKUImbRWDAOYAaUA1QM6AWwBGMaQVZUW7WaABEpSDWa7QAHz2jxAC2MBKVMNESA3HhCgAtF+J1mXj3gGzEKgALwWrNbGrjz8ulasutIAjAAM0oi2zqDuMPDQqADkjmLihaCsiDJwweSIiJEM5EoGoMxwoIX6hsZmEVG6hUA)
Here‚Äôs how the error happens:
  * `"right": "right"`
  * `s: string` because `"right"` widens to `string` on assignment to a mutable variable.
  * `string` is not assignable to `"left" | "right"`
You can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `"left" | "right"`.
    ts
    let s: "left" | "right" = "right";
    pad("hi", 10, s);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFAB6Q-AC05sMgznT+qRmpVJ02QqVZVrgLzvP4g0Sk4ipY4iwAjAAMLGTqukA)
## Concepts similar to Haskell
### Contextual typing
TypeScript has some obvious places where it can infer types, like variable
declarations:
    ts
    let s = "I'm a string!";
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECICSByAthAhtMAnAlgHYDmAhAgNxA)
But it also infers types in a few other places that you may not expect if
you‚Äôve worked with other C-syntax languages:
    ts
    declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];
    let sns = map((n) => n.toString(), [1, 2, 3]);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKRALngY1fIEp4BeO2tQwBnTgG0Aul1Y1JAbgBQEEBnjDUwvoRIMGqHv3ioAdBhwBlDDCyoA5gy7UxARmoAmagGYpcoA)
Here, `n: number` in this example also, despite the fact that `T` and `U` have
not been inferred before the call. In fact, after `[1,2,3]` has been used to
infer `T=number`, the return type of `n => n.toString()` is used to infer
`U=string`, causing `sns` to have the type `string[]`.
Note that inference will work in any order, but intellisense will only work
left-to-right, so TypeScript prefers to declare `map` with the array first:
    ts
    declare function map<T, U>(ts: T[], f: (t: T) => U): U[];
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKDAZwC55yBtAXWsXabtyASngBeOrWHsaPANxA)
Contextual typing also works recursively through object literals, and on unit
types that would otherwise be inferred as `string` or `number`. And it can
infer return types from context:
    ts
    declare function run<T>(thunk: (t: T) => void): T;
    let i: { inference: string } = run((o) => {
      o.inference = "INSERT STATE HERE";
    });
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxjQB4AVAPgAoMALNAawC54qmSBKeAXjPgDccswNqwDcAKAggM8LEwDeM1IhBx0IJgGcMMLKgDm8AL5cCaChRwdu8OWPjwcAOl3LVYBJ3gAiAJIA5AGUAUQAlEngAkgBBEiD4AAlQoK9xQzYRIA)
The type of `o` is determined to be `{ inference: string }` because
  1. Declaration initializers are contextually typed by the declaration‚Äôs type: `{ inference: string }`.
  2. The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.
  3. Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.
And it does so while you are typing, so that after typing `o.`, you get
completions for the property `inference`, along with any other properties
you‚Äôd have in a real program. Altogether, this feature can make TypeScript‚Äôs
inference look a bit like a unifying type inference engine, but it is not.
### Type aliases
Type aliases are mere aliases, just like `type` in Haskell. The compiler will
attempt to use the alias name wherever it was used in the source code, but
does not always succeed.
    ts
    type Size = [number, number];
    let x: Size = [101.1, 999.9];
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyglgL2gXigbQHYFcC2AjCAJwBopt8iBdAbgCgAbCYKADwC5ZEV0BGABh4A6HqQCc4waJpA)
The closest equivalent to `newtype` is a _tagged intersection_ :
    ts
    type FString = string & { __compileTimeOnly: any };
An `FString` is just like a normal string, except that the compiler thinks it
has a property named `__compileTimeOnly` that doesn‚Äôt actually exist. This
means that `FString` can still be assigned to `string`, but not the other way
round.
### Discriminated Unions
The closest equivalent to `data` is a union of types with discriminant
properties, normally called discriminated unions in TypeScript:
    ts
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
Unlike Haskell, the tag, or discriminant, is just a property in each object
type. Each variant has an identical property with a different unit type. This
is still a normal union type; the leading `|` is an optional part of the union
type syntax. You can discriminate the members of the union using normal
JavaScript code:
    ts
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
    function area(s: Shape) {
      if (s.kind === "circle") {
        return Math.PI * s.radius * s.radius;
      } else if (s.kind === "square") {
        return s.x * s.x;
      } else {
        return (s.x * s.y) / 2;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoaABmfCS0wEQA9iRQWhAIABRCsIiQAJR48kRBUEkAdBZkqCgoNPRMzhm48pjawHwMMQCyCMBweQAKAJJQAFRQAnncvIJ9A0M8-AIBmDJQEMwC0Nm5g4XFpdTqmtrUVTVcEPWN47pjg7ozsvOL0NWYtUcNMfln-YMgGQD0UABMV3IZEA)
Note that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.
Also, unlike Haskell, common properties show up in any union, so you can
usefully discriminate multiple members of the union:
    ts
    function height(s: Shape) {
      if (s.kind === "circle") {
        return 2 * s.radius;
      } else {
        // s.kind: "square" | "triangle"
        return s.x;
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoAPSBUAC04bR8wOGhaABmfCS0wEQA9iRQcBBEDnDAABRCsIiQAJR48kRxUIUAdBZkqCgoNPRMzuW48pjawHwMGQBMUABUUAK13LyCAZgyUBDMAtBdmJjB4-XKVuqa2tQK1rb2TmzdXBB9A5u6s7JoMkA)
### Type Parameters
Like most C-descended languages, TypeScript requires declaration of type
parameters:
    ts
    function liftArray<T>(t: T): Array<T> {
      return [t];
    }
There is no case requirement, but type parameters are conventionally single
uppercase letters. Type parameters can also be constrained to a type, which
behaves a bit like type class constraints:
    ts
    function firstish<T extends { length: number }>(t1: T, t2: T): T {
      return t1.length > t2.length ? t1 : t2;
    }
TypeScript can usually infer type arguments from a call based on the type of
the arguments, so type arguments are usually not needed.
Because TypeScript is structural, it doesn‚Äôt need type parameters as much as
nominal systems. Specifically, they are not needed to make a function
polymorphic. Type parameters should only be used to _propagate_ type
information, such as constraining parameters to be the same type:
    ts
    function length<T extends ArrayLike<unknown>>(t: T): number {}
    function length(t: ArrayLike<unknown>): number {}
In the first `length`, T is not necessary; notice that it‚Äôs only referenced
once, so it‚Äôs not being used to constrain the type of the return value or
other parameters.
#### Higher-kinded types
TypeScript does not have higher kinded types, so the following is not legal:
    ts
    function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}
#### Point-free programming
Point-free programming ‚Äî heavy use of currying and function composition ‚Äî is
possible in JavaScript, but can be verbose. In TypeScript, type inference
often fails for point-free programs, so you‚Äôll end up specifying type
parameters instead of value parameters. The result is so verbose that it‚Äôs
usually better to avoid point-free programming.
### Module system
JavaScript‚Äôs modern module syntax is a bit like Haskell‚Äôs, except that any
file with `import` or `export` is implicitly a module:
    ts
    import { value, Type } from "npm-package";
    import { other, Types } from "./local-package";
    import * as prefix from "../lib/third-package";
You can also import commonjs modules ‚Äî modules written using node.js‚Äô module
system:
    ts
    import f = require("single-function-package");
You can export with an export list:
    ts
    export { f };
    function f() {
      return g();
    }
    function g() {} // g is not exported
Or by marking each export individually:
    ts
    export function f() { return g() }
    function g() { }
The latter style is more common but both are allowed, even in the same file.
### `readonly` and `const`
In JavaScript, mutability is the default, although it allows variable
declarations with `const` to declare that the _reference_ is immutable. The
referent is still mutable:
    js
    const a = [1, 2, 3];
    a.push(102); // ):
    a[0] = 101; // D:
TypeScript additionally has a `readonly` modifier for properties.
    ts
    interface Rx {
      readonly x: number;
    }
    let rx: Rx = { x: 1 };
    rx.x = 12; // error
It also ships with a mapped type `Readonly<T>` that makes all properties
`readonly`:
    ts
    interface X {
      x: number;
    }
    let rx: Readonly<X> = { x: 1 };
    rx.x = 12; // error
And it has a specific `ReadonlyArray<T>` type that removes side-affecting
methods and prevents writing to indices of the array, as well as special
syntax for this type:
    ts
    let a: ReadonlyArray<number> = [1, 2, 3];
    let b: readonly number[] = [1, 2, 3];
    a.push(102); // error
    b[0] = 101; // error
You can also use a const-assertion, which operates on arrays and object
literals:
    ts
    let a = [1, 2, 3] as const;
    a.push(102); // error
    a[0] = 101; // error
However, none of these options are the default, so they are not consistently
used in TypeScript code.
### Next Steps
This doc is a high level overview of the syntax and types you would use in
everyday code. From here you should:
  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for Functional
Programmers.md) ‚ù§
Contributors to this page:  
OT
UJ
MF
JRSDS
RC
11+
Last updated: Sep 16, 2024  
Was this page helpful?
# TypeScript for Java/C# Programmers
TypeScript is a popular choice for programmers accustomed to other languages
with static typing, such as C# and Java.
TypeScript‚Äôs type system offers many of the same benefits, such as better code
completion, earlier detection of errors, and clearer communication between
parts of your program. While TypeScript provides many familiar features for
these developers, it‚Äôs worth stepping back to see how JavaScript (and
therefore TypeScript) differ from traditional OOP languages. Understanding
these differences will help you write better JavaScript code, and avoid common
pitfalls that programmers who go straight from C#/Java to TypeScript may fall
into.
## Co-learning JavaScript
If you‚Äôre familiar with JavaScript already but are primarily a Java or C#
programmer, this introductory page can help explain some of the common
misconceptions and pitfalls you might be susceptible to. Some of the ways that
TypeScript models types are quite different from Java or C#, and it‚Äôs
important to keep these in mind when learning TypeScript.
If you‚Äôre a Java or C# programmer that is new to JavaScript in general, we
recommend learning a little bit of JavaScript _without_ types first to
understand JavaScript‚Äôs runtime behaviors. Because TypeScript doesn‚Äôt change
how your code _runs_ , you‚Äôll still have to learn how JavaScript works in
order to write code that actually does something!
It‚Äôs important to remember that TypeScript uses the same _runtime_ as
JavaScript, so any resources about how to accomplish specific runtime behavior
(converting a string to a number, displaying an alert, writing a file to disk,
etc.) will always apply equally well to TypeScript programs. Don‚Äôt limit
yourself to TypeScript-specific resources!
## Rethinking the Class
C# and Java are what we might call _mandatory OOP_ languages. In these
languages, the _class_ is the basic unit of code organization, and also the
basic container of all data _and_ behavior at runtime. Forcing all
functionality and data to be held in classes can be a good domain model for
some problems, but not every domain _needs_ to be represented this way.
### Free Functions and Data
In JavaScript, functions can live anywhere, and data can be passed around
freely without being inside a pre-defined `class` or `struct`. This
flexibility is extremely powerful. ‚ÄúFree‚Äù functions (those not associated with
a class) working over data without an implied OOP hierarchy tend to be the
preferred model for writing programs in JavaScript.
### Static Classes
Additionally, certain constructs from C# and Java such as singletons and
static classes are unnecessary in TypeScript.
## OOP in TypeScript
That said, you can still use classes if you like! Some problems are well-
suited to being solved by a traditional OOP hierarchy, and TypeScript‚Äôs
support for JavaScript classes will make these models even more powerful.
TypeScript supports many common patterns such as implementing interfaces,
inheritance, and static methods.
We‚Äôll cover classes later in this guide.
## Rethinking Types
TypeScript‚Äôs understanding of a _type_ is actually quite different from C# or
Java‚Äôs. Let‚Äôs explore some differences.
### Nominal Reified Type Systems
In C# or Java, any given value or object has one exact type - either `null`, a
primitive, or a known class type. We can call methods like `value.GetType()`
or `value.getClass()` to query the exact type at runtime. The definition of
this type will reside in a class somewhere with some name, and we can‚Äôt use
two classes with similar shapes in lieu of each other unless there‚Äôs an
explicit inheritance relationship or commonly-implemented interface.
These aspects describe a _reified, nominal_ type system. The types we wrote in
the code are present at runtime, and the types are related via their
declarations, not their structures.
### Types as Sets
In C# or Java, it‚Äôs meaningful to think of a one-to-one correspondence between
runtime types and their compile-time declarations.
In TypeScript, it‚Äôs better to think of a type as a _set of values_ that share
something in common. Because types are just sets, a particular value can
belong to _many_ sets at the same time.
Once you start thinking of types as sets, certain operations become very
natural. For example, in C#, it‚Äôs awkward to pass around a value that is
_either_ a `string` or `int`, because there isn‚Äôt a single type that
represents this sort of value.
In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the _union_ of those sets: `string | number`.
TypeScript provides a number of mechanisms to work with types in a set-
theoretic way, and you‚Äôll find them more intuitive if you think of types as
sets.
### Erased Structural Types
In TypeScript, objects are _not_ of a single exact type. For example, if we
construct an object that satisfies an interface, we can use that object where
that interface is expected even though there was no declarative relationship
between the two.
    ts
    interface Pointlike {
      x: number;
      y: number;
    }
    interface Named {
      name: string;
    }
    function logPoint(point: Pointlike) {
      console.log("x = " + point.x + ", y = " + point.y);
    }
    function logName(x: Named) {
      console.log("Hello, " + x.name);
    }
    const obj = {
      x: 0,
      y: 0,
      name: "Origin",
    };
    logPoint(obj);
    logName(obj);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRgDbANYoDeAUMsgB4BcyIArgLYBG0A3KcgJ7V1OvEC+xLNHhJkAOTj0IAE2QkyIKRGoBnMFFABzNoOIxaIBGGDoQybOi0YsACgAOmcNRvhcBAJTz2CM6vTYEAB0llq2AETkyAC8yOHIANTIjlhBUUnhADScMXGJyU5gQRweusT6hsam5qGS0rZUEsoyXgrIviD+gSFWEQASENiW2fFJ5EFK0qUC5R3qyOiMAFa5bY0ADJnsXMib7JMqcQDymlqgWQJsxKGuYLaLS9O1yvfLpUA)
TypeScript‚Äôs type system is _structural_ , not nominal: We can use `obj` as a
`Pointlike` because it has `x` and `y` properties that are both numbers. The
relationships between types are determined by the properties they contain, not
whether they were declared with some particular relationship.
TypeScript‚Äôs type system is also _not reified_ : There‚Äôs nothing at runtime
that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is
not present _in any form_ at runtime.
Going back to the idea of _types as sets_ , we can think of `obj` as being a
member of both the `Pointlike` set of values and the `Named` set of values.
### Consequences of Structural Typing
OOP programmers are often surprised by two particular aspects of structural
typing.
#### Empty Types
The first is that the _empty type_ seems to defy expectation:
    ts
    class Empty {}
    function fn(arg: Empty) {
      // do something?
    }
    // No error, but this isn't an 'Empty' ?
    fn({ k: 10 });
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4CgcDMBXAO2GQEsB7Y6fYgCjACcBzALjiTQEpMdpoAekHQAJpWgRK8AKbIAFuWIsA-Dlw5h0AHISZTJpSYAaaACNCyaAvIxbxAORWwNBwhSoH0NXXoZoANYcAIwADNBY3ADcQA)
TypeScript determines if the call to `fn` here is valid by seeing if the
provided argument is a valid `Empty`. It does so by examining the _structure_
of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has _all_ of
the properties that `Empty` does, because `Empty` has no properties.
Therefore, this is a valid call!
This may seem surprising, but it‚Äôs ultimately a very similar relationship to
one enforced in nominal OOP languages. A subclass cannot _remove_ a property
of its base class, because doing so would destroy the natural subtype
relationship between the derived class and its base. Structural type systems
simply identify this relationship implicitly by describing subtypes in terms
of having properties of compatible types.
#### Identical Types
Another frequent source of surprise comes with identical types:
    ts
    class Car {
      drive() {
        // hit the gas
      }
    }
    class Golfer {
      drive() {
        // hit the ball far
      }
    }
    // No error?
    let w: Car = new Golfer();
Again, this isn‚Äôt an error because the _structures_ of these classes are the
same. While this may seem like a potential source of confusion, in practice,
identical classes that shouldn‚Äôt be related are not common.
We‚Äôll learn more about how classes relate to each other in the Classes
chapter.
### Reflection
OOP programmers are accustomed to being able to query the type of any value,
even a generic one:
    csharp
    // C#
    static void LogType<T>() {
        Console.WriteLine(typeof(T).Name);
    }
Because TypeScript‚Äôs type system is fully erased, information about e.g. the
instantiation of a generic type parameter is not available at runtime.
JavaScript does have some limited primitives like `typeof` and `instanceof`,
but remember that these operators are still working on the values as they
exist in the type-erased output code. For example, `typeof (new Car())` will
be `"object"`, not `Car` or `"Car"`.
## Next Steps
This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:
  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for OOPers.md) ‚ù§
Contributors to this page:  
OT
TZ
SP
L
GD
Last updated: Sep 16, 2024  
Was this page helpful?
# TypeScript for JavaScript Programmers
TypeScript stands in an unusual relationship to JavaScript. TypeScript offers
all of JavaScript‚Äôs features, and an additional layer on top of these:
TypeScript‚Äôs type system.
For example, JavaScript provides language primitives like `string` and
`number`, but it doesn‚Äôt check that you‚Äôve consistently assigned these.
TypeScript does.
This means that your existing working JavaScript code is also TypeScript code.
The main benefit of TypeScript is that it can highlight unexpected behavior in
your code, lowering the chance of bugs.
This tutorial provides a brief overview of TypeScript, focusing on its type
system.
## Types by Inference
TypeScript knows the JavaScript language and will generate types for you in
many cases. For example in creating a variable and assigning it to a
particular value, TypeScript will use the value as its type.
    ts
    let helloWorld = "Hello World";
    let helloWorld: string
    [Try](https://www.typescriptlang.org/play/#code/DYUwLgBAFizA9gdXgJ2AEwgXggIgBKwITJrq4DcAUAPQ0QQB6A-EA)
By understanding how JavaScript works, TypeScript can build a type-system that
accepts JavaScript code but has types. This offers a type-system without
needing to add extra characters to make types explicit in your code. That‚Äôs
how TypeScript knows that `helloWorld` is a `string` in the above example.
You may have written JavaScript in Visual Studio Code, and had editor auto-
completion. Visual Studio Code uses TypeScript under the hood to make it
easier to work with JavaScript.
## Defining Types
You can use a wide variety of design patterns in JavaScript. However, some
design patterns make it difficult for types to be inferred automatically (for
example, patterns that use dynamic programming). To cover these cases,
TypeScript supports an extension of the JavaScript language, which offers
places for you to tell TypeScript what the types should be.
For example, to create an object with an inferred type which includes `name:
string` and `id: number`, you can write:
    ts
    const user = {
      name: "Hayes",
      id: 0,
    };
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwFAxmAQwFtEAuGAIgAkCBPRCCgGlxgEsATcgBhYF8A3EA)
You can explicitly describe this object‚Äôs shape using an `interface`
declaration:
    ts
    interface User {
      name: string;
      id: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvkA)
You can then declare that a JavaScript object conforms to the shape of your
new `interface` by using syntax like `: TypeName` after a variable
declaration:
    ts
    const user: User = {
      name: "Hayes",
      id: 0,
    };
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrgD0Q5AFoJCDmAljcCAPYgqyDpigUMWALw4mRUhQBEACTgBPCOiMAaJqwoAGO-3pA)
If you provide an object that doesn‚Äôt match the interface you have provided,
TypeScript will warn you:
    ts
    interface User {
      name: string;
      id: number;
    }
    const user: User = {
      username: "Hayes",
    Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.
      id: 0,
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAFVEZQBvHUUA8gW0lUSOkIBzANytQeACaoCAV04AjGKIC+OHJTgE+oGQ2ip6jALzMxumB26oARAAlyAT0iJrAGjGTUABnfLhQA)
Since JavaScript supports classes and object-oriented programming, so does
TypeScript. You can use an interface declaration with classes:
    ts
    interface User {
      name: string;
      id: number;
    }
    class UserAccount {
      name: string;
      id: number;
      constructor(name: string, id: number) {
        this.name = name;
        this.id = id;
      }
    }
    const user: User = new UserAccount("Murphy", 1);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrlwIANnHTo0mKAEEECAPYdwOJkVIUqNEAyat2XXlEZNFILRwRgFUABTrylanQA0zNoUPQAlKoIEwAAtgdAA6B2QAXkISCEZ-ZCCQ0NYo93jkQUFhBXMwZA5pCgwsaJAIAHcpaDlFZTBbACIAWQ4oAAdAgE9GtwBGb3ogA)
You can use interfaces to annotate parameters and return values to functions:
    ts
    function deleteUser(user: User) {
      // ...
    }
    function getAdminUser(): User {
      //...
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEtIBcCm8AzAQwGNdQBVFfUAbzVFEiIFtcAuUFbeLAcwDcDUBgAmnSAFcWAI3xCAvmhCgAtOpKTs61WgKTIJbBmiRQo3ABtceKvgAUk6vE534ASjrCVAOj9olPQMjEzM+GwBBURYsN3t3V2cvRhA-HwCgA)
There is already a small set of primitive types available in JavaScript:
`boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`,
which you can use in an interface. TypeScript extends this list with a few
more, such as `any` (allow anything), [`unknown`](/play#example/unknown-and-
never) (ensure someone using this type declares what the type is),
[`never`](/play#example/unknown-and-never) (it‚Äôs not possible that this type
could happen), and `void` (a function which returns `undefined` or has no
return value).
You‚Äôll see that there are two syntaxes for building types: [Interfaces and
Types](/play/?e=83#example/types-vs-interfaces). You should prefer
`interface`. Use `type` when you need specific features.
## Composing Types
With TypeScript, you can create complex types by combining simple ones. There
are two popular ways to do so: with unions, and with generics.
### Unions
With a union, you can declare that a type could be one of many types. For
example, you can describe a `boolean` type as being either `true` or `false`:
    ts
    type MyBool = true | false;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAsiBCB7RAbKBeKwBOBXaAPlAGYCGKAzhANxA)
_Note:_ If you hover over `MyBool` above, you‚Äôll see that it is classed as
`boolean`. That‚Äôs a property of the Structural Type System. More on this
below.
A popular use-case for union types is to describe the set of `string` or
`number` [literals](/docs/handbook/2/everyday-types.html#literal-types) that a
value is allowed to be:
    ts
    type WindowStates = "open" | "closed" | "minimized";
    type LockStates = "locked" | "unlocked";
    type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6glgOwCYHsDuBlYBDYEDOUAvFAEQqQKlQA+ZAxgDYr4RLV2kC2icPAXm1IBuAFChIUADIp6Aayy4CxMs3lDaZAK4I1coWInQACizjA4ANwgB5JEgByWrgCMIAJ3wBVZB4AqEAgqAIyaAMyaAKyaAOyaAJzCQA)
Unions provide a way to handle different types too. For example, you may have
a function that takes an `array` or a `string`:
    ts
    function getLength(obj: string | string[]) {
      return obj.length;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQDKrMqALACjgCMArALkQGcoAnGHRAH2roeQG0BdASkQG8AUIkS10IWkhKkAdABtsuPAG5BAXyA)
To learn the type of a variable, use `typeof`:
Type | Predicate  
---|---  
string | `typeof s === "string"`  
number | `typeof n === "number"`  
boolean | `typeof b === "boolean"`  
undefined | `typeof undefined === "undefined"`  
function | `typeof f === "function"`  
array | `Array.isArray(a)`  
For example, you can make a function return different values depending on
whether it is passed a string or an array:
    ts
    function wrapInArray(obj: string | string[]) {
      if (typeof obj === "string") {
        return [obj];
    (parameter) obj: string
      }
      return obj;
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwE4EMAOBJMBBVDATwAo4AjAKwC5EBnKVGMAc0QB97HmWBtAXQCUiAN4AoRIhjBEJKEUwBTODIqVEAXi2IARAyasdw8ZMmpFUEKiS81-ANxiA9E9NvTAPQD8ExAF9fc0trRDVHPyA)
### Generics
Generics provide variables to types. A common example is an array. An array
without generics could contain anything. An array with generics can describe
the values that the array contains.
    ts
    type StringArray = Array<string>;
    type NumberArray = Array<number>;
    type ObjectWithNameArray = Array<{ name: string }>;
You can declare your own types that use generics:
    ts
    interface Backpack<Type> {
      add: (obj: Type) => void;
      get: () => Type;
    }
    // This line is a shortcut to tell TypeScript there is a
    // constant called `backpack`, and to not worry about where it came from.
    declare const backpack: Backpack<string>;
    // object is a string, because we declared it above as the variable part of Backpack.
    const object = backpack.get();
    // Since the backpack variable is a string, you can't pass a number to the add function.
    backpack.add(23);
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAEI0DWADswDwAqAni5AHygA3nlChKAEwmoAFHABGAK1Q8+ASlABeQQDc4BCQG5RoAOaQSsjdtCrIxgL548IWwAsCiUABtidT+KgiG4IJNQAriSgJHDRkN7etryQAMrU0AQsUSRuMP5elC5g1HBEiCSUpKDUlAmQEqAABvLMbNRMjQA04kQNMaBEcFEA7gjQ3OLycJGgw7nQ-lE1ALZ05PDLAHR4EpDU3pQL1aXloC3tbUyojBcc5RlEpvzGRaAKintRAZRBJA+m3Xke0o4UQdGGdF2+0O9VABCilCmOjolC8OToOkOBER3jobGgUTg5AYrWY2xKZUJSk+WjOpPam3MJBkaherhSxFo0VydNu7VAmIyOPygXuxABoG402qlQA5FE2IgCgNwssgdBorF0eIpKByOEiNQSARSttzqwyZIJDJMKygA)
## Structural Type System
One of TypeScript‚Äôs core principles is that type checking focuses on the
_shape_ that values have. This is sometimes called ‚Äúduck typing‚Äù or
‚Äústructural typing‚Äù.
In a structural type system, if two objects have the same shape, they are
considered to be of the same type.
    ts
    interface Point {
      x: number;
      y: number;
    }
    function logPoint(p: Point) {
      console.log(`${p.x}, ${p.y}`);
    }
    // logs "12, 26"
    const point = { x: 12, y: 26 };
    logPoint(point);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLIAeAXMiAK4C2ARtANwHICeZltDeAvnnjBSARhg6EMgA26AOYYsACgAOZWeACUuJglEBndOIgA6SVLkADACQ4FBolwA0yS9eZdTqxjzwB6LxOnbkACIARgAmB1CANkC8LRBtbAVMcGQAXlxiMjCHVmQo5C5GYxUwRWSwdyA)
The `point` variable is never declared to be a `Point` type. However,
TypeScript compares the shape of `point` to the shape of `Point` in the type-
check. They have the same shape, so the code passes.
The shape-matching only requires a subset of the object‚Äôs fields to match.
    ts
    const point3 = { x: 12, y: 26, z: 89 };
    logPoint(point3); // logs "12, 26"
    const rect = { x: 33, y: 3, width: 30, height: 80 };
    logPoint(rect); // logs "33, 3"
    const color = { hex: "#187ABF" };
    logPoint(color);
    Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.
      Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.
      Type '{ hex: string; }' is missing the following properties from type 'Point': x, y[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLwHIkQWMyZSDFAAXjZuVABGNFDpdAA2UIAvVAAOAE5QBXEPKxJzfJIMGNB4j0RQACJK0LRa8eUsnNBoSA1i0p5QDAxq1G3QAHcCABMSAAtdgAZQ08gCA1OSFouOrsMek2WNIZHDMfGt0IYOaZRwsBz6aBrVigG4bcYAYnKzQA7ABBABCADFxi88N1+iZwQgYkA)
There is no difference between how classes and objects conform to shapes:
    ts
    class VirtualPoint {
      x: number;
      y: number;
      constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
      }
    }
    const newVPoint = new VirtualPoint(13, 56);
    logPoint(newVPoint); // logs "13, 56"
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLxqXUpERFAANQJoEj5KXSsWdk4eUH5hMQlpWtkG+0cSaD4NBBMaurlQpv6YWyrOUBIACwJEQNAAXm5xcYnp2ckFqWXQJSVM9trIAHd8is2iY4KikrKKkwBGDFCcADYYvA87i5OKmNB4jx5ABEj2eLyBQA)
If the object or class has all the required properties, TypeScript will say
they match, regardless of the implementation details.
## Next Steps
This was a brief overview of the syntax and tools used in everyday TypeScript.
From here, you can:
  * Read the full Handbook [from start to finish](/docs/handbook/intro.html)
  * Explore the [Playground examples](/play#show-examples)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/get-started/TS for JS
Programmers.md) ‚ù§
Contributors to this page:  
OT
DS
MK
JCR
IO
18+
Last updated: Sep 16, 2024  
Was this page helpful?
# TypeScript Tooling in 5 minutes
Let‚Äôs get started by building a simple web application with TypeScript.
## Installing TypeScript
There are two main ways to add TypeScript to your project:
  * Via npm (the Node.js package manager)
  * By installing TypeScript‚Äôs Visual Studio plugins
Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language
support by default but does not include the TypeScript compiler, `tsc`. If you
didn‚Äôt install TypeScript with Visual Studio, you can still [download
it](/download).
For npm users:
    shell
    > npm install -g typescript
## Building your first TypeScript file
In your editor, type the following JavaScript code in `greeter.ts`:
    ts
    function greeter(person) {
      return "Hello, " + person;
    }
    let user = "Jane User";
    document.body.textContent = greeter(user);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0koA5gE7XVbVuACkSDK7AJSgA3rVCheWBtw4AiABLVkyaABpQq0AGpQo7uMgBuWgF9atZP1AMa3UAF4DAKTKRqoAFVXVWtaABNodAZ4akgsADoAI2gw-HiBAA8sAGF2ATiPLl5+QSEXQQlLIA)
## Compiling your code
We used a `.ts` extension, but this code is just JavaScript. You could have
copy/pasted this straight out of an existing JavaScript app.
At the command line, run the TypeScript compiler:
    shell
    tsc greeter.ts
The result will be a file `greeter.js` which contains the same JavaScript that
you fed in. We‚Äôre up and running using TypeScript in our JavaScript app!
Now we can start taking advantage of some of the new tools TypeScript offers.
Add a `: string` type annotation to the ‚Äòperson‚Äô function parameter as shown
here:
    ts
    function greeter(person: string) {
      return "Hello, " + person;
    }
    let user = "Jane User";
    document.body.textContent = greeter(user);
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFABxwGcEAuRIqVGMZASkQG8AoRRDKEVJAIgAl0AG0FwANIh6IA1IkKoSYANzMAvs2aCsiEERyIAvBIBSAQzDpEAVV2oey5gBM4EEAFt0YKADoARnAcAnl7YAB5QAMII2J4GKBhYOLg6OHSKQA)
## Type annotations
Type annotations in TypeScript are lightweight ways to record the intended
contract of the function or variable. In this case, we intend the greeter
function to be called with a single string parameter. We can try changing the
call greeter to pass an array instead:
    ts
    function greeter(person: string) {
      return "Hello, " + person;
    }
    let user = [0, 1, 2];
    document.body.textContent = greeter(user);
    Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUwAUADjIraohdCol6ASlABvPKFBMKRaHQBEACUgAbNXAA0oRaADUoLkloBuPAF88eNS1BFEMUAF5QAbQAMOgIw60AXXM8ABM4MiIAW0gSCgA6ACM4YIBPWNYADwoAYVpWGJcGJhZ2BxgRUyA)
Re-compiling, you‚Äôll now see an error:
    shell
    error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
Similarly, try removing all the arguments to the greeter call. TypeScript will
let you know that you have called this function with an unexpected number of
arguments. In both cases, TypeScript can offer static analysis based on both
the structure of your code, and the type annotations you provide.
Notice that although there were errors, the `greeter.js` file is still
created. You can use TypeScript even if there are errors in your code. But in
this case, TypeScript is warning that your code will likely not run as
expected.
## Interfaces
Let‚Äôs develop our sample further. Here we use an interface that describes
objects that have a firstName and lastName field. In TypeScript, two types are
compatible if their internal structure is compatible. This allows us to
implement an interface just by having the shape the interface requires,
without an explicit `implements` clause.
    ts
    interface Person {
      firstName: string;
      lastName: string;
    }
    function greeter(person: Person) {
      return "Hello, " + person.firstName + " " + person.lastName;
    }
    let user = { firstName: "Jane", lastName: "User" };
    document.body.textContent = greeter(user);
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyMwUGYAcnALYQBcyFUoA5gNxHIA2cF1dRszacAvgQIwAriARhgOZKygQIkKAAoADphyN05HAEp8XFWClRcAIgASEbtywAaZNeQBqZDsMgAdKTkVLQoXu7uXj7Y-rz8IWIS3GrIUhjQyAC8+CRkcYJuAFJwIBDWrrHB+dYAqmlQ7qKcBAAmWAhSdOB+AEZYzQCefpAAHmAAwjiQ4JlKKmrQGqnQRuxAA)
## Classes
Finally, let‚Äôs extend the example one last time with classes. TypeScript
supports new features in JavaScript, like support for class-based object-
oriented programming.
Here we‚Äôre going to create a `Student` class with a constructor and a few
public fields. Notice that classes and interfaces play well together, letting
the programmer decide on the right level of abstraction.
Also of note, the use of `public` on parameters to the constructor is a
shorthand that allows us to automatically create properties with that name.
    ts
    class Student {
      fullName: string;
      constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
      ) {
        this.fullName = firstName + " " + middleInitial + " " + lastName;
      }
    }
    interface Person {
      firstName: string;
      lastName: string;
    }
    function greeter(person: Person) {
      return "Hello, " + person.firstName + " " + person.lastName;
    }
    let user = new Student("Jane", "M.", "User");
    document.body.textContent = greeter(user);
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAuBXAJgUwHb2gbwFDWgDNEQQA5MAW1QC5oJ4AnAS3QHMBufaYAe3QaNEweL0YAKbgQAOiAEYhmwIs0YMK1OoNZsANFOiyFS6JWbJkIVAEl0zeMzAgtTHfoIz5i5eHVVa9K7s3ACUOAbwABbMEAB0xKQaqNAAvCpq8EnQANTQAET5OabmljZ2Dk5FBQW5vpn+XAQAvrgtuKzwqIyEYMDJAApdEPzhBISqfpqBLOyN0HVJLjOcrbi4xOgizCNsjKionRLSQ-x0g2r8YXgEe0iM6PkAEqikvLqFuccX6PET9dRVD6GE4-BYNVa4KxYRAQLqpaDoVAAdzgSDQmHEeQAUmBEXl3nkALKxfH5ACqsMYeRCXFwyF4wEQ1EwsTkvGQAE9Yp0AB7wADC-E6mHhu32h3EMK6NKAA)
Re-run `tsc greeter.ts` and you‚Äôll see the generated JavaScript is the same as
the earlier code. Classes in TypeScript are just a shorthand for the same
prototype-based OO that is frequently used in JavaScript.
## Running your TypeScript web app
Now type the following in `greeter.html`:
    html
    <!DOCTYPE html>
    <html>
      <head>
        <title>TypeScript Greeter</title>
      </head>
      <body>
        <script src="greeter.js"></script>
      </body>
    </html>
Open `greeter.html` in the browser to run your first simple TypeScript web
application!
Optional: Open `greeter.ts` in Visual Studio, or copy the code into the
TypeScript playground. You can hover over identifiers to see their types.
Notice that in some cases these types are inferred automatically for you. Re-
type the last line, and see completion lists and parameter help based on the
types of the DOM elements. Put your cursor on the reference to the greeter
function, and hit F12 to go to its definition. Notice, too, that you can
right-click on a symbol and use refactoring to rename it.
The type information provided works together with the tools to work with
JavaScript at application scale. For more examples of what‚Äôs possible in
TypeScript, see the Samples section of the website.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/tutorials/TypeScript Tooling in
5 minutes.md) ‚ù§
Contributors to this page:  
OT
H
DS
M
Last updated: Sep 16, 2024  
Was this page helpful?
# Utility Types
TypeScript provides several utility types to facilitate common type
transformations. These utilities are available globally.
## `Awaited<Type>`
> Released: [4.5](/docs/handbook/release-notes/typescript-4-5.html#the-
> awaited-type-and-promise-improvements)
This type is meant to model operations like `await` in `async` functions, or
the `.then()` method on `Promise`s - specifically, the way that they
recursively unwrap `Promise`s.
##### Example
    ts
    type A = Awaited<Promise<string>>;
    type A = string
    type B = Awaited<Promise<Promise<number>>>;
    type B = number
    type C = Awaited<boolean | Promise<number>>;
    type C = number | boolean
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAglC8sDuBDAlsCATAPABQCcB7AWzQGcIdzgC0A7AcwD5mBuAKAHouo+A9APwcOoSFABCCZOky5CpClQVlKOegFcSAIwgFW7brwHDR4aAGFpMVBmw5tRIgBsIKelAA+UFUvVbdfUMePighIA)
## `Partial<Type>`
> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)
Constructs a type with all properties of `Type` set to optional. This utility
will return a type that represents all subsets of a given type.
##### Example
    ts
    interface Todo {
      title: string;
      description: string;
    }
    function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
      return { ...todo, ...fieldsToUpdate };
    }
    const todo1 = {
      title: "organize desk",
      description: "clear clutter",
    };
    const todo2 = updateTodo(todo1, {
      description: "throw out trash",
    });
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgW+AL758MAK4gE-EMhk9McSBmwAKMFnTVN6ADTIYwCGUw0MAVVXqqyAApwoJOGQA8hgHwBKPDYoCDAZKCVcZAA6GN1sExioswsrW3tIZHFWSXwEATpiPQBGZABeQKISckcAInQoRjgQYAAvFA4aAGsaozYO7mA+YAFqGoQKV2RxmTBIKB6JVlz8sELsACYy5XSIQx1ikwIift5FUbAACyh0AHdkdBniKDgaC4XxP2YgA)
## `Required<Type>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#improved-control-
> over-mapped-type-modifiers)
Constructs a type consisting of all properties of `Type` set to required. The
opposite of `Partial`.
##### Example
    ts
    interface Props {
      a?: number;
      b?: string;
    }
    const obj: Props = { a: 5 };
    const obj2: Required<Props> = { a: 5 };
    Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBGAUAJYB2ALjAGYCGAxpKAArwAOioA3nqKJQPypEBXALYAjGAG5OoEX1CIS0YgHNJAXzx5qcIvNBwRAK1SM4LUAF523VAFZQqyZu279BtKgBKkAI4CC0SAATAB4TFgA+CytKW3txIA)
## `Readonly<Type>`
> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)
Constructs a type with all properties of `Type` set to `readonly`, meaning the
properties of the constructed type cannot be reassigned.
##### Example
    ts
    interface Todo {
      title: string;
    }
    const todo: Readonly<Todo> = {
      title: "Delete inactive users",
    };
    todo.title = "Hello";
    Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKACpwAmcoA3nqKCQSQDaRUiEtGIBzANx4AvnjzU4RYd2ZxUAJUiUWRPgE8APIxYA+UAF52nbrwGoARABFIAsqGI0eANzoBXRDCI9gA0MlJ4JKoAdDz8dJb2ABIufHD2EkA)
This utility is useful for representing assignment expressions that will fail
at runtime (i.e. when attempting to reassign properties of a [frozen
object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).
##### `Object.freeze`
    ts
    function freeze<Type>(obj: Type): Readonly<Type>;
## `Record<Keys, Type>`
> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)
Constructs an object type whose property keys are `Keys` and whose property
values are `Type`. This utility can be used to map the properties of a type to
another type.
##### Example
    ts
    type CatName = "miffy" | "boris" | "mordred";
    interface CatInfo {
      age: number;
      breed: string;
    }
    const cats: Record<CatName, CatInfo> = {
      miffy: { age: 10, breed: "Persian" },
      boris: { age: 5, breed: "Maine Coon" },
      mordred: { age: 16, breed: "British Shorthair" },
    };
    cats.boris;
    const cats: Record<CatName, CatInfo>
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwghsAcnAttAvFARCglgM3xCygB9sAjAewCdcBnE8nWgExolawG4AoX3ADtgEGvjgBjaPGABJQfipQA3ryhQ4AcwgAuKIICuKCqL7qKHTnvrA6gzXwC+-CVUE2oEhPT0AlCK40rAA8MshoADSwCPKKAHxQmKrqeIQgesoa2noAjAAMURYQVtgACqL0uHCCJI4RalDUdD4qWbpQAKyFlqx6WACycELSVG619SlsHL2tWu05AGzdxTNYAEJ0wAwAFlAAytu0wNtDNOO8jny8XsD0AHRNDHwA9M9QAHoA-EA)
## `Pick<Type, Keys>`
> Released:  
>  [2.1](/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-
> record-and-pick)
Constructs a type by picking the set of properties `Keys` (string literal or
union of string literals) from `Type`.
##### Example
    ts
    interface Todo {
      title: string;
      description: string;
      completed: boolean;
    }
    type TodoPreview = Pick<Todo, "title" | "completed">;
    const todo: TodoPreview = {
      title: "Clean room",
      completed: false,
    };
    todo;
    const todo: TodoPreview
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVgF98+MAE8eKDNgAKUCADdgEAO7IAvMmPAEAawA8R9ABpkAIhLkEL7IAD5+EtKyEJi+AHys+BIgdMRY6NSephZWtg4ERAEU1L4AwqogyFDKkr5e4lIyEHLU8GQ0EHUaCWBprAD0fcgAegD8QA)
## `Omit<Type, Keys>`
> Released:  
>  [3.5](/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-
> type)
Constructs a type by picking all properties from `Type` and then removing
`Keys` (string literal or union of string literals). The opposite of `Pick`.
##### Example
    ts
    interface Todo {
      title: string;
      description: string;
      completed: boolean;
      createdAt: number;
    }
    type TodoPreview = Omit<Todo, "description">;
    const todo: TodoPreview = {
      title: "Clean room",
      completed: false,
      createdAt: 1615544252770,
    };
    todo;
    const todo: TodoPreview
    type TodoInfo = Omit<Todo, "completed" | "createdAt">;
    const todoInfo: TodoInfo = {
      title: "Pick up kids",
      description: "Kindergarten closes at 5pm",
    };
    todoInfo;
    const todoInfo: TodoInfo
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVkW4Q4cgIJhqIAK6SF0VgF98+MAE8eKDNgAKUCADdgEAO7IAvMgA8pKkADxO6AA0yABEHFy8-CAxAHys+BIgdMRY6NQRrh5evgEERCTkVLEAwqogyFDKkjGR4lIyEHLU8GQ0EK2abjoQmPrUAIwAbOMArDMALPMATDNLAOxrAAytFulguawA9IfIAHoA-NZ2Dmi5AJIgMDgBwWER0TES0rIjMcgAPrEtMNRmBUulMtl9tgHk98vdHs88GwKhRqDFnMAEABrZBGHjIbHATA0FpseLcYB8YACdEAaVAHCgjDgUEg9QQZHQfRoyB0yBmPGaOz2CKeRxOFyAA)
## `Exclude<UnionType, ExcludedMembers>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)
Constructs a type by excluding from `UnionType` all union members that are
assignable to `ExcludedMembers`.
##### Example
    ts
    type T0 = Exclude<"a" | "b" | "c", "a">;
    type T0 = "b" | "c"
    type T1 = Exclude<"a" | "b" | "c", "a" | "b">;
    type T1 = "c"
    type T2 = Exclude<string | number | (() => void), Function>;
    type T2 = string | number
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
    type T3 = Exclude<Shape, { kind: "circle" }>
    type T3 = {
        kind: "square";
        x: number;
    } | {
        kind: "triangle";
        x: number;
        y: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogDwMYBsCuATCAHgCIBDYqAHymICMLriNiAaG8gPgG4AoAej5QhUAHoB+HqEiwAjElSZcBEuSo16apq3YN1xbv0HDxk8NBgAmeemz4iAZ2AAnAJYA7AOZq3OALa0IJzUACmCASiQOKAA3AHsXPDC2ADEcNwxgF1i3AwFhUQlTaQBlAAtSaUQeIWoAbygAa3c8AC4aDBcnbAhiLignUjwXHHs2n39AqABfarV6prdWmnsARxxSJx6+tDG-AKCZmqh55rbiZxdSTywtqB2ocf2+kF2Jg94i8wBma0U7QjKFQgbBOizOHS6NwoUw4hny4iAA)
## `Extract<Type, Union>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)
Constructs a type by extracting from `Type` all union members that are
assignable to `Union`.
##### Example
    ts
    type T0 = Extract<"a" | "b" | "c", "a" | "f">;
    type T0 = "a"
    type T1 = Extract<string | number | (() => void), Function>;
    type T1 = () => void
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
    type T2 = Extract<Shape, { kind: "circle" }>
    type T2 = {
        kind: "circle";
        radius: number;
    }
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogD2AJwIYGNgA8ARNkVAD5REBGZlRuRANFaRVQGZEB8A3AFAB6QVFFQAegH5+oSLACMSVBhz4CAZywBLAHYBzdjoCuAW2oRM7ABRWAlEm5QAbgHstAE1ssAYkZ34tFx0+IRExKX4ZcGgAZQALbDlEflFKAG8oAGtddwAuKlwtTFwAGwgiXigcdy0jdXzjMwsoAF8U9gzsnTyqdQBHI2xMcsq0BtNzSzbUqE6c-KJtbH0yiqgxqEbJypBxpqmBKLkYACYldCw8QnjEiBY57oXC4tXW7lCxCUkgA)
## `NonNullable<Type>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)
Constructs a type by excluding `null` and `undefined` from `Type`.
##### Example
    ts
    type T0 = NonNullable<string | number | undefined>;
    type T0 = string | number
    type T1 = NonNullable<string[] | null | undefined>;
    type T1 = string[]
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAcgewHYoK4BtcCGARrhADwDOwATgJYYDmUAPlBtgLZETUtTYYAJhABm9CIIB8AbgBQAenlRlUAHoB+WaEiwAjElSYc+YqUo16DANoBdPu3x8BwsRgkyFSlRqA)
## `Parameters<Type>`
> Released:  
>  [3.1](https://github.com/microsoft/TypeScript/pull/26243)
Constructs a tuple type from the types used in the parameters of a function
type `Type`.
For overloaded functions, this will be the parameters of the _last_ signature;
see [Inferring Within Conditional Types](/docs/handbook/2/conditional-
types.html#inferring-within-conditional-types).
##### Example
    ts
    declare function f1(arg: { a: number; b: string }): void;
    type T0 = Parameters<() => string>;
    type T0 = []
    type T1 = Parameters<(s: string) => void>;
    type T1 = [s: string]
    type T2 = Parameters<<T>(arg: T) => T>;
    type T2 = [arg: unknown]
    type T3 = Parameters<typeof f1>;
    type T3 = [arg: {
        a: number;
        b: string;
    }]
    type T4 = Parameters<any>;
    type T4 = unknown[]
    type T5 = Parameters<never>;
    type T5 = never
    type T6 = Parameters<string>;
    Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.
    type T6 = never
    type T7 = Parameters<Function>;
    Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.
    type T7 = never
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQATSAYwBsBDaSUAMwFcA7IgFwEs56aBGACgoHNUAb1BlU9WgFsARjADcoKakRNoLen1ABfAJSoAbnBb5ZuXEwCeAByoAVAAygAvKAAKFMhMhMYiADzdtJwA+UGVVdSCTEFAY0AA9AH4zK1tOJ1d3T28kfxRQlTU+QMcQgyNI3GjYxOTrUBs0dLdoDy8fX18bIN5oAXrikK6osGqkizqbDCbMtpzxyDhqLgqqmJr5+qxplqz2snpzFZG1sZT6gFZt1uy-ekg9GCPY+NOJgDYr3ZywwqfR2tsAHZPrM-AAxBjMNj0P4nIA)
## `ConstructorParameters<Type>`
> Released:  
>  [3.1](https://github.com/microsoft/TypeScript/pull/26243)
Constructs a tuple or array type from the types of a constructor function
type. It produces a tuple type with all the parameter types (or the type
`never` if `Type` is not a function).
##### Example
    ts
    type T0 = ConstructorParameters<ErrorConstructor>;
    type T0 = [message?: string]
    type T1 = ConstructorParameters<FunctionConstructor>;
    type T1 = string[]
    type T2 = ConstructorParameters<RegExpConstructor>;
    type T2 = [pattern: string | RegExp, flags?: string]
    class C {
      constructor(a: number, b: string) {}
    }
    type T3 = ConstructorParameters<typeof C>;
    type T3 = [a: number, b: string]
    type T4 = ConstructorParameters<any>;
    type T4 = unknown[]
    type T5 = ConstructorParameters<Function>;
    Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.
    type T5 = never
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQIJEAXaASwGMjUAzAQwBtFJciBPAB0lABUAGUALygAwnAB2xaAFdKCAAq1otALaQiMRAB4AorASiJJGUQQA+ANz4woGwD0A-Cw5duARkEjxk4-MUq1GpoAYlJilKTiBt6y0BZWNnaObJw8aB5RRjEKSqrqSJoASpAA5toAHuwZ0jFxBAkOuOT0tIiIIqAA3rg25F6ZJtAAFLSoYlLKAEYwADSgE6iSpGLFAJSdAL64m8kuGOl91QPZ-nlaO3DUIrXWiU4p3Fj7hoe+OQH5tGKs1wmgDXcuACsT2iRz8uUCITCRAiYh+9XsQA)
## `ReturnType<Type>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)
Constructs a type consisting of the return type of function `Type`.
For overloaded functions, this will be the return type of the _last_
signature; see [Inferring Within Conditional
Types](/docs/handbook/2/conditional-types.html#inferring-within-conditional-
types).
##### Example
    ts
    declare function f1(): { a: number; b: string };
    type T0 = ReturnType<() => string>;
    type T0 = string
    type T1 = ReturnType<(s: string) => void>;
    type T1 = void
    type T2 = ReturnType<<T>() => T>;
    type T2 = unknown
    type T3 = ReturnType<<T extends U, U extends number[]>() => T>;
    type T3 = number[]
    type T4 = ReturnType<typeof f1>;
    type T4 = {
        a: number;
        b: string;
    }
    type T5 = ReturnType<any>;
    type T5 = any
    type T6 = ReturnType<never>;
    type T6 = never
    type T7 = ReturnType<string>;
    Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.
    type T7 = any
    type T8 = ReturnType<Function>;
    Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.
      Type 'Function' provides no match for the signature '(...args: any): any'.
    type T8 = any
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAAmkAxgDYCG0koAZgK4B2pALgJZxP0CMAFAEpUAb1CVUTBgFsARjADcoGakSto7JgHNQAX3kECrAJ4AHWgBUADKAC8oAEqRWDaE3OnIAHkG2AfKFV1LV99EFBw0AA9AH5DD1BzHlsHJxc3D28UALUNTQE-UAA3OHYiEIIwiJi4swS0ZMdnV3czT09zXx8bfw7QsCrY41rzDAbU5oz20EgAD1ZIJiJEUABVABpV6bmFpdBJWRgAbQBdTvzuhPLK8Oqhi1w7RrSWrzu4Ol4r-pvB+PMAVjGTXSrUoTCMXwiUV+wwAbEDnhkmJBCjBIQMahYAOwIiatQK5dE-TEJAAcuJBXgAYsw2JwmEToUA)
## `InstanceType<Type>`
> Released:  
>  [2.8](/docs/handbook/release-notes/typescript-2-8.html#predefined-
> conditional-types)
Constructs a type consisting of the instance type of a constructor function in
`Type`.
##### Example
    ts
    class C {
      x = 0;
      y = 0;
    }
    type T0 = InstanceType<typeof C>;
    type T0 = C
    type T1 = InstanceType<any>;
    type T1 = any
    type T2 = InstanceType<never>;
    type T2 = never
    type T3 = InstanceType<string>;
    Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.
    type T3 = any
    type T4 = InstanceType<Function>;
    Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.
      Type 'Function' provides no match for the signature 'new (...args: any): any'.
    type T4 = any
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAgSIAu0AlgMamoBmAhgDaKQFVMOKKgDCoAbwKhQAD1ABeUAAYA3MNABPSTPkBfAgVKKADpFAAVaSoCSAOzIMzVSAd2QAPNr1w6fAHzziI0AD0A-Fr2hgCMphakVjZ2eg5Wip5EYD4BQXqGaOGW1rb2DmaQAG4wid4iqc76BhhZkTkxjmSUZgDmpcnlgZWGuFLm2dF5AGIArtakFHBm7T5+-kA)
## `NoInfer<Type>`
> Released:  
>  [5.4](/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-
> type)
Blocks inferences to the contained type. Other than blocking inferences,
`NoInfer<Type>` is identical to `Type`.
##### Example
    ts
    function createStreetLight<C extends string>(
      colors: C[],
      defaultColor?: NoInfer<C>,
    ) {
      // ...
    }
    createStreetLight(["red", "yellow", "green"], "red");  // OK
    createStreetLight(["red", "yellow", "green"], "blue");  // Error
## `ThisParameterType<Type>`
> Released:  
>  [3.3](https://github.com/microsoft/TypeScript/pull/28920)
Extracts the type of the [this](/docs/handbook/functions.html#this-parameters)
parameter for a function type, or [unknown](/docs/handbook/release-
notes/typescript-3-0.html#new-unknown-top-type) if the function type has no
`this` parameter.
##### Example
    ts
    function toHex(this: Number) {
      return this.toString(16);
    }
    function numberToString(n: ThisParameterType<typeof toHex>) {
      return toHex.apply(n);
    }
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWoSLASIwVWnQAqcMROnYwpIwUIAFAIZ0HlbvSMBPAA7oAPFG90OGBkNCwAPiY2Di4ePlCMTEEHLy8AGw9LZTUgA)
## `OmitThisParameter<Type>`
> Released:  
>  [3.3](https://github.com/microsoft/TypeScript/pull/28920)
Removes the [`this`](/docs/handbook/functions.html#this-parameters) parameter
from `Type`. If `Type` has no explicitly declared `this` parameter, the result
is simply `Type`. Otherwise, a new function type with no `this` parameter is
created from `Type`. Generics are erased and only the last overload signature
is propagated into the new function type.
##### Example
    ts
    function toHex(this: Number) {
      return this.toString(16);
    }
    const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);
    console.log(fiveToHex());
    [Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWEBISiJgMAG7oAKmiykA8pRhRjBQgAUAhnSeVu9ADxQAngAd0OGBkM0wAPkQAXhCMTEFqSQATbABWZQ0tMEI4ABt0QRy4GX0jU1jsBmUgA)
## `ThisType<Type>`
> Released:  
>  [2.3](https://github.com/microsoft/TypeScript/pull/14141)
This utility does not return a transformed type. Instead, it serves as a
marker for a contextual [`this`](/docs/handbook/functions.html#this) type.
Note that the [`noImplicitThis`](/tsconfig#noImplicitThis) flag must be
enabled to use this utility.
##### Example
    ts
    type ObjectDescriptor<D, M> = {
      data?: D;
      methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M
    };
    function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
      let data: object = desc.data || {};
      let methods: object = desc.methods || {};
      return { ...data, ...methods } as D & M;
    }
    let obj = makeObject({
      data: { x: 0, y: 0 },
      methods: {
        moveBy(dx: number, dy: number) {
          this.x += dx; // Strongly typed this
          this.y += dy; // Strongly typed this
        },
      },
    });
    obj.x = 10;
    obj.y = 20;
    obj.moveBy(5, 5);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwCoAtUBnALlCwCcBXAUwCgsBPRa0AeQCMAra9LAEWqF05VIizRyAHj4AaUAFkAfKAC8oAN61QoACYBDLHoD8pPgG4toeNSx5oOwiYWgAZKHxEcTatNcLFZqAg7t6g0ABmoADktkRRoKiQVjZ2DgmEoHx+8rQAvha04ZSQvKjQSfB6ANbUHNy80nJKABQ6guikdTz87SJiEo3+AJSm2RqWyDa6Bnqk0FzdqrrtAHT6hqAAPpsa+RNT1rb2JGELvEttQiuHqRnbuxba5DaU5EnqoCtf63pyX9cpY6gXKgPQZLJueQWXK0WiTLCnThLSo1Lq8ZqabQ-UgfAAepAADHIGITgTJLDdjjjLNp4NAAG7UABCDFa+NAkEo8HY1HIch0JI5XJ55CG420ErIBEIK1xoAA1GodLjAsEAMoUcoAc2QDDI3h0UqINIlsRlesVugYqrAGvI2t1+uYhrNJty5O07ryQwK804sqWAEYCRY-Ss9WoAEwh2hhumMlnNACsciTPqAA)
In the example above, the `methods` object in the argument to `makeObject` has
a contextual type that includes `ThisType<D & M>` and therefore the type of
[this](/docs/handbook/functions.html#this) in methods within the `methods`
object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void
}`. Notice how the type of the `methods` property simultaneously is an
inference target and a source for the `this` type in methods.
The `ThisType<T>` marker interface is simply an empty interface declared in
`lib.d.ts`. Beyond being recognized in the contextual type of an object
literal, the interface acts like any empty interface.
## Intrinsic String Manipulation Types
### `Uppercase<StringType>`
### `Lowercase<StringType>`
### `Capitalize<StringType>`
### `Uncapitalize<StringType>`
To help with string manipulation around template string literals, TypeScript
includes a set of types which can be used in string manipulation within the
type system. You can find those in the [Template Literal
Types](/docs/handbook/2/template-literal-types.html#uppercasestringtype)
documentation.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Utility Types.md) ‚ù§
Contributors to this page:  
C
OT
B
JB
HX
34+
Last updated: Sep 16, 2024  
Was this page helpful?
# Variable Declaration
`let` and `const` are two relatively new concepts for variable declarations in
JavaScript. [As we mentioned earlier](/docs/handbook/basic-types.html#a-note-
about-let), `let` is similar to `var` in some respects, but allows users to
avoid some of the common ‚Äúgotchas‚Äù that users run into in JavaScript.
`const` is an augmentation of `let` in that it prevents re-assignment to a
variable.
With TypeScript being an extension of JavaScript, the language naturally
supports `let` and `const`. Here we‚Äôll elaborate more on these new
declarations and why they‚Äôre preferable to `var`.
If you‚Äôve used JavaScript offhandedly, the next section might be a good way to
refresh your memory. If you‚Äôre intimately familiar with all the quirks of
`var` declarations in JavaScript, you might find it easier to skip ahead.
## `var` declarations
Declaring a variable in JavaScript has always traditionally been done with the
`var` keyword.
    ts
    var a = 10;
As you might‚Äôve figured out, we just declared a variable named `a` with the
value `10`.
We can also declare a variable inside of a function:
    ts
    function f() {
      var message = "Hello, world!";
      return message;
    }
and we can also access those same variables within other functions:
    ts
    function f() {
      var a = 10;
      return function g() {
        var b = a + 1;
        return b;
      };
    }
    var g = f();
    g(); // returns '11'
In this above example, `g` captured the variable `a` declared in `f`. At any
point that `g` gets called, the value of `a` will be tied to the value of `a`
in `f`. Even if `g` is called once `f` is done running, it will be able to
access and modify `a`.
    ts
    function f() {
      var a = 1;
      a = 2;
      var b = g();
      a = 3;
      return b;
      function g() {
        return a;
      }
    }
    f(); // returns '2'
### Scoping rules
`var` declarations have some odd scoping rules for those used to other
languages. Take the following example:
    ts
    function f(shouldInitialize: boolean) {
      if (shouldInitialize) {
        var x = 10;
      }
      return x;
    }
    f(true); // returns '10'
    f(false); // returns 'undefined'
Some readers might do a double-take at this example. The variable `x` was
declared _within the`if` block_, and yet we were able to access it from
outside that block. That‚Äôs because `var` declarations are accessible anywhere
within their containing function, module, namespace, or global scope - all
which we‚Äôll go over later on - regardless of the containing block. Some people
call this _`var`-scoping_ or _function-scoping_. Parameters are also function
scoped.
These scoping rules can cause several types of mistakes. One problem they
exacerbate is the fact that it is not an error to declare the same variable
multiple times:
    ts
    function sumMatrix(matrix: number[][]) {
      var sum = 0;
      for (var i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (var i = 0; i < currentRow.length; i++) {
          sum += currentRow[i];
        }
      }
      return sum;
    }
Maybe it was easy to spot out for some experienced JavaScript developers, but
the inner `for`-loop will accidentally overwrite the variable `i` because `i`
refers to the same function-scoped variable. As experienced developers know by
now, similar sorts of bugs slip through code reviews and can be an endless
source of frustration.
### Variable capturing quirks
Take a quick second to guess what the output of the following snippet is:
    ts
    for (var i = 0; i < 10; i++) {
      setTimeout(function () {
        console.log(i);
      }, 100 * i);
    }
For those unfamiliar, `setTimeout` will try to execute a function after a
certain number of milliseconds (though waiting for anything else to stop
running).
Ready? Take a look:
    10
    10
    10
    10
    10
    10
    10
    10
    10
    10
Many JavaScript developers are intimately familiar with this behavior, but if
you‚Äôre surprised, you‚Äôre certainly not alone. Most people expect the output to
be
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
Remember what we mentioned earlier about variable capturing? Every function
expression we pass to `setTimeout` actually refers to the same `i` from the
same scope.
Let‚Äôs take a minute to consider what that means. `setTimeout` will run a
function after some number of milliseconds, _but only_ after the `for` loop
has stopped executing; By the time the `for` loop has stopped executing, the
value of `i` is `10`. So each time the given function gets called, it will
print out `10`!
A common work around is to use an IIFE - an Immediately Invoked Function
Expression - to capture `i` at each iteration:
    ts
    for (var i = 0; i < 10; i++) {
      // capture the current state of 'i'
      // by invoking a function with its current value
      (function (i) {
        setTimeout(function () {
          console.log(i);
        }, 100 * i);
      })(i);
    }
This odd-looking pattern is actually pretty common. The `i` in the parameter
list actually shadows the `i` declared in the `for` loop, but since we named
them the same, we didn‚Äôt have to modify the loop body too much.
## `let` declarations
By now you‚Äôve figured out that `var` has some problems, which is precisely why
`let` statements were introduced. Apart from the keyword used, `let`
statements are written the same way `var` statements are.
    ts
    let hello = "Hello!";
The key difference is not in the syntax, but in the semantics, which we‚Äôll now
dive into.
### Block-scoping
When a variable is declared using `let`, it uses what some call _lexical-
scoping_ or _block-scoping_. Unlike variables declared with `var` whose scopes
leak out to their containing function, block-scoped variables are not visible
outside of their nearest containing block or `for`-loop.
    ts
    function f(input: boolean) {
      let a = 100;
      if (input) {
        // Still okay to reference 'a'
        let b = a + 1;
        return b;
      }
      // Error: 'b' doesn't exist here
      return b;
    }
Here, we have two local variables `a` and `b`. `a`‚Äôs scope is limited to the
body of `f` while `b`‚Äôs scope is limited to the containing `if` statement‚Äôs
block.
Variables declared in a `catch` clause also have similar scoping rules.
    ts
    try {
      throw "oh no!";
    } catch (e) {
      console.log("Oh well.");
    }
    // Error: 'e' doesn't exist here
    console.log(e);
Another property of block-scoped variables is that they can‚Äôt be read or
written to before they‚Äôre actually declared. While these variables are
‚Äúpresent‚Äù throughout their scope, all points up until their declaration are
part of their _temporal dead zone_. This is just a sophisticated way of saying
you can‚Äôt access them before the `let` statement, and luckily TypeScript will
let you know that.
    ts
    a++; // illegal to use 'a' before it's declared;
    let a;
Something to note is that you can still _capture_ a block-scoped variable
before it‚Äôs declared. The only catch is that it‚Äôs illegal to call that
function before the declaration. If targeting ES2015, a modern runtime will
throw an error; however, right now TypeScript is permissive and won‚Äôt report
this as an error.
    ts
    function foo() {
      // okay to capture 'a'
      return a;
    }
    // illegal call 'foo' before 'a' is declared
    // runtimes should throw an error here
    foo();
    let a;
For more information on temporal dead zones, see relevant content on the
[Mozilla Developer
Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).
### Re-declarations and Shadowing
With `var` declarations, we mentioned that it didn‚Äôt matter how many times you
declared your variables; you just got one.
    ts
    function f(x) {
      var x;
      var x;
      if (true) {
        var x;
      }
    }
In the above example, all declarations of `x` actually refer to the _same_
`x`, and this is perfectly valid. This often ends up being a source of bugs.
Thankfully, `let` declarations are not as forgiving.
    ts
    let x = 10;
    let x = 20; // error: can't re-declare 'x' in the same scope
The variables don‚Äôt necessarily need to both be block-scoped for TypeScript to
tell us that there‚Äôs a problem.
    ts
    function f(x) {
      let x = 100; // error: interferes with parameter declaration
    }
    function g() {
      let x = 100;
      var x = 100; // error: can't have both declarations of 'x'
    }
That‚Äôs not to say that a block-scoped variable can never be declared with a
function-scoped variable. The block-scoped variable just needs to be declared
within a distinctly different block.
    ts
    function f(condition, x) {
      if (condition) {
        let x = 100;
        return x;
      }
      return x;
    }
    f(false, 0); // returns '0'
    f(true, 0); // returns '100'
The act of introducing a new name in a more nested scope is called
_shadowing_. It is a bit of a double-edged sword in that it can introduce
certain bugs on its own in the event of accidental shadowing, while also
preventing certain bugs. For instance, imagine we had written our earlier
`sumMatrix` function using `let` variables.
    ts
    function sumMatrix(matrix: number[][]) {
      let sum = 0;
      for (let i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (let i = 0; i < currentRow.length; i++) {
          sum += currentRow[i];
        }
      }
      return sum;
    }
This version of the loop will actually perform the summation correctly because
the inner loop‚Äôs `i` shadows `i` from the outer loop.
Shadowing should _usually_ be avoided in the interest of writing clearer code.
While there are some scenarios where it may be fitting to take advantage of
it, you should use your best judgement.
### Block-scoped variable capturing
When we first touched on the idea of variable capturing with `var`
declaration, we briefly went into how variables act once captured. To give a
better intuition of this, each time a scope is run, it creates an
‚Äúenvironment‚Äù of variables. That environment and its captured variables can
exist even after everything within its scope has finished executing.
    ts
    function theCityThatAlwaysSleeps() {
      let getCity;
      if (true) {
        let city = "Seattle";
        getCity = function () {
          return city;
        };
      }
      return getCity();
    }
Because we‚Äôve captured `city` from within its environment, we‚Äôre still able to
access it despite the fact that the `if` block finished executing.
Recall that with our earlier `setTimeout` example, we ended up needing to use
an IIFE to capture the state of a variable for every iteration of the `for`
loop. In effect, what we were doing was creating a new variable environment
for our captured variables. That was a bit of a pain, but luckily, you‚Äôll
never have to do that again in TypeScript.
`let` declarations have drastically different behavior when declared as part
of a loop. Rather than just introducing a new environment to the loop itself,
these declarations sort of create a new scope _per iteration_. Since this is
what we were doing anyway with our IIFE, we can change our old `setTimeout`
example to just use a `let` declaration.
    ts
    for (let i = 0; i < 10; i++) {
      setTimeout(function () {
        console.log(i);
      }, 100 * i);
    }
and as expected, this will print out
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
## `const` declarations
`const` declarations are another way of declaring variables.
    ts
    const numLivesForCat = 9;
They are like `let` declarations but, as their name implies, their value
cannot be changed once they are bound. In other words, they have the same
scoping rules as `let`, but you can‚Äôt re-assign to them.
This should not be confused with the idea that the values they refer to are
_immutable_.
    ts
    const numLivesForCat = 9;
    const kitty = {
      name: "Aurora",
      numLives: numLivesForCat,
    };
    // Error
    kitty = {
      name: "Danielle",
      numLives: numLivesForCat,
    };
    // all "okay"
    kitty.name = "Rory";
    kitty.name = "Kitty";
    kitty.name = "Cat";
    kitty.numLives--;
Unless you take specific measures to avoid it, the internal state of a `const`
variable is still modifiable. Fortunately, TypeScript allows you to specify
that members of an object are `readonly`. The [chapter on
Interfaces](/docs/handbook/interfaces.html) has the details.
## `let` vs. `const`
Given that we have two types of declarations with similar scoping semantics,
it‚Äôs natural to find ourselves asking which one to use. Like most broad
questions, the answer is: it depends.
Applying the [principle of least
privilege](https://wikipedia.org/wiki/Principle_of_least_privilege), all
declarations other than those you plan to modify should use `const`. The
rationale is that if a variable didn‚Äôt need to get written to, others working
on the same codebase shouldn‚Äôt automatically be able to write to the object,
and will need to consider whether they really need to reassign to the
variable. Using `const` also makes code more predictable when reasoning about
flow of data.
Use your best judgement, and if applicable, consult the matter with the rest
of your team.
The majority of this handbook uses `let` declarations.
## Destructuring
Another ECMAScript 2015 feature that TypeScript has is destructuring. For a
complete reference, see [the article on the Mozilla Developer
Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
In this section, we‚Äôll give a short overview.
### Array destructuring
The simplest form of destructuring is array destructuring assignment:
    ts
    let input = [1, 2];
    let [first, second] = input;
    console.log(first); // outputs 1
    console.log(second); // outputs 2
This creates two new variables named `first` and `second`. This is equivalent
to using indexing, but is much more convenient:
    ts
    first = input[0];
    second = input[1];
Destructuring works with already-declared variables as well:
    ts
    // swap variables
    [first, second] = [second, first];
And with parameters to a function:
    ts
    function f([first, second]: [number, number]) {
      console.log(first);
      console.log(second);
    }
    f([1, 2]);
You can create a variable for the remaining items in a list using the syntax
`...`:
    ts
    let [first, ...rest] = [1, 2, 3, 4];
    console.log(first); // outputs 1
    console.log(rest); // outputs [ 2, 3, 4 ]
Of course, since this is JavaScript, you can just ignore trailing elements you
don‚Äôt care about:
    ts
    let [first] = [1, 2, 3, 4];
    console.log(first); // outputs 1
Or other elements:
    ts
    let [, second, , fourth] = [1, 2, 3, 4];
    console.log(second); // outputs 2
    console.log(fourth); // outputs 4
### Tuple destructuring
Tuples may be destructured like arrays; the destructuring variables get the
types of the corresponding tuple elements:
    ts
    let tuple: [number, string, boolean] = [7, "hello", true];
    let [a, b, c] = tuple; // a: number, b: string, c: boolean
It‚Äôs an error to destructure a tuple beyond the range of its elements:
    ts
    let [a, b, c, d] = tuple; // Error, no element at index 3
As with arrays, you can destructure the rest of the tuple with `...`, to get a
shorter tuple:
    ts
    let [a, ...bc] = tuple; // bc: [string, boolean]
    let [a, b, c, ...d] = tuple; // d: [], the empty tuple
Or ignore trailing elements, or other elements:
    ts
    let [a] = tuple; // a: number
    let [, b] = tuple; // b: string
### Object destructuring
You can also destructure objects:
    ts
    let o = {
      a: "foo",
      b: 12,
      c: "bar",
    };
    let { a, b } = o;
This creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you
can skip `c` if you don‚Äôt need it.
Like array destructuring, you can have assignment without declaration:
    ts
    ({ a, b } = { a: "baz", b: 101 });
Notice that we had to surround this statement with parentheses. JavaScript
normally parses a `{` as the start of block.
You can create a variable for the remaining items in an object using the
syntax `...`:
    ts
    let { a, ...passthrough } = o;
    let total = passthrough.b + passthrough.c.length;
#### Property renaming
You can also give different names to properties:
    ts
    let { a: newName1, b: newName2 } = o;
Here the syntax starts to get confusing. You can read `a: newName1` as ‚Äù`a` as
`newName1`‚Äù. The direction is left-to-right, as if you had written:
    ts
    let newName1 = o.a;
    let newName2 = o.b;
Confusingly, the colon here does _not_ indicate the type. The type, if you
specify it, still needs to be written after the entire destructuring:
    ts
    let { a: newName1, b: newName2 }: { a: string; b: number } = o;
#### Default values
Default values let you specify a default value in case a property is
undefined:
    ts
    function keepWholeObject(wholeObject: { a: string; b?: number }) {
      let { a, b = 1001 } = wholeObject;
    }
In this example the `b?` indicates that `b` is optional, so it may be
`undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as
the properties `a` and `b`, even if `b` is undefined.
## Function declarations
Destructuring also works in function declarations. For simple cases this is
straightforward:
    ts
    type C = { a: string; b?: number };
    function f({ a, b }: C): void {
      // ...
    }
But specifying defaults is more common for parameters, and getting defaults
right with destructuring can be tricky. First of all, you need to remember to
put the pattern before the default value.
    ts
    function f({ a = "", b = 0 } = {}): void {
      // ...
    }
    f();
> The snippet above is an example of type inference, explained earlier in the
> handbook.
Then, you need to remember to give a default for optional properties on the
destructured property instead of the main initializer. Remember that `C` was
defined with `b` optional:
    ts
    function f({ a, b = 0 } = { a: "" }): void {
      // ...
    }
    f({ a: "yes" }); // ok, default b = 0
    f(); // ok, default to { a: "" }, which then defaults b = 0
    f({}); // error, 'a' is required if you supply an argument
Use destructuring with care. As the previous example demonstrates, anything
but the simplest destructuring expression is confusing. This is especially
true with deeply nested destructuring, which gets _really_ hard to understand
even without piling on renaming, default values, and type annotations. Try to
keep destructuring expressions small and simple. You can always write the
assignments that destructuring would generate yourself.
## Spread
The spread operator is the opposite of destructuring. It allows you to spread
an array into another array, or an object into another object. For example:
    ts
    let first = [1, 2];
    let second = [3, 4];
    let bothPlus = [0, ...first, ...second, 5];
This gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a
shallow copy of `first` and `second`. They are not changed by the spread.
You can also spread objects:
    ts
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    let search = { ...defaults, food: "rich" };
Now `search` is `{ food: "rich", price: "$$", ambiance: "noisy" }`. Object
spreading is more complex than array spreading. Like array spreading, it
proceeds from left-to-right, but the result is still an object. This means
that properties that come later in the spread object overwrite properties that
come earlier. So if we modify the previous example to spread at the end:
    ts
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    let search = { food: "rich", ...defaults };
Then the `food` property in `defaults` overwrites `food: "rich"`, which is not
what we want in this case.
Object spread also has a couple of other surprising limits. First, it only
includes an objects‚Äô [own, enumerable
properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
Basically, that means you lose methods when you spread instances of an object:
    ts
    class C {
      p = 12;
      m() {}
    }
    let c = new C();
    let clone = { ...c };
    clone.p; // ok
    clone.m(); // error!
Second, the TypeScript compiler doesn‚Äôt allow spreads of type parameters from
generic functions. That feature is expected in future versions of the
language.
## `using` declarations
`using` declarations are an upcoming feature for JavaScript that are part of
the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-
explicit-resource-management) proposal. A `using` declaration is much like a
`const` declaration, except that it couples the _lifetime_ of the value bound
to the declaration with the _scope_ of the variable.
When control exits the block containing a `using` declaration, the
`[Symbol.dispose]()` method of the declared value is executed, which allows
that value to perform cleanup:
    ts
    function f() {
      using x = new C();
      doSomethingWith(x);
    } // `x[Symbol.dispose]()` is called
At runtime, this has an effect _roughly_ equivalent to the following:
    ts
    function f() {
      const x = new C();
      try {
        doSomethingWith(x);
      }
      finally {
        x[Symbol.dispose]();
      }
    }
`using` declarations are extremely useful for avoiding memory leaks when
working with JavaScript objects that hold on to native references like file
handles
    ts
    {
      using file = await openFile();
      file.write(text);
      doSomethingThatMayThrow();
    } // `file` is disposed, even if an error is thrown
or scoped operations like tracing
    ts
    function f() {
      using activity = new TraceActivity("f"); // traces entry into function
      // ...
    } // traces exit of function
Unlike `var`, `let`, and `const`, `using` declarations do not support
destructuring.
### `null` and `undefined`
It‚Äôs important to note that the value can be `null` or `undefined`, in which
case nothing is disposed at the end of the block:
    ts
    {
      using x = b ? new C() : null;
      // ...
    }
which is _roughly_ equivalent to:
    ts
    {
      const x = b ? new C() : null;
      try {
        // ...
      }
      finally {
        x?.[Symbol.dispose]();
      }
    }
This allows you to conditionally acquire resources when declaring a `using`
declaration without the need for complex branching or repetition.
### Defining a disposable resource
You can indicate the classes or objects you produce are disposable by
implementing the `Disposable` interface:
    ts
    // from the default lib:
    interface Disposable {
      [Symbol.dispose](): void;
    }
    // usage:
    class TraceActivity implements Disposable {
      readonly name: string;
      constructor(name: string) {
        this.name = name;
        console.log(`Entering: ${name}`);
      }
      [Symbol.dispose](): void {
        console.log(`Exiting: ${name}`);
      }
    }
    function f() {
      using _activity = new TraceActivity("f");
      console.log("Hello world!");
    }
    f();
    // prints:
    //   Entering: f
    //   Hello world!
    //   Exiting: f
## `await using` declarations
Some resources or operations may have cleanup that needs to be performed
asynchronously. To accommodate this, the [Explicit Resource
Management](https://github.com/tc39/proposal-explicit-resource-management)
proposal also introduces the `await using` declaration:
    ts
    async function f() {
      await using x = new C();
    } // `await x[Symbol.asyncDispose]()` is invoked
An `await using` declaration invokes, and _awaits_ , its value‚Äôs
`[Symbol.asyncDispose]()` method as control leaves the containing block. This
allows for asynchronous cleanup, such as a database transaction performing a
rollback or commit, or a file stream flushing any pending writes to storage
before it is closed.
As with `await`, `await using` can only be used in an `async` function or
method, or at the top level of a module.
### Defining an asynchronously disposable resource
Just as `using` relies on objects that are `Disposable`, an `await using`
relies on objects that are `AsyncDisposable`:
    ts
    // from the default lib:
    interface AsyncDisposable {
      [Symbol.asyncDispose]: PromiseLike<void>;
    }
    // usage:
    class DatabaseTransaction implements AsyncDisposable {
      public success = false;
      private db: Database | undefined;
      private constructor(db: Database) {
        this.db = db;
      }
      static async create(db: Database) {
        await db.execAsync("BEGIN TRANSACTION");
        return new DatabaseTransaction(db);
      }
      async [Symbol.asyncDispose]() {
        if (this.db) {
          const db = this.db:
          this.db = undefined;
          if (this.success) {
            await db.execAsync("COMMIT TRANSACTION");
          }
          else {
            await db.execAsync("ROLLBACK TRANSACTION");
          }
        }
      }
    }
    async function transfer(db: Database, account1: Account, account2: Account, amount: number) {
      using tx = await DatabaseTransaction.create(db);
      if (await debitAccount(db, account1, amount)) {
        await creditAccount(db, account2, amount);
      }
      // if an exception is thrown before this line, the transaction will roll back
      tx.success = true;
      // now the transaction will commit
    }
### `await using` vs `await`
The `await` keyword that is part of the `await using` declaration only
indicates that the _disposal_ of the resource is `await`-ed. It does _not_
`await` the value itself:
    ts
    {
      await using x = getResourceSynchronously();
    } // performs `await x[Symbol.asyncDispose]()`
    {
      await using y = await getResourceAsynchronously();
    } // performs `await y[Symbol.asyncDispose]()`
### `await using` and `return`
It‚Äôs important to note that there is a small caveat with this behavior if you
are using an `await using` declaration in an `async` function that returns a
`Promise` without first `await`-ing it:
    ts
    function g() {
      return Promise.reject("error!");
    }
    async function f() {
      await using x = new C();
      return g(); // missing an `await`
    }
Because the returned promise isn‚Äôt `await`-ed, it‚Äôs possible that the
JavaScript runtime may report an unhandled rejection since execution pauses
while `await`-ing the asynchronous disposal of `x`, without having subscribed
to the returned promise. This is not a problem that is unique to `await
using`, however, as this can also occur in an `async` function that uses
`try..finally`:
    ts
    async function f() {
      try {
        return g(); // also reports an unhandled rejection
      }
      finally {
        await somethingElse();
      }
    }
To avoid this situation, it is recommended that you `await` your return value
if it may be a `Promise`:
    ts
    async function f() {
      await using x = new C();
      return await g();
    }
## `using` and `await using` in `for` and `for..of` statements
Both `using` and `await using` can be used in a `for` statement:
    ts
    for (using x = getReader(); !x.eof; x.next()) {
      // ...
    }
In this case, the lifetime of `x` is scoped to the entire `for` statement and
is only disposed when control leaves the loop due to `break`, `return`,
`throw`, or when the loop condition is false.
In addition to `for` statements, both declarations can also be used in
`for..of` statements:
    ts
    function * g() {
      yield createResource1();
      yield createResource2();
    }
    for (using x of g()) {
      // ...
    }
Here, `x` is disposed at the end of _each iteration of the loop_ , and is then
reinitialized with the next value. This is especially useful when consuming
resources produced one at a time by a generator.
## `using` and `await using` in older runtimes
`using` and `await using` declarations can be used when targeting older
ECMAScript editions as long as you are using a compatible polyfill for
`Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in
recent editions of NodeJS.
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
### [Nightly BuildsHow to use a nightly build of
TypeScript](/docs/handbook/nightly-builds.html)
The TypeScript docs are an open source project. Help us improve these pages
[by sending a Pull Request](https://github.com/microsoft/TypeScript-
Website/blob/v2/packages/documentation/copy/en/reference/Variable
Declarations.md) ‚ù§
Contributors to this page:  
DR
OT
NS
VR
BC
24+
Last updated: Sep 16, 2024  

# Download TypeScript
TypeScript can be installed through three installation routes depending on how
you intend to use it: an npm module, a NuGet package or a Visual Studio
Extension.
If you are using Node.js, you want the npm version. If you are using MSBuild
in your project, you want the NuGet package or Visual Studio extension.
## TypeScript in Your Project
Having TypeScript set up on a per-project basis lets you have many projects
with many different versions of TypeScript, this keeps each project working
consistently.
### via npm
TypeScript is available as a [package on the npm
registry](https://www.npmjs.com/package/typescript) available as
`"typescript"`.
You will need a copy of [Node.js](https://nodejs.org/en/ "Link to the node.js
project") as an environment to run the package. Then you use a dependency
manager like [npm](https://www.npmjs.com/ "Link to the npm package manager"),
[yarn](https://yarnpkg.com/ "Link to the yarn package manager") or
[pnpm](https://pnpm.js.org/ "Link to the pnpm package manager") to download
TypeScript into your project.
`npm install typescript --save-dev`  
npm yarn pnpm
All of these dependency managers support lockfiles, ensuring that everyone on
your team is using the same version of the language. You can then run the
TypeScript compiler using one of the following commands:
`npx tsc`  
npm yarn pnpm
### with Visual Studio
For most project types, you can get TypeScript as a package in Nuget for your
MSBuild projects, for example an ASP.NET Core app.
When using Nuget, you can [install TypeScript through Visual
Studio](https://learn.microsoft.com/visualstudio/javascript/tutorial-aspnet-
with-typescript) using:
  * The Manage NuGet Packages window (which you can get to by right-clicking on a project node)
  * The Nuget Package Manager Console (found in Tools > NuGet Package Manager > Package Manager Console) and then running:  
`Install-Package Microsoft.TypeScript.MSBuild`
For project types which don't support Nuget, you can use the [ TypeScript
Visual Studio
extension](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494).
You can [install the
extension](https://learn.microsoft.com/visualstudio/ide/finding-and-using-
visual-studio-extensions) using `Extensions > Manage Extensions` in Visual
Studio.
The examples below are for more advanced use cases.
## Globally Installing TypeScript
It can be handy to have TypeScript available across all projects, often to
test one-off ideas. Long-term, codebases should prefer a project-wide
installation over a global install so that they can benefit from reproducible
builds across different machines.
### via npm
You can use npm to install TypeScript globally, this means that you can use
the `tsc` command anywhere in your terminal.
To do this, run `npm install -g typescript`. This will install the latest
version (currently 5.6).
### via Visual Studio Marketplace
You can install TypeScript as a Visual Studio extension, which will allow you
to use TypeScript across many MSBuild projects in Visual Studio.
The latest version is available [in the Visual Studio
Marketplace](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-494
"Link to the Visual Studio Marketplace for the TypeScript MSBuild extension").
## Working with TypeScript-compatible transpilers
There are other tools which convert TypeScript files to JavaScript files. You
might use these tools for speed or consistency with your existing build
tooling.
Each of these projects handle the file conversion, but do not handle the type-
checking aspects of the TypeScript compiler. So it's likely that you will
still need to keep the above TypeScript dependency around, and you will want
to enable [`isolatedModules`](/tsconfig/#isolatedModules).
### Babel
[Babel](https://babeljs.io/) is a very popular JavaScript transpiler which
supports TypeScript files via the plugin [@babel/plugin-transform-
typescript](https://babeljs.io/docs/en/babel-preset-typescript#docsNav).
### swc
[swc](https://swc-project.github.io/docs/installation/) is a fast transpiler
created in Rust which supports many of Babel's features including TypeScript.
### Sucrase
[Sucrase](https://github.com/alangpierce/sucrase#sucrase/) is a Babel fork
focused on speed for using in development mode. Sucrase supports TypeScript
natively.
## Next Steps
#### Get Started
  * [JS to TS](/docs/handbook/typescript-in-5-minutes.html)
  * [New to Programming](/docs/handbook/typescript-from-scratch.html)
  * [OOP to JS](/docs/handbook/typescript-in-5-minutes-oop.html)
  * [Functional to JS](/docs/handbook/typescript-in-5-minutes-func.html)
  * [Installation](/download/)
#### Handbook
  * [Everyday Types](/docs/handbook/2/everyday-types.html)
  * [Creating Types from Types](/docs/handbook/2/types-from-types.html)
  * [Object Types](/docs/handbook/2/objects.html)
  * [Variable Declarations](/docs/handbook/variable-declarations.html)
  * [More on Functions](/docs/handbook/2/functions.html)
#### Tools
  * [Playground](/play/)
  * [TSConfig Reference](/tsconfig/)
#### Release Notes
  * [What's new in 5.6](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/)
#### Tutorials
  * [ASP.NET](/docs/handbook/asp-net-core.html)
  * [Migrating from JS](/docs/handbook/migrating-from-javascript.html)
  * [Working with the DOM](/docs/handbook/dom-manipulation.html)
  * [React & Webpack](/docs/handbook/react-&-webpack.html)
# TypeScript is **JavaScript with syntax for types.**
TypeScript is a strongly typed programming language that builds on JavaScript,
giving you better tooling at any scale.
[Try TypeScript NowOnline or via npm](/download)
  * Editor Checks
  * Auto-complete
  * Interfaces
  * JSX
    ts
    const user = {
      firstName: "Angela",
      lastName: "Davis",
      role: "Professor",
    }
    console.log(user.name)
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
    ts
    const user = {
      firstName: "Angela",
      lastName: "Davis",
      role: "Professor",
    }
    console.log(user.name)
    Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.
[TypeScript 5.6](https://devblogs.microsoft.com/typescript/announcing-
typescript-5-6/) is now available
## What is TypeScript?
### JavaScript and More
TypeScript adds additional syntax to JavaScript to support a **tighter
integration with your editor**. Catch errors early in your editor.
### A Result You Can Trust
TypeScript code converts to JavaScript, which **runs anywhere JavaScript
runs** : In a browser, on Node.js or Deno and in your apps.
### Safety at Scale
TypeScript understands JavaScript and uses **type inference to give you great
tooling** without additional code.
## Get Started
[HandbookLearn the language](/docs/handbook/intro.html)
[PlaygroundTry in your browser](/play)
[DownloadInstall TypeScript](/download/)
## Adopt TypeScript Gradually
Apply types to your JavaScript project incrementally, **each step improves
editor support** and improves your codebase.
Let's take this incorrect JavaScript code, and see how **TypeScript can catch
mistakes in your editor**.
    js
    function compact(arr) {
        if (orr.length > 10)
            return arr.trim(0, 10)
        return arr
    }
No editor warnings in JavaScript files  
This code crashes at runtime!
JavaScript file
    js
    // @ts-check
    function compact(arr) {
      if (orr.length > 10)
    Cannot find name 'orr'.2304Cannot find name 'orr'.
        return arr.trim(0, 10)
      return arr
    }
Adding this to a JS file shows errors in your editor
the param is arr, not orr!
JavaScript with TS Check
    js
    // @ts-check
    /** @param {any[]} arr */
    function compact(arr) {
        if (arr.length > 10)
          return arr.trim(0, 10)
    Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.
        return arr
      }
Using JSDoc to give type information
Now TS has found a bad call. Arrays have slice, not trim.
JavaScript with JSDoc
    ts
    function compact(arr: string[]) {
      if (arr.length > 10)
        return arr.slice(0, 10)
      return arr
    }
TypeScript adds natural syntax for providing types
TypeScript file
### Describe Your Data
**Describe the shape of objects and functions** in your code.
Making it possible to see **documentation and issues in your editor**.
    ts
    interface Account {
      id: number
      displayName: string
      version: 1
    }
    function welcome(user: Account) {
      console.log(user.id)
    }
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
## TypeScript becomes JavaScript via the delete key.
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**TypeScript file**.
    ts
    type Result = "pass" | "fail"
    function verify(result: Result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**Types are removed**.
    js
    function verify(result) {
      if (result === "pass") {
        console.log("Passed")
      } else {
        console.log("Failed")
      }
    }
**JavaScript file**.
## TypeScript Testimonials
**First** , we were surprised by the number of small bugs we found when
converting our code.
**Second** , we underestimated how powerful the editor integration is.
TypeScript was such a boon to our stability and sanity that we started using
it for all new code within days of starting the conversion.
Felix Rieseberg at Slack covered the transition of their desktop app from
JavaScript to TypeScript in their blog
[Read](https://slack.engineering/typescript-at-slack-a81307fa288d)
### Open Source with TypeScript
[Angular](https://angular.io/)[Vue](https://vuejs.org/)[Jest](https://jestjs.io/)[Redux](https://redux.js.org/)[Ionic](https://ionicframework.com/)[Probot](https://probot.github.io/)[Deno](https://deno.land/)[Vercel](https://github.com/vercel/vercel)[Yarn](https://yarnpkg.com/)[GitHub  
Desktop](https://github.com/desktop/desktop/)
## Loved by Developers
Voted **2nd most loved programming language** in the [Stack Overflow 2020
Developer survey](https://insights.stackoverflow.com/survey/2020#most-loved-
dreaded-and-wanted)
TypeScript was **used by 78%** of the [2020 State of
JS](https://2020.stateofjs.com/en-US/technologies/javascript-flavors/)
respondents, with **93% saying they would use it again**.
TypeScript was given the award for **‚ÄúMost Adopted Technology‚Äù** based on
year-on-year growth.
## Get Started
[HandbookLearn the language](/docs/handbook/intro.html)
[PlaygroundTry in your browser](/play)
[DownloadInstall TypeScript](/download/)
Downloading TypeScript...
  * Version...... 
  * Run
  * Export
    * Tweet link to Playground
    *     * Copy as Markdown Issue
    * Copy as Markdown Link
    * Copy as Markdown Link with Preview
    *     * Open in TypeScript AST Viewer
    * Open in Bug Workbench
    * Open in VSCode TS Playground (alpha)
    *     * Open in CodeSandbox
    * Open in StackBlitz
  * Share
  * ‚á•
[Playground](/play)
A live environment for exploring, learning and sharing TypeScript code. Try
different compiler flags, run through extensive code samples to learn
specifics about how TypeScript works.
[TSConfig Reference](/tsconfig/)
An annotated reference to more than a hundred compiler options available in a
`tsconfig.json` or `jsconfig.json`.
[Cheat Sheets](/cheatsheets)
Quickly look up the syntax for common TypeScript code.
Intro to the TSConfig ReferenceA TSConfig file in a directory indicates that
the directory is the root of a TypeScript or JavaScript project...
## Compiler Options
##### Top Level
  1. `files, `
  2. `extends, `
  3. `include, `
  4. `exclude and `
  5. `references`
#### `"compilerOptions"`
##### Type Checking
  1. `allowUnreachableCode, `
  2. `allowUnusedLabels, `
  3. `alwaysStrict, `
  4. `exactOptionalPropertyTypes, `
  5. `noFallthroughCasesInSwitch, `
  6. `noImplicitAny, `
  7. `noImplicitOverride, `
  8. `noImplicitReturns, `
  9. `noImplicitThis, `
  10. `noPropertyAccessFromIndexSignature, `
  11. `noUncheckedIndexedAccess, `
  12. `noUnusedLocals, `
  13. `noUnusedParameters, `
  14. `strict, `
  15. `strictBindCallApply, `
  16. `strictBuiltinIteratorReturn, `
  17. `strictFunctionTypes, `
  18. `strictNullChecks, `
  19. `strictPropertyInitialization and `
  20. `useUnknownInCatchVariables`
##### Modules
  1. `allowArbitraryExtensions, `
  2. `allowImportingTsExtensions, `
  3. `allowUmdGlobalAccess, `
  4. `baseUrl, `
  5. `customConditions, `
  6. `module, `
  7. `moduleResolution, `
  8. `moduleSuffixes, `
  9. `noResolve, `
  10. `noUncheckedSideEffectImports, `
  11. `paths, `
  12. `resolveJsonModule, `
  13. `resolvePackageJsonExports, `
  14. `resolvePackageJsonImports, `
  15. `rootDir, `
  16. `rootDirs, `
  17. `typeRoots and `
  18. `types`
##### Emit
  1. `declaration, `
  2. `declarationDir, `
  3. `declarationMap, `
  4. `downlevelIteration, `
  5. `emitBOM, `
  6. `emitDeclarationOnly, `
  7. `importHelpers, `
  8. `inlineSourceMap, `
  9. `inlineSources, `
  10. `mapRoot, `
  11. `newLine, `
  12. `noEmit, `
  13. `noEmitHelpers, `
  14. `noEmitOnError, `
  15. `outDir, `
  16. `outFile, `
  17. `preserveConstEnums, `
  18. `removeComments, `
  19. `sourceMap, `
  20. `sourceRoot and `
  21. `stripInternal`
##### JavaScript Support
  1. `allowJs, `
  2. `checkJs and `
  3. `maxNodeModuleJsDepth`
##### Editor Support
  1. `disableSizeLimit and `
  2. `plugins`
##### Interop Constraints
  1. `allowSyntheticDefaultImports, `
  2. `esModuleInterop, `
  3. `forceConsistentCasingInFileNames, `
  4. `isolatedDeclarations, `
  5. `isolatedModules, `
  6. `preserveSymlinks and `
  7. `verbatimModuleSyntax`
##### Backwards Compatibility
  1. `charset, `
  2. `importsNotUsedAsValues, `
  3. `keyofStringsOnly, `
  4. `noImplicitUseStrict, `
  5. `noStrictGenericChecks, `
  6. `out, `
  7. `preserveValueImports, `
  8. `suppressExcessPropertyErrors and `
  9. `suppressImplicitAnyIndexErrors`
##### Language and Environment
  1. `emitDecoratorMetadata, `
  2. `experimentalDecorators, `
  3. `jsx, `
  4. `jsxFactory, `
  5. `jsxFragmentFactory, `
  6. `jsxImportSource, `
  7. `lib, `
  8. `moduleDetection, `
  9. `noLib, `
  10. `reactNamespace, `
  11. `target and `
  12. `useDefineForClassFields`
##### Compiler Diagnostics
  1. `diagnostics, `
  2. `explainFiles, `
  3. `extendedDiagnostics, `
  4. `generateCpuProfile, `
  5. `generateTrace, `
  6. `listEmittedFiles, `
  7. `listFiles, `
  8. `noCheck and `
  9. `traceResolution`
##### Projects
  1. `composite, `
  2. `disableReferencedProjectLoad, `
  3. `disableSolutionSearching, `
  4. `disableSourceOfProjectReferenceRedirect, `
  5. `incremental and `
  6. `tsBuildInfoFile`
##### Output Formatting
  1. `noErrorTruncation, `
  2. `preserveWatchOutput and `
  3. `pretty`
##### Completeness
  1. `skipDefaultLibCheck and `
  2. `skipLibCheck`
##### Command Line
##### Watch Options
  1. `assumeChangesOnlyAffectDirectDependencies`
#### `"watchOptions"`
##### watchOptions
  1. `watchFile, `
  2. `watchDirectory, `
  3. `fallbackPolling, `
  4. `synchronousWatchDirectory, `
  5. `excludeDirectories and `
  6. `excludeFiles`
#### `"typeAcquisition"`
##### typeAcquisition
  1. `enable, `
  2. `include, `
  3. `exclude and `
  4. `disableFilenameBasedTypeAcquisition`
### Root Fields
Starting up are the root options in the TSConfig - these options relate to how
your TypeScript or JavaScript project is set up.
### # Files - `files`
Specifies an allowlist of files to include in the program. An error occurs if
any of the files can‚Äôt be found.
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {},
      "[files](https://www.typescriptlang.org/tsconfig#files)": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "tsc.ts"
      ]
    }
This is useful when you only have a small number of files and don‚Äôt need to
use a glob to reference many files. If you need that then use `include`.
  * Default:
`false`
  * Related:
    * `include`
    * `exclude`
### # Extends - `extends`
The value of `extends` is a string which contains a path to another
configuration file to inherit from. The path may use Node.js style resolution.
The configuration from the base file are loaded first, then overridden by
those in the inheriting config file. All relative paths found in the
configuration file will be resolved relative to the configuration file they
originated in.
It‚Äôs worth noting that `files`, `include`, and `exclude` from the inheriting
config file _overwrite_ those from the base config file, and that circularity
between configuration files is not allowed.
Currently, the only top-level property that is excluded from inheritance is
`references`.
##### Example
`configs/base.json`:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny)": true,
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": true
      }
    }
`tsconfig.json`:
    {
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./configs/base",
      "[files](https://www.typescriptlang.org/tsconfig#files)": ["main.ts", "supplemental.ts"]
    }
`tsconfig.nostrictnull.json`:
    {
      "[extends](https://www.typescriptlang.org/tsconfig#extends)": "./tsconfig",
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)": false
      }
    }
Properties with relative paths found in the configuration file, which aren‚Äôt
excluded from inheritance, will be resolved relative to the configuration file
they originated in.
  * Default:
`false`
  * Released:
[2.1](/docs/handbook/release-notes/typescript-2-1.html)
### # Include - `include`
Specifies an array of filenames or patterns to include in the program. These
filenames are resolved relative to the directory containing the
`tsconfig.json` file.
    json
    {
      "include": ["src/**/*", "tests/**/*"]
    }
Which would include:
    .
    ‚îú‚îÄ‚îÄ scripts                ‚®Ø
    ‚îÇ   ‚îú‚îÄ‚îÄ lint.ts            ‚®Ø
    ‚îÇ   ‚îú‚îÄ‚îÄ update_deps.ts     ‚®Ø
    ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts           ‚®Ø
    ‚îú‚îÄ‚îÄ src                    ‚úì
    ‚îÇ   ‚îú‚îÄ‚îÄ client             ‚úì
    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ index.ts      ‚úì
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ utils.ts      ‚úì
    ‚îÇ   ‚îú‚îÄ‚îÄ server             ‚úì
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ index.ts      ‚úì
    ‚îú‚îÄ‚îÄ tests                  ‚úì
    ‚îÇ   ‚îú‚îÄ‚îÄ app.test.ts        ‚úì
    ‚îÇ   ‚îú‚îÄ‚îÄ utils.ts           ‚úì
    ‚îÇ   ‚îî‚îÄ‚îÄ tests.d.ts         ‚úì
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îî‚îÄ‚îÄ yarn.lock
`include` and `exclude` support wildcard characters to make glob patterns:
  * `*` matches zero or more characters (excluding directory separators)
  * `?` matches any one character (excluding directory separators)
  * `**/` matches any directory nested to any level
If the last path segment in a pattern does not contain a file extension or
wildcard character, then it is treated as a directory, and files with
supported extensions inside that directory are included (e.g. `.ts`, `.tsx`,
and `.d.ts` by default, with `.js` and `.jsx` if `allowJs` is set to true).
  * Default:
`[]` if `files` is specified; `**/*` otherwise.
  * Related:
    * `files`
    * `exclude`
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Exclude - `exclude`
Specifies an array of filenames or patterns that should be skipped when
resolving `include`.
**Important** : `exclude` _only_ changes which files are included as a result
of the `include` setting. A file specified by `exclude` can still become part
of your codebase due to an `import` statement in your code, a `types`
inclusion, a `/// <reference` directive, or being specified in the `files`
list.
It is not a mechanism that **prevents** a file from being included in the
codebase - it simply changes what the `include` setting finds.
  * Default:
node_modules bower_components jspm_packages `outDir`
  * Related:
    * `include`
    * `files`
### # References - `references`
Project references are a way to structure your TypeScript programs into
smaller pieces. Using Project References can greatly improve build and editor
interaction times, enforce logical separation between components, and organize
your code in new and improved ways.
You can read more about how references works in the [Project
References](/docs/handbook/project-references.html) section of the handbook
  * Default:
`false`
### Compiler Options
These options make up the bulk of TypeScript‚Äôs configuration and it covers how
the language should work.
## #Type Checking
### # Allow Unreachable Code - `allowUnreachableCode`
When:
  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unreachable code is ignored
  * `false` raises compiler errors about unreachable code
These warnings are only about code which is provably unreachable due to the
use of JavaScript syntax, for example:
    ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    }
With `"allowUnreachableCode": false`:
    ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    Unreachable code detected.7027Unreachable code detected.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMaBQIIBDAG2LgHcBVAO2kkIGMALQgI2MgGE4ATSVAGYlEkXAICu1BgBcAlnGqgB1ABTVU1cQFtWMAJSgA3rlChZA0GtAA+UAFYDx06brTx0RdOjjIAbhOgAL6gkMQiRgEukG4eSsJ+AYEBru6e3gmBQA)
This does not affect errors on the basis of code which _appears_ to be
unreachable due to type analysis.
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # Allow Unused Labels - `allowUnusedLabels`
When:
  * `undefined` (default) provide suggestions as warnings to editors
  * `true` unused labels are ignored
  * `false` raises compiler errors about unused labels
Labels are very rare in JavaScript and typically indicate an attempt to write
an object literal:
    ts
    function verifyAge(age: number) {
      // Forgot 'return' statement
      if (age > 18) {
        verified: true;
    Unused label.7028Unused label.
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYBMAOAUCBAIYA2JcA7gKoB2AropACYAyRARpCSqAGamM8vOjQDGAFwCWcGqABuMSbwCeAQQDmkABRFNqegFtO0AJSgA3nlChCAMQTq440AHJokcXWg0XoROKJxSANIGnErUCVQHU1QAD5QAEYcM0trawVoJUlmVHFoOkgAbgiAXzxSoA)
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # Always Strict - `alwaysStrict`
Ensures that your files are parsed in the ECMAScript strict mode, and emit
‚Äúuse strict‚Äù for each source file.
[ECMAScript
strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode)
mode was introduced in ES5 and provides behavior tweaks to the runtime of the
JavaScript engine to improve performance, and makes a set of errors throw
instead of silently ignoring them.
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[2.1](/docs/handbook/release-notes/typescript-2-1.html)
### # Exact Optional Property Types - `exactOptionalPropertyTypes`
With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules
around how it handles properties on `type` or `interfaces` which have a `?`
prefix.
For example, this interface declares that there is a property which can be one
of two strings: ‚Äòdark‚Äô or ‚Äòlight‚Äô or it should not be in the object.
    ts
    interface UserDefaults {
      // The absence of a value represents 'system'
      colorThemeOverride?: "dark" | "light";
    }
Without this flag enabled, there are three values which you can set
`colorThemeOverride` to be: ‚Äúdark‚Äù, ‚Äúlight‚Äù and `undefined`.
Setting the value to `undefined` will allow most JavaScript runtime checks for
the existence to fail, which is effectively falsy. However, this isn‚Äôt quite
accurate; `colorThemeOverride: undefined` is not the same as
`colorThemeOverride` not being defined. For example, `"colorThemeOverride" in
settings` would have different behavior with `undefined` as the key compared
to not being defined.
`exactOptionalPropertyTypes` makes TypeScript truly enforce the definition
provided as an optional property:
    ts
    const settings = getUserSettings();
    settings.colorThemeOverride = "dark";
    settings.colorThemeOverride = "light";
    // But not:
    settings.colorThemeOverride = undefined;
    Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.2412Type 'undefined' is not assignable to type '"dark" | "light"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9efACwBGXkww5EFAGYJIoAKoMKAEUgKArvkQNQAbyahQ8LPizEaAC0gBbSMgBu7DABNIAfh4Aid7DEANa+oAA+oL74GADmNoi+ANxMAL5MnvD4gUpy2jhI2DigMZCIqhQAyqWYODEMABQAlDzlxJo6egzJrAC0ffDaiH09TOY4DIigaog1daAAvMWlrVUz0nVNydOzDAB05pbWdo4ubp4LkQHBSUzb63sHVrYOTq7ExB5Ki1Gx8TcsYAAQoNQDgsIguLdqvd9hYnsdXmcvqA8p45NJIO5EkA)
  * Recommended
  * Released:
[4.4](/docs/handbook/release-notes/typescript-4-4.html)
### # No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`
Report errors for fallthrough cases in switch statements. Ensures that any
non-empty case inside a switch statement includes either `break`, `return`, or
`throw`. This means you won‚Äôt accidentally ship a case fallthrough bug.
    ts
    const a: number = 6;
    switch (a) {
      case 0:
    Fallthrough case in switch.7029Fallthrough case in switch.
        console.log("even");
      case 1:
        console.log("odd");
        break;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsDEEMA2iAuALATtArgczQMLwDOApsQJKQDKA7gJYoDGaAUCBKRlhsQFygA7AAYATAE5WTaJGIpQ8AZGwBbAEZdQAXlAA2ANytWxBszSgAFPACUoAN6tQoJiVKhhfR0+czi0RKQAdIjQuBYARKQAbqSQ4daGTi5koACMnt4+sv5BIWHh0AAmhfGJ3moYpPAA1oYAvkA)
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # No Implicit Any - `noImplicitAny`
In some cases where no type annotations are present, TypeScript will fall back
to a type of `any` for a variable when it cannot infer the type.
This can cause some errors to be missed, for example:
    ts
    function fn(s) {
      // No error?
      console.log(s.subtr(3));
    }
    fn(42);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0kpkAFJQJSgBvWqFAhQAOWihqAJxnQZAfmGh07StGTUAdMmgBzHtsoMARlhlcAzL14BuWgF963ACwAme0A)
Turning on `noImplicitAny` however TypeScript will issue an error whenever it
would have inferred `any`:
    ts
    function fn(s) {
    Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.
      console.log(s.subtr(3));
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYBQAzAVwDsBjAFwEs5jR9iAKRASlAG9dRRSbE4AbSADp+cAOZMhiQgCNy0BgGZmzANy4AvkA)
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
### # No Implicit Override - `noImplicitOverride`
When working with classes which use inheritance, it‚Äôs possible for a sub-class
to get ‚Äúout of sync‚Äù with the functions it overloads when they are renamed in
the base class.
For example, imagine you are modeling a music album syncing system:
    ts
    class Album {
      download() {
        // Default behavior
      }
    }
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaATA9gO4B2I+YuAFAJQbY7QD0j0AIgKYBmYSIALtATsAFmABuAS3wAnegF9MCzKEgwAyqOntc8ZGnYAPPu2K4Yu1HRwESZCjSsNm0APJj206RNztoffNAA5uwCEsScAZzS+GgoYMQAntAQ+EjSwOwQ8opAA)
Then when you add support for machine-learning generated playlists, you
refactor the `Album` class to have a ‚Äòsetup‚Äô function instead:
    ts
    class Album {
      setup() {
        // Default behavior
      }
    }
    class MLAlbum extends Album {
      setup() {
        // Override to get info from algorithm
      }
    }
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCICMCuBbaBvAUNaECmALkgA4AUAlBtjtAPS3QAieAZmEiAdAngBZgA3AJYB7AE7UAvpmmZQkGAFkAMvGRo8ADwJ4AdgBMYa1FRz4iZSlhp0GAeQF4xYofrzQCI6AHNC0IbosXixiImhgIN7iQgS8KFIymHLgUNAAyvxiePrGGtp6hnCIJtbQ+iIA7rogImD6FKY09NAOTi5uHl6+XAFB0CFh0ChgugCeuCJIYsB4EAmSQA)
In this case, TypeScript has provided no warning that `download` on
`SharedAlbum` _expected_ to override a function in the base class.
Using `noImplicitOverride` you can ensure that the sub-classes never go out of
sync, by ensuring that functions which override include the keyword
`override`.
The following example has `noImplicitOverride` enabled, and you can see the
error received when `override` is missing:
    ts
    class Album {
      setup() {}
    }
    class MLAlbum extends Album {
      override setup() {}
    }
    class SharedAlbum extends Album {
      setup() {}
    This member must have an 'override' modifier because it overrides a member in the base class 'Album'.4114This member must have an 'override' modifier because it overrides a member in the base class 'Album'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg7cvWQENGjUAEFkAIwCu8UAG9KoUIwJZJiABQBKOQF9Ke3gKGgAsgBkxUmQQAeWApDLDL0uQtDRCJcgSUq1Wrr6lIaCwgDKABb8RARkLtZ2Dk6iEq7yisqqGtqyejpAA)
  * Released:
[4.3](/docs/handbook/release-notes/typescript-4-3.html)
### # No Implicit Returns - `noImplicitReturns`
When enabled, TypeScript will check all code paths in a function to ensure
they return a value.
    ts
    function lookupHeadphonesManufacturer(color: "blue" | "black"): string {
    Function lacks ending return statement and return type does not include 'undefined'.2366Function lacks ending return statement and return type does not include 'undefined'.
      if (color === "blue") {
        return "beats";
      } else {
        ("bose");
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsX0bWgFABmArgHYDGALgJZzmgA2ccA1qQA4ASkAhgBNOACwaREAWT7lSxPjVLQYACkpwW0VACIARk1KQtoAD6hdTeWy0BKVImrRa5AOagA3oVChaxUKvUIoAC8IWZ6Bjbunl6gStSKjLr81IhaANzRAL6gkEyIkFExfrpw+TYZXpmEmUA)
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # No Implicit This - `noImplicitThis`
Raise error on ‚Äòthis‚Äô expressions with an implied ‚Äòany‚Äô type.
For example, the class below returns a function which tries to access
`this.width` and `this.height` ‚Äì but the context for `this` inside the
function inside `getAreaFunction` is not the instance of the Rectangle.
    ts
    class Rectangle {
      width: number;
      height: number;
      constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
      }
      getAreaFunction() {
        return function () {
          return this.width * this.height;
    'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.2683  
    2683'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.
        };
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcBmAUAMYA2AhooqAEqQEAuJAdgOZGSgDeeooA7gJYATWgAtUDAK4BbAEYwA3F1DDIfJsNpips6AsUE4DRLWji6CABT8ho0BJkwANEpVqNtrTACUHRdxF9EADorEVAAXl5BEQVuP2EAwOVVdXDnZNoY0ABfPEUmSFoAQWhIEgAxcQY6PgNzb05Y0BLacWgGUAAzSuqDUDqfRu5m1vb-IJDhUAAqUDHEl3VM7izMnKygA)
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # No Property Access From Index Signature -
`noPropertyAccessFromIndexSignature`
This setting ensures consistency between accessing a field via the ‚Äúdot‚Äù
(`obj.key`) syntax, and ‚Äúindexed‚Äù (`obj["key"]`) and the way which the
property is declared in the type.
Without this flag, TypeScript will allow you to use the dot syntax to access
fields which are not defined:
    ts
    interface GameSettings {
      // Known up-front properties
      speed: "fast" | "medium" | "slow";
      quality: "high" | "low";
      // Assume anything unknown to the interface
      // is a string.
      [key: string]: string;
    }
    const settings = getSettings();
    settings.speed;
    (property) GameSettings.speed: "fast" | "medium" | "slow"
    settings.quality;
    (property) GameSettings.quality: "high" | "low"
    // Unknown key accessors are allowed on
    // this object, and are `string`
    settings.username;
    (index) GameSettings[string]: string
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgAmkBjAGwENpJQAzAVwDsCAXASzltAHNIGBlL529ogAUASlQBxEgFtIvBv0EBubCFABaDQWoMNa7E1oMYlEgQqSZchYlABvbKFCqA0rTgB3NtQAOayvENQb3hvGGZIRAdQRFDIXFQAIhNEBgTQAB9QBJlcJmopNMyExCIPBOVHAEdqEiImBgBPRIALJnZmwqzS93LsKNUAQUREfIoSWgaGVoFQOgBrN09QBjhl5ooDI2gTM36wJhsSaIZoA3YAOiiAbTnIJuPTgQBdVBTH9mUAXz6CVhTovhnGwAXg4XCsQNEykQgIEiHOMUgcWUqkcaNAAD0APzYGHyIHnaq1eoNFFgdGObF9VQAVVoCw8bFuDVApjMwwQh3IrKI3TioFYKjAUwOAoARgArQgMAA0rNouFZ3IABm8zsrcbDBOdqDDoLRpJAyRTKVigA)
Turning the flag on will raise an error because the unknown field uses dot
syntax instead of indexed syntax.
    ts
    const settings = getSettings();
    settings.speed;
    settings.quality;
    // This would need to be settings["username"];
    settings.username;
    Property 'username' comes from an index signature, so it must be accessed with ['username'].4111Property 'username' comes from an index signature, so it must be accessed with ['username'].
    (index) GameSettings[string]: string
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYsCgQQHZwAK8ADjAC4CeAggMZ2SKIBi8AtgJL4AmkAHgGUAlgHN8AQwoBXaJGx86AGwlzQAM2n46FYXHyhRkCoOO78oxAAoAlKgDiE9pFMVzlgNzZh+CjHUSjKCOzq7uiKAA3tigoIjkkDyoAEQBiBTJoAA+oMnOPMLS7Jk5yYhKcADuyV6xAI7SEkrC1CkAFmJtJbkV1bWgANoA1pBUqOnQPqIAuuMUkxZeAL64YAC0G3TSFBtr2HT66XFmUxEAvIbGYae2XognFogAdPGQiXcPlk8NTS1UXqtQAAVDoRSpwaRKHigfBvaEUOCgABGkGOblOA2S0nu0EkzmS0w+6MeT2xMDxkC8eFiNNAAD0APxAA)
The goal of this flag is to signal intent in your calling syntax about how
certain you are this property exists.
  * Released:
[4.2](/docs/handbook/release-notes/typescript-4-2.html)
### # No Unchecked Indexed Access - `noUncheckedIndexedAccess`
TypeScript has a way to describe objects which have unknown keys but known
values on an object, via index signatures.
    ts
    interface EnvironmentVars {
      NAME: string;
      OS: string;
      // Unknown properties are covered by this index signature.
      [propName: string]: string;
    }
    declare const env: EnvironmentVars;
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
    const os: string
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    const nodeEnv: string
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL5yvggANhbIViDcyEQYnOhYuAREYKQUQjSKyAAiEMUWDnCU-l4mMjTlleTO5MmEyAC8VZhRzGxC42DIOJQL1VHiQh30yAB6APxyHQw4G4UlkXYANE5hG449cGHkKDgwbu4oPn87SU5CCIXCkSeHiIyGAGy8ZTwoN892QcC46VG62Qml8dXmiwwyxEnVQAH1UAxiAclEczkA)
Turning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared
field in the type.
    ts
    declare const env: EnvironmentVars;
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
    const os: string
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    const nodeEnv: string | undefined
    [Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKIgG7CgexAWwnADU4oBnZAbwChlkA5AQQFlUAuZcsKUAcwDcdZAHkAyp268QgmsID085AFUQAaxA4A7iGQAHXHuhhgESmRQIcGaBAAmyAEYBPZGAAWwSqDsQAHlzAfCBwYACuUBAAdMIA2gY4egxwhJI8-AC6adKyAL40isgAApqqCO4QCGr2AJIgvn72TAhI5OQFSgC03QhhYN2dNL4IADYWyFYg3MhEGJzoWLgERGCkFEIdyAAilWORDnCU-l4mMjST0+TO5MmEyAC8M5hRzGxCF2DIOJSPs1HiQkK9GQAD0APxyQoMHCfYZ7ewAGicfSclTgYXIKBwMDcFWQPn8m3IQRC4UiSI8RHxny8EzwxN8+2QcC46TOH2Qml8CweTwwLxEW1QAH1UAxiIClMDwUA)
  * Released:
[4.1](/docs/handbook/release-notes/typescript-4-1.html)
### # No Unused Locals - `noUnusedLocals`
Report errors on unused local variables.
    ts
    const createKeyboard = (modelID: number) => {
      const defaultModelID = 23;
    'defaultModelID' is declared but its value is never read.6133'defaultModelID' is declared but its value is never read.
      return { type: "keyboard", modelID };
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBsAjAMwtHbSRIAuo25FLh4oA0igCeAI2i5yaUAF5QACgC20NCnwBJACL1EaqRQCUSgHygA3kVD8uvUFoBmuBPh4BZTdv1LQACYWAG47UEEeBHJIG1AeCQAHFHoAIgBrSRk5NFSAGlANLV09UABfMIqgA)
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # No Unused Parameters - `noUnusedParameters`
Report errors on unused parameters in functions.
    ts
    const createDefaultKeyboard = (modelID: number) => {
    'modelID' is declared but its value is never read.6133'modelID' is declared but its value is never read.
      const defaultModelID = 23;
      return { type: "keyboard", modelID: defaultModelID };
    };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATACgQwE5YLYoAuKOSAUCBKTtGQFygBsAjAMxvkDG0kSRoLjhRYSAERQAzLAgA2RANIoAngCNouNKAC8oABT5oaFLICSYxonyrSASh0A+UAG9yoQb36hj0uUQCyRibmOqAATGwA3G6gwkQIOJAuoETKAA4ojABEANYq6ppZADSghsZmFt5SMvKB5SEAvtFNQA)
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Strict - `strict`
The `strict` flag enables a wide range of type checking behavior that results
in stronger guarantees of program correctness. Turning this on is equivalent
to enabling all of the _strict mode family_ options, which are outlined below.
You can then turn off individual strict mode family checks as needed.
Future versions of TypeScript may introduce additional stricter checking under
this flag, so upgrades of TypeScript might result in new type errors in your
program. When appropriate and possible, a corresponding flag will be added to
disable that behavior.
  * Recommended
  * Related:
    * `alwaysStrict`
    * `strictNullChecks`
    * `strictBindCallApply`
    * `strictFunctionTypes`
    * `strictPropertyInitialization`
    * `noImplicitAny`
    * `noImplicitThis`
    * `useUnknownInCatchVariables`
  * Released:
[2.3](/docs/handbook/release-notes/typescript-2-3.html)
### # Strict Bind Call Apply - `strictBindCallApply`
When set, TypeScript will check that the built-in methods of functions `call`,
`bind`, and `apply` are invoked with correct argument for the underlying
function:
    ts
    // With strictBindCallApply on
    function fn(x: string) {
      return parseInt(x);
    }
    const n1 = fn.call(undefined, "10");
    const n2 = fn.call(undefined, false);
    Argument of type 'boolean' is not assignable to parameter of type 'string'.2345Argument of type 'boolean' is not assignable to parameter of type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcocArgKYBQIEDssA9rJDQEwBmACwBWJizAB1eNAAWoGAmRoseQqXIVQndEwBmddMng7Qe9AAoAHjUUYA5gEpQAbyahQsBtDqx0oElweBgBJdGhrRwBuJgBfcUQdGFB0AEZQAF4zdAA6RAJ8C0NMBj0MBkwAGlAAIlSABhrohKToFL5M7LyCoqxS8qqzAkgGaKA)
Otherwise, these functions accept any arguments and will return `any`:
    ts
    // With strictBindCallApply off
    function fn(x: string) {
      return parseInt(x);
    }
    // Note: No error; return type is 'any'
    const n = fn.call(undefined, false);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BC8B2ATAwgQwDb4CCADifgJ4BcoAZgZAKYBQzIoA6vNABagwJkaLHkKlyFUAHtatZrQCu6ZPCno66ABQAPGgIwBzAJSgA3s1ChYjaAtjqSuWEwCS6aDqMBuZgF9W7AByUtCMNMGgjLCwUrBeVjZ26tAUJIyg8JCgAOS46BTZzIhqMKDqALwaAHSIBPiaSpiMtBiMmAA0dAyM3kA)
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[3.2](/docs/handbook/release-notes/typescript-3-2.html)
### # strictBuiltinIteratorReturn - `strictBuiltinIteratorReturn`
Built-in iterators are instantiated with a `TReturn` type of undefined instead
of `any`.
  * Recommended
  * Default:
`false`, unless `strict` is set
### # Strict Function Types - `strictFunctionTypes`
When enabled, this flag causes functions parameters to be checked more
correctly.
Here‚Äôs a basic example with `strictFunctionTypes` off:
    ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
    type StringOrNumberFunc = (ns: string | number) => void;
    // Unsafe assignment
    let func: StringOrNumberFunc = fn;
    // Unsafe call - will crash
    func(10);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BiBXAds+B7DAVATwAcBTSALlADMBDAG0lIChrNs8aMAKADypgIMAcwCUoAN7NQoRHkg56pAHT0cw7gCIAEqXpqANKE2gA1KF7LoOADI4A7qVgBhWk26jRAbmYBfZszQJKSgAMpw8CIA8rAAcmgAtgBGTuhYoAC8oNwYlKCCkcKgAD6gGIkpsOIZAHygAG448AAmPswgoACqubTUIW6Q8MIYCaQY0MxK0DTsVOFCwjHxyansmVw+Hd2QvSGIDPSgALSg9vD6srBuABas7NwAjAAM3kA)
With `strictFunctionTypes` _on_ , the error is correctly detected:
    ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
    type StringOrNumberFunc = (ns: string | number) => void;
    // Unsafe assignment is prevented
    let func: StringOrNumberFunc = fn;
    Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.2322Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.
      Types of parameters 'x' and 'ns' are incompatible.
        Type 'string | number' is not assignable to type 'string'.
          Type 'number' is not assignable to type 'string'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFADMBXAOwGMAXASziNDyIAoAPVRM6CogcwEpQBvHKFAlqiOABtIAOnFxO9AEQAJSONkAaUAtABqUIylk4AGTgB3GAGEAhokj1u3ANw4AvjhxkAngAdIoAGU2Dk4AeWgAOQIAWwAjGAAxYhJQAF5QeiIUUFZ2LlAAH1AiGPjoXlSAPlAANzgKABMXHBBQAFUs6zx-W0QKTiJoyCIyUApEUB9oSBrhskgGnElRwlJUILywyNLE5LTaIicgA)
During development of this feature, we discovered a large number of inherently
unsafe class hierarchies, including some in the DOM. Because of this, the
setting only applies to functions written in _function_ syntax, not to those
in _method_ syntax:
    ts
    type Methodish = {
      func(x: string | number): void;
    };
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
    // Ultimately an unsafe assignment, but not detected
    const m: Methodish = {
      func: fn,
    };
    m.func(10);
    [Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshwAsD2ATAlgZwVAvFA3gFBRQBmArgHYDGAFAB4BcUGwATmpQOZQA+UlcgFsARhDYBKZgDckaFAG5CAXyWEKNYGiSUylBs1YduEgsSjUdGJABsIAOhtIutAEQAJCDacAaKK6gAaih6e2AkABkkAHdxAGEAQwwIWgkJJWVCQgB6bKgAVRstIQTgLxAoBN0qDATSaCSMNC5KIQhKYD8RcmABJF6UeAhqMpRCS0pWKCFmOERUTGw8IhINamZSSh8VJSF7NdoARgAGdKA)
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[2.6](/docs/handbook/release-notes/typescript-2-6.html)
### # Strict Null Checks - `strictNullChecks`
When `strictNullChecks` is `false`, `null` and `undefined` are effectively
ignored by the language. This can lead to unexpected errors at runtime.
When `strictNullChecks` is `true`, `null` and `undefined` have their own
distinct types and you‚Äôll get a type error if you try to use them where a
concrete value is expected.
For example with this TypeScript code, `users.find` has no guarantee that it
will actually find a user, but you can write code as though it will:
    ts
    declare const loggedInUsername: string;
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0ByBXANhgwgCwKaIDWkAXKAGYCGGk+AUCBNFbAOb7TkCiAygEwAGAIwBWegBNCGVvlCIA9gDsYoDArYcJASSUBVOrCVUAtvnIwEStgG569RSuig0hyKAC8oANr1QoAG9QYzNyACIAeQAjAE8wgBpQKg5yYX5QAF94v0Dg03NQMIAJfHxYKgSklNAAZnSs+gBdOwdlVXVNfB19Q08XNwA6CnglCQAKMbQASk8APhcBkLkPFbUNLV0DMqWpu0dIBQx8AY6xjo2esoHk-F2gA)
Setting `strictNullChecks` to `true` will raise an error that you have not
made a guarantee that the `loggedInUser` exists before trying to use it.
    ts
    declare const loggedInUsername: string;
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    'loggedInUser' is possibly 'undefined'.18048'loggedInUser' is possibly 'undefined'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME50FYM1QBGADgAYAWUgKBAgBcBDaAc0gdQFEBlNc-nTDhEDaAEsAxgwByAVwA2CgMIALSJIDWiGgBMNClpFCS4AO1GgFcVu10BJMwFVEMM0wC2kVKIlnWANw0NKYWDKByrkigALygANo0oKAA3qDuXqgARADyAEYAnlkANKBM7KjERAC+xUmp6Z7eoFkAEpAwTCVlFaCEoLU0ALpBIeaW1raQDs5RsRFRiAB0AGbiZroAFJtyAJSxAHwRSxnGMedWNnaOLm5Nu0GhiHAKkEuTm5PXszBL5ZAPIA)
The second example failed because the array‚Äôs `find` function looks a bit like
this simplification:
    ts
    // When strictNullChecks: true
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S | undefined;
    };
    // When strictNullChecks: false the undefined is removed from the type system,
    // allowing you to write code which assumes it always found a result
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S;
    };
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Strict Property Initialization - `strictPropertyInitialization`
When set to true, TypeScript will raise an error when a class property was
declared but not set in the constructor.
    ts
    class UserAccount {
      name: string;
      accountType = "user";
      email: string;
    Property 'email' has no initializer and is not definitely assigned in the constructor.2564Property 'email' has no initializer and is not definitely assigned in the constructor.
      address: string | undefined;
      constructor(name: string) {
        this.name = name;
        // Note that this.email is not set
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAUAMYA2AhooqAKqIwCCBBcArgHYAuoA3nqKCyQFtIqRG2gBLFgHMA3D1AkGzdgBUAngAdIoALygARExrR9c+ZAElxREWMmz5JACZPokcrYnTQAH1CsnSAAzSUgnM15GFlFoJgI2BAAKfiFPewBKLnleNgALcUQAOhTtPRK5Xl4QUAA5ODZtPJIOPILCiysiUAK+etAaNnkAXzwhoA)
In the above case:
  * `this.name` is set specifically.
  * `this.accountType` is set by default.
  * `this.email` is not set and raises an error.
  * `this.address` is declared as potentially `undefined` which means it does not have to be set.
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[2.7](/docs/handbook/release-notes/typescript-2-7.html)
### # Use Unknown In Catch Variables - `useUnknownInCatchVariables`
In TypeScript 4.0, support was added to allow changing the type of the
variable in a catch clause from `any` to `unknown`. Allowing for code like:
    ts
    try {
      // ...
    } catch (err: unknown) {
      // We have to verify err is an
      // error before using it as one.
      if (err instanceof Error) {
        console.log(err.message);
      }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFBHUCeoA3m6FAhQAOjFsAvqBLFyoABSxq1AFyhIKdFgCUfAULAB1WKDIEAbiaJpQlugDMeS6qFrRQBRPuHO0LhrD2fiYwtIgA5q5EHu5oiLAi+rT2Cs6uiNBEniSwaCkAosp+uvyCgiRx0GgsIkxo4YrKIgC2rNAE4bDaANz6EpJAA)
This pattern ensures that error handling code becomes more comprehensive
because you cannot guarantee that the object being thrown _is_ a Error
subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled,
then you do not need the additional syntax (`: unknown`) nor a linter rule to
try enforce this behavior.
  * Recommended
  * Default:
`true` if `strict`; `false` otherwise.
  * Related:
    * `strict`
  * Released:
[4.4](/docs/handbook/release-notes/typescript-4-4.html)
## #Modules
### # Allow Arbitrary Extensions - `allowArbitraryExtensions`
In TypeScript 5.0, when an import path ends in an extension that isn‚Äôt a known
JavaScript or TypeScript file extension, the compiler will look for a
declaration file for that path in the form of `{file
basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a
bundler project, you might want to write (or generate) declaration files for
those stylesheets:
    css
    /* app.css */
    .cookie-banner {
      display: none;
    }
    ts
    // app.d.css.ts
    declare const css: {
      cookieBanner: string;
    };
    export default css;
    ts
    // App.tsx
    import styles from "./app.css";
    styles.cookieBanner; // string
By default, this import will raise an error to let you know that TypeScript
doesn‚Äôt understand this file type and your runtime might not support importing
it. But if you‚Äôve configured your runtime or bundler to handle it, you can
suppress the error with the new `--allowArbitraryExtensions` compiler option.
Note that historically, a similar effect has often been achievable by adding a
declaration file named `app.css.d.ts` instead of `app.d.css.ts` \- however,
this just worked through Node‚Äôs `require` resolution rules for CommonJS.
Strictly speaking, the former is interpreted as a declaration file for a
JavaScript file named `app.css.js`. Because relative files imports need to
include extensions in Node‚Äôs ESM support, TypeScript would error on our
example in an ESM file under `--moduleResolution node16` or `nodenext`.
For more information, read up [the proposal for this
feature](https://github.com/microsoft/TypeScript/issues/50133) and [its
corresponding pull
request](https://github.com/microsoft/TypeScript/pull/51435).
### # Allow Importing TS Extensions - `allowImportingTsExtensions`
`--allowImportingTsExtensions` allows TypeScript files to import each other
with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.
This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is
enabled, since these import paths would not be resolvable at runtime in
JavaScript output files. The expectation here is that your resolver (e.g. your
bundler, a runtime, or some other tool) is going to make these imports between
`.ts` files work.
### # Allow Umd Global Access - `allowUmdGlobalAccess`
When set to true, `allowUmdGlobalAccess` lets you access UMD exports as
globals from inside module files. A module file is a file that has imports
and/or exports. Without this flag, using an export from a UMD module requires
an import declaration.
An example use case for this flag would be a web project where you know the
particular library (like jQuery or Lodash) will always be available at
runtime, but you can‚Äôt access it with an import.
  * Released:
[3.5](/docs/handbook/release-notes/typescript-3-5.html)
### # Base URL - `baseUrl`
Sets a base directory from which to resolve bare specifier module names. For
example, in the directory structure:
    project
    ‚îú‚îÄ‚îÄ ex.ts
    ‚îú‚îÄ‚îÄ hello
    ‚îÇ   ‚îî‚îÄ‚îÄ world.ts
    ‚îî‚îÄ‚îÄ tsconfig.json
With `"baseUrl": "./"`, TypeScript will look for files starting at the same
folder as the `tsconfig.json`:
    ts
    import { helloWorld } from "hello/world";
    console.log(helloWorld);
This resolution has higher priority than lookups from `node_modules`.
This feature was designed for use in conjunction with AMD module loaders in
the browser, and is not recommended in any other context. As of TypeScript
4.1, `baseUrl` is no longer required to be set when using `paths`.
### # Custom Conditions - `customConditions`
`--customConditions` takes a list of additional
[conditions](https://nodejs.org/api/packages.html#nested-conditions) that
should succeed when TypeScript resolves from an
[`exports`](https://nodejs.org/api/packages.html#exports) or
[`imports`](https://nodejs.org/api/packages.html#imports) field of a
`package.json`. These conditions are added to whatever existing conditions a
resolver will use by default.
For example, when this field is set in a `tsconfig.json` as so:
    jsonc
    {
      "compilerOptions": {
        "target": "es2022",
        "moduleResolution": "bundler",
        "customConditions": ["my-condition"]
      }
    }
Any time an `exports` or `imports` field is referenced in `package.json`,
TypeScript will consider conditions called `my-condition`.
So when importing from a package with the following `package.json`
    jsonc
    {
      // ...
      "exports": {
        ".": {
          "my-condition": "./foo.mjs",
          "node": "./bar.mjs",
          "import": "./baz.mjs",
          "require": "./biz.mjs"
        }
      }
    }
TypeScript will try to look for files corresponding to `foo.mjs`.
This field is only valid under the `node16`, `nodenext`, and `bundler` options
for `--moduleResolution`.
  * Related:
    * `moduleResolution`
    * `resolvePackageJsonExports`
    * `resolvePackageJsonImports`
### # Module - `module`
Sets the module system for the program. See the [theory behind TypeScript‚Äôs
`module` option](/docs/handbook/modules/theory.html#the-module-output-format)
and [its reference page](/docs/handbook/modules/reference.html#the-module-
compiler-option) for more information. You very likely want `"nodenext"` for
modern Node.js projects and `preserve` or `esnext` for code that will be
bundled.
Changing `module` affects `moduleResolution` which [also has a reference
page](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).
Here‚Äôs some example output for this file:
    ts
    // @filename: index.ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQFDwAeADrgE5E77GgBuysArvADykAArRQAXlABmCgEYALACYA3NRCgAtNux8i2zerBQ4SNJlDREAE3pUC1aKiatQAb268BwsaAC+oJDMuKigAEQUwHiEJGQEYWq0jCxs0ZxEAO64vlI8-EKi4gBUoKpAA)
#### `CommonJS`
    ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAGNZk8A7AK0mzHHtkQCcvYuXUyAA590oAN6gAbgENihUgHkAZgAVUoAL6hlvZKABEAOmA16kdDPrpIBgNyZMpAB4iuYsxdDp4sdaABeaTkFFX8AKlAAJjsgA)
#### `UMD`
    ts
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "./constants"], factory);
        }
    })(function (require, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        const constants_1 = require("./constants");
        exports.twoPi = constants_1.valueOfPi * 2;
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEOX2zHADtZEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNYDSOnEN0kbQG5MmUgA9+LQUZOD08WEtABeMZLS8j4AVKAATNZAA)
#### `AMD`
    ts
    define(["require", "exports", "./constants"], function (require, exports, constants_1) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        exports.twoPi = constants_1.valueOfPi * 2;
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAENl9sxwA7WRAJ1dlck1WQAdO6UAG9QANyrFCpAPIAzAAqpQAX1ByOyUACIAdMADGsRpHRVG6SNoDcmTKQAeA1kKMmh6eLCWgAvOMlpeR8AKlAAJmsgA)
#### `System`
    ts
    System.register(["./constants"], function (exports_1, context_1) {
        "use strict";
        var constants_1, twoPi;
        var __moduleName = context_1 && context_1.id;
        return {
            setters: [
                function (constants_1_1) {
                    constants_1 = constants_1_1;
                }
            ],
            execute: function () {
                exports_1("twoPi", twoPi = constants_1.valueOfPi * 2);
            }
        };
    });
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlEgE9J1TlsxwA7WRAJw9g8k1WQAHHulABvUADcAhsUKkA8gDMACqlABfUEu7JQAIgB0wAMawWdaS3SR9AbkyZSAD2EdRZi6PTxYa0AC8UrLyyv4AVKAATHZAA)
#### `ESNext`
    ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgDtSAPLHcG2RAJ3dnck1WQAO3dKADeoAG4BDYoVIB5AGYAFVKAC+oRV2SgARADpgAY1g1I6KTXSQ9AbkyYGQ9iNPmR6eLFWgAvJIyckq+AFSgAEx2QA)
#### `ES2015`/`ES6`/`ES2020`/`ES2022`
    ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlFMgCYAGARgFZsxwA7WRAJ29m8iZUyAA790oAN6gAbgENihUgHkAZgAVUoAL6hVfZKABEAOmABjWO0jo57dJCMBuTJlIAPMdwmXrE9PCwmqAAvLIKSmrBAFSgNE5AA)
In addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support
for [dynamic `import`s](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import), and
[`import.meta`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further
adds support for [top level `await`](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).
#### `node16`/`nodenext`
Available from 4.7+, the `node16` and `nodenext` modes integrate with Node‚Äôs
[native ECMAScript Module support](https://nodejs.org/api/esm.html). The
emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the
file extension and the value of the `type` setting in the nearest
`package.json`. Module resolution also works differently. You can learn more
in the [handbook](/docs/handbook/esm-node.html) and [Modules
Reference](/docs/handbook/modules/reference.html#node16-nodenext).
#### `preserve`
In `--module preserve`
([added](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-
bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and
exports written in input files are preserved in the output, and CommonJS-style
`import x = require("...")` and `export = ...` statements are emitted as
CommonJS `require` and `module.exports`. In other words, the format of each
individual import or export statement is preserved, rather than being coerced
into a single format for the whole compilation (or even a whole file).
    ts
    import { valueOfPi } from "./constants";
    const constants = require("./constants");
    export const piSquared = valueOfPi * constants.valueOfPi;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlAAcAnUyUmgN1OzHADtZEabYbImVMir90oAN6gmAQ2KFSAeQBmABVSgAvqGV9koAEQA6YAGNYHSOhkd0kAwG4hIsaHOXrtyKAC8oOgCOhKh0ABTGZhZWNnYGAJROmKQAHqI04u5W1KgAykEydPi+0nIKKuqgAFRuUZ52RrLySmqoDkA)
While it‚Äôs rare to need to mix imports and require calls in the same file,
this `module` mode best reflects the capabilities of most modern bundlers, as
well as the Bun runtime.
> Why care about TypeScript‚Äôs `module` emit with a bundler or with Bun, where
> you‚Äôre likely also setting `noEmit`? TypeScript‚Äôs type checking and module
> resolution behavior are affected by the module format that it _would_ emit.
> Setting `module` gives TypeScript information about how your bundler or
> runtime will process imports and exports, which ensures that the types you
> see on imported values accurately reflect what will happen at runtime or
> after bundling.
#### `None`
    ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgs2ATAVwBsBTALlADtYrTsxwbEAnF2FyTVZABw-SgA3qABuAQ2KFSAeQBmABVSgAvqDntkoAEQA6YAGNakdOKrpI2gNyZMpAB78Wgo1ROh08WEtABeMZLS8j4AVKAATFZAA)
  * Default:
`CommonJS` if `target` is `ES5`; `ES6`/`ES2015` otherwise.
  * Allowed:
    * `none`
    * `commonjs`
    * `amd`
    * `umd`
    * `system`
    * `es6`/`es2015`
    * `es2020`
    * `es2022`
    * `esnext`
    * `node16`
    * `nodenext`
    * `preserve`
  * Related:
    * `moduleResolution`
    * `esModuleInterop`
    * `allowImportingTsExtensions`
    * `allowArbitraryExtensions`
    * `resolveJsonModule`
  * Released:
[1.0](/docs/handbook/release-notes/typescript-1-0.html)
### # Module Resolution - `moduleResolution`
Specify the module resolution strategy:
  * `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding `module` values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.
  * `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won‚Äôt need to use `node10` in modern code.
  * `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `"imports"` and `"exports"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.
  * `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.
There are reference pages explaining the [theory behind TypeScript‚Äôs module
resolution](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-
resolution) and the [details of each
option](/docs/handbook/modules/reference.html#the-moduleresolution-compiler-
option).
  * Default:
`Classic` if `module` is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if
`module` is `node16` or `nodenext`; `Node` otherwise.
  * Allowed:
    * `classic`
    * `node10`/`node`
    * `node16`
    * `nodenext`
    * `bundler`
  * Related:
    * `module`
    * `paths`
    * `baseUrl`
    * `rootDirs`
    * `moduleSuffixes`
    * `customConditions`
    * `resolvePackageJsonExports`
    * `resolvePackageJsonImports`
### # Module Suffixes - `moduleSuffixes`
Provides a way to override the default list of file name suffixes to search
when resolving a module.
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[moduleSuffixes](https://www.typescriptlang.org/tsconfig#moduleSuffixes)": [".ios", ".native", ""]
      }
    }
Given the above configuration, an import like the following:
    ts
    import * as foo from "./foo";
TypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`,
and finally `./foo.ts`.
Note the empty string `""` in `moduleSuffixes` which is necessary for
TypeScript to also look-up `./foo.ts`.
This feature can be useful for React Native projects where each target
platform can use a separate tsconfig.json with differing `moduleSuffixes`.
  * Released:
[4.7](/docs/handbook/release-notes/typescript-4-7.html)
### # No Resolve - `noResolve`
By default, TypeScript will examine the initial set of files for `import` and
`<reference` directives and add these resolved files to your program.
If `noResolve` is set, this process doesn‚Äôt happen. However, `import`
statements are still checked to see if they resolve to a valid module, so
you‚Äôll need to make sure this is satisfied by some other means.
### # noUncheckedSideEffectImports - `noUncheckedSideEffectImports`
In JavaScript it‚Äôs possible to `import` a module without actually importing
any values from it.
    ts
    import "some-module";
These imports are often called _side effect imports_ because the only useful
behavior they can provide is by executing some side effect (like registering a
global variable, or adding a polyfill to a prototype).
By default, TypeScript will not check these imports for validity. If the
import resolves to a valid source file, TypeScript will load and check the
file. If no source file is found, TypeScript will silently ignore the import.
This is surprising behavior, but it partially stems from modeling patterns in
the JavaScript ecosystem. For example, this syntax has also been used with
special loaders in bundlers to load CSS or other assets. Your bundler might be
configured in such a way where you can include specific `.css` files by
writing something like the following:
    tsx
    import "./button-component.css";
    export function Button() {
      // ...
    }
Still, this masks potential typos on side effect imports.
When `--noUncheckedSideEffectImports` is enabled, TypeScript will error if it
can‚Äôt find a source file for a side effect import.
    ts
    import "oops-this-module-does-not-exist";
    //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations.
When enabling this option, some working code may now receive an error, like in
the CSS example above. To work around this, users who want to just write side
effect `import`s for assets might be better served by writing what‚Äôs called an
_ambient module declaration_ with a wildcard specifier. It would go in a
global file and look something like the following:
    ts
    // ./src/globals.d.ts
    // Recognize all CSS files as module imports.
    declare module "*.css" {}
In fact, you might already have a file like this in your project! For example,
running something like `vite init` might create a similar `vite-env.d.ts`.
### # Paths - `paths`
A series of entries which re-map imports to lookup locations relative to the
`baseUrl` if set, or to the tsconfig file itself otherwise. There is a larger
coverage of `paths` in [the `moduleResolution` reference
page](/docs/handbook/modules/reference.html#paths).
`paths` lets you declare how TypeScript should resolve an import in your
`require`/`import`s.
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
          "jquery": ["./vendor/jquery/dist/jquery"]
        }
      }
    }
This would allow you to be able to write `import "jquery"`, and get all of the
correct typing locally.
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[paths](https://www.typescriptlang.org/tsconfig#paths)": {
            "app/*": ["./src/app/*"],
            "config/*": ["./src/app/_config/*"],
            "environment/*": ["./src/environments/*"],
            "shared/*": ["./src/app/_shared/*"],
            "helpers/*": ["./src/helpers/*"],
            "tests/*": ["./src/tests/*"]
        },
    }
In this case, you can tell the TypeScript file resolver to support a number of
custom prefixes to find code.
Note that this feature does not change how import paths are emitted by `tsc`,
so `paths` should only be used to inform TypeScript that another tool has this
mapping and will use it at runtime or when bundling.
### # Resolve JSON Module - `resolveJsonModule`
Allows importing modules with a `.json` extension, which is a common practice
in node projects. This includes generating a type for the `import` based on
the static JSON shape.
TypeScript does not support resolving JSON files by default:
    ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
    Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.2732Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.
    settings.debug === true;
    settings.dry === 2;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYDMaBQIIAzASwBtIA7AQwFtJVFIAXJ4igc0QDoArROCrgDeuUGNAAiaJAAOcCagkAVAJ4zIAZQDG0YjKYSANKPESAJtBULQhKqUbHxks5ABGAV3bXb9yLgC++GDgJOTUdKhsLgAeXEyIuMQ0ctBMoIwsbJw28DSSXMAZrBzcfAISANy4uEVZ3C4e7KAAvK2gTNDukFW1JVwWKi1taBVAA)
Enabling the option allows importing JSON, and validating the types in that
JSON file.
    ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
    settings.debug === true;
    settings.dry === 2;
    This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.2367This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUCBNJInADYBukAUqQHYCycAJgK5mQFjgC2L7kVAGM4PPnQBWiLhD5sOAJRLlWAFwCWcOqjotOhcADN1HOgEMeg0IkiqNdAOaIAdFK14A3nlA-QAImIABzg-VD8AFQBPQMgAZSFodUDVPwAab18-ZmhI0NBDMzIbdN9-ZkgAI1YHPIKizgBfGSMTSHNLVHU6coAPZ1VpdR5g6FVrW3snfPgef2dgGzsup1d6PwBuPDxFyZdyqodQAF4T0FVoVkhNneW9nOPTtHWgA)
### # Resolve package.json Exports - `resolvePackageJsonExports`
`--resolvePackageJsonExports` forces TypeScript to consult [the `exports`
field of `package.json` files](https://nodejs.org/api/packages.html#exports)
if it ever reads from a package in `node_modules`.
This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.
  * Default:
`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`
  * Related:
    * `moduleResolution`
    * `customConditions`
    * `resolvePackageJsonImports`
### # Resolve package.json Imports - `resolvePackageJsonImports`
`--resolvePackageJsonImports` forces TypeScript to consult [the `imports`
field of `package.json` files](https://nodejs.org/api/packages.html#imports)
when performing a lookup that starts with `#` from a file whose ancestor
directory contains a `package.json`.
This option defaults to `true` under the `node16`, `nodenext`, and `bundler`
options for `--moduleResolution`.
  * Default:
`true` when `moduleResolution` is `node16`, `nodenext`, or `bundler`;
otherwise `false`
  * Related:
    * `moduleResolution`
    * `customConditions`
    * `resolvePackageJsonExports`
### # Root Dir - `rootDir`
**Default** : The longest common path of all non-declaration input files. If
`composite` is set, the default is instead the directory containing the
`tsconfig.json` file.
When TypeScript compiles files, it keeps the same directory structure in the
output directory as exists in the input directory.
For example, let‚Äôs say you have some input files:
    MyProj
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îú‚îÄ‚îÄ core
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.ts
    ‚îú‚îÄ‚îÄ types.d.ts
The inferred value for `rootDir` is the longest common path of all non-
declaration input files, which in this case is `core/`.
If your `outDir` was `dist`, TypeScript would write this tree:
    MyProj
    ‚îú‚îÄ‚îÄ dist
    ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    ‚îÇ   ‚îú‚îÄ‚îÄ sub
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js
However, you may have intended for `core` to be part of the output directory
structure. By setting `rootDir: "."` in `tsconfig.json`, TypeScript would
write this tree:
    MyProj
    ‚îú‚îÄ‚îÄ dist
    ‚îÇ   ‚îú‚îÄ‚îÄ core
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ a.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ b.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sub
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ c.js
Importantly, `rootDir` **does not affect which files become part of the
compilation**. It has no interaction with the `include`, `exclude`, or `files`
`tsconfig.json` settings.
Note that TypeScript will never write an output file to a directory outside of
`outDir`, and will never skip emitting a file. For this reason, `rootDir` also
enforces that all files which need to be emitted are underneath the `rootDir`
path.
For example, let‚Äôs say you had this tree:
    MyProj
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îú‚îÄ‚îÄ core
    ‚îÇ   ‚îú‚îÄ‚îÄ a.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ b.ts
    ‚îú‚îÄ‚îÄ helpers.ts
It would be an error to specify `rootDir` as `core` _and_ `include` as `*`
because it creates a file (`helpers.ts`) that would need to be emitted
_outside_ the `outDir` (i.e. `../helpers.js`).
  * Default:
Computed from the list of input files.
  * Released:
[1.5](/docs/handbook/release-notes/typescript-1-5.html)
### # Root Dirs - `rootDirs`
Using `rootDirs`, you can inform the compiler that there are many ‚Äúvirtual‚Äù
directories acting as a single root. This allows the compiler to resolve
relative module imports within these ‚Äúvirtual‚Äù directories, as if they were
merged in to one directory.
For example:
     src
     ‚îî‚îÄ‚îÄ views
         ‚îî‚îÄ‚îÄ view1.ts (can import "./template1", "./view2`)
         ‚îî‚îÄ‚îÄ view2.ts (can import "./template1", "./view1`)
     generated
     ‚îî‚îÄ‚îÄ templates
             ‚îî‚îÄ‚îÄ views
                 ‚îî‚îÄ‚îÄ template1.ts (can import "./view1", "./view2")
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src/views", "generated/templates/views"]
      }
    }
This does not affect how TypeScript emits JavaScript, it only emulates the
assumption that they will be able to work via those relative paths at runtime.
`rootDirs` can be used to provide a separate ‚Äútype layer‚Äù to files that are
not TypeScript or JavaScript by providing a home for generated `.d.ts` files
in another folder. This technique is useful for bundled applications where you
use `import` of files that aren‚Äôt necessarily code:
    sh
     src
     ‚îî‚îÄ‚îÄ index.ts
     ‚îî‚îÄ‚îÄ css
         ‚îî‚îÄ‚îÄ main.css
         ‚îî‚îÄ‚îÄ navigation.css
     generated
     ‚îî‚îÄ‚îÄ css
         ‚îî‚îÄ‚îÄ main.css.d.ts
         ‚îî‚îÄ‚îÄ navigation.css.d.ts
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[rootDirs](https://www.typescriptlang.org/tsconfig#rootDirs)": ["src", "generated"]
      }
    }
This technique lets you generate types ahead of time for the non-code source
files. Imports then work naturally based off the source file‚Äôs location. For
example `./src/index.ts` can import the file `./src/css/main.css` and
TypeScript will be aware of the bundler‚Äôs behavior for that filetype via the
corresponding generated declaration file.
    ts
    // @filename: index.ts
    import { appClass } from "./main.css";
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVzqIHQDGAzsfgCb4AuxAUPAB4AOA9gE5WiEuLGfJMmAYVjJSoALygARDjwixxAGIBmAKJCATNIDctEKAC0xwgFcqxw-rBQ4SNJlB5yjanWipWHUAG9QA4VFxAF9QSDYWVBl8YDkCEmJdIA)
  * Default:
Computed from the list of input files.
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Type Roots - `typeRoots`
By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.
If `typeRoots` is specified, _only_ packages under `typeRoots` will be
included. For example:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[typeRoots](https://www.typescriptlang.org/tsconfig#typeRoots)": ["./typings", "./vendor/types"]
      }
    }
This config file will include _all_ packages under `./typings` and
`./vendor/types`, and no packages from `./node_modules/@types`. All paths are
relative to the `tsconfig.json`.
  * Related:
    * `types`
### # Types - `types`
By default all _visible_ ‚Äù`@types`‚Äù packages are included in your compilation.
Packages in `node_modules/@types` of any enclosing folder are considered
_visible_. For example, that means packages within `./node_modules/@types/`,
`../node_modules/@types/`, `../../node_modules/@types/`, and so on.
If `types` is specified, only packages listed will be included in the global
scope. For instance:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["node", "jest", "express"]
      }
    }
This `tsconfig.json` file will _only_ include `./node_modules/@types/node`,
`./node_modules/@types/jest` and `./node_modules/@types/express`. Other
packages under `node_modules/@types/*` will not be included.
### What does this affect?
This option does not affect how `@types/*` are included in your application
code, for example if you had the above `compilerOptions` example with code
like:
    ts
    import * as moment from "moment";
    moment().format("MMMM Do YYYY, h:mm:ss a");
The `moment` import would be fully typed.
When you have this option set, by not including a module in the `types` array
it:
  * Will not add globals to your project (e.g `process` in node, or `expect` in Jest)
  * Will not have exports appear as auto-import recommendations
This feature differs from `typeRoots` in that it is about specifying only the
exact types you want included, whereas `typeRoots` supports saying you want
particular folders.
  * Related:
    * `typeRoots`
## #Emit
### # Declaration - `declaration`
Generate `.d.ts` files for every TypeScript or JavaScript file inside your
project. These `.d.ts` files are type definition files which describe the
external API of your module. With `.d.ts` files, tools like TypeScript can
provide intellisense and accurate types for un-typed code.
When `declaration` is set to `true`, running the compiler with this TypeScript
code:
    ts
    export let helloWorld = "hi";
    [Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAG2PAFsBCIHVoICZwC8cARCgJYkDcQA)
Will generate an `index.js` file like this:
    ts
    export let helloWorld = "hi";
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMAeAHWAJ3VABttTpsyzYB1YsgE1AF5QAiaVTgbiA)
With a corresponding `helloWorld.d.ts`:
    ts
    export declare let helloWorld: string;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCi1oAHWKPShiy6FkKFYAdUWEcoALygARNFQmA3EA)
When working with `.d.ts` files for JavaScript files you may want to use
`emitDeclarationOnly` or use `outDir` to ensure that the JavaScript files are
not overwritten.
  * Default:
`true` if `composite`; `false` otherwise.
  * Related:
    * `declarationDir`
    * `emitDeclarationOnly`
  * Released:
[1.0](/docs/handbook/release-notes/typescript-1-0.html)
### # Declaration Dir - `declarationDir`
Offers a way to configure the root directory for where declaration files are
emitted.
    example
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ tsconfig.json
with this `tsconfig.json`:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
        "[declarationDir](https://www.typescriptlang.org/tsconfig#declarationDir)": "./types"
      }
    }
Would place the d.ts for the `index.ts` in a `types` folder:
    example
    ‚îú‚îÄ‚îÄ index.js
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îî‚îÄ‚îÄ types
        ‚îî‚îÄ‚îÄ index.d.ts
  * Related:
    * `declaration`
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Declaration Map - `declarationMap`
Generates a source map for `.d.ts` files which map back to the original `.ts`
source file. This will allow editors such as VS Code to go to the original
`.ts` file when using features like _Go to Definition_.
You should strongly consider turning this on if you‚Äôre using project
references.
  * Released:
[2.9](/docs/handbook/release-notes/typescript-2-9.html)
### # Downlevel Iteration - `downlevelIteration`
Downleveling is TypeScript‚Äôs term for transpiling to an older version of
JavaScript. This flag is to enable support for a more accurate implementation
of how modern JavaScript iterates through new concepts in older JavaScript
runtimes.
ECMAScript 6 added several new iteration primitives: the `for / of` loop (`for
(el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`),
and `Symbol.iterator`. `downlevelIteration` allows for these iteration
primitives to be used more accurately in ES5 environments if a
`Symbol.iterator` implementation is present.
#### Example: Effects on `for / of`
With this TypeScript code:
    ts
    const str = "Hello!";
    for (const s of str) {
      console.log(s);
    }
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBNBOMC8MBEAJApgG2yAhKgNwBQAZiIgBSiSwQwhlxTwCUMA3iTDLRCGyYAdHgDmVCG1IBfIA)
Without `downlevelIteration` enabled, a `for / of` loop on any object is
downleveled to a traditional `for` loop:
    ts
    "use strict";
    var str = "Hello!";
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var s = str_1[_i];
        console.log(s);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBAM4AWA9gO7oC2AlpLgMakB2hkobsoAvKAEQAJRABthpAIR8A3LgBmpLgAomrdoVClZHSLACUoAN65QoFYVLDEAOjHxFhXTIC+QA)
This is often what people expect, but it‚Äôs not 100% compliant with ECMAScript
iteration protocol. Certain strings, such as emoji (üòú), have a `.length` of 2
(or even more!), but should iterate as 1 unit in a `for-of` loop. See [this
blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-
equals-two) for a longer explanation.
When `downlevelIteration` is enabled, TypeScript will use a helper function
that checks for a `Symbol.iterator` implementation (either native or
polyfill). If this implementation is missing, you‚Äôll fall back to index-based
iteration.
    ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y4AzgAsy6ALbtIuAMZc+kULNigAvKABEACXqViAQlUBuXADNiigBTTys+aGJH5kWAEpQAb1yhQlvsWoA6bXgzPidDAF8gA)
You can use [tslib](https://www.npmjs.com/package/tslib) via `importHelpers`
to reduce the amount of inline JavaScript too:
    ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcoCiBlArAKBBACYD2A7gHYA2iAbopQJKSKzSQCWx5+Y47AtgAdisSAAl6glgGceEaQAsy6fu0i4Axl2mRQO2KAC8oAEQTKlYgEITAblwAzEaAAUW8jr2hiDvZFgAlKAA3rigoO7SxNQAdJbwLtIB9gC+QA)
**Note:** enabling `downlevelIteration` does not improve compliance if
`Symbol.iterator` is not present in the runtime.
#### Example: Effects on Array Spreads
This is an array spread:
    js
    // Make a new array whose elements are 1 followed by the elements of arr2
    const arr = [1, ...arr2];
Based on the description, it sounds easy to downlevel to ES5:
    js
    // The same, right?
    const arr = [1].concat(arr2);
However, this is observably different in certain rare cases.
For example, if a source array is missing one or more items (contains a hole),
the spread syntax will replace each empty item with `undefined`, whereas
`.concat` will leave them intact.
    js
    // Make an array where the element at index 1 is missing
    let arrayWithHole = ["a", , "c"];
    let spread = [...arrayWithHole];
    let concatenated = [].concat(arrayWithHole);
    console.log(arrayWithHole);
    // [ 'a', <1 empty item>, 'c' ]
    console.log(spread);
    // [ 'a', undefined, 'c' ]
    console.log(concatenated);
    // [ 'a', <1 empty item>, 'c' ]
Just as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if
present) to more accurately emulate ES 6 behavior.
  * Related:
    * `importHelpers`
  * Released:
[2.3](/docs/handbook/release-notes/typescript-2-3.html)
### # Emit BOM - `emitBOM`
Controls whether TypeScript will emit a [byte order mark
(BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files.
Some runtime environments require a BOM to correctly interpret a JavaScript
files; others require that it is not present. The default value of `false` is
generally best unless you have a reason to change it.
### # Emit Declaration Only - `emitDeclarationOnly`
_Only_ emit `.d.ts` files; do not emit `.js` files.
This setting is useful in two cases:
  * You are using a transpiler other than TypeScript to generate your JavaScript.
  * You are using TypeScript to only generate `d.ts` files for your consumers.
  * Related:
    * `declaration`
  * Released:
[2.8](/docs/handbook/release-notes/typescript-2-8.html)
### # Import Helpers - `importHelpers`
For certain downleveling operations, TypeScript uses some helper code for
operations like extending class, spreading arrays or objects, and async
operations. By default, these helpers are inserted into files which use them.
This can result in code duplication if the same helper is used in many
different modules.
If the `importHelpers` flag is on, these helper functions are instead imported
from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to
ensure that the `tslib` module is able to be imported at runtime. This only
affects modules; global script files will not attempt to import modules.
For example, with this TypeScript:
    ts
    export function fn(arr: number[]) {
      const arr2 = [1, ...arr];
    }
Turning on `downlevelIteration` and `importHelpers` is still false:
    ts
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFaYSADwAOsAulAAzAK6sAxsNGLWACkIFKrJcgBGAgNoBdAJSgA3plChVoyPL0AmUAF5QZgIwANKAAdKF6FgDcmAC+QA)
Then turning on both `downlevelIteration` and `importHelpers`:
    ts
    import { __read, __spreadArray } from "tslib";
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOACYIB2ANiQG4nsYkE86VLFYMIqZAAdYBdNF5SBkceFaxEBArJUkAHjLmgAZgFdWAY2GiTrABSEClVqeQAjAQG0AugEpQAN6YoKAWopDooI4ATKAAvKCeAIwANKAAdJmO3gDcmAC+QA)
You can use `noEmitHelpers` when you provide your own implementations of these
functions.
  * Related:
    * `noEmitHelpers`
    * `downlevelIteration`
### # Inline Source Map - `inlineSourceMap`
When set, instead of writing out a `.js.map` file to provide source maps,
TypeScript will embed the source map content in the `.js` files. Although this
results in larger JS files, it can be convenient in some scenarios. For
example, you might want to debug JS files on a webserver that doesn‚Äôt allow
`.map` files to be served.
Mutually exclusive with `sourceMap`.
For example, with this TypeScript:
    ts
    const helloWorld = "hi";
    console.log(helloWorld);
Converts to this JavaScript:
    ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)
Then enable building it with `inlineSourceMap` enabled there is a comment at
the bottom of the file which includes a source-map for the file.
    ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQWQIYAOAUCBAM4AWKA7gKIC2kALsVitOc6JQrLCgDqKDLAAmoALygARJUgyA3Gw7kUsBADoBAcwAUvfkJHiAlIqA)
  * Released:
[1.5](/docs/handbook/release-notes/typescript-1-5.html)
### # Inline Sources - `inlineSources`
When set, TypeScript will include the original content of the `.ts` file as an
embedded string in the source map (using the source map‚Äôs `sourcesContent`
property). This is often useful in the same cases as `inlineSourceMap`.
Requires either `sourceMap` or `inlineSourceMap` to be set.
For example, with this TypeScript:
    ts
    const helloWorld = "hi";
    console.log(helloWorld);
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAFgUwDZJAdRAJyQExgXhgCI4BLIgbgChRIQkEA6VAcwApEV0tcBKCoA)
By default converts to this JavaScript:
    ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1RoBTAGzNgHVYAnMgE1AF5QAiaVNgbh30lhkSAOkoBzABSkK1OowCU3IA)
Then enable building it with `inlineSources` and `inlineSourceMap` enabled
there is a comment at the bottom of the file which includes a source-map for
the file. Note that the end is different from the example in `inlineSourceMap`
because the source-map now contains the original source code also.
    ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEsDsBsYKYGUD2BXATgYwQZwFAgQzzTLrYICyAhgA6Fji4AWKA7gKIC2kALviwpouPqBYJYsFAHUUGWABNQAXlAAiFpHUBuQcNwpYCAHTSA5gAoJU2fKUBKHUA)
  * Released:
[1.5](/docs/handbook/release-notes/typescript-1-5.html)
### # Map Root - `mapRoot`
Specify the location where debugger should locate map files instead of
generated locations. This string is treated verbatim inside the source-map,
for example:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
        "[mapRoot](https://www.typescriptlang.org/tsconfig#mapRoot)": "https://my-website.com/debug/sourcemaps/"
      }
    }
Would declare that `index.js` will have sourcemaps at `https://my-
website.com/debug/sourcemaps/index.js.map`.
### # New Line - `newLine`
Specify the end of line sequence to be used when emitting files: ‚ÄòCRLF‚Äô (dos)
or ‚ÄòLF‚Äô (unix).
  * Default:
`lf`
  * Allowed:
    * `crlf`
    * `lf`
  * Released:
[1.5](/docs/handbook/release-notes/typescript-1-5.html)
### # No Emit - `noEmit`
Do not emit compiler output files like JavaScript source code, source-maps or
declarations.
This makes room for another tool like [Babel](https://babeljs.io), or
[swc](https://github.com/swc-project/swc) to handle converting the TypeScript
file to a file which can run inside a JavaScript environment.
You can then use TypeScript as a tool for providing editor integration, and as
a source code type-checker.
### # No Emit Helpers - `noEmitHelpers`
Instead of importing helpers with `importHelpers`, you can provide
implementations in the global scope for the helpers you use and completely
turn off emitting of helper functions.
For example, using this `async` function in ES5 requires a `await`-like
function and `generator`-like function to run:
    ts
    const getAPI = async (url: string) => {
      // Get API
      return {};
    };
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBA5gUygQQAoEkYF4YEMICeYwMAFAK4BOANgFwzSUCWYcAlNgHwwDeAUDBgB6ITADiSGGnQCYlJFTC8AvgG4+aoA)
Which creates quite a lot of JavaScript:
    ts
    "use strict";
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArJgMawB2k6op6AggAoCSoALyg8kAJ7MGoABQBXAgBtKbAqmZEAlEIB8oAN6ZQoHAHEyoXn0OgCZec30BfANyYXQA)
Which can be switched out with your own globals via this flag:
    ts
    "use strict";
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFyiIDKArNmOAHawoYASJANgA4kGRMAY1hNI6UKXQBBAAoBJUAF5QeSAE8mQ0AAoArgS6VxBVEyIBKZQD5QAb0yhQOAOJlQc+Y9AEyBpvYAvgDcmCFAA)
  * Related:
    * `importHelpers`
  * Released:
[1.5](/docs/handbook/release-notes/typescript-1-5.html)
### # No Emit On Error - `noEmitOnError`
Do not emit compiler output files like JavaScript source code, source-maps or
declarations if any errors were reported.
This defaults to `false`, making it easier to work with TypeScript in a watch-
like environment where you may want to see results of changes to your code in
another environment before making sure all errors are resolved.
  * Released:
[1.4](/docs/handbook/release-notes/typescript-1-4.html)
### # Out Dir - `outDir`
If specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be
emitted into this directory. The directory structure of the original source
files is preserved; see `rootDir` if the computed root is not what you
intended.
If not specified, `.js` files will be emitted in the same directory as the
`.ts` files they were generated from:
    sh
    $ tsc
    example
    ‚îú‚îÄ‚îÄ index.js
    ‚îî‚îÄ‚îÄ index.ts
With a `tsconfig.json` like this:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[outDir](https://www.typescriptlang.org/tsconfig#outDir)": "dist"
      }
    }
Running `tsc` with these settings moves the files into the specified `dist`
folder:
    sh
    $ tsc
    example
    ‚îú‚îÄ‚îÄ dist
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îú‚îÄ‚îÄ index.ts
    ‚îî‚îÄ‚îÄ tsconfig.json
  * Related:
    * `out`
    * `outFile`
### # Out File - `outFile`
If specified, all _global_ (non-module) files will be concatenated into the
single output file specified.
If `module` is `system` or `amd`, all module files will also be concatenated
into this file after all global content.
Note: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`.
This option _cannot_ be used to bundle CommonJS or ES6 modules.
  * Related:
    * `out`
    * `outDir`
  * Released:
[1.0](/docs/handbook/release-notes/typescript-1-0.html)
### # Preserve Const Enums - `preserveConstEnums`
Do not erase `const enum` declarations in generated code. `const enum`s
provide a way to reduce the overall memory footprint of your application at
runtime by emitting the enum value instead of a reference.
For example with this TypeScript:
    ts
    const enum Album {
      JimmyEatWorldFutures = 1,
      TubRingZooHypothesis = 2,
      DogFashionDiscoAdultery = 3,
    }
    const selectedAlbum = Album.JimmyEatWorldFutures;
    if (selectedAlbum === Album.JimmyEatWorldFutures) {
      console.log("That is a great choice.");
    }
    [Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgQQDYCMUwN4BQMMAUgJbLICeAogIZQDqIAThgCYBiiUiLcEGAF4YARgA0RGABVEWAEpkwAcwBaIEAAkqABxBQAFgLKCRAJknEAIiGWc6EA2XBWToNO0QYocFlWEwAMySAL4EBKCQsBBwGHDAPuyYOKgiySgAdOSUtAzMbFw8fAIA3ARkAGYwABQxcQlwSdi4Qq3ozchZFNT0TKwc3Lz8EACU+FKRECBxGRi21QBE0gYMMCYwdDDK-KvABiBkwHAZCyNlIUA)
The default `const enum` behavior is to convert any `Album.Something` to the
corresponding number literal, and to remove a reference to the enum from the
JavaScript completely.
    ts
    "use strict";
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VAEEAbAIwtAG9NRQApVZZAT0QEN0AdVgAnGgBMAYmXRlRxSKAC8oAIwAaVqAAqZOgCVUeAOYAtWLAASPAA6x00RaiWqATFrYARWCan8YVHwvF1wqCTIadGJRHhVQAGYtAF9MHHxCUEhiGmJsaIlaBkpVIooAOk5uPkERcWlZeUUAbkxUADNQAAps3PziQvpGZRHqIeRKrl4BYTFJGTkFSABKZm1cAlhc8ppfLoAiHWhBUBdQflATBRPsOFRsYnL95dbkoA)
With `preserveConstEnums` set to `true`, the `enum` exists at runtime and the
numbers are still emitted.
    ts
    "use strict";
    var Album;
    (function (Album) {
        Album[Album["JimmyEatWorldFutures"] = 1] = "JimmyEatWorldFutures";
        Album[Album["TubRingZooHypothesis"] = 2] = "TubRingZooHypothesis";
        Album[Album["DogFashionDiscoAdultery"] = 3] = "DogFashionDiscoAdultery";
    })(Album || (Album = {}));
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEAcCcFMGdbQG6wMIHsB28AuBRLAVwFt4AuUXaI2AKBAngAsMB3fEgS1zoGNseULGIlQAQQA2AI1KgA3nVCgAUlxIkAnvgCGuAOoZokgCYAxIriJx4oALygAjABoloACpFpAJS5YA5gBaGBgAEpqQGLjMCFy2DgBMrsoAIhj+ZjosXNgpcQLiJkSSuEia9qAAzK4AvnT8grigiJKwfKUmUrJiDl2kAHRqGtp6hsbmltYIANx0XABmoAAULW0dfT12vTIDQ1q6BkamFlY2AJQKbgI4GK39kulLAETuzHqgcaA6oP5w73ysLh8WD9J5nWY1IA)
This essentially makes such `const enums` a source-code feature only, with no
runtime traces.
  * Default:
`true` if `isolatedModules`; `false` otherwise.
### # Remove Comments - `removeComments`
Strips all comments from TypeScript files when converting into JavaScript.
Defaults to `false`.
For example, this is a TypeScript file which has a JSDoc comment:
    ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Ol√° Mundo";
When `removeComments` is set to `true`:
    ts
    export const helloWorldPTBR = "Ol√° Mundo";
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBco6uArvtgFSegAq0+ZrgCGNSABth6VLBqhYAM1AByABL5x42KHixc4gCbLQqOtoAKe9KwDm7SIM7BM+AB4AHK6ADGsyOlABTVgAdT1Dc14AIQAlUABeUAAiAHlxAEPQAFlWGgNYJIBuIA)
Without setting `removeComments` or having it as `false`:
    ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Ol√° Mundo";
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqQBcoAZgIYA2k+2AVD6ABVo+UOlysakdq3SpYNULGagA5AAl87drFDxYudgBMVoVHR0AFfegCuAcxv4uoHsEz4AHgAdroAMbykOigwlqwAOr6RhYCAEIASqAAvKAARADy7ACHoACyNjSGsKkA3EA)
This means that your comments will show up in the JavaScript code.
### # Source Map - `sourceMap`
Enables the generation of [sourcemap
files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map).
These files allow debuggers and other tools to display the original TypeScript
source code when actually working with the emitted JavaScript files. Source
map files are emitted as `.js.map` (or `.jsx.map`) files next to the
corresponding `.js` output file.
The `.js` files will in turn contain a sourcemap comment to indicate where the
files are to external tools, for example:
    ts
    // helloWorld.ts
    export declare const helloWorld = "hi";
Compiling with `sourceMap` set to `true` creates the following JavaScript
file:
    js
    // helloWorld.js
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.helloWorld = "hi";
    //# sourceMappingURL=// helloWorld.js.map
And this also generates this json map:
    json
    // helloWorld.js.map
    {
      "version": 3,
      "file": "ex.js",
      "sourceRoot": "",
      "sources": ["../ex.ts"],
      "names": [],
      "mappings": ";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA"
    }
### # Source Root - `sourceRoot`
Specify the location where a debugger should locate TypeScript files instead
of relative source locations. This string is treated verbatim inside the
source-map where you can use a path or a URL:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap)": true,
        "[sourceRoot](https://www.typescriptlang.org/tsconfig#sourceRoot)": "https://my-website.com/debug/source/"
      }
    }
Would declare that `index.js` will have a source file at `https://my-
website.com/debug/source/index.ts`.
### # Strip Internal - `stripInternal`
Do not emit declarations for code that has an `@internal` annotation in its
JSDoc comment. This is an internal compiler option; use at your own risk,
because the compiler does not check that the result is valid. If you are
searching for a tool to handle additional levels of visibility within your
`d.ts` files, look at [api-extractor](https://api-extractor.com).
    ts
    /**
     * Days available in a week
     * @internal
     */
    export const daysInAWeek = 7;
    /** Calculate how much someone earns in a week */
    export function weeklySalary(dayRate: number) {
      return daysInAWeek * dayRate;
    }
    [Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgRBDAngZ0vAbvAlgG3gIxwFNIsA7NSAdyKIGsoYABcgFyICcz4dHhwiADwAOAew6tIAY1FlkkgCZJkASTIBBAOq06kALyQA7AG5w4UDADCPKQFc87SAAtRVSAFtbUp5GSj3RLIkRPBcqOSUNPTQ-EJiEpAAZrZkUqxYstQ6OIgAyjyhiAAUSogASvDsAFyQZLbu+JwAlJAA3lCQHESstlyQpaoa2tEwpRXspgC+QA)
With the flag set to `false` (default):
    ts
    /**
     * Days available in a week
     * @internal
     */
    export declare const daysInAWeek = 7;
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgF3QUwCYDFUAbLALlFQDscsAPAOhzvUgCgQIYEUM2xxqAxoQCGAJ2HpUsCmwBUslqFmgAIsICekUMIBuwosIBGxchW2h4WLAGtFy8JWyiKwwneAtaAB1ij0oAWlIfxwNSABJCgBBAHUra1AAXlAAdgBuFjllAGFXAQBXEWxQOHhQZHyBaFBIWGQsaSxQLDEKLUpzSxslD29ffwAzfIoBSWkLeMJ1AGVXMXUAClD1ACUJUlAKfORDLFEASlAAb0VQUSx0fOdQZYjouO7lZbXsDIBfIA)
With `stripInternal` set to `true` the `d.ts` emitted will be redacted.
    ts
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsAO8B20CmsUEMA2AoECSACwHsB3AUQFt5oMATAMXl3QC5RVH0APAHSMB0SITBRy1OtHEReAY1zZY2aPDIpCAKm35Q20ABFsAT0ihsAN2xtsAI3bcUl0BXToA1vsPhUGLDwfYHx+RDJYaFAFTRhQRjNIAEkUAEEAdQ9PUABeUAB2AG58HUMAYTwFAFdlDFApUBoqhRJQSDIadE10UHQVFAtUV3cvAxCwiKiAMyqUBXVNNyzcUwBlPBVTAAoE0wAlNU5QFCqae0wASlAAb31QWHRoKqx4xJSMrINX-cPigF8gA)
The JavaScript output is still the same.
  * Internal
## #JavaScript Support
### # Allow JS - `allowJs`
Allow JavaScript files to be imported inside your project, instead of just
`.ts` and `.tsx` files. For example, this JS file:
    js
    // @filename: card.js
    export const defaultCardDeck = "Heart";
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQ8AHgA4D2eALjvYmSwfJMgK6xMAwvgIAReNgDWoALygARAAl4+JvIDcQA)
When imported into a TypeScript file will raise an error:
    ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
    console.log(defaultCardDeck);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMB2AUCBAGYCWANpAHYCGAtpKgMbXQAmAdAFaJ61ysBXCu0gAPAA4IALonatIRakKkBhFqwAikRgGtQAXlAAiABKQWUowG4CYALQPGAqQ7u3i5KnQagSleaLsMngktJLQUqAA3qDyispqbFq6oAC+oETwtMbswMxs1nh4jHCUiHDCZHAA5gAUcUpkqurJOgCUVkA)
Imports fine with `allowJs` enabled:
    ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
    console.log(defaultCardDeck);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxsgTgCYB0AVgM4BQqA9gQK4JHwAeADtXgC5lEHyTIGnAML4CAEXjYA1qAC8oAEQAJePk6KA3BRCgAtAex1OBvTrDhksWNQDuAKUq6ocJGkyhoiPsyLcK0KjsXKAA3qB8AkKihJIyoAC+oJB41KhKRMC4hFoUFNjUiGTUjDYA5gAUkYKwImJx0gCUmkA)
This flag can be used as a way to incrementally add TypeScript files into JS
projects by allowing the `.ts` and `.tsx` files to live along-side existing
JavaScript files.
It can also be used along-side `declaration` and `emitDeclarationOnly` to
[create declarations for JS files](/docs/handbook/declaration-files/dts-from-
js.html).
  * Related:
    * `checkJs`
    * `emitDeclarationOnly`
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # Check JS - `checkJs`
Works in tandem with `allowJs`. When `checkJs` is enabled then errors are
reported in JavaScript files. This is the equivalent of including `// @ts-
check` at the top of all JavaScript files which are included in your project.
For example, this is incorrect JavaScript according to the `parseFloat` type
definition which comes with TypeScript:
    js
    // parseFloat only takes a string
    module.exports.pi = parseFloat(3.142);
When imported into a TypeScript module:
    ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEEMBtoewO4CkDOAoEEBmBLaBTAO0gFt8AuUAYzkJQBdJD6UA6AK3RLgBMBXAq3wAPAA5wATi1aicoALyhRkCSnwAxeJHoAKAMysAjABYATAEoA3GgxhwuAsTKUchHiNYs0OEuKmgAbyU5AF9QLAk4ElAAIlZgGjpGZhQY60SUOEF4AHMdWSsgA)
You will not get any errors. However, if you turn on `checkJs` then you will
get error messages from the JavaScript file.
    ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
    Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUCBAIYA2JcA7gFYqgAu0ArpAWOAMYAWk7A1jagbNWEAGYBLEpAB2RALaRU7ONMR0i0uogB0NPHLgATRlO2QAHgAcEW7ZfGgAvKEtEkkAGLkidABQZtAEYsNABKAG48EXAJKVkFVHFpQwttLTxxOWtoOlAAbxcHAF9QUXg5UAAibWBlVXVNRErIusQ4U3IAc197CKA)
  * Related:
    * `allowJs`
    * `emitDeclarationOnly`
  * Released:
[2.3](/docs/handbook/release-notes/typescript-2-3.html)
### # Max Node Module JS Depth - `maxNodeModuleJsDepth`
The maximum dependency depth to search under `node_modules` and load
JavaScript files.
This flag can only be used when `allowJs` is enabled, and is used if you want
to have TypeScript infer types for all of the JavaScript inside your
`node_modules`.
Ideally this should stay at 0 (the default), and `d.ts` files should be used
to explicitly define the shape of modules. However, there are cases where you
may want to turn this on at the expense of speed and potential accuracy.
## #Editor Support
### # Disable Size Limit - `disableSizeLimit`
To avoid a possible memory bloat issues when working with very large
JavaScript projects, there is an upper limit to the amount of memory
TypeScript will allocate. Turning this flag on will remove the limit.
### # Plugins - `plugins`
List of language service plugins to run inside the editor.
Language service plugins are a way to provide additional information to a user
based on existing TypeScript files. They can enhance existing messages between
TypeScript and an editor, or to provide their own error messages.
For example:
  * [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) ‚Äî Adds SQL linting with a template strings SQL builder.
  * [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) ‚Äî Provides CSS linting inside template strings .
  * [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) ‚Äî Provides eslint error messaging and fix-its inside the compiler‚Äôs output.
  * [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) ‚Äî Provides validation and auto-completion inside GraphQL query template strings.
VS Code has the ability for a extension to [automatically include language
service plugins](https://code.visualstudio.com/api/references/contribution-
points#contributes.typescriptServerPlugins), and so you may have some running
in your editor without needing to define them in your `tsconfig.json`.
## #Interop Constraints
### # Allow Synthetic Default Imports - `allowSyntheticDefaultImports`
When set to true, `allowSyntheticDefaultImports` allows you to write an import
like:
    ts
    import React from "react";
instead of:
    ts
    import * as React from "react";
When the module **does not** explicitly specify a default export.
For example, without `allowSyntheticDefaultImports` as true:
    ts
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
    module.exports = {
      getStringLength,
    };
    // @filename: index.ts
    import utils from "./utilFunctions";
    Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.1192Module '"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions"' has no default export.
    const count = utils.getStringLength("Check JS");
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYCsBOdacMAoECAYwAtIyBrAKURLHAEMAbNuAdwaYkkQBZOABMArm0gBJAHYAXGHAAOqAGbtEkPuFUBLSTJYBbSKjFz9AMTEyyFuDMQA6AFaNS4GXClGlbXWS6cgCCMgCeahpaZA6IcqAA5pByAMpy0LoyCQAykFlyFKAAvKAAFHHQAJTFAHygFU4GCQUA3ERERqISkE6QAB5KCHKIxaAA3kSgiclpGVm5+RQANEQAvm3aegbGpqCZIv1Ow0S6vkOg5vojqvBGoABETsCXbNa29o73GzGO8TE28RKL2cSVS6UyOTyzQopXuAGEqLRQHQUvdKi0gA)
This code raises an error because there isn‚Äôt a `default` object which you can
import. Even though it feels like it should. For convenience, transpilers like
Babel will automatically create a default if one isn‚Äôt created. Making the
module look a bit more like:
    js
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
    const allFunctions = {
      getStringLength,
    };
    module.exports = allFunctions;
    module.exports.default = allFunctions;
This flag does not affect the JavaScript emitted by TypeScript, it‚Äôs only for
the type checking. This option brings the behavior of TypeScript in-line with
Babel, where extra code is emitted to make using a default export of a module
more ergonomic.
  * Default:
`true` if `esModuleInterop` is enabled, `module` is `system`, or
`moduleResolution` is `bundler`; `false` otherwise.
  * Related:
    * `esModuleInterop`
  * Released:
[1.8](/docs/handbook/release-notes/typescript-1-8.html)
### # ES Module Interop - `esModuleInterop`
By default (with `esModuleInterop` false or not set) TypeScript treats
CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two
parts in particular which turned out to be flawed assumptions:
  * a namespace import like `import * as moment from "moment"` acts the same as `const moment = require("moment")`
  * a default import like `import moment from "moment"` acts the same as `const moment = require("moment").default`
This mis-match causes these two issues:
  * the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require("x")` then TypeScript allowed for the import to be treated as a function and be callable. That‚Äôs not valid according to the spec.
  * while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn‚Äôt conform as strictly as TypeScript‚Äôs implementation.
Turning on `esModuleInterop` will fix both of these problems in the code
transpiled by TypeScript. The first changes the behavior in the compiler, the
second is fixed by two new helper functions which provide a shim to ensure
compatibility in the emitted JavaScript:
    ts
    import * as fs from "fs";
    import _ from "lodash";
    fs.readFileSync("file.txt", "utf8");
    _.chunk(["a", "b", "c", "d"], 2);
With `esModuleInterop` disabled:
    ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const lodash_1 = require("lodash");
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4BcoAGYBDFiioUIhRqyqCAxtEIzIAK3TFCvZKVAAqUCJTCTQpIVAAiISisBuNFp3w9AfWEXrLRsewO0NFsAOngqEQYAMWI2AGUAT0gFAAobGKpg0gAPUisAGmsmUiEADisASkc3YIVsJkgAa2SAbSsRfOsAIw6rBR6GKwBdAoAmSqA)
With `esModuleInterop` set to `true`:
    ts
    "use strict";
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = __importStar(require("fs"));
    const lodash_1 = __importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URCjVlQBcoAMbRCQyACt0xQr2SlQAKlABDFKABmuvUkKgARAdMBuNEpXw1AfX3GzLRjuxW0aAwDp4VFoMAGLEbADKAJ6QEgAU5mFUvqQAHqSmADRmTKR6ABymAJTWDr4S2EyQANaxANqmWplmAEZNphJtDKYAulkATMVAA)
_Note_ : The namespace import `import * as fs from "fs"` only accounts for
properties which [are owned](https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)
(basically properties set on the object and not via the prototype chain) on
the imported object. If the module you‚Äôre importing defines its API using
inherited properties, you need to use the default import form (`import fs from
"fs"`), or disable `esModuleInterop`.
_Note_ : You can make JS emit terser by enabling `importHelpers`:
    ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require("tslib");
    const fs = tslib_1.__importStar(require("fs"));
    const lodash_1 = tslib_1.__importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmOAKYoCy0AJgK4A2VAkpKVUgA4URihXslIAJKi1490mcIUasqALlABjaIQWQAVuiEj4pUACpQAQxSgAZletJCoAES2nAbjQHRoAPo2HziyMltjuaGi2AHTwVOYMAGLEbADKAJ6QagAULklUkaQAHqROADTOTKTWABxOAJQePpFq2EyQANaZANpO5qXOAEZ9TmpDDE4AumUATPVAA)
Enabling `esModuleInterop` will also enable `allowSyntheticDefaultImports`.
  * Recommended
  * Default:
`true` if `module` is `node16` or `nodenext`; `false` otherwise.
  * Related:
    * `allowSyntheticDefaultImports`
  * Released:
[2.7](/docs/handbook/release-notes/typescript-2-7.html)
### # Force Consistent Casing In File Names -
`forceConsistentCasingInFileNames`
TypeScript follows the case sensitivity rules of the file system it‚Äôs running
on. This can be problematic if some developers are working in a case-sensitive
file system and others aren‚Äôt. If a file attempts to import `fileManager.ts`
by specifying `./FileManager.ts` the file will be found in a case-insensitive
file system, but not on a case-sensitive file system.
When this option is set, TypeScript will issue an error if a program tries to
include a file by a casing different from the casing on disk.
  * Recommended
  * Default:
`true`
### # isolatedDeclarations - `isolatedDeclarations`
Require sufficient annotation on exports so other tools can trivially generate
declaration files.
For more information, see the [5.5 release notes](/docs/handbook/release-
notes/typescript-5-5.html#isolated-declarations)
### # Isolated Modules - `isolatedModules`
While you can use TypeScript to produce JavaScript code from TypeScript code,
it‚Äôs also common to use other transpilers such as [Babel](https://babeljs.io)
to do this. However, other transpilers only operate on a single file at a
time, which means they can‚Äôt apply code transforms that depend on
understanding the full type system. This restriction also applies to
TypeScript‚Äôs `ts.transpileModule` API which is used by some build tools.
These limitations can cause runtime problems with some TypeScript features
like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells
TypeScript to warn you if you write certain code that can‚Äôt be correctly
interpreted by a single-file transpilation process.
It does not change the behavior of your code, or otherwise change the behavior
of TypeScript‚Äôs checking and emitting process.
Some examples of code which does not work when `isolatedModules` is enabled.
#### Exports of Non-Value Identifiers
In TypeScript, you can import a _type_ and then subsequently export it:
    ts
    import { someType, someFunction } from "someModule";
    someFunction();
    export { someType, someFunction };
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEsC2AHZAXUAb1BWiwFMAVATxwoBpTyKAxAV0gGN8NpJQAX1AAzJFlAAiMpQCy0ACbsANhUkBuNGhltOPPpAAUASk1oKADzzxCJHbXpMdHbr35D1QA)
Because there‚Äôs no value for `someType`, the emitted `export` will not try to
export it (this would be a runtime error in JavaScript):
    js
    export { someFunction };
Single-file transpilers don‚Äôt know whether `someType` produces a value or not,
so it‚Äôs an error to export a name that only refers to a type.
#### Non-Module Files
If `isolatedModules` is set, namespaces are only allowed in _modules_ (which
means it has some form of `import`/`export`). An error occurs if a namespace
is found in a non-module file:
    ts
    namespace Instantiated {
    Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.1280Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.
      export const x = 1;
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYDsWBQIIBLROAGwEMAXSAEwFk4aBXUyRXAO3IFs2AHcgGNIoAJIdElch0qEqtUAG9coUJAAefBJVCC4EnetABedAG5cAXyA)
This restriction doesn‚Äôt apply to `.d.ts` files.
#### References to `const enum` members
In TypeScript, when you reference a `const enum` member, the reference is
replaced by its actual value in the emitted JavaScript. Changing this
TypeScript:
    ts
    declare const enum Numbers {
      Zero = 0,
      One = 1,
    }
    console.log(Numbers.Zero + Numbers.One);
    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iFBXAtvAHIEBGIMa8A3gFDzwBaFS8AvPAAwA098A8igQcAjLwC+tZOiQQQAOghIA5gAoS+cpXnMYrANTEyFNPMEgAlAG4gA)
To this JavaScript:
    ts
    "use strict";
    console.log(0 + 1);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggJwKbKwBu+AwrMsvgHbqSYAm+AxgDYCGBoLsNk6ULQCuyUADlRAI3y5IoAN6ZQoAFqzYoALygADABploAPI1820AEZDAX0y9+sNvgB0bWAHMAFJOQy5Luq4mgDUEtKykC6m+ACUANxAA)
Without knowledge of the values of these members, other transpilers can‚Äôt
replace the references to `Numbers`, which would be a runtime error if left
alone (since there are no `Numbers` object at runtime). Because of this, when
`isolatedModules` is set, it is an error to reference an ambient `const enum`
member.
  * Default:
`true` if `verbatimModuleSyntax`; `false` otherwise.
### # Preserve Symlinks - `preserveSymlinks`
This is to reflect the same flag in Node.js; which does not resolve the real
path of symlinks.
This flag also exhibits the opposite behavior to Webpack‚Äôs `resolve.symlinks`
option (i.e. setting TypeScript‚Äôs `preserveSymlinks` to true parallels setting
Webpack‚Äôs `resolve.symlinks` to false, and vice-versa).
With this enabled, references to modules and packages (e.g. `import`s and `///
<reference type="..." />` directives) are all resolved relative to the
location of the symbolic link file, rather than relative to the path that the
symbolic link resolves to.
### # Verbatim Module Syntax - `verbatimModuleSyntax`
By default, TypeScript does something called _import elision_. Basically, if
you write something like
    ts
    import { Car } from "./car";
    export function drive(car: Car) {
      // ...
    }
TypeScript detects that you‚Äôre only using an import for types and drops the
import entirely. Your output JavaScript might look something like this:
    js
    export function drive(car) {
      // ...
    }
Most of the time this is good, because if `Car` isn‚Äôt a value that‚Äôs exported
from `./car`, we‚Äôll get a runtime error.
But it does add a layer of complexity for certain edge cases. For example,
notice there‚Äôs no statement like `import "./car";` \- the import was dropped
entirely. That actually makes a difference for modules that have side-effects
or not.
TypeScript‚Äôs emit strategy for JavaScript also has another few layers of
complexity - import elision isn‚Äôt always just driven by how an import is used
- it often consults how a value is declared as well. So it‚Äôs not always clear
whether code like the following
    ts
    export { Car } from "./car";
should be preserved or dropped. If `Car` is declared with something like a
`class`, then it can be preserved in the resulting JavaScript file. But if
`Car` is only declared as a `type` alias or `interface`, then the JavaScript
file shouldn‚Äôt export `Car` at all.
While TypeScript might be able to make these emit decisions based on
information from across files, not every compiler can.
The `type` modifier on imports and exports helps with these situations a bit.
We can make it explicit whether an import or export is only being used for
type analysis, and can be dropped entirely in JavaScript files by using the
`type` modifier.
    ts
    // This statement can be dropped entirely in JS output
    import type * as car from "./car";
    // The named import/export 'Car' can be dropped in JS output
    import { type Car } from "./car";
    export { type Car } from "./car";
`type` modifiers are not quite useful on their own - by default, module
elision will still drop imports, and nothing forces you to make the
distinction between `type` and plain imports and exports. So TypeScript has
the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier,
`--preserveValueImports` to prevent _some_ module elision behavior, and
`--isolatedModules` to make sure that your TypeScript code works across
different compilers. Unfortunately, understanding the fine details of those 3
flags is hard, and there are still some edge cases with unexpected behavior.
TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to
simplify the situation. The rules are much simpler - any imports or exports
without a `type` modifier are left around. Anything that uses the `type`
modifier is dropped entirely.
    ts
    // Erased away entirely.
    import type { A } from "a";
    // Rewritten to 'import { b } from "bcd";'
    import { b, type c, type d } from "bcd";
    // Rewritten to 'import {} from "xyz";'
    import { type xyz } from "xyz";
With this new option, what you see is what you get.
That does have some implications when it comes to module interop though. Under
this flag, ECMAScript `import`s and `export`s won‚Äôt be rewritten to `require`
calls when your settings or file extension implied a different module system.
Instead, you‚Äôll get an error. If you need to emit code that uses `require` and
`module.exports`, you‚Äôll have to use TypeScript‚Äôs module syntax that predates
ES2015:
Input TypeScript | Output JavaScript  
---|---  
    tsimport foo = require("foo");
|
    jsconst foo = require("foo");  
    tsfunction foo() {}function bar() {}function baz() {}export = {  foo,  bar,  baz,};
|
    jsfunction foo() {}function bar() {}function baz() {}module.exports = {  foo,  bar,  baz,};  
While this is a limitation, it does help make some issues more obvious. For
example, it‚Äôs very common to forget to set the [`type` field in
`package.json`](https://nodejs.org/api/packages.html#type) under `--module
node16`. As a result, developers would start writing CommonJS modules instead
of an ES modules without realizing it, giving surprising lookup rules and
JavaScript output. This new flag ensures that you‚Äôre intentional about the
file type you‚Äôre using because the syntax is intentionally different.
Because `--verbatimModuleSyntax` provides a more consistent story than
`--importsNotUsedAsValues` and `--preserveValueImports`, those two existing
flags are being deprecated in its favor.
For more details, read up on [the original pull
request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal
issue](https://github.com/microsoft/TypeScript/issues/51479).
## #Backwards Compatibility
### # Charset - `charset`
In prior versions of TypeScript, this controlled what encoding was used when
reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but
will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.
  * Deprecated
  * Default:
`utf8`
### # Imports Not Used As Values - `importsNotUsedAsValues`
Deprecated in favor of `verbatimModuleSyntax`.
This flag controls how `import` works, there are 3 different options:
  * `remove`: The default behavior of dropping `import` statements which only reference types.
  * `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.
  * `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.
This flag works because you can use `import type` to explicitly create an
`import` statement which should never be emitted into JavaScript.
  * Default:
`remove`
  * Allowed:
    * `remove`
    * `preserve`
    * `error`
  * Related:
    * `preserveValueImports`
    * `verbatimModuleSyntax`
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
### # Keyof Strings Only - `keyofStringsOnly`
This flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.
This flag is used to help people keep this behavior from [before TypeScript
2.9‚Äôs release](/docs/handbook/release-notes/typescript-2-9.html#support-
number-and-symbol-named-properties-with-keyof-and-mapped-types).
  * Deprecated
  * Released:
[2.9](/docs/handbook/release-notes/typescript-2-9.html)
### # No Implicit Use Strict - `noImplicitUseStrict`
You shouldn‚Äôt need this. By default, when emitting a module file to a non-ES6
target, TypeScript emits a `"use strict";` prologue at the top of the file.
This setting disables the prologue.
### # No Strict Generic Checks - `noStrictGenericChecks`
TypeScript will unify type parameters when comparing two generic functions.
    ts
    type A = <T, U>(x: T, y: U) => [T, U];
    type B = <S>(x: S, y: S) => [S, S];
    function f(a: A, b: B) {
      b = a; // Ok
      a = b; // Error
    Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.2322Type 'B' is not assignable to type 'A'.
      Types of parameters 'y' and 'y' are incompatible.
        Type 'U' is not assignable to type 'T'.
          'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFA4C4CeADpKAIKgC8oAPACoA0oAqgHwAUAHqk6IahYBKam1ABtPiwC6AbgIkyAIWp0Aypx6g1zAdpFUx4ndrl4AZgFcAdgGN8ASzjXQ5jgENU5ZgCNUSkQBvHFBQH1V3WVAQUAB5AGsQ0HdVHyiYgFFYBBwAXyA)
This flag can be used to remove that check.
  * Released:
[2.4](/docs/handbook/release-notes/typescript-2-4.html)
### # Out - `out`
Use `outFile` instead.
The `out` option computes the final file location in a way that is not
predictable or consistent. This option is retained for backward compatibility
only and is deprecated.
  * Deprecated
  * Related:
    * `outDir`
    * `outFile`
### # Preserve Value Imports - `preserveValueImports`
Deprecated in favor of `verbatimModuleSyntax`.
There are some cases where TypeScript can‚Äôt detect that you‚Äôre using an
import. For example, take the following code:
    ts
    import { Animal } from "./animal.js";
    eval("console.log(new Animal().isDangerous())");
or code using ‚ÄòCompiles to HTML‚Äô languages like Svelte or Vue.
`preserveValueImports` will prevent TypeScript from removing the import, even
if it appears unused.
When combined with `isolatedModules`: imported types _must_ be marked as type-
only because compilers that process single files at a time have no way of
knowing whether imports are values that appear unused, or a type that must be
removed in order to avoid a runtime crash.
  * Related:
    * `isolatedModules`
    * `importsNotUsedAsValues`
    * `verbatimModuleSyntax`
  * Released:
[4.5](/docs/handbook/release-notes/typescript-4-5.html)
### # Suppress Excess Property Errors - `suppressExcessPropertyErrors`
This disables reporting of excess property errors, such as the one shown in
the following example:
    ts
    type Point = { x: number; y: number };
    const p: Point = { x: 1, y: 3, m: 10 };
    Object literal may only specify known properties, and 'm' does not exist in type 'Point'.2353Object literal may only specify known properties, and 'm' does not exist in type 'Point'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAAU4BLAOz1AF5QBvUAD1WoFcBbAIxgDcoAhx79ooAL4CcAYzjVEdIqgo06jFu1ABGADTDUGA91Q6ADFIFA)
This flag was added to help people migrate to the stricter checking of new
object literals in [TypeScript 1.6](/docs/handbook/release-
notes/typescript-1-6.html#stricter-object-literal-assignment-checks).
We don‚Äôt recommend using this flag in a modern codebase, you can suppress one-
off cases where you need it using `// @ts-ignore`.
### # Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`
Turning `suppressImplicitAnyIndexErrors` on suppresses reporting the error
about implicit anys when indexing into objects, as shown in the following
example:
    ts
    const obj = { x: 10 };
    console.log(obj["foo"]);
    Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.7053Element implicitly has an 'any' type because expression of type '"foo"' can't be used to index type '{ x: number; }'.
      Property 'foo' does not exist on type '{ x: number; }'.[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM7mKKmX30IobZ76yQATSgA8AoqVLRS9YgDMAhsno064emQxZiZKrTDhKEqTNAB2AAwBWAMzV00SOtDQARgCtQAXlABvUMOIARnNQAF8AbjsHemhkSgA6ZGgAcwAKVzcAbQAiWWhobIBdAEpwoA)
Using `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is
recommended to use a `@ts-ignore` comment instead:
    ts
    const obj = { x: 10 };
    // @ts-ignore
    console.log(obj["foo"]);
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoWATgK4CmAUCBAM5kZbFlXXrSSOjQBGAK1ABeUAG9QAD2IBGAAygAvgG5aYcFnoBaVAHMYpGp27RklAHTJougBT8BAbQBEAM2jQnAXQCUyoA)
  * Related:
    * `noImplicitAny`
## #Language and Environment
### # Emit Decorator Metadata - `emitDecoratorMetadata`
Enables experimental support for emitting type metadata for decorators which
works with the module [`reflect-
metadata`](https://www.npmjs.com/package/reflect-metadata).
For example, here is the TypeScript
    ts
    function LogMethod(
      target: any,
      propertyKey: string | symbol,
      descriptor: PropertyDescriptor
    ) {
      console.log(target);
      console.log(propertyKey);
      console.log(descriptor);
    }
    class Demo {
      @LogMethod
      public foo(bar: number) {
        // do nothing
      }
    }
    const demo = new Demo();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgAyJA5gLKRMACxIATABQ1QoHAh6CAXKGzoAngBopoWAhLwEmVQGlIqpVUzJ0PUAB9QVVSgBGJXJumjIVIsliUEJQAFXX1DQh8-AJoASlAAby1SdCo3SAA6XF5xWXlMGIBuJPZU3AysnnEdPURDE1VC4pS0zOyvSKR-MkaAXxoaIlxsKipQQhQSBK1wbn5BEVEtWAZnXCQiUDoSEnFnbEDQdAYXRDjE6WkQUFFJ9BJhJGstPr6BksxryAnQAF5DyAA7mMvjtCkA)
With `emitDecoratorMetadata` not set to true (default) the emitted JavaScript
is:
    ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmNAZgK7oimJCXSgAMiQDmAWUiZmAEwAUNUKBwIp8gFyhs6AJ4AaNaFgIS8BJkMBpSIb1VMydFNAAfUFUMoARiS4puqKkFREyLCUCHoACpbWtoQRUTE0AJSgAN5mpOhUQZAAdLjSypramBkA3HmihbglZVLKFlaItg6GtfUFRaXlYalI0WS9AL40NES42FRUoIQoJDlm4JKy8kpmsHz+uEhEoDwkJMr+2LGg6HwBiFm56ur0iqvoJApI7mZTUzMNTCgMIrUAAXhukBYS0gK2UtSAA)
With `emitDecoratorMetadata` set to true the emitted JavaScript is:
    ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEVAFiQO4CiKSmdYUnmhUuUoIAspBwATCthoAzAK7oimJCXSgAMiQDm4zM0kAKGqFA4EOiQC5Q2dAE8ANKdCwEJeAkwOA0pAdbKkxkdB1QAB9QKgcUACMSXBczSUgqImRYEVsABQ8vH0J0zJEaAEpQAG9XUnQqRMgAOlxdIwsrTDKAbhr1etwmlp0jd09EH38Hbt66hubW1OKkLLJpgF8aGiJcbCoqUEIUEirXcG09CUNXWAU43CQiUDkSEiM47ARbdAV4xArqsxmeiSY7oEgGJBhVwbDZbPqYUCpI6gAC8oHQkBYB0gRyM3SAA)
  * Related:
    * `experimentalDecorators`
### # Experimental Decorators - `experimentalDecorators`
Enables [experimental support for
decorators](https://github.com/tc39/proposal-decorators), which is a version
of decorators that predates the TC39 standardization process.
Decorators are a language feature which hasn‚Äôt yet been fully ratified into
the JavaScript specification. This means that the implementation version in
TypeScript may differ from the implementation in JavaScript when it it decided
by TC39.
You can find out more about decorator support in TypeScript in [the
handbook](/docs/handbook/decorators.html).
  * Related:
    * `emitDecoratorMetadata`
### # JSX - `jsx`
Controls how JSX constructs are emitted in JavaScript files. This only affects
output of JS files that started in `.tsx` files.
  * `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production
  * `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only
  * `preserve`: Emit `.jsx` files with the JSX unchanged
  * `react-native`: Emit `.js` files with the JSX unchanged
  * `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls
### For example
This sample code:
    tsx
    export const HelloWorld = () => <h1>Hello world</h1>;
React: `"react-jsx"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-
new-jsx-transform.html)
    tsx
    import { jsx as _jsx } from "react/jsx-runtime";
    export const HelloWorld = () => _jsx("h1", { children: "Hello world" });
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q2kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQLAHxwADwZAIzro+MQcNkzrFvke+txQA)
React dev transform: `"react-
jsxdev"`[[1]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html)
    tsx
    import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
    const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx";
    export const HelloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhM9Q3sAG6kSA2QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJTLAHxwADwZAIxbE1MQcNnzrLvkh1txQA)
Preserve: `"preserve"`
    tsx
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BYET2agBuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlEsAfHAAPBkAjJvjkxBw2XOsO+QHm3FAA)
React Native: `"react-native"`
    tsx
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9kVpAFb2AB4BROhMSigwwABuSKRIDZCwcGgQSkFwABJInJwQAOrQnKxwALxwABQAlKsAfHAAPBkAjDtTMxBw2Yus++THO3FAA)
Legacy React runtime: `"react"`
    tsx
    import React from 'react';
    export const HelloWorld = () => React.createElement("h1", null, "Hello world");
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbrSATJNAGxSLhAlb1OSOACkAygA04Ab1Jw4wAHYwkUTOhEBRYSCQrZAX3mKVajWhEBJFVGUBnYGh1I9K+7JMKA2vYBccPYwdkoA5gC6AShKAJ4A3CbGxpRwAAL2ABYQAO5aIMAwFFSpShBaUDhQ9qRIAB6QsHBoEEpBcAASSJycEADq0JyscAC8cAAUAJQjAHxwADwZAIzTnd0QcNkDrHPkS9NxQA)
This option can be used on a per-file basis too using an `@jsxRuntime`
comment.
Always use the classic runtime (`"react"`) for this file:
    tsx
    /* @jsxRuntime classic */
    export const HelloWorld = () => <h1>Hello world</h1>;
Always use the automatic runtime (`"react-jsx"`) for this file:
    tsx
    /* @jsxRuntime automatic */
    export const HelloWorld = () => <h1>Hello world</h1>;
  * Allowed:
    * `preserve`
    * `react`
    * `react-native`
    * `react-jsx`
    * `react-jsxdev`
  * Related:
    * `jsxFactory`
    * `jsxFragmentFactory`
    * `jsxImportSource`
  * Released:
[2.2](/docs/handbook/release-notes/typescript-2-2.html)
### # JSX Factory - `jsxFactory`
Changes the function called in `.js` files when compiling JSX Elements using
the classic JSX runtime. The most common change is to use `"h"` or
`"preact.h"` instead of the default `"React.createElement"` if using `preact`.
For example, this TSX file:
    tsx
    import { h } from "preact";
    const HelloWorld = () => <div>Hello</div>;
With `jsxFactory: "h"` looks like:
    tsx
    const preact_1 = require("preact");
    const HelloWorld = () => (0, preact_1.h)("div", null, "Hello");
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdTmiPyg4oJymJgooAcyQw6kgcmnoinmwgELL0KupouFGaxqSkoJCwcADecFwANHDyUCi+IEia8AC+cNi4cABEYERW9QDcqQmaHPAAEkhKShAA6tBKsnAAvHAAFACUkwB8cAA8ssAAbgt9AxDL5GubrUA)
This option can be used on a per-file basis too similar to [Babel‚Äôs `/** @jsx
h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-
jsx#custom).
    tsx
    /** @jsx h */
    import { h } from "preact";
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    const HelloWorld = () => <div>Hello</div>;
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3KlQkWHADewuAF842XHABEYIuhhqA3KVJoIAO17wAEkgA2ViAHVoVgCZwAvHAAUASjcA+OAA8TsAAbr6WNhAB5MFhukA)
The factory chosen will also affect where the `JSX` namespace is looked up
(for type checking information) before falling back to the global one.
If the factory is defined as `React.createElement` (the default), the compiler
will check for `React.JSX` before checking for a global `JSX`. If the factory
is defined as `h`, it will check for `h.JSX` before a global `JSX`.
  * Default:
`React.createElement`
  * Allowed:
    * Any identifier or dotted identifier.
  * Related:
    * `jsx`
    * `jsxFragmentFactory`
    * `jsxImportSource`
### # JSX Fragment Factory - `jsxFragmentFactory`
Specify the JSX fragment factory function to use when targeting react JSX emit
with `jsxFactory` compiler option is specified, e.g. `Fragment`.
For example with this TSConfig:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react",
        "[jsxFactory](https://www.typescriptlang.org/tsconfig#jsxFactory)": "h",
        "[jsxFragmentFactory](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)": "Fragment"
      }
    }
This TSX file:
    tsx
    import { h, Fragment } from "preact";
    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
Would look like:
    tsx
    const preact_1 = require("preact");
    const HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,
        (0, preact_1.h)("div", null, "Hello")));
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOJx4ChMGEgAmAMWAAbJAC44wAHaykADwB0AKw6i2x3fPQxoAT3VdT5+VBQBzEEk0xLGW+uduHl6mmhD8UDhQJpRiMChQrkgw6kgcmnoiMWwgELL0KupouDmaxqSkoJCwcADecFwANHAB7p7wAL5w2LhwAERgRFa9ANzlRZoc8AASSEpKEADq0EqycAC8cAAUAJTrAHxbpHBwADx7R8enssAAbnszcxAn5Nd3F8-n28NAA)
This option can be used on a per-file basis too similar to [Babel‚Äôs `/*
@jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-
react-jsx#fragments).
For example:
    tsx
    /** @jsx h */
    /** @jsxFrag Fragment */
    import { h, Fragment } from "preact";
    Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.
    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKAqVuAAQCsBnADzgALOK3JsOPAQDEoKAOZxZCkEgB28MaVKhIsOAG9hAGiVz5qjXAC+cbLjgAiMEXQxHAbm1oIa3vAAJJAAbYIgAdWhggBM4AF44AAoASniAPiTSODgAHjSs7Nzo4AA3NKDQiBzyYrKC6vzkjyA)
  * Default:
`React.Fragment`
  * Related:
    * `jsx`
    * `jsxFactory`
    * `jsxImportSource`
  * Released:
[4.0](/docs/handbook/release-notes/typescript-4-0.html)
### # JSX Import Source - `jsxImportSource`
Declares the module specifier to be used for importing the `jsx` and `jsxs`
factory functions when using `jsx` as `"react-jsx"` or `"react-jsxdev"` which
were introduced in TypeScript 4.1.
With [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-
transform.html) the library supports a new form of JSX transformation via a
separate import.
For example with this code:
    tsx
    import React from "react";
    function App() {
      return <h1>Hello World</h1>;
    }
Using this TSConfig:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx"
      }
    }
The emitted JavaScript from TypeScript is:
    tsx
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const jsx_runtime_1 = require("react/jsx-runtime");
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
    [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAggO1ogE6GyGTZjgBWkAHgFyiECmAhgMboC0NtFEyWABMArgBtmjdrGSDcNfuHStCAc2bpGzSLma0sQ5uzErmoQaImgAUgGUAGqADemUKFS50zQgDMOZxAlkZk9nAF9Xd09vP3YzAElPQg9IVHZA5mDPSGdItwBtSEZIdGTcVQBdRlZcAE8AbkiIiNRkAAdSdFAAJTZOUB8SZFAAIhYOdBHGzB8RXE5UWFxQAEE2toAKAEpctxZ0EUJlgB5oAEYAPgAJZjExWFAAdVIxIWPgc4vGsKA)
For example if you wanted to use `"jsxImportSource": "preact"`, you need a
tsconfig like:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[target](https://www.typescriptlang.org/tsconfig#target)": "esnext",
        "[module](https://www.typescriptlang.org/tsconfig#module)": "commonjs",
        "[jsx](https://www.typescriptlang.org/tsconfig#jsx)": "react-jsx",
        "[jsxImportSource](https://www.typescriptlang.org/tsconfig#jsxImportSource)": "preact",
        "[types](https://www.typescriptlang.org/tsconfig#types)": ["preact"]
      }
    }
Which generates code like:
    tsx
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
    [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAZwAsIB3AURDAYrOGwBWHAB4BJcNBgBlCPShokALjhgi6EZTEwAnmCQctO4vvaSpW3Rmq3RbGCigBzJDC1mAdkhS1mIgEAAm9AA2mnBouKF+ki5+EPxQOFAcpKSBkLBwmPR+GMAQfnAAgmBgABQAlHAA3qRwcEQwquUAPFwAjAB8ABJIkZEQcADq0JFhXeR9-QDcpAC+QA)
Alternatively, you can use a per-file pragma to set this option, for example:
    tsx
    /** @jsxImportSource preact */
    export function App() {
      return <h1>Hello World</h1>;
    }
Would add `preact/jsx-runtime` as an import for the `_jsx` factory.
_Note:_ In order for this to work like you would expect, your `tsx` file must
include an `export` or `import` so that it is considered a module.
  * Default:
`react`
  * Related:
    * `jsx`
    * `jsxFactory`
  * Released:
[4.1](/docs/handbook/release-notes/typescript-4-1.html)
### # Lib - `lib`
TypeScript includes a default set of type definitions for built-in JS APIs
(like `Math`), as well as type definitions for things found in browser
environments (like `document`). TypeScript also includes APIs for newer JS
features matching the `target` you specify; for example the definition for
`Map` is available if `target` is `ES6` or newer.
You may want to change these for a few reasons:
  * Your program doesn‚Äôt run in a browser, so you don‚Äôt want the `"dom"` type definitions
  * Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn‚Äôt yet support the full syntax of a given ECMAScript version
  * You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version
In TypeScript 4.5, lib files can be overridden by npm modules, find out more
[in the blog](https://devblogs.microsoft.com/typescript/announcing-
typescript-4-5-beta/#supporting-lib-from-node_modules).
### High Level libraries
Name | Contents  
---|---  
`ES5` | Core definitions for all ES5 functionality  
`ES2015` | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.  
`ES6` | Alias for ‚ÄúES2015‚Äù  
`ES2016` | Additional APIs available in ES2016 - `array.include`, etc.  
`ES7` | Alias for ‚ÄúES2016‚Äù  
`ES2017` | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc.  
`ES2018` | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.  
`ES2019` | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.  
`ES2020` | Additional APIs available in ES2020 - `string.matchAll`, etc.  
`ES2021` | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.  
`ES2022` | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.  
`ES2023` | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.  
`ESNext` | Additional APIs available in ESNext - This changes as the JavaScript specification evolves  
`DOM` | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.  
`WebWorker` | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts  
`ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)  
### Individual library components
Name  
---  
`DOM.Iterable`  
`ES2015.Core`  
`ES2015.Collection`  
`ES2015.Generator`  
`ES2015.Iterable`  
`ES2015.Promise`  
`ES2015.Proxy`  
`ES2015.Reflect`  
`ES2015.Symbol`  
`ES2015.Symbol.WellKnown`  
`ES2016.Array.Include`  
`ES2017.object`  
`ES2017.Intl`  
`ES2017.SharedMemory`  
`ES2017.String`  
`ES2017.TypedArrays`  
`ES2018.Intl`  
`ES2018.Promise`  
`ES2018.RegExp`  
`ES2019.Array`  
`ES2019.Object`  
`ES2019.String`  
`ES2019.Symbol`  
`ES2020.String`  
`ES2020.Symbol.wellknown`  
`ES2021.Promise`  
`ES2021.String`  
`ES2021.WeakRef`  
`ESNext.AsyncIterable`  
`ESNext.Array`  
`ESNext.Intl`  
`ESNext.Symbol`  
This list may be out of date, you can see the full list in the [TypeScript
source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).
  * Related:
    * `noLib`
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
### # Module Detection - `moduleDetection`
This setting controls how TypeScript determines whether a file is a [script or
a module](/docs/handbook/modules/theory.html#scripts-and-modules-in-
javascript).
There are three choices:
  * `"auto"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `"type"` field in a `package.json` is set to `"module"` when running with `module`: `nodenext` or `node16`, and check whether the current file is a JSX file when running under `jsx`: `react-jsx`.
  * `"legacy"` \- The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.
  * `"force"` \- Ensures that every non-declaration file is treated as a module.
  * Default:
"auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-
jsx), or esm format (with module: node16+) as modules.
  * Allowed:
    * `legacy`
    * `auto`
    * `force`
  * Released:
[4.7](/docs/handbook/release-notes/typescript-4-7.html)
### # No Lib - `noLib`
Disables the automatic inclusion of any library files. If this option is set,
`lib` is ignored.
TypeScript _cannot_ compile anything without a set of interfaces for key
primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`,
`Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you
will be including your own type definitions for these.
  * Related:
    * `lib`
### # React Namespace - `reactNamespace`
Use `jsxFactory` instead. Specify the object invoked for `createElement` when
targeting `react` for TSX files.
  * Default:
`React`
### # Target - `target`
Modern browsers support all ES6 features, so `ES6` is a good choice. You might
choose to set a lower target if your code is deployed to older environments,
or a higher target if your code is guaranteed to run in newer environments.
The `target` setting changes which JS features are downleveled and which are
left intact. For example, an arrow function `() => this` will be turned into
an equivalent `function` expression if `target` is ES5 or lower.
Changing `target` also changes the default value of `lib`. You may ‚Äúmix and
match‚Äù `target` and `lib` settings as desired, but you could just set `target`
for convenience.
For developer platforms like Node there are baselines for the `target`,
depending on the type of platform and its version. You can find a set of
community organized TSConfigs at
[tsconfig/bases](https://github.com/tsconfig/bases#centralized-
recommendations-for-tsconfig-bases), which has configurations for common
platforms and their versions.
The special `ESNext` value refers to the highest version your version of
TypeScript supports. This setting should be used with caution, since it
doesn‚Äôt mean the same thing between different TypeScript versions and can make
upgrades less predictable.
  * Default:
`ES5`
  * Allowed:
    * `es3`
    * `es5`
    * `es6`/`es2015`
    * `es2016`
    * `es2017`
    * `es2018`
    * `es2019`
    * `es2020`
    * `es2021`
    * `es2022`
    * `es2023`
    * `esnext`
  * Released:
[1.0](/docs/handbook/release-notes/typescript-1-0.html)
### # Use Define For Class Fields - `useDefineForClassFields`
This flag is used as part of migrating to the upcoming standard version of
class fields. TypeScript introduced class fields many years before it was
ratified in TC39. The latest version of the upcoming specification has a
different runtime behavior to TypeScript‚Äôs implementation but the same syntax.
This flag switches to the upcoming ECMA runtime behavior.
You can read more about the transition in [the 3.7 release
notes](/docs/handbook/release-notes/typescript-3-7.html#the-
usedefineforclassfields-flag-and-the-declare-property-modifier).
  * Default:
`true` if `target` is `ES2022` or higher, including `ESNext`; `false`
otherwise.
  * Released:
[3.7](/docs/handbook/release-notes/typescript-3-7.html)
## #Compiler Diagnostics
### # Diagnostics - `diagnostics`
Used to output diagnostic information for debugging. This command is a subset
of `extendedDiagnostics` which are more user-facing results, and easier to
interpret.
If you have been asked by a TypeScript compiler engineer to give the results
using this flag in a compile, in which there is no harm in using
`extendedDiagnostics` instead.
  * Deprecated
  * Related:
    * `extendedDiagnostics`
### # Explain Files - `explainFiles`
Print names of files which TypeScript sees as a part of your project and the
reason they are part of the compilation.
For example, with this project of just a single `index.ts` file
    sh
    example
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ tsconfig.json
Using a `tsconfig.json` which has `explainFiles` set to true:
    json
    {
      "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "explainFiles": true
      }
    }
Running TypeScript against this folder would have output like this:
    ‚ùØ tsc
    node_modules/typescript/lib/lib.d.ts
      Default library for target 'es5'
    node_modules/typescript/lib/lib.es5.d.ts
      Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.dom.d.ts
      Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.webworker.importscripts.d.ts
      Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.scripthost.d.ts
      Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'
    index.ts
      Matched by include pattern '**/*' in 'tsconfig.json'
The output above show:
  * The initial lib.d.ts lookup based on `target`, and the chain of `.d.ts` files which are referenced
  * The `index.ts` file located via the default pattern of `include`
This option is intended for debugging how a file has become a part of your
compile.
  * Released:
[4.2](/docs/handbook/release-notes/typescript-4-2.html)
### # Extended Diagnostics - `extendedDiagnostics`
You can use this flag to discover where TypeScript is spending its time when
compiling. This is a tool used for understanding the performance
characteristics of your codebase overall.
You can learn more about how to measure and understand the output in the
performance [section of the
wiki](https://github.com/microsoft/TypeScript/wiki/Performance).
  * Related:
    * `diagnostics`
### # Generate CPU Profile - `generateCpuProfile`
This option gives you the chance to have TypeScript emit a v8 CPU profile
during the compiler run. The CPU profile can provide insight into why your
builds may be slow.
This option can only be used from the CLI via: `--generateCpuProfile tsc-
output.cpuprofile`.
    sh
    npm run tsc --generateCpuProfile tsc-output.cpuprofile
This file can be opened in a chromium based browser like Chrome or Edge
Developer in [the CPU
profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-
tools/js-execution) section. You can learn more about understanding the
compilers performance in the [TypeScript wiki section on
performance](https://github.com/microsoft/TypeScript/wiki/Performance).
  * Default:
`profile.cpuprofile`
  * Released:
[3.7](/docs/handbook/release-notes/typescript-3-7.html)
### # generateTrace - `generateTrace`
Generates an event trace and a list of types.
### # List Emitted Files - `listEmittedFiles`
Print names of generated files part of the compilation to the terminal.
This flag is useful in two cases:
  * You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.
  * You are not sure that TypeScript has included a file you expected, as a part of debugging the file inclusion settings.
For example:
    example
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ tsconfig.json
With:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[declaration](https://www.typescriptlang.org/tsconfig#declaration)": true,
        "[listEmittedFiles](https://www.typescriptlang.org/tsconfig#listEmittedFiles)": true
      }
    }
Would echo paths like:
    $ npm run tsc
    path/to/example/index.js
    path/to/example/index.d.ts
Normally, TypeScript would return silently on success.
### # List Files - `listFiles`
Print names of files part of the compilation. This is useful when you are not
sure that TypeScript has included a file you expected.
For example:
    example
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ tsconfig.json
With:
    {
      "[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions)": {
        "[listFiles](https://www.typescriptlang.org/tsconfig#listFiles)": true
      }
    }
Would echo paths like:
    $ npm run tsc
    path/to/example/node_modules/typescript/lib/lib.d.ts
    path/to/example/node_modules/typescript/lib/lib.es5.d.ts
    path/to/example/node_modules/typescript/lib/lib.dom.d.ts
    path/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    path/to/example/node_modules/typescript/lib/lib.scripthost.d.ts
    path/to/example/index.ts
Note if using TypeScript 4.2, prefer `explainFiles` which offers an
explanation of why a file was added too.
  * Related:
    * `explainFiles`
### # noCheck - `noCheck`
Disable full type checking (only critical parse and emit errors will be
reported).
### # Trace Resolution - `traceResolution`
When you are trying to debug why a module isn‚Äôt being included. You can set
`traceResolution` to `true` to have TypeScript print information about its
resolution process for each processed file.
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
## #Projects
### # Composite - `composite`
The `composite` option enforces certain constraints which make it possible for
build tools (including TypeScript itself, under `--build` mode) to quickly
determine if a project has been built yet.
When this setting is on:
  * The `rootDir` setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.
  * All implementation files must be matched by an `include` pattern or listed in the `files` array. If this constraint is violated, `tsc` will inform you which files weren‚Äôt specified.
  * `declaration` defaults to `true`
You can find documentation on TypeScript projects in [the
handbook](https://www.typescriptlang.org/docs/handbook/project-
references.html).
  * Related:
    * `incremental`
    * `tsBuildInfoFile`
  * Released:
[3.0](/docs/handbook/release-notes/typescript-3-0.html)
### # Disable Referenced Project Load - `disableReferencedProjectLoad`
In multi-project TypeScript programs, TypeScript will load all of the
available projects into memory in order to provide accurate results for editor
responses which require a full knowledge graph like ‚ÄòFind All References‚Äô.
If your project is large, you can use the flag `disableReferencedProjectLoad`
to disable the automatic loading of all projects. Instead, projects are loaded
dynamically as you open files through your editor.
  * Released:
[4.0](/docs/handbook/release-notes/typescript-4-0.html)
### # Disable Solution Searching - `disableSolutionSearching`
When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to declare that you do not want a
project to be included when using features like _find all references_ or _jump
to definition_ in an editor.
This flag is something you can use to increase responsiveness in large
composite projects.
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
### # Disable Source Project Reference Redirect -
`disableSourceOfProjectReferenceRedirect`
When working with [composite TypeScript projects](/docs/handbook/project-
references.html), this option provides a way to go [back to the
pre-3.7](/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-
with-project-references) behavior where d.ts files were used to as the
boundaries between modules. In 3.7 the source of truth is now your TypeScript
files.
  * Released:
[3.7](/docs/handbook/release-notes/typescript-3-7.html)
### # Incremental - `incremental`
Tells TypeScript to save information about the project graph from the last
compilation to files stored on disk. This creates a series of `.tsbuildinfo`
files in the same folder as your compilation output. They are not used by your
JavaScript at runtime and can be safely deleted. You can read more about the
flag in the [3.4 release notes](/docs/handbook/release-
notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-
flag).
To control which folders you want to the files to be built to, use the config
option `tsBuildInfoFile`.
  * Default:
`true` if `composite`; `false` otherwise.
  * Related:
    * `composite`
    * `tsBuildInfoFile`
  * Released:
[3.4](/docs/handbook/release-notes/typescript-3-4.html)
### # TS Build Info File - `tsBuildInfoFile`
This setting lets you specify a file for storing incremental compilation
information as a part of composite projects which enables faster building of
larger TypeScript codebases. You can read more about composite projects [in
the handbook](/docs/handbook/project-references.html).
The default depends on a combination of other settings:
  * If `outFile` is set, the default is `<outFile>.tsbuildinfo`.
  * If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.
  * If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`
  * Otherwise, the default is `<config name>.tsbuildInfo`
  * Default:
`.tsbuildinfo`
  * Related:
    * `incremental`
    * `composite`
  * Released:
[3.4](/docs/handbook/release-notes/typescript-3-4.html)
## #Output Formatting
### # No Error Truncation - `noErrorTruncation`
Do not truncate error messages.
With `false`, the default.
    ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQAbgIbSgAeqA3kaKAA7xMwAuAngOoCW7ACwCCAOwCiVAMaRIAE14iA5gBtOAGThKAcmQC2kAIypE7aAsUBuBs1Yce-YeKkz5S1Ru17IaY6fNXGFjg2aC4+QVEJaTlzd01FHX0MXzMlAJtgu3DHKJdY9XjEyFwU-2sgkLCHSOcYtwLPfXxStPLbUPsIp2jXFQaErwA2Fss2zI7smp78jwH9AHYR9Iqs6u68+tmigA4logBfKyIQUABlPyVQaEgWSERIEXYydl5NUDgAM1AuNnevgHIqP9QIgBHAAK7KWSgABGkG+0HBIkkzzkoAUoBg8Eo+kQiDIikgpAoIJGoAAvNQLEA)
With `true`
    ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.2322  
    2454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vQFgKy4BQIEAdnAKKwIAq0ArmQMYCGALgJZxmruOQiAN1bRQAD1QBvIqFAAHePJjsAngHVO7ABYBBMpXHNIkACacyAcwA2qgDI9LAOVYBbSAEZUifhcsBuWQUlFQ0tPQMjE3MrWwcrF3c0b18rQLlFOGVoNU0dfUNjMz84x0TIDBToP3TgrNC8iMLokvsyt0hcKpqgzOzc8IKo4ti2hI78brTekJyw-MiimJsx5w6ANimAmfq5xqGl1vi19wB2Ldq+hsHFltHj8oAOC6IAX0CSMABlVMtQaEgikgiEgZHYHG4ZFAcAAZqA1MpoXCAOTiZGgRDaOAMaymUAAI0g8MYLA4ZlAFlAMHgYnciEQrEsghEYhQGN+oAAvBJ-EA)
### # Preserve Watch Output - `preserveWatchOutput`
Whether to keep outdated console output in watch mode instead of clearing the
screen every time a change happened.
  * Internal
### # Pretty - `pretty`
Stylize errors and messages using color and context, this is on by default ‚Äî
offers you a chance to have less terse, single colored messages from the
compiler.
  * Default:
`true`
## #Completeness
### # Skip Default Lib Check - `skipDefaultLibCheck`
Use `skipLibCheck` instead. Skip type checking of default library declaration
files.
### # Skip Lib Check - `skipLibCheck`
Skip type checking of declaration files.
This can save time during compilation at the expense of type-system accuracy.
For example, two libraries could define two copies of the same `type` in an
inconsistent way. Rather than doing a full check of all `d.ts` files,
TypeScript will type check the code you specifically refer to in your app‚Äôs
source code.
A common case where you might think to use `skipLibCheck` is when there are
two copies of a library‚Äôs types in your `node_modules`. In these cases, you
should consider using a feature like [yarn‚Äôs
resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/)
to ensure there is only one copy of that dependency in your tree or
investigate how to ensure there is only one copy by understanding the
dependency resolution to fix the issue without additional tooling.
Another possibility is when you are migrating between TypeScript releases and
the changes cause breakages in node_modules and the JS standard libraries
which you do not want to deal with during the TypeScript update.
Note, that if these issues come from the TypeScript standard library you can
replace the library using [TypeScript 4.5‚Äôs lib
replacement](https://www.typescriptlang.org/docs/handbook/release-
notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.
  * Recommended
  * Released:
[2.0](/docs/handbook/release-notes/typescript-2-0.html)
## #Command Line
## #Watch Options
TypeScript 3.8 shipped a new strategy for watching directories, which is
crucial for efficiently picking up changes to `node_modules`.
On operating systems like Linux, TypeScript installs directory watchers (as
opposed to file watchers) on `node_modules` and many of its subdirectories to
detect changes in dependencies. This is because the number of available file
watchers is often eclipsed by the number of files in `node_modules`, whereas
there are way fewer directories to track.
Because every project might work better under different strategies, and this
new approach might not work well for your workflows, TypeScript 3.8 introduces
a new `watchOptions` field which allows users to tell the compiler/language
service which watching strategies should be used to keep track of files and
directories.
### # Assume Changes Only Affect Direct Dependencies -
`assumeChangesOnlyAffectDirectDependencies`
When this option is enabled, TypeScript will avoid rechecking/rebuilding all
truly possibly-affected files, and only recheck/rebuild files that have
changed as well as files that directly import them.
This can be considered a ‚Äòfast & loose‚Äô implementation of the watching
algorithm, which can drastically reduce incremental rebuild times at the
expense of having to run the full build occasionally to get all compiler error
messages.
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
## Watch Options
You can configure the how TypeScript `--watch` works. This section is mainly
for handling case where `fs.watch` and `fs.watchFile` have additional
constraints like on Linux. You can read more at [Configuring
Watch](/docs/handbook/configuring-watch.html).
### # Watch File - `watchFile`
The strategy for how individual files are watched.
  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for file changes.
  * `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system‚Äôs native events to listen for changes on a file‚Äôs parent directory
  * Allowed:
    * `fixedpollinginterval`
    * `prioritypollinginterval`
    * `dynamicprioritypolling`
    * `fixedchunksizepolling`
    * `usefsevents`
    * `usefseventsonparentdirectory`
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
### # Watch Directory - `watchDirectory`
The strategy for how entire directory trees are watched under systems that
lack recursive file-watching functionality.
  * `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
  * `useFsEvents` (the default): Attempt to use the operating system/file system‚Äôs native events for directory changes.
  * Allowed:
    * `usefsevents`
    * `fixedpollinginterval`
    * `dynamicprioritypolling`
    * `fixedchunksizepolling`
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
### # Fallback Polling - `fallbackPolling`
When using file system events, this option specifies the polling strategy that
gets used when the system runs out of native file watchers and/or doesn‚Äôt
support native file watchers.
  * `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
  * `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
  * `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
  * `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.
  * Allowed:
    * `fixedinterval`
    * `priorityinterval`
    * `dynamicpriority`
    * `fixedchunksize`
  * Released:
[3.8](/docs/handbook/release-notes/typescript-3-8.html)
### # Synchronous Watch Directory - `synchronousWatchDirectory`
Synchronously call callbacks and update the state of directory watchers on
platforms that don`t support recursive watching natively. Instead of giving a
small timeout to allow for potentially multiple edits to occur on a file.
    {
      "watchOptions": {
        "[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory)": true
      }
    }
### # Exclude Directories - `excludeDirectories`
You can use `excludeFiles` to drastically reduce the number of files which are
watched during `--watch`. This can be a useful way to reduce the number of
open file which TypeScript tracks on Linux.
    {
      "watchOptions": {
        "[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories)": ["**/node_modules", "_build", "temp/*"]
      }
    }
### # Exclude Files - `excludeFiles`
You can use `excludeFiles` to remove a set of specific files from the files
which are watched.
    {
      "watchOptions": {
        "[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles)": ["temp/file.ts"]
      }
    }
## Type Acquisition
Type Acquisition is only important for JavaScript projects. In TypeScript
projects you need to include the types in your projects explicitly. However,
for JavaScript projects, the TypeScript tooling will download types for your
modules in the background and outside of your node_modules folder.
### # Enable - `enable`
Disables automatic type acquisition in JavaScript projects:
    json
    {
      "typeAcquisition": {
        "enable": false
      }
    }
### # Include - `include`
If you have a JavaScript project where TypeScript needs additional guidance to
understand global dependencies, or have disabled the built-in inference via
`disableFilenameBasedTypeAcquisition`.
You can use `include` to specify which types should be used from
DefinitelyTyped:
    json
    {
      "typeAcquisition": {
        "include": ["jquery"]
      }
    }
### # Exclude - `exclude`
Offers a config for disabling the type-acquisition for a certain module in
JavaScript projects. This can be useful for projects which include other
libraries in testing infrastructure which aren‚Äôt needed in the main
application.
    json
    {
      "typeAcquisition": {
        "exclude": ["jest", "mocha"]
      }
    }
### # Disable Filename Based Type Acquisition -
`disableFilenameBasedTypeAcquisition`
TypeScript‚Äôs type acquisition can infer what types should be added based on
filenames in a project. This means that having a file like `jquery.js` in your
project would automatically download the types for JQuery from
DefinitelyTyped.
You can disable this via `disableFilenameBasedTypeAcquisition`.
    json
    {
      "typeAcquisition": {
        "disableFilenameBasedTypeAcquisition": true
      }
    }
  * Released:
[4.1](/docs/handbook/release-notes/typescript-4-1.html)
TypeScript is a language from Microsoft which builds on JavaScript.  
This post is a non-technical overview of what JavaScript is, how TypeScript
extends JavaScript and what problems it solves.
## What is JavaScript?
Because TypeScript extends JavaScript, this makes it a good starting point.
JavaScript is commonly used to create websites. When building a website, you
work with three languages: HTML, CSS and JavaScript (JS). Broadly speaking:
HTML defines the content which will appear on the page, CSS defines the visual
style of the page, and JS defines the interactive behaviors of the page.
We describe having these sets of skills as being a "front-end" developer. You
use three languages to create pages inside a web browser like Safari, Firefox,
Edge or Chrome. Given how popular the web is for commerce and information
sharing, there is a massive demand for people who are good at using these
three languages.
Related to the role of being a "front-end" developer is the set of skills for
the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another
service (by sending data more directly.) You don't need to use HTML, CSS or JS
to write this type of code, but it's usually an end-product of your work
because it is likely to be presented in a web browser.
### What do Programming Languages do?
Programming languages are a way for humans and computers to communicate.
People read code many, many multiples of times more than they write it - so
developers create programming languages which are good at solving particular
problems with a small amount of code. Here's an example using JavaScript:
    var name = "Danger"
    console.log("Hello, " + name)
The first line makes a variable (effectively a box you can store other things
in) and then the second line outputs text to the console (for example DOS, or
the terminal) `"Hello, Danger"`.
JavaScript is designed to work as a scripting language, which means the code
starts at the top of the file and then goes through line by line downwards
running that code. To provide some contrast, here is the same behavior in
Java, which is built with different language constraints:
    class Main {
      public static void main(String[] args) {
        String name = "Danger";
        System.out.println("Hello, " + name);
      }
    }
These two code samples do the same thing, however the Java version comes with
a lot of words that aren't necessarily about telling the computer exactly what
to do, e.g. `class Main {`, `public static void main(String[] args) {`, and
two extra `}`s. It also has semi-colons at the end of some lines. Neither of
these programming languages are wrong, Java however, is aimed at building
different things from JavaScript, and these extra bits of code make sense
within the constraints of building a Java app.
To get to the key point though, there is one standout line I'd like us to
compare:
    // JavaScript
    var name = "Danger"
    // Java
    String name = "Danger";
Both of these lines declare variables called `name` which contain the value
`"Danger"`.
In JavaScript you use the abbreviation `var` to declare a variable. Meanwhile,
in Java you need to say _what kind of data_ the variable contains. In this
case the variable contains a `String`. (A string is a programming term for a
collection of characters. They `"look like this"`. This [5m
video](https://www.youtube.com/watch?v=czTWbdwbt7E) is a good primer if you
want to learn more.)
Both of these variables contain a string, but the difference is that in Java
the variable can _only_ ever contain a _string_ , because that's what we said
when we created the variable. In JS, the variable can change to be _anything_
, like a number, or a list of dates.
To illustrate:
    // Before in JS
    var name = "Danger"
    // Also OK
    var name = 1
    var name = false
    var name = ["2018-02-03", "2019-01-12"]
    // Before in Java
    String name = "Danger";
    // Not OK, the code wouldn't be accepted by Java
    String name = 1;
    String name = false
    String name = new String[]{"2018-02-03", "2019-01-12"};
These trade-offs make sense in the context for which these languages were
built back in 1995. JavaScript was originally designed to be a small
programming language which handled simple interactions on websites. Java on
the other hand was built specifically to make complex apps which could run on
any computer. They expected to be used to build codebases of different scales,
so the language required programmers write different types of code.
Java required programmers to be more explicit with the values of their
variables because the programs they expected people to build were more
complex. While JavaScript opted for ease of reading by omitting information
about the specifics, and expected codebases to be significantly smaller.
### What is TypeScript?
TypeScript is a programming language - it contains all of JavaScript, and then
a bit more. Using our example above, let's compare the scripts for "Hello,
Danger" in JavaScript vs TypeScript:
    // JavaScript
    var name = "Danger"
    console.log("Hello, " + name)
    // TypeScript
    var name = "Danger"
    console.log("Hello, " + name)
    // Yep, you're not missing something, there's no difference
Due to TypeScript's goal of only _extending_ JavaScript, the existing
JavaScript code we saw works as TypeScript. The extensions which TypeScript
adds to JavaScript are intended to help you be more explicit about what kinds
of data are used in your code, a bit like Java.
Here is the same sample, but using TypeScript to be more explicit about what
the variable is:
    var name: string = "Danger"
    console.log("Hello, " + name)
This extra `: string` allow the reader to be certain that `name` will only be
a string. Annotating your variables in this way also gives TypeScript the
chance to verify that these match. This is _very_ useful, because keeping
track of changes like the type of value in a variable seems easy when it's one
or two, but once it starts hitting the hundreds, that's a lot to keep track
of. Writing types help programmers be more confident about their code because
types catch mistakes.
Simply speaking, we call these annotations "Types". Hence the name _Type_
Script. One of the tag-lines for TypeScript is "JavaScript which scales" which
is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is.
This means you have less need to understand how every change affects the rest
of the program.
In the 90s, and maybe until a 5-10 years ago the trade-off for not having
types in your JavaScript application was fine because the size and
complexities of the programs being built were constrained to just the front-
end of websites. Today though, JavaScript is being used almost everywhere, to
build almost anything which runs on a computer. A large amount of mobile and
desktop apps use JavaScript and web technology under the hood.
These are all considerably more complicated to build and understand, adding
types drastically reduces the complexity of making improvements to those
programs.
### What Problems Can TypeScript Solve?
Typically, the need to ensure there are no bugs in your code can be handled by
writing automated tests, then by manually verifying that the code works as you
expect and finally having another person validate that it seems correct.
Not many companies are the size of Microsoft, however a lot of all problems
writing JavaScript in large codebases are the same. Many JavaScript apps are
made up of hundreds of thousands of files. A single change to one individual
file can affect the behaviour of any number of other files, like throwing a
pebble into a pond and causing ripples to spread out to the bank.
Validating the connections between every part of your project can get time
consuming quickly, using a type-checked language like TypeScript can handle
that automatically and provide instant feedback during development.
These features allows TypeScript to help developers feel more confident in
their code, and save considerable amounts time in validating that they have
not accidentally broken the project.