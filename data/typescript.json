{
    "name": "https://www.typescriptlang.org",
    "url": "https://https://www.typescriptlang.org",
    "pages": [
        {
            "url": "https://www.typescriptlang.org/docs",
            "title": "TypeScript: The starting point for learning TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Quick introductions based on your background or preference."
                },
                {
                    "type": "list",
                    "items": [
                        "TS for the New Programmer",
                        "TypeScript for JS Programmers",
                        "TS for Java/C# Programmers",
                        "TS for Functional Programmers",
                        "TypeScript Tooling in 5 minutes"
                    ]
                },
                {
                    "type": "p",
                    "text": "A great first read for your daily TS work."
                },
                {
                    "type": "list",
                    "items": [
                        "The TypeScript Handbook",
                        "The Basics",
                        "Everyday Types",
                        "Narrowing",
                        "More on Functions",
                        "Object Types",
                        "Type Manipulation",
                        "Creating Types from TypesGenericsKeyof Type OperatorTypeof Type OperatorIndexed Access TypesConditional TypesMapped TypesTemplate Literal Types",
                        "Creating Types from Types",
                        "Generics",
                        "Keyof Type Operator",
                        "Typeof Type Operator",
                        "Indexed Access Types",
                        "Conditional Types",
                        "Mapped Types",
                        "Template Literal Types",
                        "Classes",
                        "Modules"
                    ]
                },
                {
                    "type": "p",
                    "text": "Deep dive reference materials."
                },
                {
                    "type": "list",
                    "items": [
                        "Utility Types",
                        "Cheat Sheets",
                        "Decorators",
                        "Declaration Merging",
                        "Enums",
                        "Iterators and Generators",
                        "JSX",
                        "Mixins",
                        "Namespaces",
                        "Namespaces and Modules",
                        "Symbols",
                        "Triple-Slash Directives",
                        "Type Compatibility",
                        "Type Inference",
                        "Variable Declaration"
                    ]
                },
                {
                    "type": "p",
                    "text": "How TypeScript models JavaScript modules."
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Theory",
                        "Guides",
                        "Choosing Compiler Options",
                        "Choosing Compiler Options",
                        "Reference",
                        "Appendices",
                        "ESM/CJS Interoperability",
                        "ESM/CJS Interoperability"
                    ]
                },
                {
                    "type": "p",
                    "text": "Using TypeScript in several environments."
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET Core",
                        "Gulp",
                        "DOM Manipulation",
                        "Migrating from JavaScript",
                        "Using Babel with TypeScript"
                    ]
                },
                {
                    "type": "p",
                    "text": "Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions."
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Declaration Reference",
                        "Library Structures",
                        ".d.ts Templates",
                        "Modules .d.tsModule: PluginModule: ClassModule: FunctionGlobal .d.tsGlobal: Modifying Module",
                        "Modules .d.ts",
                        "Module: Plugin",
                        "Module: Class",
                        "Module: Function",
                        "Global .d.ts",
                        "Global: Modifying Module",
                        "Do's and Don'ts",
                        "Deep Dive",
                        "Publishing",
                        "Consumption"
                    ]
                },
                {
                    "type": "p",
                    "text": "How to use TypeScript-powered JavaScript tooling."
                },
                {
                    "type": "list",
                    "items": [
                        "JS Projects Utilizing TypeScript",
                        "Type Checking JavaScript Files",
                        "JSDoc Reference",
                        "Creating .d.ts Files from .js files"
                    ]
                },
                {
                    "type": "p",
                    "text": "Compiler configuration reference."
                },
                {
                    "type": "list",
                    "items": [
                        "What is a tsconfig.json",
                        "Compiler Options in MSBuild",
                        "TSConfig Reference",
                        "tsc CLI Options",
                        "Project References",
                        "Integrating with Build Tools",
                        "Configuring Watch",
                        "Nightly Builds"
                    ]
                },
                {
                    "type": "p",
                    "text": "Downloadable syntax reference pages for different parts of everyday TypeScript code."
                },
                {
                    "type": "list",
                    "items": [
                        "Control Flow Analysis",
                        "Classes",
                        "Interfaces",
                        "Types",
                        "Download PDFs and PNGs"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "JS to TS",
                        "New to Programming",
                        "OOP to JS",
                        "Functional to JS",
                        "Installation"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Everyday Types",
                        "Creating Types from Types",
                        "Object Types",
                        "Variable Declarations",
                        "More on Functions"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Playground",
                        "TSConfig Reference"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "What's new in5.7"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET",
                        "Migrating from JS",
                        "Working with the DOM",
                        "React & Webpack"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/asp-net-core.html",
            "title": "TypeScript: Documentation - ASP.NET Core",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "First, installASP.NET Coreif you need it. This quick-start guide requires Visual Studio 2015 or 2017. Next, if your version of Visual Studio does not already have the latest TypeScript, you caninstall it."
                },
                {
                    "type": "list",
                    "items": [
                        "ChooseFile",
                        "ChooseNew Project(Ctrl + Shift + N)",
                        "Search for.NET Corein the project search bar",
                        "SelectASP.NET Core Web Applicationand press theNextbutton"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "list",
                    "items": [
                        "Name your project and solution. After select theCreatebutton"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "list",
                    "items": [
                        "In the last window, select theEmptytemplate and press theCreatebutton"
                    ]
                },
                {
                    "type": "p",
                    "text": " Run the application and make sure that it works. "
                },
                {
                    "type": "p",
                    "text": "OpenDependencies > Manage NuGet Packages > Browse.Search and installMicrosoft.AspNetCore.StaticFilesandMicrosoft.TypeScript.MSBuild:  Open up yourStartup.csfile and edit yourConfigurefunction to look like this:"
                },
                {
                    "type": "code",
                    "code": "public void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}"
                },
                {
                    "type": "p",
                    "text": "You may need to restart VS for the red squiggly lines belowUseDefaultFilesandUseStaticFilesto disappear."
                },
                {
                    "type": "p",
                    "text": "Next we will add a new folder and call itscripts.  "
                },
                {
                    "type": "p",
                    "text": "Right click onscriptsand clickNew Item. Then chooseTypeScript Fileand name the fileapp.ts "
                },
                {
                    "type": "p",
                    "text": "Add the following code to theapp.tsfile."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsayHello() {constcompiler= (document.getElementById(\"compiler\")asHTMLInputElement).value;constframework= (document.getElementById(\"framework\")asHTMLInputElement).value;return`Hello from${compiler}and${framework}!`;}"
                },
                {
                    "type": "p",
                    "text": "Configure the TypeScript compiler First we need to tell TypeScript how to build. Right click onscriptsand clickNew Item. Then chooseTypeScript Configuration Fileand use the default name oftsconfig.json  Replace the contents of thetsconfig.jsonfile with:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"noEmitOnError\":true,\"noImplicitAny\":true,\"sourceMap\":true,\"target\":\"es6\"},\"files\": [\"./app.ts\"],\"compileOnSave\":true}"
                },
                {
                    "type": "list",
                    "items": [
                        "noEmitOnError: Do not emit outputs if any errors were reported.",
                        "noImplicitAny: Raise error on expressions and declarations with an impliedanytype.",
                        "sourceMap: Generates corresponding.mapfile.",
                        "target: Specify ECMAScript target version."
                    ]
                },
                {
                    "type": "p",
                    "text": "Note:\"ESNext\"targets latest supported noImplicitAnyis good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake.\"compileOnSave\"makes it easy to update your code in a running web app."
                },
                {
                    "type": "p",
                    "text": "We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and selectNew Item. Then chooseNPM Configuration Fileand use the default name ofpackage.json.  Inside the\"devDependencies\"section of thepackage.jsonfile, addgulpanddel"
                },
                {
                    "type": "code",
                    "code": "\"devDependencies\": {\"gulp\":\"4.0.2\",\"del\":\"5.1.0\"}"
                },
                {
                    "type": "p",
                    "text": "Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages. After you should see annpmfolder in your solution explorer "
                },
                {
                    "type": "p",
                    "text": "Right click on the project and clickNew Item. Then chooseJavaScript Fileand use the name ofgulpfile.js"
                },
                {
                    "type": "code",
                    "code": "js/// <binding AfterBuild='default' Clean='clean' />/*This file is the main entry point for defining Gulp tasks and using Gulp plugins.Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007*/vargulp=require(\"gulp\");vardel=require(\"del\");varpaths= {scripts:[\"scripts/**/*.js\",\"scripts/**/*.ts\",\"scripts/**/*.map\"],};gulp.task(\"clean\",function() {returndel([\"wwwroot/scripts/**/*\"]);});gulp.task(\"default\",function(done) {gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));done();});"
                },
                {
                    "type": "p",
                    "text": "The first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build. Now right-click ongulpfile.jsand click Task Runner Explorer.  If ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer: "
                },
                {
                    "type": "p",
                    "text": "Right click on thewwwrootfolder (if you don’t see the folder try building the project) and add a New Item namedindex.htmlinside. Use the following code forindex.html"
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html><html><head><meta charset=\"utf-8\" /><script src=\"scripts/app.js\"></script><title></title></head><body><div id=\"message\"></div><div>Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /></div></body></html>"
                },
                {
                    "type": "list",
                    "items": [
                        "Run the project",
                        "As you type on the boxes you should see the message appear/change!"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "list",
                    "items": [
                        "In Edge, press F12 and click the Debugger tab.",
                        "Look in the first localhost folder, then scripts/app.ts",
                        "Put a breakpoint on the line with return.",
                        "Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly."
                    ]
                },
                {
                    "type": "p",
                    "text": " Congrats you’ve built your own .NET Core project with a TypeScript frontend."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html",
            "title": "TypeScript: Documentation - Using Babel with TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript? A lot of the time the answer is“it depends”, or“someone may have decided for you”depending on the project. If you are building your project with an existing framework liketsdx,Angular,NestJSor any framework mentioned in theGetting Startedthen this decision is handled for you. However, a useful heuristic could be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Is your build output mostly the same as your source input files? Usetsc",
                        "Do you need a build pipeline with multiple potential outputs? Usebabelfor transpiling andtscfor type checking"
                    ]
                },
                {
                    "type": "p",
                    "text": "This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript. This technique is a hybrid approach, using Babel’spreset-typescriptto generate your JS files, and then using TypeScript to do type checking and.d.tsfile generation. By using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code."
                },
                {
                    "type": "p",
                    "text": "The downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code. In addition to that, Babel cannot create.d.tsfiles for your TypeScript which can make it harder to work with your project if it is a library. To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a correspondingtsconfig.jsonand ensuring these flags are enabled:"
                },
                {
                    "type": "code",
                    "code": "\"compilerOptions\": {// Ensure that .d.ts files are created by tsc, but not .js files\"declaration\":true,\"emitDeclarationOnly\":true,// Ensure that Babel can safely transpile files in the TypeScript project\"isolatedModules\":true}"
                },
                {
                    "type": "p",
                    "text": "For more information on these flags:"
                },
                {
                    "type": "list",
                    "items": [
                        "isolatedModules",
                        "declaration,emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html",
            "title": "TypeScript: Documentation - Compiler Options in MSBuild",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via atsconfig.jsonor via the project settings."
                },
                {
                    "type": "p",
                    "text": "We recommend using atsconfig.jsonfor your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio. The newtsconfig.jsonwill then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learnabout how TSConfigs works hereand there is acomprehensive reference here."
                },
                {
                    "type": "p",
                    "text": "You can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your.csprojto definePropertyGroupswhich describe how the build can work:"
                },
                {
                    "type": "code",
                    "code": "xml<PropertyGroup><TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError><TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns></PropertyGroup>"
                },
                {
                    "type": "p",
                    "text": "There is a series of mappings for common TypeScript settings, these are settings which map directly toTypeScript cli optionsand are used to help you write a more understandable project file. You can use theTSConfig referenceto get more information on what values and defaults are for each mapping."
                },
                {
                    "type": "p",
                    "text": "Allow JavaScript files to be a part of your program. Use thecheckJSoption to get errors from these files."
                },
                {
                    "type": "p",
                    "text": "Disable emitting comments."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for expressions and declarations with an impliedanytype.."
                },
                {
                    "type": "p",
                    "text": "Generate .d.ts files from TypeScript and JavaScript files in your project."
                },
                {
                    "type": "p",
                    "text": "Specify what module code is generated."
                },
                {
                    "type": "p",
                    "text": "Specify what JSX code is generated."
                },
                {
                    "type": "p",
                    "text": "Specify an output folder for all emitted files."
                },
                {
                    "type": "p",
                    "text": "Create source map files for emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."
                },
                {
                    "type": "p",
                    "text": "Disallowimports,requires or<reference>s from expanding the number of files TypeScript should add to a project."
                },
                {
                    "type": "p",
                    "text": "Specify the location where debugger should locate map files instead of generated locations."
                },
                {
                    "type": "p",
                    "text": "Specify the root path for debuggers to find the reference source code."
                },
                {
                    "type": "p",
                    "text": "No longer supported. In early versions, manually set the text encoding for reading files."
                },
                {
                    "type": "p",
                    "text": "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."
                },
                {
                    "type": "p",
                    "text": "Disable including any library files, including the default lib.d.ts."
                },
                {
                    "type": "p",
                    "text": "Disable erasingconst enumdeclarations in generated code."
                },
                {
                    "type": "p",
                    "text": "SuppressnoImplicitAnyerrors when indexing objects that lack index signatures."
                },
                {
                    "type": "p",
                    "text": "Disable generating custom helper functions like__extendsin compiled output."
                },
                {
                    "type": "p",
                    "text": "Include sourcemap files inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "Include source code in the sourcemaps inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "Set the newline character for emitting files."
                },
                {
                    "type": "p",
                    "text": "Ensure that each file can be safely transpiled without relying on other imports."
                },
                {
                    "type": "p",
                    "text": "Emit design-type metadata for decorated declarations in source files."
                },
                {
                    "type": "p",
                    "text": "Specify the root folder within your source files."
                },
                {
                    "type": "p",
                    "text": "Enable experimental support for TC39 stage 2 draft decorators."
                },
                {
                    "type": "p",
                    "text": "Specify how TypeScript looks up a file from a given module specifier."
                },
                {
                    "type": "p",
                    "text": "Disable reporting of excess property errors during the creation of object literals."
                },
                {
                    "type": "p",
                    "text": "Specify the object invoked forcreateElement. This only applies when targetingreactJSX emit."
                },
                {
                    "type": "p",
                    "text": "Skip type checking .d.ts files that are included with TypeScript."
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unused labels."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for codepaths that do not explicitly return in a function."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for fallthrough cases in switch statements."
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unreachable code."
                },
                {
                    "type": "p",
                    "text": "Ensure that casing is correct in imports."
                },
                {
                    "type": "p",
                    "text": "Allow 'import x from y' when a module doesn't have a default export."
                },
                {
                    "type": "p",
                    "text": "Disable adding 'use strict' directives in emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Specify a set of bundled library declaration files that describe the target runtime environment."
                },
                {
                    "type": "p",
                    "text": "Specify the base directory to resolve bare specifier module names."
                },
                {
                    "type": "p",
                    "text": "Specify the output directory for generated declaration files."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting whenthisis given the typeany."
                },
                {
                    "type": "p",
                    "text": "Skip type checking all .d.ts files."
                },
                {
                    "type": "p",
                    "text": "When type checking, take into accountnullandundefined."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting when a local variables aren't read."
                },
                {
                    "type": "p",
                    "text": "Raise an error when a function parameter isn't read"
                },
                {
                    "type": "p",
                    "text": "Ensure 'use strict' is always emitted."
                },
                {
                    "type": "p",
                    "text": "Allow importing helper functions from tslib once per project, instead of including them per-file."
                },
                {
                    "type": "p",
                    "text": "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'"
                },
                {
                    "type": "p",
                    "text": "Disable emitting declarations that have@internalin their JSDoc comments."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting in type-checked JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Emit more compliant, but verbose and less performant JavaScript for iteration."
                },
                {
                    "type": "p",
                    "text": "Enable all strict type checking options."
                },
                {
                    "type": "p",
                    "text": "Disable strict checking of generic signatures in function types."
                },
                {
                    "type": "p",
                    "text": "Disable resolving symlinks to their realpath. This correlates to the same flag in node."
                },
                {
                    "type": "p",
                    "text": "When assigning functions, check to ensure parameters and the return values are subtype-compatible."
                },
                {
                    "type": "p",
                    "text": "Check for class properties that are declared but not set in the constructor."
                },
                {
                    "type": "p",
                    "text": "Emit additional JavaScript to ease support for importing CommonJS modules. This enablesallowSyntheticDefaultImportsfor type compatibility."
                },
                {
                    "type": "p",
                    "text": "Only output d.ts files and not JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Make keyof only return strings instead of string, numbers or symbols. Legacy option."
                },
                {
                    "type": "p",
                    "text": "Emit ECMAScript-standard-compliant class fields."
                },
                {
                    "type": "p",
                    "text": "Create sourcemaps for d.ts files."
                },
                {
                    "type": "p",
                    "text": "Enable importing .json files"
                },
                {
                    "type": "p",
                    "text": "Check that the arguments forbind,call, andapplymethods match the original function."
                },
                {
                    "type": "p",
                    "text": "Disable emitting files if any type checking errors are reported."
                },
                {
                    "type": "p",
                    "text": "Because the MSBuild system passes arguments directly to the TypeScript CLI, you can use the optionTypeScriptAdditionalFlagsto provide specific flags which don’t have a mapping above. For example, this would turn onnoPropertyAccessFromIndexSignature:"
                },
                {
                    "type": "code",
                    "code": "xml<TypeScriptAdditionalFlags>$(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>"
                },
                {
                    "type": "p",
                    "text": "You can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:"
                },
                {
                    "type": "code",
                    "code": "xml<PropertyGroupCondition=\"'$(Configuration)' == 'Debug'\"><TypeScriptRemoveComments>false</TypeScriptRemoveComments><TypeScriptSourceMap>true</TypeScriptSourceMap></PropertyGroup><PropertyGroupCondition=\"'$(Configuration)' == 'Release'\"><TypeScriptRemoveComments>true</TypeScriptRemoveComments><TypeScriptSourceMap>false</TypeScriptSourceMap></PropertyGroup><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"/>"
                },
                {
                    "type": "p",
                    "text": "The value of<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>property in the project file identifies the compiler version to use to build (1.7 in this example).\nThis allows a project to build against the same versions of the compiler on different machines. IfTypeScriptToolsVersionis not specified, the latest compiler version installed on the machine will be used to build. Users using newer versions of TS, will see a prompt to upgrade their project on first load."
                },
                {
                    "type": "p",
                    "text": "If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>in your project.\nThis should give you all the editing support, but not the build when you hit F5."
                },
                {
                    "type": "p",
                    "text": "By default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation.\nHowever, if this behavior is causing issues, such as when TypeScript’sincrementaloption is enabled, set<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>to ensure the TypeScript compiler is invoked with every run of MSBuild."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html",
            "title": "TypeScript: Documentation - tsc CLI Options",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Runningtsclocally will compile the closest project defined by atsconfig.json, or you can compile a set of TypeScript\nfiles by passing in a glob of files you want. When input files are specified on the command line,tsconfig.jsonfiles are\nignored."
                },
                {
                    "type": "code",
                    "code": "sh# Run a compile based on a backwards look through the fs for a tsconfig.jsontsc# Emit JS for just the index.ts with the compiler defaultstsc index.ts# Emit JS for any .ts files in the folder src, with the default settingstsc src/*.ts# Emit files referenced in with the compiler settings from tsconfig.production.jsontsc --project tsconfig.production.json# Emit d.ts files for a js file with showing compiler options which are booleanstsc index.js --declaration --emitDeclarationOnly# Emit a single .js file from two files via compiler options which take string argumentstsc app.ts util.ts --target esnext --outfile index.js"
                },
                {
                    "type": "p",
                    "text": "If you’re looking for more information about the compiler options in a tsconfig, check out theTSConfig Reference"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Show all compiler options."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Gives local information for help on the CLI."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Initializes a TypeScript project and creates a tsconfig.json file."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print names of files that are part of the compilation and then stop processing."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Set the language of the messaging from TypeScript. This does not affect emit."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print the final configuration instead of building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print the compiler's version."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Build one or more projects and their dependencies, if out of date"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Delete the outputs of all projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Show what would be built (or deleted, if specified with '--clean')"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Build all projects, including those that appear to be up to date."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Enable verbose logging."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Remove a list of directories from the watch process."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Remove a list of files from the watch mode's processing."
                },
                {
                    "type": "p",
                    "text": "fixedinterval,priorityinterval,dynamicpriority, orfixedchunksize"
                },
                {
                    "type": "p",
                    "text": "Specify what approach the watcher should use if the system runs out of native file watchers."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Watch input files."
                },
                {
                    "type": "p",
                    "text": "usefsevents,fixedpollinginterval,dynamicprioritypolling, orfixedchunksizepolling"
                },
                {
                    "type": "p",
                    "text": "Specify how directories are watched on systems that lack recursive file-watching functionality."
                },
                {
                    "type": "p",
                    "text": "fixedpollinginterval,prioritypollinginterval,dynamicprioritypolling,fixedchunksizepolling,usefsevents, orusefseventsonparentdirectory"
                },
                {
                    "type": "p",
                    "text": "Specify how the TypeScript watch mode works."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable importing files with any extension, provided a declaration file is present."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow imports to include TypeScript file extensions."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow JavaScript files to be a part of your program. Use thecheckJSoption to get errors from these files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifesModuleInteropis enabled,moduleissystem, ormoduleResolutionisbundler;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Allow 'import x from y' when a module doesn't have a default export."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow accessing UMD globals from modules."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unreachable code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unused labels."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Ensure 'use strict' is always emitted."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Have recompiles in projects that useincrementalandwatchmode assume that changes within a file will only affect files directly depending on it."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the base directory to resolve bare specifier module names."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "utf8"
                },
                {
                    "type": "p",
                    "text": "No longer supported. In early versions, manually set the text encoding for reading files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting in type-checked JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable constraints that allow a TypeScript project to be used with project references."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Conditions to set in addition to the resolver-specific defaults when resolving imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Generate .d.ts files from TypeScript and JavaScript files in your project."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the output directory for generated declaration files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Create sourcemaps for d.ts files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Output compiler performance information after building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Reduce the number of projects loaded automatically by TypeScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Opt a project out of multi-project reference checking when editing."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable preferring source files instead of declaration files when referencing composite projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit more compliant, but verbose and less performant JavaScript for iteration."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Only output d.ts files and not JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit design-type metadata for decorated declarations in source files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifmoduleisnode16ornodenext;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Emit additional JavaScript to ease support for importing CommonJS modules. This enablesallowSyntheticDefaultImportsfor type compatibility."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Interpret optional property types as written, rather than addingundefined."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable experimental support for TC39 stage 2 draft decorators."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print files read during the compilation including why it was included."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Output more detailed compiler performance information after building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "p",
                    "text": "Ensure that casing is correct in imports."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "profile.cpuprofile"
                },
                {
                    "type": "p",
                    "text": "Emit a v8 CPU profile of the compiler run for debugging."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Generates an event trace and a list of types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow importing helper functions from tslib once per project, instead of including them per-file."
                },
                {
                    "type": "p",
                    "text": "remove,preserve, orerror"
                },
                {
                    "type": "p",
                    "text": "remove"
                },
                {
                    "type": "p",
                    "text": "Specify emit/checking behavior for imports that are only used for types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Save .tsbuildinfo files to allow for incremental compilation of projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Include sourcemap files inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Include source code in the sourcemaps inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Require sufficient annotation on exports so other tools can trivially generate declaration files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifverbatimModuleSyntax;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Ensure that each file can be safely transpiled without relying on other imports."
                },
                {
                    "type": "p",
                    "text": "preserve,react,react-native,react-jsx, orreact-jsxdev"
                },
                {
                    "type": "p",
                    "text": "Specify what JSX code is generated."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React.createElement"
                },
                {
                    "type": "p",
                    "text": "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React.Fragment"
                },
                {
                    "type": "p",
                    "text": "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "react"
                },
                {
                    "type": "p",
                    "text": "Specify module specifier used to import the JSX factory functions when usingjsx: react-jsx*."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Make keyof only return strings instead of string, numbers or symbols. Legacy option."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify a set of bundled library declaration files that describe the target runtime environment."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print the names of emitted files after a compilation."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print all of the files read during the compilation."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the location where debugger should locate map files instead of generated locations."
                },
                {
                    "type": "p",
                    "text": "number"
                },
                {
                    "type": "p",
                    "text": "0"
                },
                {
                    "type": "p",
                    "text": "Specify the maximum folder depth used for checking JavaScript files fromnode_modules. Only applicable withallowJs."
                },
                {
                    "type": "p",
                    "text": "none,commonjs,amd,umd,system,es6/es2015,es2020,es2022,esnext,node16,nodenext, orpreserve"
                },
                {
                    "type": "p",
                    "text": "CommonJSiftargetisES5;ES6/ES2015otherwise."
                },
                {
                    "type": "p",
                    "text": "Specify what module code is generated."
                },
                {
                    "type": "p",
                    "text": "legacy,auto, orforce"
                },
                {
                    "type": "p",
                    "text": "\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."
                },
                {
                    "type": "p",
                    "text": "Specify what method is used to detect whether a file is a script or a module."
                },
                {
                    "type": "p",
                    "text": "classic,node10/node,node16,nodenext, orbundler"
                },
                {
                    "type": "p",
                    "text": "ClassicifmoduleisAMD,UMD,System, orES6/ES2015; Matches ifmoduleisnode16ornodenext;Nodeotherwise."
                },
                {
                    "type": "p",
                    "text": "Specify how TypeScript looks up a file from a given module specifier."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "List of file name suffixes to search when resolving a module."
                },
                {
                    "type": "p",
                    "text": "crlforlf"
                },
                {
                    "type": "p",
                    "text": "lf"
                },
                {
                    "type": "p",
                    "text": "Set the newline character for emitting files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable full type checking (only critical parse and emit errors will be reported)."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting files from a compilation."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable generating custom helper functions like__extendsin compiled output."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting files if any type checking errors are reported."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable truncating types in error messages."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for fallthrough cases in switch statements."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for expressions and declarations with an impliedanytype."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Ensure overriding members in derived classes are marked with an override modifier."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for codepaths that do not explicitly return in a function."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting whenthisis given the typeany."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable adding 'use strict' directives in emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable including any library files, including the default lib.d.ts."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enforces using indexed accessors for keys declared using an indexed type."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disallowimports,requires or<reference>s from expanding the number of files TypeScript should add to a project."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable strict checking of generic signatures in function types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Addundefinedto a type when accessed using an index."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Check side effect imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting when local variables aren't read."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Raise an error when a function parameter isn't read."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Deprecated setting. UseoutFileinstead."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify an output folder for all emitted files."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify a file that bundles all outputs into one JavaScript file. Ifdeclarationis true, also designates a file that bundles all .d.ts output."
                },
                {
                    "type": "p",
                    "text": "object"
                },
                {
                    "type": "p",
                    "text": "Specify a set of entries that re-map imports to additional lookup locations."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify a list of language service plugins to include."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifisolatedModules;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Disable erasingconst enumdeclarations in generated code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable resolving symlinks to their realpath. This correlates to the same flag in node."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Preserve unused imported values in the JavaScript output that would otherwise be removed."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable wiping the console in watch mode."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "p",
                    "text": "Enable color and formatting in TypeScript's output to make compiler errors easier to read."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React"
                },
                {
                    "type": "p",
                    "text": "Specify the object invoked forcreateElement. This only applies when targetingreactJSX emit."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting comments."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable importing .json files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "p",
                    "text": "Use the package.json 'exports' field when resolving package imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "p",
                    "text": "Use the package.json 'imports' field when resolving imports."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "Specify the root folder within your source files."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "Allow multiple folders to be treated as one when resolving modules."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Skip type checking .d.ts files that are included with TypeScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Skip type checking all .d.ts files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Create source map files for emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the root path for debuggers to find the reference source code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Skip building downstream projects on error in upstream project."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable all strict type-checking options."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Check that the arguments forbind,call, andapplymethods match the original function."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false, unlessstrictis set"
                },
                {
                    "type": "p",
                    "text": "Built-in iterators are instantiated with a TReturn type of undefined instead of any."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "When assigning functions, check to ensure parameters and the return values are subtype-compatible."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "When type checking, take into accountnullandundefined."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Check for class properties that are declared but not set in the constructor."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting declarations that have@internalin their JSDoc comments."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable reporting of excess property errors during the creation of object literals."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "SuppressnoImplicitAnyerrors when indexing objects that lack index signatures."
                },
                {
                    "type": "p",
                    "text": "es3,es5,es6/es2015,es2016,es2017,es2018,es2019,es2020,es2021,es2022,es2023, oresnext"
                },
                {
                    "type": "p",
                    "text": "ES5"
                },
                {
                    "type": "p",
                    "text": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Log paths used during themoduleResolutionprocess."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": ".tsbuildinfo"
                },
                {
                    "type": "p",
                    "text": "The file to store.tsbuildinfoincremental build information in."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify multiple folders that act like./node_modules/@types."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify type package names to be included without being referenced in a source file."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueiftargetisES2022or higher, includingESNext;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Emit ECMAScript-standard-compliant class fields."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Default catch clause variables asunknowninstead ofany."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting."
                },
                {
                    "type": "list",
                    "items": [
                        "Every option is fully explained in theTSConfig Reference.",
                        "Learn how to use atsconfig.jsonfile.",
                        "Learn how to work in anMSBuild project."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/configuring-watch.html",
            "title": "TypeScript: Documentation - Configuring Watch",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available."
                },
                {
                    "type": "p",
                    "text": "The--watchimplementation of the compiler relies on Node’sfs.watchandfs.watchFile. Each of these methods has pros and cons. fs.watchrelies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors ofLinux). Heavy use offs.watchin large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically usesfs.watchto watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching. fs.watchFileuses polling and thus costs CPU cycles. However,fs.watchFileis by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically usesfs.watchFileto watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when usingfs.watchFiledepends directly on number of files watched in the codebase."
                },
                {
                    "type": "p",
                    "text": "The suggested method of configuring watch behavior is through the newwatchOptionssection oftsconfig.json. We provide an example configuration below. See the following section for detailed descriptions of the settings available."
                },
                {
                    "type": "code",
                    "code": "{// Some typical compiler options\"compilerOptions\": {\"target\":\"es2020\",\"moduleResolution\":\"node\"// ...},// NEW: Options for file/directory watching\"watchOptions\": {// Use native file system events for files and directories\"watchFile\":\"useFsEvents\",\"watchDirectory\":\"useFsEvents\",// Poll files for updates more frequently// when they're updated a lot.\"fallbackPolling\":\"dynamicPriority\",// Don't coalesce watch notification\"synchronousWatchDirectory\":true,// Finally, two additional settings for reducing the amount of possible// files to track  work from these directories\"excludeDirectories\": [\"**/node_modules\",\"_build\"],\"excludeFiles\": [\"build/fileWhichChangesOften.ts\"]}}"
                },
                {
                    "type": "p",
                    "text": "For further details, seethe release notes for Typescript 3.8."
                },
                {
                    "type": "p",
                    "text": "For directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected byTSC_WATCHDIRECTORY. NOTE:On platforms which support native recursive directory watching, the value ofTSC_WATCHDIRECTORYis ignored."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html",
            "title": "TypeScript: Documentation - Declaration Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The purpose of this guide is to teach you how to write a high-quality definition file.\nThis guide is structured by showing documentation for some API, along with sample usage of that API,\nand explaining how to write the corresponding declaration. These examples are ordered in approximately increasing order of complexity."
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "The global variablemyLibhas a functionmakeGreetingfor creating greetings,\nand a propertynumberOfGreetingsindicating the number of greetings made so far."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsletresult=myLib.makeGreeting(\"hello, world\");console.log(\"The computed greeting is:\"+result);letcount=myLib.numberOfGreetings;"
                },
                {
                    "type": "p",
                    "text": "Declaration Usedeclare namespaceto describe types or values accessed by dotted notation."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacemyLib{functionmakeGreeting(s:string):string;letnumberOfGreetings:number;}"
                },
                {
                    "type": "p",
                    "text": "Documentation ThegetWidgetfunction accepts a number and returns a Widget, or accepts a string and returns a Widget array. Code"
                },
                {
                    "type": "code",
                    "code": "tsletx:Widget=getWidget(43);letarr:Widget[] =getWidget(\"all of them\");"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongetWidget(n:number):Widget;declarefunctiongetWidget(s:string):Widget[];"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "When specifying a greeting, you must pass aGreetingSettingsobject.\nThis object has the following properties: 1 - greeting: Mandatory string 2 - duration: Optional length of time (in milliseconds) 3 - color: Optional string, e.g. ‘#ff00ff’"
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsgreet({greeting:\"hello world\",duration:4000});"
                },
                {
                    "type": "p",
                    "text": "Declaration Use aninterfaceto define a type with properties."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGreetingSettings{greeting:string;duration?:number;color?:string;}declarefunctiongreet(setting:GreetingSettings):void;"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "Anywhere a greeting is expected, you can provide astring, a function returning astring, or aGreeterinstance."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetGreeting() {return\"howdy\";}classMyGreeterextendsGreeter{}greet(\"hello\");greet(getGreeting);greet(newMyGreeter());"
                },
                {
                    "type": "p",
                    "text": "Declaration You can use a type alias to make a shorthand for a type:"
                },
                {
                    "type": "code",
                    "code": "tstypeGreetingLike=string| (()=>string) |MyGreeter;declarefunctiongreet(g:GreetingLike):void;"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "Thegreeterobject can log to a file or display an alert.\nYou can provide LogOptions to.log(...)and alert options to.alert(...)"
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconstg=newGreeter(\"Hello\");g.log({verbose:true});g.alert({modal:false,title:\"Current Greeting\"});"
                },
                {
                    "type": "p",
                    "text": "Declaration Use namespaces to organize types."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceGreetingLib{interfaceLogOptions{verbose?:boolean;}interfaceAlertOptions{modal:boolean;title?:string;color?:string;}}"
                },
                {
                    "type": "p",
                    "text": "You can also create nested namespaces in one declaration:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceGreetingLib.Options{// Refer to via GreetingLib.Options.LoginterfaceLog{verbose?:boolean;}interfaceAlert{modal:boolean;title?:string;color?:string;}}"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "You can create a greeter by instantiating theGreeterobject, or create a customized greeter by extending from it."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconstmyGreeter=newGreeter(\"hello, world\");myGreeter.greeting=\"howdy\";myGreeter.showGreeting();classSpecialGreeterextendsGreeter{constructor() {super(\"Very special greetings\");}}"
                },
                {
                    "type": "p",
                    "text": "Declaration Usedeclare classto describe a class or class-like object.\nClasses can have properties and methods as well as a constructor."
                },
                {
                    "type": "code",
                    "code": "tsdeclareclassGreeter{constructor(greeting:string);greeting:string;showGreeting():void;}"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "The global variablefoocontains the number of widgets present."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconsole.log(\"Half the number of widgets is \"+foo/2);"
                },
                {
                    "type": "p",
                    "text": "Declaration Usedeclare varto declare variables.\nIf the variable is read-only, you can usedeclare const.\nYou can also usedeclare letif the variable is block-scoped."
                },
                {
                    "type": "code",
                    "code": "ts/** The number of widgets present */declarevarfoo:number;"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "You can call the functiongreetwith a string to show a greeting to the user."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsgreet(\"hello, world\");"
                },
                {
                    "type": "p",
                    "text": "Declaration Usedeclare functionto declare functions."
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongreet(greeting:string):void;"
                },
                {
                    "type": "p",
                    "text": "How to write a high-quality TypeScript Declaration (d.ts) file"
                },
                {
                    "type": "p",
                    "text": "How to structure your d.ts files"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html",
            "title": "TypeScript: Documentation - Consumption",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Getting type declarations requires no tools apart from npm. As an example, getting the declarations for a library like lodash takes nothing more than the following command"
                },
                {
                    "type": "code",
                    "code": "cmdnpminstall--save-dev@types/lodash"
                },
                {
                    "type": "p",
                    "text": "It is worth noting that if the npm package already includes its declaration file as described inPublishing, downloading the corresponding@typespackage is not needed."
                },
                {
                    "type": "p",
                    "text": "From there you’ll be able to use lodash in your TypeScript code with no fuss.\nThis works for both modules and global code. For example, once you’venpm install-ed your type declarations, you can use imports and write"
                },
                {
                    "type": "code",
                    "code": "tsimport*as_from\"lodash\";_.padStart(\"Hello TypeScript!\",20,\" \");"
                },
                {
                    "type": "p",
                    "text": "or if you’re not using modules, you can just use the global variable_."
                },
                {
                    "type": "code",
                    "code": "ts_.padStart(\"Hello TypeScript!\",20,\" \");"
                },
                {
                    "type": "p",
                    "text": "For the most part, type declaration packages should always have the same name as the package name onnpm, but prefixed with@types/,\nbut if you need, you can use theYarn package searchto find the package for your favorite library."
                },
                {
                    "type": "p",
                    "text": "Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it.\nPlease see the DefinitelyTypedcontribution guidelines pagefor details."
                },
                {
                    "type": "p",
                    "text": "How to get your d.ts files to users"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html",
            "title": "TypeScript: Documentation - Deep Dive",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Structuring modules to give the exact API shape you want can be tricky.\nFor example, we might want a module that can be invoked with or withoutnewto produce different types,\nhas a variety of named types exposed in a hierarchy,\nand has some properties on the module object as well. By reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface.\nThis guide focuses on module (or UMD) libraries because the options here are more varied."
                },
                {
                    "type": "p",
                    "text": "You can fully understand how to make any shape of declaration\nby understanding some key concepts of how TypeScript works."
                },
                {
                    "type": "p",
                    "text": "If you’re reading this guide, you probably already roughly know what a type in TypeScript is.\nTo be more explicit, though, atypeis introduced with:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type alias declaration (type sn = number | string;)",
                        "An interface declaration (interface I { x: number[]; })",
                        "A class declaration (class C { })",
                        "An enum declaration (enum E { A, B, C })",
                        "Animportdeclaration which refers to a type"
                    ]
                },
                {
                    "type": "p",
                    "text": "Each of these declaration forms creates a new type name."
                },
                {
                    "type": "p",
                    "text": "As with types, you probably already understand what a value is.\nValues are runtime names that we can reference in expressions.\nFor examplelet x = 5;creates a value calledx. Again, being explicit, the following things create values:"
                },
                {
                    "type": "list",
                    "items": [
                        "let,const, andvardeclarations",
                        "Anamespaceormoduledeclaration which contains a value",
                        "Anenumdeclaration",
                        "Aclassdeclaration",
                        "Animportdeclaration which refers to a value",
                        "Afunctiondeclaration"
                    ]
                },
                {
                    "type": "p",
                    "text": "Types can exist innamespaces.\nFor example, if we have the declarationlet x: A.B.C,\nwe say that the typeCcomes from theA.Bnamespace. This distinction is subtle and important — here,A.Bis not necessarily a type or a value."
                },
                {
                    "type": "p",
                    "text": "Given a nameA, we might find up to three different meanings forA: a type, a value or a namespace.\nHow the name is interpreted depends on the context in which it is used.\nFor example, in the declarationlet m: A.A = A;,Ais used first as a namespace, then as a type name, then as a value.\nThese meanings might end up referring to entirely different declarations! This may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things.\nLet’s look at some useful aspects of this combining behavior."
                },
                {
                    "type": "p",
                    "text": "Astute readers will notice that, for example,classappeared in both thetypeandvaluelists.\nThe declarationclass C { }creates two things:\natypeCwhich refers to the instance shape of the class,\nand avalueCwhich refers to the constructor function of the class.\nEnum declarations behave similarly."
                },
                {
                    "type": "p",
                    "text": "Let’s say we wrote a module filefoo.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportvarSomeVar: {a:SomeType};exportinterfaceSomeType{count:number;}"
                },
                {
                    "type": "p",
                    "text": "Then consumed it:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfoofrom\"./foo\";letx:foo.SomeType=foo.SomeVar.a;console.log(x.count);"
                },
                {
                    "type": "p",
                    "text": "This works well enough, but we might imagine thatSomeTypeandSomeVarwere very closely related\nsuch that you’d like them to have the same name.\nWe can use combining to present these two different objects (the value and the type) under the same nameBar:"
                },
                {
                    "type": "code",
                    "code": "tsexportvarBar: {a:Bar};exportinterfaceBar{count:number;}"
                },
                {
                    "type": "p",
                    "text": "This presents a very good opportunity for destructuring in the consuming code:"
                },
                {
                    "type": "code",
                    "code": "tsimport{Bar}from\"./foo\";letx:Bar=Bar.a;console.log(x.count);"
                },
                {
                    "type": "p",
                    "text": "Again, we’ve usedBaras both a type and a value here.\nNote that we didn’t have to declare theBarvalue as being of theBartype — they’re independent."
                },
                {
                    "type": "p",
                    "text": "Some kinds of declarations can be combined across multiple declarations.\nFor example,class C { }andinterface C { }can co-exist and both contribute properties to theCtypes. This is legal as long as it does not create a conflict.\nA general rule of thumb is that values always conflict with other values of the same name unless they are declared asnamespaces,\ntypes will conflict if they are declared with a type alias declaration (type s = string),\nand namespaces never conflict. Let’s see how this can be used."
                },
                {
                    "type": "p",
                    "text": "We can add additional members to aninterfacewith anotherinterfacedeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceFoo{x:number;}// ... elsewhere ...interfaceFoo{y:number;}leta:Foo= ...;console.log(a.x+a.y);// OK"
                },
                {
                    "type": "p",
                    "text": "This also works with classes:"
                },
                {
                    "type": "code",
                    "code": "tsclassFoo{x:number;}// ... elsewhere ...interfaceFoo{y:number;}leta:Foo= ...;console.log(a.x+a.y);// OK"
                },
                {
                    "type": "p",
                    "text": "Note that we cannot add to type aliases (type s = string;) using an interface."
                },
                {
                    "type": "p",
                    "text": "Anamespacedeclaration can be used to add new types, values, and namespaces in any way which does not create a conflict. For example, we can add a static member to a class:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{}// ... elsewhere ...namespaceC{exportletx:number;}lety=C.x;// OK"
                },
                {
                    "type": "p",
                    "text": "Note that in this example, we added a value to thestaticside ofC(its constructor function).\nThis is because we added avalue, and the container for all values is another value\n(types are contained by namespaces, and namespaces are contained by other namespaces). We could also add a namespaced type to a class:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{}// ... elsewhere ...namespaceC{exportinterfaceD{}}lety:C.D;// OK"
                },
                {
                    "type": "p",
                    "text": "In this example, there wasn’t a namespaceCuntil we wrote thenamespacedeclaration for it.\nThe meaningCas a namespace doesn’t conflict with the value or type meanings ofCcreated by the class. Finally, we could perform many different merges usingnamespacedeclarations.\nThis isn’t a particularly realistic example, but shows all sorts of interesting behavior:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceX{exportinterfaceY{}exportclassZ{}}// ... elsewhere ...namespaceX{exportvarY:number;exportnamespaceZ{exportclassC{}}}typeX=string;"
                },
                {
                    "type": "p",
                    "text": "In this example, the first block creates the following name meanings:"
                },
                {
                    "type": "list",
                    "items": [
                        "A valueX(because thenamespacedeclaration contains a value,Z)",
                        "A namespaceX(because thenamespacedeclaration contains a type,Y)",
                        "A typeYin theXnamespace",
                        "A typeZin theXnamespace (the instance shape of the class)",
                        "A valueZthat is a property of theXvalue (the constructor function of the class)"
                    ]
                },
                {
                    "type": "p",
                    "text": "The second block creates the following name meanings:"
                },
                {
                    "type": "list",
                    "items": [
                        "A valueY(of typenumber) that is a property of theXvalue",
                        "A namespaceZ",
                        "A valueZthat is a property of theXvalue",
                        "A typeCin theX.Znamespace",
                        "A valueCthat is a property of theX.Zvalue",
                        "A typeX"
                    ]
                },
                {
                    "type": "p",
                    "text": "Recommendations for writing d.ts files"
                },
                {
                    "type": "p",
                    "text": "How to get your d.ts files to users"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
            "title": "TypeScript: Documentation - Do's and Don'ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "❌Don’tever use the typesNumber,String,Boolean,Symbol, orObjectThese types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code."
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */functionreverse(s:String):String;"
                },
                {
                    "type": "p",
                    "text": "✅Douse the typesnumber,string,boolean, andsymbol."
                },
                {
                    "type": "code",
                    "code": "ts/* OK */functionreverse(s:string):string;"
                },
                {
                    "type": "p",
                    "text": "Instead ofObject, use the non-primitiveobjecttype (added in TypeScript 2.2)."
                },
                {
                    "type": "p",
                    "text": "❌Don’tever have a generic type which doesn’t use its type parameter.\nSee more details inTypeScript FAQ page."
                },
                {
                    "type": "p",
                    "text": "❌Don’tuseanyas a type unless you are in the process of migrating a JavaScript project to TypeScript. The compilereffectivelytreatsanyas “please turn off type checking for this thing”. It is similar to putting an@ts-ignorecomment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet asany, but in a full TypeScript project you are disabling type checking for any parts of your program that use it. In cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can useunknown."
                },
                {
                    "type": "p",
                    "text": "❌Don’tuse the return typeanyfor callbacks whose value will be ignored:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */functionfn(x: ()=>any) {x();}"
                },
                {
                    "type": "p",
                    "text": "✅Douse the return typevoidfor callbacks whose value will be ignored:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */functionfn(x: ()=>void) {x();}"
                },
                {
                    "type": "p",
                    "text": "❔Why:Usingvoidis safer because it prevents you from accidentally using the return value ofxin an unchecked way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x: ()=>void) {vark=x();// oops! meant to do something elsek.doSomething();// error, but would be OK if the return type had been 'any'}"
                },
                {
                    "type": "p",
                    "text": "❌Don’tuse optional parameters in callbacks unless you really mean it:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceFetcher{getObject(done: (data:unknown,elapsedTime?:number)=>void):void;}"
                },
                {
                    "type": "p",
                    "text": "This has a very specific meaning: thedonecallback might be invoked with 1 argument or might be invoked with 2 arguments.\nThe author probably intended to say that the callback might not care about theelapsedTimeparameter,\nbut there’s no need to make the parameter optional to accomplish this —\nit’s always legal to provide a callback that accepts fewer arguments. ✅Dowrite callback parameters as non-optional:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceFetcher{getObject(done: (data:unknown,elapsedTime:number)=>void):void;}"
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite separate overloads that differ only on callback arity:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */declarefunctionbeforeAll(action: ()=>void,timeout?:number):void;declarefunctionbeforeAll(action: (done:DoneFn)=>void,timeout?:number):void;"
                },
                {
                    "type": "p",
                    "text": "✅Dowrite a single overload using the maximum arity:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */declarefunctionbeforeAll(action: (done:DoneFn)=>void,timeout?:number):void;"
                },
                {
                    "type": "p",
                    "text": "❔Why:It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload.\nProviding a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload."
                },
                {
                    "type": "p",
                    "text": "❌Don’tput more general overloads before more specific overloads:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */declarefunctionfn(x:unknown):unknown;declarefunctionfn(x:HTMLElement):number;declarefunctionfn(x:HTMLDivElement):string;varmyElem:HTMLDivElement;varx=fn(myElem);// x: unknown, wat?"
                },
                {
                    "type": "p",
                    "text": "✅Dosort overloads by putting the more general signatures after more specific signatures:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */declarefunctionfn(x:HTMLDivElement):string;declarefunctionfn(x:HTMLElement):number;declarefunctionfn(x:unknown):unknown;varmyElem:HTMLDivElement;varx=fn(myElem);// x: string, :)"
                },
                {
                    "type": "p",
                    "text": "❔Why:TypeScript chooses thefirst matching overloadwhen resolving function calls.\nWhen an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called."
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite several overloads that differ only in trailing parameters:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceExample{diff(one:string):number;diff(one:string,two:string):number;diff(one:string,two:string,three:boolean):number;}"
                },
                {
                    "type": "p",
                    "text": "✅Douse optional parameters whenever possible:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceExample{diff(one:string,two?:string,three?:boolean):number;}"
                },
                {
                    "type": "p",
                    "text": "Note that this collapsing should only occur when all overloads have the same return type. ❔Why:This is important for two reasons. TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source,and extraneous arguments are allowed.\nThis code, for example, exposes a bug only when the signature is correctly written using optional parameters:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x: (a:string,b:number,c:number)=>void) {}varx:Example;// When written with overloads, OK -- used first overload// When written with optionals, correctly an errorfn(x.diff);"
                },
                {
                    "type": "p",
                    "text": "The second reason is when a consumer uses the “strict null checking” feature of TypeScript.\nBecause unspecified parameters appear asundefinedin JavaScript, it’s usually fine to pass an explicitundefinedto a function with optional arguments.\nThis code, for example, should be OK under strict nulls:"
                },
                {
                    "type": "code",
                    "code": "tsvarx:Example;// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'// When written with optionals, correctly OKx.diff(\"something\",true?undefined:\"hour\");"
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite overloads that differ by type in only one argument position:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceMoment{utcOffset():number;utcOffset(b:number):Moment;utcOffset(b:string):Moment;}"
                },
                {
                    "type": "p",
                    "text": "✅Douse union types whenever possible:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceMoment{utcOffset():number;utcOffset(b:number|string):Moment;}"
                },
                {
                    "type": "p",
                    "text": "Note that we didn’t makeboptional here because the return types of the signatures differ. ❔Why:This is important for people who are “passing through” a value to your function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string):Moment;functionfn(x:number):Moment;functionfn(x:number|string) {// When written with separate overloads, incorrectly an error// When written with union types, correctly OKreturnmoment().utcOffset(x);}"
                },
                {
                    "type": "p",
                    "text": "How do d.ts files work, a deep dive"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html",
            "title": "TypeScript: Documentation - Creating .d.ts Files from .js files",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "With TypeScript 3.7,\nTypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax. This set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase.\nTypeScript supports most JSDoc tags, you can findthe reference here."
                },
                {
                    "type": "p",
                    "text": "To add creation of .d.ts files in your project, you will need to do up-to four steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Add TypeScript to your dev dependencies",
                        "Add atsconfig.jsonto configure TypeScript",
                        "Run the TypeScript compiler to generate the corresponding d.ts files for JS files",
                        "(optional) Edit your package.json to reference the types"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can learn how to do this in ourinstallation page."
                },
                {
                    "type": "p",
                    "text": "The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files.\nIn this case, you will want a file like the following:"
                },
                {
                    "type": "code",
                    "code": "{// Change this to match your project\"include\": [\"src/**/*\"],\"compilerOptions\": {// Tells TypeScript to read JS files, as// normally they are ignored as source files\"allowJs\":true,// Generate d.ts files\"declaration\":true,// This compiler run should// only output d.ts files\"emitDeclarationOnly\":true,// Types should go into this directory.// Removing this would place the .d.ts files// next to the .js files\"outDir\":\"dist\",// go to js file when using IDE functions like// \"Go to Definition\" in VSCode\"declarationMap\":true}}"
                },
                {
                    "type": "p",
                    "text": "You can learn more about the options in thetsconfig reference.\nAn alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command."
                },
                {
                    "type": "code",
                    "code": "shnpx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types"
                },
                {
                    "type": "p",
                    "text": "You can learn how to do this in ourinstallation page.\nYou want to make sure these files are included in your package if you have the files in your project’s.gitignore."
                },
                {
                    "type": "p",
                    "text": "TypeScript replicates the node resolution for modules in apackage.json, with an additional step for finding .d.ts files.\nRoughly, the resolution will first check the optionaltypesfield, then the\"main\"field, and finally will tryindex.d.tsin the root."
                },
                {
                    "type": "p",
                    "text": "If absent, then “main” is used"
                },
                {
                    "type": "p",
                    "text": "If you’d like to write tests for your .d.ts files, trytsdorTSTyche."
                },
                {
                    "type": "p",
                    "text": "What JSDoc does TypeScript-powered JavaScript support?"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html",
            "title": "TypeScript: Documentation - Introduction",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started. If you haven’t already, you should read theTypeScript Handbookto familiarize yourself with basic concepts, especially types and modules. The most common case for learning how .d.ts files work is that you’re typing an npm package with no types.\nIn that case, you can jump straight toModules .d.ts. The Declaration Files section is broken down into the following sections."
                },
                {
                    "type": "p",
                    "text": "We are often faced with writing a declaration file when we only have examples of the underlying library to guide us.\nTheDeclaration Referencesection shows many common API patterns and how to write declarations for each of them.\nThis guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript."
                },
                {
                    "type": "p",
                    "text": "TheLibrary Structuresguide helps you understand common library formats and how to write a proper declaration file for each format.\nIf you’re editing an existing file, you probably don’t need to read this section.\nAuthors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file. In the Template section you’ll find a number of declaration files that serve as a useful starting point\nwhen writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar."
                },
                {
                    "type": "p",
                    "text": "Many common mistakes in declaration files can be easily avoided.\nTheDo’s and Don’tssection identifies common errors,\ndescribes how to detect them,\nand how to fix them.\nEveryone should read this section to help themselves avoid common mistakes."
                },
                {
                    "type": "p",
                    "text": "For seasoned authors interested in the underlying mechanics of how declaration files work,\ntheDeep Divesection explains many advanced concepts in declaration writing,\nand shows how to leverage these concepts to create cleaner and more intuitive declaration files."
                },
                {
                    "type": "p",
                    "text": "ThePublishingsection explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages."
                },
                {
                    "type": "p",
                    "text": "For JavaScript library users, theConsumptionsection offers a few simple steps to locate and install corresponding declaration files."
                },
                {
                    "type": "p",
                    "text": "How to create a d.ts file for a module"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html",
            "title": "TypeScript: Documentation - Library Structures",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Broadly speaking, the way youstructureyour declaration file depends on how the library is consumed.\nThere are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it.\nThis guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern. Each type of major library structuring pattern has a corresponding file in theTemplatessection.\nYou can start with these templates to help you get going faster."
                },
                {
                    "type": "p",
                    "text": "First, we’ll review the kinds of libraries TypeScript declaration files can represent.\nWe’ll briefly show how each kind of library isused, how it iswritten, and list some example libraries from the real world. Identifying the structure of a library is the first step in writing its declaration file.\nWe’ll give hints on how to identify structure both based on itsusageand itscode.\nDepending on the library’s documentation and organization, one might be easier than the other.\nWe recommend using whichever is more comfortable to you."
                },
                {
                    "type": "p",
                    "text": "Question to ask yourself while looking at a library you are trying to type."
                },
                {
                    "type": "list",
                    "items": [
                        "How do you obtain the library?For example, can youonlyget it through npm or only from a CDN?",
                        "How would you import it?Does it add a global object? Does it userequireorimport/exportstatements?"
                    ]
                },
                {
                    "type": "p",
                    "text": "Almost every modern Node.js library falls into the module family.\nThese type of libraries only work in a JS environment with a module loader.\nFor example,expressonly works in Node.js and must be loaded using the CommonJSrequirefunction. ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions ofimportingamodule.\nIn JavaScript CommonJS (Node.js), for example, you would write"
                },
                {
                    "type": "code",
                    "code": "jsvarfs=require(\"fs\");"
                },
                {
                    "type": "p",
                    "text": "In TypeScript or ES6, theimportkeyword serves the same purpose:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfsfrom\"fs\";"
                },
                {
                    "type": "p",
                    "text": "You’ll typically see modular libraries include one of these lines in their documentation:"
                },
                {
                    "type": "code",
                    "code": "jsvarsomeLib=require(\"someLib\");"
                },
                {
                    "type": "p",
                    "text": "or"
                },
                {
                    "type": "code",
                    "code": "jsdefine(..., ['someLib'],function(someLib) {});"
                },
                {
                    "type": "p",
                    "text": "As with global modules, you might see these examples in the documentation ofa UMDmodule, so be sure to check the code or documentation."
                },
                {
                    "type": "p",
                    "text": "Modular libraries will typically have at least some of the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Unconditional calls torequireordefine",
                        "Declarations likeimport * as a from 'b';orexport c;",
                        "Assignments toexportsormodule.exports"
                    ]
                },
                {
                    "type": "p",
                    "text": "They will rarely have:"
                },
                {
                    "type": "list",
                    "items": [
                        "Assignments to properties ofwindoworglobal"
                    ]
                },
                {
                    "type": "p",
                    "text": "There are four templates available for modules,module.d.ts,module-class.d.ts,module-function.d.tsandmodule-plugin.d.ts. You should first readmodule.d.tsfor an overview on the way they all work. Then use the templatemodule-function.d.tsif your module can becalledlike a function:"
                },
                {
                    "type": "code",
                    "code": "jsconstx=require(\"foo\");// Note: calling 'x' as a functionconsty=x(42);"
                },
                {
                    "type": "p",
                    "text": "Use the templatemodule-class.d.tsif your module can beconstructedusingnew:"
                },
                {
                    "type": "code",
                    "code": "jsconstx=require(\"bar\");// Note: using 'new' operator on the imported variableconsty=newx(\"hello\");"
                },
                {
                    "type": "p",
                    "text": "If you have a module which when imported, makes changes to other modules use templatemodule-plugin.d.ts:"
                },
                {
                    "type": "code",
                    "code": "jsconstjest=require(\"jest\");require(\"jest-matchers-files\");"
                },
                {
                    "type": "p",
                    "text": "Agloballibrary is one that can be accessed from the global scope (i.e. without using any form ofimport).\nMany libraries simply expose one or more global variables for use.\nFor example, if you were usingjQuery, the$variable can be used by simply referring to it:"
                },
                {
                    "type": "code",
                    "code": "ts$(()=>{console.log(\"hello!\");});"
                },
                {
                    "type": "p",
                    "text": "You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"http://a.great.cdn.for/someLib.js\"></script>"
                },
                {
                    "type": "p",
                    "text": "Today, most popular globally-accessible libraries are actually written as UMD libraries (see below).\nUMD library documentation is hard to distinguish from global library documentation.\nBefore writing a global declaration file, make sure the library isn’t actually UMD."
                },
                {
                    "type": "p",
                    "text": "Global library code is usually extremely simple.\nA global “Hello, world” library might look like this:"
                },
                {
                    "type": "code",
                    "code": "jsfunctioncreateGreeting(s) {return\"Hello, \"+s;}"
                },
                {
                    "type": "p",
                    "text": "or like this:"
                },
                {
                    "type": "code",
                    "code": "js// Webwindow.createGreeting=function(s) {return\"Hello, \"+s;};// Nodeglobal.createGreeting=function(s) {return\"Hello, \"+s;};// Potentially any runtimeglobalThis.createGreeting=function(s) {return\"Hello, \"+s;};"
                },
                {
                    "type": "p",
                    "text": "When looking at the code of a global library, you’ll usually see:"
                },
                {
                    "type": "list",
                    "items": [
                        "Top-levelvarstatements orfunctiondeclarations",
                        "One or more assignments towindow.someName",
                        "Assumptions that DOM primitives likedocumentorwindowexist"
                    ]
                },
                {
                    "type": "p",
                    "text": "Youwon’tsee:"
                },
                {
                    "type": "list",
                    "items": [
                        "Checks for, or usage of, module loaders likerequireordefine",
                        "CommonJS/Node.js-style imports of the formvar fs = require(\"fs\");",
                        "Calls todefine(...)",
                        "Documentation describing how torequireor import the library"
                    ]
                },
                {
                    "type": "p",
                    "text": "Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style.\nHowever, libraries that are small and require the DOM (or havenodependencies) may still be global."
                },
                {
                    "type": "p",
                    "text": "The template fileglobal.d.tsdefines an example librarymyLib.\nBe sure to read the“Preventing Name Conflicts” footnote."
                },
                {
                    "type": "p",
                    "text": "AUMDmodule is one that caneitherbe used as module (through an import), or as a global (when run in an environment without a module loader).\nMany popular libraries, such asMoment.js, are written this way.\nFor example, in Node.js or using RequireJS, you would write:"
                },
                {
                    "type": "code",
                    "code": "tsimportmoment=require(\"moment\");console.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "whereas in a vanilla browser environment you would write:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "UMD modulescheck for the existence of a module loader environment.\nThis is an easy-to-spot pattern that looks something like this:"
                },
                {
                    "type": "code",
                    "code": "js(function(root,factory) {if(typeofdefine===\"function\"&&define.amd) {define([\"libName\"],factory);}elseif(typeofmodule===\"object\"&&module.exports) {module.exports=factory(require(\"libName\"));}else{root.returnExports=factory(root.libName);}}(this,function(b) {"
                },
                {
                    "type": "p",
                    "text": "If you see tests fortypeof define,typeof window, ortypeof modulein the code of a library, especially at the top of the file, it’s almost always a UMD library. Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showingrequire,\nand a “Using in the browser” example showing using a<script>tag to load the script."
                },
                {
                    "type": "p",
                    "text": "Most popular libraries are now available as UMD packages.\nExamples includejQuery,Moment.js,lodash, and many more."
                },
                {
                    "type": "p",
                    "text": "Use themodule-plugin.d.tstemplate."
                },
                {
                    "type": "p",
                    "text": "There are several kinds of dependencies your library might have.\nThis section shows how to import them into the declaration file."
                },
                {
                    "type": "p",
                    "text": "If your library depends on a global library, use a/// <reference types=\"...\" />directive:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"someLib\"/>functiongetThing():someLib.thing;"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a module, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmomentfrom\"moment\";functiongetThing():moment;"
                },
                {
                    "type": "p",
                    "text": "If your global library depends on a UMD module, use a/// <reference typesdirective:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"moment\"/>functiongetThing():moment;"
                },
                {
                    "type": "p",
                    "text": "If your module or UMD library depends on a UMD library, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*assomeLibfrom\"someLib\";"
                },
                {
                    "type": "p",
                    "text": "Donotuse a/// <referencedirective to declare a dependency to a UMD library!"
                },
                {
                    "type": "p",
                    "text": "Note that it’s possible to define many types in the global scope when writing a global declaration file.\nWe strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project. A simple rule to follow is to only declare typesnamespacedby whatever global variable the library defines.\nFor example, if the library defines the global value ‘cats’, you should write"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacecats{interfaceKittySettings{}}"
                },
                {
                    "type": "p",
                    "text": "Butnot"
                },
                {
                    "type": "code",
                    "code": "ts// at top-levelinterfaceCatsKittySettings{}"
                },
                {
                    "type": "p",
                    "text": "This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users."
                },
                {
                    "type": "p",
                    "text": "Many popular libraries, such as Express, expose themselves as a callable function when imported.\nFor example, the typical Express usage looks like this:"
                },
                {
                    "type": "code",
                    "code": "tsimportexp=require(\"express\");varapp=exp();"
                },
                {
                    "type": "p",
                    "text": "In ES6-compliant module loaders, the top-level object (here imported asexp) can only have properties;\nthe top-level module object canneverbe callable. The most common solution here is to define adefaultexport for a callable/constructable object;\nmodule loaders commonly detect this situation automatically and replace the top-level object with thedefaultexport.\nTypeScript can handle this for you, if you have\"esModuleInterop\": truein your tsconfig.json."
                },
                {
                    "type": "p",
                    "text": "How to create a d.ts file for a module"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html",
            "title": "TypeScript: Documentation - Publishing",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm.\nThere are two main ways you can publish your declaration files to npm:"
                },
                {
                    "type": "list",
                    "items": [
                        "bundling with your npm package",
                        "publishing to the@types organizationon npm."
                    ]
                },
                {
                    "type": "p",
                    "text": "If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types viadeclaration. Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the@typesorganization on npm."
                },
                {
                    "type": "p",
                    "text": "If your package has a main.jsfile, you will need to indicate the main declaration file in yourpackage.jsonfile as well.\nSet thetypesproperty to point to your bundled declaration file.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"awesome\",\"author\":\"Vandelay Industries\",\"version\":\"1.0.0\",\"main\":\"./lib/main.js\",\"types\":\"./lib/main.d.ts\"}"
                },
                {
                    "type": "p",
                    "text": "Note that the\"typings\"field is synonymous withtypes, and could be used as well."
                },
                {
                    "type": "p",
                    "text": "All dependencies are managed by npm.\nMake sure all the declaration packages you depend on are marked appropriately in the\"dependencies\"section in yourpackage.json.\nFor example, imagine we authored a package that used Browserify and TypeScript."
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"browserify-typescript-extension\",\"author\":\"Vandelay Industries\",\"version\":\"1.0.0\",\"main\":\"./lib/main.js\",\"types\":\"./lib/main.d.ts\",\"dependencies\": {\"browserify\":\"latest\",\"@types/browserify\":\"latest\",\"typescript\":\"next\"}}"
                },
                {
                    "type": "p",
                    "text": "Here, our package depends on thebrowserifyandtypescriptpackages.browserifydoes not bundle its declaration files with its npm packages, so we needed to depend on@types/browserifyfor its declarations.typescript, on the other hand, packages its declaration files, so there was no need for any additional dependencies. Our package exposes declarations from each of those, so any user of ourbrowserify-typescript-extensionpackage needs to have these dependencies as well.\nFor that reason, we used\"dependencies\"and not\"devDependencies\", because otherwise our consumers would have needed to manually install those packages.\nIf we had just written a command line application and not expected our package to be used as a library, we might have useddevDependencies."
                },
                {
                    "type": "p",
                    "text": "Don’tuse/// <reference path=\"...\" />in your declaration files."
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"../typescript/lib/typescriptServices.d.ts\"/>...."
                },
                {
                    "type": "p",
                    "text": "Douse/// <reference types=\"...\" />instead."
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"typescript\"/>...."
                },
                {
                    "type": "p",
                    "text": "Make sure to revisit theConsuming dependenciessection for more information."
                },
                {
                    "type": "p",
                    "text": "If your type definitions depend on another package:"
                },
                {
                    "type": "list",
                    "items": [
                        "Don’tcombine it with yours, keep each in their own file.",
                        "Don’tcopy the declarations in your package either.",
                        "Dodepend on the npm type declaration package if it doesn’t package its declaration files."
                    ]
                },
                {
                    "type": "p",
                    "text": "When TypeScript opens apackage.jsonfile to figure out which files it needs to read, it first looks at a field calledtypesVersions."
                },
                {
                    "type": "p",
                    "text": "Apackage.jsonwith atypesVersionsfield might look like this:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"package-name\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.1\": {\"*\": [\"ts3.1/*\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Thispackage.jsontells TypeScript to first check the current version of TypeScript.\nIf it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’sts3.1folder. That’s what that{ \"*\": [\"ts3.1/*\"] }means - if you’re familiar withpath mapping, it works exactly like that. In the above example, if we’re importing from\"package-name\", TypeScript will try to resolve from[...]/node_modules/package-name/ts3.1/index.d.ts(and other relevant paths) when running in TypeScript 3.1.\nIf we import frompackage-name/foo, we’ll try to look for[...]/node_modules/package-name/ts3.1/foo.d.tsand[...]/node_modules/package-name/ts3.1/foo/index.d.ts. What if we’re not running in TypeScript 3.1 in this example?\nWell, if none of the fields intypesVersionsget matched, TypeScript falls back to thetypesfield, so here TypeScript 3.0 and earlier will be redirected to[...]/node_modules/package-name/index.d.ts."
                },
                {
                    "type": "p",
                    "text": "When you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"package-name\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\"<4.0\": {\"index.d.ts\": [\"index.v3.d.ts\"] }}}"
                },
                {
                    "type": "p",
                    "text": "On TypeScript 4.0 and above, an import for\"package-name\"would resolve to./index.d.tsand for 3.9 and below\"./index.v3.d.ts. Note that redirections only affect theexternalAPI of a package; import resolution within a project is not affected bytypesVersions. For example, ad.tsfile in the previous example containingimport * as foo from \"./index\"will still map toindex.d.ts, notindex.v3.d.ts, whereas another package importingimport * as foo from \"package-name\"willgetindex.v3.d.ts."
                },
                {
                    "type": "p",
                    "text": "The way that TypeScript decides on whether a version of the compiler & language matches is by using Node’ssemver ranges."
                },
                {
                    "type": "p",
                    "text": "typesVersionscan support multiple fields where each field name is specified by the range to match on."
                },
                {
                    "type": "code",
                    "code": "{\"name\":\"package-name\",\"version\":\"1.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.2\": {\"*\": [\"ts3.2/*\"] },\">=3.1\": {\"*\": [\"ts3.1/*\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Since ranges have the potential to overlap, determining which redirect applies is order-specific.\nThat means in the above example, even though both the>=3.2and the>=3.1matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following."
                },
                {
                    "type": "code",
                    "code": "{\"name\":\"package-name\",\"version\":\"1.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {// NOTE: this doesn't work!\">=3.1\": {\"*\": [\"ts3.1/*\"] },\">=3.2\": {\"*\": [\"ts3.2/*\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Packages under the@typesorganization are published automatically fromDefinitelyTypedusing thetypes-publisher tool.\nTo get your declarations published as an @types package, please submit a pull request toDefinitelyTyped.\nYou can find more details in thecontribution guidelines page."
                },
                {
                    "type": "p",
                    "text": "How do d.ts files work, a deep dive"
                },
                {
                    "type": "p",
                    "text": "How to download d.ts files for your project"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html",
            "title": "TypeScript: Documentation - Templates",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "global-modifying-module.d.ts"
                },
                {
                    "type": "list",
                    "items": [
                        "global-plugin.d.ts",
                        "global.d.ts",
                        "module-class.d.ts",
                        "module-function.d.ts",
                        "module-plugin.d.ts",
                        "module.d.ts"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html",
            "title": "TypeScript: Documentation - Global .d.ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Agloballibrary is one that can be accessed from the global scope (i.e. without using any form ofimport).\nMany libraries simply expose one or more global variables for use.\nFor example, if you were usingjQuery, the$variable can be used by simply referring to it:"
                },
                {
                    "type": "code",
                    "code": "ts$(()=>{console.log(\"hello!\");});"
                },
                {
                    "type": "p",
                    "text": "You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"http://a.great.cdn.for/someLib.js\"></script>"
                },
                {
                    "type": "p",
                    "text": "Today, most popular globally-accessible libraries are actually written as UMD libraries (see below).\nUMD library documentation is hard to distinguish from global library documentation.\nBefore writing a global declaration file, make sure the library isn’t actually UMD."
                },
                {
                    "type": "p",
                    "text": "Global library code is usually extremely simple.\nA global “Hello, world” library might look like this:"
                },
                {
                    "type": "code",
                    "code": "jsfunctioncreateGreeting(s) {return\"Hello, \"+s;}"
                },
                {
                    "type": "p",
                    "text": "or like this:"
                },
                {
                    "type": "code",
                    "code": "jswindow.createGreeting=function(s) {return\"Hello, \"+s;};"
                },
                {
                    "type": "p",
                    "text": "When looking at the code of a global library, you’ll usually see:"
                },
                {
                    "type": "list",
                    "items": [
                        "Top-levelvarstatements orfunctiondeclarations",
                        "One or more assignments towindow.someName",
                        "Assumptions that DOM primitives likedocumentorwindowexist"
                    ]
                },
                {
                    "type": "p",
                    "text": "Youwon’tsee:"
                },
                {
                    "type": "list",
                    "items": [
                        "Checks for, or usage of, module loaders likerequireordefine",
                        "CommonJS/Node.js-style imports of the formvar fs = require(\"fs\");",
                        "Calls todefine(...)",
                        "Documentation describing how torequireor import the library"
                    ]
                },
                {
                    "type": "p",
                    "text": "Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style.\nHowever, libraries that are small and require the DOM (or havenodependencies) may still be global."
                },
                {
                    "type": "p",
                    "text": "You can see an example DTS below:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ If this library is callable (e.g. can be invoked as myLib(3)),*~ include those call signatures here.*~ Otherwise, delete this section.*/declarefunctionmyLib(a:string):string;declarefunctionmyLib(a:number):number;/*~ If you want the name of this library to be a valid type name,*~ you can do so here.*~*~ For example, this allows us to write 'var x: myLib';*~ Be sure this actually makes sense! If it doesn't, just*~ delete this declaration and add types inside the namespace below.*/interfacemyLib{name:string;length:number;extras?:string[];}/*~ If your library has properties exposed on a global variable,*~ place them here.*~ You should also place types (interfaces and type alias) here.*/declarenamespacemyLib{//~ We can write 'myLib.timeout = 50;'lettimeout:number;//~ We can access 'myLib.version', but not change itconstversion:string;//~ There's some class we can create via 'let c = new myLib.Cat(42)'//~ Or reference e.g. 'function f(c: myLib.Cat) { ... }classCat{constructor(n:number);//~ We can read 'c.age' from a 'Cat' instancereadonlyage:number;//~ We can invoke 'c.purr()' from a 'Cat' instancepurr():void;}//~ We can declare a variable as//~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'interfaceCatSettings{weight:number;name:string;tailLength?:number;}//~ We can write 'const v: myLib.VetID = 42;'//~  or 'const v: myLib.VetID = \"bob\";'typeVetID=string|number;//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'functioncheckCat(c:Cat,s?:VetID);}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html",
            "title": "TypeScript: Documentation - Global: Modifying Module",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Aglobal-modifying modulealters existing values in the global scope when they are imported.\nFor example, there might exist a library which adds new members toString.prototypewhen imported.\nThis pattern is somewhat dangerous due to the possibility of runtime conflicts,\nbut we can still write a declaration file for it."
                },
                {
                    "type": "p",
                    "text": "Global-modifying modules are generally easy to identify from their documentation.\nIn general, they’re similar to global plugins, but need arequirecall to activate their effects. You might see documentation like this:"
                },
                {
                    "type": "code",
                    "code": "js// 'require' call that doesn't use its return valuevarunused=require(\"magic-string-time\");/* or */require(\"magic-string-time\");varx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "p",
                    "text": "Here is an example"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the global-modifying module template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ Note: If your global-modifying module is callable or constructable, you'll*~ need to combine the patterns here with those in the module-class or module-function*~ template files*/declareglobal{/*~ Here, declare things that go in the global namespace, or augment*~ existing declarations in the global namespace*/interfaceString{fancyFormat(opts:StringFormatOptions):string;}}/*~ If your module exports types or values, write them as usual */exportinterfaceStringFormatOptions{fancinessLevel:number;}/*~ For example, declaring a method on the module (in addition to its global side effects) */exportfunctiondoSomething():void;/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */export{};"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html",
            "title": "TypeScript: Documentation - Global: Plugin",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "AUMDmodule is one that caneitherbe used as module (through an import), or as a global (when run in an environment without a module loader).\nMany popular libraries, such asMoment.js, are written this way.\nFor example, in Node.js or using RequireJS, you would write:"
                },
                {
                    "type": "code",
                    "code": "tsimportmoment=require(\"moment\");console.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "whereas in a vanilla browser environment you would write:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "UMD modulescheck for the existence of a module loader environment.\nThis is an easy-to-spot pattern that looks something like this:"
                },
                {
                    "type": "code",
                    "code": "js(function(root,factory) {if(typeofdefine===\"function\"&&define.amd) {define([\"libName\"],factory);}elseif(typeofmodule===\"object\"&&module.exports) {module.exports=factory(require(\"libName\"));}else{root.returnExports=factory(root.libName);}}(this,function(b) {"
                },
                {
                    "type": "p",
                    "text": "If you see tests fortypeof define,typeof window, ortypeof modulein the code of a library, especially at the top of the file, it’s almost always a UMD library. Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showingrequire,\nand a “Using in the browser” example showing using a<script>tag to load the script."
                },
                {
                    "type": "p",
                    "text": "Most popular libraries are now available as UMD packages.\nExamples includejQuery,Moment.js,lodash, and many more."
                },
                {
                    "type": "p",
                    "text": "There are three templates available for modules,module.d.ts,module-class.d.tsandmodule-function.d.ts. Usemodule-function.d.tsif your module can becalledlike a function:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=require(\"foo\");// Note: calling 'x' as a functionvary=x(42);"
                },
                {
                    "type": "p",
                    "text": "Be sure to read thefootnote “The Impact of ES6 on Module Call Signatures” Usemodule-class.d.tsif your module can beconstructedusingnew:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=require(\"bar\");// Note: using 'new' operator on the imported variablevary=newx(\"hello\");"
                },
                {
                    "type": "p",
                    "text": "The samefootnoteapplies to these modules. If your module is not callable or constructable, use themodule.d.tsfile."
                },
                {
                    "type": "p",
                    "text": "Amodule pluginchanges the shape of another module (either UMD or module).\nFor example, in Moment.js,moment-rangeadds a newrangemethod to themomentobject. For the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module."
                },
                {
                    "type": "p",
                    "text": "Use themodule-plugin.d.tstemplate."
                },
                {
                    "type": "p",
                    "text": "Aglobal pluginis global code that changes the shape of some global.\nAs withglobal-modifying modules, these raise the possibility of runtime conflict. For example, some libraries add new functions toArray.prototypeorString.prototype."
                },
                {
                    "type": "p",
                    "text": "Global plugins are generally easy to identify from their documentation. You’ll see examples that look like this:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "p",
                    "text": "Use theglobal-plugin.d.tstemplate."
                },
                {
                    "type": "p",
                    "text": "Aglobal-modifying modulealters existing values in the global scope when they are imported.\nFor example, there might exist a library which adds new members toString.prototypewhen imported.\nThis pattern is somewhat dangerous due to the possibility of runtime conflicts,\nbut we can still write a declaration file for it."
                },
                {
                    "type": "p",
                    "text": "Global-modifying modules are generally easy to identify from their documentation.\nIn general, they’re similar to global plugins, but need arequirecall to activate their effects. You might see documentation like this:"
                },
                {
                    "type": "code",
                    "code": "js// 'require' call that doesn't use its return valuevarunused=require(\"magic-string-time\");/* or */require(\"magic-string-time\");varx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "p",
                    "text": "Use theglobal-modifying-module.d.tstemplate."
                },
                {
                    "type": "p",
                    "text": "There are several kinds of dependencies your library might have.\nThis section shows how to import them into the declaration file."
                },
                {
                    "type": "p",
                    "text": "If your library depends on a global library, use a/// <reference types=\"...\" />directive:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"someLib\"/>functiongetThing():someLib.thing;"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a module, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmomentfrom\"moment\";functiongetThing():moment;"
                },
                {
                    "type": "p",
                    "text": "If your global library depends on a UMD module, use a/// <reference typesdirective:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"moment\"/>functiongetThing():moment;"
                },
                {
                    "type": "p",
                    "text": "If your module or UMD library depends on a UMD library, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*assomeLibfrom\"someLib\";"
                },
                {
                    "type": "p",
                    "text": "Donotuse a/// <referencedirective to declare a dependency to a UMD library!"
                },
                {
                    "type": "p",
                    "text": "Note that it’s possible to define many types in the global scope when writing a global declaration file.\nWe strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project. A simple rule to follow is to only declare typesnamespacedby whatever global variable the library defines.\nFor example, if the library defines the global value ‘cats’, you should write"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacecats{interfaceKittySettings{}}"
                },
                {
                    "type": "p",
                    "text": "Butnot"
                },
                {
                    "type": "code",
                    "code": "ts// at top-levelinterfaceCatsKittySettings{}"
                },
                {
                    "type": "p",
                    "text": "This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users."
                },
                {
                    "type": "p",
                    "text": "Some plugins add or modify top-level exports on existing modules.\nWhile this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible.\nBecause TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this."
                },
                {
                    "type": "p",
                    "text": "Many popular libraries, such as Express, expose themselves as a callable function when imported.\nFor example, the typical Express usage looks like this:"
                },
                {
                    "type": "code",
                    "code": "tsimportexp=require(\"express\");varapp=exp();"
                },
                {
                    "type": "p",
                    "text": "In ES6 module loaders, the top-level object (here imported asexp) can only have properties;\nthe top-level module object isnevercallable.\nThe most common solution here is to define adefaultexport for a callable/constructable object;\nsome module loader shims will automatically detect this situation and replace the top-level object with thedefaultexport."
                },
                {
                    "type": "p",
                    "text": "The layout of your declaration files should mirror the layout of the library. A library can consist of multiple modules, such as"
                },
                {
                    "type": "code",
                    "code": "myLib+---- index.js+---- foo.js+---- bar+---- index.js+---- baz.js"
                },
                {
                    "type": "p",
                    "text": "These could be imported as"
                },
                {
                    "type": "code",
                    "code": "jsvara=require(\"myLib\");varb=require(\"myLib/foo\");varc=require(\"myLib/bar\");vard=require(\"myLib/bar/baz\");"
                },
                {
                    "type": "p",
                    "text": "Your declaration files should thus be"
                },
                {
                    "type": "code",
                    "code": "@types/myLib+---- index.d.ts+---- foo.d.ts+---- bar+---- index.d.ts+---- baz.d.ts"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This template shows how to write a global plugin. *//*~ Write a declaration for the original type and add new members.*~ For example, this adds a 'toBinaryString' method with overloads to*~ the built-in number type.*/interfaceNumber{toBinaryString(opts?:MyLibrary.BinaryFormatOptions):string;toBinaryString(callback:MyLibrary.BinaryFormatCallback,opts?:MyLibrary.BinaryFormatOptions):string;}/*~ If you need to declare several types, place them inside a namespace*~ to avoid adding too many things to the global namespace.*/declarenamespaceMyLibrary{typeBinaryFormatCallback= (n:number)=>string;interfaceBinaryFormatOptions{prefix?:string;padding:number;}}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html",
            "title": "TypeScript: Documentation - Module: Class",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which looks like:"
                },
                {
                    "type": "code",
                    "code": "tsconstGreeter=require(\"super-greeter\");constgreeter=newGreeter();greeter.greet();"
                },
                {
                    "type": "p",
                    "text": "To handle both importing via UMD and modules:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file for class modules.*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*/// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style://   import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import://   import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myClassLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespace\"super-greeter\";/*~ This declaration specifies that the class constructor function*~ is the exported object from the file*/export=Greeter;/*~ Write your module's methods and properties in this class */declareclassGreeter{constructor(customGreeting?:string);greet:void;myMethod(opts:MyClass.MyClassMethodOptions):number;}/*~ If you want to expose types from your module as well, you can*~ place them in this block.*~*~ Note that if you decide to include this namespace, the module can be*~ incorrectly imported as a namespace object, unless*~ --esModuleInterop is turned on:*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!*/declarenamespaceMyClass{exportinterfaceMyClassMethodOptions{width?:number;height?:number;}}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html",
            "title": "TypeScript: Documentation - Modules .d.ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "A module using CommonJS patterns usesmodule.exportsto describe the exported values. For example, here is a module which exports a function and a numerical constant:"
                },
                {
                    "type": "code",
                    "code": "jsconstmaxInterval=12;functiongetArrayLength(arr) {returnarr.length;}module.exports= {getArrayLength,maxInterval,};"
                },
                {
                    "type": "p",
                    "text": "This can be described by the following.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctiongetArrayLength(arr:any[]):number;exportconstmaxInterval:12;"
                },
                {
                    "type": "p",
                    "text": "The TypeScript playground can show you the.d.tsequivalent for JavaScript code. You cantry it yourself here. The.d.tssyntax intentionally looks likeES Modulessyntax.\nES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:"
                },
                {
                    "type": "code",
                    "code": "jsexportfunctiongetArrayLength(arr) {returnarr.length;}"
                },
                {
                    "type": "p",
                    "text": "This would have the following.d.tsequivalent:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctiongetArrayLength(arr:any[]):number;"
                },
                {
                    "type": "p",
                    "text": "In CommonJS you can export any value as the default export, for example here is a regular expression module:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=/hello(world)?/;"
                },
                {
                    "type": "p",
                    "text": "Which can be described by the following .d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconsthelloWorld:RegExp;exportdefaulthelloWorld;"
                },
                {
                    "type": "p",
                    "text": "Or a number:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=3.142;"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstpi:number;exportdefaultpi;"
                },
                {
                    "type": "p",
                    "text": "One style of exporting in CommonJS is to export a function.\nBecause a function is also an object, then extra fields can be added and are included in the export."
                },
                {
                    "type": "code",
                    "code": "jsfunctiongetArrayLength(arr) {returnarr.length;}getArrayLength.maxInterval=12;module.exports=getArrayLength;"
                },
                {
                    "type": "p",
                    "text": "Which can be described with:"
                },
                {
                    "type": "code",
                    "code": "tsexportdefaultfunctiongetArrayLength(arr:any[]):number;exportconstmaxInterval:12;"
                },
                {
                    "type": "p",
                    "text": "Note that usingexport defaultin your .d.ts files requiresesModuleInterop: trueto work.\nIf you can’t haveesModuleInterop: truein your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use theexport=syntax instead. This older syntax is harder to use but works everywhere.\nHere’s how the above example would have to be written usingexport=:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongetArrayLength(arr:any[]):number;declarenamespacegetArrayLength{declareconstmaxInterval:12;}export=getArrayLength;"
                },
                {
                    "type": "p",
                    "text": "SeeModule: Functionsfor details of how that works, and theModules referencepage."
                },
                {
                    "type": "p",
                    "text": "There are many ways to import a module in modern consuming code:"
                },
                {
                    "type": "code",
                    "code": "tsconstfastify=require(\"fastify\");const{fastify} =require(\"fastify\");importfastify=require(\"fastify\");import*asFastifyfrom\"fastify\";import{fastify,FastifyInstance}from\"fastify\";importfastifyfrom\"fastify\";importfastify, {FastifyInstance}from\"fastify\";"
                },
                {
                    "type": "p",
                    "text": "Covering all of these cases requires the JavaScript code to actually support all of these patterns.\nTo support many of these patterns, a CommonJS module would need to look something like:"
                },
                {
                    "type": "code",
                    "code": "jsclassFastifyInstance{}functionfastify() {returnnewFastifyInstance();}fastify.FastifyInstance=FastifyInstance;// Allows for { fastify }fastify.fastify=fastify;// Allows for strict ES Module supportfastify.default=fastify;// Sets the default exportmodule.exports=fastify;"
                },
                {
                    "type": "p",
                    "text": "You may want to provide a type for JavaScript code which does not exist"
                },
                {
                    "type": "code",
                    "code": "jsfunctiongetArrayMetadata(arr) {return{length:getArrayLength(arr),firstObject:arr[0],};}module.exports= {getArrayMetadata,};"
                },
                {
                    "type": "p",
                    "text": "This can be described with:"
                },
                {
                    "type": "code",
                    "code": "tsexporttypeArrayMetadata= {length:number;firstObject:any|undefined;};exportfunctiongetArrayMetadata(arr:any[]):ArrayMetadata;"
                },
                {
                    "type": "p",
                    "text": "This example is a good case forusing genericsto provide richer type information:"
                },
                {
                    "type": "code",
                    "code": "tsexporttypeArrayMetadata<ArrType> = {length:number;firstObject:ArrType|undefined;};exportfunctiongetArrayMetadata<ArrType>(arr:ArrType[]):ArrayMetadata<ArrType>;"
                },
                {
                    "type": "p",
                    "text": "Now the type of the array propagates into theArrayMetadatatype. The types which are exported can then be re-used by consumers of the modules using eitherimportorimport typein TypeScript code orJSDoc imports."
                },
                {
                    "type": "p",
                    "text": "Trying to describe the runtime relationship of JavaScript code can be tricky.\nWhen the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can usenamespaces. For example, you may have complex enough types to describe that you choose to namespace them inside your.d.ts:"
                },
                {
                    "type": "code",
                    "code": "ts// This represents the JavaScript class which would be available at runtimeexportclassAPI{constructor(baseURL:string);getInfo(opts:API.InfoRequest):API.InfoResponse;}// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declarenamespaceAPI{exportinterfaceInfoRequest{id:string;}exportinterfaceInfoResponse{width:number;height:number;}}"
                },
                {
                    "type": "p",
                    "text": "To understand how namespaces work in.d.tsfiles read the.d.tsdeep dive."
                },
                {
                    "type": "p",
                    "text": "You can useexport as namespaceto declare that your module will be available in the global scope in UMD contexts:"
                },
                {
                    "type": "code",
                    "code": "tsexportasnamespacemoduleName;"
                },
                {
                    "type": "p",
                    "text": "To give you an idea of how all these pieces can come together, here is a reference.d.tsto start with when making a new module"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ If this module is a UMD module that exposes a global variable 'myLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespacemyLib;/*~ If this module exports functions, declare them like so.*/exportfunctionmyFunction(a:string):string;exportfunctionmyOtherFunction(a:number):number;/*~ You can declare types that are available via importing the module */exportinterfaceSomeType{name:string;length:number;extras?:string[];}/*~ You can declare properties of the module using const, let, or var */exportconstmyField:number;"
                },
                {
                    "type": "p",
                    "text": "The layout of your declaration files should mirror the layout of the library. A library can consist of multiple modules, such as"
                },
                {
                    "type": "code",
                    "code": "myLib+---- index.js+---- foo.js+---- bar+---- index.js+---- baz.js"
                },
                {
                    "type": "p",
                    "text": "These could be imported as"
                },
                {
                    "type": "code",
                    "code": "jsvara=require(\"myLib\");varb=require(\"myLib/foo\");varc=require(\"myLib/bar\");vard=require(\"myLib/bar/baz\");"
                },
                {
                    "type": "p",
                    "text": "Your declaration files should thus be"
                },
                {
                    "type": "code",
                    "code": "@types/myLib+---- index.d.ts+---- foo.d.ts+---- bar+---- index.d.ts+---- baz.d.ts"
                },
                {
                    "type": "p",
                    "text": "If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:"
                },
                {
                    "type": "list",
                    "items": [
                        "Create a new folder innode_modules/@types/[libname]",
                        "Create anindex.d.tsin that folder, and copy the example in",
                        "See where your usage of the module breaks, and start to fill out the index.d.ts",
                        "When you’re happy, cloneDefinitelyTyped/DefinitelyTypedand follow the instructions in the README."
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise"
                },
                {
                    "type": "list",
                    "items": [
                        "Create a new file in the root of your source tree:[libname].d.ts",
                        "Adddeclare module \"[libname]\" {  }",
                        "Add the template inside the braces of the declare module, and see where your usage breaks"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html",
            "title": "TypeScript: Documentation - Module: Function",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which looks like:"
                },
                {
                    "type": "code",
                    "code": "tsimportgreeterfrom\"super-greeter\";greeter(2);greeter(\"Hello world\");"
                },
                {
                    "type": "p",
                    "text": "To handle both importing via UMD and modules:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file for function modules.*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*/// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style://   import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import://   import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespacemyFuncLib;/*~ This declaration specifies that the function*~ is the exported object from the file*/export=Greeter;/*~ This example shows how to have multiple overloads for your function */declarefunctionGreeter(name:string):Greeter.NamedReturnType;declarefunctionGreeter(length:number):Greeter.LengthReturnType;/*~ If you want to expose types from your module as well, you can*~ place them in this block. Often you will want to describe the*~ shape of the return type of the function; that type should*~ be declared in here, as this example shows.*~*~ Note that if you decide to include this namespace, the module can be*~ incorrectly imported as a namespace object, unless*~ --esModuleInterop is turned on:*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!*/declarenamespaceGreeter{exportinterfaceLengthReturnType{width:number;height:number;}exportinterfaceNamedReturnType{firstName:string;lastName:string;}/*~ If the module also has properties, declare them here. For example,*~ this declaration says that this code is legal:*~   import f = require('super-greeter');*~   console.log(f.defaultName);*/exportconstdefaultName:string;exportletdefaultLength:number;}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html",
            "title": "TypeScript: Documentation - Module: Plugin",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which extends another library."
                },
                {
                    "type": "code",
                    "code": "tsimport{greeter}from\"super-greeter\";// Normal Greeter APIgreeter(2);greeter(\"Hello world\");// Now we extend the object with a new function at runtimeimport\"hyper-super-greeter\";greeter.hyperGreet();"
                },
                {
                    "type": "p",
                    "text": "The definition for “super-greeter”:"
                },
                {
                    "type": "code",
                    "code": "ts/*~ This example shows how to have multiple overloads for your function */exportinterfaceGreeterFunction{(name:string):void(time:number):void}/*~ This example shows how to export a function specified by an interface */exportconstgreeter:GreeterFunction;"
                },
                {
                    "type": "p",
                    "text": "We can extend the existing module like the following:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module plugin template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ On this line, import the module which this module adds to */import{greeter}from\"super-greeter\";/*~ Here, declare the same module as the one you imported above*~ then we expand the existing declaration of the greeter function*/exportmodule\"super-greeter\"{exportinterfaceGreeterFunction{/** Greets even better! */hyperGreet():void;}}"
                },
                {
                    "type": "p",
                    "text": "This usesdeclaration merging"
                },
                {
                    "type": "p",
                    "text": "Some plugins add or modify top-level exports on existing modules.\nWhile this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible.\nBecause TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html",
            "title": "TypeScript: Documentation - Declaration Merging",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level.\nOne example that is especially unique to TypeScript is the concept of ‘declaration merging’.\nUnderstanding this concept will give you an advantage when working with existing JavaScript.\nIt also opens the door to more advanced abstraction concepts. For the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition.\nThis merged definition has the features of both of the original declarations.\nAny number of declarations can be merged; it’s not limited to just two declarations."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value.\nNamespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation.\nType-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name.\nLastly, value-creating declarations create values that are visible in the output JavaScript."
                },
                {
                    "type": "p",
                    "text": "Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge."
                },
                {
                    "type": "p",
                    "text": "The simplest, and perhaps most common, type of declaration merging is interface merging.\nAt the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox{height:number;width:number;}interfaceBox{scale:number;}letbox:Box= {height:5,width:6,scale:10};"
                },
                {
                    "type": "p",
                    "text": "Non-function members of the interfaces should be unique.\nIf they are not unique, they must be of the same type.\nThe compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types. For function members, each function member of the same name is treated as describing an overload of the same function.\nOf note, too, is that in the case of interfaceAmerging with later interfaceA, the second interface will have a higher precedence than the first. That is, in the example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCloner{clone(animal:Animal):Animal;}interfaceCloner{clone(animal:Sheep):Sheep;}interfaceCloner{clone(animal:Dog):Dog;clone(animal:Cat):Cat;}"
                },
                {
                    "type": "p",
                    "text": "The three interfaces will merge to create a single declaration as so:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCloner{clone(animal:Dog):Dog;clone(animal:Cat):Cat;clone(animal:Sheep):Sheep;clone(animal:Animal):Animal;}"
                },
                {
                    "type": "p",
                    "text": "Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first. One exception to this rule is specialized signatures.\nIf a signature has a parameter whose type is asinglestring literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list. For instance, the following interfaces will merge together:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDocument{createElement(tagName:any):Element;}interfaceDocument{createElement(tagName:\"div\"):HTMLDivElement;createElement(tagName:\"span\"):HTMLSpanElement;}interfaceDocument{createElement(tagName:string):HTMLElement;createElement(tagName:\"canvas\"):HTMLCanvasElement;}"
                },
                {
                    "type": "p",
                    "text": "The resulting merged declaration ofDocumentwill be the following:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDocument{createElement(tagName:\"canvas\"):HTMLCanvasElement;createElement(tagName:\"div\"):HTMLDivElement;createElement(tagName:\"span\"):HTMLSpanElement;createElement(tagName:string):HTMLElement;createElement(tagName:any):Element;}"
                },
                {
                    "type": "p",
                    "text": "Similarly to interfaces, namespaces of the same name will also merge their members.\nSince namespaces create both a namespace and a value, we need to understand how both merge. To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside. To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first. The declaration merge ofAnimalsin this example:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimals{exportclassZebra{}}namespaceAnimals{exportinterfaceLegged{numberOfLegs:number;}exportclassDog{}}"
                },
                {
                    "type": "p",
                    "text": "is equivalent to:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimals{exportinterfaceLegged{numberOfLegs:number;}exportclassZebra{}exportclassDog{}}"
                },
                {
                    "type": "p",
                    "text": "This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members.\nNon-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members. We can see this more clearly in this example:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimal{lethaveMuscles=true;exportfunctionanimalsHaveMuscles() {returnhaveMuscles;}}namespaceAnimal{exportfunctiondoAnimalsHaveMuscles() {returnhaveMuscles;// Error, because haveMuscles is not accessible here}}"
                },
                {
                    "type": "p",
                    "text": "BecausehaveMusclesis not exported, only theanimalsHaveMusclesfunction that shares the same un-merged namespace can see the symbol.\nThedoAnimalsHaveMusclesfunction, even though it’s part of the mergedAnimalnamespace can not see this un-exported member."
                },
                {
                    "type": "p",
                    "text": "Namespaces are flexible enough to also merge with other types of declarations.\nTo do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types.\nTypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages."
                },
                {
                    "type": "p",
                    "text": "This gives the user a way of describing inner classes."
                },
                {
                    "type": "code",
                    "code": "tsclassAlbum{label:Album.AlbumLabel;}namespaceAlbum{exportclassAlbumLabel{}}"
                },
                {
                    "type": "p",
                    "text": "The visibility rules for merged members is the same as described in theMerging Namespacessection, so we must export theAlbumLabelclass for the merged class to see it.\nThe end result is a class managed inside of another class.\nYou can also use namespaces to add more static members to an existing class. In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function.\nTypeScript uses declaration merging to build up definitions like this in a type-safe way."
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildLabel(name:string):string{returnbuildLabel.prefix+name+buildLabel.suffix;}namespacebuildLabel{exportletsuffix=\"\";exportletprefix=\"Hello, \";}console.log(buildLabel(\"Sam Smith\"));"
                },
                {
                    "type": "p",
                    "text": "Similarly, namespaces can be used to extend enums with static members:"
                },
                {
                    "type": "code",
                    "code": "tsenumColor{red=1,green=2,blue=4,}namespaceColor{exportfunctionmixColor(colorName:string) {if(colorName==\"yellow\") {returnColor.red+Color.green;}elseif(colorName==\"white\") {returnColor.red+Color.green+Color.blue;}elseif(colorName==\"magenta\") {returnColor.red+Color.blue;}elseif(colorName==\"cyan\") {returnColor.green+Color.blue;}}}"
                },
                {
                    "type": "p",
                    "text": "Not all merges are allowed in TypeScript.\nCurrently, classes can not merge with other classes or with variables.\nFor information on mimicking class merging, see theMixins in TypeScriptsection."
                },
                {
                    "type": "p",
                    "text": "Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them.\nLet’s look at a toy Observable example:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... implementation left as an exercise for the reader ...}// map.tsimport{Observable}from\"./observable\";Observable.prototype.map=function(f) {// ... another exercise for the reader};"
                },
                {
                    "type": "p",
                    "text": "This works fine in TypeScript too, but the compiler doesn’t know aboutObservable.prototype.map.\nYou can use module augmentation to tell the compiler about it:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... implementation left as an exercise for the reader ...}// map.tsimport{Observable}from\"./observable\";declaremodule\"./observable\"{interfaceObservable<T> {map<U>(f: (x:T)=>U):Observable<U>;}}Observable.prototype.map=function(f) {// ... another exercise for the reader};// consumer.tsimport{Observable}from\"./observable\";import\"./map\";leto:Observable<number>;o.map((x)=>x.toFixed());"
                },
                {
                    "type": "p",
                    "text": "The module name is resolved the same way as module specifiers inimport/export.\nSeeModulesfor more information.\nThen the declarations in an augmentation are merged as if they were declared in the same file as the original. However, there are two limitations to keep in mind:"
                },
                {
                    "type": "list",
                    "items": [
                        "You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.",
                        "Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, anddefaultis a reserved word - see#14080for details)"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can also add declarations to the global scope from inside a module:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... still no implementation ...}declareglobal{interfaceArray<T> {toObservable():Observable<T>;}}Array.prototype.toObservable=function() {// ...};"
                },
                {
                    "type": "p",
                    "text": "Global augmentations have the same behavior and limits as module augmentations."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/decorators.html",
            "title": "TypeScript: Documentation - Decorators",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "NOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0.\nSee:Decorators in Typescript 5.0"
                },
                {
                    "type": "p",
                    "text": "With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members.\nDecorators provide a way to add both annotations and a meta-programming syntax for class declarations and members."
                },
                {
                    "type": "p",
                    "text": "Further Reading (stage 2):A Complete Guide to TypeScript Decorators"
                },
                {
                    "type": "p",
                    "text": "To enable experimental support for decorators, you must enable theexperimentalDecoratorscompiler option either on the command line or in yourtsconfig.json: Command Line:"
                },
                {
                    "type": "code",
                    "code": "shelltsc --target ES5 --experimentalDecorators"
                },
                {
                    "type": "p",
                    "text": "tsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"ES5\",\"experimentalDecorators\":true}}"
                },
                {
                    "type": "p",
                    "text": "ADecoratoris a special kind of declaration that can be attached to aclass declaration,method,accessor,property, orparameter.\nDecorators use the form@expression, whereexpressionmust evaluate to a function that will be called at runtime with information about the decorated declaration. For example, given the decorator@sealedwe might write thesealedfunction as follows:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsealed(target) {// do something with 'target' ...}"
                },
                {
                    "type": "p",
                    "text": "If we want to customize how a decorator is applied to a declaration, we can write a decorator factory.\nADecorator Factoryis simply a function that returns the expression that will be called by the decorator at runtime. We can write a decorator factory in the following fashion:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncolor(value:string) {// this is the decorator factory, it sets up// the returned decorator functionreturnfunction(target) {// this is the decorator// do something with 'target' and 'value'...};}"
                },
                {
                    "type": "p",
                    "text": "Multiple decorators can be applied to a declaration, for example on a single line:"
                },
                {
                    "type": "code",
                    "code": "ts@f@gxTry"
                },
                {
                    "type": "p",
                    "text": "On multiple lines:"
                },
                {
                    "type": "code",
                    "code": "ts@f@gxTry"
                },
                {
                    "type": "p",
                    "text": "When multiple decorators apply to a single declaration, their evaluation is similar tofunction composition in mathematics. In this model, when composing functionsfandg, the resulting composite (f∘g)(x) is equivalent tof(g(x)). As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "The expressions for each decorator are evaluated top-to-bottom.",
                        "The results are then called as functions from bottom-to-top."
                    ]
                },
                {
                    "type": "p",
                    "text": "If we were to usedecorator factories, we can observe this evaluation order with the following example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirst() {console.log(\"first(): factory evaluated\");returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {console.log(\"first(): called\");};}functionsecond() {console.log(\"second(): factory evaluated\");returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {console.log(\"second(): called\");};}classExampleClass{@first()@second()method() {}}Try"
                },
                {
                    "type": "p",
                    "text": "Which would print this output to the console:"
                },
                {
                    "type": "code",
                    "code": "shellfirst(): factory evaluatedsecond(): factory evaluatedsecond(): calledfirst(): called"
                },
                {
                    "type": "p",
                    "text": "There is a well defined order to how decorators applied to various declarations inside of a class are applied:"
                },
                {
                    "type": "list",
                    "items": [
                        "Parameter Decorators, followed byMethod,Accessor, orProperty Decoratorsare applied for each instance member.",
                        "Parameter Decorators, followed byMethod,Accessor, orProperty Decoratorsare applied for each static member.",
                        "Parameter Decoratorsare applied for the constructor.",
                        "Class Decoratorsare applied for the class."
                    ]
                },
                {
                    "type": "p",
                    "text": "AClass Decoratoris declared just before a class declaration.\nThe class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition.\nA class decorator cannot be used in a declaration file, or in any other ambient context (such as on adeclareclass). The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument. If the class decorator returns a value, it will replace the class declaration with the provided constructor function."
                },
                {
                    "type": "p",
                    "text": "NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype.\nThe logic that applies decorators at runtime willnotdo this for you."
                },
                {
                    "type": "p",
                    "text": "The following is an example of a class decorator (@sealed) applied to aBugReportclass:"
                },
                {
                    "type": "code",
                    "code": "ts@sealedclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@sealeddecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsealed(constructor:Function) {Object.seal(constructor);Object.seal(constructor.prototype);}"
                },
                {
                    "type": "p",
                    "text": "When@sealedis executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessingBugReport.prototypeor by defining properties onBugReportitself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator doesnotprevent classes from sub-classingBugReport. Next we have an example of how to override the constructor to set new defaults."
                },
                {
                    "type": "code",
                    "code": "tsfunctionreportableClassDecorator<Textends{new(...args:any[]): {} }>(constructor:T) {returnclassextendsconstructor{reportingURL=\"http://www...\";};}@reportableClassDecoratorclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}}constbug=newBugReport(\"Needs dark mode\");console.log(bug.title);// Prints \"Needs dark mode\"console.log(bug.type);// Prints \"report\"// Note that the decorator _does not_ change the TypeScript type// and so the new property `reportingURL` is not known// to the type system:bug.reportingURL;Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.Try"
                },
                {
                    "type": "p",
                    "text": "AMethod Decoratoris declared just before a method declaration.\nThe decorator is applied to theProperty Descriptorfor the method, and can be used to observe, modify, or replace a method definition.\nA method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in adeclareclass). The expression for the method decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "TheProperty Descriptorfor the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  TheProperty Descriptorwill beundefinedif your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "If the method decorator returns a value, it will be used as theProperty Descriptorfor the method."
                },
                {
                    "type": "p",
                    "text": "NOTE  The return value is ignored if your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "The following is an example of a method decorator (@enumerable) applied to a method on theGreeterclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{greeting:string;constructor(message:string) {this.greeting=message;}@enumerable(false)greet() {return\"Hello, \"+this.greeting;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@enumerabledecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionenumerable(value:boolean) {returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {descriptor.enumerable=value;};}Try"
                },
                {
                    "type": "p",
                    "text": "The@enumerable(false)decorator here is adecorator factory.\nWhen the@enumerable(false)decorator is called, it modifies theenumerableproperty of the property descriptor."
                },
                {
                    "type": "p",
                    "text": "AnAccessor Decoratoris declared just before an accessor declaration.\nThe accessor decorator is applied to theProperty Descriptorfor the accessor and can be used to observe, modify, or replace an accessor’s definitions.\nAn accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "NOTE  TypeScript disallows decorating both thegetandsetaccessor for a single member.\nInstead, all decorators for the member must be applied to the first accessor specified in document order.\nThis is because decorators apply to aProperty Descriptor, which combines both thegetandsetaccessor, not each declaration separately."
                },
                {
                    "type": "p",
                    "text": "The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "TheProperty Descriptorfor the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  TheProperty Descriptorwill beundefinedif your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "If the accessor decorator returns a value, it will be used as theProperty Descriptorfor the member."
                },
                {
                    "type": "p",
                    "text": "NOTE  The return value is ignored if your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "The following is an example of an accessor decorator (@configurable) applied to a member of thePointclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{private_x:number;private_y:number;constructor(x:number,y:number) {this._x=x;this._y=y;}@configurable(false)getx() {returnthis._x;}@configurable(false)gety() {returnthis._y;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@configurabledecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionconfigurable(value:boolean) {returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {descriptor.configurable=value;};}"
                },
                {
                    "type": "p",
                    "text": "AProperty Decoratoris declared just before a property declaration.\nA property decorator cannot be used in a declaration file, or in any other ambient context (such as in adeclareclass). The expression for the property decorator will be called as a function at runtime, with the following two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  AProperty Descriptoris not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript.\nThis is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too.\nAs such, a property decorator can only be used to observe that a property of a specific name has been declared for a class."
                },
                {
                    "type": "p",
                    "text": "We can use this information to record metadata about the property, as in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{@format(\"Hello, %s\")greeting:string;constructor(message:string) {this.greeting=message;}greet() {letformatString=getFormat(this,\"greeting\");returnformatString.replace(\"%s\",this.greeting);}}"
                },
                {
                    "type": "p",
                    "text": "We can then define the@formatdecorator andgetFormatfunctions using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";constformatMetadataKey=Symbol(\"format\");functionformat(formatString:string) {returnReflect.metadata(formatMetadataKey,formatString);}functiongetFormat(target:any,propertyKey:string) {returnReflect.getMetadata(formatMetadataKey,target,propertyKey);}"
                },
                {
                    "type": "p",
                    "text": "The@format(\"Hello, %s\")decorator here is adecorator factory.\nWhen@format(\"Hello, %s\")is called, it adds a metadata entry for the property using theReflect.metadatafunction from thereflect-metadatalibrary.\nWhengetFormatis called, it reads the metadata value for the format."
                },
                {
                    "type": "p",
                    "text": "NOTE  This example requires thereflect-metadatalibrary.\nSeeMetadatafor more information about thereflect-metadatalibrary."
                },
                {
                    "type": "p",
                    "text": "AParameter Decoratoris declared just before a parameter declaration.\nThe parameter decorator is applied to the function for a class constructor or method declaration.\nA parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in adeclareclass). The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "The ordinal index of the parameter in the function’s parameter list."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method."
                },
                {
                    "type": "p",
                    "text": "The return value of the parameter decorator is ignored. The following is an example of a parameter decorator (@required) applied to parameter of a member of theBugReportclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}@validateprint(@requiredverbose:boolean) {if(verbose) {return`type:${this.type}\\ntitle:${this.title}`;}else{returnthis.title;}}}Try"
                },
                {
                    "type": "p",
                    "text": "We can then define the@requiredand@validatedecorators using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";constrequiredMetadataKey=Symbol(\"required\");functionrequired(target:Object,propertyKey:string|symbol,parameterIndex:number) {letexistingRequiredParameters:number[] =Reflect.getOwnMetadata(requiredMetadataKey,target,propertyKey) || [];existingRequiredParameters.push(parameterIndex);Reflect.defineMetadata(requiredMetadataKey,existingRequiredParameters,target,propertyKey);}functionvalidate(target:any,propertyName:string,descriptor:TypedPropertyDescriptor<Function>) {letmethod=descriptor.value!;descriptor.value=function() {letrequiredParameters:number[] =Reflect.getOwnMetadata(requiredMetadataKey,target,propertyName);if(requiredParameters) {for(letparameterIndexofrequiredParameters) {if(parameterIndex>=arguments.length||arguments[parameterIndex] ===undefined) {thrownewError(\"Missing required argument.\");}}}returnmethod.apply(this,arguments);};}Try"
                },
                {
                    "type": "p",
                    "text": "The@requireddecorator adds a metadata entry that marks the parameter as required.\nThe@validatedecorator then wraps the existingprintmethod in a function that validates the arguments before invoking the original method."
                },
                {
                    "type": "p",
                    "text": "NOTE  This example requires thereflect-metadatalibrary.\nSeeMetadatafor more information about thereflect-metadatalibrary."
                },
                {
                    "type": "p",
                    "text": "Some examples use thereflect-metadatalibrary which adds a polyfill for anexperimental metadata API.\nThis library is not yet part of the ECMAScript (JavaScript) standard.\nHowever, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption. You can install this library via npm:"
                },
                {
                    "type": "code",
                    "code": "shellnpm i reflect-metadata --save"
                },
                {
                    "type": "p",
                    "text": "TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators.\nTo enable this experimental support, you must set theemitDecoratorMetadatacompiler option either on the command line or in yourtsconfig.json: Command Line:"
                },
                {
                    "type": "code",
                    "code": "shelltsc --target ES5 --experimentalDecorators --emitDecoratorMetadata"
                },
                {
                    "type": "p",
                    "text": "tsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"ES5\",\"experimentalDecorators\":true,\"emitDecoratorMetadata\":true}}"
                },
                {
                    "type": "p",
                    "text": "When enabled, as long as thereflect-metadatalibrary has been imported, additional design-time type information will be exposed at runtime. We can see this in action in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";classPoint{constructor(publicx:number,publicy:number) {}}classLine{private_start:Point;private_end:Point;@validatesetstart(value:Point) {this._start=value;}getstart() {returnthis._start;}@validatesetend(value:Point) {this._end=value;}getend() {returnthis._end;}}functionvalidate<T>(target:any,propertyKey:string,descriptor:TypedPropertyDescriptor<T>) {letset=descriptor.set!;descriptor.set=function(value:T) {lettype=Reflect.getMetadata(\"design:type\",target,propertyKey);if(!(valueinstanceoftype)) {thrownewTypeError(`Invalid type, got${typeofvalue}not${type.name}.`);}set.call(this,value);};}constline=newLine()line.start=newPoint(0,0)// @ts-ignore// line.end = {}// Fails at runtime with:// > Invalid type, got object not PointTry"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler will inject design-time type information using the@Reflect.metadatadecorator.\nYou could consider it the equivalent of the following TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsclassLine{private_start:Point;private_end:Point;@validate@Reflect.metadata(\"design:type\",Point)setstart(value:Point) {this._start=value;}getstart() {returnthis._start;}@validate@Reflect.metadata(\"design:type\",Point)setend(value:Point) {this._end=value;}getend() {returnthis._end;}}"
                },
                {
                    "type": "p",
                    "text": "NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/dom-manipulation.html",
            "title": "TypeScript: Documentation - DOM Manipulation",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers. Websites are made up of HTML and/or XML documents. These documents are static, they do not change. TheDocument Object Model (DOM)is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop. TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions inlib.dom.d.ts, one stands out among the rest:HTMLElement. This type is the backbone for DOM manipulation with TypeScript."
                },
                {
                    "type": "p",
                    "text": "You can explore the source code for theDOM type definitions"
                },
                {
                    "type": "p",
                    "text": "Given a simplifiedindex.htmlfile:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><htmllang=\"en\"><head><title>TypeScript Dom Manipulation</title></head><body><divid=\"app\"></div><!-- Assume index.js is the compiled output of index.ts --><scriptsrc=\"index.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Let’s explore a TypeScript script that adds a<p>Hello, World!</p>element to the#appelement."
                },
                {
                    "type": "code",
                    "code": "ts// 1. Select the div element using the id propertyconstapp=document.getElementById(\"app\");// 2. Create a new <p></p> element programmaticallyconstp=document.createElement(\"p\");// 3. Add the text contentp.textContent=\"Hello, World!\";// 4. Append the p element to the div elementapp?.appendChild(p);"
                },
                {
                    "type": "p",
                    "text": "After compiling and running theindex.htmlpage, the resulting HTML will be:"
                },
                {
                    "type": "code",
                    "code": "html<divid=\"app\"><p>Hello, World!</p></div>"
                },
                {
                    "type": "p",
                    "text": "The first line of the TypeScript code uses a global variabledocument. Inspecting the variable shows it is defined by theDocumentinterface from thelib.dom.d.tsfile. The code snippet contains calls to two methods,getElementByIdandcreateElement."
                },
                {
                    "type": "p",
                    "text": "The definition for this method is as follows:"
                },
                {
                    "type": "code",
                    "code": "tsgetElementById(elementId:string):HTMLElement|null;"
                },
                {
                    "type": "p",
                    "text": "Pass it an element id string and it will return eitherHTMLElementornull. This method introduces one of the most important types,HTMLElement. It serves as the base interface for every other element interface. For example, thepvariable in the code example is of typeHTMLParagraphElement. Also, take note that this method can returnnull. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the newoptional chainingoperator is used to callappendChild."
                },
                {
                    "type": "p",
                    "text": "The definition for this method is (I have omitted thedeprecateddefinition):"
                },
                {
                    "type": "code",
                    "code": "tscreateElement<KextendskeyofHTMLElementTagNameMap>(tagName:K,options?:ElementCreationOptions):HTMLElementTagNameMap[K];createElement(tagName:string,options?:ElementCreationOptions):HTMLElement;"
                },
                {
                    "type": "p",
                    "text": "This is an overloaded function definition. The second overload is simplest and works a lot like thegetElementByIdmethod does. Pass it anystringand it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags. For exampledocument.createElement('xyz')returns a<xyz></xyz>element, clearly not an element that is specified by the HTML specification."
                },
                {
                    "type": "p",
                    "text": "For those interested, you can interact with custom tag elements using thedocument.getElementsByTagName"
                },
                {
                    "type": "p",
                    "text": "For the first definition ofcreateElement, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression:<K extends keyof HTMLElementTagNameMap>. This expression defines a generic parameterKthat isconstrainedto the keys of the interfaceHTMLElementTagNameMap. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceHTMLElementTagNameMap{\"a\":HTMLAnchorElement;\"abbr\":HTMLElement;\"address\":HTMLElement;\"applet\":HTMLAppletElement;\"area\":HTMLAreaElement;...}"
                },
                {
                    "type": "p",
                    "text": "Some elements do not exhibit unique properties and so they just returnHTMLElement, but other types do have unique properties and methods so they return their specific interface (which will extend from or implementHTMLElement). Now, for the remainder of thecreateElementdefinition:(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]. The first argumenttagNameis defined as the generic parameterK. The TypeScript interpreter is smart enough toinferthe generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to thetagNameargument will be inferred asKand thus can be used throughout the remainder of the definition. This is exactly what happens; the return valueHTMLElementTagNameMap[K]takes thetagNameargument and uses it to return the corresponding type. This definition is how thepvariable from the code snippet gets a type ofHTMLParagraphElement. And if the code wasdocument.createElement('a'), then it would be an element of typeHTMLAnchorElement."
                },
                {
                    "type": "p",
                    "text": "Thedocument.getElementByIdfunction returns anHTMLElement.HTMLElementinterface extends theElementinterface which extends theNodeinterface. This prototypal extension allows for allHTMLElementsto utilize a subset of standard methods. In the code snippet, we use a property defined on theNodeinterface to append the newpelement to the website."
                },
                {
                    "type": "p",
                    "text": "The last line of the code snippet isapp?.appendChild(p). The previous,document.getElementById, section detailed that theoptional chainingoperator is used here becauseappcan potentially be null at runtime. TheappendChildmethod is defined by:"
                },
                {
                    "type": "code",
                    "code": "tsappendChild<TextendsNode>(newChild:T):T;"
                },
                {
                    "type": "p",
                    "text": "This method works similarly to thecreateElementmethod as the generic parameterTis inferred from thenewChildargument.Tisconstrainedto another base interfaceNode."
                },
                {
                    "type": "p",
                    "text": "Previously, this document details theHTMLElementinterface extends fromElementwhich extends fromNode. In the DOM API there is a concept ofchildrenelements. For example in the following HTML, theptags are children of thedivelement"
                },
                {
                    "type": "code",
                    "code": "tsx<div><p>Hello, World</p><p>TypeScript!</p></div>;constdiv=document.getElementsByTagName(\"div\")[0];div.children;// HTMLCollection(2) [p, p]div.childNodes;// NodeList(2) [p, p]"
                },
                {
                    "type": "p",
                    "text": "After capturing thedivelement, thechildrenprop will return anHTMLCollectionlist containing theHTMLParagraphElements. ThechildNodesproperty will return a similarNodeListlist of nodes. Eachptag will still be of typeHTMLParagraphElements, but theNodeListcan contain additionalHTML nodesthat theHTMLCollectionlist cannot. Modify the HTML by removing one of theptags, but keep the text."
                },
                {
                    "type": "code",
                    "code": "tsx<div><p>Hello, World</p>TypeScript!</div>;constdiv=document.getElementsByTagName(\"div\")[0];div.children;// HTMLCollection(1) [p]div.childNodes;// NodeList(2) [p, text]"
                },
                {
                    "type": "p",
                    "text": "See how both lists change.childrennow only contains the<p>Hello, World</p>element, and thechildNodescontains atextnode rather than twopnodes. Thetextpart of theNodeListis the literalNodecontaining the textTypeScript!. Thechildrenlist does not contain thisNodebecause it is not considered anHTMLElement."
                },
                {
                    "type": "p",
                    "text": "Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined inlib.dom.d.tsas:"
                },
                {
                    "type": "code",
                    "code": "ts/*** Returns the first element that is a descendant of node that matches selectors.*/querySelector<KextendskeyofHTMLElementTagNameMap>(selectors:K):HTMLElementTagNameMap[K] |null;querySelector<KextendskeyofSVGElementTagNameMap>(selectors:K):SVGElementTagNameMap[K] |null;querySelector<EextendsElement=Element>(selectors:string):E|null;/*** Returns all element descendants of node that match selectors.*/querySelectorAll<KextendskeyofHTMLElementTagNameMap>(selectors:K):NodeListOf<HTMLElementTagNameMap[K]>;querySelectorAll<KextendskeyofSVGElementTagNameMap>(selectors:K):NodeListOf<SVGElementTagNameMap[K]>;querySelectorAll<EextendsElement=Element>(selectors:string):NodeListOf<E>;"
                },
                {
                    "type": "p",
                    "text": "ThequerySelectorAlldefinition is similar togetElementsByTagName, except it returns a new type:NodeListOf. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacingNodeListOf<E>withE[]would result in a very similar user experience.NodeListOfonly implements the following properties and methods:length,item(index),forEach((value, key, parent) => void), and numeric indexing. Additionally, this method returns a list ofelements, notnodes, which is whatNodeListwas returning from the.childNodesmethod. While this may appear as a discrepancy, take note that interfaceElementextends fromNode. To see these methods in action modify the existing code to:"
                },
                {
                    "type": "code",
                    "code": "tsx<ul><li>First :)</li><li>Second!</li><li>Third times a charm.</li></ul>;constfirst=document.querySelector(\"li\");// returns the first li elementconstall=document.querySelectorAll(\"li\");// returns the list of all li elements"
                },
                {
                    "type": "p",
                    "text": "The best part about thelib.dom.d.tstype definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, theHTMLElementinterface is documented by thisHTMLElement pageon MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to theW3C Recommendation for HTMLElement. Sources:"
                },
                {
                    "type": "list",
                    "items": [
                        "ECMA-262 Standard",
                        "Introduction to the DOM"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/enums.html",
            "title": "TypeScript: Handbook - Enums",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript. Enums allow a developer to define a set of named constants.\nUsing enums can make it easier to document intent, or create a set of distinct cases.\nTypeScript provides both numeric and string-based enums."
                },
                {
                    "type": "p",
                    "text": "We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages.\nAn enum can be defined using theenumkeyword."
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up=1,Down,Left,Right,}Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have a numeric enum whereUpis initialized with1.\nAll of the following members are auto-incremented from that point on.\nIn other words,Direction.Uphas the value1,Downhas2,Lefthas3, andRighthas4. If we wanted, we could leave off the initializers entirely:"
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up,Down,Left,Right,}Try"
                },
                {
                    "type": "p",
                    "text": "Here,Upwould have the value0,Downwould have1, etc.\nThis auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum. Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:"
                },
                {
                    "type": "code",
                    "code": "tsenumUserResponse{No=0,Yes=1,}functionrespond(recipient:string,message:UserResponse):void{// ...}respond(\"Princess Caroline\",UserResponse.Yes);Try"
                },
                {
                    "type": "p",
                    "text": "Numeric enums can be mixed incomputed and constant members (see below).\nThe short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members.\nIn other words, the following isn’t allowed:"
                },
                {
                    "type": "code",
                    "code": "tsenumE{A=getSomeValue(),B,Enum member must have initializer.1061Enum member must have initializer.}Try"
                },
                {
                    "type": "p",
                    "text": "String enums are a similar concept, but have some subtleruntime differencesas documented below.\nIn a string enum, each member has to be constant-initialized with a string literal, or with another string enum member."
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up=\"UP\",Down=\"DOWN\",Left=\"LEFT\",Right=\"RIGHT\",}Try"
                },
                {
                    "type": "p",
                    "text": "While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well.\nIn other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (thoughreverse mappingcan often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself."
                },
                {
                    "type": "p",
                    "text": "Technically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:"
                },
                {
                    "type": "code",
                    "code": "tsenumBooleanLikeHeterogeneousEnum{No=0,Yes=\"YES\",}Try"
                },
                {
                    "type": "p",
                    "text": "Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this."
                },
                {
                    "type": "p",
                    "text": "Each enum member has a value associated with it which can be eitherconstantorcomputed.\nAn enum member is considered constant if:"
                },
                {
                    "type": "list",
                    "items": [
                        "It is the first member in the enum and it has no initializer, in which case it’s assigned the value0:ts// E.X is constant:enumE{X,}Try",
                        "It does not have an initializer and the preceding enum member was anumericconstant.\nIn this case the value of the current enum member will be the value of the preceding enum member plus one.ts// All enum members in 'E1' and 'E2' are constant.enumE1{X,Y,Z,}enumE2{A=1,B,C,}Try",
                        "The enum member is initialized with a constant enum expression.\nA constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time.\nAn expression is a constant enum expression if it is:a literal enum expression (basically a string literal or a numeric literal)a reference to previously defined constant enum member (which can originate from a different enum)a parenthesized constant enum expressionone of the+,-,~unary operators applied to constant enum expression+,-,*,/,%,<<,>>,>>>,&,|,^binary operators with constant enum expressions as operandsIt is a compile time error for constant enum expressions to be evaluated toNaNorInfinity.",
                        "a literal enum expression (basically a string literal or a numeric literal)",
                        "a reference to previously defined constant enum member (which can originate from a different enum)",
                        "a parenthesized constant enum expression",
                        "one of the+,-,~unary operators applied to constant enum expression",
                        "+,-,*,/,%,<<,>>,>>>,&,|,^binary operators with constant enum expressions as operands"
                    ]
                },
                {
                    "type": "p",
                    "text": "In all other cases enum member is considered computed."
                },
                {
                    "type": "code",
                    "code": "tsenumFileAccess{// constant membersNone,Read=1<<1,Write=1<<2,ReadWrite=Read|Write,// computed memberG=\"123\".length,}Try"
                },
                {
                    "type": "p",
                    "text": "There is a special subset of constant enum members that aren’t calculated: literal enum members.\nA literal enum member is a constant enum member with no initialized value, or with values that are initialized to"
                },
                {
                    "type": "list",
                    "items": [
                        "any string literal (e.g.\"foo\",\"bar\",\"baz\")",
                        "any numeric literal (e.g.1,100)",
                        "a unary minus applied to any numeric literal (e.g.-1,-100)"
                    ]
                },
                {
                    "type": "p",
                    "text": "When all members in an enum have literal enum values, some special semantics come into play. The first is that enum members also become types as well!\nFor example, we can say that certain members canonlyhave the value of an enum member:"
                },
                {
                    "type": "code",
                    "code": "tsenumShapeKind{Circle,Square,}interfaceCircle{kind:ShapeKind.Circle;radius:number;}interfaceSquare{kind:ShapeKind.Square;sideLength:number;}letc:Circle= {kind:ShapeKind.Square,Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.radius:100,};Try"
                },
                {
                    "type": "p",
                    "text": "The other change is that enum types themselves effectively become aunionof each enum member.\nWith union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself.\nBecause of that, TypeScript can catch bugs where we might be comparing values incorrectly.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsenumE{Foo,Bar,}functionf(x:E) {if(x!==E.Foo||x!==E.Bar) {This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.//}}Try"
                },
                {
                    "type": "p",
                    "text": "In that example, we first checked whetherxwasnotE.Foo.\nIf that check succeeds, then our||will short-circuit, and the body of the ‘if’ will run.\nHowever, if the check didn’t succeed, thenxcanonlybeE.Foo, so it doesn’t make sense to see whether it’snotequal toE.Bar."
                },
                {
                    "type": "p",
                    "text": "Enums are real objects that exist at runtime.\nFor example, the following enum"
                },
                {
                    "type": "code",
                    "code": "tsenumE{X,Y,Z,}Try"
                },
                {
                    "type": "p",
                    "text": "can actually be passed around to functions"
                },
                {
                    "type": "code",
                    "code": "tsenumE{X,Y,Z,}functionf(obj: {X:number}) {returnobj.X;}// Works, since 'E' has a property named 'X' which is a number.f(E);Try"
                },
                {
                    "type": "p",
                    "text": "Even though Enums are real objects that exist at runtime, thekeyofkeyword works differently than you might expect for typical objects. Instead, usekeyof typeofto get a Type that represents all Enum keys as strings."
                },
                {
                    "type": "code",
                    "code": "tsenumLogLevel{ERROR,WARN,INFO,DEBUG,}/*** This is equivalent to:* type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';*/typeLogLevelStrings=keyoftypeofLogLevel;functionprintImportant(key:LogLevelStrings,message:string) {constnum=LogLevel[key];if(num<=LogLevel.WARN) {console.log(\"Log level key is:\",key);console.log(\"Log level value is:\",num);console.log(\"Log level message is:\",message);}}printImportant(\"ERROR\",\"This is a message\");Try"
                },
                {
                    "type": "p",
                    "text": "In addition to creating an object with property names for members, numeric enums members also get areverse mappingfrom enum values to enum names.\nFor example, in this example:"
                },
                {
                    "type": "code",
                    "code": "tsenumEnum{A,}leta=Enum.A;letnameOfA=Enum[a];// \"A\"Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript compiles this down to the following JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";varEnum;(function(Enum) {Enum[Enum[\"A\"] =0] =\"A\";})(Enum|| (Enum= {}));leta=Enum.A;letnameOfA=Enum[a];// \"A\"Try"
                },
                {
                    "type": "p",
                    "text": "In this generated code, an enum is compiled into an object that stores both forward (name->value) and reverse (value->name) mappings.\nReferences to other enum members are always emitted as property accesses and never inlined. Keep in mind that string enum membersdo notget a reverse mapping generated at all."
                },
                {
                    "type": "p",
                    "text": "In most cases, enums are a perfectly valid solution.\nHowever sometimes requirements are tighter.\nTo avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to useconstenums.\nConst enums are defined using theconstmodifier on our enums:"
                },
                {
                    "type": "code",
                    "code": "tsconstenumEnum{A=1,B=A*2,}Try"
                },
                {
                    "type": "p",
                    "text": "Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation.\nConst enum members are inlined at use sites.\nThis is possible since const enums cannot have computed members."
                },
                {
                    "type": "code",
                    "code": "tsconstenumDirection{Up,Down,Left,Right,}letdirections= [Direction.Up,Direction.Down,Direction.Left,Direction.Right,];Try"
                },
                {
                    "type": "p",
                    "text": "in generated code will become"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";letdirections= [0/* Direction.Up */,1/* Direction.Down */,2/* Direction.Left */,3/* Direction.Right */,];Try"
                },
                {
                    "type": "p",
                    "text": "Inlining enum values is straightforward at first, but comes with subtle implications.\nThese pitfalls pertain toambientconst enums only (basically const enums in.d.tsfiles) and sharing them between projects, but if you are publishing or consuming.d.tsfiles, these pitfalls likely apply to you, becausetsc --declarationtransforms.tsfiles into.d.tsfiles."
                },
                {
                    "type": "list",
                    "items": [
                        "For the reasons laid out in theisolatedModulesdocumentation, that mode is fundamentally incompatible with ambient const enums.\nThis means if you publish ambient const enums, downstream consumers will not be able to useisolatedModulesand those enum values at the same time.",
                        "You can easily inline values from version A of a dependency at compile time, and import version B at runtime.\nVersion A and B’s enums can have different values, if you are not very careful, resulting insurprising bugs, like taking the wrong branches ofifstatements.\nThese bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.",
                        "importsNotUsedAsValues: \"preserve\"will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime.jsfiles exist.\nThe unresolvable imports cause errors at runtime.\nThe usual way to unambiguously elide imports,type-only imports,does not allow const enum values, currently."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here are two approaches to avoiding these pitfalls:"
                },
                {
                    "type": "list",
                    "items": [
                        "Do not use const enums at all.\nYou can easilyban const enumswith the help of a linter.\nObviously this avoids any issues with const enums, but prevents your project from inlining its own enums.\nUnlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.",
                        "Do not publish ambient const enums, by deconstifying them with the help ofpreserveConstEnums.\nThis is the approach taken internally by theTypeScript project itself.preserveConstEnumsemits the same JavaScript for const enums as plain enums.\nYou can then safely strip theconstmodifier from.d.tsfilesin a build step.This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely."
                    ]
                },
                {
                    "type": "p",
                    "text": "Ambient enums are used to describe the shape of already existing enum types."
                },
                {
                    "type": "code",
                    "code": "tsdeclareenumEnum{A=1,B,C=2,}Try"
                },
                {
                    "type": "p",
                    "text": "One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant.\nBy contrast, an ambient (and non-const) enum member that does not have an initializer isalwaysconsidered computed."
                },
                {
                    "type": "p",
                    "text": "In modern TypeScript, you may not need an enum when an object withas constcould suffice:"
                },
                {
                    "type": "code",
                    "code": "tsconstenumEDirection{Up,Down,Left,Right,}constODirection= {Up:0,Down:1,Left:2,Right:3,}asconst;EDirection.Up;(enum member) EDirection.Up = 0ODirection.Up;(property) Up: 0// Using the enum as a parameterfunctionwalk(dir:EDirection) {}// It requires an extra line to pull out the valuestypeDirection=typeofODirection[keyoftypeofODirection];functionrun(dir:Direction) {}walk(EDirection.Left);run(ODirection.Right);Try"
                },
                {
                    "type": "p",
                    "text": "The biggest argument in favour of this format over TypeScript’senumis that it keeps your codebase aligned with the state of JavaScript, andwhen/ifenums are added to JavaScript then you can move to the additional syntax."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/gulp.html",
            "title": "TypeScript: Documentation - Gulp",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "This quick start guide will teach you how to build TypeScript withgulpand then addBrowserify,terser, orWatchifyto the gulp pipeline.\nThis guide also shows how to addBabelfunctionality usingBabelify. We assume that you’re already usingNode.jswithnpm."
                },
                {
                    "type": "p",
                    "text": "Let’s start out with a new directory.\nWe’ll name itprojfor now, but you can change it to whatever you want."
                },
                {
                    "type": "code",
                    "code": "shellmkdir projcdproj"
                },
                {
                    "type": "p",
                    "text": "To start, we’re going to structure our project in the following way:"
                },
                {
                    "type": "code",
                    "code": "proj/├─ src/└─ dist/"
                },
                {
                    "type": "p",
                    "text": "TypeScript files will start out in yoursrcfolder, run through the TypeScript compiler and end up indist. Let’s scaffold this out:"
                },
                {
                    "type": "code",
                    "code": "shellmkdir srcmkdir dist"
                },
                {
                    "type": "p",
                    "text": "Now we’ll turn this folder into an npm package."
                },
                {
                    "type": "code",
                    "code": "shellnpm init"
                },
                {
                    "type": "p",
                    "text": "You’ll be given a series of prompts.\nYou can use the defaults except for your entry point.\nFor your entry point, use./dist/main.js.\nYou can always go back and change these in thepackage.jsonfile that’s been generated for you."
                },
                {
                    "type": "p",
                    "text": "Now we can usenpm installto install packages.\nFirst installgulp-cliglobally (if you use a Unix system, you may need to prefix thenpm installcommands in this guide withsudo)."
                },
                {
                    "type": "code",
                    "code": "shellnpm install -g gulp-cli"
                },
                {
                    "type": "p",
                    "text": "Then installtypescript,gulpandgulp-typescriptin your project’s dev dependencies.Gulp-typescriptis a gulp plugin for TypeScript."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev typescript gulp@4.0.0 gulp-typescript"
                },
                {
                    "type": "p",
                    "text": "Let’s write a Hello World program.\nInsrc, create the filemain.ts:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionhello(compiler:string) {console.log(`Hello from${compiler}`);}hello(\"TypeScript\");"
                },
                {
                    "type": "p",
                    "text": "In the project root,proj, create the filetsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es5\"}}"
                },
                {
                    "type": "p",
                    "text": "In the project root, create the filegulpfile.js:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varts=require(\"gulp-typescript\");vartsProject=ts.createProject(\"tsconfig.json\");gulp.task(\"default\",function() {returntsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));});"
                },
                {
                    "type": "code",
                    "code": "shellgulpnode dist/main.js"
                },
                {
                    "type": "p",
                    "text": "The program should print “Hello from TypeScript!“."
                },
                {
                    "type": "p",
                    "text": "Before we get to Browserify, let’s build our code out and add modules to the mix.\nThis is the structure you’re more likely to use for a real app. Create a file calledsrc/greet.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionsayHello(name:string) {return`Hello from${name}`;}"
                },
                {
                    "type": "p",
                    "text": "Now change the code insrc/main.tsto importsayHellofromgreet.ts:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"./greet\";console.log(sayHello(\"TypeScript\"));"
                },
                {
                    "type": "p",
                    "text": "Finally, addsrc/greet.tstotsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\",\"src/greet.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es5\"}}"
                },
                {
                    "type": "p",
                    "text": "Make sure that the modules work by runninggulpand then testing in Node:"
                },
                {
                    "type": "code",
                    "code": "shellgulpnode dist/main.js"
                },
                {
                    "type": "p",
                    "text": "Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses.\nWe’ll stick with CommonJS for this tutorial, but you could setmodulein the options object to change this."
                },
                {
                    "type": "p",
                    "text": "Now let’s move this project from Node to the browser.\nTo do this, we’d like to bundle all our modules into one JavaScript file.\nFortunately, that’s exactly what Browserify does.\nEven better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit.\nThat means our TypeScript and Node setup will transfer to the browser basically unchanged. First, install browserify,tsify, and vinyl-source-stream.\ntsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler.\nvinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands calledvinyl."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev browserify tsify vinyl-source-stream"
                },
                {
                    "type": "p",
                    "text": "Create a file insrcnamedindex.html:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><html><head><metacharset=\"UTF-8\"/><title>Hello World!</title></head><body><pid=\"greeting\">Loading ...</p><scriptsrc=\"bundle.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Now changemain.tsto update the page:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"./greet\";functionshowHello(divName:string,name:string) {constelt=document.getElementById(divName);elt.innerText=sayHello(name);}showHello(\"greeting\",\"TypeScript\");"
                },
                {
                    "type": "p",
                    "text": "CallingshowHellocallssayHelloto change the paragraph’s text.\nNow change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");vartsify=require(\"tsify\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).bundle().pipe(source(\"bundle.js\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "This adds thecopy-htmltask and adds it as a dependency ofdefault.\nThat means any timedefaultis run,copy-htmlhas to run first.\nWe’ve also changeddefaultto call Browserify with the tsify plugin instead of gulp-typescript.\nConveniently, they both allow us to pass the same options object to the TypeScript compiler. After callingbundlewe usesource(our alias for vinyl-source-stream) to name our output bundlebundle.js. Test the page by running gulp and then openingdist/index.htmlin a browser.\nYou should see “Hello from TypeScript” on the page. Notice that we specifieddebug: trueto Browserify.\nThis causes tsify to emit source maps inside the bundled JavaScript file.\nSource maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript.\nYou can test that source maps are working by opening the debugger for your browser and putting a breakpoint insidemain.ts.\nWhen you refresh the page the breakpoint should pause the page and let you debuggreet.ts."
                },
                {
                    "type": "p",
                    "text": "Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins."
                },
                {
                    "type": "list",
                    "items": [
                        "Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file.\nThis lets you keep an edit-save-refresh cycle going in the browser.",
                        "Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3.\nThis lets you add extensive and customized transformations that TypeScript doesn’t support.",
                        "Terser compacts your code so that it takes less time to download."
                    ]
                },
                {
                    "type": "p",
                    "text": "We’ll start with Watchify to provide background compilation:"
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev watchify fancy-log"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");varwatchify=require(\"watchify\");vartsify=require(\"tsify\");varfancy_log=require(\"fancy-log\");varpaths= {pages:[\"src/*.html\"],};varwatchedBrowserify=watchify(browserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify));gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});functionbundle() {returnwatchedBrowserify.bundle().on(\"error\",fancy_log).pipe(source(\"bundle.js\")).pipe(gulp.dest(\"dist\"));}gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),bundle));watchedBrowserify.on(\"update\",bundle);watchedBrowserify.on(\"log\",fancy_log);"
                },
                {
                    "type": "p",
                    "text": "There are basically three changes here, but they require you to refactor your code a bit."
                },
                {
                    "type": "list",
                    "items": [
                        "We wrapped ourbrowserifyinstance in a call towatchify, and then held on to the result.",
                        "We calledwatchedBrowserify.on('update', bundle);so that Browserify will run thebundlefunction every time one of your TypeScript files changes.",
                        "We calledwatchedBrowserify.on('log', fancy_log);to log to the console."
                    ]
                },
                {
                    "type": "p",
                    "text": "Together (1) and (2) mean that we have to move our call tobrowserifyout of thedefaulttask.\nAnd we have to give the function fordefaulta name since both Watchify and Gulp need to call it.\nAdding logging with (3) is optional but very useful for debugging your setup. Now when you run Gulp, it should start and stay running.\nTry changing the code forshowHelloinmain.tsand saving it.\nYou should see output that looks like this:"
                },
                {
                    "type": "code",
                    "code": "shellproj$ gulp[10:34:20] Using gulpfile ~/src/proj/gulpfile.js[10:34:20] Starting'copy-html'...[10:34:20] Finished'copy-html'after 26 ms[10:34:20] Starting'default'...[10:34:21] 2824 bytes written (0.13 seconds)[10:34:21] Finished'default'after 1.36 s[10:35:22] 2261 bytes written (0.02 seconds)[10:35:24] 2808 bytes written (0.05 seconds)"
                },
                {
                    "type": "p",
                    "text": "First install Terser.\nSince the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");varterser=require(\"gulp-terser\");vartsify=require(\"tsify\");varsourcemaps=require(\"gulp-sourcemaps\");varbuffer=require(\"vinyl-buffer\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).bundle().pipe(source(\"bundle.js\")).pipe(buffer()).pipe(sourcemaps.init({loadMaps:true})).pipe(terser()).pipe(sourcemaps.write(\"./\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "Notice thatterseritself has just one call — the calls tobufferandsourcemapsexist to make sure sourcemaps keep working.\nThese calls give us a separate sourcemap file instead of using inline sourcemaps like before.\nNow you can run Gulp and check thatbundle.jsdoes get minified into an unreadable mess:"
                },
                {
                    "type": "code",
                    "code": "shellgulpcat dist/bundle.js"
                },
                {
                    "type": "p",
                    "text": "First install Babelify and the Babel preset for ES2015.\nLike Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps.\nBy default Babelify will only process files with extensions of.js,.es,.es6and.jsxso we need to add the.tsextension as an option to Babelify."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");vartsify=require(\"tsify\");varsourcemaps=require(\"gulp-sourcemaps\");varbuffer=require(\"vinyl-buffer\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).transform(\"babelify\", {presets:[\"es2015\"],extensions:[\".ts\"],}).bundle().pipe(source(\"bundle.js\")).pipe(buffer()).pipe(sourcemaps.init({loadMaps:true})).pipe(sourcemaps.write(\"./\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "We also need to have TypeScript target ES2015.\nBabel will then produce ES5 from the ES2015 code that TypeScript emits.\nLet’s modifytsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es2015\"}}"
                },
                {
                    "type": "p",
                    "text": "Babel’s ES5 output should be very similar to TypeScript’s output for such a simple script."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html",
            "title": "TypeScript: Documentation - Integrating with Build Tools",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "code",
                    "code": "shnpm install @babel/cli @babel/core @babel/preset-typescript --save-dev"
                },
                {
                    "type": "code",
                    "code": "js{\"presets\": [\"@babel/preset-typescript\"]}"
                },
                {
                    "type": "code",
                    "code": "sh./node_modules/.bin/babel --out-file bundle.js src/index.ts"
                },
                {
                    "type": "code",
                    "code": "js{\"scripts\": {\"build\":\"babel --out-file bundle.js main.ts\"},}"
                },
                {
                    "type": "code",
                    "code": "shnpm run build"
                },
                {
                    "type": "code",
                    "code": "shnpm install tsify"
                },
                {
                    "type": "code",
                    "code": "shbrowserify main.ts -p [ tsify --noImplicitAny ] > bundle.js"
                },
                {
                    "type": "code",
                    "code": "jsvarbrowserify=require(\"browserify\");vartsify=require(\"tsify\");browserify().add(\"main.ts\").plugin(\"tsify\", {noImplicitAny:true}).bundle().pipe(process.stdout);"
                },
                {
                    "type": "p",
                    "text": "More details:smrq/tsify"
                },
                {
                    "type": "code",
                    "code": "shnpm install grunt-ts --save-dev"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=function(grunt) {grunt.initConfig({ts:{default:{src:[\"**/*.ts\",\"!node_modules/**/*.ts\"],},},});grunt.loadNpmTasks(\"grunt-ts\");grunt.registerTask(\"default\", [\"ts\"]);};"
                },
                {
                    "type": "p",
                    "text": "More details:TypeStrong/grunt-ts"
                },
                {
                    "type": "code",
                    "code": "shnpm install grunt-browserify tsify --save-dev"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=function(grunt) {grunt.initConfig({browserify:{all:{src:\"src/main.ts\",dest:\"dist/main.js\",options:{plugin:[\"tsify\"],},},},});grunt.loadNpmTasks(\"grunt-browserify\");grunt.registerTask(\"default\", [\"browserify\"]);};"
                },
                {
                    "type": "p",
                    "text": "More details:jmreidy/grunt-browserify,TypeStrong/tsify"
                },
                {
                    "type": "code",
                    "code": "shnpm install gulp-typescript"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varts=require(\"gulp-typescript\");gulp.task(\"default\",function() {vartsResult=gulp.src(\"src/*.ts\").pipe(ts({noImplicitAny:true,out:\"output.js\",}));returntsResult.js.pipe(gulp.dest(\"built/local\"));});"
                },
                {
                    "type": "p",
                    "text": "More details:ivogabe/gulp-typescript"
                },
                {
                    "type": "code",
                    "code": "shnpm install -g jspm@beta"
                },
                {
                    "type": "p",
                    "text": "Note: Currently TypeScript support in jspm is in 0.16beta More details:TypeScriptSamples/jspm"
                },
                {
                    "type": "p",
                    "text": "Update project file to include locally installedMicrosoft.TypeScript.Default.props(at the top) andMicrosoft.TypeScript.targets(at the bottom) files:"
                },
                {
                    "type": "code",
                    "code": "xml<?xmlversion=\"1.0\"encoding=\"utf-8\"?><ProjectToolsVersion=\"4.0\"DefaultTargets=\"Build\"xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"><!-- Include default props at the top --><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\"/><!-- TypeScript configurations go here --><PropertyGroupCondition=\"'$(Configuration)' == 'Debug'\"><TypeScriptRemoveComments>false</TypeScriptRemoveComments><TypeScriptSourceMap>true</TypeScriptSourceMap></PropertyGroup><PropertyGroupCondition=\"'$(Configuration)' == 'Release'\"><TypeScriptRemoveComments>true</TypeScriptRemoveComments><TypeScriptSourceMap>false</TypeScriptSourceMap></PropertyGroup><!-- Include default targets at the bottom --><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"/></Project>"
                },
                {
                    "type": "p",
                    "text": "More details about defining MSBuild compiler options:Setting Compiler Options in MSBuild projects"
                },
                {
                    "type": "list",
                    "items": [
                        "Right-Click -> Manage NuGet Packages",
                        "Search forMicrosoft.TypeScript.MSBuild",
                        "HitInstall",
                        "When install is complete, rebuild!"
                    ]
                },
                {
                    "type": "p",
                    "text": "More details can be found atPackage Manager Dialogandusing nightly builds with NuGet"
                },
                {
                    "type": "code",
                    "code": "npm install @rollup/plugin-typescript --save-dev"
                },
                {
                    "type": "p",
                    "text": "Note that bothtypescriptandtslibare peer dependencies of this plugin that need to be installed separately."
                },
                {
                    "type": "p",
                    "text": "Create arollup.config.jsconfiguration fileand import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js// rollup.config.jsimporttypescriptfrom'@rollup/plugin-typescript';exportdefault{input:'src/index.ts',output:{dir:'output',format:'cjs'},plugins:[typescript()]};"
                },
                {
                    "type": "code",
                    "code": "npm install --save-dev svelte-preprocess"
                },
                {
                    "type": "p",
                    "text": "Note thattypescriptis an optional peer dependencies of this plugin and needs to be installed separately.tslibis not provided either. You may also considersvelte-checkfor CLI type checking."
                },
                {
                    "type": "p",
                    "text": "Create asvelte.config.jsconfiguration file and import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js// svelte.config.jsimportpreprocessfrom'svelte-preprocess';constconfig= {// Consult https://github.com/sveltejs/svelte-preprocess// for more information about preprocessorspreprocess:preprocess()};exportdefaultconfig;"
                },
                {
                    "type": "p",
                    "text": "You can now specify that script blocks are written in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "<script lang=\"ts\">"
                },
                {
                    "type": "p",
                    "text": "Vite supports importing.tsfiles out-of-the-box. It only performs transpilation and not type checking. It also requires that somecompilerOptionshave certain values. See theVite docsfor more details."
                },
                {
                    "type": "code",
                    "code": "shnpm install ts-loader --save-dev"
                },
                {
                    "type": "code",
                    "code": "jsconstpath=require('path');module.exports= {entry:'./src/index.ts',module:{rules:[{test:/\\.tsx?$/,use:'ts-loader',exclude:/node_modules/,},],},resolve:{extensions:['.tsx','.ts','.js'],},output:{filename:'bundle.js',path:path.resolve(__dirname,'dist'),},};"
                },
                {
                    "type": "p",
                    "text": "Seemore details on ts-loader here. Alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "awesome-typescript-loader"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/interfaces.html",
            "title": "TypeScript: Handbook - Interfaces",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "p",
                    "text": "One of TypeScript’s core principles is that type checking focuses on theshapethat values have.\nThis is sometimes called “duck typing” or “structural subtyping”.\nIn TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project."
                },
                {
                    "type": "p",
                    "text": "The easiest way to see how interfaces work is to start with a simple example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintLabel(labeledObj: {label:string}) {console.log(labeledObj.label);}letmyObj= {size:10,label:\"Size 10 Object\"};printLabel(myObj);Try"
                },
                {
                    "type": "p",
                    "text": "The type checker checks the call toprintLabel.\nTheprintLabelfunction has a single parameter that requires that the object passed in has a property calledlabelof typestring.\nNotice that our object actually has more properties than this, but the compiler only checks thatat leastthe ones required are present and match the types required.\nThere are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit. We can write the same example again, this time using an interface to describe the requirement of having thelabelproperty that is a string:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceLabeledValue{label:string;}functionprintLabel(labeledObj:LabeledValue) {console.log(labeledObj.label);}letmyObj= {size:10,label:\"Size 10 Object\"};printLabel(myObj);Try"
                },
                {
                    "type": "p",
                    "text": "The interfaceLabeledValueis a name we can now use to describe the requirement in the previous example.\nIt still represents having a single property calledlabelthat is of typestring.\nNotice we didn’t have to explicitly say that the object we pass toprintLabelimplements this interface like we might have to in other languages.\nHere, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed. It’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type."
                },
                {
                    "type": "p",
                    "text": "Not all properties of an interface may be required.\nSome exist under certain conditions or may not be there at all.\nThese optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in. Here’s an example of this pattern:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {letnewSquare= {color:\"white\",area:100};if(config.color) {newSquare.color=config.color;}if(config.width) {newSquare.area=config.width*config.width;}returnnewSquare;}letmySquare=createSquare({color:\"black\"});Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a?at the end of the property name in the declaration. The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface.\nFor example, had we mistyped the name of thecolorproperty increateSquare, we would get an error message letting us know:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {letnewSquare= {color:\"white\",area:100};if(config.clor) {Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?// Error: Property 'clor' does not exist on type 'SquareConfig'newSquare.color=config.clor;Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?}if(config.width) {newSquare.area=config.width*config.width;}returnnewSquare;}letmySquare=createSquare({color:\"black\"});Try"
                },
                {
                    "type": "p",
                    "text": "Some properties should only be modifiable when an object is first created.\nYou can specify this by puttingreadonlybefore the name of the property:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePoint{readonlyx:number;readonlyy:number;}Try"
                },
                {
                    "type": "p",
                    "text": "You can construct aPointby assigning an object literal.\nAfter the assignment,xandycan’t be changed."
                },
                {
                    "type": "code",
                    "code": "tsletp1:Point= {x:10,y:20};p1.x=5;// error!Cannot assign to 'x' because it is a read-only property.2540Cannot assign to 'x' because it is a read-only property.Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript comes with aReadonlyArray<T>type that is the same asArray<T>with all mutating methods removed, so you can make sure you don’t change your arrays after creation:"
                },
                {
                    "type": "code",
                    "code": "tsleta:number[] = [1,2,3,4];letro:ReadonlyArray<number> =a;ro[0] =12;// error!Index signature in type 'readonly number[]' only permits reading.2542Index signature in type 'readonly number[]' only permits reading.ro.push(5);// error!Property 'push' does not exist on type 'readonly number[]'.2339Property 'push' does not exist on type 'readonly number[]'.ro.length=100;// error!Cannot assign to 'length' because it is a read-only property.2540Cannot assign to 'length' because it is a read-only property.a=ro;// error!The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.4104The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.Try"
                },
                {
                    "type": "p",
                    "text": "On the last line of the snippet you can see that even assigning the entireReadonlyArrayback to a normal array is illegal.\nYou can still override it with a type assertion, though:"
                },
                {
                    "type": "code",
                    "code": "tsleta:number[] = [1,2,3,4];letro:ReadonlyArray<number> =a;a=roasnumber[];Try"
                },
                {
                    "type": "p",
                    "text": "The easiest way to remember whether to usereadonlyorconstis to ask whether you’re using it on a variable or a property.\nVariables useconstwhereas properties usereadonly."
                },
                {
                    "type": "p",
                    "text": "In our first example using interfaces, TypeScript lets us pass{ size: number; label: string; }to something that only expected a{ label: string; }.\nWe also just learned about optional properties, and how they’re useful when describing so-called “option bags”. However, combining the two naively would allow an error to sneak in. For example, taking our last example usingcreateSquare:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {return{color:config.color||\"red\",area:config.width?config.width*config.width:20,};}letmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Notice the given argument tocreateSquareis spelledcolourinstead ofcolor.\nIn plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since thewidthproperties are compatible, there’s nocolorproperty present, and the extracolourproperty is insignificant. However, TypeScript takes the stance that there’s probably a bug in this code.\nObject literals get special treatment and undergoexcess property checkingwhen assigning them to other variables, or passing them as arguments.\nIf an object literal has any properties that the “target type” doesn’t have, you’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Getting around these checks is actually really simple.\nThe easiest method is to just use a type assertion:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({width:100,opacity:0.5}asSquareConfig);Try"
                },
                {
                    "type": "p",
                    "text": "However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way.\nIfSquareConfigcan havecolorandwidthproperties with the above types, but couldalsohave any number of other properties, then we could define it like so:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;[propName:string]:any;}Try"
                },
                {
                    "type": "p",
                    "text": "We’ll discuss index signatures in a bit, but here we’re saying aSquareConfigcan have any number of properties, and as long as they aren’tcolororwidth, their types don’t matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable:\nSincesquareOptionswon’t undergo excess property checks, the compiler won’t give you an error."
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\",width:100};letmySquare=createSquare(squareOptions);Try"
                },
                {
                    "type": "p",
                    "text": "The above workaround will work as long as you have a common property betweensquareOptionsandSquareConfig.\nIn this example, it was the propertywidth. It will however, fail if the variable does not have any common object property. For example:"
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\"};letmySquare=createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks.\nFor more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations.\nIn this instance, if it’s okay to pass an object with both acolororcolourproperty tocreateSquare, you should fix up the definition ofSquareConfigto reflect that."
                },
                {
                    "type": "p",
                    "text": "Interfaces are capable of describing the wide range of shapes that JavaScript objects can take.\nIn addition to describing an object with properties, interfaces are also capable of describing function types. To describe a function type with an interface, we give the interface a call signature.\nThis is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSearchFunc{(source:string,subString:string):boolean;}Try"
                },
                {
                    "type": "p",
                    "text": "Once defined, we can use this function type interface like we would other interfaces.\nHere, we show how you can create a variable of a function type and assign it a function value of the same type."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(source:string,subString:string):boolean{letresult=source.search(subString);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "For function types to correctly type check, the names of the parameters do not need to match.\nWe could have, for example, written the above example like this:"
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src:string,sub:string):boolean{letresult=src.search(sub);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other.\nIf you do not want to specify types at all, TypeScript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of typeSearchFunc.\nHere, also, the return type of our function expression is implied by the values it returns (herefalseandtrue)."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src,sub) {letresult=src.search(sub);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn’t match the return type described in theSearchFuncinterface."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src,sub) {Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.2322Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.letresult=src.search(sub);return\"string\";};Try"
                },
                {
                    "type": "p",
                    "text": "Similarly to how we can use interfaces to describe function types, we can also describe types that we can “index into” likea[10], orageMap[\"daniel\"].\nIndexable types have anindex signaturethat describes the types we can use to index into the object, along with the corresponding return types when indexing. Let’s take an example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringArray{[index:number]:string;}letmyArray:StringArray;myArray= [\"Bob\",\"Fred\"];letmyStr:string=myArray[0];Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have aStringArrayinterface that has an index signature.\nThis index signature states that when aStringArrayis indexed with anumber, it will return astring. There are four types of supported index signatures: string, number, symbol and template strings.\nIt is possible to support many types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with anumber, JavaScript will actually convert that to astringbefore indexing into an object.\nThat means that indexing with100(anumber) is the same thing as indexing with\"100\"(astring), so the two need to be consistent."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimal{name:string;}interfaceDogextendsAnimal{breed:string;}// Error: indexing with a numeric string might get you a completely separate type of Animal!interfaceNotOkay{[x:number]:Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.[x:string]:Dog;}Try"
                },
                {
                    "type": "p",
                    "text": "While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type.\nThis is because a string index declares thatobj.propertyis also available asobj[\"property\"].\nIn the following example,name’s type does not match the string index’s type, and the type checker gives an error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberDictionary{[index:string]:number;length:number;// ok, length is a numbername:string;// error, the type of 'name' is not a subtype of the indexerProperty 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "However, properties of different types are acceptable if the index signature is a union of the property types:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberOrStringDictionary{[index:string]:number|string;length:number;// ok, length is a numbername:string;// ok, name is a string}Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can make index signaturesreadonlyin order to prevent assignment to their indices:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceReadonlyStringArray{readonly[index:number]:string;}letmyArray:ReadonlyStringArray= [\"Alice\",\"Bob\"];myArray[2] =\"Mallory\";// error!Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try"
                },
                {
                    "type": "p",
                    "text": "You can’t setmyArray[2]because the index signature isreadonly."
                },
                {
                    "type": "p",
                    "text": "A template string can be used to indicate that a particular pattern is allowed, but not all. For example, a HTTP headers object may have a set list of known headers and support anycustom defined propertieswhich are prefixed withx-."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceHeadersResponse{\"content-type\":string,date:string,\"content-length\":string// Permit any property starting with 'x-'.[headerName:`x-${string}`]:string;}functionhandleResponse(r:HeadersResponse) {// Handle known, and x- prefixedconsttype=r[\"content-type\"]constpoweredBy=r[\"x-powered-by\"]// Unknown keys without the prefix raise errorsconstorigin=r.originProperty 'origin' does not exist on type 'HeadersResponse'.2339Property 'origin' does not exist on type 'HeadersResponse'.}Try"
                },
                {
                    "type": "p",
                    "text": "One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockInterface{currentTime:Date;}classClockimplementsClockInterface{currentTime:Date=newDate();constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "You can also describe methods in an interface that are implemented in the class, as we do withsetTimein the below example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockInterface{currentTime:Date;setTime(d:Date):void;}classClockimplementsClockInterface{currentTime:Date=newDate();setTime(d:Date) {this.currentTime=d;}constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces describe the public side of the class, rather than both the public and private side.\nThis prohibits you from using them to check that a class also has particular types for the private side of the class instance."
                },
                {
                    "type": "p",
                    "text": "When working with classes and interfaces, it helps to keep in mind that a class hastwotypes: the type of the static side and the type of the instance side.\nYou may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number);}classClockimplementsClockConstructor{Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.2420Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.currentTime:Date;constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "This is because when a class implements an interface, only the instance side of the class is checked.\nSince the constructor sits in the static side, it is not included in this check. Instead, you would need to work with the static side of the class directly.\nIn this example, we define two interfaces,ClockConstructorfor the constructor andClockInterfacefor the instance methods.\nThen, for convenience, we define a constructor functioncreateClockthat creates instances of the type that is passed to it:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number):ClockInterface;}interfaceClockInterface{tick():void;}functioncreateClock(ctor:ClockConstructor,hour:number,minute:number):ClockInterface{returnnewctor(hour,minute);}classDigitalClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"beep beep\");}}classAnalogClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"tick tock\");}}letdigital=createClock(DigitalClock,12,17);letanalog=createClock(AnalogClock,7,32);Try"
                },
                {
                    "type": "p",
                    "text": "BecausecreateClock’s first parameter is of typeClockConstructor, increateClock(AnalogClock, 7, 32), it checks thatAnalogClockhas the correct constructor signature. Another simple way is to use class expressions:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number):ClockInterface;}interfaceClockInterface{tick():void;}constClock:ClockConstructor=classClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"beep beep\");}};letclock=newClock(12,17);clock.tick();Try"
                },
                {
                    "type": "p",
                    "text": "Like classes, interfaces can extend each other.\nThis allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceShape{color:string;}interfaceSquareextendsShape{sideLength:number;}letsquare= {}asSquare;square.color=\"blue\";square.sideLength=10;Try"
                },
                {
                    "type": "p",
                    "text": "An interface can extend multiple interfaces, creating a combination of all of the interfaces."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceShape{color:string;}interfacePenStroke{penWidth:number;}interfaceSquareextendsShape,PenStroke{sideLength:number;}letsquare= {}asSquare;square.color=\"blue\";square.sideLength=10;square.penWidth=5.0;Try"
                },
                {
                    "type": "p",
                    "text": "As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript.\nBecause of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above. One such example is an object that acts as both a function and an object, with additional properties:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCounter{(start:number):string;interval:number;reset():void;}functiongetCounter():Counter{letcounter=function(start:number) {}asCounter;counter.interval=123;counter.reset=function() {};returncounter;}letc=getCounter();c(10);c.reset();c.interval=5.0;Try"
                },
                {
                    "type": "p",
                    "text": "When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type."
                },
                {
                    "type": "p",
                    "text": "When an interface type extends a class type it inherits the members of the class but not their implementations.\nIt is as if the interface had declared all of the members of the class without providing an implementation.\nInterfaces inherit even the private and protected members of a base class.\nThis means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties.\nThe subclasses don’t have to be related besides inheriting from the base class.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsclassControl{privatestate:any;}interfaceSelectableControlextendsControl{select():void;}classButtonextendsControlimplementsSelectableControl{select() {}}classTextBoxextendsControl{select() {}}classImageControlimplementsSelectableControl{Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.2420Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.privatestate:any;select() {}}Try"
                },
                {
                    "type": "p",
                    "text": "In the above example,SelectableControlcontains all of the members ofControl, including the privatestateproperty.\nSincestateis a private member it is only possible for descendants ofControlto implementSelectableControl.\nThis is because only descendants ofControlwill have astateprivate member that originates in the same declaration, which is a requirement for private members to be compatible. Within theControlclass it is possible to access thestateprivate member through an instance ofSelectableControl.\nEffectively, aSelectableControlacts like aControlthat is known to have aselectmethod.\nTheButtonandTextBoxclasses are subtypes ofSelectableControl(because they both inherit fromControland have aselectmethod). TheImageControlclass has its ownstateprivate member rather than extendingControl, so it cannot implementSelectableControl."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html",
            "title": "TypeScript: Documentation - JS Projects Utilizing TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The type system in TypeScript has different levels of strictness when working with a codebase:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type-system based only on inference with JavaScript code",
                        "Incremental typing in JavaScriptvia JSDoc",
                        "Using// @ts-checkin a JavaScript file",
                        "TypeScript code",
                        "TypeScript withstrictenabled"
                    ]
                },
                {
                    "type": "p",
                    "text": "Each step represents a move towards a safer type-system, but not every project needs that level of verification."
                },
                {
                    "type": "p",
                    "text": "This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename.\nThehomepagehas a list of editors which have TypeScript plugins."
                },
                {
                    "type": "p",
                    "text": "In a.jsfile, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax. JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{number}*/varx;x=0;// OKx=false;// OK?!Try"
                },
                {
                    "type": "p",
                    "text": "You can find the full list of supported JSDoc patternsin JSDoc Supported Types."
                },
                {
                    "type": "p",
                    "text": "The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project.\nTo enable errors in your JavaScript files add:// @ts-checkto the first line in your.jsfiles to have TypeScript raise it as an error."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@type{number}*/varx;x=0;// OKx=false;// Not OKType 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "If you have a lot of JavaScript files you want to add errors to then you can switch to using ajsconfig.json.\nYou can skip checking some files by adding a// @ts-nocheckcomment to files. TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding// @ts-ignoreor// @ts-expect-erroron the preceding line."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@type{number}*/varx;x=0;// OK// @ts-expect-errorx=false;// Not OKTry"
                },
                {
                    "type": "p",
                    "text": "To learn more about how JavaScript is interpreted by TypeScript readHow TS Type Checks JS"
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro.html",
            "title": "TypeScript: Handbook - The TypeScript Handbook",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale. The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked). If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either theMicrosoft Learn JavaScript tutorialor readJavaScript at the Mozilla Web Docs.\nIf you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook."
                },
                {
                    "type": "p",
                    "text": "The handbook is split into two sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "The HandbookThe TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.A reader who completes the walkthrough should be able to:Read and understand commonly-used TypeScript syntax and patternsExplain the effects of important compiler optionsCorrectly predict type system behavior in most casesIn the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.",
                        "Read and understand commonly-used TypeScript syntax and patterns",
                        "Explain the effects of important compiler options",
                        "Correctly predict type system behavior in most cases",
                        "Reference FilesThe reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity."
                    ]
                },
                {
                    "type": "p",
                    "text": "The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short. Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts. The Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet. Finally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web."
                },
                {
                    "type": "p",
                    "text": "Before getting started withThe Basics, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages."
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript for the New Programmer",
                        "TypeScript for JavaScript Programmers",
                        "TypeScript for Java/C# Programmers",
                        "TypeScript for Functional Programmers"
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise, jump toThe Basics."
                },
                {
                    "type": "p",
                    "text": "Step one in learning TypeScript: The basic types."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html",
            "title": "TypeScript: Documentation - Iterators and Generators",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "An object is deemed iterable if it has an implementation for theSymbol.iteratorproperty.\nSome built-in types likeArray,Map,Set,String,Int32Array,Uint32Array, etc. have theirSymbol.iteratorproperty already implemented.Symbol.iteratorfunction on an object is responsible for returning the list of values to iterate on."
                },
                {
                    "type": "p",
                    "text": "Iterableis a type we can use if we want to take in types listed above which are iterable. Here is an example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoArray<X>(xs:Iterable<X>):X[] {return[...xs]}"
                },
                {
                    "type": "p",
                    "text": "for..ofloops over an iterable object, invoking theSymbol.iteratorproperty on the object.\nHere is a simplefor..ofloop on an array:"
                },
                {
                    "type": "code",
                    "code": "tsletsomeArray= [1,\"string\",false];for(letentryofsomeArray) {console.log(entry);// 1, \"string\", false}"
                },
                {
                    "type": "p",
                    "text": "Bothfor..ofandfor..instatements iterate over lists; the values iterated on are different though,for..inreturns a list ofkeyson the object being iterated, whereasfor..ofreturns a list ofvaluesof the numeric properties of the object being iterated. Here is an example that demonstrates this distinction:"
                },
                {
                    "type": "code",
                    "code": "tsletlist= [4,5,6];for(letiinlist) {console.log(i);// \"0\", \"1\", \"2\",}for(letioflist) {console.log(i);// 4, 5, 6}"
                },
                {
                    "type": "p",
                    "text": "Another distinction is thatfor..inoperates on any object; it serves as a way to inspect properties on this object.for..ofon the other hand, is mainly interested in values of iterable objects. Built-in objects likeMapandSetimplementSymbol.iteratorproperty allowing access to stored values."
                },
                {
                    "type": "code",
                    "code": "tsletpets=newSet([\"Cat\",\"Dog\",\"Hamster\"]);pets[\"species\"] =\"mammals\";for(letpetinpets) {console.log(pet);// \"species\"}for(letpetofpets) {console.log(pet);// \"Cat\", \"Dog\", \"Hamster\"}"
                },
                {
                    "type": "p",
                    "text": "When targeting an ES5-compliant engine, iterators are only allowed on values ofArraytype.\nIt is an error to usefor..ofloops on non-Array values, even if these non-Array values implement theSymbol.iteratorproperty. The compiler will generate a simpleforloop for afor..ofloop, for instance:"
                },
                {
                    "type": "code",
                    "code": "tsletnumbers= [1,2,3];for(letnumofnumbers) {console.log(num);}"
                },
                {
                    "type": "p",
                    "text": "will be generated as:"
                },
                {
                    "type": "code",
                    "code": "jsvarnumbers= [1,2,3];for(var_i=0;_i<numbers.length;_i++) {varnum=numbers[_i];console.log(num);}"
                },
                {
                    "type": "p",
                    "text": "When targeting an ECMAScript 2015-compliant engine, the compiler will generatefor..ofloops to target the built-in iterator implementation in the engine."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
            "title": "TypeScript: Documentation - JSDoc Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The list below outlines which constructs are currently supported\nwhen using JSDoc annotations to provide type information in JavaScript files. Note:"
                },
                {
                    "type": "list",
                    "items": [
                        "Any tags which are not explicitly listed below (such as@async) are not yet supported.",
                        "Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "@type",
                        "@param(or@argor@argument)",
                        "@returns(or@return)",
                        "@typedef",
                        "@callback",
                        "@template",
                        "@satisfies"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Property Modifiers@public,@private,@protected,@readonly",
                        "@override",
                        "@extends(or@augments)",
                        "@implements",
                        "@class(or@constructor)",
                        "@this"
                    ]
                },
                {
                    "type": "p",
                    "text": "Documentation tags work in both TypeScript and JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "@deprecated",
                        "@see",
                        "@link"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "@enum",
                        "@author",
                        "Other supported patterns",
                        "Unsupported patterns",
                        "Unsupported tags"
                    ]
                },
                {
                    "type": "p",
                    "text": "The meaning is usually the same, or a superset, of the meaning of the tag given atjsdoc.app.\nThe code below describes the differences and gives some example usage of each tag. Note:You can usethe playground to explore JSDoc support."
                },
                {
                    "type": "p",
                    "text": "You can reference types with the “@type” tag. The type can be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Primitive, likestringornumber.",
                        "Declared in a TypeScript declaration, either global or imported.",
                        "Declared in a JSDoc@typedeftag."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use most JSDoc type syntax and any TypeScript syntax, fromthe most basic likestringtothe most advanced, like conditional types."
                },
                {
                    "type": "code",
                    "code": "js/***@type{string}*/vars;/**@type{Window}*/varwin;/**@type{PromiseLike<string>}*/varpromisedString;// You can specify an HTML Element with DOM properties/**@type{HTMLElement}*/varmyElement=document.querySelector(selector);element.dataset.myData=\"\";Try"
                },
                {
                    "type": "p",
                    "text": "@typecan specify a union type — for example, something can be either a string or a boolean."
                },
                {
                    "type": "code",
                    "code": "js/***@type{string | boolean}*/varsb;Try"
                },
                {
                    "type": "p",
                    "text": "You can specify array types using a variety of syntaxes:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{number[]}*/varns;/**@type{Array.<number>}*/varjsdoc;/**@type{Array<number>}*/varnas;Try"
                },
                {
                    "type": "p",
                    "text": "You can also specify object literal types.\nFor example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{{ a: string, b: number }}*/varvar9;Try"
                },
                {
                    "type": "p",
                    "text": "You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax."
                },
                {
                    "type": "code",
                    "code": "js/*** A map-like object that maps arbitrary `string` properties to `number`s.**@type{Object.<string, number>}*/varstringToNumber;/**@type{Object.<number, object>}*/vararrayLike;Try"
                },
                {
                    "type": "p",
                    "text": "The preceding two types are equivalent to the TypeScript types{ [x: string]: number }and{ [x: number]: any }. The compiler understands both syntaxes. You can specify function types using either TypeScript or Google Closure syntax:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{function(string, boolean): number}Closure syntax */varsbn;/**@type{(s: string, b: boolean) => number}TypeScript syntax */varsbn2;Try"
                },
                {
                    "type": "p",
                    "text": "Or you can just use the unspecifiedFunctiontype:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{Function}*/varfn7;/**@type{function}*/varfn6;Try"
                },
                {
                    "type": "p",
                    "text": "Other types from Closure also work:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{*}- can be 'any' type*/varstar;/***@type{?}- unknown type (same as 'any')*/varquestion;Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript borrows cast syntax from Google Closure.\nThis lets you cast types to other types by adding a@typetag before any parenthesized expression."
                },
                {
                    "type": "code",
                    "code": "js/***@type{number | string}*/varnumberOrString=Math.random() <0.5?\"hello\":100;vartypeAssertedNumber=/**@type{number}*/(numberOrString);Try"
                },
                {
                    "type": "p",
                    "text": "You can even cast toconstjust like TypeScript:"
                },
                {
                    "type": "code",
                    "code": "jsletone=/**@type{const}*/(1);Try"
                },
                {
                    "type": "p",
                    "text": "You can import declarations from other files using import types.\nThis syntax is TypeScript-specific and differs from the JSDoc standard:"
                },
                {
                    "type": "code",
                    "code": "js// @filename: types.d.tsexporttypePet= {name:string,};// @filename: main.js/***@param{import(\"./types\").Pet}p*/functionwalk(p) {console.log(`Walking${p.name}...`);}Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used in type alias declarations:"
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{import(\"./types\").Pet}Pet*//***@type{Pet}*/varmyPet;myPet.name;Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{typeof import(\"./accounts\").userAccount}*/varx=require(\"./accounts\").userAccount;Try"
                },
                {
                    "type": "p",
                    "text": "@paramuses the same type syntax as@type, but adds a parameter name.\nThe parameter may also be declared optional by surrounding the name with square brackets:"
                },
                {
                    "type": "code",
                    "code": "js// Parameters may be declared in a variety of syntactic forms/***@param{string}p1- A string param.*@param{string=}p2- An optional param (Google Closure syntax)*@param{string}[p3]- Another optional param (JSDoc syntax).*@param{string}[p4=\"test\"]- An optional param with a default value*@returns{string}This is the result*/functionstringsStringStrings(p1,p2,p3,p4) {// TODO}Try"
                },
                {
                    "type": "p",
                    "text": "Likewise, for the return type of a function:"
                },
                {
                    "type": "code",
                    "code": "js/***@return{PromiseLike<string>}*/functionps() {}/***@returns{{ a: string, b: number }}- May use '@returns' as well as '@return'*/functionab() {}Try"
                },
                {
                    "type": "p",
                    "text": "You can define complex types with@typedef.\nSimilar syntax works with@param."
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{Object}SpecialType- creates a new type named 'SpecialType'*@property{string}prop1- a string property of SpecialType*@property{number}prop2- a number property of SpecialType*@property{number=}prop3- an optional number property of SpecialType*@prop{number}[prop4]- an optional number property of SpecialType*@prop{number}[prop5=42]- an optional number property of SpecialType with default*//**@type{SpecialType}*/varspecialTypeObject;specialTypeObject.prop3;Try"
                },
                {
                    "type": "p",
                    "text": "You can use eitherobjectorObjecton the first line."
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{object}SpecialType1- creates a new type named 'SpecialType1'*@property{string}prop1- a string property of SpecialType1*@property{number}prop2- a number property of SpecialType1*@property{number=}prop3- an optional number property of SpecialType1*//**@type{SpecialType1}*/varspecialTypeObject1;Try"
                },
                {
                    "type": "p",
                    "text": "@paramallows a similar syntax for one-off type specifications.\nNote that the nested property names must be prefixed with the name of the parameter:"
                },
                {
                    "type": "code",
                    "code": "js/***@param{Object}options- The shape is the same as SpecialType above*@param{string}options.prop1*@param{number}options.prop2*@param{number=}options.prop3*@param{number}[options.prop4]*@param{number}[options.prop5=42]*/functionspecial(options) {return(options.prop4||1001) +options.prop5;}Try"
                },
                {
                    "type": "p",
                    "text": "@callbackis similar to@typedef, but it specifies a function type instead of an object type:"
                },
                {
                    "type": "code",
                    "code": "js/***@callbackPredicate*@param{string}data*@param{number}[index]*@returns{boolean}*//**@type{Predicate}*/constok= (s)=>!(s.length%2);Try"
                },
                {
                    "type": "p",
                    "text": "Of course, any of these types can be declared using TypeScript syntax in a single-line@typedef:"
                },
                {
                    "type": "code",
                    "code": "js/**@typedef{{ prop1: string, prop2: string, prop3?: number }}SpecialType*//**@typedef{(data: string, index?: number) => boolean}Predicate*/"
                },
                {
                    "type": "p",
                    "text": "You can declare type parameters with the@templatetag.\nThis lets you make functions, classes, or types that are generic:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT*@param{T}x- A generic parameter that flows through to the return type*@returns{T}*/functionid(x) {returnx;}consta=id(\"string\");constb=id(123);constc=id({});Try"
                },
                {
                    "type": "p",
                    "text": "Use comma or multiple tags to declare multiple type parameters:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT,U,V*@templateW,X*/"
                },
                {
                    "type": "p",
                    "text": "You can also specify a type constraint before the type parameter name.\nOnly the first type parameter in a list is constrained:"
                },
                {
                    "type": "code",
                    "code": "js/***@template{string}K- K must be a string or string literal*@template{{ serious(): string }}Seriousalizable- must have a serious method*@param{K}key*@param{Seriousalizable}object*/functionseriousalize(key,object) {// ????}Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can specify a default for a type parameter:"
                },
                {
                    "type": "code",
                    "code": "js/**@template[T=object] */classCache{/**@param{T}initial*/constructor(initial) {}}letc=newCache()Try"
                },
                {
                    "type": "p",
                    "text": "@satisfiesprovides access to the postfixoperatorsatisfiesin TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/***@typedef{\"hello world\" | \"Hello, world\"}WelcomeMessage*//**@satisfies{WelcomeMessage} */constmessage=\"hello world\"const message: \"hello world\"/**@satisfies{WelcomeMessage} */Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.1360Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.constfailingMessage=\"Hello world!\"/**@type{WelcomeMessage}*/constmessageUsingType=\"hello world\"const messageUsingType: WelcomeMessageTry"
                },
                {
                    "type": "p",
                    "text": "Classes can be declared as ES6 classes."
                },
                {
                    "type": "code",
                    "code": "jsclassC{/***@param{number}data*/constructor(data) {// property types can be inferredthis.name=\"foo\";// or set explicitly/**@type{string | null}*/this.title=null;// or simply annotated, if they're set elsewhere/**@type{number}*/this.size;this.initialize(data);// Should error, initializer expects a string}/***@param{string}s*/initialize=function(s) {this.size=s.length;};}varc=newC(0);// C should only be called with new, but// because it is JavaScript, this is allowed and// considered an 'any'.varresult=C(1);Try"
                },
                {
                    "type": "p",
                    "text": "They can also be declared as constructor functions; use@constructoralong with@thisfor this."
                },
                {
                    "type": "p",
                    "text": "@public,@private, and@protectedwork exactly likepublic,private, andprotectedin TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkclassCar{constructor() {/**@private*/this.identifier=100;}printIdentifier() {console.log(this.identifier);}}constc=newCar();console.log(c.identifier);Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.Try"
                },
                {
                    "type": "list",
                    "items": [
                        "@publicis always implied and can be left off, but means that a property can be reached from anywhere.",
                        "@privatemeans that a property can only be used within the containing class.",
                        "@protectedmeans that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class."
                    ]
                },
                {
                    "type": "p",
                    "text": "@public,@private, and@protecteddo not work in constructor functions."
                },
                {
                    "type": "p",
                    "text": "The@readonlymodifier ensures that a property is only ever written to during initialization."
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkclassCar{constructor() {/**@readonly*/this.identifier=100;}printIdentifier() {console.log(this.identifier);}}constc=newCar();console.log(c.identifier);Try"
                },
                {
                    "type": "p",
                    "text": "@overrideworks the same way as in TypeScript; use it on methods that override a method from a base class:"
                },
                {
                    "type": "code",
                    "code": "jsexportclassC{m() { }}classDextendsC{/**@override*/m() { }}Try"
                },
                {
                    "type": "p",
                    "text": "SetnoImplicitOverride: truein tsconfig to check overrides."
                },
                {
                    "type": "p",
                    "text": "When JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The@extendstag allows this:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT*@extends{Set<T>}*/classSortableSetextendsSet{// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Note that@extendsonly works with classes. Currently, there is no way for a constructor function to extend a class."
                },
                {
                    "type": "p",
                    "text": "In the same way, there is no JavaScript syntax for implementing a TypeScript interface. The@implementstag works just like in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js/**@implements{Print}*/classTextBook{print() {// TODO}}Try"
                },
                {
                    "type": "p",
                    "text": "The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a@constructortag:"
                },
                {
                    "type": "code",
                    "code": "js/***@constructor*@param{number}data*/functionC(data) {// property types can be inferredthis.name=\"foo\";// or set explicitly/**@type{string | null}*/this.title=null;// or simply annotated, if they're set elsewhere/**@type{number}*/this.size;this.initialize(data);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.}/***@param{string}s*/C.prototype.initialize=function(s) {this.size=s.length;};varc=newC(0);c.size;varresult=C(1);Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?Try"
                },
                {
                    "type": "p",
                    "text": "Note: Error messages only show up in JS codebases witha JSConfigandcheckJsenabled."
                },
                {
                    "type": "p",
                    "text": "With@constructor,thisis checked inside the constructor functionC, so you will get suggestions for theinitializemethod and an error if you pass it a number. Your editor may also show warnings if you callCinstead of constructing it. Unfortunately, this means that constructor functions that are also callable cannot use@constructor."
                },
                {
                    "type": "p",
                    "text": "The compiler can usually figure out the type ofthiswhen it has some context to work with. When it doesn’t, you can explicitly specify the type ofthiswith@this:"
                },
                {
                    "type": "code",
                    "code": "js/***@this{HTMLElement}*@param{*}e*/functioncallbackForLater(e) {this.clientHeight=parseInt(e);// should be fine!}Try"
                },
                {
                    "type": "p",
                    "text": "When a function, method, or property is deprecated you can let users know by marking it with a/** @deprecated */JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through stylelike this."
                },
                {
                    "type": "code",
                    "code": "js/**@deprecated*/constapiV1= {};constapiV2= {};apiV;apiV1apiV2Try"
                },
                {
                    "type": "p",
                    "text": "@seelets you link to other names in your program:"
                },
                {
                    "type": "code",
                    "code": "tstypeBox<T> = {t:T}/**@seeBoxfor implementation details */typeBoxify<T> = { [KinkeyofT]:Box<T> };Try"
                },
                {
                    "type": "p",
                    "text": "Some editors will turnBoxinto a link to make it easy to jump there and back."
                },
                {
                    "type": "p",
                    "text": "@linkis like@see, except that it can be used inside other tags:"
                },
                {
                    "type": "code",
                    "code": "tstypeBox<T> = {t:T}/**@returnsA{@linkBox}containing the parameter. */functionbox<U>(u:U):Box<U> {return{t:u};}Try"
                },
                {
                    "type": "p",
                    "text": "You can also link a property:"
                },
                {
                    "type": "code",
                    "code": "tstypePet= {name:stringhello: ()=>string}/*** Note: you should implement the{@linkPet.hello}method of Pet.*/functionhello(p:Pet) {p.hello()}Try"
                },
                {
                    "type": "p",
                    "text": "Or with an optional name:"
                },
                {
                    "type": "code",
                    "code": "tstypePet= {name:stringhello: ()=>string}/*** Note: you should implement the{@linkPet.hello| hello}method of Pet.*/functionhello(p:Pet) {p.hello()}Try"
                },
                {
                    "type": "p",
                    "text": "The@enumtag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members.@enumis intended for compatibility with Google Closure’s@enumtag."
                },
                {
                    "type": "code",
                    "code": "js/**@enum{number}*/constJSDocState= {BeginningOfLine:0,SawAsterisk:1,SavingComments:2,};JSDocState.SawAsterisk;Try"
                },
                {
                    "type": "p",
                    "text": "Note that@enumis quite different from, and much simpler than, TypeScript’senum. However, unlike TypeScript’s enums,@enumcan have any type:"
                },
                {
                    "type": "code",
                    "code": "js/**@enum{function(number): number}*/constMathFuncs= {add1:(n)=>n+1,id:(n)=>-n,sub1:(n)=>n-1,};MathFuncs.add1;Try"
                },
                {
                    "type": "p",
                    "text": "You can specify the author of an item with@author:"
                },
                {
                    "type": "code",
                    "code": "ts/*** Welcome to awesome.ts*@authorIan Awesome<i.am.awesome@example.com>*/Try"
                },
                {
                    "type": "p",
                    "text": "Remember to surround the email address with angle brackets.\nOtherwise,@examplewill be parsed as a new tag."
                },
                {
                    "type": "code",
                    "code": "jsvarsomeObj= {/***@param{string}param1- JSDocs on property assignments work*/x:function(param1) {},};/*** As do jsdocs on variable assignments*@return{Window}*/letsomeFunc=function() {};/*** And class methods*@param{string}greetingThe greeting to use*/Foo.prototype.sayHi= (greeting)=>console.log(\"Hi!\");/*** And arrow function expressions*@param{number}x- A multiplier*/letmyArrow= (x)=>x*x;/*** Which means it works for function components in JSX too*@param{{a: string, b: number}}props- Some param*/varfc= (props)=><div>{props.a.charAt(0)}</div>;/*** A parameter can be a class constructor, using Google Closure syntax.**@param{{new(...args: any[]): object}}C- The class to register*/functionregisterClass(C) {}/***@param{...string}p1- A 'rest' arg (array) of strings. (treated as 'any')*/functionfn10(p1) {}/***@param{...string}p1- A 'rest' arg (array) of strings. (treated as 'any')*/functionfn9(p1) {returnp1.join();}Try"
                },
                {
                    "type": "p",
                    "text": "Postfix equals on a property type in an object literal type doesn’t specify an optional property:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{{ a: string, b: number= }}*/varwrong;/*** Use postfix question on the property name instead:*@type{{ a: string, b?: number }}*/varright;Try"
                },
                {
                    "type": "p",
                    "text": "Nullable types only have meaning ifstrictNullChecksis on:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{?number}* With strictNullChecks: true  -- number | null* With strictNullChecks: false -- number*/varnullable;Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript-native syntax is a union type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{number | null}* With strictNullChecks: true  -- number | null* With strictNullChecks: false -- number*/varunionNullable;Try"
                },
                {
                    "type": "p",
                    "text": "Non-nullable types have no meaning and are treated just as their original type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{!number}* Just has type number*/varnormal;Try"
                },
                {
                    "type": "p",
                    "text": "Unlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not.\nThere is no explicit non-nullability — if strictNullChecks is on, thennumberis not nullable.\nIf it is off, thennumberis nullable."
                },
                {
                    "type": "p",
                    "text": "TypeScript ignores any unsupported JSDoc tags. The following tags have open issues to support them:"
                },
                {
                    "type": "list",
                    "items": [
                        "@memberof(issue #7237)",
                        "@yields(issue #23857)",
                        "@member(issue #56674)"
                    ]
                },
                {
                    "type": "p",
                    "text": "A number of common types are given aliases for compatibility with old JavaScript code.\nSome of the aliases are the same as existing types, although most of those are rarely used.\nFor example,Stringis treated as an alias forstring.\nEven thoughStringis a type in TypeScript, old JSDoc often uses it to meanstring.\nBesides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use.\nSo the compiler treats these types as synonyms based on usage in old JSDoc:"
                },
                {
                    "type": "list",
                    "items": [
                        "String -> string",
                        "Number -> number",
                        "Boolean -> boolean",
                        "Void -> void",
                        "Undefined -> undefined",
                        "Null -> null",
                        "function -> Function",
                        "array -> Array<any>",
                        "promise -> Promise<any>",
                        "Object -> any",
                        "object -> any"
                    ]
                },
                {
                    "type": "p",
                    "text": "The last four aliases are turned off whennoImplicitAny: true:"
                },
                {
                    "type": "list",
                    "items": [
                        "objectandObjectare built-in types, althoughObjectis rarely used.",
                        "arrayandpromiseare not built-in, but might be declared somewhere in your program."
                    ]
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "p",
                    "text": "How to add d.ts generation to JavaScript projects"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsx.html",
            "title": "TypeScript: Documentation - JSX",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "JSXis an embeddable XML-like syntax.\nIt is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific.\nJSX rose to popularity with theReactframework, but has since seen other implementations as well.\nTypeScript supports embedding, type checking, and compiling JSX directly to JavaScript."
                },
                {
                    "type": "p",
                    "text": "In order to use JSX you must do two things."
                },
                {
                    "type": "list",
                    "items": [
                        "Name your files with a.tsxextension",
                        "Enable thejsxoption"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript ships with several JSX modes:preserve,react(classic runtime),react-jsx(automatic runtime),react-jsxdev(automatic development runtime), andreact-native.\nThepreservemode will keep the JSX as part of the output to be further consumed by another transform step (e.g.Babel).\nAdditionally the output will have a.jsxfile extension.\nThereactmode will emitReact.createElement, does not need to go through a JSX transformation before use, and the output will have a.jsfile extension.\nThereact-nativemode is the equivalent ofpreservein that it keeps all JSX, but the output will instead have a.jsfile extension."
                },
                {
                    "type": "p",
                    "text": "You can specify this mode using either thejsxcommand line flag or the corresponding optionjsxin your tsconfig.jsonfile."
                },
                {
                    "type": "p",
                    "text": "*Note: You can specify the JSX factory function to use when targeting react JSX emit withjsxFactoryoption (defaults toReact.createElement)"
                },
                {
                    "type": "p",
                    "text": "Recall how to write a type assertion:"
                },
                {
                    "type": "code",
                    "code": "tsconstfoo= <Foo>bar;"
                },
                {
                    "type": "p",
                    "text": "This asserts the variablebarto have the typeFoo.\nSince TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in.tsxfiles. Since the above syntax cannot be used in.tsxfiles, an alternate type assertion operator should be used:as.\nThe example can easily be rewritten with theasoperator."
                },
                {
                    "type": "code",
                    "code": "tsconstfoo=barasFoo;"
                },
                {
                    "type": "p",
                    "text": "Theasoperator is available in both.tsand.tsxfiles, and is identical in behavior to the angle-bracket type assertion style."
                },
                {
                    "type": "p",
                    "text": "In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements.\nGiven a JSX expression<expr />,exprmay either refer to something intrinsic to the environment (e.g. adivorspanin a DOM environment) or to a custom component that you’ve created.\nThis is important for two reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "For React, intrinsic elements are emitted as strings (React.createElement(\"div\")), whereas a component you’ve created is not (React.createElement(MyComponent)).",
                        "The types of the attributes being passed in the JSX element should be looked up differently.\nIntrinsic element attributes should be knownintrinsicallywhereas components will likely want to specify their own set of attributes."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript uses thesame convention that React doesfor distinguishing between these.\nAn intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter."
                },
                {
                    "type": "p",
                    "text": "JSX in TypeScript is typed by theJSXnamespace. TheJSXnamespace may be defined in various places, depending on thejsxcompiler option. Thejsxoptionspreserve,react, andreact-nativeuse the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by thejsxFactorycompiler option. TheJSXnamespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factoryReact.createElement. This means itsJSXnamespace should be defined asReact.JSX."
                },
                {
                    "type": "code",
                    "code": "tsexportfunctioncreateElement():any;exportnamespaceJSX{// …}"
                },
                {
                    "type": "p",
                    "text": "And the user should always import React asReact."
                },
                {
                    "type": "code",
                    "code": "tsimport*asReactfrom'react';"
                },
                {
                    "type": "p",
                    "text": "Preact uses the JSX factoryh. That means its types should be defined as theh.JSX."
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionh(props:any):any;exportnamespaceh.JSX{// …}"
                },
                {
                    "type": "p",
                    "text": "The user should use a named import to importh."
                },
                {
                    "type": "code",
                    "code": "tsimport{h}from'preact';"
                },
                {
                    "type": "p",
                    "text": "For thejsxoptionsreact-jsxandreact-jsxdev, theJSXnamespace should be exported from the matching entry points. Forreact-jsxthis is${jsxImportSource}/jsx-runtime. Forreact-jsxdev, this is${jsxImportSource}/jsx-dev-runtime. Since these don’t use a file extension, you must use theexportsfield inpackage.jsonmap in order to support ESM users."
                },
                {
                    "type": "code",
                    "code": "json{\"exports\": {\"./jsx-runtime\":\"./jsx-runtime.js\",\"./jsx-dev-runtime\":\"./jsx-dev-runtime.js\",}}"
                },
                {
                    "type": "p",
                    "text": "Then injsx-runtime.d.tsandjsx-dev-runtime.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportnamespaceJSX{// …}"
                },
                {
                    "type": "p",
                    "text": "Note that while exporting theJSXnamespace is sufficient for type checking, the production runtime needs thejsx,jsxs, andFragmentexports at runtime, and the development runtime needsjsxDEVandFragment. Ideally you add types for those too. If theJSXnamespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the globalJSXnamespace."
                },
                {
                    "type": "p",
                    "text": "Intrinsic elements are looked up on the special interfaceJSX.IntrinsicElements.\nBy default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked.\nHowever, if this interfaceispresent, then the name of the intrinsic element is looked up as a property on theJSX.IntrinsicElementsinterface.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo:any;}}<foo/>;// ok<bar/>;// error"
                },
                {
                    "type": "p",
                    "text": "In the above example,<foo />will work fine but<bar />will result in an error since it has not been specified onJSX.IntrinsicElements."
                },
                {
                    "type": "p",
                    "text": "Note: You can also specify a catch-all string indexer onJSX.IntrinsicElementsas follows:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceJSX{interfaceIntrinsicElements{[elemName:string]:any;}}"
                },
                {
                    "type": "p",
                    "text": "Value-based elements are simply looked up by identifiers that are in scope."
                },
                {
                    "type": "code",
                    "code": "tsximportMyComponentfrom\"./myComponent\";<MyComponent/>;// ok<SomeOtherComponent/>;// error"
                },
                {
                    "type": "p",
                    "text": "There are two ways to define a value-based element:"
                },
                {
                    "type": "list",
                    "items": [
                        "Function Component (FC)",
                        "Class Component"
                    ]
                },
                {
                    "type": "p",
                    "text": "Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error."
                },
                {
                    "type": "p",
                    "text": "As the name suggests, the component is defined as a JavaScript function where its first argument is apropsobject.\nTS enforces that its return type must be assignable toJSX.Element."
                },
                {
                    "type": "code",
                    "code": "tsxinterfaceFooProp{name:string;X:number;Y:number;}declarefunctionAnotherComponent(prop: {name:string});functionComponentFoo(prop:FooProp) {return<AnotherComponentname={prop.name}/>;}constButton= (prop: {value:string},context: {color:string})=>(<button/>);"
                },
                {
                    "type": "p",
                    "text": "Because a Function Component is simply a JavaScript function, function overloads may be used here as well:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClickableProps{children:JSX.Element[] |JSX.Element;}interfaceHomePropsextendsClickableProps{home:JSX.Element;}interfaceSidePropsextendsClickableProps{side:JSX.Element|string;}functionMainButton(prop:HomeProps):JSX.Element;functionMainButton(prop:SideProps):JSX.Element;functionMainButton(prop:ClickableProps):JSX.Element{// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the typeSFCand its aliasStatelessComponentwere deprecated."
                },
                {
                    "type": "p",
                    "text": "It is possible to define the type of a class component.\nHowever, to do so it is best to understand two new terms: theelement class typeand theelement instance type. Given<Expr />, theelement class typeis the type ofExpr.\nSo in the example above, ifMyComponentwas an ES6 class the class type would be that class’s constructor and statics.\nIfMyComponentwas a factory function, the class type would be that function. Once the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present).\nSo again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function."
                },
                {
                    "type": "code",
                    "code": "tsclassMyComponent{render() {}}// use a construct signatureconstmyComponent=newMyComponent();// element class type => MyComponent// element instance type => { render: () => void }functionMyFactoryFunction() {return{render:()=>{},};}// use a call signatureconstmyComponent=MyFactoryFunction();// element class type => MyFactoryFunction// element instance type => { render: () => void }"
                },
                {
                    "type": "p",
                    "text": "The element instance type is interesting because it must be assignable toJSX.ElementClassor it will result in an error.\nBy defaultJSX.ElementClassis{}, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceElementClass{render:any;}}classMyComponent{render() {}}functionMyFactoryFunction() {return{render:()=>{} };}<MyComponent/>;// ok<MyFactoryFunction/>;// okclassNotAValidComponent{}functionNotAValidFactoryFunction() {return{};}<NotAValidComponent/>;// error<NotAValidFactoryFunction/>;// error"
                },
                {
                    "type": "p",
                    "text": "The first step to type checking attributes is to determine theelement attributes type.\nThis is slightly different between intrinsic and value-based elements. For intrinsic elements, it is the type of the property onJSX.IntrinsicElements"
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo: {bar?:boolean};}}// element attributes type for 'foo' is '{bar?: boolean}'<foobar/>;"
                },
                {
                    "type": "p",
                    "text": "For value-based elements, it is a bit more complex.\nIt is determined by the type of a property on theelement instance typethat was previously determined.\nWhich property to use is determined byJSX.ElementAttributesProperty.\nIt should be declared with a single property.\nThe name of that property is then used.\nAs of TypeScript 2.8, ifJSX.ElementAttributesPropertyis not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceElementAttributesProperty{props;// specify the property name to use}}classMyComponent{// specify the property on the element instance typeprops: {foo?:string;};}// element attributes type for 'MyComponent' is '{foo?: string}'<MyComponentfoo=\"bar\"/>;"
                },
                {
                    "type": "p",
                    "text": "The element attribute type is used to type check the attributes in the JSX.\nOptional and required properties are supported."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo: {requiredProp:string;optionalProp?:number};}}<foorequiredProp=\"bar\"/>;// ok<foorequiredProp=\"bar\"optionalProp={0}/>;// ok<foo/>;// error, requiredProp is missing<foorequiredProp={0}/>;// error, requiredProp should be a string<foorequiredProp=\"bar\"unknownProp/>;// error, unknownProp does not exist<foorequiredProp=\"bar\"some-unknown-prop/>;// ok, because 'some-unknown-prop' is not a valid identifier"
                },
                {
                    "type": "p",
                    "text": "Note: If an attribute name is not a valid JS identifier (like adata-*attribute), it is not considered to be an error if it is not found in the element attributes type."
                },
                {
                    "type": "p",
                    "text": "Additionally, theJSX.IntrinsicAttributesinterface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instancekeyin React. Specializing further, the genericJSX.IntrinsicClassAttributes<T>type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow therefattribute of typeRef<T>. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag. The spread operator also works:"
                },
                {
                    "type": "code",
                    "code": "tsxconstprops= {requiredProp:\"bar\"};<foo{...props}/>;// okconstbadProps= {};<foo{...badProps}/>;// error"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 2.3, TS introduced type checking ofchildren.childrenis a special property in anelement attributes typewhere childJSXExpressions are taken to be inserted into the attributes.\nSimilar to how TS usesJSX.ElementAttributesPropertyto determine the name ofprops, TS usesJSX.ElementChildrenAttributeto determine the name ofchildrenwithin those props.JSX.ElementChildrenAttributeshould be declared with a single property."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceJSX{interfaceElementChildrenAttribute{children: {};// specify children name to use}}"
                },
                {
                    "type": "code",
                    "code": "tsx<div><h1>Hello</h1></div>;<div><h1>Hello</h1>World</div>;constCustomComp= (props)=><div>{props.children}</div><CustomComp><div>Hello World</div>{\"This is just a JS expression...\"+1000}</CustomComp>"
                },
                {
                    "type": "p",
                    "text": "You can specify the type ofchildrenlike any other attribute. This will override the default type from, e.g. theReact typingsif you use them."
                },
                {
                    "type": "code",
                    "code": "tsxinterfacePropsType{children:JSX.Elementname:string}classComponentextendsReact.Component<PropsType, {}> {render() {return(<h2>{this.props.children}</h2>)}}// OK<Componentname=\"foo\"><h1>Hello World</h1></Component>// Error: children is of type JSX.Element not array of JSX.Element<Componentname=\"bar\"><h1>Hello World</h1><h2>Hello World</h2></Component>// Error: children is of type JSX.Element not array of JSX.Element or string.<Componentname=\"baz\"><h1>Hello</h1>World</Component>"
                },
                {
                    "type": "p",
                    "text": "By default the result of a JSX expression is typed asany.\nYou can customize the type by specifying theJSX.Elementinterface.\nHowever, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface.\nIt is a black box."
                },
                {
                    "type": "p",
                    "text": "By default, function components must returnJSX.Element | null. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specifyJSX.ElementTypeto override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceJSX{exporttypeElementType=// All the valid lowercase tags|keyofIntrinsicElements// Function components| (props:any)=>Element// Class components|new(props:any)=>ElementClass;exportinterfaceIntrinsicAttributesextends/*...*/{}exporttypeElement=/*...*/;exporttypeElementClass=/*...*/;}"
                },
                {
                    "type": "p",
                    "text": "JSX allows you to embed expressions between tags by surrounding the expressions with curly braces ({ })."
                },
                {
                    "type": "code",
                    "code": "tsxconsta= (<div>{[\"foo\",\"bar\"].map((i)=>(<span>{i/2}</span>))}</div>);"
                },
                {
                    "type": "p",
                    "text": "The above code will result in an error since you cannot divide a string by a number.\nThe output, when using thepreserveoption, looks like:"
                },
                {
                    "type": "code",
                    "code": "tsxconsta= (<div>{[\"foo\",\"bar\"].map(function(i) {return<span>{i/2}</span>;})}</div>);"
                },
                {
                    "type": "p",
                    "text": "To use JSX with React you should use theReact typings.\nThese typings define theJSXnamespace appropriately for use with React."
                },
                {
                    "type": "code",
                    "code": "tsx///<referencepath=\"react.d.ts\"/>interfaceProps{foo:string;}classMyComponentextendsReact.Component<Props, {}> {render() {return<span>{this.props.foo}</span>;}}<MyComponentfoo=\"bar\"/>;// ok<MyComponentfoo={0}/>;// error"
                },
                {
                    "type": "p",
                    "text": "There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:"
                },
                {
                    "type": "list",
                    "items": [
                        "jsxFactory",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
            "title": "TypeScript: Documentation - Migrating from JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t exist in a vacuum.\nIt was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today.\nConverting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging.\nIn this tutorial, we’re going to look at how you might start out.\nWe assume you’ve read enough of the handbook to write new TypeScript code. If you’re looking to convert a React project, we recommend looking at theReact Conversion Guidefirst."
                },
                {
                    "type": "p",
                    "text": "If you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly,\nwhere your.jsfiles are in asrc,lib, ordistdirectory, and then run as desired. If that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces.\nDuring our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them.\nIf your output files need to reside in a specific directory, then that will be your output directory. You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel.\nIn this case, you might already have a folder structure like this set up. From this point on, we’re going to assume that your directory is set up something like this:"
                },
                {
                    "type": "code",
                    "code": "projectRoot├── src│   ├── file1.js│   └── file2.js├── built└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "If you have atestsfolder outside of yoursrcdirectory, you might have onetsconfig.jsoninsrc, and one intestsas well."
                },
                {
                    "type": "p",
                    "text": "TypeScript uses a file calledtsconfig.jsonfor managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform.\nLet’s create a bare-bones one for our project:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"outDir\":\"./built\",\"allowJs\":true,\"target\":\"es5\"},\"include\": [\"./src/**/*\"]}"
                },
                {
                    "type": "p",
                    "text": "Here we’re specifying a few things to TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read in any files it understands in thesrcdirectory (withinclude).",
                        "Accept JavaScript files as inputs (withallowJs).",
                        "Emit all of the output files inbuilt(withoutDir).",
                        "Translate newer JavaScript constructs down to an older version like ECMAScript 5 (usingtarget)."
                    ]
                },
                {
                    "type": "p",
                    "text": "At this point, if you try runningtscat the root of your project, you should see output files in thebuiltdirectory.\nThe layout of files inbuiltshould look identical to the layout ofsrc.\nYou should now have TypeScript working with your project."
                },
                {
                    "type": "p",
                    "text": "Even at this point you can get some great benefits from TypeScript understanding your project.\nIf you open up an editor likeVS CodeorVisual Studio, you’ll see that you can often get some tooling support like completion.\nYou can also catch certain bugs with options like:"
                },
                {
                    "type": "list",
                    "items": [
                        "noImplicitReturnswhich prevents you from forgetting to return at the end of a function.",
                        "noFallthroughCasesInSwitchwhich is helpful if you never want to forget abreakstatement betweencases in aswitchblock."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript will also warn about unreachable code and labels, which you can disable withallowUnreachableCodeandallowUnusedLabelsrespectively."
                },
                {
                    "type": "p",
                    "text": "You might have some more build steps in your pipeline.\nPerhaps you concatenate something to each of your files.\nEach build tool is different, but we’ll do our best to cover the gist of things."
                },
                {
                    "type": "p",
                    "text": "If you’re using Gulp in some fashion, we have a tutorial onusing Gulpwith TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify.\nYou can read more there."
                },
                {
                    "type": "p",
                    "text": "Webpack integration is pretty simple.\nYou can usets-loader, a TypeScript loader, combined withsource-map-loaderfor easier debugging.\nSimply run"
                },
                {
                    "type": "code",
                    "code": "shellnpm install ts-loader source-map-loader"
                },
                {
                    "type": "p",
                    "text": "and merge in options from the following into yourwebpack.config.jsfile:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports= {entry:\"./src/index.ts\",output:{filename:\"./dist/bundle.js\",},// Enable sourcemaps for debugging webpack's output.devtool:\"source-map\",resolve:{// Add '.ts' and '.tsx' as resolvable extensions.extensions:[\"\",\".webpack.js\",\".web.js\",\".ts\",\".tsx\",\".js\"],},module:{rules:[// All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.{test:/\\.tsx?$/,loader:\"ts-loader\"},// All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.{test:/\\.js$/,loader:\"source-map-loader\"},],},// Other options...};"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that ts-loader will need to run before any other loader that deals with.jsfiles. You can see an example of using Webpack in ourtutorial on React and Webpack."
                },
                {
                    "type": "p",
                    "text": "At this point, you’re probably ready to start using TypeScript files.\nThe first step is to rename one of your.jsfiles to.ts.\nIf your file uses JSX, you’ll need to rename it to.tsx. Finished with that step?\nGreat!\nYou’ve successfully migrated a file from JavaScript to TypeScript! Of course, that might not feel right.\nIf you open that file in an editor with TypeScript support (or if you runtsc --pretty), you might see red squiggles on certain lines.\nYou should think of these the same way you’d think of red squiggles in an editor like Microsoft Word.\nTypeScript will still translate your code, just like Word will still let you print your documents. If that sounds too lax for you, you can tighten that behavior up.\nIf, for instance, youdon’twant TypeScript to compile to JavaScript in the face of errors, you can use thenoEmitOnErroroption.\nIn that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want. If you plan on using the stricter settings that are available, it’s best to turn them on now (seeGetting Stricter Checksbelow).\nFor instance, if you never want TypeScript to silently inferanyfor a type without you explicitly saying so, you can usenoImplicitAnybefore you start modifying your files.\nWhile it might feel somewhat overwhelming, the long-term gains become apparent much more quickly."
                },
                {
                    "type": "p",
                    "text": "Like we mentioned, it’s not unexpected to get error messages after conversion.\nThe important thing is to actually go one by one through these and decide how to deal with the errors.\nOften these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript."
                },
                {
                    "type": "p",
                    "text": "You might start out getting a bunch of errors likeCannot find name 'require'., andCannot find name 'define'..\nIn these cases, it’s likely that you’re using modules.\nWhile you can just convince TypeScript that these exist by writing out"
                },
                {
                    "type": "code",
                    "code": "ts// For Node/CommonJSdeclarefunctionrequire(path:string):any;"
                },
                {
                    "type": "p",
                    "text": "or"
                },
                {
                    "type": "code",
                    "code": "ts// For RequireJS/AMDdeclarefunctiondefine(...args:any[]):any;"
                },
                {
                    "type": "p",
                    "text": "it’s better to get rid of those calls and use TypeScript syntax for imports. First, you’ll need to enable some module system by setting TypeScript’smoduleoption.\nValid options arecommonjs,amd,system, andumd. If you had the following Node/CommonJS code:"
                },
                {
                    "type": "code",
                    "code": "jsvarfoo=require(\"foo\");foo.doStuff();"
                },
                {
                    "type": "p",
                    "text": "or the following RequireJS/AMD code:"
                },
                {
                    "type": "code",
                    "code": "jsdefine([\"foo\"],function(foo) {foo.doStuff();});"
                },
                {
                    "type": "p",
                    "text": "then you would write the following TypeScript code:"
                },
                {
                    "type": "code",
                    "code": "tsimportfoo=require(\"foo\");foo.doStuff();"
                },
                {
                    "type": "p",
                    "text": "If you started converting over to TypeScript imports, you’ll probably run into errors likeCannot find module 'foo'..\nThe issue here is that you likely don’t havedeclaration filesto describe your library.\nLuckily this is pretty easy.\nIf TypeScript complains about a package likelodash, you can just write"
                },
                {
                    "type": "code",
                    "code": "shellnpm install -S @types/lodash"
                },
                {
                    "type": "p",
                    "text": "If you’re using a module option other thancommonjs, you’ll need to set yourmoduleResolutionoption tonode. After that, you’ll be able to import lodash with no issues, and get accurate completions."
                },
                {
                    "type": "p",
                    "text": "Typically, exporting from a module involves adding properties to a value likeexportsormodule.exports.\nTypeScript allows you to use top-level export statements.\nFor instance, if you exported a function like so:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports.feedPets=function(pets) {// ...};"
                },
                {
                    "type": "p",
                    "text": "you could write that out as the following:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionfeedPets(pets) {// ...}"
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll entirely overwrite the exports object.\nThis is a common pattern people use to make their modules immediately callable like in this snippet:"
                },
                {
                    "type": "code",
                    "code": "jsvarexpress=require(\"express\");varapp=express();"
                },
                {
                    "type": "p",
                    "text": "You might have previously written that like so:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionfoo() {// ...}module.exports=foo;"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, you can model this with theexport =construct."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfoo() {// ...}export=foo;"
                },
                {
                    "type": "p",
                    "text": "You’ll sometimes find yourself calling a function with too many/few arguments.\nTypically, this is a bug, but in some cases, you might have declared a function that uses theargumentsobject instead of writing out any parameters:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionmyCoolFunction() {if(arguments.length==2&& !Array.isArray(arguments[1])) {varf=arguments[0];vararr=arguments[1];// ...}// ...}myCoolFunction(function(x) {console.log(x);},[1,2,3,4]);myCoolFunction(function(x) {console.log(x);},1,2,3,4);"
                },
                {
                    "type": "p",
                    "text": "In this case, we need to use TypeScript to tell any of our callers about the waysmyCoolFunctioncan be called using function overloads."
                },
                {
                    "type": "code",
                    "code": "tsfunctionmyCoolFunction(f: (x:number)=>void,nums:number[]):void;functionmyCoolFunction(f: (x:number)=>void, ...nums:number[]):void;functionmyCoolFunction() {if(arguments.length==2&& !Array.isArray(arguments[1])) {varf=arguments[0];vararr=arguments[1];// ...}// ...}"
                },
                {
                    "type": "p",
                    "text": "We added two overload signatures tomyCoolFunction.\nThe first checks states thatmyCoolFunctiontakes a function (which takes anumber), and then a list ofnumbers.\nThe second one says that it will take a function as well, and then uses a rest parameter (...nums) to state that any number of arguments after that need to benumbers."
                },
                {
                    "type": "p",
                    "text": "Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:"
                },
                {
                    "type": "code",
                    "code": "jsvaroptions= {};options.color=\"red\";options.volume=11;"
                },
                {
                    "type": "p",
                    "text": "TypeScript will say that you can’t assign tocolorandvolumebecause it first figured out the type ofoptionsas{}which doesn’t have any properties.\nIf you instead moved the declarations into the object literal themselves, you’d get no errors:"
                },
                {
                    "type": "code",
                    "code": "tsletoptions= {color:\"red\",volume:11,};"
                },
                {
                    "type": "p",
                    "text": "You could also define the type ofoptionsand add a type assertion on the object literal."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceOptions{color:string;volume:number;}letoptions= {}asOptions;options.color=\"red\";options.volume=11;"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can just sayoptionshas the typeanywhich is the easiest thing to do, but which will benefit you the least."
                },
                {
                    "type": "p",
                    "text": "You might be tempted to useObjector{}to say that a value can have any property on it becauseObjectis, for most purposes, the most general type.\nHoweveranyis actually the type you want to usein those situations, since it’s the mostflexibletype. For instance, if you have something that’s typed asObjectyou won’t be able to call methods liketoLowerCase()on it.\nBeing more general usually means you can do less with a type, butanyis special in that it is the most general type while still allowing you to do anything with it.\nThat means you can call it, construct it, access properties on it, etc.\nKeep in mind though, whenever you useany, you lose out on most of the error checking and editor support that TypeScript gives you. If a decision ever comes down toObjectand{}, you should prefer{}.\nWhile they are mostly the same, technically{}is a more general type thanObjectin certain esoteric cases."
                },
                {
                    "type": "p",
                    "text": "TypeScript comes with certain checks to give you more safety and analysis of your program.\nOnce you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety."
                },
                {
                    "type": "p",
                    "text": "There are certain cases where TypeScript can’t figure out what certain types should be.\nTo be as lenient as possible, it will decide to use the typeanyin its place.\nWhile this is great for migration, usinganymeans that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere.\nYou can tell TypeScript to flag these locations down and give an error with thenoImplicitAnyoption."
                },
                {
                    "type": "p",
                    "text": "By default, TypeScript assumes thatnullandundefinedare in the domain of every type.\nThat means anything declared with the typenumbercould benullorundefined.\nSincenullandundefinedare such a frequent source of bugs in JavaScript and TypeScript, TypeScript has thestrictNullChecksoption to spare you the stress of worrying about these issues. WhenstrictNullChecksis enabled,nullandundefinedget their own types callednullandundefinedrespectively.\nWhenever anything ispossiblynull, you can use a union type with the original type.\nSo for instance, if something could be anumberornull, you’d write the type out asnumber | null. If you ever have a value that TypeScript thinks is possiblynull/undefined, but you know better, you can use the postfix!operator to tell it otherwise."
                },
                {
                    "type": "code",
                    "code": "tsdeclarevarfoo:string[] |null;foo.length;// error - 'foo' is possibly 'null'foo!.length;// okay - 'foo!' just has type 'string[]'"
                },
                {
                    "type": "p",
                    "text": "As a heads up, when usingstrictNullChecks, your dependencies may need to be updated to usestrictNullChecksas well."
                },
                {
                    "type": "p",
                    "text": "When you use thethiskeyword outside of classes, it has the typeanyby default.\nFor instance, imagine aPointclass, and imagine a function that we wish to add as a method:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{constructor(publicx,publicy) {}getDistance(p:Point) {letdx=p.x-this.x;letdy=p.y-this.y;returnMath.sqrt(dx**2+dy**2);}}// ...// Reopen the interface.interfacePoint{distanceFromOrigin():number;}Point.prototype.distanceFromOrigin=function() {returnthis.getDistance({x:0,y:0});};"
                },
                {
                    "type": "p",
                    "text": "This has the same problems we mentioned above - we could easily have misspelledgetDistanceand not gotten an error.\nFor this reason, TypeScript has thenoImplicitThisoption.\nWhen that option is set, TypeScript will issue an error whenthisis used without an explicit (or inferred) type.\nThe fix is to use athis-parameter to give an explicit type in the interface or in the function itself:"
                },
                {
                    "type": "code",
                    "code": "tsPoint.prototype.distanceFromOrigin=function(this:Point) {returnthis.getDistance({x:0,y:0});};"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/mixins.html",
            "title": "TypeScript: Documentation - Mixins",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes.\nYou may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community."
                },
                {
                    "type": "p",
                    "text": "The pattern relies on using generics with class inheritance to extend a base class.\nTypeScript’s best mixin support is done via the class expression pattern.\nYou can read more about how this pattern works in JavaScripthere. To get started, we’ll need a class which will have the mixins applied on top of:"
                },
                {
                    "type": "code",
                    "code": "tsclassSprite{name=\"\";x=0;y=0;constructor(name:string) {this.name=name;}}Try"
                },
                {
                    "type": "p",
                    "text": "Then you need a type and a factory function which returns a class expression extending the base class."
                },
                {
                    "type": "code",
                    "code": "ts// To get started, we need a type which we'll use to extend// other classes from. The main responsibility is to declare// that the type being passed in is a class.typeConstructor=new(...args:any[])=>{};// This mixin adds a scale property, with getters and setters// for changing it with an encapsulated private property:functionScale<TBaseextendsConstructor>(Base:TBase) {returnclassScalingextendsBase{// Mixins may not declare private/protected properties// however, you can use ES2020 private fields_scale=1;setScale(scale:number) {this._scale=scale;}getscale():number{returnthis._scale;}};}Try"
                },
                {
                    "type": "p",
                    "text": "With these all set up, then you can create a class which represents the base class with mixins applied:"
                },
                {
                    "type": "code",
                    "code": "ts// Compose a new class from the Sprite class,// with the Mixin Scale applier:constEightBitSprite=Scale(Sprite);constflappySprite=newEightBitSprite(\"Bird\");flappySprite.setScale(0.8);console.log(flappySprite.scale);Try"
                },
                {
                    "type": "p",
                    "text": "In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want. To model this, we modify the original constructor type to accept a generic argument."
                },
                {
                    "type": "code",
                    "code": "ts// This was our previous constructor:typeConstructor=new(...args:any[])=>{};// Now we use a generic version which can apply a constraint on// the class which this mixin is applied totypeGConstructor<T= {}> =new(...args:any[])=>T;Try"
                },
                {
                    "type": "p",
                    "text": "This allows for creating classes which only work with constrained base classes:"
                },
                {
                    "type": "code",
                    "code": "tstypePositionable=GConstructor<{setPos: (x:number,y:number)=>void}>;typeSpritable=GConstructor<Sprite>;typeLoggable=GConstructor<{print: ()=>void}>;Try"
                },
                {
                    "type": "p",
                    "text": "Then you can create mixins which only work when you have a particular base to build on:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionJumpable<TBaseextendsPositionable>(Base:TBase) {returnclassJumpableextendsBase{jump() {// This mixin will only work if it is passed a base// class which has setPos defined because of the// Positionable constraint.this.setPos(0,20);}};}Try"
                },
                {
                    "type": "p",
                    "text": "Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:"
                },
                {
                    "type": "code",
                    "code": "ts// Each mixin is a traditional ES classclassJumpable{jump() {}}classDuckable{duck() {}}// Including the baseclassSprite{x=0;y=0;}// Then you create an interface which merges// the expected mixins with the same name as your baseinterfaceSpriteextendsJumpable,Duckable{}// Apply the mixins into the base class via// the JS at runtimeapplyMixins(Sprite, [Jumpable,Duckable]);letplayer=newSprite();player.jump();console.log(player.x,player.y);// This can live anywhere in your codebase:functionapplyMixins(derivedCtor:any,constructors:any[]) {constructors.forEach((baseCtor)=>{Object.getOwnPropertyNames(baseCtor.prototype).forEach((name)=>{Object.defineProperty(derivedCtor.prototype,name,Object.getOwnPropertyDescriptor(baseCtor.prototype,name) ||Object.create(null));});});}Try"
                },
                {
                    "type": "p",
                    "text": "This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync."
                },
                {
                    "type": "p",
                    "text": "The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis.\nThere are a few cases where you can hit the edges of the native support."
                },
                {
                    "type": "p",
                    "text": "You cannot use decorators to provide mixins via code flow analysis:"
                },
                {
                    "type": "code",
                    "code": "ts// A decorator function which replicates the mixin pattern:constPausable= (target:typeofPlayer)=>{returnclassPausableextendstarget{shouldFreeze=false;};};@PausableclassPlayer{x=0;y=0;}// The Player class does not have the decorator's type merged:constplayer=newPlayer();player.shouldFreeze;Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.// The runtime aspect could be manually replicated via// type composition or interface merging.typeFreezablePlayer=Player& {shouldFreeze:boolean};constplayerTwo= (newPlayer()asunknown)asFreezablePlayer;playerTwo.shouldFreeze;Try"
                },
                {
                    "type": "p",
                    "text": "More of a gotcha than a constraint.\nThe class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types. You can work around this by using functions to return your classes which differ based on a generic:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbase<T>() {classBase{staticprop:T;}returnBase;}functionderived<T>() {classDerivedextendsbase<T>() {staticanotherProp:T;}returnDerived;}classSpecextendsderived<string>() {}Spec.prop;// stringSpec.anotherProp;// stringTry"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html",
            "title": "TypeScript: Documentation - Modules - ESM/CJS Interoperability",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "It’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:"
                },
                {
                    "type": "code",
                    "code": "tsexportconstA= {};exportconstB= {};exportdefault\"Hello, world!\";"
                },
                {
                    "type": "p",
                    "text": "How would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:"
                },
                {
                    "type": "code",
                    "code": "tsexports.A= {};exports.B= {};exports.default=\"Hello, world!\";"
                },
                {
                    "type": "p",
                    "text": "This is a nice analog, and it lets you implement a similar on the importing side:"
                },
                {
                    "type": "code",
                    "code": "tsimporthello, {A,B}from\"./module\";console.log(hello,A,B);// transpiles to:constmodule_1=require(\"./module\");console.log(module_1.default,module_1.A,module_1.B);"
                },
                {
                    "type": "p",
                    "text": "So far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmodfrom\"./module\";console.log(mod.default,mod.A,mod.B);// transpiles to:constmod=require(\"./module\");console.log(mod.default,mod.A,mod.B);"
                },
                {
                    "type": "p",
                    "text": "You might notice that in this scheme, there’s no way to write an ESM export that produces an output whereexportsis assigned a function, class, or primitive:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: exports-function.jsmodule.exports=functionhello() {console.log(\"Hello, world!\");};"
                },
                {
                    "type": "p",
                    "text": "But existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (import *) transpiles to a plainrequirecall, so we can support an input like:"
                },
                {
                    "type": "code",
                    "code": "tsimport*ashellofrom\"./exports-function\";hello();// transpiles to:consthello=require(\"./exports-function\");hello();"
                },
                {
                    "type": "p",
                    "text": "Our output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to aModule Namespace Object, that is, an object whose members are the exports of the module. In this case,requirewould return the functionhello, butimport *can never return a function. The correspondence we assumed appears invalid. It’s worth taking a step back here and clarifying what thegoalis. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior. By following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):  However, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.  Even if transpiler authors did nothing, a behavior would emerge from the existing semantics between therequirecalls they emitted in transpiled code and theexportsdefined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement. Guessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able torequireES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJSrequirecalls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM."
                },
                {
                    "type": "p",
                    "text": "Let’s return to our specification compliance problem, whereimport *transpiles torequire:"
                },
                {
                    "type": "code",
                    "code": "ts// Invalid according to the spec:import*ashellofrom\"./exports-function\";hello();// but the transpilation works:consthello=require(\"./exports-function\");hello();"
                },
                {
                    "type": "p",
                    "text": "When TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whoseexportswas not a namespace-like object:"
                },
                {
                    "type": "code",
                    "code": "tsimport*ashellofrom\"./exports-function\";// TS2497              ^^^^^^^^^^^^^^^^^^^^// External module '\"./exports-function\"' resolves to a non-module entity// and cannot be imported using this construct."
                },
                {
                    "type": "p",
                    "text": "The only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJSrequire:"
                },
                {
                    "type": "code",
                    "code": "tsimporthello=require(\"./exports-function\");"
                },
                {
                    "type": "p",
                    "text": "Forcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like\"./exports-function\"will be accessible with ESM imports in the future, but we know itcan’tbe withimport *, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing theimport *to link to a function. This is still the behavior in TypeScript today whenallowSyntheticDefaultImportsandesModuleInteropare disabled."
                },
                {
                    "type": "p",
                    "text": "Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunction$(selector:string):any;export=$;// Cannot `import *` this 👍"
                },
                {
                    "type": "p",
                    "text": "A should-be-meaningless change allowed the invalid import to type check without errors:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespace${}declarefunction$(selector:string):any;export=$;// Allowed to `import *` this and call it 😱"
                },
                {
                    "type": "p",
                    "text": "Meanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.",
                        "Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modulesalwayslink directly to the wholeexports, rather than only doing so if theexportsis a function or primitive.",
                        "So, a default import of a true CJS module should work just like arequirecall. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpileexport default \"hello\"toexports.default = \"hello\"and have a default import ofthatmodule link toexports.default. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).",
                        "When we transpile an ES module to CJS, let’s add a special extra field to the output:tsexports.A= {};exports.B= {};exports.default=\"Hello, world!\";// Extra special flag!exports.__esModule=true;that we can check for when we transpile a default import:ts// import hello from \"./module\";const_mod=require(\"./module\");consthello=_mod.__esModule?_mod.default:_mod;"
                    ]
                },
                {
                    "type": "p",
                    "text": "The__esModuleflag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added theallowSyntheticDefaultImportsin 1.8 to allow the type checker to link default imports directly to theexports, rather than theexports.default, of any module types that lacked anexport defaultdeclaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” whereimport *was an error:"
                },
                {
                    "type": "code",
                    "code": "ts// Error:import*ashellofrom\"./exports-function\";// Old workaround:importhello=require(\"./exports-function\");// New way, with `allowSyntheticDefaultImports`:importhellofrom\"./exports-function\";"
                },
                {
                    "type": "p",
                    "text": "This was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:"
                },
                {
                    "type": "list",
                    "items": [
                        "Babel and others varied their default import behavior on whether an__esModuleproperty was found on the target module, butallowSyntheticDefaultImportsonly enabled afallbackbehavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an__esModuleflag butnodefault export. Transpilers and bundlers would still link a default import of such a module to itsexports.default, which would beundefined, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But withallowSyntheticDefaultImports, TypeScript would think a default import of such an import links to the wholeexportsobject, allowing named exports to be accessed as its properties.",
                        "allowSyntheticDefaultImportsdidn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:ts// @Filename: exportEqualsObject.d.tsdeclareconstobj:object;export=obj;// @Filename: main.tsimportobjDefaultfrom\"./exportEqualsObject\";import*asobjNamespacefrom\"./exportEqualsObject\";// This should be true at runtime, but TypeScript gives an error:objNamespace.default===objDefault;//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.",
                        "Most importantly,allowSyntheticDefaultImportsdid not change the JavaScript emitted bytsc. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting--module commonjswithtscand running in Node.js. If they encountered an error withimport *, it may have appeared as if enablingallowSyntheticDefaultImportswould fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript introduced theesModuleInteropflag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same__esModule-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper forimport *ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node."
                },
                {
                    "type": "p",
                    "text": "Node.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of theirexportsobject, allowing the entire module contents to be accessed with a default import from ESM:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: export.cjsmodule.exports= {hello:\"world\"};// @Filename: import.mjsimportgreetingfrom\"./export.cjs\";greeting.hello;// \"world\""
                },
                {
                    "type": "p",
                    "text": "That’s one win for seamless migration! Unfortunately, the similarities mostly end there."
                },
                {
                    "type": "p",
                    "text": "Node.js wasn’t able to respect the__esModulemarker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/dependency/index.jsexports.__esModule=true;exports.default=functiondoSomething() {/*...*/}// @Filename: transpile-vs-run-directly.{js/mjs}importdoSomethingfrom\"dependency\";// Works after transpilation, but not a function in Node.js ESM:doSomething();// Doesn't exist after trasnpilation, but works in Node.js ESM:doSomething.default();"
                },
                {
                    "type": "p",
                    "text": "While the transpiled default import only makes the synthetic default export if the target module lacks an__esModuleflag, Node.jsalwayssynthesizes a default export, creating a “double default” on the transpiled module."
                },
                {
                    "type": "p",
                    "text": "In addition to making a CommonJS module’sexportsobject available as a default import, Node.js attempts to find properties ofexportsto make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js usessyntactic analysisto synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: named-exports.cjsexports.hello=\"world\";exports[\"worl\"+\"d\"] =\"hello\";// @Filename: transpile-vs-run-directly.{js/mjs}import{hello,world}from\"./named-exports.cjs\";// `hello` works, but `world` is missing in Node.js 💥importmodfrom\"./named-exports.cjs\";mod.world;// Accessing properties from the default always works ✅"
                },
                {
                    "type": "p",
                    "text": "True CommonJS modules canrequirean ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js,requirecrashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/dependency/index.jsexportfunctiondoSomething() {/* ... */}// @Filename: dependent.jsimport{doSomething}from\"dependency\";// ✅ Works if dependent and dependency are both transpiled// ✅ Works if dependent and dependency are both true ESM// ✅ Works if dependent is true ESM and dependency is transpiled// 💥 Crashes if dependent is transpiled and dependency is true ESM"
                },
                {
                    "type": "p",
                    "text": "Node.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolvingrequirecalls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: add.jsexportfunctionadd(a,b) {returna+b;}// @Filename: math.jsexport*from\"./add\";//            ^^^^^^^// Works when transpiled to CJS,// but would have to be \"./add.js\"// in Node.js ESM."
                },
                {
                    "type": "p",
                    "text": "Clearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?"
                },
                {
                    "type": "p",
                    "text": "Since interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of themodulecompiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unlessmoduleis set tonode16ornodenext.)"
                },
                {
                    "type": "p",
                    "text": "In a TypeScriptapplication(as opposed to a library that others may consume) wheretscis used to emit JavaScript files, whetheresModuleInteropis enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leavingesModuleInteropdisabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future. In an application that gets processed by a third-party transpiler or bundler, on the other hand, enablingesModuleInteropis more important. All major bundlers and transpilers use anesModuleInterop-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files thattscwould emit, so even if another tool is being used in place oftsc, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.) allowSyntheticDefaultImportswithoutesModuleInteropshould be avoided. It changes the compiler’s checking behavior without changing the code emitted bytsc, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced byesModuleInterop. Even iftscisn’t being used for emit, it’s better to enableesModuleInteropthanallowSyntheticDefaultImports. Some people object to the inclusion of the__importDefaultand__importStarhelper functions included intsc’s JavaScript output whenesModuleInteropis enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for__esModule, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited withesModuleInteropdisabled. First, theimportHelperscompiler option can be used to import the helper functions fromtslibrather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/transpiled-dependency/index.jsexports.__esModule=true;exports.default=functiondoSomething() {/* ... */};exports.something=\"something\";// @Filename: node_modules/true-cjs-dependency/index.jsmodule.exports=functiondoSomethingElse() {/* ... */};// @Filename: src/sayHello.tsexportdefaultfunctionsayHello() {/* ... */}exportconsthello=\"hello\";// @Filename: src/main.tsimportdoSomethingfrom\"transpiled-dependency\";importdoSomethingElsefrom\"true-cjs-dependency\";importsayHellofrom\"./sayHello.js\";"
                },
                {
                    "type": "p",
                    "text": "Assume we’re compilingsrcto CommonJS for use in Node.js. WithoutallowSyntheticDefaultImportsoresModuleInterop, the import ofdoSomethingElsefrom\"true-cjs-dependency\"is an error, and the others are not. To fix the error without changing any compiler options, you could change the import toimport doSomethingElse = require(\"true-cjs-dependency\"). However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. WithesModuleInterop, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught. What would change if we decided to migratesrcto true ESM in Node.js (say, add\"type\": \"module\"to our root package.json)? The first import,doSomethingfrom\"transpiled-dependency\", would no longer be callable—it exhibits the “double default” problem, where we’d have to calldoSomething.default()rather thandoSomething(). (TypeScript understands and catches this under--module node16andnodenext.) But notably, thesecondimport ofdoSomethingElse, which neededesModuleInteropto work when compiling to CommonJS, works fine in true ESM. If there’s something to complain about here, it’s not whatesModuleInteropdoes with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is thatesModuleInteropseems to fail at giving us a seamless migration path for thefirstimport. But this problem was not introduced by enablingesModuleInterop; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract betweenmain.tsandsayHello.ts, because the CommonJS output ofsayHello.tslooks structurally identical totranspiled-dependency/index.js. IfesModuleInteropchanged the way the transpiled import ofdoSomethingworks to be identical to the way it would work in Node.js ESM, it would change the behavior of thesayHelloimport in the same way, making the input code violate ESM semantics (thus still preventing thesrcdirectory from being migrated to ESM without changes). As we’ve seen, there is no seamless migration path from transpiled modules to true ESM. ButesModuleInteropis one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enablingverbatimModuleSyntaxis a better choice than disablingesModuleInterop.verbatimModuleSyntaxenforces that theimport mod = require(\"mod\")andexport = nssyntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM."
                },
                {
                    "type": "p",
                    "text": "Libraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS bytsc, is accessible in Node.js as the default property of a default import:"
                },
                {
                    "type": "code",
                    "code": "jsimportpkgfrom\"pkg\";pkg.default();"
                },
                {
                    "type": "p",
                    "text": "in most bundlers or transpiled ESM as the default import itself:"
                },
                {
                    "type": "code",
                    "code": "jsimportpkgfrom\"pkg\";pkg();"
                },
                {
                    "type": "p",
                    "text": "and in vanilla CommonJS as the default property of arequirecall:"
                },
                {
                    "type": "code",
                    "code": "jsconstpkg=require(\"pkg\");pkg.default();"
                },
                {
                    "type": "p",
                    "text": "Users will detect a misconfigured module smell if they have to access the.defaultproperty of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (.d.ts) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should useexport =for modules that have a single main export, or named exports for modules that have multiple exports:"
                },
                {
                    "type": "code",
                    "code": "diff- export default function doSomething() { /* ... */ }+ export = function doSomething() { /* ... */ }"
                },
                {
                    "type": "p",
                    "text": "Libraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully whenstrictNullChecksis disabled. If a library were to publish types like that, it would force all their users to disablestrictNullCheckstoo.esModuleInteropcan allow type declarations to contain similarly “infectious” default imports:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: /node_modules/dependency/index.d.tsimportexpressfrom\"express\";declarefunctiondoSomething(req:express.Request):any;export=doSomething;"
                },
                {
                    "type": "p",
                    "text": "Suppose this default importonlyworks withesModuleInteropenabled, and causes an error when a user without that option references this file. The user shouldprobablyenableesModuleInteropanyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:"
                },
                {
                    "type": "code",
                    "code": "tsimportexpress=require(\"express\");// ..."
                },
                {
                    "type": "p",
                    "text": "Examples like this have led to conventional wisdom that says libraries shouldnotenableesModuleInterop. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentiallyintroducingan error, when enablingesModuleInterop. So whether libraries compile with or withoutesModuleInterop, they run the risk of writing syntax that makes their choice infectious. Library authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But usingverbatimModuleSyntaxcompletely sidesteps the issue withesModuleInteropby forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, sinceesModuleInteroponly affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html",
            "title": "TypeScript: Documentation - Modules - Choosing Compiler Options",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "A single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected withproject references. Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “I’m writing a library” section."
                },
                {
                    "type": "p",
                    "text": "In addition to adopting the following settings, it’s also recommendednotto set{ \"type\": \"module\" }or use.mtsfiles in bundler projects for now.Some bundlersadopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with\"moduleResolution\": \"bundler\". Seeissue #54102for more information."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Required\"module\":\"esnext\",\"moduleResolution\":\"bundler\",\"esModuleInterop\":true,// Consult your bundler’s documentation\"customConditions\": [\"module\"],// Recommended\"noEmit\":true,// or `emitDeclarationOnly`\"allowImportingTsExtensions\":true,\"allowArbitraryExtensions\":true,\"verbatimModuleSyntax\":true,// or `isolatedModules`}}"
                },
                {
                    "type": "p",
                    "text": "Remember to set\"type\": \"module\"or use.mtsfiles if you intend to emit ES modules."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Required\"module\":\"nodenext\",// Implied by `\"module\": \"nodenext\"`:// \"moduleResolution\": \"nodenext\",// \"esModuleInterop\": true,// \"target\": \"esnext\",// Recommended\"verbatimModuleSyntax\":true,}}"
                },
                {
                    "type": "p",
                    "text": "ts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used tocompile and run the JS outputs in Node.js. Refer tots-node documentationfor more details."
                },
                {
                    "type": "p",
                    "text": "Whereas ts-node makes minimal modifications to Node.js’s module system by default,tsxbehaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as youwould for a bundler."
                },
                {
                    "type": "p",
                    "text": "TypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of thenodenextESM module resolution algorithm andpathsas a substitute for URL and import map support."
                },
                {
                    "type": "code",
                    "code": "json// tsconfig.json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Combined with `\"type\": \"module\"` in a local package.json,// this enforces including file extensions on relative path imports.\"module\":\"nodenext\",\"paths\": {// Point TS to local types for remote URLs:\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],// Optional: point bare specifier imports to an empty file// to prohibit importing from node_modules specifiers not listed here:\"*\": [\"./empty-file.ts\"]}}}"
                },
                {
                    "type": "p",
                    "text": "This setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node_modules:"
                },
                {
                    "type": "code",
                    "code": "tsimport{}from\"lodash\";//             ^^^^^^^^// File '/project/empty-file.ts' is not a module. ts(2306)"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can useimport mapsto explicitly map a list of bare specifiers to URLs in the browser, while relying onnodenext’s default node_modules lookups, or onpaths, to direct TypeScript to type declaration files for those bare specifier imports:"
                },
                {
                    "type": "code",
                    "code": "html<scripttype=\"importmap\">{\"imports\": {\"lodash\": \"https://esm.sh/lodash@4.17.21\"}}</script>"
                },
                {
                    "type": "code",
                    "code": "tsimport{}from\"lodash\";// Browser: https://esm.sh/lodash@4.17.21// TypeScript: ./node_modules/@types/lodash/index.d.ts"
                },
                {
                    "type": "p",
                    "text": "Choosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code underall possiblelibrary consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"node16\",\"target\":\"es2020\",// set to the *lowest* target you support\"strict\":true,\"verbatimModuleSyntax\":true,\"declaration\":true,\"sourceMap\":true,\"declarationMap\":true}}"
                },
                {
                    "type": "p",
                    "text": "Let’s examine why we picked each of these settings:"
                },
                {
                    "type": "list",
                    "items": [
                        "module: \"node16\". When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set\"type\": \"module\"in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with\"moduleResolution\": \"bundler\":tsexport*from\"./utils\";Assuming./utils.ts(or./utils/index.ts) exists, a bundler would be fine with this code, so\"moduleResolution\": \"bundler\"doesn’t complain. Compiled with\"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.jsDid you mean to import ./utils.js?On the other hand, if we had written:tsexport*from\"./utils.js\";This would produce output that works both in Node.jsandin bundlers.In short,\"moduleResolution\": \"bundler\"is infectious, allowing code that only works in bundlers to be produced. Likewise,\"moduleResolution\": \"nodenext\"is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.",
                        "target: \"es2020\". Setting this value to thelowestECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Sincetargetalso implies a corresponding value forlib, this also ensures you don’t access globals that may not be available in older environments.",
                        "strict: true. Without this, you may write type-level code that ends up in your output.d.tsfiles and errors when a consumer compiles withstrictenabled. For example, thisextendsclause:tsexportinterfaceSuper{foo:string;}exportinterfaceSubextendsSuper{foo:string|undefined;}is only an error understrictNullChecks. On the other hand, it’s very difficult to write code that errors only whenstrictisdisabled, so it’s highly recommended for libraries to compile withstrict.",
                        "verbatimModuleSyntax: true. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value ofesModuleInteroporallowSyntheticDefaultImports. Previously, it was often suggested that libraries compile withoutesModuleInterop, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only workwithoutesModuleInterop, so neither value for the setting guarantees portability for libraries.verbatimModuleSyntaxdoes provide such a guarantee.1Second, it prevents the use ofexport defaultin modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix onESM/CJS Interopfor more details.",
                        "declaration: trueemits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.",
                        "sourceMap: trueanddeclarationMap: trueemit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (.ts) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use\"module\": \"esnext\"and\"moduleResolution\": \"bundler\", but only with two caveats:"
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with\"moduleResolution\": \"bundler\"and externalized imports with\"moduleResolution\": \"nodenext\"(or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using\"moduleResolution\": \"bundler\"may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using\"moduleResolution\": \"nodenext\"may impose overly strict requirements on bundled imports.",
                        "You must ensure that your declaration files get bundled as well. Recall thefirst rule of declaration files: every declaration file represents exactly one JavaScript file. If you use\"moduleResolution\": \"bundler\"and use a bundler to emit an ESM bundle while usingtscto emit many individual declaration files, your declaration files may cause errors when consumed under\"module\": \"nodenext\". For example, an input file like:tsimport{Component}from\"./extensionless-relative-import\";will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencingComponentwithany, assuming the dependency will crash at runtime.If your TypeScript bundler does not produce bundled declaration files, use\"moduleResolution\": \"nodenext\"to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library."
                    ]
                },
                {
                    "type": "p",
                    "text": "A single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even iftscisn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination withtsctype checking as long astsccan be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests andstatic analysisagainst all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed."
                },
                {
                    "type": "list",
                    "items": [
                        "verbatimModuleSyntaxcan only work when the JS emitter emits the same module kind astscwould given the tsconfig.json, source file extension, and package.json\"type\". The option works by enforcing that theimport/requirewritten is identical to theimport/requireemitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible withverbatimModuleSyntax, since its whole purpose is to prevent you from writingimportanywhere that arequirewould be emitted.verbatimModuleSyntaxcan also be defeated by configuring a third-party emitter to emit a different module kind thantscwould—for example, by setting\"module\": \"esnext\"in tsconfig.json while configuring Babel to emit CommonJS.↩"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/introduction.html",
            "title": "TypeScript: Documentation - Modules - Introduction",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "This document is divided into four sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "The first section develops thetheorybehind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.",
                        "Theguidesshow how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.",
                        "Thereferencesection provides a more detailed look at the syntaxes and configurations presented in previous sections.",
                        "Theappendicescover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/reference.html",
            "title": "TypeScript: Documentation - Modules - Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler recognizes standardECMAScript module syntaxin TypeScript and JavaScript files and many forms ofCommonJS syntaxin JavaScript files. There are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments."
                },
                {
                    "type": "p",
                    "text": "Type aliases, interfaces, enums, and namespaces can be exported from a module with anexportmodifier, like any standard JavaScript declaration:"
                },
                {
                    "type": "code",
                    "code": "ts// Standard JavaScript syntax...exportfunctionf() {}// ...extended to type declarationsexporttypeSomeType=/* ... */;exportinterfaceSomeInterface{/* ... */}"
                },
                {
                    "type": "p",
                    "text": "They can also be referenced in named exports, even alongside references to standard JavaScript declarations:"
                },
                {
                    "type": "code",
                    "code": "tsexport{f,SomeType,SomeInterface};"
                },
                {
                    "type": "p",
                    "text": "Exported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:"
                },
                {
                    "type": "code",
                    "code": "tsimport{f,SomeType,SomeInterface}from\"./module.js\";"
                },
                {
                    "type": "p",
                    "text": "When using namespace imports or exports, exported types are available on the namespace when referenced in a type position:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmodfrom\"./module.js\";mod.f();mod.SomeType;// Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'letx:mod.SomeType;// Ok"
                },
                {
                    "type": "p",
                    "text": "When emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written withimport type, export declarations written withexport type { ... }, and import or export specifiers prefixed with thetypekeyword are all guaranteed to be elided from the output JavaScript."
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimport{f,typeSomeInterface}from\"./module.js\";importtype{SomeType}from\"./module.js\";classCimplementsSomeInterface{constructor(p:SomeType) {f();}}exporttype{C};// @Filename: main.jsimport{f}from\"./module.js\";classC{constructor(p) {f();}}"
                },
                {
                    "type": "p",
                    "text": "Even values can be imported withimport type, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:"
                },
                {
                    "type": "code",
                    "code": "tsimporttype{f}from\"./module.js\";f();// 'f' cannot be used as a value because it was imported using 'import type'letotherFunction:typeoff= ()=>{};// Ok"
                },
                {
                    "type": "p",
                    "text": "A type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whethertypeapplies to the default import or to the entire import declaration. Instead, split the import declaration into two, or usedefaultas a named binding:"
                },
                {
                    "type": "code",
                    "code": "tsimporttypefs, {BigIntOptions}from\"fs\";//          ^^^^^^^^^^^^^^^^^^^^^// Error: A type-only import can specify a default import or named bindings, but not both.importtype{defaultasfs,BigIntOptions}from\"fs\";// Ok"
                },
                {
                    "type": "p",
                    "text": "TypeScript provides a type syntax similar to JavaScript’s dynamicimportfor referencing the type of a module without writing an import declaration:"
                },
                {
                    "type": "code",
                    "code": "ts// Access an exported type:typeWriteFileOptions=import(\"fs\").WriteFileOptions;// Access the type of an exported value:typeWriteFileFunction=typeofimport(\"fs\").writeFile;"
                },
                {
                    "type": "p",
                    "text": "This is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:"
                },
                {
                    "type": "code",
                    "code": "ts/**@type{import(\"webpack\").Configuration}*/module.exports= {// ...}"
                },
                {
                    "type": "p",
                    "text": "When emitting CommonJS modules, TypeScript files can use a direct analog ofmodule.exports = ...andconst mod = require(\"...\")JavaScript syntax:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportfs=require(\"fs\");export=fs.readFileSync(\"...\");// @Filename: main.js\"use strict\";constfs=require(\"fs\");module.exports=fs.readFileSync(\"...\");"
                },
                {
                    "type": "p",
                    "text": "This syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsinterfaceOptions{/* ... */}module.exports=Options;// Error: 'Options' only refers to a type, but is being used as a value here.export=Options;// Ok// @Filename: b.tsconstOptions=require(\"./a\");constoptions:Options= {/* ... */};// Error: 'Options' refers to a value, but is being used as a type here.// @Filename: c.tsimportOptions=require(\"./a\");constoptions:Options= {/* ... */};// Ok"
                },
                {
                    "type": "p",
                    "text": "TypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. Theseambient modulesusually represent runtime-provided modules, like\"fs\"or\"path\"in Node.js:"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"path\"{exportfunctionnormalize(p:string):string;exportfunctionjoin(...paths:any[]):string;exportvarsep:string;}"
                },
                {
                    "type": "p",
                    "text": "Once an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:"
                },
                {
                    "type": "code",
                    "code": "ts// 👇 Ensure the ambient module is loaded -//    may be unnecessary if path.d.ts is included//    by the project tsconfig.json somehow.///<referencepath=\"path.d.ts\"/>import{normalize,join}from\"path\";"
                },
                {
                    "type": "p",
                    "text": "Ambient module declarations are easy to confuse withmodule augmentationssince they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-levelimportorexportstatement (or is affected by--moduleDetection forceorauto):"
                },
                {
                    "type": "code",
                    "code": "ts// Not an ambient module declaration anymore!export{};declaremodule\"path\"{exportfunctionnormalize(p:string):string;exportfunctionjoin(...paths:any[]):string;exportvarsep:string;}"
                },
                {
                    "type": "p",
                    "text": "Ambient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"m\"{// Moving this outside \"m\" would totally change the meaning of the file!import{SomeType}from\"other\";exportfunctionf():SomeType;}"
                },
                {
                    "type": "p",
                    "text": "Apatternambient module contains a single*wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"*.html\"{constcontent:string;exportdefaultcontent;}"
                },
                {
                    "type": "p",
                    "text": "This section discusses the details of eachmodulecompiler option value. See theModule output formattheory section for more background on what the option is and how it fits into the overall compilation process. In brief, themodulecompiler option was historically only used to control the output module format of emitted JavaScript files. The more recentnode16andnodenextvalues, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate."
                },
                {
                    "type": "p",
                    "text": "Node.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate.node16andnodenextdescribe the full range of behavior for Node.js’s dual-format module system, andemit files in either CommonJS or ESM format. This is different from every othermoduleoption, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime."
                },
                {
                    "type": "p",
                    "text": "A common misconception is thatnode16andnodenextonly emit ES modules. In reality,node16andnodenextdescribe versions of Node.js thatsupportES modules, not just projects thatuseES modules. Both ESM and CommonJS emit are supported, based on thedetected module formatof each file. Becausenode16andnodenextare the onlymoduleoptions that reflect the complexities of Node.js’s dual module system, they are theonly correctmoduleoptionsfor all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not."
                },
                {
                    "type": "p",
                    "text": "node16andnodenextare currently identical, with the exception that theyimply differenttargetoption values. If Node.js makes significant changes to its module system in the future,node16will be frozen whilenodenextwill be updated to reflect the new behavior."
                },
                {
                    "type": "list",
                    "items": [
                        ".mts/.mjs/.d.mtsfiles are always ES modules.",
                        ".cts/.cjs/.d.ctsfiles are always CommonJS modules.",
                        ".ts/.tsx/.js/.jsx/.d.tsfiles are ES modules if the nearest ancestor package.json file contains\"type\": \"module\", otherwise CommonJS modules."
                    ]
                },
                {
                    "type": "p",
                    "text": "The detected module format of input.ts/.tsx/.mts/.ctsfiles determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of.tsfiles will emit all CommonJS modules by default under--module nodenext, and can be made to emit all ES modules by adding\"type\": \"module\"to the project package.json."
                },
                {
                    "type": "list",
                    "items": [
                        "When an ES module references a CommonJS module:Themodule.exportsof the CommonJS module is available as a default import to the ES module.Properties (other thandefault) of the CommonJS module’smodule.exportsmay or may not be available as named imports to the ES module. Node.js attempts to make them available viastatic analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See#54018for more details.",
                        "Themodule.exportsof the CommonJS module is available as a default import to the ES module.",
                        "Properties (other thandefault) of the CommonJS module’smodule.exportsmay or may not be available as named imports to the ES module. Node.js attempts to make them available viastatic analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See#54018for more details.",
                        "When a CommonJS module references an ES module:requirecannot reference an ES module. For TypeScript, this includesimportstatements in files that aredetectedto be CommonJS modules, since thoseimportstatements will be transformed torequirecalls in the emitted JavaScript.A dynamicimport()call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get fromimport * as ns from \"./module.js\"from another ES module).",
                        "requirecannot reference an ES module. For TypeScript, this includesimportstatements in files that aredetectedto be CommonJS modules, since thoseimportstatements will be transformed torequirecalls in the emitted JavaScript.",
                        "A dynamicimport()call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get fromimport * as ns from \"./module.js\"from another ES module)."
                    ]
                },
                {
                    "type": "p",
                    "text": "The emit format of each file is determined by thedetected module formatof each file. ESM emit is similar to--module esnext, but has a special transformation forimport x = require(\"...\"), which is not allowed in--module esnext:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx=require(\"mod\");"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsimport{createRequireas_createRequire}from\"module\";const__require=_createRequire(import.meta.url);constx=__require(\"mod\");"
                },
                {
                    "type": "p",
                    "text": "CommonJS emit is similar to--module commonjs, but dynamicimport()calls are not transformed. Emit here is shown withesModuleInteropenabled:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportfsfrom\"fs\";// transformedconstdynamic=import(\"mod\");// not transformed"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";var__importDefault= (this&&this.__importDefault) ||function(mod) {return(mod&&mod.__esModule) ?mod: {\"default\":mod};};Object.defineProperty(exports,\"__esModule\", {value:true});constfs_1=__importDefault(require(\"fs\"));// transformedconstdynamic=import(\"mod\");// not transformed"
                },
                {
                    "type": "list",
                    "items": [
                        "--module nodenextornode16implies and enforces themoduleResolutionwith the same name.",
                        "--module nodenextimplies--target esnext.",
                        "--module node16implies--target es2022.",
                        "--module nodenextornode16implies--esModuleInterop."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "node16andnodenextare the only correctmoduleoptions for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.",
                        "node16andnodenextemit files in either CommonJS or ESM format, based on thedetected module formatof each file.",
                        "Node.js’s interoperability rules between ESM and CJS are reflected in type checking.",
                        "ESM emit transformsimport x = require(\"...\")to arequirecall constructed from acreateRequireimport.",
                        "CommonJS emit leaves dynamicimport()calls untransformed, so CommonJS modules can asynchronously import ES modules."
                    ]
                },
                {
                    "type": "p",
                    "text": "In--module preserve(addedin TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-styleimport x = require(\"...\")andexport = ...statements are emitted as CommonJSrequireandmodule.exports. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file). While it’s rare to need to mix imports and require calls in the same file, thismodulemode best reflects the capabilities of most modern bundlers, as well as the Bun runtime."
                },
                {
                    "type": "p",
                    "text": "Why care about TypeScript’smoduleemit with a bundler or with Bun, where you’re likely also settingnoEmit? TypeScript’s type checking and module resolution behavior are affected by the module format that itwouldemit. Settingmodulegives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See--moduleResolution bundlerfor more discussion."
                },
                {
                    "type": "code",
                    "code": "tsimportx, {y,z}from\"mod\";importmod=require(\"mod\");constdynamic=import(\"mod\");exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "jsimportx, {y,z}from\"mod\";constmod=require(\"mod\");constdynamic=import(\"mod\");exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "list",
                    "items": [
                        "--module preserveimplies--moduleResolution bundler.",
                        "--module preserveimplies--esModuleInterop."
                    ]
                },
                {
                    "type": "p",
                    "text": "The option--esModuleInteropis enabled by default in--module preserveonly for itstype checkingbehavior. Since imports never transform into require calls in--module preserve,--esModuleInteropdoes not affect the emitted JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "Useesnextwith--moduleResolution bundlerfor bundlers, Bun, and tsx.",
                        "Do not use for Node.js. Usenode16ornodenextwith\"type\": \"module\"in package.json to emit ES modules for Node.js.",
                        "import mod = require(\"mod\")is not allowed in non-declaration files.",
                        "es2020adds support forimport.metaproperties.",
                        "es2022adds support for top-levelawait.",
                        "esnextis a moving target that may include support for Stage 3 proposals to ECMAScript modules.",
                        "Emitted files are ES modules, but dependencies may be any format."
                    ]
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "list",
                    "items": [
                        "You probably shouldn’t use this. Usenode16ornodenextto emit CommonJS modules for Node.js.",
                        "Emitted files are CommonJS modules, but dependencies may be any format.",
                        "Dynamicimport()is transformed to a Promise of arequire()call.",
                        "esModuleInteropaffects the output code for default and namespace imports."
                    ]
                },
                {
                    "type": "p",
                    "text": "Output is shown withesModuleInterop: false."
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constmod_1=require(\"mod\");constmod=require(\"mod\");constdynamic=Promise.resolve().then(()=>require(\"mod\"));console.log(mod_1.default,mod_1.y,mod_1.z,mod);exports.e1=0;exports.default=\"default export\";"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportmod=require(\"mod\");console.log(mod);export= {p1:true,p2:false};"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";constmod=require(\"mod\");console.log(mod);module.exports= {p1:true,p2:false};"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for use with theSystemJS module loader."
                    ]
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsSystem.register([\"mod\"],function(exports_1,context_1) {\"use strict\";varmod_1,mod,dynamic,e1;var__moduleName=context_1&&context_1.id;return{setters:[function(mod_1_1) {mod_1=mod_1_1;mod=mod_1_1;}],execute:function() {dynamic=context_1.import(\"mod\");console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports_1(\"e1\",e1=0);exports_1(\"default\",\"default export\");}};});"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for AMD loaders like RequireJS.",
                        "You probably shouldn’t use this. Use a bundler instead.",
                        "Emitted files are AMD modules, but dependencies may be any format.",
                        "SupportsoutFile."
                    ]
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsdefine([\"require\",\"exports\",\"mod\",\"mod\"],function(require,exports,mod_1,mod) {\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constdynamic=newPromise((resolve_1,reject_1)=>{require([\"mod\"],resolve_1,reject_1); });console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports.e1=0;exports.default=\"default export\";});"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for AMD or CommonJS loaders.",
                        "Does not expose a global variable like most other UMD wrappers.",
                        "You probably shouldn’t use this. Use a bundler instead.",
                        "Emitted files are UMD modules, but dependencies may be any format."
                    ]
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js(function(factory) {if(typeofmodule===\"object\"&&typeofmodule.exports===\"object\") {varv=factory(require,exports);if(v!==undefined)module.exports=v;}elseif(typeofdefine===\"function\"&&define.amd) {define([\"require\",\"exports\",\"mod\",\"mod\"],factory);}})(function(require,exports) {\"use strict\";var__syncRequire=typeofmodule===\"object\"&&typeofmodule.exports===\"object\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constmod_1=require(\"mod\");constmod=require(\"mod\");constdynamic=__syncRequire?Promise.resolve().then(()=>require(\"mod\")) :newPromise((resolve_1,reject_1)=>{require([\"mod\"],resolve_1,reject_1); });console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports.e1=0;exports.default=\"default export\";});"
                },
                {
                    "type": "p",
                    "text": "This section describes module resolution features and processes shared by multiplemoduleResolutionmodes, then specifies the details of each mode. See theModule resolutiontheory section for more background on what the option is and how it fits into the overall compilation process. In brief,moduleResolutioncontrols how TypeScript resolvesmodule specifiers(string literals inimport/export/requirestatements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler."
                },
                {
                    "type": "p",
                    "text": "TypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to themoduleResolutionalgorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension."
                },
                {
                    "type": "p",
                    "text": "Note that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a.tsor.d.tsfile even if the module specifier explicitly uses a.jsfile extension:"
                },
                {
                    "type": "code",
                    "code": "tsimportxfrom\"./mod.js\";// Runtime lookup: \"./mod.js\"// TypeScript lookup #1: \"./mod.ts\"// TypeScript lookup #2: \"./mod.d.ts\"// TypeScript lookup #3: \"./mod.js\""
                },
                {
                    "type": "p",
                    "text": "SeeTypeScript imitates the host’s module resolution, but with typesfor an explanation of why TypeScript’s module resolution works this way."
                },
                {
                    "type": "p",
                    "text": "All of TypeScript’smoduleResolutionalgorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to therules above):"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsexport{};// @Filename: b.tsimport{}from\"./a.js\";// ✅ Works in every `moduleResolution`"
                },
                {
                    "type": "p",
                    "text": "In some cases, the runtime or bundler allows omitting a.jsfile extension from a relative path. TypeScript supports this behavior where themoduleResolutionsetting and the context indicate that the runtime or bundler supports it:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsexport{};// @Filename: b.tsimport{}from\"./a\";"
                },
                {
                    "type": "p",
                    "text": "If TypeScript determines that the runtime will perform a lookup for./a.jsgiven the module specifier\"./a\", then./a.jswill undergoextension substitution, and resolve to the filea.tsin this example. Extensionless relative paths are not supported inimportpaths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a.mjs/.mtsor.cjs/.ctsfile extension, even though some runtimes and bundlers do."
                },
                {
                    "type": "p",
                    "text": "In some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for anindex.jsfile in a directory. TypeScript supports this behavior where themoduleResolutionsetting and the context indicate that the runtime or bundler supports it:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: dir/index.tsexport{};// @Filename: b.tsimport{}from\"./dir\";"
                },
                {
                    "type": "p",
                    "text": "If TypeScript determines that the runtime will perform a lookup for./dir/index.jsgiven the module specifier\"./dir\", then./dir/index.jswill undergoextension substitution, and resolve to the filedir/index.tsin this example. Directory modules may also contain a package.json file, where resolution of the\"main\"and\"types\"fields are supported, and take precedence overindex.jslookups. The\"typesVersions\"field is also supported in directory modules. Note that directory modules are not the same asnode_modulespackagesand only support a subset of the features available to packages, and are not supported at all in some contexts.  Node.js considers them alegacy feature."
                },
                {
                    "type": "p",
                    "text": "TypeScript offers a way to override the compiler’s module resolution for bare specifiers with thepathscompiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with--experimental-network-imports, you can manually specify a local type definition file for a specifichttps://import:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"nodenext\",\"paths\": {\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]}}}"
                },
                {
                    "type": "code",
                    "code": "ts// Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entryimport{add}from\"https://esm.sh/lodash@4.17.21\";"
                },
                {
                    "type": "p",
                    "text": "It’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases withpaths:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"esnext\",\"moduleResolution\":\"bundler\",\"paths\": {\"@app/*\": [\"./src/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "Thepathsoption doesnotchange the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"nodenext\",\"paths\": {\"node-has-no-idea-what-this-is\": [\"./oops.ts\"]}}}"
                },
                {
                    "type": "code",
                    "code": "ts// TypeScript: ✅// Node.js: 💥import{}from\"node-has-no-idea-what-this-is\";"
                },
                {
                    "type": "p",
                    "text": "While it’s ok for bundled apps to set uppaths, it’s very important that published libraries donot, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can considerpackage.json\"imports\"as a standard replacement for conveniencepathsaliases."
                },
                {
                    "type": "p",
                    "text": "While module specifiers that matchpathsaliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen fornode_modulespackage lookups, including package.json\"exports\"field support, do not take effect when apathsalias is matched. This can lead to surprising behavior ifpathsis used to point to anode_modulespackage:"
                },
                {
                    "type": "code",
                    "code": "ts{\"compilerOptions\": {\"paths\":{\"pkg\":[\"./node_modules/pkg/dist/index.d.ts\"],\"pkg/*\":[\"./node_modules/pkg/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "While this configuration may simulate some of the behavior of package resolution, it overrides anymain,types,exports, andtypesVersionsthe package’spackage.jsonfile defines, and imports from the package may fail at runtime. The same caveat applies to packages referencing each other in a monorepo. Instead of usingpathsto make TypeScript artificially resolve\"@my-scope/lib\"to a sibling package, it’s best to use workspaces vianpm,yarn, orpnpmto symlink your packages intonode_modules, so both TypeScript and the runtime or bundler perform realnode_modulespackage lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other vianode_modulespackage lookups once installed by users, and using workspaces allows you to test that behavior during local development."
                },
                {
                    "type": "p",
                    "text": "WhenbaseUrlis provided, the values in eachpathsarray are resolved relative to thebaseUrl. Otherwise, they are resolved relative to thetsconfig.jsonfile that defines them."
                },
                {
                    "type": "p",
                    "text": "pathspatterns can contain a single*wildcard, which matches any string. The*token can then be used in the file path values to substitute the matched string:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"@app/*\": [\"./src/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "When resolving an import of\"@app/components/Button\", TypeScript will match on@app/*, binding*tocomponents/Button, and then attempt to resolve the path./src/components/Buttonrelative to thetsconfig.jsonpath. The remainder of this lookup will follow the same rules as any otherrelative path lookupaccording to themoduleResolutionsetting. When multiple patterns match a module specifier, the pattern with the longest matching prefix before any*token is used:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"*\": [\"./src/foo/one.ts\"],\"foo/*\": [\"./src/foo/two.ts\"],\"foo/bar\": [\"./src/foo/three.ts\"]}}}"
                },
                {
                    "type": "p",
                    "text": "When resolving an import of\"foo/bar\", all threepathspatterns match, but the last is used because\"foo/bar\"is longer than\"foo/\"and\"\"."
                },
                {
                    "type": "p",
                    "text": "Multiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"*\": [\"./vendor/*\",\"./types/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "baseUrlwas designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t usebaseUrl. Since TypeScript 4.1,baseUrlis no longer required to usepathsand should not be used just to set the directorypathsvalues are resolved from."
                },
                {
                    "type": "p",
                    "text": "ThebaseUrlcompiler option can be combined with anymoduleResolutionmode and specifies a directory that bare specifiers (module specifiers that don’t begin with./,../, or/) are resolved from.baseUrlhas a higher precedence thannode_modulespackage lookupsinmoduleResolutionmodes that support them. When performing abaseUrllookup, resolution proceeds with the same rules as other relative path resolutions. For example, in amoduleResolutionmode that supportsextensionless relative pathsa module specifier\"some-file\"may resolve to/src/some-file.tsifbaseUrlis set to/src. Resolution of relative module specifiers are never affected by thebaseUrloption."
                },
                {
                    "type": "p",
                    "text": "Node.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up innode_modulessubdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’smoduleResolutionoptions exceptclassicsupportnode_moduleslookups. (classicsupports lookups innode_modules/@typeswhen other means of resolution fail, but never looks for packages innode_modulesdirectly.) Everynode_modulespackage lookup has the following structure (beginning after higher precedence bare specifier rules, likepaths,baseUrl, self-name imports, and package.json\"imports\"lookups have been exhausted):"
                },
                {
                    "type": "list",
                    "items": [
                        "For each ancestor directory of the importing file, if anode_modulesdirectory exists within it:If a directory with the same name as the package exists withinnode_modules:Attempt to resolve types from the package directory.If a result is found, return it and stop the search.If a directory with the same name as the package exists withinnode_modules/@types:Attempt to resolve types from the@typespackage directory.If a result is found, return it and stop the search.",
                        "If a directory with the same name as the package exists withinnode_modules:Attempt to resolve types from the package directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the package directory.",
                        "If a result is found, return it and stop the search.",
                        "If a directory with the same name as the package exists withinnode_modules/@types:Attempt to resolve types from the@typespackage directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the@typespackage directory.",
                        "If a result is found, return it and stop the search.",
                        "Repeat the previous search through allnode_modulesdirectories, but this time, allow JavaScript files as a result, and do not search in@typesdirectories."
                    ]
                },
                {
                    "type": "p",
                    "text": "AllmoduleResolutionmodes (exceptclassic) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections."
                },
                {
                    "type": "p",
                    "text": "WhenmoduleResolutionis set tonode16,nodenext, orbundler, andresolvePackageJsonExportsis not disabled, TypeScript follows Node.js’spackage.json\"exports\"specwhen resolving from a package directory triggered by abare specifiernode_modulespackage lookup. TypeScript’s implementation for resolving a module specifier through\"exports\"to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will stilltry multiple file extensionsin order to prioritize finding types. When resolving throughconditional\"exports\", TypeScript always matches the\"types\"and\"default\"conditions if present. Additionally, TypeScript will match a versioned types condition in the form\"types@{selector}\"(where{selector}is a\"typesVersions\"-compatible version selector) according to the same version-matching rules implemented in\"typesVersions\". Other non-configurable conditions are dependent on themoduleResolutionmode and specified in the following sections. Additional conditions can be configured to match with thecustomConditionscompiler option. Note that the presence of\"exports\"prevents any subpaths not explicitly listed or matched by a pattern in\"exports\"from being resolved."
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"require\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\".\": {\"import\":\"./index.mjs\",\"require\":\"./index.cjs\"},\"./subpath\": {\"import\":\"./subpath/index.mjs\",\"require\":\"./subpath/index.cjs\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?No.",
                        "Does the second condition\"require\"match this request?Yes.",
                        "Does the path\"./subpath/index.cjs\"have a recognized TypeScript file extension?No, so use extension substitution.",
                        "Viaextension substitution, try the following paths, returning the first one that exists, orundefinedotherwise:./subpath/index.cts./subpath/index.d.cts./subpath/index.cjs",
                        "./subpath/index.cts",
                        "./subpath/index.d.cts",
                        "./subpath/index.cjs"
                    ]
                },
                {
                    "type": "p",
                    "text": "If./subpath/index.ctsor./subpath.d.ctsexists, resolution is complete. Otherwise, resolution searchesnode_modules/@types/pkgand othernode_modulesdirectories in an attempt to resolve types, according to thenode_modulespackage lookupsrules. If no types are found, a second pass through allnode_modulesresolves to./subpath/index.cjs(assuming it exists), which counts as a successful resolution, but one that does not provide types, leading toany-typed imports and anoImplicitAnyerror if enabled."
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\"./subpath\": {\"import\": {\"types\":\"./types/subpath/index.d.mts\",\"default\":\"./es/subpath/index.mjs\"},\"require\": {\"types\":\"./types/subpath/index.d.cts\",\"default\":\"./cjs/subpath/index.cjs\"}}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "The value atexports[\"./subpath\"].importis an object—it must be specifying conditions.",
                        "Does the first condition\"types\"match this request?Yes.",
                        "Does the path\"./types/subpath/index.d.mts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./types/subpath/index.d.mts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "Scenario: using TypeScript 4.7.5,\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\"./subpath\": {\"types@>=5.2\":\"./ts5.2/subpath/index.d.ts\",\"types@>=4.6\":\"./ts4.6/subpath/index.d.ts\",\"types\":\"./tsold/subpath/index.d.ts\",\"default\":\"./dist/subpath/index.js\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"types@>=5.2\"match this request?No, 4.7.5 is not greater than or equal to 5.2.",
                        "Does the second condition\"types@>=4.6\"match this request?Yes, 4.7.5 is greater than or equal to 4.6.",
                        "Does the path\"./ts4.6/subpath/index.d.ts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./ts4.6/subpath/index.d.ts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/wildcard.js\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"type\":\"module\",\"exports\": {\"./*.js\": {\"types\":\"./types/*.d.ts\",\"default\":\"./dist/*.js\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./wildcard.js\"entry?No.",
                        "Does any key with a*in it match\"./wildcard.js\"?Yes,\"./*.js\"matches and setswildcardto be the substitution.",
                        "The value atexports[\"./*.js\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"types\"match this request?Yes.",
                        "In./types/*.d.ts, replace*with the substitutionwildcard../types/wildcard.d.ts",
                        "Does the path\"./types/wildcard.d.ts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./types/wildcard.d.ts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/dist/index.js\"is requested in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"main\":\"./dist/index.js\",\"exports\":\"./dist/index.js\"}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "The value atexportsis a string—it must be a file path for the package root (\".\").",
                        "Is the request\"pkg/dist/index.js\"for the package root?No, it has a subpathdist/index.js.",
                        "Resolution fails; returnundefined."
                    ]
                },
                {
                    "type": "p",
                    "text": "Without\"exports\", the request could have succeeded, but the presence of\"exports\"prevents resolving any subpaths that cannot be matched through\"exports\"."
                },
                {
                    "type": "p",
                    "text": "Anode_modulespackageordirectory modulemay specify a\"typesVersions\"field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and fornode_modulespackages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool likedownlevel-dts).\"typesVersions\"is supported in allmoduleResolutionmodes; however, the field is not read in situations whenpackage.json\"exports\"are read."
                },
                {
                    "type": "p",
                    "text": "Scenario: a module imports\"pkg\"using TypeScript 5.2, wherenode_modules/pkg/package.jsonis:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.1\": {\"*\": [\"ts3.1/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "(Depending on compiler options) Does\"exports\"exist?No.",
                        "Does\"typesVersions\"exist?Yes.",
                        "Is the TypeScript version>=3.1?Yes. Remember the mapping\"*\": [\"ts3.1/*\"].",
                        "Are we resolving a subpath after the package name?No, just the root\"pkg\".",
                        "Does\"types\"exist?Yes.",
                        "Does any key in\"typesVersions\"match./index.d.ts?Yes,\"*\"matches and setsindex.d.tsto be the substitution.",
                        "Ints3.1/*, replace*with the substitution./index.d.ts:ts3.1/index.d.ts.",
                        "Does the path./ts3.1/index.d.tshave a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path./ts3.1/index.d.tsif the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "Scenario: a module imports\"pkg\"using TypeScript 3.9, wherenode_modules/pkg/package.jsonis:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\"<4.0\": {\"index.d.ts\": [\"index.v3.d.ts\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "(Depending on compiler options) Does\"exports\"exist?No.",
                        "Does\"typesVersions\"exist?Yes.",
                        "Is the TypeScript version<4.0?Yes. Remember the mapping\"index.d.ts\": [\"index.v3.d.ts\"].",
                        "Are we resolving a subpath after the package name?No, just the root\"pkg\".",
                        "Does\"types\"exist?Yes.",
                        "Does any key in\"typesVersions\"match./index.d.ts?Yes,\"index.d.ts\"matches.",
                        "Does the path./index.v3.d.tshave a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path./index.v3.d.tsif the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a directory’spackage.json\"exports\"field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as adirectory moduleinstead of anode_modulespackage) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"types\"",
                        "\"typings\"(legacy)",
                        "\"main\""
                    ]
                },
                {
                    "type": "p",
                    "text": "The declaration file found at\"types\"is assumed to be an accurate representation of the implementation file found at\"main\". If\"types\"and\"typings\"are not present or cannot be resolved, TypeScript will read the\"main\"field and performextension substitutionto find a declaration file. When publishing a typed package to npm, it’s recommended to include a\"types\"field even ifextension substitutionorpackage.json\"exports\"make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a\"types\"field."
                },
                {
                    "type": "p",
                    "text": "If neitherpackage.json\"exports\"norpackage.json\"typesVersions\"apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicablerelative pathresolution rules. In modes that respect [package.json\"exports\"], this behavior is blocked by the mere presence of the\"exports\"field in the package’s package.json, even if the import fails to resolve through\"exports\", as demonstrated inan example above. On the other hand, if the import fails to resolve through\"typesVersions\", a package-relative file path resolution is attempted as a fallback. When package-relative paths are supported, they resolve under the same rules as any other relative path considering themoduleResolutionmode and context. For example, in--moduleResolution nodenext,directory modulesandextensionless pathsare only supported inrequirecalls, not inimports:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: module.mtsimport\"pkg/dist/foo\";// ❌ import, needs `.js` extensionimport\"pkg/dist/foo.js\";// ✅importfoo=require(\"pkg/dist/foo\");// ✅ require, no extension needed"
                },
                {
                    "type": "p",
                    "text": "WhenmoduleResolutionis set tonode16,nodenext, orbundler, andresolvePackageJsonImportsis not disabled, TypeScript will attempt to resolve import paths beginning with#through the\"imports\"field of the nearest ancestor package.json of the importing file. Similarly, whenpackage.json\"exports\"lookupsare enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the\"name\"field of the nearest ancestor package.json of the importing file—through the\"exports\"field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path. TypeScript follows Node.js’s resolution algorithm for\"imports\"andself referencesexactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the\"imports\"or\"exports\"being resolved belongs to anode_modulesdependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):"
                },
                {
                    "type": "list",
                    "items": [
                        "If the package.json is innode_modules, TypeScript will applyextension substitutionto the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.",
                        "If the package.json is part of the local project, an additional remapping step is performed in order to find theinputTypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from\"imports\". Without this step, any compilation that resolves an\"imports\"path would be referencing output files from theprevious compilationinstead of other input files that are intended to be included in the current compilation. This remapping uses theoutDir/declarationDirandrootDirfrom the tsconfig.json, so using\"imports\"usually requires an explicitrootDirto be set."
                    ]
                },
                {
                    "type": "p",
                    "text": "This variation allows package authors to write\"imports\"and\"exports\"fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files."
                },
                {
                    "type": "p",
                    "text": "Scenario:\"/src/main.mts\"imports\"#utils\"with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:"
                },
                {
                    "type": "code",
                    "code": "json// tsconfig.json{\"compilerOptions\": {\"moduleResolution\":\"node16\",\"resolvePackageJsonImports\":true,\"rootDir\":\"./src\",\"outDir\":\"./dist\"}}"
                },
                {
                    "type": "code",
                    "code": "json// package.json{\"name\":\"pkg\",\"imports\": {\"#utils\": {\"import\":\"./dist/utils.d.mts\",\"require\":\"./dist/utils.d.cts\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "Import path starts with#, try to resolve through\"imports\".",
                        "Does\"imports\"exist in the nearest ancestor package.json?Yes.",
                        "Does\"#utils\"exist in the\"imports\"object?Yes.",
                        "The value atimports[\"#utils\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "Should we attempt to map the output path to an input path?Yes, because:Is the package.json innode_modules?No, it’s in the local project.Is the tsconfig.json within the package.json directory?Yes.",
                        "Is the package.json innode_modules?No, it’s in the local project.",
                        "Is the tsconfig.json within the package.json directory?Yes.",
                        "In./dist/utils.d.mts, replace theoutDirprefix withrootDir../src/utils.d.mts",
                        "Replace the output extension.d.mtswith the corresponding input extension.mts../src/utils.mts",
                        "Return the path\"./src/utils.mts\"if the file exists.",
                        "Otherwise, return the path\"./dist/utils.d.mts\"if the file exists."
                    ]
                },
                {
                    "type": "p",
                    "text": "Scenario:\"/node_modules/pkg/main.mts\"imports\"#internal/utils\"with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) with the package.json:"
                },
                {
                    "type": "code",
                    "code": "json// /node_modules/pkg/package.json{\"name\":\"pkg\",\"imports\": {\"#internal/*\": {\"import\":\"./dist/internal/*.mjs\",\"require\":\"./dist/internal/*.cjs\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "Import path starts with#, try to resolve through\"imports\".",
                        "Does\"imports\"exist in the nearest ancestor package.json?Yes.",
                        "Does\"#internal/utils\"exist in the\"imports\"object?No, check for pattern matches.",
                        "Does any key with a*match\"#internal/utils\"?Yes,\"#internal/*\"matches and setsutilsto be the substitution.",
                        "The value atimports[\"#internal/*\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "Should we attempt to map the output path to an input path?No, because the package.json is innode_modules.",
                        "In./dist/internal/*.mjs, replace*with the substitutionutils../dist/internal/utils.mjs",
                        "Does the path./dist/internal/utils.mjshave a recognized TypeScript file extension?No, try extension substitution.",
                        "Viaextension substitution, try the following paths, returning the first one that exists, orundefinedotherwise:./dist/internal/utils.mts./dist/internal/utils.d.mts./dist/internal/utils.mjs",
                        "./dist/internal/utils.mts",
                        "./dist/internal/utils.d.mts",
                        "./dist/internal/utils.mjs"
                    ]
                },
                {
                    "type": "p",
                    "text": "These modes reflect the module resolution behavior of Node.js v12 and later. (node16andnodenextare currently identical, but if Node.js makes significant changes to its module system in the future,node16will be frozen whilenodenextwill be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJSrequirecalls. For each module specifier being resolved, the syntax and themodule format of the importing fileare first used to determine whether the module specifier will be in animportorrequirein the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the\"import\"or\"require\"condition for package.json\"exports\"or\"imports\")."
                },
                {
                    "type": "p",
                    "text": "TypeScript files that aredetermined to be in CommonJS formatmay still useimportandexportsyntax by default, but the emitted JavaScript will userequireandmodule.exportsinstead. This means that it’s common to seeimportstatements that are resolved using therequirealgorithm. If this causes confusion, theverbatimModuleSyntaxcompiler option can be enabled, which prohibits the use ofimportstatements that would be emitted asrequirecalls."
                },
                {
                    "type": "p",
                    "text": "Note that dynamicimport()calls are always resolved using theimportalgorithm, according to Node.js’s behavior. However,import()types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: module.mtsimportxfrom\"./mod.js\";// `import` algorithm due to file format (emitted as-written)import(\"./mod.js\");// `import` algorithm due to syntax (emitted as-written)typeMod=typeofimport(\"./mod.js\");// `import` algorithm due to file formatimportmod=require(\"./mod\");// `require` algorithm due to syntax (emitted as `require`)// @Filename: commonjs.ctsimportxfrom\"./mod\";// `require` algorithm due to file format (emitted as `require`)import(\"./mod.js\");// `import` algorithm due to syntax (emitted as-written)typeMod=typeofimport(\"./mod\");// `require` algorithm due to file formatimportmod=require(\"./mod\");// `require` algorithm due to syntax (emitted as `require`)"
                },
                {
                    "type": "list",
                    "items": [
                        "--moduleResolution node16andnodenextmust be paired with theircorrespondingmodulevalue."
                    ]
                },
                {
                    "type": "p",
                    "text": "Features are listed in order of precedence."
                },
                {
                    "type": "p",
                    "text": "--moduleResolution bundlerattempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJSrequireresolution algorithm likenode_moduleslookups,directory modules, andextensionless paths, while also supporting newer Node.js resolution features likepackage.json\"exports\"andpackage.json\"imports\". It’s instructive to think about the similarities and differences between--moduleResolution bundlerand--moduleResolution nodenext, particularly in how they decide what conditions to use when resolving package.json\"exports\"or\"imports\". Consider an import statement in a.tsfile:"
                },
                {
                    "type": "code",
                    "code": "ts// index.tsimport{foo}from\"pkg\";"
                },
                {
                    "type": "p",
                    "text": "Recall that in--module nodenext --moduleResolution nodenext, the--modulesetting firstdetermineswhether the import will be emitted to the.jsfile as animportorrequirecall, then passes that information to TypeScript’s module resolver, which decides whether to match\"import\"or\"require\"conditions in\"pkg\"’s package.json\"exports\"accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is.ts, so the output file extension will be.js, which Node.js will interpret as CommonJS, so TypeScript will emit thisimportas arequirecall. So, the module resolver will use therequirecondition as it resolves\"exports\"from\"pkg\". The same process happens in--moduleResolution bundler, but the rules for deciding whether to emit animportorrequirecall for this import statement will be different, since--moduleResolution bundlernecessitates using--module esnextor--module preserve. In both of those modes, ESMimportdeclarations always emit as ESMimportdeclarations, so TypeScript’s module resolver will receive that information and use the\"import\"condition as it resolves\"exports\"from\"pkg\". This explanation may be somewhat unintuitive, since--moduleResolution bundleris usually used in combination with--noEmit—bundlers typically process raw.tsfiles and perform module resolution on untransformedimports orrequires. However, for consistency, TypeScript still uses the hypothetical emit decided bymoduleto inform module resolution and type checking. This makes--module preservethe best choice whenever a runtime or bundler is operating on raw.tsfiles, since it implies no transformation. Under--module preserve --moduleResolution bundler, you can write imports and requires in the same file that will resolve with theimportandrequireconditions, respectively:"
                },
                {
                    "type": "code",
                    "code": "ts// index.tsimportpkg1from\"pkg\";// Resolved with \"import\" conditionimportpkg2=require(\"pkg\");// Resolved with \"require\" condition"
                },
                {
                    "type": "list",
                    "items": [
                        "--moduleResolution bundlermust be paired with--module esnextor--module preserve.",
                        "--moduleResolution bundlerimplies--allowSyntheticDefaultImports."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "paths✅",
                        "baseUrl✅",
                        "node_modulespackage lookups✅",
                        "package.json\"exports\"✅ matchestypes,import/requiredepending on syntax",
                        "package.json\"imports\"and self-name imports✅ matchestypes,import/requiredepending on syntax",
                        "package.json\"typesVersions\"✅",
                        "Package-relative paths✅ whenexportsnot present",
                        "Full relative paths✅",
                        "Extensionless relative paths✅",
                        "Directory modules✅"
                    ]
                },
                {
                    "type": "p",
                    "text": "--moduleResolution nodewas renamed tonode10(keepingnodeas an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used."
                },
                {
                    "type": "list",
                    "items": [
                        "paths✅",
                        "baseUrl✅",
                        "node_modulespackage lookups✅",
                        "package.json\"exports\"❌",
                        "package.json\"imports\"and self-name imports❌",
                        "package.json\"typesVersions\"✅",
                        "Package-relative paths✅",
                        "Full relative paths✅",
                        "Extensionless relative paths✅",
                        "Directory modules✅"
                    ]
                },
                {
                    "type": "p",
                    "text": "Do not useclassic."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/theory.html",
            "title": "TypeScript: Documentation - Modules - Theory",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "In the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiplescripttags in HTML:"
                },
                {
                    "type": "code",
                    "code": "html<html><head><scriptsrc=\"a.js\"></script><scriptsrc=\"b.js\"></script></head><body></body></html>"
                },
                {
                    "type": "p",
                    "text": "This approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions. Any system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast withscriptfiles, which run outside a module system, in a global scope.)"
                },
                {
                    "type": "p",
                    "text": "There aremany module systems, and TypeScriptsupports emitting several, but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS). ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicatedimportandexportsyntax:"
                },
                {
                    "type": "code",
                    "code": "js// a.jsexportdefault\"Hello from a.js\";"
                },
                {
                    "type": "code",
                    "code": "js// b.jsimportafrom\"./a.js\";console.log(a);// 'Hello from a.js'"
                },
                {
                    "type": "p",
                    "text": "CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions namedexportsandrequire:"
                },
                {
                    "type": "code",
                    "code": "js// a.jsexports.message=\"Hello from a.js\";"
                },
                {
                    "type": "code",
                    "code": "js// b.jsconsta=require(\"./a\");console.log(a.message);// 'Hello from a.js'"
                },
                {
                    "type": "p",
                    "text": "Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated."
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:"
                },
                {
                    "type": "code",
                    "code": "tsimportsayHellofrom\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "To check this file, the compiler needs to know the type ofsayHello(is it a function that can accept one string argument?), which opens quite a few additional questions:"
                },
                {
                    "type": "list",
                    "items": [
                        "Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?",
                        "Whatkindof module does the module system expect to find, given the file name it will load and its location on disk?",
                        "If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?",
                        "Where will the module system look to find the module specified by\"greetings\"? Will the lookup succeed?",
                        "What kind of module is the file resolved by that lookup?",
                        "Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?",
                        "Once the\"greetings\"module has been analyzed, what piece of that module is bound tosayHello?"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notice that all of these questions depend on characteristics of thehost—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack). The ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known asmodule resolution, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options. The other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of itsoutputJavaScript files, not itsinputTypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and otherTypeScript-first runtimes and bundlers. So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files: Understand therules of the hostenough"
                },
                {
                    "type": "list",
                    "items": [
                        "to compile files into a validoutput module format,",
                        "to ensure that imports in thoseoutputswillresolve successfully, and",
                        "to know whattypeto assign toimported names."
                    ]
                },
                {
                    "type": "p",
                    "text": "Before we move on, it’s worth making sure we’re on the same page about the termhost, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:"
                },
                {
                    "type": "list",
                    "items": [
                        "When the output code (whether produced bytscor a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.",
                        "When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.",
                        "When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)",
                        "If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’snota host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.",
                        "When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.",
                        "The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts."
                    ]
                },
                {
                    "type": "p",
                    "text": "In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host onlysupportsone kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions andpackage.jsonfiles to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format. Themodulecompiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features likeimport.metaand top-levelawaitare available. So, even if a TypeScript project is usingnoEmit, choosing the right setting formodulestill matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. SeeChoosing compiler optionsfor guidance on choosing the rightmodulesetting for your project. The availablemodulesettings are"
                },
                {
                    "type": "list",
                    "items": [
                        "node16: Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.",
                        "nodenext: Currently identical tonode16, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.",
                        "es2015: Reflects the ES2015 language specification for JavaScript modules (the version that first introducedimportandexportto the language).",
                        "es2020: Adds support forimport.metaandexport * as ns from \"mod\"toes2015.",
                        "es2022: Adds support for top-levelawaittoes2020.",
                        "esnext: Currently identical toes2022, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.",
                        "commonjs,system,amd, andumd: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation."
                    ]
                },
                {
                    "type": "p",
                    "text": "Node.js’s rules for module format detection and interoperability make it incorrect to specifymoduleasesnextorcommonjsfor projects that run in Node.js, even if all files emitted bytscare ESM or CJS, respectively. The only correctmodulesettings for projects that intend to run in Node.js arenode16andnodenext. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations usingesnextandnodenext, the type checking can differ. See thereference section onnodenextfor more details."
                },
                {
                    "type": "p",
                    "text": "Node.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and thetypefield of the firstpackage.jsonfile found in a search of the file’s directory and all ancestor directories:"
                },
                {
                    "type": "list",
                    "items": [
                        ".mjsand.cjsfiles are always interpreted as ES modules and CJS modules, respectively.",
                        ".jsfiles are interpreted as ES modules if the nearestpackage.jsonfile contains atypefield with the value\"module\". If there is nopackage.jsonfile, or if thetypefield is missing or has any other value,.jsfiles are interpreted as CJS modules."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a file is determined to be an ES module by these rules, Node.js will not inject the CommonJSmoduleandrequireobjects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module,importandexportdeclarations in the file will cause a syntax error crash. When themodulecompiler option is set tonode16ornodenext, TypeScript applies this same algorithm to the project’sinputfiles to determine the module kind of each correspondingoutputfile. Let’s look at how module formats are detected in an example project that uses--module nodenext:"
                },
                {
                    "type": "p",
                    "text": "When the input file extension is.mtsor.cts, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output.mjsfile as an ES module or the output.cjsfile as a CJS module. When the input file extension is.ts, TypeScript has to consult the nearestpackage.jsonfile to determine the module format, because this is what Node.js will do when it encounters the output.jsfile. (Notice that the same rules apply to the.d.ctsand.d.tsdeclaration files in thepkgdependency: though they will not produce an output file as part of this compilation, the presence of a.d.tsfileimpliesthe existence of a corresponding.jsfile—perhaps created when the author of thepkglibrary rantscon an input.tsfile of their own—which Node.js must interpret as an ES module, due to its.jsextension and the presence of the\"type\": \"module\"field in/node_modules/pkg/package.json. Declaration files are covered in more detail in alater section.) The detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit/example.jswithimportandexportstatements in it, Node.js would crash when parsing the file. If TypeScript were to emit/main.mjswithrequirecalls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections. It’s worth mentioning again that TypeScript’s behavior in--module node16and--module nodenextis entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection isnecessaryfor checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts."
                },
                {
                    "type": "p",
                    "text": "It’s important to note that theinputmodule syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:"
                },
                {
                    "type": "code",
                    "code": "tsObject.defineProperty(exports,\"__esModule\", {value:true});constgreetings_1=require(\"greetings\");(0,greetings_1.sayHello)(\"world\");"
                },
                {
                    "type": "p",
                    "text": "depending on themodulecompiler option (and any applicablemodule format detectionrules, if themoduleoption supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module."
                },
                {
                    "type": "p",
                    "text": "Today, most TypeScript files are authored using ESM syntax (importandexportstatements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspiredimport fs = require(\"fs\")syntax inthe 1.5 release. The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:"
                },
                {
                    "type": "list",
                    "items": [
                        "Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.",
                        "When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.",
                        "When input files are written in ESM, the syntax in type declaration outputs (.d.tsfiles) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScripthasto know what kind of module everything is in order to provide correct types and prevent imports that will crash."
                    ]
                },
                {
                    "type": "p",
                    "text": "In TypeScript 5.0, a new compiler option calledverbatimModuleSyntaxwas introduced to help TypeScript authors know exactly how theirimportandexportstatements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (import fs = require(\"fs\")andexport = {}). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future."
                },
                {
                    "type": "p",
                    "text": "Can an ES moduleimporta CommonJS module? If so, does a default import link toexportsorexports.default? Can a CommonJS modulerequirean ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:"
                },
                {
                    "type": "list",
                    "items": [
                        "ESM-only.Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.",
                        "Bundler-like.Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.",
                        "Node.js.In Node.js, CommonJS modules cannot load ES modules synchronously (withrequire); they can only load them asynchronously with dynamicimport()calls. ES modules can default-import CJS modules, which always binds toexports. (This means that a default import of a Babel-like CJS output with__esModulebehaves differently between Node.js and some bundlers.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularlydefault) imports and to error on imports that will crash at runtime. When themodulecompiler option is set tonode16ornodenext, Node.js’s rules are enforced. All othermodulesettings, combined with theesModuleInteropoption, result in bundler-like interop in TypeScript. (While using--module esnextdoes prevent you fromwritingCommonJS modules, it does not prevent you fromimportingthem as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)"
                },
                {
                    "type": "p",
                    "text": "While themodulecompiler option can transform imports and exports in input files to different module formats in output files, the modulespecifier(the stringfromwhich youimport, or pass torequire) is always emitted as-written. For example, an input like:"
                },
                {
                    "type": "code",
                    "code": "tsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "might be emitted as either:"
                },
                {
                    "type": "code",
                    "code": "tsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "or:"
                },
                {
                    "type": "code",
                    "code": "tsconstmath_1=require(\"./math.mjs\");math_1.add(1,2);"
                },
                {
                    "type": "p",
                    "text": "depending on themodulecompiler option, but the module specifier will always be\"./math.mjs\". There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand thoseoutput-relative specifiers. The process of finding the file referenced by a module specifier is calledmodule resolution."
                },
                {
                    "type": "p",
                    "text": "Let’s return to ourfirst exampleand review what we’ve learned about it so far:"
                },
                {
                    "type": "code",
                    "code": "tsimportsayHellofrom\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve discussed how the host’s module system and TypeScript’smodulecompiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on themodulecompiler option, potentially the file extension, andpackage.json\"type\"field. We also know that whatsayHellogets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how tofindthe target file."
                },
                {
                    "type": "p",
                    "text": "While the ECMAScript specification defines how to parse and interpretimportandexportstatements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:"
                },
                {
                    "type": "code",
                    "code": "tsimportmonkeyfrom\"🐒\";// Looks for './eats/bananas.js'importcowfrom\"🐄\";// Looks for './eats/grass.js'importlionfrom\"🦁\";// Looks for './eats/you.js'"
                },
                {
                    "type": "p",
                    "text": "and still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign tomonkey,cow, andlionwithout built-in knowledge of this runtime’s module resolution algorithm. Just asmoduleinforms the compiler about the host’s expected module format,moduleResolution, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host. The availablemoduleResolutionoptions are:"
                },
                {
                    "type": "list",
                    "items": [
                        "classic: TypeScript’s oldest module resolution mode, this is unfortunately the default whenmoduleis set to anything other thancommonjs,node16, ornodenext. It was probably made to provide best-effort resolution for a wide range ofRequireJSconfigurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.",
                        "node10: Formerly known asnode, this is the unfortunate default whenmoduleis set tocommonjs. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages fromnode_modules, loading directoryindex.jsfiles, and omitting.jsextensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.",
                        "node16: This is the counterpart of--module node16and is set by default with thatmodulesetting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamicimport()calls are not allowed to omit file extensions or/index.jssuffixes, while module specifiers inrequirecalls are. This module resolution mode understands and enforces this restriction where necessary, as determined by themodule format detection rulesinstated by--module node16. (Fornode16andnodenext,moduleandmoduleResolutiongo hand-in-hand: setting one tonode16ornodenextwhile setting the other to something else has unsupported behavior and may be an error in the future.)",
                        "nodenext: Currently identical tonode16, this is the counterpart of--module nodenextand is set by default with thatmodulesetting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.",
                        "bundler: Node.js v12 introduced some new module resolution features for importing npm packages—the\"exports\"and\"imports\"fields ofpackage.json—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supportspackage.json\"exports\"and\"imports\"by default, but can be configured to ignore them. It requires settingmoduletoesnext."
                    ]
                },
                {
                    "type": "p",
                    "text": "Remember the three components of TypeScript’sjobconcerning modules?"
                },
                {
                    "type": "list",
                    "items": [
                        "Compile files into a validoutput module format",
                        "Ensure that imports in thoseoutputswillresolve successfully",
                        "Know whattypeto assign toimported names."
                    ]
                },
                {
                    "type": "p",
                    "text": "Module resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports orrequirecalls in the output files, containing thesame module specifiers as the input files, will actually work at runtime. Let’s look at a new example with multiple files:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: math.tsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: main.tsimport{add}from\"./math\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "When we see the import from\"./math\", it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type toadd.”"
                },
                {
                    "type": "p",
                    "text": "This isn’t entirely wrong, but the reality is deeper. The resolution of\"./math\"(and subsequently, the type ofadd) need to reflect the reality of what happens at runtime to theoutputfiles. A more robust way to think about this process would look like this:  This model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:"
                },
                {
                    "type": "code",
                    "code": "ts// @moduleResolution: node16// @rootDir: src// @outDir: dist// @Filename: src/math.mtsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: src/main.mtsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "Node.js ESMimportdeclarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that\"./math.mjs\"seems to resolve tomath.mts. Since we’re using anoutDirto put compiled outputs in a different directory,math.mjsdoesn’t even exist next tomain.mts! Why should this resolve? With our new mental model, it’s no problem:  Understanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts:\"./math.mjs\"refers to the input filemath.mts. I have to write the output extension, but the compiler knows to look for.mtswhen I write.mjs.This shortcut is even how the compiler works internally, but the more robust mental model explainswhymodule resolution in TypeScript works this way: given the constraint that the module specifier in the output file will bethe sameas the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types."
                },
                {
                    "type": "p",
                    "text": "In the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types? This is where declaration files (.d.ts,.d.mts, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you runtsc --declarationon an input file, you get one output JavaScript file and one output declaration file:"
                },
                {
                    "type": "p",
                    "text": "Because of this relationship, the compilerassumesthat wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript filewillexist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file. The declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:"
                },
                {
                    "type": "p",
                    "text": "The last row expresses that non-JS files can be typed with theallowArbitraryExtensionscompiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file namedstyles.csscan be represented by a declaration file namedstyles.d.css.ts."
                },
                {
                    "type": "p",
                    "text": "“But wait! Plenty of declaration files are written by hand,notgenerated bytsc. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not usingtscto generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package@arethetypeswrong/clican help catch and explain these errors before they’re published."
                },
                {
                    "type": "p",
                    "text": "So far, we’ve really emphasized the distinction betweeninput filesandoutput files. Recall that when specifying a file extension on a relative module specifier, TypeScript typicallymakes you use theoutputfile extension:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: src/math.tsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: src/main.tsimport{add}from\"./math.ts\";//                  ^^^^^^^^^^^// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled."
                },
                {
                    "type": "p",
                    "text": "This restriction applies since TypeScriptwon’t rewrite the extensionto.js, and if\"./math.ts\"appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if thereisno output JS file? What if you’re in one of these situations:"
                },
                {
                    "type": "list",
                    "items": [
                        "You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.",
                        "You’re running this code directly in a TypeScript runtime like Deno or Bun.",
                        "You’re usingts-node,tsx, or another transpiling loader for Node."
                    ]
                },
                {
                    "type": "p",
                    "text": "In these cases, you can turn onnoEmit(oremitDeclarationOnly) andallowImportingTsExtensionsto disable emitting unsafe JavaScript files and silence the error on.ts-extensioned imports. With or withoutallowImportingTsExtensions, it’s still important to pick the most appropriatemoduleResolutionsetting for the module resolution host. For bundlers and the Bun runtime, it’sbundler. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm thatdisables extension searchingthat Node.js applies to imports. Thebundlermodule resolution setting reflects this, enablingpackage.json\"exports\"support likenode16andnodenext, while always allowing extensionless imports. SeeChoosing compiler optionsfor more guidance."
                },
                {
                    "type": "p",
                    "text": "When compiling an app, you choose themoduleResolutionoption for a TypeScript project based on who the module resolutionhostis. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using\"module\": \"nodenext\"(along with the implied\"moduleResolution\": \"nodenext\") is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules forimportmodule resolution. Let’s look at what would happen if a library were to compile with\"moduleResolution\": \"bundler\"(or worse,\"node10\"):"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils\";"
                },
                {
                    "type": "p",
                    "text": "Assuming./utils.ts(or./utils/index.ts) exists, a bundler would be fine with this code, so\"moduleResolution\": \"bundler\"doesn’t complain. Compiled with\"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:"
                },
                {
                    "type": "code",
                    "code": "Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.jsDid you mean to import ./utils.js?"
                },
                {
                    "type": "p",
                    "text": "On the other hand, if we had written:"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils.js\";"
                },
                {
                    "type": "p",
                    "text": "This would produce output that works both in Node.jsandin bundlers. In short,\"moduleResolution\": \"bundler\"is infectious, allowing code that only works in bundlers to be produced. Likewise,\"moduleResolution\": \"nodenext\"is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers. Of course, this guidance can only apply in cases where the library ships outputs fromtsc. If the library is being bundledbeforeshipping,\"moduleResolution\": \"bundler\"may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, andtsccan no longer contribute to that task, since it can’t know what module code will exist at runtime."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html",
            "title": "TypeScript: Documentation - Namespaces and Modules",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "This post outlines the various ways to organize your code using modules and namespaces in TypeScript.\nWe’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript. See theModulesdocumentation for more information about ES Modules.\nSee theNamespacesdocumentation for more information about TypeScript namespaces. Note: Inveryold versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems."
                },
                {
                    "type": "p",
                    "text": "Modules can contain both code and declarations. Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules.\nModules provide for better code reuse, stronger isolation and better tooling support for bundling. It is also worth noting that, for Node.js applications, modules are the default andwe recommended modules over namespaces in modern code. Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations.\nThus, for new projects modules would be the recommended code organization mechanism."
                },
                {
                    "type": "p",
                    "text": "Namespaces are a TypeScript-specific way to organize code.Namespaces are simply named JavaScript objects in the global namespace.\nThis makes namespaces a very simple construct to use.\nUnlike modules, they can span multiple files, and can be concatenated usingoutFile.\nNamespaces can be a good way to structure your code in a Web Application, with all dependencies included as<script>tags in your HTML page. Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application."
                },
                {
                    "type": "p",
                    "text": "In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them."
                },
                {
                    "type": "p",
                    "text": "A common mistake is to try to use the/// <reference ... />syntax to refer to a module file, rather than using animportstatement.\nTo understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of animport(e.g. the...inimport x from \"...\";,import x = require(\"...\");, etc.) path. The compiler will try to find a.ts,.tsx, and then a.d.tswith the appropriate path.\nIf a specific file could not be found, then the compiler will look for anambient module declaration.\nRecall that these need to be declared in a.d.tsfile."
                },
                {
                    "type": "list",
                    "items": [
                        "myModules.d.tsts// In a .d.ts file or .ts file that is not a module:declaremodule\"SomeModule\"{exportfunctionfn():string;}",
                        "myOtherModule.tsts///<referencepath=\"myModules.d.ts\"/>import*asmfrom\"SomeModule\";"
                    ]
                },
                {
                    "type": "p",
                    "text": "The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module.\nThis is how thenode.d.tsfile that several of the TypeScript samples use is consumed."
                },
                {
                    "type": "p",
                    "text": "If you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapes.tstsexportnamespaceShapes{exportclassTriangle{/* ... */}exportclassSquare{/* ... */}}"
                    ]
                },
                {
                    "type": "p",
                    "text": "The top-level namespace hereShapeswraps upTriangleandSquarefor no reason.\nThis is confusing and annoying for consumers of your module:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapeConsumer.tstsimport*asshapesfrom\"./shapes\";lett=newshapes.Shapes.Triangle();// shapes.Shapes?"
                    ]
                },
                {
                    "type": "p",
                    "text": "A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope.\nBecause the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace. To reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions.\nBecause the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects. Here’s a revised example:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapes.tstsexportclassTriangle{/* ... */}exportclassSquare{/* ... */}",
                        "shapeConsumer.tstsimport*asshapesfrom\"./shapes\";lett=newshapes.Triangle();"
                    ]
                },
                {
                    "type": "p",
                    "text": "Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files.\nOne effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target.\nFor instance, you can’t use theoutFileoption while targetingcommonjsorumd, but with TypeScript 1.8 and later,it’s possibleto useoutFilewhen targetingamdorsystem."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
            "title": "TypeScript: Documentation - Namespaces",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "A note about terminology:It’s important to note that in TypeScript 1.5, the nomenclature has changed.\n“Internal modules” are now “namespaces”.\n“External modules” are now simply “modules”, as to align withECMAScript 2015’s terminology, (namely thatmodule X {is equivalent to the now-preferrednamespace X {)."
                },
                {
                    "type": "p",
                    "text": "This post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript.\nAs we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”.\nAdditionally, anywhere themodulekeyword was used when declaring an internal module, thenamespacekeyword can and should be used instead.\nThis avoids confusing new users by overloading them with similarly named terms."
                },
                {
                    "type": "p",
                    "text": "Let’s start with the program we’ll be using as our example throughout this page.\nWe’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringValidator{isAcceptable(s:string):boolean;}letlettersRegexp=/^[A-Za-z]+$/;letnumberRegexp=/^[0-9]+$/;classLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}classZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:StringValidator} = {};validators[\"ZIP code\"] =newZipCodeValidator();validators[\"Letters only\"] =newLettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {letisMatch=validators[name].isAcceptable(s);console.log(`'${s}'${isMatch?\"matches\":\"does not match\"}'${name}'.`);}}"
                },
                {
                    "type": "p",
                    "text": "As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects.\nInstead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace. In this example, we’ll move all validator-related entities into a namespace calledValidation.\nBecause we want the interfaces and classes here to be visible outside the namespace, we preface them withexport.\nConversely, the variableslettersRegexpandnumberRegexpare implementation details, so they are left unexported and will not be visible to code outside the namespace.\nIn the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g.Validation.LettersOnlyValidator."
                },
                {
                    "type": "code",
                    "code": "tsnamespaceValidation{exportinterfaceStringValidator{isAcceptable(s:string):boolean;}constlettersRegexp=/^[A-Za-z]+$/;constnumberRegexp=/^[0-9]+$/;exportclassLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}exportclassZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}}// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:Validation.StringValidator} = {};validators[\"ZIP code\"] =newValidation.ZipCodeValidator();validators[\"Letters only\"] =newValidation.LettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {console.log(`\"${s}\" -${validators[name].isAcceptable(s)?\"matches\":\"does not match\"}${name}`);}}"
                },
                {
                    "type": "p",
                    "text": "As our application grows, we’ll want to split the code across multiple files to make it easier to maintain."
                },
                {
                    "type": "p",
                    "text": "Here, we’ll split ourValidationnamespace across many files.\nEven though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place.\nBecause there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files.\nOur test code is otherwise unchanged."
                },
                {
                    "type": "code",
                    "code": "tsnamespaceValidation{exportinterfaceStringValidator{isAcceptable(s:string):boolean;}}"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>namespaceValidation{constlettersRegexp=/^[A-Za-z]+$/;exportclassLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}}"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>namespaceValidation{constnumberRegexp=/^[0-9]+$/;exportclassZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}}"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>///<referencepath=\"LettersOnlyValidator.ts\"/>///<referencepath=\"ZipCodeValidator.ts\"/>// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:Validation.StringValidator} = {};validators[\"ZIP code\"] =newValidation.ZipCodeValidator();validators[\"Letters only\"] =newValidation.LettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {console.log(`\"${s}\" -${validators[name].isAcceptable(s)?\"matches\":\"does not match\"}${name}`);}}"
                },
                {
                    "type": "p",
                    "text": "Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded.\nThere are two ways of doing this. First, we can use concatenated output using theoutFileoption to compile all of the input files into a single JavaScript output file:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Test.ts"
                },
                {
                    "type": "p",
                    "text": "The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts"
                },
                {
                    "type": "p",
                    "text": "Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file.\nIf multiple JS files get produced, we’ll need to use<script>tags on our webpage to load each emitted file in the appropriate order, for example:"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"Validation.js\"type=\"text/javascript\"/><scriptsrc=\"LettersOnlyValidator.js\"type=\"text/javascript\"/><scriptsrc=\"ZipCodeValidator.js\"type=\"text/javascript\"/><scriptsrc=\"Test.js\"type=\"text/javascript\"/>"
                },
                {
                    "type": "p",
                    "text": "Another way that you can simplify working with namespaces is to useimport q = x.y.zto create shorter names for commonly-used objects.\nNot to be confused with theimport x = require(\"name\")syntax used to load modules, this syntax simply creates an alias for the specified symbol.\nYou can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports."
                },
                {
                    "type": "code",
                    "code": "tsnamespaceShapes{exportnamespacePolygons{exportclassTriangle{}exportclassSquare{}}}importpolygons=Shapes.Polygons;letsq=newpolygons.Square();// Same as 'new Shapes.Polygons.Square()'"
                },
                {
                    "type": "p",
                    "text": "Notice that we don’t use therequirekeyword; instead we assign directly from the qualified name of the symbol we’re importing.\nThis is similar to usingvar, but also works on the type and namespace meanings of the imported symbol.\nImportantly, for values,importis a distinct reference from the original symbol, so changes to an aliasedvarwill not be reflected in the original variable."
                },
                {
                    "type": "p",
                    "text": "To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.\nBecause most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them. We call declarations that don’t define an implementation “ambient”.\nTypically these are defined in.d.tsfiles.\nIf you’re familiar with C/C++, you can think of these as.hfiles.\nLet’s look at a few examples."
                },
                {
                    "type": "p",
                    "text": "The popular library D3 defines its functionality in a global object calledd3.\nBecause this library is loaded through a<script>tag (instead of a module loader), its declaration uses namespaces to define its shape.\nFor the TypeScript compiler to see this shape, we use an ambient namespace declaration.\nFor example, we could begin writing it as follows:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceD3{exportinterfaceSelectors{select: {(selector:string):Selection;(element:EventTarget):Selection;};}exportinterfaceEvent{x:number;y:number;}exportinterfaceBaseextendsSelectors{event:Event;}}declarevard3:D3.Base;"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/nightly-builds.html",
            "title": "TypeScript: Documentation - Nightly Builds",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "A nightly build from theTypeScript’smainbranch is published by midnight PST to npm.\nHere is how you can get it and use it with your tools."
                },
                {
                    "type": "code",
                    "code": "shellnpm install -D typescript@next"
                },
                {
                    "type": "p",
                    "text": "You can also update your editor/IDE to use the nightly drop.\nYou will typically need to install the package through npm.\nThe rest of this section mostly assumestypescript@nextis already installed."
                },
                {
                    "type": "p",
                    "text": "The VS Code websitehas documentation on selecting a workspace version of TypeScript.\nAfter installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view.\nA direct way to do this is to open or create your workspace’s.vscode/settings.jsonand add the following property:"
                },
                {
                    "type": "code",
                    "code": "json\"typescript.tsdk\":\"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "Alternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run theJavaScript and TypeScript Nightly Extension"
                },
                {
                    "type": "p",
                    "text": "Update theSettings - Userfile with the following:"
                },
                {
                    "type": "code",
                    "code": "json\"typescript_tsdk\":\"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "More information is available at theTypeScript Plugin for Sublime Text installation documentation."
                },
                {
                    "type": "p",
                    "text": "Note: Most changes do not require you to install a new version of the VS TypeScript plugin."
                },
                {
                    "type": "p",
                    "text": "The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well."
                },
                {
                    "type": "list",
                    "items": [
                        "Download theVSDevMode.ps1script.Also see our wiki page onusing a custom language service file.",
                        "From a PowerShell command window, run:"
                    ]
                },
                {
                    "type": "p",
                    "text": "For VS 2015:"
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "p",
                    "text": "For VS 2013:"
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "p",
                    "text": "Go toPreferences>Languages & Frameworks>TypeScript:"
                },
                {
                    "type": "p",
                    "text": "TypeScript Version: If you installed with npm:/usr/local/lib/node_modules/typescript/lib"
                },
                {
                    "type": "p",
                    "text": "Go toFile>Settings>Languages & Frameworks>TypeScript:"
                },
                {
                    "type": "p",
                    "text": "TypeScript Version: If you installed with npm:C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
            "title": "TypeScript: Documentation - Project References",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Project references allows you to structure your TypeScript programs into smaller pieces, available in TypeScript 3.0 and newer. By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways. We’re also introducing a new mode fortsc, the--buildflag, that works hand in hand with project references to enable faster TypeScript builds."
                },
                {
                    "type": "p",
                    "text": "Let’s look at a fairly normal program and see how project references can help us better organize it.\nImagine you have a project with two modules,converterandunits, and a corresponding test file for each:"
                },
                {
                    "type": "code",
                    "code": "/├── src/│   ├── converter.ts│   └── units.ts├── test/│   ├── converter-tests.ts│   └── units-tests.ts└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "The test files import the implementation files and do some testing:"
                },
                {
                    "type": "code",
                    "code": "ts// converter-tests.tsimport*asconverterfrom\"../src/converter\";assert.areEqual(converter.celsiusToFahrenheit(0),32);"
                },
                {
                    "type": "p",
                    "text": "Previously, this structure was rather awkward to work with if you used a single tsconfig file:"
                },
                {
                    "type": "list",
                    "items": [
                        "It was possible for the implementation files to import the test files",
                        "It wasn’t possible to buildtestandsrcat the same time without havingsrcappear in the output folder name, which you probably don’t want",
                        "Changing just theinternalsin the implementation files requiredtypecheckingthe tests again, even though this wouldn’t ever cause new errors",
                        "Changing just the tests required typechecking the implementation again, even if nothing changed"
                    ]
                },
                {
                    "type": "p",
                    "text": "You could use multiple tsconfig files to solvesomeof those problems, but new ones would appear:"
                },
                {
                    "type": "list",
                    "items": [
                        "There’s no built-in up-to-date checking, so you end up always runningtsctwice",
                        "Invokingtsctwice incurs more startup time overhead",
                        "tsc -wcan’t run on multiple config files at once"
                    ]
                },
                {
                    "type": "p",
                    "text": "Project references can solve all of these problems and more."
                },
                {
                    "type": "p",
                    "text": "tsconfig.jsonfiles have a new top-level property,references. It’s an array of objects that specifies projects to reference:"
                },
                {
                    "type": "code",
                    "code": "js{\"compilerOptions\": {// The usual},\"references\": [{\"path\":\"../src\"}]}"
                },
                {
                    "type": "p",
                    "text": "Thepathproperty of each reference can point to a directory containing atsconfig.jsonfile, or to the config file itself (which may have any name). When you reference a project, new things happen:"
                },
                {
                    "type": "list",
                    "items": [
                        "Importing modules from a referenced project will instead load itsoutputdeclaration file (.d.ts)",
                        "If the referenced project produces anoutFile, the output file.d.tsfile’s declarations will be visible in this project",
                        "Build mode (see below) will automatically build the referenced project if needed"
                    ]
                },
                {
                    "type": "p",
                    "text": "By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program."
                },
                {
                    "type": "p",
                    "text": "Referenced projects must have the newcompositesetting enabled.\nThis setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project.\nEnabling thecompositeflag changes a few things:"
                },
                {
                    "type": "list",
                    "items": [
                        "TherootDirsetting, if not explicitly set, defaults to the directory containing thetsconfigfile",
                        "All implementation files must be matched by anincludepattern or listed in thefilesarray. If this constraint is violated,tscwill inform you which files weren’t specified",
                        "declarationmust be turned on"
                    ]
                },
                {
                    "type": "p",
                    "text": "We’ve also added support fordeclaration source maps.\nIf you enabledeclarationMap, you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors."
                },
                {
                    "type": "p",
                    "text": "Project references have a few trade-offs you should be aware of. Because dependent projects make use of.d.tsfiles that are built from their dependencies, you’ll either have to check in certain build outputsorbuild a project after cloning it before you can navigate the project in an editor without seeing spurious errors. When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory.d.tsgeneration process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this usingdisableSourceOfProjectReferenceRedirect option. Additionally, to preserve compatibility with existing build workflows,tscwillnotautomatically build dependencies unless invoked with the--buildswitch.\nLet’s learn more about--build."
                },
                {
                    "type": "p",
                    "text": "A long-awaited feature is smart incremental builds for TypeScript projects.\nIn 3.0 you can use the--buildflag withtsc.\nThis is effectively a new entry point fortscthat behaves more like a build orchestrator than a simple compiler. Runningtsc --build(tsc -bfor short) will do the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Find all referenced projects",
                        "Detect if they are up-to-date",
                        "Build out-of-date projects in the correct order"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can providetsc -bwith multiple config file paths (e.g.tsc -b src test).\nJust liketsc -p, specifying the config file name itself is unnecessary if it’s namedtsconfig.json."
                },
                {
                    "type": "p",
                    "text": "You can specify any number of config files:"
                },
                {
                    "type": "code",
                    "code": "shell> tsc -b# Use the tsconfig.json in the current directory> tsc -b src# Use src/tsconfig.json> tsc -b foo/prd.tsconfig.json bar# Use foo/prd.tsconfig.json and bar/tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "Don’t worry about ordering the files you pass on the commandline -tscwill re-order them if needed so that dependencies are always built first. There are also some flags specific totsc -b:"
                },
                {
                    "type": "list",
                    "items": [
                        "--verbose: Prints out verbose logging to explain what’s going on (may be combined with any other flag)",
                        "--dry: Shows what would be done but doesn’t actually build anything",
                        "--clean: Deletes the outputs of the specified projects (may be combined with--dry)",
                        "--force: Act as if all projects are out of date",
                        "--watch: Watch mode (may not be combined with any flag except--verbose)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Normally,tscwill produce outputs (.jsand.d.ts) in the presence of syntax or type errors, unlessnoEmitOnErroris on.\nDoing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see itoncebecause a subsequent build would skip building the now up-to-date project.\nFor this reason,tsc -beffectively acts as ifnoEmitOnErroris enabled for all projects. If you check in any build outputs (.js,.d.ts,.d.ts.map, etc.), you may need to run a--forcebuild after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy."
                },
                {
                    "type": "p",
                    "text": "If you have an msbuild project, you can enable build mode by adding"
                },
                {
                    "type": "code",
                    "code": "xml<TypeScriptBuildMode>true</TypeScriptBuildMode>"
                },
                {
                    "type": "p",
                    "text": "to your proj file. This will enable automatic incremental build as well as cleaning. Note that as withtsconfig.json/-p, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file. Some teams have set up msbuild-based workflows wherein tsconfig files have the sameimplicitgraph ordering as the managed projects they are paired with.\nIf your solution is like this, you can continue to usemsbuildwithtsc -palong with project references; these are fully interoperable."
                },
                {
                    "type": "p",
                    "text": "With moretsconfig.jsonfiles, you’ll usually want to useConfiguration file inheritanceto centralize your common compiler options.\nThis way you can change a setting in one file rather than having to edit multiple files. Another good practice is to have a “solution”tsconfig.jsonfile that simply hasreferencesto all of your leaf-node projects and setsfilesto an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an emptyfilesarray if you have at least onereferencein atsconfig.jsonfile. This presents a simple entry point; e.g. in the TypeScript repo we simply runtsc -b srcto build all endpoints because we list all the subprojects insrc/tsconfig.json You can see these patterns in the TypeScript repo - seesrc/tsconfig_base.json,src/tsconfig.json, andsrc/tsc/tsconfig.jsonas key examples."
                },
                {
                    "type": "p",
                    "text": "In general, not much is needed to transition a repo using relative modules.\nSimply place atsconfig.jsonfile in each subdirectory of a given parent folder, and addreferences to these config files to match the intended layering of the program.\nYou will need to either set theoutDirto an explicit subfolder of the output folder, or set therootDirto the common root of all project folders."
                },
                {
                    "type": "p",
                    "text": "Layout for compilations usingoutFileis more flexible because relative paths don’t matter as much.\nThe TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/symbols.html",
            "title": "TypeScript: Documentation - Symbols",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Starting with ECMAScript 2015,symbolis a primitive data type, just likenumberandstring. symbolvalues are created by calling theSymbolconstructor."
                },
                {
                    "type": "code",
                    "code": "tsletsym1=Symbol();letsym2=Symbol(\"key\");// optional string key"
                },
                {
                    "type": "p",
                    "text": "Symbols are immutable, and unique."
                },
                {
                    "type": "code",
                    "code": "tsletsym2=Symbol(\"key\");letsym3=Symbol(\"key\");sym2===sym3;// false, symbols are unique"
                },
                {
                    "type": "p",
                    "text": "Just like strings, symbols can be used as keys for object properties."
                },
                {
                    "type": "code",
                    "code": "tsconstsym=Symbol();letobj= {[sym]:\"value\",};console.log(obj[sym]);// \"value\""
                },
                {
                    "type": "p",
                    "text": "Symbols can also be combined with computed property declarations to declare object properties and class members."
                },
                {
                    "type": "code",
                    "code": "tsconstgetClassNameSymbol=Symbol();classC{[getClassNameSymbol]() {return\"C\";}}letc=newC();letclassName=c[getClassNameSymbol]();// \"C\""
                },
                {
                    "type": "p",
                    "text": "To enable treating symbols as unique literals a special typeunique symbolis available.unique symbolis a subtype ofsymbol, and are produced only from callingSymbol()orSymbol.for(), or from explicit type annotations. This type is only allowed onconstdeclarations andreadonly staticproperties, and in order to reference a specific unique symbol, you’ll have to use thetypeofoperator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration."
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstsym1:uniquesymbol;// sym2 can only be a constant reference.letsym2:uniquesymbol=Symbol();A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.// Works - refers to a unique symbol, but its identity is tied to 'sym1'.letsym3:typeofsym1=sym1;// Also works.classC{staticreadonlyStaticSymbol:uniquesymbol=Symbol();}Try"
                },
                {
                    "type": "p",
                    "text": "Because eachunique symbolhas a completely separate identity, no twounique symboltypes are assignable or comparable to each other."
                },
                {
                    "type": "code",
                    "code": "tsconstsym2=Symbol();constsym3=Symbol();if(sym2===sym3) {This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.// ...}Try"
                },
                {
                    "type": "p",
                    "text": "In addition to user-defined symbols, there are well-known built-in symbols.\nBuilt-in symbols are used to represent internal language behaviors. Here is a list of well-known symbols:"
                },
                {
                    "type": "p",
                    "text": "A method that returns async iterator for an object, compatible to be used with for await..of loop."
                },
                {
                    "type": "p",
                    "text": "A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator."
                },
                {
                    "type": "p",
                    "text": "A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat."
                },
                {
                    "type": "p",
                    "text": "A method that returns the default iterator for an object. Called by the semantics of the for-of statement."
                },
                {
                    "type": "p",
                    "text": "A regular expression method that matches the regular expression against a string. Called by theString.prototype.matchmethod."
                },
                {
                    "type": "p",
                    "text": "A regular expression method that replaces matched substrings of a string. Called by theString.prototype.replacemethod."
                },
                {
                    "type": "p",
                    "text": "A regular expression method that returns the index within a string that matches the regular expression. Called by theString.prototype.searchmethod."
                },
                {
                    "type": "p",
                    "text": "A function valued property that is the constructor function that is used to create derived objects."
                },
                {
                    "type": "p",
                    "text": "A regular expression method that splits a string at the indices that match the regular expression.\nCalled by theString.prototype.splitmethod."
                },
                {
                    "type": "p",
                    "text": "A method that converts an object to a corresponding primitive value.\nCalled by theToPrimitiveabstract operation."
                },
                {
                    "type": "p",
                    "text": "A String value that is used in the creation of the default string description of an object.\nCalled by the built-in methodObject.prototype.toString."
                },
                {
                    "type": "p",
                    "text": "An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",
            "title": "TypeScript: Documentation - Triple-Slash Directives",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Triple-slash directives are single-line comments containing a single XML tag.\nThe contents of the comment are used as compiler directives. Triple-slash directives areonlyvalid at the top of their containing file.\nA triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives.\nIf they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning. As of TypeScript 5.5, the compiler does not generate reference directives, and doesnotemit handwritten triple-slash directives to output files unless those directives are marked aspreserve=\"true\"."
                },
                {
                    "type": "p",
                    "text": "The/// <reference path=\"...\" />directive is the most common of this group.\nIt serves as a declaration ofdependencybetween files. Triple-slash references instruct the compiler to include additional files in the compilation process. They also serve as a method to order the output when usingoutoroutFile.\nFiles are emitted to the output file location in the same order as the input after preprocessing pass."
                },
                {
                    "type": "p",
                    "text": "The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives.\nDuring this process, additional files are added to the compilation. The process starts with a set ofroot files;\nthese are the file names specified on the command-line or in thefileslist in thetsconfig.jsonfile.\nThese root files are preprocessed in the same order they are specified.\nBefore a file is added to the list, all triple-slash references in it are processed, and their targets included.\nTriple-slash references are resolved in a depth-first manner, in the order they have been seen in the file. A triple-slash reference path is resolved relative to the containing file, if a relative path is used."
                },
                {
                    "type": "p",
                    "text": "It is an error to reference a file that does not exist.\nIt is an error for a file to have a triple-slash reference to itself."
                },
                {
                    "type": "p",
                    "text": "If the compiler flagnoResolveis specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided."
                },
                {
                    "type": "p",
                    "text": "Similar to a/// <reference path=\"...\" />directive, which serves as a declaration ofdependency, a/// <reference types=\"...\" />directive declares a dependency on a package. The process of resolving these package names is similar to the process of resolving module names in animportstatement.\nAn easy way to think of triple-slash-reference-types directives are as animportfor declaration packages. For example, including/// <reference types=\"node\" />in a declaration file declares that this file uses names declared in@types/node/index.d.ts;\nand thus, this package needs to be included in the compilation along with the declaration file. For declaring a dependency on an@typespackage in a.tsfile, usetypeson the command line or in yourtsconfig.jsoninstead.\nSeeusing@types,typeRootsandtypesintsconfig.jsonfilesfor more details."
                },
                {
                    "type": "p",
                    "text": "This directive allows a file to explicitly include an existing built-inlibfile. Built-inlibfiles are referenced in the same fashion as thelibcompiler option intsconfig.json(e.g. uselib=\"es2015\"and notlib=\"lib.es2015.d.ts\", etc.). For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors likeSymbolorIterable, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types. For example, adding/// <reference lib=\"es2017.string\" />to one of the files in a compilation is equivalent to compiling with--lib es2017.string."
                },
                {
                    "type": "code",
                    "code": "ts///<referencelib=\"es2017.string\"/>\"foo\".padStart(4);"
                },
                {
                    "type": "p",
                    "text": "This directive marks a file as adefault library.\nYou will see this comment at the top oflib.d.tsand its different variants. This directive instructs the compiler tonotinclude the default library (i.e.lib.d.ts) in the compilation.\nThe impact here is similar to passingnoLibon the command line. Also note that when passingskipDefaultLibCheck, the compiler will only skip checking files with/// <reference no-default-lib=\"true\"/>."
                },
                {
                    "type": "p",
                    "text": "By default AMD modules are generated anonymous.\nThis can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g.r.js). Theamd-moduledirective allows passing an optional module name to the compiler:"
                },
                {
                    "type": "code",
                    "code": "ts///<amd-modulename=\"NamedModule\"/>exportclassC{}"
                },
                {
                    "type": "p",
                    "text": "Will result in assigning the nameNamedModuleto the module as part of calling the AMDdefine:"
                },
                {
                    "type": "code",
                    "code": "jsdefine(\"NamedModule\", [\"require\",\"exports\"],function(require,exports) {varC= (function() {functionC() {}returnC;})();exports.C=C;});"
                },
                {
                    "type": "p",
                    "text": "Note: this directive has been deprecated. Useimport \"moduleName\";statements instead."
                },
                {
                    "type": "p",
                    "text": "/// <amd-dependency path=\"x\" />informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call. Theamd-dependencydirective can also have an optionalnameproperty; this allows passing an optional name for an amd-dependency:"
                },
                {
                    "type": "code",
                    "code": "ts///<amd-dependencypath=\"legacy/moduleA\"name=\"moduleA\"/>declarevarmoduleA:MyType;moduleA.callStuff();"
                },
                {
                    "type": "p",
                    "text": "Generated JS code:"
                },
                {
                    "type": "code",
                    "code": "jsdefine([\"require\",\"exports\",\"legacy/moduleA\"],function(require,exports,moduleA) {moduleA.callStuff();});"
                },
                {
                    "type": "p",
                    "text": "Triple-slash directives can be marked withpreserve=\"true\"to prevent the compiler from removing them from the output. For example, these will be erased in the output:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"...\"/>///<referencetypes=\"...\"/>///<referencelib=\"...\"/>"
                },
                {
                    "type": "p",
                    "text": "But these will be preserved:"
                },
                {
                    "type": "code",
                    "code": "ts/// <reference path=\"...\" preserve=\"true\" />/// <reference types=\"...\" preserve=\"true\" />/// <reference lib=\"...\" preserve=\"true\" />"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
            "title": "TypeScript: Documentation - What is a tsconfig.json",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "The presence of atsconfig.jsonfile in a directory indicates that the directory is the root of a TypeScript project.\nThetsconfig.jsonfile specifies the root files and the compiler options required to compile the project. JavaScript projects can use ajsconfig.jsonfile instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default. A project is compiled in one of the following ways:"
                },
                {
                    "type": "list",
                    "items": [
                        "By invoking tsc with no input files, in which case the compiler searches for thetsconfig.jsonfile starting in the current directory and continuing up the parent directory chain.",
                        "By invoking tsc with no input files and a--project(or just-p) command line option that specifies the path of a directory containing atsconfig.jsonfile, or a path to a valid.jsonfile containing the configurations."
                    ]
                },
                {
                    "type": "p",
                    "text": "When input files are specified on the command line,tsconfig.jsonfiles are ignored."
                },
                {
                    "type": "p",
                    "text": "Exampletsconfig.jsonfiles:"
                },
                {
                    "type": "list",
                    "items": [
                        "Using thefilesproperty{\"compilerOptions\": {\"module\":\"commonjs\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"sourceMap\":true},\"files\": [\"core.ts\",\"sys.ts\",\"types.ts\",\"scanner.ts\",\"parser.ts\",\"utilities.ts\",\"binder.ts\",\"checker.ts\",\"emitter.ts\",\"program.ts\",\"commandLineParser.ts\",\"tsc.ts\",\"diagnosticInformationMap.generated.ts\"]}",
                        "Using theincludeandexcludeproperties{\"compilerOptions\": {\"module\":\"system\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"outFile\":\"../../built/local/tsc.js\",\"sourceMap\":true},\"include\": [\"src/**/*\"],\"exclude\": [\"**/*.spec.ts\"]}"
                    ]
                },
                {
                    "type": "p",
                    "text": "Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use atgithub.com/tsconfig/bases.\nThese aretsconfig.jsonfiles which your project extends from which simplifies yourtsconfig.jsonby handling the runtime support. For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module@tsconfig/node12:"
                },
                {
                    "type": "code",
                    "code": "{\"extends\":\"@tsconfig/node12/tsconfig.json\",\"compilerOptions\": {\"preserveConstEnums\":true},\"include\": [\"src/**/*\"],\"exclude\": [\"**/*.spec.ts\"]}"
                },
                {
                    "type": "p",
                    "text": "This lets yourtsconfig.jsonfocus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments."
                },
                {
                    "type": "p",
                    "text": "The\"compilerOptions\"property can be omitted, in which case the compiler’s defaults are used. See our full list of supportedCompiler Options."
                },
                {
                    "type": "p",
                    "text": "To learn more about the hundreds of configuration options in theTSConfig Reference."
                },
                {
                    "type": "p",
                    "text": "Thetsconfig.jsonSchema can be found atthe JSON Schema Store."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html",
            "title": "TypeScript: Documentation - Type Checking JavaScript Files",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Here are some notable differences on how checking works in.jsfiles compared to.tsfiles."
                },
                {
                    "type": "p",
                    "text": "ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals. In a.jsfile, the compiler infers properties from property assignments inside the class body.\nThe type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null.\nIn that case, the type is the union of the types of all the right-hand values in these assignments.\nProperties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional."
                },
                {
                    "type": "code",
                    "code": "jsclassC{constructor() {this.constructorOnly=0;this.constructorUnknown=undefined;}method() {this.constructorOnly=false;Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.this.constructorUnknown=\"plunkbat\";// ok, constructorUnknown is string | undefinedthis.methodOnly=\"ok\";// ok, but methodOnly could also be undefined}method2() {this.methodOnly=true;// also, ok, methodOnly's type is string | boolean | undefined}}Try"
                },
                {
                    "type": "p",
                    "text": "If properties are never set in the class body, they are considered unknown.\nIf your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type.\nYou don’t even have to give a value if it will be initialized later:"
                },
                {
                    "type": "code",
                    "code": "jsclassC{constructor() {/**@type{number | undefined}*/this.prop=undefined;/**@type{number | undefined}*/this.count;}}letc=newC();c.prop=0;// OKc.count=\"string\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "Before ES2015, JavaScript used constructor functions instead of classes.\nThe compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes.\nThe property inference rules described above work exactly the same way."
                },
                {
                    "type": "code",
                    "code": "jsfunctionC() {this.constructorOnly=0;this.constructorUnknown=undefined;}C.prototype.method=function() {this.constructorOnly=false;Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.this.constructorUnknown=\"plunkbat\";// OK, the type is string | undefined};Try"
                },
                {
                    "type": "p",
                    "text": "In a.jsfile, TypeScript understands the CommonJS module format.\nAssignments toexportsandmodule.exportsare recognized as export declarations.\nSimilarly,requirefunction calls are recognized as module imports. For example:"
                },
                {
                    "type": "code",
                    "code": "js// same as `import module \"fs\"`constfs=require(\"fs\");// same as `export function readFile`module.exports.readFile=function(f) {returnfs.readFileSync(f);};"
                },
                {
                    "type": "p",
                    "text": "The module support in JavaScript is much more syntactically forgiving than TypeScript’s module support.\nMost combinations of assignments and declarations are supported."
                },
                {
                    "type": "p",
                    "text": "Classes are namespaces in.jsfiles.\nThis can be used to nest classes, for example:"
                },
                {
                    "type": "code",
                    "code": "jsclassC{}C.D=class{};Try"
                },
                {
                    "type": "p",
                    "text": "And, for pre-ES2015 code, it can be used to simulate static methods:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionOuter() {this.y=2;}Outer.Inner=function() {this.yy=2;};Outer.Inner();Try"
                },
                {
                    "type": "p",
                    "text": "It can also be used to create simple namespaces:"
                },
                {
                    "type": "code",
                    "code": "jsvarns= {};ns.C=class{};ns.func=function() {};ns;Try"
                },
                {
                    "type": "p",
                    "text": "Other variants are allowed as well:"
                },
                {
                    "type": "code",
                    "code": "js// IIFEvarns= (function(n) {returnn|| {};})();ns.CONST=1;// defaulting to globalvarassign=assign||function() {// code goes here};assign.extra=1;Try"
                },
                {
                    "type": "p",
                    "text": "In a.tsfile, an object literal that initializes a variable declaration gives its type to the declaration.\nNo new members can be added that were not specified in the original literal.\nThis rule is relaxed in a.jsfile; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally.\nFor instance:"
                },
                {
                    "type": "code",
                    "code": "jsvarobj= {a:1};obj.b=2;// AllowedTry"
                },
                {
                    "type": "p",
                    "text": "Object literals behave as if they have an index signature[x:string]: anythat allows them to be treated as open maps instead of closed objects. Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{{a: number}}*/varobj= {a:1};obj.b=2;Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.Try"
                },
                {
                    "type": "p",
                    "text": "Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on.\nAny variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on.\nThe only exception is for properties that have multiple initializers as described above."
                },
                {
                    "type": "code",
                    "code": "jsfunctionFoo(i=null) {if(!i)i=1;varj=undefined;j=2;this.l= [];}varfoo=newFoo();foo.l.push(foo.i);foo.l.push(\"end\");Try"
                },
                {
                    "type": "p",
                    "text": "Since there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in.jsfile are considered optional.\nCalls with fewer arguments than the declared number of parameters are allowed. It is important to note that it is an error to call a function with too many arguments. For instance:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionbar(a,b) {console.log(a+\" \"+b);}bar(1);// OK, second argument considered optionalbar(1,2);bar(1,2,3);// Error, too many argumentsExpected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.Try"
                },
                {
                    "type": "p",
                    "text": "JSDoc annotated functions are excluded from this rule.\nUse JSDoc optional parameter syntax ([]) to express optionality. e.g.:"
                },
                {
                    "type": "code",
                    "code": "js/***@param{string}[somebody]- Somebody's name.*/functionsayHello(somebody) {if(!somebody) {somebody=\"John Doe\";}console.log(\"Hello \"+somebody);}sayHello();Try"
                },
                {
                    "type": "p",
                    "text": "A function whose body has a reference to theargumentsreference is implicitly considered to have a var-arg parameter (i.e.(...arg: any[]) => any). Use JSDoc var-arg syntax to specify the type of the arguments."
                },
                {
                    "type": "code",
                    "code": "js/**@param{...number}args*/functionsum(/* numbers */) {vartotal=0;for(vari=0;i<arguments.length;i++) {total+=arguments[i];}returntotal;}Try"
                },
                {
                    "type": "p",
                    "text": "Since there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults toany."
                },
                {
                    "type": "p",
                    "text": "For instance,React.Componentis defined to have two type parameters,PropsandState.\nIn a.jsfile, there is no legal way to specify these in the extends clause. By default the type arguments will beany:"
                },
                {
                    "type": "code",
                    "code": "jsimport{Component}from\"react\";classMyComponentextendsComponent{render() {this.props.b;// Allowed, since this.props is of type any}}"
                },
                {
                    "type": "p",
                    "text": "Use JSDoc@augmentsto specify the types explicitly. for instance:"
                },
                {
                    "type": "code",
                    "code": "jsimport{Component}from\"react\";/***@augments{Component<{a: number}, State>}*/classMyComponentextendsComponent{render() {this.props.b;// Error: b does not exist on {a:number}}}"
                },
                {
                    "type": "p",
                    "text": "An unspecified type argument in JSDoc defaults to any:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{Array} */varx= [];x.push(1);// OKx.push(\"string\");// OK, x is of type Array<any>/**@type{Array.<number>} */vary= [];y.push(1);// OKy.push(\"string\");// Error, string is not assignable to numberTry"
                },
                {
                    "type": "p",
                    "text": "A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default toany. For example:"
                },
                {
                    "type": "code",
                    "code": "jsvarp=newPromise((resolve,reject)=>{reject();});p;// Promise<any>;"
                },
                {
                    "type": "p",
                    "text": "To learn all of the features available in JSDoc, seethe reference."
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "p",
                    "text": "What JSDoc does TypeScript-powered JavaScript support?"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html",
            "title": "TypeScript: Documentation - Type Compatibility",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Type compatibility in TypeScript is based on structural subtyping.\nStructural typing is a way of relating types based solely on their members.\nThis is in contrast with nominal typing.\nConsider the following code:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}classDog{name:string;}letpet:Pet;// OK, because of structural typingpet=newDog();"
                },
                {
                    "type": "p",
                    "text": "In nominally-typed languages like C# or Java, the equivalent code would be an error because theDogclass does not explicitly describe itself as being an implementer of thePetinterface. TypeScript’s structural type system was designed based on how JavaScript code is typically written.\nBecause JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them."
                },
                {
                    "type": "p",
                    "text": "The basic rule for TypeScript’s structural type system is thatxis compatible withyifyhas at least the same members asx. For example consider the following code involving an interface namedPetwhich has anameproperty:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}letpet:Pet;// dog's inferred type is { name: string; owner: string; }letdog= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};pet=dog;"
                },
                {
                    "type": "p",
                    "text": "To check whetherdogcan be assigned topet, the compiler checks each property ofpetto find a corresponding compatible property indog.\nIn this case,dogmust have a member callednamethat is a string. It does, so the assignment is allowed. The same rule for assignment is used when checking function call arguments:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}letdog= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};functiongreet(pet:Pet) {console.log(\"Hello, \"+pet.name);}greet(dog);// OK"
                },
                {
                    "type": "p",
                    "text": "Note thatdoghas an extraownerproperty, but this does not create an error.\nOnly members of the target type (Petin this case) are considered when\nchecking for compatibility. This comparison process proceeds recursively,\nexploring the type of each member and sub-member. Be aware, however, that object literalsmay only specify known properties.\nFor example, because we have explicitly specified thatdogis\nof typePet, the following code is invalid:"
                },
                {
                    "type": "code",
                    "code": "tsletdog:Pet= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};// Error"
                },
                {
                    "type": "p",
                    "text": "While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved.\nLet’s start with a basic example of two functions that differ only in their parameter lists:"
                },
                {
                    "type": "code",
                    "code": "tsletx= (a:number)=>0;lety= (b:number,s:string)=>0;y=x;// OKx=y;// Error"
                },
                {
                    "type": "p",
                    "text": "To check ifxis assignable toy, we first look at the parameter list.\nEach parameter inxmust have a corresponding parameter inywith a compatible type.\nNote that the names of the parameters are not considered, only their types.\nIn this case, every parameter ofxhas a corresponding compatible parameter iny, so the assignment is allowed. The second assignment is an error, becauseyhas a required second parameter thatxdoes not have, so the assignment is disallowed. You may be wondering why we allow ‘discarding’ parameters like in the exampley = x.\nThe reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript.\nFor example,Array#forEachprovides three parameters to the callback function: the array element, its index, and the containing array.\nNevertheless, it’s very useful to provide a callback that only uses the first parameter:"
                },
                {
                    "type": "code",
                    "code": "tsletitems= [1,2,3];// Don't force these extra parametersitems.forEach((item,index,array)=>console.log(item));// Should be OK!items.forEach((item)=>console.log(item));"
                },
                {
                    "type": "p",
                    "text": "Now let’s look at how return types are treated, using two functions that differ only by their return type:"
                },
                {
                    "type": "code",
                    "code": "tsletx= ()=>({name:\"Alice\"});lety= ()=>({name:\"Alice\",location:\"Seattle\"});x=y;// OKy=x;// Error, because x() lacks a location property"
                },
                {
                    "type": "p",
                    "text": "The type system enforces that the source function’s return type be a subtype of the target type’s return type."
                },
                {
                    "type": "p",
                    "text": "When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa.\nThis is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type.\nIn practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:"
                },
                {
                    "type": "code",
                    "code": "tsenumEventType{Mouse,Keyboard,}interfaceEvent{timestamp:number;}interfaceMyMouseEventextendsEvent{x:number;y:number;}interfaceMyKeyEventextendsEvent{keyCode:number;}functionlistenEvent(eventType:EventType,handler: (n:Event)=>void) {/* ... */}// Unsound, but useful and commonlistenEvent(EventType.Mouse, (e:MyMouseEvent)=>console.log(e.x+\",\"+e.y));// Undesirable alternatives in presence of soundnesslistenEvent(EventType.Mouse, (e:Event)=>console.log((easMyMouseEvent).x+\",\"+ (easMyMouseEvent).y));listenEvent(EventType.Mouse, ((e:MyMouseEvent)=>console.log(e.x+\",\"+e.y))as(e:Event)=>void);// Still disallowed (clear error). Type safety enforced for wholly incompatible typeslistenEvent(EventType.Mouse, (e:number)=>console.log(e));"
                },
                {
                    "type": "p",
                    "text": "You can have TypeScript raise errors when this happens via the compiler flagstrictFunctionTypes."
                },
                {
                    "type": "p",
                    "text": "When comparing functions for compatibility, optional and required parameters are interchangeable.\nExtra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error. When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters. This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passingundefinedin that position is equivalent for most functions. The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioninvokeLater(args:any[],callback: (...args:any[])=>void) {/* ... Invoke callback with 'args' ... */}// Unsound - invokeLater \"might\" provide any number of argumentsinvokeLater([1,2], (x,y)=>console.log(x+\", \"+y));// Confusing (x and y are actually required) and undiscoverableinvokeLater([1,2], (x?,y?)=>console.log(x+\", \"+y));"
                },
                {
                    "type": "p",
                    "text": "When a function has overloads, each overload in the target type must be matched by a compatible signature on the source type.\nThis ensures that the source function can be called in all the same cases as the target function."
                },
                {
                    "type": "p",
                    "text": "Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,"
                },
                {
                    "type": "code",
                    "code": "tsenumStatus{Ready,Waiting,}enumColor{Red,Blue,Green,}letstatus=Status.Ready;status=Color.Green;// Error"
                },
                {
                    "type": "p",
                    "text": "Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type.\nWhen comparing two objects of a class type, only members of the instance are compared.\nStatic members and constructors do not affect compatibility."
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{feet:number;constructor(name:string,numFeet:number) {}}classSize{feet:number;constructor(numFeet:number) {}}leta:Animal;lets:Size;a=s;// OKs=a;// OK"
                },
                {
                    "type": "p",
                    "text": "Private and protected members in a class affect their compatibility.\nWhen an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class.\nLikewise, the same applies for an instance with a protected member.\nThis allows a class to be assignment compatible with its super class, butnotwith classes from a different inheritance hierarchy which otherwise have the same shape."
                },
                {
                    "type": "p",
                    "text": "Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceEmpty<T> {}letx:Empty<number>;lety:Empty<string>;x=y;// OK, because y matches structure of x"
                },
                {
                    "type": "p",
                    "text": "In the above,xandyare compatible because their structures do not use the type argument in a differentiating way.\nChanging this example by adding a member toEmpty<T>shows how this works:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNotEmpty<T> {data:T;}letx:NotEmpty<number>;lety:NotEmpty<string>;x=y;// Error, because x and y are not compatible"
                },
                {
                    "type": "p",
                    "text": "In this way, a generic type that has its type arguments specified acts just like a non-generic type. For generic types that do not have their type arguments specified, compatibility is checked by specifyinganyin place of all unspecified type arguments.\nThe resulting types are then checked for compatibility, just as in the non-generic case. For example,"
                },
                {
                    "type": "code",
                    "code": "tsletidentity=function<T>(x:T):T{// ...};letreverse=function<U>(y:U):U{// ...};identity=reverse;// OK, because (x: any) => any matches (y: any) => any"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve used “compatible”, which is not a term defined in the language spec.\nIn TypeScript, there are two kinds of compatibility: subtype and assignment.\nThese differ only in that assignment extends subtype compatibility with rules to allow assignment to and fromany, and to and fromenumwith corresponding numeric values. Different places in the language use one of the two compatibility mechanisms, depending on the situation.\nFor practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of theimplementsandextendsclauses."
                },
                {
                    "type": "p",
                    "text": "The following table summarizes assignability between some abstract types.\nRows indicate what each is assignable to, columns indicate what is assignable to them.\nA ”✓” indicates a combination that is compatible only whenstrictNullChecksis off."
                },
                {
                    "type": "p",
                    "text": "ReiteratingThe Basics:"
                },
                {
                    "type": "list",
                    "items": [
                        "Everything is assignable to itself.",
                        "anyandunknownare the same in terms of what is assignable to them, different in thatunknownis not assignable to anything exceptany.",
                        "unknownandneverare like inverses of each other.\nEverything is assignable tounknown,neveris assignable to everything.\nNothing is assignable tonever,unknownis not assignable to anything (exceptany).",
                        "voidis not assignable to or from anything, with the following exceptions:any,unknown,never,undefined, andnull(ifstrictNullChecksis off, see table for details).",
                        "WhenstrictNullChecksis off,nullandundefinedare similar tonever: assignable to most types, most types are not assignable to them.\nThey are assignable to each other.",
                        "WhenstrictNullChecksis on,nullandundefinedbehave more likevoid: not assignable to or from anything, except forany,unknown, andvoid(undefinedis always assignable tovoid)."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
            "title": "TypeScript: Documentation - Type Inference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code"
                },
                {
                    "type": "code",
                    "code": "tsletx=3;let x: numberTry"
                },
                {
                    "type": "p",
                    "text": "The type of thexvariable is inferred to benumber.\nThis kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types. In most cases, type inference is straightforward.\nIn the following sections, we’ll explore some of the nuances in how types are inferred."
                },
                {
                    "type": "p",
                    "text": "When a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,"
                },
                {
                    "type": "code",
                    "code": "tsletx= [0,1,null];let x: (number | null)[]Try"
                },
                {
                    "type": "p",
                    "text": "To infer the type ofxin the example above, we must consider the type of each array element.\nHere we are given two choices for the type of the array:numberandnull.\nThe best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates. Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:"
                },
                {
                    "type": "code",
                    "code": "tsletzoo= [newRhino(),newElephant(),newSnake()];let zoo: (Rhino | Elephant | Snake)[]Try"
                },
                {
                    "type": "p",
                    "text": "Ideally, we may wantzooto be inferred as anAnimal[], but because there is no object that is strictly of typeAnimalin the array, we make no inference about the array element type.\nTo correct this, explicitly provide the type when no one type is a super type of all other candidates:"
                },
                {
                    "type": "code",
                    "code": "tsletzoo:Animal[] = [newRhino(),newElephant(),newSnake()];let zoo: Animal[]Try"
                },
                {
                    "type": "p",
                    "text": "When no best common type is found, the resulting inference is the union array type,(Rhino | Elephant | Snake)[]."
                },
                {
                    "type": "p",
                    "text": "Type inference also works in “the other direction” in some cases in TypeScript.\nThis is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onmousedown=function(mouseEvent) {console.log(mouseEvent.button);console.log(mouseEvent.kangaroo);Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.};Try"
                },
                {
                    "type": "p",
                    "text": "Here, the TypeScript type checker used the type of theWindow.onmousedownfunction to infer the type of the function expression on the right hand side of the assignment.\nWhen it did so, it was able to infer thetypeof themouseEventparameter, which does contain abuttonproperty, but not akangarooproperty. This works because window already hasonmousedowndeclared in its type:"
                },
                {
                    "type": "code",
                    "code": "ts// Declares there is a global variable called 'window'declarevarwindow:Window&typeofglobalThis;// Which is declared as (simplified):interfaceWindowextendsGlobalEventHandlers{// ...}// Which defines a lot of known handler eventsinterfaceGlobalEventHandlers{onmousedown: ((this:GlobalEventHandlers,ev:MouseEvent)=>any) |null;// ...}"
                },
                {
                    "type": "p",
                    "text": "TypeScript is smart enough to infer types in other contexts as well:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onscroll=function(uiEvent) {console.log(uiEvent.button);Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.};Try"
                },
                {
                    "type": "p",
                    "text": "Based on the fact that the above function is being assigned toWindow.onscroll, TypeScript knows thatuiEventis aUIEvent, and not aMouseEventlike the previous example.UIEventobjects contain nobuttonproperty, and so TypeScript will throw an error. If this function were not in a contextually typed position, the function’s argument would implicitly have typeany, and no error would be issued (unless you are using thenoImplicitAnyoption):"
                },
                {
                    "type": "code",
                    "code": "tsconsthandler=function(uiEvent) {console.log(uiEvent.button);// <- OK};Try"
                },
                {
                    "type": "p",
                    "text": "We can also explicitly give type information to the function’s argument to override any contextual type:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onscroll=function(uiEvent:any) {console.log(uiEvent.button);// <- Now, no error is given};Try"
                },
                {
                    "type": "p",
                    "text": "However, this code will logundefined, sinceuiEventhas no property calledbutton. Contextual typing applies in many cases.\nCommon cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements.\nThe contextual type also acts as a candidate type in best common type. For example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreateZoo():Animal[] {return[newRhino(),newElephant(),newSnake()];}Try"
                },
                {
                    "type": "p",
                    "text": "In this example, best common type has a set of four candidates:Animal,Rhino,Elephant, andSnake.\nOf these,Animalcan be chosen by the best common type algorithm."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html",
            "title": "TypeScript: Documentation - TypeScript for the New Programmer",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions! You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript.\nThe relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript."
                },
                {
                    "type": "p",
                    "text": "JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers.\nAt the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual.\nDue to this, early web browsers executed such code pretty slowly.\nOver time, though, JS became more and more popular, and web developers started using it to create interactive experiences. Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more.\nOn modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code.\nThis is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for richapplicationsof all kinds. More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js.\nThe “run anywhere” nature of JS makes it an attractive choice for cross-platform development.\nThere are many developers these days that useonlyJavaScript to program their entire stack! To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines.\nEvery language has its ownquirks— oddities and surprises, and JavaScript’s humble beginning makes it havemanyof these. Some examples:"
                },
                {
                    "type": "list",
                    "items": [
                        "JavaScript’s equality operator (==)coercesits operands, leading to unexpected behavior:jsif(\"\"==0) {// It is! But why??}if(1<x<3) {// True for *any* value of x!}",
                        "JavaScript also allows accessing properties which aren’t present:jsconstobj= {width:10,height:15};// Why is this NaN? Spelling is hard!constarea=obj.width*obj.heigth;"
                    ]
                },
                {
                    "type": "p",
                    "text": "Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running.\nWhen writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem."
                },
                {
                    "type": "p",
                    "text": "We said earlier that some languages wouldn’t allow those buggy programs to run at all.\nDetecting errors in code without running it is referred to asstatic checking.\nDetermining what’s an error and what’s not based on the kinds of values being operated on is known as statictypechecking. TypeScript checks a program for errors before execution, and does so based on thekinds of values, making it astatic type checker.\nFor example, the last example above has an error because of thetypeofobj.\nHere’s the error TypeScript found:"
                },
                {
                    "type": "code",
                    "code": "tsconstobj= {width:10,height:15};constarea=obj.width*obj.heigth;Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?Try"
                },
                {
                    "type": "p",
                    "text": "How does TypeScript relate to JavaScript, though?"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a language that is asupersetof JavaScript: JS syntax is therefore legal TS.\nSyntax refers to the way we write text to form a program.\nFor example, this code has asyntaxerror because it’s missing a):"
                },
                {
                    "type": "code",
                    "code": "tsleta= (4')' expected.1005')' expected.Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t consider any JavaScript code to be an error because of its syntax.\nThis means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written."
                },
                {
                    "type": "p",
                    "text": "However, TypeScript is atypedsuperset, meaning that it adds rules about how different kinds of values can be used.\nThe earlier error aboutobj.heigthwas not asyntaxerror: it is an error of using some kind of value (atype) in an incorrect way. As another example, this is JavaScript code that you can run in your browser, and itwilllog a value:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(4/ []);"
                },
                {
                    "type": "p",
                    "text": "This syntactically-legal program logsInfinity.\nTypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:"
                },
                {
                    "type": "code",
                    "code": "tsconsole.log(4/[]);The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.Try"
                },
                {
                    "type": "p",
                    "text": "It’s possible you reallydidintend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake.\nTypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible.\n(Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.) If you move some code from a JavaScript file to a TypeScript file, you might seetype errorsdepending on how the code is written.\nThese may be legitimate problems with the code, or TypeScript being overly conservative.\nThroughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors."
                },
                {
                    "type": "p",
                    "text": "TypeScript is also a programming language that preserves theruntime behaviorof JavaScript.\nFor example, dividing by zero in JavaScript producesInfinityinstead of throwing a runtime exception.\nAs a principle, TypeScriptneverchanges the runtime behavior of JavaScript code. This means that if you move code from JavaScript to TypeScript, it isguaranteedto run the same way, even if TypeScript thinks that the code has type errors. Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working."
                },
                {
                    "type": "p",
                    "text": "Roughly speaking, once TypeScript’s compiler is done with checking your code, iterasesthe types to produce the resulting “compiled” code.\nThis means that once your code is compiled, the resulting plain JS code has no type information. This also means that TypeScript never changes thebehaviorof your program based on the types it inferred.\nThe bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs. Finally, TypeScript doesn’t provide any additional runtime libraries.\nYour programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn."
                },
                {
                    "type": "p",
                    "text": "We frequently see the question “Should I learn JavaScript or TypeScript?“. The answer is that you can’t learn TypeScript without learning JavaScript!\nTypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time. There are many, many resources available for programmers to learn JavaScript; you shouldnotignore these resources if you’re writing TypeScript.\nFor example, there are about 20 times more StackOverflow questions taggedjavascriptthantypescript, butallof thejavascriptquestions also apply to TypeScript. If you find yourself searching for something like “how to sort a list in TypeScript”, remember:TypeScript is JavaScript’s runtime with a compile-time type checker.\nThe way you sort a list in TypeScript is the same way you do so in JavaScript.\nIf you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks."
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Learn some of the JavaScript fundamentals, we recommend either:Microsoft’s JavaScript ResourcesorJavaScript guide at the Mozilla Web Docs",
                        "Microsoft’s JavaScript Resourcesor",
                        "JavaScript guide at the Mozilla Web Docs",
                        "Continue toTypeScript for JavaScript Programmers",
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html",
            "title": "TypeScript: Documentation - TypeScript for Functional Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional object-oriented programs to the web. As it has developed, TypeScript’s type\nsystem has evolved to model code written by native JavaScripters. The\nresulting system is powerful, interesting and messy. This introduction is designed for working Haskell or ML programmers\nwho want to learn TypeScript. It describes how the type system of\nTypeScript differs from Haskell’s type system. It also describes\nunique features of TypeScript’s type system that arise from its\nmodelling of JavaScript code. This introduction does not cover object-oriented programming. In\npractice, object-oriented programs in TypeScript are similar to those\nin other popular languages with OO features."
                },
                {
                    "type": "p",
                    "text": "In this introduction, I assume you know the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "How to program in JavaScript, the good parts.",
                        "Type syntax of a C-descended language."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you need to learn the good parts of JavaScript, readJavaScript: The Good Parts.\nYou may be able to skip the book if you know how to write programs in\na call-by-value lexically scoped language with lots of mutability and\nnot much else.R4RS Schemeis a good example. The C++ Programming Languageis\na good place to learn about C-style type syntax. Unlike C++,\nTypeScript uses postfix types, like so:x: stringinstead ofstring x."
                },
                {
                    "type": "p",
                    "text": "JavaScript defines 8 built-in types:"
                },
                {
                    "type": "p",
                    "text": "See the MDN page for more detail. TypeScript has corresponding primitive types for the built-in types:"
                },
                {
                    "type": "list",
                    "items": [
                        "number",
                        "string",
                        "bigint",
                        "boolean",
                        "symbol",
                        "null",
                        "undefined",
                        "object"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notes:"
                },
                {
                    "type": "list",
                    "items": [
                        "Function syntax includes parameter names. This is pretty hard to get used to!tsletfst: (a:any,b:any)=>any= (a,b)=>a;// or more precisely:letfst: <T,U>(a:T,b:U)=>T= (a,b)=>a;",
                        "Object literal type syntax closely mirrors object literal value syntax:tsleto: {n:number;xs:object[] } = {n:1,xs:[] };",
                        "[T, T]is a subtype ofT[]. This is different than Haskell, where tuples are not related to lists."
                    ]
                },
                {
                    "type": "p",
                    "text": "JavaScript has boxed equivalents of primitive types that contain the\nmethods that programmers associate with those types. TypeScript\nreflects this with, for example, the difference between the primitive\ntypenumberand the boxed typeNumber. The boxed types are rarely\nneeded, since their methods return primitives."
                },
                {
                    "type": "code",
                    "code": "ts(1).toExponential();// equivalent toNumber.prototype.toExponential.call(1);"
                },
                {
                    "type": "p",
                    "text": "Note that calling a method on a numeric literal requires it to be in\nparentheses to aid the parser."
                },
                {
                    "type": "p",
                    "text": "TypeScript uses the typeanywhenever it can’t tell what the type of\nan expression should be. Compared toDynamic, callinganya type\nis an overstatement. It just turns off the type checker\nwherever it appears. For example, you can push any value into anany[]without marking the value in any way:"
                },
                {
                    "type": "code",
                    "code": "ts// with \"noImplicitAny\": false in tsconfig.json, anys: any[]constanys= [];anys.push(1);anys.push(\"oh no\");anys.push({anything:\"goes\"});Try"
                },
                {
                    "type": "p",
                    "text": "And you can use an expression of typeanyanywhere:"
                },
                {
                    "type": "code",
                    "code": "tsanys.map(anys[1]);// oh no, \"oh no\" is not a function"
                },
                {
                    "type": "p",
                    "text": "anyis contagious, too — if you initialize a variable with an\nexpression of typeany, the variable has typeanytoo."
                },
                {
                    "type": "code",
                    "code": "tsletsepsis=anys[0] +anys[1];// this could mean anything"
                },
                {
                    "type": "p",
                    "text": "To get an error when TypeScript produces anany, use\"noImplicitAny\": true, or\"strict\": trueintsconfig.json."
                },
                {
                    "type": "p",
                    "text": "Structural typing is a familiar concept to most functional\nprogrammers, although Haskell and most MLs are not\nstructurally typed. Its basic form is pretty simple:"
                },
                {
                    "type": "code",
                    "code": "ts// @strict: falseleto= {x:\"hi\",extra:1};// okleto2: {x:string} =o;// ok"
                },
                {
                    "type": "p",
                    "text": "Here, the object literal{ x: \"hi\", extra: 1 }has a matching\nliteral type{ x: string, extra: number }. That\ntype is assignable to{ x: string }since\nit has all the required properties and those properties have\nassignable types. The extra property doesn’t prevent assignment, it\njust makes it a subtype of{ x: string }. Named types just give a name to a type; for assignability purposes\nthere’s no difference between the type aliasOneand the interface\ntypeTwobelow. They both have a propertyp: string. (Type aliases\nbehave differently from interfaces with respect to recursive\ndefinitions and type parameters, however.)"
                },
                {
                    "type": "code",
                    "code": "tstypeOne= {p:string};interfaceTwo{p:string;}classThree{p=\"Hello\";}letx:One= {p:\"hi\"};lettwo:Two=x;two=newThree();Try"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, union types are untagged. In other words, they are not\ndiscriminated unions likedatain Haskell. However, you can often\ndiscriminate types in a union using built-in tags or other properties."
                },
                {
                    "type": "code",
                    "code": "tsfunctionstart(arg:string|string[] | (()=>string) | {s:string}):string{// this is super common in JavaScriptif(typeofarg===\"string\") {returncommonCase(arg);}elseif(Array.isArray(arg)) {returnarg.map(commonCase).join(\",\");}elseif(typeofarg===\"function\") {returncommonCase(arg());}else{returncommonCase(arg.s);}functioncommonCase(s:string):string{// finally, just convert a string to another stringreturns;}}Try"
                },
                {
                    "type": "p",
                    "text": "string,ArrayandFunctionhave built-in type predicates,\nconveniently leaving the object type for theelsebranch. It is\npossible, however, to generate unions that are difficult to\ndifferentiate at runtime. For new code, it’s best to build only\ndiscriminated unions. The following types have built-in predicates:"
                },
                {
                    "type": "p",
                    "text": "Note that functions and arrays are objects at runtime, but have their\nown predicates."
                },
                {
                    "type": "p",
                    "text": "In addition to unions, TypeScript also has intersections:"
                },
                {
                    "type": "code",
                    "code": "tstypeCombined= {a:number} & {b:string};typeConflicting= {a:number} & {a:string};Try"
                },
                {
                    "type": "p",
                    "text": "Combinedhas two properties,aandb, just as if they had been\nwritten as one object literal type. Intersection and union are\nrecursive in case of conflicts, soConflicting.a: number & string."
                },
                {
                    "type": "p",
                    "text": "Unit types are subtypes of primitive types that contain exactly one\nprimitive value. For example, the string\"foo\"has the type\"foo\". Since JavaScript has no built-in enums, it is common to use a set of\nwell-known strings instead. Unions of string literal types allow\nTypeScript to type this pattern:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionpad(s:string,n:number,direction:\"left\"|\"right\"):string;pad(\"hi\",10,\"left\");Try"
                },
                {
                    "type": "p",
                    "text": "When needed, the compilerwidens— converts to a\nsupertype — the unit type to the primitive type, such as\"foo\"tostring. This happens when using mutability, which can hamper some\nuses of mutable variables:"
                },
                {
                    "type": "code",
                    "code": "tslets=\"right\";pad(\"hi\",10,s);// error: 'string' is not assignable to '\"left\" | \"right\"'Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.2345Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.Try"
                },
                {
                    "type": "p",
                    "text": "Here’s how the error happens:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"right\": \"right\"",
                        "s: stringbecause\"right\"widens tostringon assignment to a mutable variable.",
                        "stringis not assignable to\"left\" | \"right\""
                    ]
                },
                {
                    "type": "p",
                    "text": "You can work around this with a type annotation fors, but that\nin turn prevents assignments tosof variables that are not of type\"left\" | \"right\"."
                },
                {
                    "type": "code",
                    "code": "tslets:\"left\"|\"right\"=\"right\";pad(\"hi\",10,s);Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript has some obvious places where it can infer types, like\nvariable declarations:"
                },
                {
                    "type": "code",
                    "code": "tslets=\"I'm a string!\";Try"
                },
                {
                    "type": "p",
                    "text": "But it also infers types in a few other places that you may not expect\nif you’ve worked with other C-syntax languages:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionmap<T,U>(f: (t:T)=>U,ts:T[]):U[];letsns=map((n)=>n.toString(), [1,2,3]);Try"
                },
                {
                    "type": "p",
                    "text": "Here,n: numberin this example also, despite the fact thatTandUhave not been inferred before the call. In fact, after[1,2,3]has\nbeen used to inferT=number, the return type ofn => n.toString()is used to inferU=string, causingsnsto have the typestring[]. Note that inference will work in any order, but intellisense will only\nwork left-to-right, so TypeScript prefers to declaremapwith the\narray first:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionmap<T,U>(ts:T[],f: (t:T)=>U):U[];Try"
                },
                {
                    "type": "p",
                    "text": "Contextual typing also works recursively through object literals, and\non unit types that would otherwise be inferred asstringornumber. And it can infer return types from context:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionrun<T>(thunk: (t:T)=>void):T;leti: {inference:string} =run((o)=>{o.inference=\"INSERT STATE HERE\";});Try"
                },
                {
                    "type": "p",
                    "text": "The type ofois determined to be{ inference: string }because"
                },
                {
                    "type": "list",
                    "items": [
                        "Declaration initializers are contextually typed by the\ndeclaration’s type:{ inference: string }.",
                        "The return type of a call uses the contextual type for inferences,\nso the compiler infers thatT={ inference: string }.",
                        "Arrow functions use the contextual type to type their parameters,\nso the compiler giveso: { inference: string }."
                    ]
                },
                {
                    "type": "p",
                    "text": "And it does so while you are typing, so that after typingo., you\nget completions for the propertyinference, along with any other\nproperties you’d have in a real program.\nAltogether, this feature can make TypeScript’s inference look a bit\nlike a unifying type inference engine, but it is not."
                },
                {
                    "type": "p",
                    "text": "Type aliases are mere aliases, just liketypein Haskell. The\ncompiler will attempt to use the alias name wherever it was used in\nthe source code, but does not always succeed."
                },
                {
                    "type": "code",
                    "code": "tstypeSize= [number,number];letx:Size= [101.1,999.9];Try"
                },
                {
                    "type": "p",
                    "text": "The closest equivalent tonewtypeis atagged intersection:"
                },
                {
                    "type": "code",
                    "code": "tstypeFString=string& {__compileTimeOnly:any};"
                },
                {
                    "type": "p",
                    "text": "AnFStringis just like a normal string, except that the compiler\nthinks it has a property named__compileTimeOnlythat doesn’t\nactually exist. This means thatFStringcan still be assigned tostring, but not the other way round."
                },
                {
                    "type": "p",
                    "text": "The closest equivalent todatais a union of types with discriminant\nproperties, normally called discriminated unions in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tstypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};"
                },
                {
                    "type": "p",
                    "text": "Unlike Haskell, the tag, or discriminant, is just a property in each\nobject type. Each variant has an identical property with a different\nunit type. This is still a normal union type; the leading|is\nan optional part of the union type syntax. You can discriminate the\nmembers of the union using normal JavaScript code:"
                },
                {
                    "type": "code",
                    "code": "tstypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};functionarea(s:Shape) {if(s.kind===\"circle\") {returnMath.PI*s.radius*s.radius;}elseif(s.kind===\"square\") {returns.x*s.x;}else{return(s.x*s.y) /2;}}Try"
                },
                {
                    "type": "p",
                    "text": "Note that the return type ofareais inferred to benumberbecause\nTypeScript knows the function is total. If some variant is not\ncovered, the return type ofareawill benumber | undefinedinstead. Also, unlike Haskell, common properties show up in any union, so you\ncan usefully discriminate multiple members of the union:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionheight(s:Shape) {if(s.kind===\"circle\") {return2*s.radius;}else{// s.kind: \"square\" | \"triangle\"returns.x;}}Try"
                },
                {
                    "type": "p",
                    "text": "Like most C-descended languages, TypeScript requires declaration of\ntype parameters:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionliftArray<T>(t:T):Array<T> {return[t];}"
                },
                {
                    "type": "p",
                    "text": "There is no case requirement, but type parameters are conventionally\nsingle uppercase letters. Type parameters can also be constrained to a\ntype, which behaves a bit like type class constraints:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirstish<Textends{length:number}>(t1:T,t2:T):T{returnt1.length>t2.length?t1:t2;}"
                },
                {
                    "type": "p",
                    "text": "TypeScript can usually infer type arguments from a call based on the\ntype of the arguments, so type arguments are usually not needed. Because TypeScript is structural, it doesn’t need type parameters as\nmuch as nominal systems. Specifically, they are not needed to make a\nfunction polymorphic. Type parameters should only be used topropagatetype information, such as constraining parameters to be\nthe same type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlength<TextendsArrayLike<unknown>>(t:T):number{}functionlength(t:ArrayLike<unknown>):number{}"
                },
                {
                    "type": "p",
                    "text": "In the firstlength, T is not necessary; notice that it’s only\nreferenced once, so it’s not being used to constrain the type of the\nreturn value or other parameters."
                },
                {
                    "type": "p",
                    "text": "TypeScript does not have higher kinded types, so the following is not legal:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlength<TextendsArrayLike<unknown>,U>(m:T<U>) {}"
                },
                {
                    "type": "p",
                    "text": "Point-free programming — heavy use of currying and function\ncomposition — is possible in JavaScript, but can be verbose.\nIn TypeScript, type inference often fails for point-free programs, so\nyou’ll end up specifying type parameters instead of value parameters. The\nresult is so verbose that it’s usually better to avoid point-free\nprogramming."
                },
                {
                    "type": "p",
                    "text": "JavaScript’s modern module syntax is a bit like Haskell’s, except that\nany file withimportorexportis implicitly a module:"
                },
                {
                    "type": "code",
                    "code": "tsimport{value,Type}from\"npm-package\";import{other,Types}from\"./local-package\";import*asprefixfrom\"../lib/third-package\";"
                },
                {
                    "type": "p",
                    "text": "You can also import commonjs modules — modules written using node.js’\nmodule system:"
                },
                {
                    "type": "code",
                    "code": "tsimportf=require(\"single-function-package\");"
                },
                {
                    "type": "p",
                    "text": "You can export with an export list:"
                },
                {
                    "type": "code",
                    "code": "tsexport{f};functionf() {returng();}functiong() {}// g is not exported"
                },
                {
                    "type": "p",
                    "text": "Or by marking each export individually:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionf() {returng() }functiong() { }"
                },
                {
                    "type": "p",
                    "text": "The latter style is more common but both are allowed, even in the same\nfile."
                },
                {
                    "type": "p",
                    "text": "In JavaScript, mutability is the default, although it allows variable\ndeclarations withconstto declare that thereferenceis\nimmutable. The referent is still mutable:"
                },
                {
                    "type": "code",
                    "code": "jsconsta= [1,2,3];a.push(102);// ):a[0] =101;// D:"
                },
                {
                    "type": "p",
                    "text": "TypeScript additionally has areadonlymodifier for properties."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceRx{readonlyx:number;}letrx:Rx= {x:1};rx.x=12;// error"
                },
                {
                    "type": "p",
                    "text": "It also ships with a mapped typeReadonly<T>that makes\nall propertiesreadonly:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceX{x:number;}letrx:Readonly<X> = {x:1};rx.x=12;// error"
                },
                {
                    "type": "p",
                    "text": "And it has a specificReadonlyArray<T>type that removes\nside-affecting methods and prevents writing to indices of the array,\nas well as special syntax for this type:"
                },
                {
                    "type": "code",
                    "code": "tsleta:ReadonlyArray<number> = [1,2,3];letb:readonlynumber[] = [1,2,3];a.push(102);// errorb[0] =101;// error"
                },
                {
                    "type": "p",
                    "text": "You can also use a const-assertion, which operates on arrays and\nobject literals:"
                },
                {
                    "type": "code",
                    "code": "tsleta= [1,2,3]asconst;a.push(102);// errora[0] =101;// error"
                },
                {
                    "type": "p",
                    "text": "However, none of these options are the default, so they are not\nconsistently used in TypeScript code."
                },
                {
                    "type": "p",
                    "text": "This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html",
            "title": "TypeScript: Documentation - TypeScript for Java/C# Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java. TypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program.\nWhile TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages.\nUnderstanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into."
                },
                {
                    "type": "p",
                    "text": "If you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to.\nSome of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript. If you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScriptwithouttypes first to understand JavaScript’s runtime behaviors.\nBecause TypeScript doesn’t change how your coderuns, you’ll still have to learn how JavaScript works in order to write code that actually does something! It’s important to remember that TypeScript uses the sameruntimeas JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs.\nDon’t limit yourself to TypeScript-specific resources!"
                },
                {
                    "type": "p",
                    "text": "C# and Java are what we might callmandatory OOPlanguages.\nIn these languages, theclassis the basic unit of code organization, and also the basic container of all dataandbehavior at runtime.\nForcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domainneedsto be represented this way."
                },
                {
                    "type": "p",
                    "text": "In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-definedclassorstruct.\nThis flexibility is extremely powerful.\n“Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript."
                },
                {
                    "type": "p",
                    "text": "Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript."
                },
                {
                    "type": "p",
                    "text": "That said, you can still use classes if you like!\nSome problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful.\nTypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods. We’ll cover classes later in this guide."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s understanding of atypeis actually quite different from C# or Java’s.\nLet’s explore some differences."
                },
                {
                    "type": "p",
                    "text": "In C# or Java, any given value or object has one exact type - eithernull, a primitive, or a known class type.\nWe can call methods likevalue.GetType()orvalue.getClass()to query the exact type at runtime.\nThe definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface. These aspects describe areified, nominaltype system.\nThe types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures."
                },
                {
                    "type": "p",
                    "text": "In C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations. In TypeScript, it’s better to think of a type as aset of valuesthat share something in common.\nBecause types are just sets, a particular value can belong tomanysets at the same time. Once you start thinking of types as sets, certain operations become very natural.\nFor example, in C#, it’s awkward to pass around a value that iseitherastringorint, because there isn’t a single type that represents this sort of value. In TypeScript, this becomes very natural once you realize that every type is just a set.\nHow do you describe a value that either belongs in thestringset or thenumberset?\nIt simply belongs to theunionof those sets:string | number. TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, objects arenotof a single exact type.\nFor example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePointlike{x:number;y:number;}interfaceNamed{name:string;}functionlogPoint(point:Pointlike) {console.log(\"x = \"+point.x+\", y = \"+point.y);}functionlogName(x:Named) {console.log(\"Hello, \"+x.name);}constobj= {x:0,y:0,name:\"Origin\",};logPoint(obj);logName(obj);Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system isstructural, not nominal: We can useobjas aPointlikebecause it hasxandyproperties that are both numbers.\nThe relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship. TypeScript’s type system is alsonot reified: There’s nothing at runtime that will tell us thatobjisPointlike.\nIn fact, thePointliketype is not presentin any format runtime. Going back to the idea oftypes as sets, we can think ofobjas being a member of both thePointlikeset of values and theNamedset of values."
                },
                {
                    "type": "p",
                    "text": "OOP programmers are often surprised by two particular aspects of structural typing."
                },
                {
                    "type": "p",
                    "text": "The first is that theempty typeseems to defy expectation:"
                },
                {
                    "type": "code",
                    "code": "tsclassEmpty{}functionfn(arg:Empty) {// do something?}// No error, but this isn't an 'Empty' ?fn({k:10});Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript determines if the call tofnhere is valid by seeing if the provided argument is a validEmpty.\nIt does so by examining thestructureof{ k: 10 }andclass Empty { }.\nWe can see that{ k: 10 }hasallof the properties thatEmptydoes, becauseEmptyhas no properties.\nTherefore, this is a valid call! This may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages.\nA subclass cannotremovea property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base.\nStructural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types."
                },
                {
                    "type": "p",
                    "text": "Another frequent source of surprise comes with identical types:"
                },
                {
                    "type": "code",
                    "code": "tsclassCar{drive() {// hit the gas}}classGolfer{drive() {// hit the ball far}}// No error?letw:Car=newGolfer();"
                },
                {
                    "type": "p",
                    "text": "Again, this isn’t an error because thestructuresof these classes are the same.\nWhile this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common. We’ll learn more about how classes relate to each other in the Classes chapter."
                },
                {
                    "type": "p",
                    "text": "OOP programmers are accustomed to being able to query the type of any value, even a generic one:"
                },
                {
                    "type": "code",
                    "code": "csharp// C#staticvoidLogType<T>() {Console.WriteLine(typeof(T).Name);}"
                },
                {
                    "type": "p",
                    "text": "Because TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime. JavaScript does have some limited primitives liketypeofandinstanceof, but remember that these operators are still working on the values as they exist in the type-erased output code.\nFor example,typeof (new Car())will be\"object\", notCaror\"Car\"."
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript for JavaScript Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system. For example, JavaScript provides language primitives likestringandnumber, but it doesn’t check that you’ve consistently assigned these. TypeScript does. This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs. This tutorial provides a brief overview of TypeScript, focusing on its type system."
                },
                {
                    "type": "p",
                    "text": "TypeScript knows the JavaScript language and will generate types for you in many cases.\nFor example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type."
                },
                {
                    "type": "code",
                    "code": "tslethelloWorld=\"Hello World\";let helloWorld: stringTry"
                },
                {
                    "type": "p",
                    "text": "By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows thathelloWorldis astringin the above example. You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript."
                },
                {
                    "type": "p",
                    "text": "You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be. For example, to create an object with an inferred type which includesname: stringandid: number, you can write:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser= {name:\"Hayes\",id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "You can explicitly describe this object’s shape using aninterfacedeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}Try"
                },
                {
                    "type": "p",
                    "text": "You can then declare that a JavaScript object conforms to the shape of your newinterfaceby using syntax like: TypeNameafter a variable declaration:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser:User= {name:\"Hayes\",id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}constuser:User= {username:\"Hayes\",Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}classUserAccount{name:string;id:number;constructor(name:string,id:number) {this.name=name;this.id=id;}}constuser:User=newUserAccount(\"Murphy\",1);Try"
                },
                {
                    "type": "p",
                    "text": "You can use interfaces to annotate parameters and return values to functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiondeleteUser(user:User) {// ...}functiongetAdminUser():User{//...}Try"
                },
                {
                    "type": "p",
                    "text": "There is already a small set of primitive types available in JavaScript:boolean,bigint,null,number,string,symbol, andundefined, which you can use in an interface. TypeScript extends this list with a few more, such asany(allow anything),unknown(ensure someone using this type declares what the type is),never(it’s not possible that this type could happen), andvoid(a function which returnsundefinedor has no return value). You’ll see that there are two syntaxes for building types:Interfaces and Types. You should preferinterface. Usetypewhen you need specific features."
                },
                {
                    "type": "p",
                    "text": "With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics."
                },
                {
                    "type": "p",
                    "text": "With a union, you can declare that a type could be one of many types. For example, you can describe abooleantype as being eithertrueorfalse:"
                },
                {
                    "type": "code",
                    "code": "tstypeMyBool=true|false;Try"
                },
                {
                    "type": "p",
                    "text": "Note:If you hover overMyBoolabove, you’ll see that it is classed asboolean. That’s a property of the Structural Type System. More on this below. A popular use-case for union types is to describe the set ofstringornumberliteralsthat a value is allowed to be:"
                },
                {
                    "type": "code",
                    "code": "tstypeWindowStates=\"open\"|\"closed\"|\"minimized\";typeLockStates=\"locked\"|\"unlocked\";typePositiveOddNumbersUnderTen=1|3|5|7|9;Try"
                },
                {
                    "type": "p",
                    "text": "Unions provide a way to handle different types too. For example, you may have a function that takes anarrayor astring:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetLength(obj:string|string[]) {returnobj.length;}Try"
                },
                {
                    "type": "p",
                    "text": "To learn the type of a variable, usetypeof:"
                },
                {
                    "type": "p",
                    "text": "For example, you can make a function return different values depending on whether it is passed a string or an array:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionwrapInArray(obj:string|string[]) {if(typeofobj===\"string\") {return[obj];(parameter) obj: string}returnobj;}Try"
                },
                {
                    "type": "p",
                    "text": "Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains."
                },
                {
                    "type": "code",
                    "code": "tstypeStringArray=Array<string>;typeNumberArray=Array<number>;typeObjectWithNameArray=Array<{name:string}>;"
                },
                {
                    "type": "p",
                    "text": "You can declare your own types that use generics:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBackpack<Type> {add: (obj:Type)=>void;get: ()=>Type;}// This line is a shortcut to tell TypeScript there is a// constant called `backpack`, and to not worry about where it came from.declareconstbackpack:Backpack<string>;// object is a string, because we declared it above as the variable part of Backpack.constobject=backpack.get();// Since the backpack variable is a string, you can't pass a number to the add function.backpack.add(23);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "One of TypeScript’s core principles is that type checking focuses on theshapethat values have. This is sometimes called “duck typing” or “structural typing”. In a structural type system, if two objects have the same shape, they are considered to be of the same type."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePoint{x:number;y:number;}functionlogPoint(p:Point) {console.log(`${p.x},${p.y}`);}// logs \"12, 26\"constpoint= {x:12,y:26};logPoint(point);Try"
                },
                {
                    "type": "p",
                    "text": "Thepointvariable is never declared to be aPointtype. However, TypeScript compares the shape ofpointto the shape ofPointin the type-check. They have the same shape, so the code passes. The shape-matching only requires a subset of the object’s fields to match."
                },
                {
                    "type": "code",
                    "code": "tsconstpoint3= {x:12,y:26,z:89};logPoint(point3);// logs \"12, 26\"constrect= {x:33,y:3,width:30,height:80};logPoint(rect);// logs \"33, 3\"constcolor= {hex:\"#187ABF\"};logPoint(color);Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, yTry"
                },
                {
                    "type": "p",
                    "text": "There is no difference between how classes and objects conform to shapes:"
                },
                {
                    "type": "code",
                    "code": "tsclassVirtualPoint{x:number;y:number;constructor(x:number,y:number) {this.x=x;this.y=y;}}constnewVPoint=newVirtualPoint(13,56);logPoint(newVPoint);// logs \"13, 56\"Try"
                },
                {
                    "type": "p",
                    "text": "If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details."
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript Tooling in 5 minutes",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "Let’s get started by building a simple web application with TypeScript."
                },
                {
                    "type": "p",
                    "text": "There are two main ways to add TypeScript to your project:"
                },
                {
                    "type": "list",
                    "items": [
                        "Via npm (the Node.js package manager)",
                        "By installing TypeScript’s Visual Studio plugins"
                    ]
                },
                {
                    "type": "p",
                    "text": "Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler,tsc.\nIf you didn’t install TypeScript with Visual Studio, you can stilldownload it. For npm users:"
                },
                {
                    "type": "code",
                    "code": "shell> npm install -g typescript"
                },
                {
                    "type": "p",
                    "text": "In your editor, type the following JavaScript code ingreeter.ts:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person) {return\"Hello, \"+person;}letuser=\"Jane User\";document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "p",
                    "text": "We used a.tsextension, but this code is just JavaScript.\nYou could have copy/pasted this straight out of an existing JavaScript app. At the command line, run the TypeScript compiler:"
                },
                {
                    "type": "code",
                    "code": "shelltsc greeter.ts"
                },
                {
                    "type": "p",
                    "text": "The result will be a filegreeter.jswhich contains the same JavaScript that you fed in.\nWe’re up and running using TypeScript in our JavaScript app! Now we can start taking advantage of some of the new tools TypeScript offers.\nAdd a: stringtype annotation to the ‘person’ function parameter as shown here:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person:string) {return\"Hello, \"+person;}letuser=\"Jane User\";document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "p",
                    "text": "Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable.\nIn this case, we intend the greeter function to be called with a single string parameter.\nWe can try changing the call greeter to pass an array instead:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person:string) {return\"Hello, \"+person;}letuser= [0,1,2];document.body.textContent=greeter(user);Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "Re-compiling, you’ll now see an error:"
                },
                {
                    "type": "code",
                    "code": "shellerror TS2345: Argument oftype'number[]'is not assignable to parameter oftype'string'."
                },
                {
                    "type": "p",
                    "text": "Similarly, try removing all the arguments to the greeter call.\nTypeScript will let you know that you have called this function with an unexpected number of arguments.\nIn both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide. Notice that although there were errors, thegreeter.jsfile is still created.\nYou can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected."
                },
                {
                    "type": "p",
                    "text": "Let’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field.\nIn TypeScript, two types are compatible if their internal structure is compatible.\nThis allows us to implement an interface just by having the shape the interface requires, without an explicitimplementsclause."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson{firstName:string;lastName:string;}functiongreeter(person:Person) {return\"Hello, \"+person.firstName+\" \"+person.lastName;}letuser= {firstName:\"Jane\",lastName:\"User\"};document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "p",
                    "text": "Finally, let’s extend the example one last time with classes.\nTypeScript supports new features in JavaScript, like support for class-based object-oriented programming. Here we’re going to create aStudentclass with a constructor and a few public fields.\nNotice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction. Also of note, the use ofpublicon parameters to the constructor is a shorthand that allows us to automatically create properties with that name."
                },
                {
                    "type": "code",
                    "code": "tsclassStudent{fullName:string;constructor(publicfirstName:string,publicmiddleInitial:string,publiclastName:string) {this.fullName=firstName+\" \"+middleInitial+\" \"+lastName;}}interfacePerson{firstName:string;lastName:string;}functiongreeter(person:Person) {return\"Hello, \"+person.firstName+\" \"+person.lastName;}letuser=newStudent(\"Jane\",\"M.\",\"User\");document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "p",
                    "text": "Re-runtsc greeter.tsand you’ll see the generated JavaScript is the same as the earlier code.\nClasses in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript."
                },
                {
                    "type": "p",
                    "text": "Now type the following ingreeter.html:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><html><head><title>TypeScript Greeter</title></head><body><scriptsrc=\"greeter.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Opengreeter.htmlin the browser to run your first simple TypeScript web application! Optional: Opengreeter.tsin Visual Studio, or copy the code into the TypeScript playground.\nYou can hover over identifiers to see their types.\nNotice that in some cases these types are inferred automatically for you.\nRe-type the last line, and see completion lists and parameter help based on the types of the DOM elements.\nPut your cursor on the reference to the greeter function, and hit F12 to go to its definition.\nNotice, too, that you can right-click on a symbol and use refactoring to rename it. The type information provided works together with the tools to work with JavaScript at application scale.\nFor more examples of what’s possible in TypeScript, see the Samples section of the website. "
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
            "title": "TypeScript: Documentation - Utility Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally."
                },
                {
                    "type": "p",
                    "text": "Released:4.5"
                },
                {
                    "type": "p",
                    "text": "This type is meant to model operations likeawaitinasyncfunctions, or the.then()method onPromises - specifically, the way that they recursively\nunwrapPromises."
                },
                {
                    "type": "code",
                    "code": "tstypeA=Awaited<Promise<string>>;type A = stringtypeB=Awaited<Promise<Promise<number>>>;type B = numbertypeC=Awaited<boolean|Promise<number>>;type C = number | booleanTry"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties ofTypeset to optional. This utility will return a type that represents all subsets of a given type."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;}functionupdateTodo(todo:Todo,fieldsToUpdate:Partial<Todo>) {return{ ...todo, ...fieldsToUpdate};}consttodo1= {title:\"organize desk\",description:\"clear clutter\",};consttodo2=updateTodo(todo1, {description:\"throw out trash\",});Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of all properties ofTypeset to required. The opposite ofPartial."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceProps{a?:number;b?:string;}constobj:Props= {a:5};constobj2:Required<Props> = {a:5};Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties ofTypeset toreadonly, meaning the properties of the constructed type cannot be reassigned."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;}consttodo:Readonly<Todo> = {title:\"Delete inactive users\",};todo.title=\"Hello\";Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.Try"
                },
                {
                    "type": "p",
                    "text": "This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of afrozen object)."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfreeze<Type>(obj:Type):Readonly<Type>;"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs an object type whose property keys areKeysand whose property values areType. This utility can be used to map the properties of a type to another type."
                },
                {
                    "type": "code",
                    "code": "tstypeCatName=\"miffy\"|\"boris\"|\"mordred\";interfaceCatInfo{age:number;breed:string;}constcats:Record<CatName,CatInfo> = {miffy:{age:10,breed:\"Persian\"},boris:{age:5,breed:\"Maine Coon\"},mordred:{age:16,breed:\"British Shorthair\"},};cats.boris;const cats: Record<CatName, CatInfo>Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking the set of propertiesKeys(string literal or union of string literals) fromType."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;completed:boolean;}typeTodoPreview=Pick<Todo,\"title\"|\"completed\">;consttodo:TodoPreview= {title:\"Clean room\",completed:false,};todo;const todo: TodoPreviewTry"
                },
                {
                    "type": "p",
                    "text": "Released:3.5"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking all properties fromTypeand then removingKeys(string literal or union of string literals). The opposite ofPick."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;completed:boolean;createdAt:number;}typeTodoPreview=Omit<Todo,\"description\">;consttodo:TodoPreview= {title:\"Clean room\",completed:false,createdAt:1615544252770,};todo;const todo: TodoPreviewtypeTodoInfo=Omit<Todo,\"completed\"|\"createdAt\">;consttodoInfo:TodoInfo= {title:\"Pick up kids\",description:\"Kindergarten closes at 5pm\",};todoInfo;const todoInfo: TodoInfoTry"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excluding fromUnionTypeall union members that are assignable toExcludedMembers."
                },
                {
                    "type": "code",
                    "code": "tstypeT0=Exclude<\"a\"|\"b\"|\"c\",\"a\">;type T0 = \"b\" | \"c\"typeT1=Exclude<\"a\"|\"b\"|\"c\",\"a\"|\"b\">;type T1 = \"c\"typeT2=Exclude<string|number| (()=>void),Function>;type T2 = string | numbertypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};typeT3=Exclude<Shape, {kind:\"circle\"}>type T3 = {\n    kind: \"square\";\n    x: number;\n} | {\n    kind: \"triangle\";\n    x: number;\n    y: number;\n}Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by extracting fromTypeall union members that are assignable toUnion."
                },
                {
                    "type": "code",
                    "code": "tstypeT0=Extract<\"a\"|\"b\"|\"c\",\"a\"|\"f\">;type T0 = \"a\"typeT1=Extract<string|number| (()=>void),Function>;type T1 = () => voidtypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};typeT2=Extract<Shape, {kind:\"circle\"}>type T2 = {\n    kind: \"circle\";\n    radius: number;\n}Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excludingnullandundefinedfromType."
                },
                {
                    "type": "code",
                    "code": "tstypeT0=NonNullable<string|number|undefined>;type T0 = string | numbertypeT1=NonNullable<string[] |null|undefined>;type T1 = string[]Try"
                },
                {
                    "type": "p",
                    "text": "Released:3.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple type from the types used in the parameters of a function typeType. For overloaded functions, this will be the parameters of thelastsignature; seeInferring Within Conditional Types."
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionf1(arg: {a:number;b:string}):void;typeT0=Parameters<()=>string>;type T0 = []typeT1=Parameters<(s:string)=>void>;type T1 = [s: string]typeT2=Parameters<<T>(arg:T)=>T>;type T2 = [arg: unknown]typeT3=Parameters<typeoff1>;type T3 = [arg: {\n    a: number;\n    b: string;\n}]typeT4=Parameters<any>;type T4 = unknown[]typeT5=Parameters<never>;type T5 = nevertypeT6=Parameters<string>;Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.type T6 = nevertypeT7=Parameters<Function>;Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.type T7 = neverTry"
                },
                {
                    "type": "p",
                    "text": "Released:3.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the typeneverifTypeis not a function)."
                },
                {
                    "type": "code",
                    "code": "tstypeT0=ConstructorParameters<ErrorConstructor>;type T0 = [message?: string]typeT1=ConstructorParameters<FunctionConstructor>;type T1 = string[]typeT2=ConstructorParameters<RegExpConstructor>;type T2 = [pattern: string | RegExp, flags?: string]classC{constructor(a:number,b:string) {}}typeT3=ConstructorParameters<typeofC>;type T3 = [a: number, b: string]typeT4=ConstructorParameters<any>;type T4 = unknown[]typeT5=ConstructorParameters<Function>;Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.type T5 = neverTry"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the return type of functionType. For overloaded functions, this will be the return type of thelastsignature; seeInferring Within Conditional Types."
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionf1(): {a:number;b:string};typeT0=ReturnType<()=>string>;type T0 = stringtypeT1=ReturnType<(s:string)=>void>;type T1 = voidtypeT2=ReturnType<<T>()=>T>;type T2 = unknowntypeT3=ReturnType<<TextendsU,Uextendsnumber[]>()=>T>;type T3 = number[]typeT4=ReturnType<typeoff1>;type T4 = {\n    a: number;\n    b: string;\n}typeT5=ReturnType<any>;type T5 = anytypeT6=ReturnType<never>;type T6 = nevertypeT7=ReturnType<string>;Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.type T7 = anytypeT8=ReturnType<Function>;Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.type T8 = anyTry"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the instance type of a constructor function inType."
                },
                {
                    "type": "code",
                    "code": "tsclassC{x=0;y=0;}typeT0=InstanceType<typeofC>;type T0 = CtypeT1=InstanceType<any>;type T1 = anytypeT2=InstanceType<never>;type T2 = nevertypeT3=InstanceType<string>;Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.type T3 = anytypeT4=InstanceType<Function>;Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.type T4 = anyTry"
                },
                {
                    "type": "p",
                    "text": "Released:5.4"
                },
                {
                    "type": "p",
                    "text": "Blocks inferences to the contained type. Other than blocking inferences,NoInfer<Type>is\nidentical toType."
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreateStreetLight<Cextendsstring>(colors:C[],defaultColor?:NoInfer<C>,) {// ...}createStreetLight([\"red\",\"yellow\",\"green\"],\"red\");// OKcreateStreetLight([\"red\",\"yellow\",\"green\"],\"blue\");// Error"
                },
                {
                    "type": "p",
                    "text": "Released:3.3"
                },
                {
                    "type": "p",
                    "text": "Extracts the type of thethisparameter for a function type, orunknownif the function type has nothisparameter."
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoHex(this:Number) {returnthis.toString(16);}functionnumberToString(n:ThisParameterType<typeoftoHex>) {returntoHex.apply(n);}Try"
                },
                {
                    "type": "p",
                    "text": "Released:3.3"
                },
                {
                    "type": "p",
                    "text": "Removes thethisparameter fromType. IfTypehas no explicitly declaredthisparameter, the result is simplyType. Otherwise, a new function type with nothisparameter is created fromType. Generics are erased and only the last overload signature is propagated into the new function type."
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoHex(this:Number) {returnthis.toString(16);}constfiveToHex:OmitThisParameter<typeoftoHex> =toHex.bind(5);console.log(fiveToHex());Try"
                },
                {
                    "type": "p",
                    "text": "Released:2.3"
                },
                {
                    "type": "p",
                    "text": "This utility does not return a transformed type. Instead, it serves as a marker for a contextualthistype. Note that thenoImplicitThisflag must be enabled to use this utility."
                },
                {
                    "type": "code",
                    "code": "tstypeObjectDescriptor<D,M> = {data?:D;methods?:M&ThisType<D&M>;// Type of 'this' in methods is D & M};functionmakeObject<D,M>(desc:ObjectDescriptor<D,M>):D&M{letdata:object=desc.data|| {};letmethods:object=desc.methods|| {};return{ ...data, ...methods}asD&M;}letobj=makeObject({data:{x:0,y:0},methods:{moveBy(dx:number,dy:number) {this.x+=dx;// Strongly typed thisthis.y+=dy;// Strongly typed this},},});obj.x=10;obj.y=20;obj.moveBy(5,5);Try"
                },
                {
                    "type": "p",
                    "text": "In the example above, themethodsobject in the argument tomakeObjecthas a contextual type that includesThisType<D & M>and therefore the type ofthisin methods within themethodsobject is{ x: number, y: number } & { moveBy(dx: number, dy: number): void }. Notice how the type of themethodsproperty simultaneously is an inference target and a source for thethistype in methods. TheThisType<T>marker interface is simply an empty interface declared inlib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface."
                },
                {
                    "type": "p",
                    "text": "To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in theTemplate Literal Typesdocumentation."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/variable-declarations.html",
            "title": "TypeScript: Documentation - Variable Declaration",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "p",
                    "text": "letandconstare two relatively new concepts for variable declarations in JavaScript.As we mentioned earlier,letis similar tovarin some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript. constis an augmentation ofletin that it prevents re-assignment to a variable. With TypeScript being an extension of JavaScript, the language naturally supportsletandconst.\nHere we’ll elaborate more on these new declarations and why they’re preferable tovar. If you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory.\nIf you’re intimately familiar with all the quirks ofvardeclarations in JavaScript, you might find it easier to skip ahead."
                },
                {
                    "type": "p",
                    "text": "Declaring a variable in JavaScript has always traditionally been done with thevarkeyword."
                },
                {
                    "type": "code",
                    "code": "tsvara=10;"
                },
                {
                    "type": "p",
                    "text": "As you might’ve figured out, we just declared a variable namedawith the value10. We can also declare a variable inside of a function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {varmessage=\"Hello, world!\";returnmessage;}"
                },
                {
                    "type": "p",
                    "text": "and we can also access those same variables within other functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {vara=10;returnfunctiong() {varb=a+1;returnb;};}varg=f();g();// returns '11'"
                },
                {
                    "type": "p",
                    "text": "In this above example,gcaptured the variableadeclared inf.\nAt any point thatggets called, the value ofawill be tied to the value ofainf.\nEven ifgis called oncefis done running, it will be able to access and modifya."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {vara=1;a=2;varb=g();a=3;returnb;functiong() {returna;}}f();// returns '2'"
                },
                {
                    "type": "p",
                    "text": "vardeclarations have some odd scoping rules for those used to other languages.\nTake the following example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(shouldInitialize:boolean) {if(shouldInitialize) {varx=10;}returnx;}f(true);// returns '10'f(false);// returns 'undefined'"
                },
                {
                    "type": "p",
                    "text": "Some readers might do a double-take at this example.\nThe variablexwas declaredwithin theifblock, and yet we were able to access it from outside that block.\nThat’s becausevardeclarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block.\nSome people call thisvar-scopingorfunction-scoping.\nParameters are also function scoped. These scoping rules can cause several types of mistakes.\nOne problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsumMatrix(matrix:number[][]) {varsum=0;for(vari=0;i<matrix.length;i++) {varcurrentRow=matrix[i];for(vari=0;i<currentRow.length;i++) {sum+=currentRow[i];}}returnsum;}"
                },
                {
                    "type": "p",
                    "text": "Maybe it was easy to spot out for some experienced JavaScript developers, but the innerfor-loop will accidentally overwrite the variableibecauseirefers to the same function-scoped variable.\nAs experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration."
                },
                {
                    "type": "p",
                    "text": "Take a quick second to guess what the output of the following snippet is:"
                },
                {
                    "type": "code",
                    "code": "tsfor(vari=0;i<10;i++) {setTimeout(function() {console.log(i);},100*i);}"
                },
                {
                    "type": "p",
                    "text": "For those unfamiliar,setTimeoutwill try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running). Ready? Take a look:"
                },
                {
                    "type": "code",
                    "code": "10101010101010101010"
                },
                {
                    "type": "p",
                    "text": "Many JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone.\nMost people expect the output to be"
                },
                {
                    "type": "code",
                    "code": "0123456789"
                },
                {
                    "type": "p",
                    "text": "Remember what we mentioned earlier about variable capturing?\nEvery function expression we pass tosetTimeoutactually refers to the sameifrom the same scope. Let’s take a minute to consider what that means.setTimeoutwill run a function after some number of milliseconds,but onlyafter theforloop has stopped executing;\nBy the time theforloop has stopped executing, the value ofiis10.\nSo each time the given function gets called, it will print out10! A common work around is to use an IIFE - an Immediately Invoked Function Expression - to captureiat each iteration:"
                },
                {
                    "type": "code",
                    "code": "tsfor(vari=0;i<10;i++) {// capture the current state of 'i'// by invoking a function with its current value(function(i) {setTimeout(function() {console.log(i);},100*i);})(i);}"
                },
                {
                    "type": "p",
                    "text": "This odd-looking pattern is actually pretty common.\nTheiin the parameter list actually shadows theideclared in theforloop, but since we named them the same, we didn’t have to modify the loop body too much."
                },
                {
                    "type": "p",
                    "text": "By now you’ve figured out thatvarhas some problems, which is precisely whyletstatements were introduced.\nApart from the keyword used,letstatements are written the same wayvarstatements are."
                },
                {
                    "type": "code",
                    "code": "tslethello=\"Hello!\";"
                },
                {
                    "type": "p",
                    "text": "The key difference is not in the syntax, but in the semantics, which we’ll now dive into."
                },
                {
                    "type": "p",
                    "text": "When a variable is declared usinglet, it uses what some calllexical-scopingorblock-scoping.\nUnlike variables declared withvarwhose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block orfor-loop."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(input:boolean) {leta=100;if(input) {// Still okay to reference 'a'letb=a+1;returnb;}// Error: 'b' doesn't exist herereturnb;}"
                },
                {
                    "type": "p",
                    "text": "Here, we have two local variablesaandb.a’s scope is limited to the body offwhileb’s scope is limited to the containingifstatement’s block. Variables declared in acatchclause also have similar scoping rules."
                },
                {
                    "type": "code",
                    "code": "tstry{throw\"oh no!\";}catch(e) {console.log(\"Oh well.\");}// Error: 'e' doesn't exist hereconsole.log(e);"
                },
                {
                    "type": "p",
                    "text": "Another property of block-scoped variables is that they can’t be read or written to before they’re actually declared.\nWhile these variables are “present” throughout their scope, all points up until their declaration are part of theirtemporal dead zone.\nThis is just a sophisticated way of saying you can’t access them before theletstatement, and luckily TypeScript will let you know that."
                },
                {
                    "type": "code",
                    "code": "tsa++;// illegal to use 'a' before it's declared;leta;"
                },
                {
                    "type": "p",
                    "text": "Something to note is that you can stillcapturea block-scoped variable before it’s declared.\nThe only catch is that it’s illegal to call that function before the declaration.\nIf targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfoo() {// okay to capture 'a'returna;}// illegal call 'foo' before 'a' is declared// runtimes should throw an error herefoo();leta;"
                },
                {
                    "type": "p",
                    "text": "For more information on temporal dead zones, see relevant content on theMozilla Developer Network."
                },
                {
                    "type": "p",
                    "text": "Withvardeclarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x) {varx;varx;if(true) {varx;}}"
                },
                {
                    "type": "p",
                    "text": "In the above example, all declarations ofxactually refer to thesamex, and this is perfectly valid.\nThis often ends up being a source of bugs.\nThankfully,letdeclarations are not as forgiving."
                },
                {
                    "type": "code",
                    "code": "tsletx=10;letx=20;// error: can't re-declare 'x' in the same scope"
                },
                {
                    "type": "p",
                    "text": "The variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x) {letx=100;// error: interferes with parameter declaration}functiong() {letx=100;varx=100;// error: can't have both declarations of 'x'}"
                },
                {
                    "type": "p",
                    "text": "That’s not to say that a block-scoped variable can never be declared with a function-scoped variable.\nThe block-scoped variable just needs to be declared within a distinctly different block."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(condition,x) {if(condition) {letx=100;returnx;}returnx;}f(false,0);// returns '0'f(true,0);// returns '100'"
                },
                {
                    "type": "p",
                    "text": "The act of introducing a new name in a more nested scope is calledshadowing.\nIt is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs.\nFor instance, imagine we had written our earliersumMatrixfunction usingletvariables."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsumMatrix(matrix:number[][]) {letsum=0;for(leti=0;i<matrix.length;i++) {varcurrentRow=matrix[i];for(leti=0;i<currentRow.length;i++) {sum+=currentRow[i];}}returnsum;}"
                },
                {
                    "type": "p",
                    "text": "This version of the loop will actually perform the summation correctly because the inner loop’sishadowsifrom the outer loop. Shadowing shouldusuallybe avoided in the interest of writing clearer code.\nWhile there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement."
                },
                {
                    "type": "p",
                    "text": "When we first touched on the idea of variable capturing withvardeclaration, we briefly went into how variables act once captured.\nTo give a better intuition of this, each time a scope is run, it creates an “environment” of variables.\nThat environment and its captured variables can exist even after everything within its scope has finished executing."
                },
                {
                    "type": "code",
                    "code": "tsfunctiontheCityThatAlwaysSleeps() {letgetCity;if(true) {letcity=\"Seattle\";getCity=function() {returncity;};}returngetCity();}"
                },
                {
                    "type": "p",
                    "text": "Because we’ve capturedcityfrom within its environment, we’re still able to access it despite the fact that theifblock finished executing. Recall that with our earliersetTimeoutexample, we ended up needing to use an IIFE to capture the state of a variable for every iteration of theforloop.\nIn effect, what we were doing was creating a new variable environment for our captured variables.\nThat was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript. letdeclarations have drastically different behavior when declared as part of a loop.\nRather than just introducing a new environment to the loop itself, these declarations sort of create a new scopeper iteration.\nSince this is what we were doing anyway with our IIFE, we can change our oldsetTimeoutexample to just use aletdeclaration."
                },
                {
                    "type": "code",
                    "code": "tsfor(leti=0;i<10;i++) {setTimeout(function() {console.log(i);},100*i);}"
                },
                {
                    "type": "p",
                    "text": "and as expected, this will print out"
                },
                {
                    "type": "code",
                    "code": "0123456789"
                },
                {
                    "type": "p",
                    "text": "constdeclarations are another way of declaring variables."
                },
                {
                    "type": "code",
                    "code": "tsconstnumLivesForCat=9;"
                },
                {
                    "type": "p",
                    "text": "They are likeletdeclarations but, as their name implies, their value cannot be changed once they are bound.\nIn other words, they have the same scoping rules aslet, but you can’t re-assign to them. This should not be confused with the idea that the values they refer to areimmutable."
                },
                {
                    "type": "code",
                    "code": "tsconstnumLivesForCat=9;constkitty= {name:\"Aurora\",numLives:numLivesForCat,};// Errorkitty= {name:\"Danielle\",numLives:numLivesForCat,};// all \"okay\"kitty.name=\"Rory\";kitty.name=\"Kitty\";kitty.name=\"Cat\";kitty.numLives--;"
                },
                {
                    "type": "p",
                    "text": "Unless you take specific measures to avoid it, the internal state of aconstvariable is still modifiable.\nFortunately, TypeScript allows you to specify that members of an object arereadonly.\nThechapter on Interfaceshas the details."
                },
                {
                    "type": "p",
                    "text": "Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use.\nLike most broad questions, the answer is: it depends. Applying theprinciple of least privilege, all declarations other than those you plan to modify should useconst.\nThe rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable.\nUsingconstalso makes code more predictable when reasoning about flow of data. Use your best judgement, and if applicable, consult the matter with the rest of your team. The majority of this handbook usesletdeclarations."
                },
                {
                    "type": "p",
                    "text": "Another ECMAScript 2015 feature that TypeScript has is destructuring.\nFor a complete reference, seethe article on the Mozilla Developer Network.\nIn this section, we’ll give a short overview."
                },
                {
                    "type": "p",
                    "text": "The simplest form of destructuring is array destructuring assignment:"
                },
                {
                    "type": "code",
                    "code": "tsletinput= [1,2];let[first,second] =input;console.log(first);// outputs 1console.log(second);// outputs 2"
                },
                {
                    "type": "p",
                    "text": "This creates two new variables namedfirstandsecond.\nThis is equivalent to using indexing, but is much more convenient:"
                },
                {
                    "type": "code",
                    "code": "tsfirst=input[0];second=input[1];"
                },
                {
                    "type": "p",
                    "text": "Destructuring works with already-declared variables as well:"
                },
                {
                    "type": "code",
                    "code": "ts// swap variables[first,second] = [second,first];"
                },
                {
                    "type": "p",
                    "text": "And with parameters to a function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf([first,second]: [number,number]) {console.log(first);console.log(second);}f([1,2]);"
                },
                {
                    "type": "p",
                    "text": "You can create a variable for the remaining items in a list using the syntax...:"
                },
                {
                    "type": "code",
                    "code": "tslet[first, ...rest] = [1,2,3,4];console.log(first);// outputs 1console.log(rest);// outputs [ 2, 3, 4 ]"
                },
                {
                    "type": "p",
                    "text": "Of course, since this is JavaScript, you can just ignore trailing elements you don’t care about:"
                },
                {
                    "type": "code",
                    "code": "tslet[first] = [1,2,3,4];console.log(first);// outputs 1"
                },
                {
                    "type": "p",
                    "text": "Or other elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[,second, ,fourth] = [1,2,3,4];console.log(second);// outputs 2console.log(fourth);// outputs 4"
                },
                {
                    "type": "p",
                    "text": "Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:"
                },
                {
                    "type": "code",
                    "code": "tslettuple: [number,string,boolean] = [7,\"hello\",true];let[a,b,c] =tuple;// a: number, b: string, c: boolean"
                },
                {
                    "type": "p",
                    "text": "It’s an error to destructure a tuple beyond the range of its elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[a,b,c,d] =tuple;// Error, no element at index 3"
                },
                {
                    "type": "p",
                    "text": "As with arrays, you can destructure the rest of the tuple with..., to get a shorter tuple:"
                },
                {
                    "type": "code",
                    "code": "tslet[a, ...bc] =tuple;// bc: [string, boolean]let[a,b,c, ...d] =tuple;// d: [], the empty tuple"
                },
                {
                    "type": "p",
                    "text": "Or ignore trailing elements, or other elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[a] =tuple;// a: numberlet[,b] =tuple;// b: string"
                },
                {
                    "type": "p",
                    "text": "You can also destructure objects:"
                },
                {
                    "type": "code",
                    "code": "tsleto= {a:\"foo\",b:12,c:\"bar\",};let{a,b} =o;"
                },
                {
                    "type": "p",
                    "text": "This creates new variablesaandbfromo.aando.b.\nNotice that you can skipcif you don’t need it. Like array destructuring, you can have assignment without declaration:"
                },
                {
                    "type": "code",
                    "code": "ts({a,b} = {a:\"baz\",b:101});"
                },
                {
                    "type": "p",
                    "text": "Notice that we had to surround this statement with parentheses.\nJavaScript normally parses a{as the start of block. You can create a variable for the remaining items in an object using the syntax...:"
                },
                {
                    "type": "code",
                    "code": "tslet{a, ...passthrough} =o;lettotal=passthrough.b+passthrough.c.length;"
                },
                {
                    "type": "p",
                    "text": "You can also give different names to properties:"
                },
                {
                    "type": "code",
                    "code": "tslet{a:newName1,b:newName2} =o;"
                },
                {
                    "type": "p",
                    "text": "Here the syntax starts to get confusing.\nYou can reada: newName1as ”aasnewName1”.\nThe direction is left-to-right, as if you had written:"
                },
                {
                    "type": "code",
                    "code": "tsletnewName1=o.a;letnewName2=o.b;"
                },
                {
                    "type": "p",
                    "text": "Confusingly, the colon here doesnotindicate the type.\nThe type, if you specify it, still needs to be written after the entire destructuring:"
                },
                {
                    "type": "code",
                    "code": "tslet{a:newName1,b:newName2}: {a:string;b:number} =o;"
                },
                {
                    "type": "p",
                    "text": "Default values let you specify a default value in case a property is undefined:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionkeepWholeObject(wholeObject: {a:string;b?:number}) {let{a,b=1001} =wholeObject;}"
                },
                {
                    "type": "p",
                    "text": "In this example theb?indicates thatbis optional, so it may beundefined.keepWholeObjectnow has a variable forwholeObjectas well as the propertiesaandb, even ifbis undefined."
                },
                {
                    "type": "p",
                    "text": "Destructuring also works in function declarations.\nFor simple cases this is straightforward:"
                },
                {
                    "type": "code",
                    "code": "tstypeC= {a:string;b?:number};functionf({a,b}:C):void{// ...}"
                },
                {
                    "type": "p",
                    "text": "But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky.\nFirst of all, you need to remember to put the pattern before the default value."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf({a=\"\",b=0} = {}):void{// ...}f();"
                },
                {
                    "type": "p",
                    "text": "The snippet above is an example of type inference, explained earlier in the handbook."
                },
                {
                    "type": "p",
                    "text": "Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer.\nRemember thatCwas defined withboptional:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf({a,b=0} = {a:\"\"}):void{// ...}f({a:\"yes\"});// ok, default b = 0f();// ok, default to { a: \"\" }, which then defaults b = 0f({});// error, 'a' is required if you supply an argument"
                },
                {
                    "type": "p",
                    "text": "Use destructuring with care.\nAs the previous example demonstrates, anything but the simplest destructuring expression is confusing.\nThis is especially true with deeply nested destructuring, which getsreallyhard to understand even without piling on renaming, default values, and type annotations.\nTry to keep destructuring expressions small and simple.\nYou can always write the assignments that destructuring would generate yourself."
                },
                {
                    "type": "p",
                    "text": "The spread operator is the opposite of destructuring.\nIt allows you to spread an array into another array, or an object into another object.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsletfirst= [1,2];letsecond= [3,4];letbothPlus= [0, ...first, ...second,5];"
                },
                {
                    "type": "p",
                    "text": "This gives bothPlus the value[0, 1, 2, 3, 4, 5].\nSpreading creates a shallow copy offirstandsecond.\nThey are not changed by the spread. You can also spread objects:"
                },
                {
                    "type": "code",
                    "code": "tsletdefaults= {food:\"spicy\",price:\"$$\",ambiance:\"noisy\"};letsearch= { ...defaults,food:\"rich\"};"
                },
                {
                    "type": "p",
                    "text": "Nowsearchis{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }.\nObject spreading is more complex than array spreading.\nLike array spreading, it proceeds from left-to-right, but the result is still an object.\nThis means that properties that come later in the spread object overwrite properties that come earlier.\nSo if we modify the previous example to spread at the end:"
                },
                {
                    "type": "code",
                    "code": "tsletdefaults= {food:\"spicy\",price:\"$$\",ambiance:\"noisy\"};letsearch= {food:\"rich\", ...defaults};"
                },
                {
                    "type": "p",
                    "text": "Then thefoodproperty indefaultsoverwritesfood: \"rich\", which is not what we want in this case. Object spread also has a couple of other surprising limits.\nFirst, it only includes an objects’own, enumerable properties.\nBasically, that means you lose methods when you spread instances of an object:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{p=12;m() {}}letc=newC();letclone= { ...c};clone.p;// okclone.m();// error!"
                },
                {
                    "type": "p",
                    "text": "Second, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions.\nThat feature is expected in future versions of the language."
                },
                {
                    "type": "p",
                    "text": "usingdeclarations are an upcoming feature for JavaScript that are part of theStage 3 Explicit Resource Managementproposal. Ausingdeclaration is much like aconstdeclaration, except that it couples thelifetimeof the value bound to the\ndeclaration with thescopeof the variable. When control exits the block containing ausingdeclaration, the[Symbol.dispose]()method of the\ndeclared value is executed, which allows that value to perform cleanup:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {usingx=newC();doSomethingWith(x);}// `x[Symbol.dispose]()` is called"
                },
                {
                    "type": "p",
                    "text": "At runtime, this has an effectroughlyequivalent to the following:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {constx=newC();try{doSomethingWith(x);}finally{x[Symbol.dispose]();}}"
                },
                {
                    "type": "p",
                    "text": "usingdeclarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to\nnative references like file handles"
                },
                {
                    "type": "code",
                    "code": "ts{usingfile=awaitopenFile();file.write(text);doSomethingThatMayThrow();}// `file` is disposed, even if an error is thrown"
                },
                {
                    "type": "p",
                    "text": "or scoped operations like tracing"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {usingactivity=newTraceActivity(\"f\");// traces entry into function// ...}// traces exit of function"
                },
                {
                    "type": "p",
                    "text": "Unlikevar,let, andconst,usingdeclarations do not support destructuring."
                },
                {
                    "type": "p",
                    "text": "It’s important to note that the value can benullorundefined, in which case nothing is disposed at the end of the\nblock:"
                },
                {
                    "type": "code",
                    "code": "ts{usingx=b?newC() :null;// ...}"
                },
                {
                    "type": "p",
                    "text": "which isroughlyequivalent to:"
                },
                {
                    "type": "code",
                    "code": "ts{constx=b?newC() :null;try{// ...}finally{x?.[Symbol.dispose]();}}"
                },
                {
                    "type": "p",
                    "text": "This allows you to conditionally acquire resources when declaring ausingdeclaration without the need for complex\nbranching or repetition."
                },
                {
                    "type": "p",
                    "text": "You can indicate the classes or objects you produce are disposable by implementing theDisposableinterface:"
                },
                {
                    "type": "code",
                    "code": "ts// from the default lib:interfaceDisposable{[Symbol.dispose]():void;}// usage:classTraceActivityimplementsDisposable{readonlyname:string;constructor(name:string) {this.name=name;console.log(`Entering:${name}`);}[Symbol.dispose]():void{console.log(`Exiting:${name}`);}}functionf() {using_activity=newTraceActivity(\"f\");console.log(\"Hello world!\");}f();// prints://   Entering: f//   Hello world!//   Exiting: f"
                },
                {
                    "type": "p",
                    "text": "Some resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, theExplicit Resource Managementproposal also introduces\ntheawait usingdeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {awaitusingx=newC();}// `await x[Symbol.asyncDispose]()` is invoked"
                },
                {
                    "type": "p",
                    "text": "Anawait usingdeclaration invokes, andawaits, its value’s[Symbol.asyncDispose]()method as control leaves the\ncontaining block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit,\nor a file stream flushing any pending writes to storage before it is closed. As withawait,await usingcan only be used in anasyncfunction or method, or at the top level of a module."
                },
                {
                    "type": "p",
                    "text": "Just asusingrelies on objects that areDisposable, anawait usingrelies on objects that areAsyncDisposable:"
                },
                {
                    "type": "code",
                    "code": "ts// from the default lib:interfaceAsyncDisposable{[Symbol.asyncDispose]:PromiseLike<void>;}// usage:classDatabaseTransactionimplementsAsyncDisposable{publicsuccess=false;privatedb:Database|undefined;privateconstructor(db:Database) {this.db=db;}staticasynccreate(db:Database) {awaitdb.execAsync(\"BEGIN TRANSACTION\");returnnewDatabaseTransaction(db);}async[Symbol.asyncDispose]() {if(this.db) {constdb=this.db:this.db=undefined;if(this.success) {awaitdb.execAsync(\"COMMIT TRANSACTION\");}else{awaitdb.execAsync(\"ROLLBACK TRANSACTION\");}}}}asyncfunctiontransfer(db:Database,account1:Account,account2:Account,amount:number) {usingtx=awaitDatabaseTransaction.create(db);if(awaitdebitAccount(db,account1,amount)) {awaitcreditAccount(db,account2,amount);}// if an exception is thrown before this line, the transaction will roll backtx.success=true;// now the transaction will commit}"
                },
                {
                    "type": "p",
                    "text": "Theawaitkeyword that is part of theawait usingdeclaration only indicates that thedisposalof the resource isawait-ed. It doesnotawaitthe value itself:"
                },
                {
                    "type": "code",
                    "code": "ts{awaitusingx=getResourceSynchronously();}// performs `await x[Symbol.asyncDispose]()`{awaitusingy=awaitgetResourceAsynchronously();}// performs `await y[Symbol.asyncDispose]()`"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that there is a small caveat with this behavior if you are using anawait usingdeclaration in\nanasyncfunction that returns aPromisewithout firstawait-ing it:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiong() {returnPromise.reject(\"error!\");}asyncfunctionf() {awaitusingx=newC();returng();// missing an `await`}"
                },
                {
                    "type": "p",
                    "text": "Because the returned promise isn’tawait-ed, it’s possible that the JavaScript runtime may report an unhandled\nrejection since execution pauses whileawait-ing the asynchronous disposal ofx, without having subscribed to the\nreturned promise. This is not a problem that is unique toawait using, however, as this can also occur in anasyncfunction that usestry..finally:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {try{returng();// also reports an unhandled rejection}finally{awaitsomethingElse();}}"
                },
                {
                    "type": "p",
                    "text": "To avoid this situation, it is recommended that youawaityour return value if it may be aPromise:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {awaitusingx=newC();returnawaitg();}"
                },
                {
                    "type": "p",
                    "text": "Bothusingandawait usingcan be used in aforstatement:"
                },
                {
                    "type": "code",
                    "code": "tsfor(usingx=getReader(); !x.eof;x.next()) {// ...}"
                },
                {
                    "type": "p",
                    "text": "In this case, the lifetime ofxis scoped to the entireforstatement and is only disposed when control leaves the\nloop due tobreak,return,throw, or when the loop condition is false. In addition toforstatements, both declarations can also be used infor..ofstatements:"
                },
                {
                    "type": "code",
                    "code": "tsfunction*g() {yieldcreateResource1();yieldcreateResource2();}for(usingxofg()) {// ...}"
                },
                {
                    "type": "p",
                    "text": "Here,xis disposed at the end ofeach iteration of the loop, and is then reinitialized with the next value. This is\nespecially useful when consuming resources produced one at a time by a generator."
                },
                {
                    "type": "p",
                    "text": "usingandawait usingdeclarations can be used when targeting older ECMAScript editions as long as you are using\na compatible polyfill forSymbol.dispose/Symbol.asyncDispose, such as the one provided by default in recent\neditions of NodeJS."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Dec 09, 2024"
                }
            ]
        }
    ]
}