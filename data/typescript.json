[{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html", "title": "Documentation - TypeScript 5.0", "text": "Decorators\nDecorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way.\nLet\u2019s consider the following code:\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}greet() {console.log(`Hello, my name is ${this.name}.`);}}const p = new Person(\"Ray\");p.greet();\ngreet\nis pretty simple here, but let\u2019s imagine it\u2019s something way more complicated - maybe it does some async logic, it\u2019s recursive, it has side effects, etc.\nRegardless of what kind of ball-of-mud you\u2019re imagining, let\u2019s say you throw in some console.log\ncalls to help debug greet\n.\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}greet() {console.log(\"LOG: Entering method.\");console.log(`Hello, my name is ${this.name}.`);console.log(\"LOG: Exiting method.\")}}\nThis pattern is fairly common. It sure would be nice if there was a way we could do this for every method!\nThis is where decorators come in.\nWe can write a function called loggedMethod\nthat looks like the following:\nts\nfunction loggedMethod(originalMethod: any, _context: any) {function replacementMethod(this: any, ...args: any[]) {console.log(\"LOG: Entering method.\")const result = originalMethod.call(this, ...args);console.log(\"LOG: Exiting method.\")return result;}return replacementMethod;}\n\u201cWhat\u2019s the deal with all of these any\ns?\nWhat is this, any\nScript!?\u201d\nJust be patient - we\u2019re keeping things simple for now so that we can focus on what this function is doing.\nNotice that loggedMethod\ntakes the original method (originalMethod\n) and returns a function that\n- logs an \u201cEntering\u2026\u201d message\n- passes along\nthis\nand all of its arguments to the original method - logs an \u201cExiting\u2026\u201d message, and\n- returns whatever the original method returned.\nNow we can use loggedMethod\nto decorate the method greet\n:\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}@loggedMethodgreet() {console.log(`Hello, my name is ${this.name}.`);}}const p = new Person(\"Ray\");p.greet();// Output://// LOG: Entering method.// Hello, my name is Ray.// LOG: Exiting method.\nWe just used loggedMethod\nas a decorator above greet\n- and notice that we wrote it as @loggedMethod\n.\nWhen we did that, it got called with the method target and a context object.\nBecause loggedMethod\nreturned a new function, that function replaced the original definition of greet\n.\nWe didn\u2019t mention it yet, but loggedMethod\nwas defined with a second parameter.\nIt\u2019s called a \u201ccontext object\u201d, and it has some useful information about how the decorated method was declared - like whether it was a #private\nmember, or static\n, or what the name of the method was.\nLet\u2019s rewrite loggedMethod\nto take advantage of that and print out the name of the method that was decorated.\nts\nfunction loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = String(context.name);function replacementMethod(this: any, ...args: any[]) {console.log(`LOG: Entering method '${methodName}'.`)const result = originalMethod.call(this, ...args);console.log(`LOG: Exiting method '${methodName}'.`)return result;}return replacementMethod;}\nWe\u2019re now using the context parameter - and that it\u2019s the first thing in loggedMethod\nthat has a type stricter than any\nand any[]\n.\nTypeScript provides a type called ClassMethodDecoratorContext\nthat models the context object that method decorators take.\nApart from metadata, the context object for methods also has a useful function called addInitializer\n.\nIt\u2019s a way to hook into the beginning of the constructor (or the initialization of the class itself if we\u2019re working with static\ns).\nAs an example - in JavaScript, it\u2019s common to write something like the following pattern:\nts\nclass Person {name: string;constructor(name: string) {this.name = name;this.greet = this.greet.bind(this);}greet() {console.log(`Hello, my name is ${this.name}.`);}}\nAlternatively, greet\nmight be declared as a property initialized to an arrow function.\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}greet = () => {console.log(`Hello, my name is ${this.name}.`);};}\nThis code is written to ensure that this\nisn\u2019t re-bound if greet\nis called as a stand-alone function or passed as a callback.\nts\nconst greet = new Person(\"Ray\").greet;// We don't want this to fail!greet();\nWe can write a decorator that uses addInitializer\nto call bind\nin the constructor for us.\nts\nfunction bound(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = context.name;if (context.private) {throw new Error(`'bound' cannot decorate private properties like ${methodName as string}.`);}context.addInitializer(function () {this[methodName] = this[methodName].bind(this);});}\nbound\nisn\u2019t returning anything - so when it decorates a method, it leaves the original alone.\nInstead, it will add logic before any other fields are initialized.\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}@bound@loggedMethodgreet() {console.log(`Hello, my name is ${this.name}.`);}}const p = new Person(\"Ray\");const greet = p.greet;// Works!greet();\nNotice that we stacked two decorators - @bound\nand @loggedMethod\n.\nThese decorations run in \u201creverse order\u201d.\nThat is, @loggedMethod\ndecorates the original method greet\n, and @bound\ndecorates the result of @loggedMethod\n.\nIn this example, it doesn\u2019t matter - but it could if your decorators have side-effects or expect a certain order.\nAlso worth noting - if you\u2019d prefer stylistically, you can put these decorators on the same line.\nts\n@bound @loggedMethod greet() {console.log(`Hello, my name is ${this.name}.`);}\nSomething that might not be obvious is that we can even make functions that return decorator functions.\nThat makes it possible to customize the final decorator just a little.\nIf we wanted, we could have made loggedMethod\nreturn a decorator and customize how it logs its messages.\nts\nfunction loggedMethod(headMessage = \"LOG:\") {return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = String(context.name);function replacementMethod(this: any, ...args: any[]) {console.log(`${headMessage} Entering method '${methodName}'.`)const result = originalMethod.call(this, ...args);console.log(`${headMessage} Exiting method '${methodName}'.`)return result;}return replacementMethod;}}\nIf we did that, we\u2019d have to call loggedMethod\nbefore using it as a decorator.\nWe could then pass in any string as the prefix for messages that get logged to the console.\nts\nclass Person {name: string;constructor(name: string) {this.name = name;}@loggedMethod(\"\u26a0\ufe0f\")greet() {console.log(`Hello, my name is ${this.name}.`);}}const p = new Person(\"Ray\");p.greet();// Output://// \u26a0\ufe0f Entering method 'greet'.// Hello, my name is Ray.// \u26a0\ufe0f Exiting method 'greet'.\nDecorators can be used on more than just methods! They can be used on properties/fields, getters, setters, and auto-accessors. Even classes themselves can be decorated for things like subclassing and registration.\nTo learn more about decorators in-depth, you can read up on Axel Rauschmayer\u2019s extensive summary.\nFor more information about the changes involved, you can view the original pull request.\nDifferences with Experimental Legacy Decorators\nIf you\u2019ve been using TypeScript for a while, you might be aware of the fact that it\u2019s had support for \u201cexperimental\u201d decorators for years.\nWhile these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called --experimentalDecorators\n.\nAny attempt to use decorators in TypeScript without this flag used to prompt an error message.\n--experimentalDecorators\nwill continue to exist for the foreseeable future;\nhowever, without the flag, decorators will now be valid syntax for all new code.\nOutside of --experimentalDecorators\n, they will be type-checked and emitted differently.\nThe type-checking rules and emit are sufficiently different that while decorators can be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so.\nThis new decorators proposal is not compatible with --emitDecoratorMetadata\n, and it does not allow decorating parameters.\nFuture ECMAScript proposals may be able to help bridge that gap.\nOn a final note: in addition to allowing decorators to be placed before the export\nkeyword, the proposal for decorators now provides the option of placing decorators after export\nor export default\n.\nThe only exception is that mixing the two styles is not allowed.\njs\n// \u2705 allowed@register export default class Foo {// ...}// \u2705 also allowedexport default @register class Bar {// ...}// \u274c error - before *and* after is not allowed@before export @after class Bar {// ...}\nWriting Well-Typed Decorators\nThe loggedMethod\nand bound\ndecorator examples above are intentionally simple and omit lots of details about types.\nTyping decorators can be fairly complex.\nFor example, a well-typed version of loggedMethod\nfrom above might look something like this:\nts\nfunction loggedMethod<This, Args extends any[], Return>(target: (this: This, ...args: Args) => Return,context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>) {const methodName = String(context.name);function replacementMethod(this: This, ...args: Args): Return {console.log(`LOG: Entering method '${methodName}'.`)const result = target.call(this, ...args);console.log(`LOG: Exiting method '${methodName}'.`)return result;}return replacementMethod;}\nWe had to separately model out the type of this\n, the parameters, and the return type of the original method, using the type parameters This\n, Args\n, and Return\n.\nExactly how complex your decorators functions are defined depends on what you want to guarantee. Just keep in mind, your decorators will be used more than they\u2019re written, so a well-typed version will usually be preferable - but there\u2019s clearly a trade-off with readability, so try to keep things simple.\nMore documentation on writing decorators will be available in the future - but this post should have a good amount of detail for the mechanics of decorators.\nconst\nType Parameters\nWhen inferring the type of an object, TypeScript will usually choose a type that\u2019s meant to be general.\nFor example, in this case, the inferred type of names\nis string[]\n:\nts\ntype HasNames = { names: readonly string[] };function getNamesExactly<T extends HasNames>(arg: T): T[\"names\"] {return arg.names;}// Inferred type: string[]const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});\nUsually the intent of this is to enable mutation down the line.\nHowever, depending on what exactly getNamesExactly\ndoes and how it\u2019s intended to be used, it can often be the case that a more-specific type is desired.\nUp until now, API authors have typically had to recommend adding as const\nin certain places to achieve the desired inference:\nts\n// The type we wanted:// readonly [\"Alice\", \"Bob\", \"Eve\"]// The type we got:// string[]const names1 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});// Correctly gets what we wanted:// readonly [\"Alice\", \"Bob\", \"Eve\"]const names2 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]} as const);\nThis can be cumbersome and easy to forget.\nIn TypeScript 5.0, you can now add a const\nmodifier to a type parameter declaration to cause const\n-like inference to be the default:\nts\ntype HasNames = { names: readonly string[] };function getNamesExactly<const T extends HasNames>(arg: T): T[\"names\"] {// ^^^^^return arg.names;}// Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"]// Note: Didn't need to write 'as const' hereconst names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"] });\nNote that the const\nmodifier doesn\u2019t reject mutable values, and doesn\u2019t require immutable constraints.\nUsing a mutable type constraint might give surprising results.\nFor example:\nts\ndeclare function fnBad<const T extends string[]>(args: T): void;// 'T' is still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' is not assignable to 'string[]'fnBad([\"a\", \"b\" ,\"c\"]);\nHere, the inferred candidate for T\nis readonly [\"a\", \"b\", \"c\"]\n, and a readonly\narray can\u2019t be used where a mutable one is needed.\nIn this case, inference falls back to the constraint, the array is treated as string[]\n, and the call still proceeds successfully.\nA better definition of this function should use readonly string[]\n:\nts\ndeclare function fnGood<const T extends readonly string[]>(args: T): void;// T is readonly [\"a\", \"b\", \"c\"]fnGood([\"a\", \"b\" ,\"c\"]);\nSimilarly, remember to keep in mind that the const\nmodifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn\u2019t (or couldn\u2019t) be modified with as const\nwon\u2019t see any change in behavior:\nts\ndeclare function fnGood<const T extends readonly string[]>(args: T): void;const arr = [\"a\", \"b\" ,\"c\"];// 'T' is still 'string[]'-- the 'const' modifier has no effect herefnGood(arr);\nSee the pull request and the (first and second second) motivating issues for more details.\nSupporting Multiple Configuration Files in extends\nWhen managing multiple projects, it can be helpful to have a \u201cbase\u201d configuration file that other tsconfig.json\nfiles can extend from.\nThat\u2019s why TypeScript supports an extends\nfield for copying over fields from compilerOptions\n.\njsonc\n// packages/front-end/src/tsconfig.json{\"extends\": \"../../../tsconfig.base.json\",\"compilerOptions\": {\"outDir\": \"../lib\",// ...}}\nHowever, there are scenarios where you might want to extend from multiple configuration files.\nFor example, imagine using a TypeScript base configuration file shipped to npm.\nIf you want all your projects to also use the options from the @tsconfig/strictest\npackage on npm, then there\u2019s a simple solution: have tsconfig.base.json\nextend from @tsconfig/strictest\n:\njsonc\n// tsconfig.base.json{\"extends\": \"@tsconfig/strictest/tsconfig.json\",\"compilerOptions\": {// ...}}\nThis works to a point.\nIf you have any projects that don\u2019t want to use @tsconfig/strictest\n, they have to either manually disable the options, or create a separate version of tsconfig.base.json\nthat doesn\u2019t extend from @tsconfig/strictest\n.\nTo give some more flexibility here, Typescript 5.0 now allows the extends\nfield to take multiple entries.\nFor example, in this configuration file:\njsonc\n{\"extends\": [\"a\", \"b\", \"c\"],\"compilerOptions\": {// ...}}\nWriting this is kind of like extending c\ndirectly, where c\nextends b\n, and b\nextends a\n.\nIf any fields \u201cconflict\u201d, the latter entry wins.\nSo in the following example, both strictNullChecks\nand noImplicitAny\nare enabled in the final tsconfig.json\n.\njsonc\n// tsconfig1.json{\"compilerOptions\": {\"strictNullChecks\": true}}// tsconfig2.json{\"compilerOptions\": {\"noImplicitAny\": true}}// tsconfig.json{\"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"],\"files\": [\"./index.ts\"]}\nAs another example, we can rewrite our original example in the following way.\njsonc\n// packages/front-end/src/tsconfig.json{\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"../../../tsconfig.base.json\"],\"compilerOptions\": {\"outDir\": \"../lib\",// ...}}\nFor more details, read more on the original pull request.\nAll enum\ns Are Union enum\ns\nWhen TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type.\nts\nenum E {Foo = 10,Bar = 20,}\nThe only thing special about E.Foo\nand E.Bar\nwas that they were assignable to anything expecting the type E\n.\nOther than that, they were pretty much just number\ns.\nts\nfunction takeValue(e: E) {}takeValue(E.Foo); // workstakeValue(123); // error!\nIt wasn\u2019t until TypeScript 2.0 introduced enum literal types that enums got a bit more special. Enum literal types gave each enum member its own type, and turned the enum itself into a union of each member type. They also allowed us to refer to only a subset of the types of an enum, and to narrow away those types.\nts\n// Color is like a union of Red | Orange | Yellow | Green | Blue | Violetenum Color {Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet}// Each enum member has its own type that we can refer to!type PrimaryColor = Color.Red | Color.Green | Color.Blue;function isPrimaryColor(c: Color): c is PrimaryColor {// Narrowing literal types can catch bugs.// TypeScript will error here because// we'll end up comparing 'Color.Red' to 'Color.Green'.// We meant to use ||, but accidentally wrote &&.return c === Color.Red && c === Color.Green && c === Color.Blue;}\nOne issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member. In some cases it\u2019s not possible to compute that value - for instance, an enum member could be initialized by a function call.\nts\nenum E {Blah = Math.random()}\nWhenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy. That meant giving up all the advantages of unions and literal types.\nTypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member. That means that all enums can now be narrowed and have their members referenced as types as well.\nFor more details on this change, you can read the specifics on GitHub.\n--moduleResolution bundler\nTypeScript 4.7 introduced the node16\nand nodenext\noptions for its --module\nand --moduleResolution\nsettings.\nThe intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js;\nhowever, this mode has many restrictions that other tools don\u2019t really enforce.\nFor example, in an ECMAScript module in Node.js, any relative import needs to include a file extension.\njs\n// entry.mjsimport * as utils from \"./utils\"; // \u274c wrong - we need to include the file extension.import * as utils from \"./utils.mjs\"; // \u2705 works\nThere are certain reasons for this in Node.js and the browser - it makes file lookups faster and works better for naive file servers.\nBut for many developers using tools like bundlers, the node16\n/nodenext\nsettings were cumbersome because bundlers don\u2019t have most of these restrictions.\nIn some ways, the node\nresolution mode was better for anyone using a bundler.\nBut in some ways, the original node\nresolution mode was already out of date.\nMost modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js.\nFor example, extensionless imports work just fine just like in CommonJS, but when looking through the export\nconditions of a package, they\u2019ll prefer an import\ncondition just like in an ECMAScript file.\nTo model how bundlers work, TypeScript now introduces a new strategy: --moduleResolution bundler\n.\njsonc\n{\"compilerOptions\": {\"target\": \"esnext\",\"moduleResolution\": \"bundler\"}}\nIf you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new bundler\noption should be a good fit for you.\nOn the other hand, if you\u2019re writing a library that\u2019s meant to be published on npm, using the bundler\noption can hide compatibility issues that may arise for your users who aren\u2019t using a bundler.\nSo in these cases, using the node16\nor nodenext\nresolution options is likely to be a better path.\nTo read more on --moduleResolution bundler\n, take a look at the implementing pull request.\nResolution Customization Flags\nJavaScript tooling may now model \u201chybrid\u201d resolution rules, like in the bundler\nmode we described above.\nBecause tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration.\nallowImportingTsExtensions\n--allowImportingTsExtensions\nallows TypeScript files to import each other with a TypeScript-specific extension like .ts\n, .mts\n, or .tsx\n.\nThis flag is only allowed when --noEmit\nor --emitDeclarationOnly\nis enabled, since these import paths would not be resolvable at runtime in JavaScript output files.\nThe expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between .ts\nfiles work.\nresolvePackageJsonExports\n--resolvePackageJsonExports\nforces TypeScript to consult the exports\nfield of package.json\nfiles if it ever reads from a package in node_modules\n.\nThis option defaults to true\nunder the node16\n, nodenext\n, and bundler\noptions for --moduleResolution\n.\nresolvePackageJsonImports\n--resolvePackageJsonImports\nforces TypeScript to consult the imports\nfield of package.json\nfiles when performing a lookup that starts with #\nfrom a file whose ancestor directory contains a package.json\n.\nThis option defaults to true\nunder the node16\n, nodenext\n, and bundler\noptions for --moduleResolution\n.\nallowArbitraryExtensions\nIn TypeScript 5.0, when an import path ends in an extension that isn\u2019t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of {file basename}.d.{extension}.ts\n.\nFor example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\ncss\n/* app.css */.cookie-banner {display: none;}\nts\n// app.d.css.tsdeclare const css: {cookieBanner: string;};export default css;\nts\n// App.tsximport styles from \"./app.css\";styles.cookieBanner; // string\nBy default, this import will raise an error to let you know that TypeScript doesn\u2019t understand this file type and your runtime might not support importing it.\nBut if you\u2019ve configured your runtime or bundler to handle it, you can suppress the error with the new --allowArbitraryExtensions\ncompiler option.\nNote that historically, a similar effect has often been achievable by adding a declaration file named app.css.d.ts\ninstead of app.d.css.ts\n- however, this just worked through Node\u2019s require\nresolution rules for CommonJS.\nStrictly speaking, the former is interpreted as a declaration file for a JavaScript file named app.css.js\n.\nBecause relative files imports need to include extensions in Node\u2019s ESM support, TypeScript would error on our example in an ESM file under --moduleResolution node16\nor nodenext\n.\nFor more information, read up the proposal for this feature and its corresponding pull request.\ncustomConditions\n--customConditions\ntakes a list of additional conditions that should succeed when TypeScript resolves from an exports\nor imports\nfield of a package.json\n.\nThese conditions are added to whatever existing conditions a resolver will use by default.\nFor example, when this field is set in a tsconfig.json\nas so:\njsonc\n{\"compilerOptions\": {\"target\": \"es2022\",\"moduleResolution\": \"bundler\",\"customConditions\": [\"my-condition\"]}}\nAny time an exports\nor imports\nfield is referenced in package.json\n, TypeScript will consider conditions called my-condition\n.\nSo when importing from a package with the following package.json\njsonc\n{// ...\"exports\": {\".\": {\"my-condition\": \"./foo.mjs\",\"node\": \"./bar.mjs\",\"import\": \"./baz.mjs\",\"require\": \"./biz.mjs\"}}}\nTypeScript will try to look for files corresponding to foo.mjs\n.\nThis field is only valid under the node16\n, nodenext\n, and bundler\noptions for --moduleResolution\n--verbatimModuleSyntax\nBy default, TypeScript does something called import elision. Basically, if you write something like\nts\nimport { Car } from \"./car\";export function drive(car: Car) {// ...}\nTypeScript detects that you\u2019re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\njs\nexport function drive(car) {// ...}\nMost of the time this is good, because if Car\nisn\u2019t a value that\u2019s exported from ./car\n, we\u2019ll get a runtime error.\nBut it does add a layer of complexity for certain edge cases.\nFor example, notice there\u2019s no statement like import \"./car\";\n- the import was dropped entirely.\nThat actually makes a difference for modules that have side-effects or not.\nTypeScript\u2019s emit strategy for JavaScript also has another few layers of complexity - import elision isn\u2019t always just driven by how an import is used - it often consults how a value is declared as well. So it\u2019s not always clear whether code like the following\nts\nexport { Car } from \"./car\";\nshould be preserved or dropped.\nIf Car\nis declared with something like a class\n, then it can be preserved in the resulting JavaScript file.\nBut if Car\nis only declared as a type\nalias or interface\n, then the JavaScript file shouldn\u2019t export Car\nat all.\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\nThe type\nmodifier on imports and exports helps with these situations a bit.\nWe can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the type\nmodifier.\nts\n// This statement can be dropped entirely in JS outputimport type * as car from \"./car\";// The named import/export 'Car' can be dropped in JS outputimport { type Car } from \"./car\";export { type Car } from \"./car\";\ntype\nmodifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between type\nand plain imports and exports.\nSo TypeScript has the flag --importsNotUsedAsValues\nto make sure you use the type\nmodifier, --preserveValueImports\nto prevent some module elision behavior, and --isolatedModules\nto make sure that your TypeScript code works across different compilers.\nUnfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\nTypeScript 5.0 introduces a new option called --verbatimModuleSyntax\nto simplify the situation.\nThe rules are much simpler - any imports or exports without a type\nmodifier are left around.\nAnything that uses the type\nmodifier is dropped entirely.\nts\n// Erased away entirely.import type { A } from \"a\";// Rewritten to 'import { b } from \"bcd\";'import { b, type c, type d } from \"bcd\";// Rewritten to 'import {} from \"xyz\";'import { type xyz } from \"xyz\";\nWith this new option, what you see is what you get.\nThat does have some implications when it comes to module interop though.\nUnder this flag, ECMAScript import\ns and export\ns won\u2019t be rewritten to require\ncalls when your settings or file extension implied a different module system.\nInstead, you\u2019ll get an error.\nIf you need to emit code that uses require\nand module.exports\n, you\u2019ll have to use TypeScript\u2019s module syntax that predates ES2015:\n| Input TypeScript | Output JavaScript |\n|---|---|\n|\n|\n|\n|\nWhile this is a limitation, it does help make some issues more obvious.\nFor example, it\u2019s very common to forget to set the type\nfield in package.json\nunder --module node16\n.\nAs a result, developers would start writing CommonJS modules instead of ES modules without realizing it, giving surprising lookup rules and JavaScript output.\nThis new flag ensures that you\u2019re intentional about the file type you\u2019re using because the syntax is intentionally different.\nBecause --verbatimModuleSyntax\nprovides a more consistent story than --importsNotUsedAsValues\nand --preserveValueImports\n, those two existing flags are being deprecated in its favor.\nFor more details, read up on [the original pull request]https://github.com/microsoft/TypeScript/pull/52203 and its proposal issue.\nSupport for export type *\nWhen TypeScript 3.8 introduced type-only imports, the new syntax wasn\u2019t allowed on export * from \"module\"\nor export * as ns from \"module\"\nre-exports. TypeScript 5.0 adds support for both of these forms:\nts\n// models/vehicles.tsexport class Spaceship {// ...}// models/index.tsexport type * as vehicles from \"./vehicles\";// main.tsimport { vehicles } from \"./models\";function takeASpaceship(s: vehicles.Spaceship) {// \u2705 ok - `vehicles` only used in a type position}function makeASpaceship() {return new vehicles.Spaceship();// ^^^^^^^^// 'vehicles' cannot be used as a value because it was exported using 'export type'.}\nYou can read more about the implementation here.\n@satisfies\nSupport in JSDoc\nTypeScript 4.9 introduced the satisfies\noperator.\nIt made sure that the type of an expression was compatible, without affecting the type itself.\nFor example, let\u2019s take the following code:\nts\ninterface CompilerOptions {strict?: boolean;outDir?: string;// ...}interface ConfigSettings {compilerOptions?: CompilerOptions;extends?: string | string[];// ...}let myConfigSettings = {compilerOptions: {strict: true,outDir: \"../lib\",// ...},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],} satisfies ConfigSettings;\nHere, TypeScript knows that myConfigSettings.extends\nwas declared with an array - because while satisfies\nvalidated the type of our object, it didn\u2019t bluntly change it to CompilerOptions\nand lose information.\nSo if we want to map over extends\n, that\u2019s fine.\nts\ndeclare function resolveConfig(configPath: string): CompilerOptions;let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);\nThis was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations.\nThat\u2019s why TypeScript 5.0 is supporting a new JSDoc tag called @satisfies\nthat does exactly the same thing.\n/** @satisfies */\ncan catch type mismatches:\njs\n// @ts-check/*** @typedef CompilerOptions* @prop {boolean} [strict]* @prop {string} [outDir]*//*** @satisfies {CompilerOptions}*/let myCompilerOptions = {outdir: \"../lib\",// ~~~~~~ oops! we meant outDir};\nBut it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code.\njs\n// @ts-check/*** @typedef CompilerOptions* @prop {boolean} [strict]* @prop {string} [outDir]*//*** @typedef ConfigSettings* @prop {CompilerOptions} [compilerOptions]* @prop {string | string[]} [extends]*//*** @satisfies {ConfigSettings}*/let myConfigSettings = {compilerOptions: {strict: true,outDir: \"../lib\",},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],};let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);\n/** @satisfies */\ncan also be used inline on any parenthesized expression.\nWe could have written myCompilerOptions\nlike this:\nts\nlet myConfigSettings = /** @satisfies {ConfigSettings} */ ({compilerOptions: {strict: true,outDir: \"../lib\",},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],});\nWhy? Well, it usually makes more sense when you\u2019re deeper in some other code, like a function call.\njs\ncompileCode(/** @satisfies {CompilerOptions} */ ({// ...}));\nThis feature was provided thanks to Oleksandr Tarasiuk!\n@overload\nSupport in JSDoc\nIn TypeScript, you can specify overloads for a function. Overloads give us a way to say that a function can be called with different arguments, and possibly return different results. They can restrict how callers can actually use our functions, and refine what results they\u2019ll get back.\nts\n// Our overloads:function printValue(str: string): void;function printValue(num: number, maxFractionDigits?: number): void;// Our implementation:function printValue(value: string | number, maximumFractionDigits?: number) {if (typeof value === \"number\") {const formatter = Intl.NumberFormat(\"en-US\", {maximumFractionDigits,});value = formatter.format(value);}console.log(value);}\nHere, we\u2019ve said that printValue\ntakes either a string\nor a number\nas its first argument.\nIf it takes a number\n, it can take a second argument to determine how many fractional digits we can print.\nTypeScript 5.0 now allows JSDoc to declare overloads with a new @overload\ntag.\nEach JSDoc comment with an @overload\ntag is treated as a distinct overload for the following function declaration.\njs\n// @ts-check/*** @overload* @param {string} value* @return {void}*//*** @overload* @param {number} value* @param {number} [maximumFractionDigits]* @return {void}*//*** @param {string | number} value* @param {number} [maximumFractionDigits]*/function printValue(value, maximumFractionDigits) {if (typeof value === \"number\") {const formatter = Intl.NumberFormat(\"en-US\", {maximumFractionDigits,});value = formatter.format(value);}console.log(value);}\nNow regardless of whether we\u2019re writing in a TypeScript or JavaScript file, TypeScript can let us know if we\u2019ve called our functions incorrectly.\nts\n// all allowedprintValue(\"hello!\");printValue(123.45);printValue(123.45, 2);printValue(\"hello!\", 123); // error!\nThis new tag was implemented thanks to Tomasz Lenarcik.\nPassing Emit-Specific Flags Under --build\nTypeScript now allows the following flags to be passed under --build\nmode\n--declaration\n--emitDeclarationOnly\n--declarationMap\n--sourceMap\n--inlineSourceMap\nThis makes it way easier to customize certain parts of a build where you might have different development and production builds.\nFor example, a development build of a library might not need to produce declaration files, but a production build would. A project can configure declaration emit to be off by default and simply be built with\nsh\ntsc --build -p ./my-project-dir\nOnce you\u2019re done iterating in the inner loop, a \u201cproduction\u201d build can just pass the --declaration\nflag.\nsh\ntsc --build -p ./my-project-dir --declaration\nMore information on this change is available here.\nCase-Insensitive Import Sorting in Editors\nIn editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports. Often though, there can be different interpretations of when a list is \u201csorted\u201d.\nFor example, is the following import list sorted?\nts\nimport {Toggle,freeze,toBoolean,} from \"./utils\";\nThe answer might surprisingly be \u201cit depends\u201d.\nIf we don\u2019t care about case-sensitivity, then this list is clearly not sorted.\nThe letter f\ncomes before both t\nand T\n.\nBut in most programming languages, sorting defaults to comparing the byte values of strings.\nThe way JavaScript compares strings means that \"Toggle\"\nalways comes before \"freeze\"\nbecause according to the ASCII character encoding, uppercase letters come before lowercase.\nSo from that perspective, the import list is sorted.\nTypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort. This could be a point of frustration for developers who preferred a case-insensitive ordering, or who used tools like ESLint which require case-insensitive ordering by default.\nTypeScript now detects case sensitivity by default. This means that TypeScript and tools like ESLint typically won\u2019t \u201cfight\u201d each other over how to best sort imports.\nOur team has also been experimenting with further sorting strategies which you can read about here.\nThese options may eventually be configurable by editors.\nFor now, they are still unstable and experimental, and you can opt into them in VS Code today by using the typescript.unstable\nentry in your JSON options.\nBelow are all of the options you can try out (set to their defaults):\njsonc\n{\"typescript.unstable\": {// Should sorting be case-sensitive? Can be:// - true// - false// - \"auto\" (auto-detect)\"organizeImportsIgnoreCase\": \"auto\",// Should sorting be \"ordinal\" and use code points or consider Unicode rules? Can be:// - \"ordinal\"// - \"unicode\"\"organizeImportsCollation\": \"ordinal\",// Under `\"organizeImportsCollation\": \"unicode\"`,// what is the current locale? Can be:// - [any other locale code]// - \"auto\" (use the editor's locale)\"organizeImportsLocale\": \"en\",// Under `\"organizeImportsCollation\": \"unicode\"`,// should upper-case letters or lower-case letters come first? Can be:// - false (locale-specific)// - \"upper\"// - \"lower\"\"organizeImportsCaseFirst\": false,// Under `\"organizeImportsCollation\": \"unicode\"`,// do runs of numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? Can be:// - true// - false\"organizeImportsNumericCollation\": true,// Under `\"organizeImportsCollation\": \"unicode\"`,// do letters with accent marks/diacritics get sorted distinctly// from their \"base\" letter (i.e. is \u00e9 different from e)? Can be// - true// - false\"organizeImportsAccentCollation\": true},\"javascript.unstable\": {// same options valid here...},}\nYou can read more details on the original work for auto-detecting and specifying case-insensitivity, followed by the the broader set of options.\nExhaustive switch\n/case\nCompletions\nWhen writing a switch\nstatement, TypeScript now detects when the value being checked has a literal type.\nIf so, it will offer a completion that scaffolds out each uncovered case\n.\nYou can see specifics of the implementation on GitHub.\nSpeed, Memory, and Package Size Optimizations\nTypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations. What these all mean is that your entire experience should be faster - not just running TypeScript, but even installing it.\nHere are a few interesting wins in speed and size that we\u2019ve been able to capture relative to TypeScript 4.9.\n| Scenario | Time or Size Relative to TS 4.9 |\n|---|---|\n| material-ui build time | 89% |\n| TypeScript Compiler startup time | 89% |\n| Playwright build time | 88% |\n| TypeScript Compiler self-build time | 87% |\n| Outlook Web build time | 82% |\n| VS Code build time | 80% |\n| typescript npm Package Size | 59% |\nHow? There are a few notable improvements we\u2019d like give more details on in the future. But we won\u2019t make you wait for that blog post.\nFirst off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting. Using this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9\u2019s 63.8 MB package size. It also brought us a notable speed-up through direct function calls.\nTypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well. This reduced polymorphic and megamorphic use sites, while offsetting most of the necessary memory consumption that was necessary for uniform shapes.\nWe\u2019ve also performed some caching when serializing information to strings. Type display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive. TypeScript now caches some commonly used machinery to reuse across these operations.\nAnother notable change we made that improved our parser was leveraging var\nto occasionally side-step the cost of using let\nand const\nacross closures.\nThis improved some of our parsing performance.\nOverall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%. Of course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today!\nFor more information, see some of our notable optimizations:\n- Migrate to Modules\nNode\nMonomorphizationSymbol\nMonomorphizationIdentifier\nSize ReductionPrinter\nCaching- Limited Usage of\nvar\nBreaking Changes and Deprecations\nRuntime Requirements\nTypeScript now targets ECMAScript 2018. For Node users, that means a minimum version requirement of at least Node.js 10 and later.\nlib.d.ts\nChanges\nChanges to how types for the DOM are generated might have an impact on existing code.\nNotably, certain properties have been converted from number\nto numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces.\nAPI Breaking Changes\nIn TypeScript 5.0, we moved to modules, removed some unnecessary interfaces, and made some correctness improvements. For more details on what\u2019s changed, see our API Breaking Changes page.\nForbidden Implicit Coercions in Relational Operators\nCertain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:\nts\nfunction func(ns: number | string) {return ns * 4; // Error, possible implicit coercion}\nIn 5.0, this will also be applied to the relational operators >\n, <\n, <=\n, and >=\n:\nts\nfunction func(ns: number | string) {return ns > 4; // Now also an error}\nTo allow this if desired, you can explicitly coerce the operand to a number\nusing +\n:\nts\nfunction func(ns: number | string) {return +ns > 4; // OK}\nThis correctness improvement was contributed courtesy of Mateusz Burzy\u0144ski.\nEnum Overhaul\nTypeScript has had some long-standing oddities around enum\ns ever since its first release.\nIn 5.0, we\u2019re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of enum\ns you can declare.\nThere are two main new errors you might see as part of this.\nThe first is that assigning an out-of-domain literal to an enum\ntype will now error as one might expect:\nts\nenum SomeEvenDigit {Zero = 0,Two = 2,Four = 4}// Now correctly an errorlet m: SomeEvenDigit = 1;\nThe other is that declaration of certain kinds of indirected mixed string/number enum\nforms would, incorrectly, create an all-number enum\n:\nts\nenum Letters {A = \"a\"}enum Numbers {one = 1,two = Letters.A}// Now correctly an errorconst t: number = Numbers.two;\nYou can see more details in relevant change.\nMore Accurate Type-Checking for Parameter Decorators in Constructors Under --experimentalDecorators\nTypeScript 5.0 makes type-checking more accurate for decorators under --experimentalDecorators\n.\nOne place where this becomes apparent is when using a decorator on a constructor parameter.\nts\nexport declare const inject:(entity: any) =>(target: object, key: string | symbol, index?: number) => void;export class Foo {}export class C {constructor(@inject(Foo) private x: any) {}}\nThis call will fail because key\nexpects a string | symbol\n, but constructor parameters receive a key of undefined\n.\nThe correct fix is to change the type of key\nwithin inject\n.\nA reasonable workaround if you\u2019re using a library that can\u2019t be upgraded is is to wrap inject\nin a more type-safe decorator function, and use a type-assertion on key\n.\nFor more details, see this issue.\nDeprecations and Default Changes\nIn TypeScript 5.0, we\u2019ve deprecated the following settings and setting values:\n--target: ES3\n--out\n--noImplicitUseStrict\n--keyofStringsOnly\n--suppressExcessPropertyErrors\n--suppressImplicitAnyIndexErrors\n--noStrictGenericChecks\n--charset\n--importsNotUsedAsValues\n--preserveValueImports\nprepend\nin project references\nThese configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings.\nIn TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify \"ignoreDeprecations\": \"5.0\"\nto silence those warnings.\nWe\u2019ll also shortly be releasing a 4.9 patch to allow specifying ignoreDeprecations\nto allow for smoother upgrades.\nAside from deprecations, we\u2019ve changed some settings to better improve cross-platform behavior in TypeScript.\n--newLine\n, which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified.\nWe think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is LF\n.\nThe old OS-specific inference behavior is no longer available.\n--forceConsistentCasingInFileNames\n, which ensured that all references to the same file name in a project agreed in casing, now defaults to true\n.\nThis can help catch differences issues with code written on case-insensitive file systems.\nYou can leave feedback and view more information on the tracking issue for 5.0 deprecations"},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html", "title": "Documentation - TypeScript 5.1", "text": "Easier Implicit Returns for undefined\n-Returning Functions\nIn JavaScript, if a function finishes running without hitting a return\n, it returns the value undefined\n.\nts\nfunction foo() {// no return}// x = undefinedlet x = foo();\nHowever, in previous versions of TypeScript, the only functions that could have absolutely no return statements were void\n- and any\n-returning functions.\nThat meant that even if you explicitly said \u201cthis function returns undefined\n\u201d you were forced to have at least one return statement.\nts\n// \u2705 fine - we inferred that 'f1' returns 'void'function f1() {// no returns}// \u2705 fine - 'void' doesn't need a return statementfunction f2(): void {// no returns}// \u2705 fine - 'any' doesn't need a return statementfunction f3(): any {// no returns}// \u274c error!// A function whose declared type is neither 'void' nor 'any' must return a value.function f4(): undefined {// no returns}\nThis could be a pain if some API expected a function returning undefined\n- you would need to have either at least one explicit return of undefined\nor a return\nstatement and an explicit annotation.\nts\ndeclare function takesFunction(f: () => undefined): undefined;// \u274c error!// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.takesFunction(() => {// no returns});// \u274c error!// A function whose declared type is neither 'void' nor 'any' must return a value.takesFunction((): undefined => {// no returns});// \u274c error!// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.takesFunction(() => {return;});// \u2705 workstakesFunction(() => {return undefined;});// \u2705 workstakesFunction((): undefined => {return;});\nThis behavior was frustrating and confusing, especially when calling functions outside of one\u2019s control.\nUnderstanding the interplay between inferring void\nover undefined\n, whether an undefined\n-returning function needs a return\nstatement, etc. seems like a distraction.\nFirst, TypeScript 5.1 now allows undefined\n-returning functions to have no return statement.\nts\n// \u2705 Works in TypeScript 5.1!function f4(): undefined {// no returns}// \u2705 Works in TypeScript 5.1!takesFunction((): undefined => {// no returns});\nSecond, if a function has no return expressions and is being passed to something expecting a function that returns undefined\n, TypeScript infers undefined\nfor that function\u2019s return type.\nts\n// \u2705 Works in TypeScript 5.1!takesFunction(function f() {// ^ return type is undefined// no returns});// \u2705 Works in TypeScript 5.1!takesFunction(function f() {// ^ return type is undefinedreturn;});\nTo address another similar pain-point, under TypeScript\u2019s --noImplicitReturns\noption, functions returning only undefined\nnow have a similar exception to void\n, in that not every single code path must end in an explicit return\n.\nts\n// \u2705 Works in TypeScript 5.1 under '--noImplicitReturns'!function f(): undefined {if (Math.random()) {// do some stuff...return;}}\nFor more information, you can read up on the original issue and the implementing pull request.\nUnrelated Types for Getters and Setters\nTypeScript 4.3 made it possible to say that a get\nand set\naccessor pair might specify two different types.\nts\ninterface Serializer {set value(v: string | number | boolean);get value(): string;}declare let box: Serializer;// Allows writing a 'boolean'box.value = true;// Comes out as a 'string'console.log(box.value.toUpperCase());\nInitially we required that the get\ntype had to be a subtype of the set\ntype.\nThis meant that writing\nts\nbox.value = box.value;\nwould always be valid.\nHowever, there are plenty of existing and proposed APIs that have completely unrelated types between their getters and setters.\nFor example, consider one of the most common examples - the style\nproperty in the DOM and CSSStyleRule\nAPI.\nEvery style rule has a style\nproperty that is a CSSStyleDeclaration\n;\nhowever, if you try to write to that property, it will only work correctly with a string!\nTypeScript 5.1 now allows completely unrelated types for get\nand set\naccessor properties, provided that they have explicit type annotations.\nAnd while this version of TypeScript does not yet change the types for these built-in interfaces, CSSStyleRule\ncan now be defined in the following way:\nts\ninterface CSSStyleRule {// .../** Always reads as a `CSSStyleDeclaration` */get style(): CSSStyleDeclaration;/** Can only write a `string` here. */set style(newValue: string);// ...}\nThis also allows other patterns like requiring set\naccessors to accept only \u201cvalid\u201d data, but specifying that get\naccessors may return undefined\nif some underlying state hasn\u2019t been initialized yet.\nts\nclass SafeBox {#value: string | undefined;// Only accepts strings!set value(newValue: string) {}// Must check for 'undefined'!get value(): string | undefined {return this.#value;}}\nIn fact, this is similar to how optional properties are checked under --exactOptionalProperties\n.\nYou can read up more on the implementing pull request.\nDecoupled Type-Checking Between JSX Elements and JSX Tag Types\nOne pain point TypeScript had with JSX was its requirements on the type of every JSX element\u2019s tag.\nFor context, a JSX element is either of the following:\ntsx\n// A self-closing JSX tag<Foo />// A regular element with an opening/closing tag<Bar></Bar>\nWhen type-checking <Foo />\nor <Bar></Bar>\n, TypeScript always looks up a namespace called JSX\nand fetches a type out of it called Element\n- or more directly, it looks up JSX.Element\n.\nBut to check whether Foo\nor Bar\nthemselves were valid to use as tag names, TypeScript would roughly just grab the types returned or constructed by Foo\nor Bar\nand check for compatibility with JSX.Element\n(or another type called JSX.ElementClass\nif the type is constructable).\nThe limitations here meant that components could not be used if they returned or \u201crendered\u201d a more broad type than just JSX.Element\n.\nFor example, a JSX library might be fine with a component returning string\ns or Promise\ns.\nAs a more concrete example, React is considering adding limited support for components that return Promise\ns, but existing versions of TypeScript cannot express that without someone drastically loosening the type of JSX.Element\n.\ntsx\nimport * as React from \"react\";async function Foo() {return <div></div>;}let element = <Foo />;// ~~~// 'Foo' cannot be used as a JSX component.// Its return type 'Promise<Element>' is not a valid JSX element.\nTo provide libraries with a way to express this, TypeScript 5.1 now looks up a type called JSX.ElementType\n.\nElementType\nspecifies precisely what is valid to use as a tag in a JSX element.\nSo it might be typed today as something like\ntsx\nnamespace JSX {export type ElementType =// All the valid lowercase tagskeyof IntrinsicAttributes// Function components(props: any) => Element// Class componentsnew (props: any) => ElementClass;export interface IntrinsicAttributes extends /*...*/ {}export type Element = /*...*/;export type ElementClass = /*...*/;}\nWe\u2019d like to extend our thanks to Sebastian Silbermann who contributed this change!\nNamespaced JSX Attributes\nTypeScript now supports namespaced attribute names when using JSX.\ntsx\nimport * as React from \"react\";// Both of these are equivalent:const x = <Foo a:b=\"hello\" />;const y = <Foo a : b=\"hello\" />;interface FooProps {\"a:b\": string;}function Foo(props: FooProps) {return <div>{props[\"a:b\"]}</div>;}\nNamespaced tag names are looked up in a similar way on JSX.IntrinsicAttributes\nwhen the first segment of the name is a lowercase name.\ntsx\n// In some library's code or in an augmentation of that library:namespace JSX {interface IntrinsicElements {[\"a:b\"]: { prop: string };}}// In our code:let x = <a:b prop=\"hello!\" />;\nThis contribution was provided thanks to Oleksandr Tarasiuk.\ntypeRoots\nAre Consulted In Module Resolution\nWhen TypeScript\u2019s specified module lookup strategy is unable to resolve a path, it will now resolve packages relative to the specified typeRoots\n.\nSee this pull request for more details.\nMove Declarations to Existing Files\nIn addition to moving declarations to new files, TypeScript now ships a preview feature for moving declarations to existing files as well. You can try this functionality out in a recent version of Visual Studio Code.\nKeep in mind that this feature is currently in preview, and we are seeking further feedback on it.\nhttps://github.com/microsoft/TypeScript/pull/53542\nLinked Cursors for JSX Tags\nTypeScript now supports linked editing for JSX tag names. Linked editing (occasionally called \u201cmirrored cursors\u201d) allows an editor to edit multiple locations at the same time automatically.\nThis new feature should work in both TypeScript and JavaScript files, and can be enabled in Visual Studio Code Insiders.\nIn Visual Studio Code, you can either edit the Editor: Linked Editing\noption in the Settings UI:\nor configure editor.linkedEditing\nin your JSON settings file:\njsonc\n{// ...\"editor.linkedEditing\": true,}\nThis feature will also be supported by Visual Studio 17.7 Preview 1.\nYou can take a look at our implementation of linked editing here!\nSnippet Completions for @param\nJSDoc Tags\nTypeScript now provides snippet completions when typing out a @param\ntag in both TypeScript and JavaScript files.\nThis can help cut down on some typing and jumping around text as you document your code or add JSDoc types in JavaScript.\nYou can check out how this new feature was implemented on GitHub.\nOptimizations\nAvoiding Unnecessary Type Instantiation\nTypeScript 5.1 now avoids performing type instantiation within object types that are known not to contain references to outer type parameters. This has the potential to cut down on many unnecessary computations, and reduced the type-checking time of material-ui\u2019s docs directory by over 50%.\nYou can see the changes involved for this change on GitHub.\nNegative Case Checks for Union Literals\nWhen checking if a source type is part of a union type, TypeScript will first do a fast look-up using an internal type identifier for that source. If that look-up fails, then TypeScript checks for compatibility against every type within the union.\nWhen relating a literal type to a union of purely literal types, TypeScript can now avoid that full walk against every other type in the union. This assumption is safe because TypeScript always interns/caches literal types - though there are some edge cases to handle relating to \u201cfresh\u201d literal types.\nThis optimization was able to reduce the type-checking time of the code in this issue from about 45 seconds to about 0.4 seconds.\nReduced Calls into Scanner for JSDoc Parsing\nWhen older versions of TypeScript parsed out a JSDoc comment, they would use the scanner/tokenizer to break the comment into fine-grained tokens and piece the contents back together. This could be helpful for normalizing comment text, so that multiple spaces would just collapse into one; but it was extremely \u201cchatty\u201d and meant the parser and scanner would jump back and forth very often, adding overhead to JSDoc parsing.\nTypeScript 5.1 has moved more logic around breaking down JSDoc comments into the scanner/tokenizer. The scanner now returns larger chunks of content directly to the parser to do as it needs.\nThese changes have brought down the parse time of several 10Mb mostly-prose-comment JavaScript files by about half. For a more realistic example, our performance suite\u2019s snapshot of xstate dropped about 300ms of parse time, making it faster to load and analyze.\nBreaking Changes\nES2020 and Node.js 14.17 as Minimum Runtime Requirements\nTypeScript 5.1 now ships JavaScript functionality that was introduced in ECMAScript 2020. As a result, at minimum TypeScript must be run in a reasonably modern runtime. For most users, this means TypeScript now only runs on Node.js 14.17 and later.\nIf you try running TypeScript 5.1 under an older version of Node.js such as Node 10 or 12, you may see an error like the following from running either tsc.js\nor tsserver.js\n:\nnode_modules/typescript/lib/tsserver.js:2406for (let i = startIndex ?? 0; i < array.length; i++) {^SyntaxError: Unexpected token '?'at wrapSafe (internal/modules/cjs/loader.js:915:16)at Module._compile (internal/modules/cjs/loader.js:963:27)at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)at Module.load (internal/modules/cjs/loader.js:863:32)at Function.Module._load (internal/modules/cjs/loader.js:708:14)at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)at internal/main/run_main_module.js:17:47\nAdditionally, if you try installing TypeScript you\u2019ll get something like the following error messages from npm:\nnpm WARN EBADENGINE Unsupported engine {npm WARN EBADENGINE package: 'typescript@5.1.1-rc',npm WARN EBADENGINE required: { node: '>=14.17' },npm WARN EBADENGINE current: { node: 'v12.22.12', npm: '8.19.2' }npm WARN EBADENGINE }\nfrom Yarn:\nerror typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\"error Found incompatible module.\nSee more information around this change here.\nExplicit typeRoots\nDisables Upward Walks for node_modules/@types\nPreviously, when the typeRoots\noption was specified in a tsconfig.json\nbut resolution to any typeRoots\ndirectories had failed, TypeScript would still continue walking up parent directories, trying to resolve packages within each parent\u2019s node_modules/@types\nfolder.\nThis behavior could prompt excessive look-ups and has been disabled in TypeScript 5.1.\nAs a result, you may begin to see errors like the following based on entries in your tsconfig.json\n\u2019s types\noption or /// <reference >\ndirectives\nerror TS2688: Cannot find type definition file for 'node'.error TS2688: Cannot find type definition file for 'mocha'.error TS2688: Cannot find type definition file for 'jasmine'.error TS2688: Cannot find type definition file for 'chai-http'.error TS2688: Cannot find type definition file for 'webpack-env\"'.\nThe solution is typically to add specific entries for node_modules/@types\nto your typeRoots\n:\njsonc\n{\"compilerOptions\": {\"types\": [\"node\",\"mocha\"],\"typeRoots\": [// Keep whatever you had around before.\"./some-custom-types/\",// You might need your local 'node_modules/@types'.\"./node_modules/@types\",// You might also need to specify a shared 'node_modules/@types'// if you're using a \"monorepo\" layout.\"../../node_modules/@types\",]}}\nMore information is available on the original change on our issue tracker."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html", "title": "Documentation - TypeScript 5.2", "text": "using\nDeclarations and Explicit Resource Management\nTypeScript 5.2 adds support for the upcoming Explicit Resource Management feature in ECMAScript. Let\u2019s explore some of the motivations and understand what the feature brings us.\nIt\u2019s common to need to do some sort of \u201cclean-up\u201d after creating an object. For example, you might need to close network connections, delete temporary files, or just free up some memory.\nLet\u2019s imagine a function that creates a temporary file, reads and writes to it for various operations, and then closes and deletes it.\nts\nimport * as fs from \"fs\";export function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");// use file...// Close the file and delete it.fs.closeSync(file);fs.unlinkSync(path);}\nThis is fine, but what happens if we need to perform an early exit?\nts\nexport function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");// use file...if (someCondition()) {// do some more work...// Close the file and delete it.fs.closeSync(file);fs.unlinkSync(path);return;}// Close the file and delete it.fs.closeSync(file);fs.unlinkSync(path);}\nWe\u2019re starting to see some duplication of clean-up which can be easy to forget.\nWe\u2019re also not guaranteed to close and delete the file if an error gets thrown.\nThis could be solved by wrapping this all in a try\n/finally\nblock.\nts\nexport function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");try {// use file...if (someCondition()) {// do some more work...return;}}finally {// Close the file and delete it.fs.closeSync(file);fs.unlinkSync(path);}}\nWhile this is more robust, it\u2019s added quite a bit of \u201cnoise\u201d to our code.\nThere are also other foot-guns we can run into if we start adding more clean-up logic to our finally\nblock \u2014 for example, exceptions preventing other resources from being disposed.\nThis is what the explicit resource management proposal aims to solve.\nThe key idea of the proposal is to support resource disposal \u2014 this clean-up work we\u2019re trying to deal with \u2014 as a first class idea in JavaScript.\nThis starts by adding a new built-in symbol\ncalled Symbol.dispose\n, and we can create objects with methods named by Symbol.dispose\n.\nFor convenience, TypeScript defines a new global type called Disposable\nwhich describes these.\nts\nclass TempFile implements Disposable {#path: string;#handle: number;constructor(path: string) {this.#path = path;this.#handle = fs.openSync(path, \"w+\");}// other methods[Symbol.dispose]() {// Close the file and delete it.fs.closeSync(this.#handle);fs.unlinkSync(this.#path);}}\nLater on we can call those methods.\nts\nexport function doSomeWork() {const file = new TempFile(\".some_temp_file\");try {// ...}finally {file[Symbol.dispose]();}}\nMoving the clean-up logic to TempFile\nitself doesn\u2019t buy us much;\nwe\u2019ve basically just moved all the clean-up work from the finally\nblock into a method, and that\u2019s always been possible.\nBut having a well-known \u201cname\u201d for this method means that JavaScript can build other features on top of it.\nThat brings us to the first star of the feature: using\ndeclarations!\nusing\nis a new keyword that lets us declare new fixed bindings, kind of like const\n.\nThe key difference is that variables declared with using\nget their Symbol.dispose\nmethod called at the end of the scope!\nSo we could simply have written our code like this:\nts\nexport function doSomeWork() {using file = new TempFile(\".some_temp_file\");// use file...if (someCondition()) {// do some more work...return;}}\nCheck it out \u2014 no try\n/finally\nblocks!\nAt least, none that we see.\nFunctionally, that\u2019s exactly what using\ndeclarations will do for us, but we don\u2019t have to deal with that.\nYou might be familiar with using\ndeclarations in C#, with\nstatements in Python, or try\n-with-resource declarations in Java.\nThese are all similar to JavaScript\u2019s new using\nkeyword, and provide a similar explicit way to perform a \u201ctear-down\u201d of an object at the end of a scope.\nusing\ndeclarations do this clean-up at the very end of their containing scope or right before an \u201cearly return\u201d like a return\nor a throw\nn error.\nThey also dispose in a first-in-last-out order like a stack.\nts\nfunction loggy(id: string): Disposable {console.log(`Creating ${id}`);return {[Symbol.dispose]() {console.log(`Disposing ${id}`);}}}function func() {using a = loggy(\"a\");using b = loggy(\"b\");{using c = loggy(\"c\");using d = loggy(\"d\");}using e = loggy(\"e\");return;// Unreachable.// Never created, never disposed.using f = loggy(\"f\");}func();// Creating a// Creating b// Creating c// Creating d// Disposing d// Disposing c// Creating e// Disposing e// Disposing b// Disposing a\nusing\ndeclarations are supposed to be resilient to exceptions;\nif an error is thrown, it\u2019s rethrown after disposal.\nOn the other hand, the body of your function might execute as expected, but the Symbol.dispose\nmight throw.\nIn that case, that exception is rethrown as well.\nBut what happens if both the logic before and during disposal throws an error?\nFor those cases, SuppressedError\nhas been introduced as a new subtype of Error\n.\nIt features a suppressed\nproperty that holds the last-thrown error, and an error\nproperty for the most-recently thrown error.\nts\nclass ErrorA extends Error {name = \"ErrorA\";}class ErrorB extends Error {name = \"ErrorB\";}function throwy(id: string) {return {[Symbol.dispose]() {throw new ErrorA(`Error from ${id}`);}};}function func() {using a = throwy(\"a\");throw new ErrorB(\"oops!\")}try {func();}catch (e: any) {console.log(e.name); // SuppressedErrorconsole.log(e.message); // An error was suppressed during disposal.console.log(e.error.name); // ErrorAconsole.log(e.error.message); // Error from aconsole.log(e.suppressed.name); // ErrorBconsole.log(e.suppressed.message); // oops!}\nYou might have noticed that we\u2019re using synchronous methods in these examples. However, lots of resource disposal involves asynchronous operations, and we need to wait for those to complete before we continue running any other code.\nThat\u2019s why there is also a new Symbol.asyncDispose\n, and it brings us to the next star of the show \u2014 await using\ndeclarations.\nThese are similar to using\ndeclarations, but the key is that they look up whose disposal must be await\ned.\nThey use a different method named by Symbol.asyncDispose\n, though they can operate on anything with a Symbol.dispose\nas well.\nFor convenience, TypeScript also introduces a global type called AsyncDisposable\nthat describes any object with an asynchronous dispose method.\nts\nasync function doWork() {// Do fake work for half a second.await new Promise(resolve => setTimeout(resolve, 500));}function loggy(id: string): AsyncDisposable {console.log(`Constructing ${id}`);return {async [Symbol.asyncDispose]() {console.log(`Disposing (async) ${id}`);await doWork();},}}async function func() {await using a = loggy(\"a\");await using b = loggy(\"b\");{await using c = loggy(\"c\");await using d = loggy(\"d\");}await using e = loggy(\"e\");return;// Unreachable.// Never created, never disposed.await using f = loggy(\"f\");}func();// Constructing a// Constructing b// Constructing c// Constructing d// Disposing (async) d// Disposing (async) c// Constructing e// Disposing (async) e// Disposing (async) b// Disposing (async) a\nDefining types in terms of Disposable\nand AsyncDisposable\ncan make your code much easier to work with if you expect others to do tear-down logic consistently.\nIn fact, lots of existing types exist in the wild which have a dispose()\nor close()\nmethod.\nFor example, the Visual Studio Code APIs even define their own Disposable\ninterface.\nAPIs in the browser and in runtimes like Node.js, Deno, and Bun might also choose to use Symbol.dispose\nand Symbol.asyncDispose\nfor objects which already have clean-up methods, like file handles, connections, and more.\nNow maybe this all sounds great for libraries, but a little bit heavy-weight for your scenarios.\nIf you\u2019re doing a lot of ad-hoc clean-up, creating a new type might introduce a lot of over-abstraction and questions about best-practices.\nFor example, take our TempFile\nexample again.\nts\nclass TempFile implements Disposable {#path: string;#handle: number;constructor(path: string) {this.#path = path;this.#handle = fs.openSync(path, \"w+\");}// other methods[Symbol.dispose]() {// Close the file and delete it.fs.closeSync(this.#handle);fs.unlinkSync(this.#path);}}export function doSomeWork() {using file = new TempFile(\".some_temp_file\");// use file...if (someCondition()) {// do some more work...return;}}\nAll we wanted was to remember to call two functions \u2014 but was this the best way to write it?\nShould we be calling openSync\nin the constructor, create an open()\nmethod, or pass in the handle ourselves?\nShould we expose a method for every possible operation we need to perform, or should we just make the properties public?\nThat brings us to the final stars of the feature: DisposableStack\nand AsyncDisposableStack\n.\nThese objects are useful for doing both one-off clean-up, along with arbitrary amounts of cleanup.\nA DisposableStack\nis an object that has several methods for keeping track of Disposable\nobjects, and can be given functions for doing arbitrary clean-up work.\nWe can also assign them to using\nvariables because \u2014 get this \u2014 they\u2019re also Disposable\n!\nSo here\u2019s how we could\u2019ve written the original example.\nts\nfunction doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");using cleanup = new DisposableStack();cleanup.defer(() => {fs.closeSync(file);fs.unlinkSync(path);});// use file...if (someCondition()) {// do some more work...return;}// ...}\nHere, the defer()\nmethod just takes a callback, and that callback will be run once cleanup\nis disposed of.\nTypically, defer\n(and other DisposableStack\nmethods like use\nand adopt\n)\nshould be called immediately after creating a resource.\nAs the name suggests, DisposableStack\ndisposes of everything it keeps track of like a stack, in a first-in-last-out order, so defer\ning immediately after creating a value helps avoid odd dependency issues.\nAsyncDisposableStack\nworks similarly, but can keep track of async\nfunctions and AsyncDisposable\ns, and is itself an AsyncDisposable.\nThe defer\nmethod is similar in many ways to the defer\nkeyword in Go, Swift, Zig, Odin, and others, where the conventions should be similar.\nBecause this feature is so recent, most runtimes will not support it natively. To use it, you will need runtime polyfills for the following:\nSymbol.dispose\nSymbol.asyncDispose\nDisposableStack\nAsyncDisposableStack\nSuppressedError\nHowever, if all you\u2019re interested in is using\nand await using\n, you should be able to get away with only polyfilling the built-in symbol\ns.\nSomething as simple as the following should work for most cases:\nts\nSymbol.dispose ??= Symbol(\"Symbol.dispose\");Symbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\");\nYou will also need to set your compilation target\nto es2022\nor below, and configure your lib\nsetting to either include \"esnext\"\nor \"esnext.disposable\"\n.\njson\n{\"compilerOptions\": {\"target\": \"es2022\",\"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]}}\nFor more information on this feature, take a look at the work on GitHub!\nDecorator Metadata\nTypeScript 5.2 implements an upcoming ECMAScript feature called decorator metadata.\nThe key idea of this feature is to make it easy for decorators to create and consume metadata on any class they\u2019re used on or within.\nWhenever decorator functions are used, they now have access to a new metadata\nproperty on their context object.\nThe metadata\nproperty just holds a simple object.\nSince JavaScript lets us add properties arbitrarily, it can be used as a dictionary that is updated by each decorator.\nAlternatively, since every metadata\nobject will be identical for each decorated portion of a class, it can be used as a key into a Map\n.\nAfter all decorators on or in a class get run, that object can be accessed on the class via Symbol.metadata\n.\nts\ninterface Context {name: string;metadata: Record<PropertyKey, unknown>;}function setMetadata(_target: any, context: Context) {context.metadata[context.name] = true;}class SomeClass {@setMetadatafoo = 123;@setMetadataaccessor bar = \"hello!\";@setMetadatabaz() { }}const ourMetadata = SomeClass[Symbol.metadata];console.log(JSON.stringify(ourMetadata));// { \"bar\": true, \"baz\": true, \"foo\": true }\nThis can be useful in a number of different scenarios.\nMetadata could possibly be attached for lots of uses like debugging, serialization, or performing dependency injection with decorators.\nSince metadata objects are created per decorated class, frameworks can either privately use them as keys into a Map\nor WeakMap\n, or tack properties on as necessary.\nFor example, let\u2019s say we wanted to use decorators to keep track of which properties and accessors are serializable when using JSON.stringify\nlike so:\nts\nimport { serialize, jsonify } from \"./serializer\";class Person {firstName: string;lastName: string;@serializeage: number@serializeget fullName() {return `${this.firstName} ${this.lastName}`;}toJSON() {return jsonify(this)}constructor(firstName: string, lastName: string, age: number) {// ...}}\nHere, the intent is that only age\nand fullName\nshould be serialized because they are marked with the @serialize\ndecorator.\nWe define a toJSON\nmethod for this purpose, but it just calls out to jsonify\nwhich uses the metadata that @serialize\ncreated.\nHere\u2019s an example of how the module ./serialize.ts\nmight be defined:\nts\nconst serializables = Symbol();type Context =| ClassAccessorDecoratorContext| ClassGetterDecoratorContext| ClassFieldDecoratorContext;export function serialize(_target: any, context: Context): void {if (context.static || context.private) {throw new Error(\"Can only serialize public instance members.\")}if (typeof context.name === \"symbol\") {throw new Error(\"Cannot serialize symbol-named properties.\");}const propNames =(context.metadata[serializables] as string[] | undefined) ??= [];propNames.push(context.name);}export function jsonify(instance: object): string {const metadata = instance.constructor[Symbol.metadata];const propNames = metadata?.[serializables] as string[] | undefined;if (!propNames) {throw new Error(\"No members marked with @serialize.\");}const pairStrings = propNames.map(key => {const strKey = JSON.stringify(key);const strValue = JSON.stringify((instance as any)[key]);return `${strKey}: ${strValue}`;});return `{ ${pairStrings.join(\", \")} }`;}\nThis module has a local symbol\ncalled serializables\nto store and retrieve the names of properties marked @serializable\n.\nIt stores a list of these property names on the metadata on each invocation of @serializable\n.\nWhen jsonify\nis called, the list of properties is fetched off of the metadata and used to retrieve the actual values from the instance, eventually serializing those names and values.\nUsing a symbol\ntechnically makes this data accessible to others.\nAn alternative might be to use a WeakMap\nusing the metadata object as a key.\nThis keeps data private and happens to use fewer type assertions in this case, but is otherwise similar.\nts\nconst serializables = new WeakMap<object, string[]>();type Context =| ClassAccessorDecoratorContext| ClassGetterDecoratorContext| ClassFieldDecoratorContext;export function serialize(_target: any, context: Context): void {if (context.static || context.private) {throw new Error(\"Can only serialize public instance members.\")}if (typeof context.name !== \"string\") {throw new Error(\"Can only serialize string properties.\");}let propNames = serializables.get(context.metadata);if (propNames === undefined) {serializables.set(context.metadata, propNames = []);}propNames.push(context.name);}export function jsonify(instance: object): string {const metadata = instance.constructor[Symbol.metadata];const propNames = metadata && serializables.get(metadata);if (!propNames) {throw new Error(\"No members marked with @serialize.\");}const pairStrings = propNames.map(key => {const strKey = JSON.stringify(key);const strValue = JSON.stringify((instance as any)[key]);return `${strKey}: ${strValue}`;});return `{ ${pairStrings.join(\", \")} }`;}\nAs a note, these implementations don\u2019t handle subclassing and inheritance. That\u2019s left as an exercise to you (and you might find that it is easier in one version of the file than the other!).\nBecause this feature is still fresh, most runtimes will not support it natively.\nTo use it, you will need a polyfill for Symbol.metadata\n.\nSomething as simple as the following should work for most cases:\nts\nSymbol.metadata ??= Symbol(\"Symbol.metadata\");\nYou will also need to set your compilation target\nto es2022\nor below, and configure your lib\nsetting to either include \"esnext\"\nor \"esnext.decorators\"\n.\njson\n{\"compilerOptions\": {\"target\": \"es2022\",\"lib\": [\"es2022\", \"esnext.decorators\", \"dom\"]}}\nWe\u2019d like to thank Oleksandr Tarasiuk for contributing the implementation of decorator metadata for TypeScript 5.2!\nNamed and Anonymous Tuple Elements\nTuple types have supported optional labels or names for each element.\nts\ntype Pair<T> = [first: T, second: T];\nThese labels don\u2019t change what you\u2019re allowed to do with them \u2014 they\u2019re solely to help with readability and tooling.\nHowever, TypeScript previously had a rule that tuples could not mix and match between labeled and unlabeled elements. In other words, either no element could have a label in a tuple, or all elements needed one.\nts\n// \u2705 fine - no labelstype Pair1<T> = [T, T];// \u2705 fine - all fully labeledtype Pair2<T> = [first: T, second: T];// \u274c previously an errortype Pair3<T> = [first: T, T];// ~// Tuple members must all have names// or all not have names.\nThis could be annoying for rest elements where we\u2019d be forced to just add a label like rest\nor tail\n.\nts\n// \u274c previously an errortype TwoOrMore_A<T> = [first: T, second: T, ...T[]];// ~~~~~~// Tuple members must all have names// or all not have names.// \u2705type TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]];\nIt also meant that this restriction had to be enforced internally in the type system, meaning TypeScript would lose labels.\nts\ntype HasLabels = [a: string, b: string];type HasNoLabels = [number, number];type Merged = [...HasNoLabels, ...HasLabels];// ^ [number, number, string, string]//// 'a' and 'b' were lost in 'Merged'\nIn TypeScript 5.2, the all-or-nothing restriction on tuple labels has been lifted. The language can now also preserve labels when spreading into an unlabeled tuple.\nWe\u2019d like to extend our thanks to Josh Goldberg and Mateusz Burzy\u0144ski who collaborated to lift this restriction.\nEasier Method Usage for Unions of Arrays\nIn previous versions of TypeScript, calling a method on a union of arrays could end in pain.\nts\ndeclare let array: string[] | number[];array.filter(x => !!x);// ~~~~~~ error!// This expression is not callable.// Each member of the union type '...' has signatures,// but none of those signatures are compatible// with each other.\nIn this example, TypeScript would try to see if each version of filter\nis compatible across string[]\nand number[]\n.\nWithout a coherent strategy, TypeScript threw its hands in the air and said \u201cI can\u2019t make it work\u201d.\nIn TypeScript 5.2, before giving up in these cases, unions of arrays are treated as a special case. A new array type is constructed out of each member\u2019s element type, and then the method is invoked on that.\nTaking the above example, string[] | number[]\nis transformed into (string | number)[]\n(or Array<string | number>\n), and filter\nis invoked on that type.\nThere is a slight caveat which is that filter\nwill produce an Array<string | number>\ninstead of a string[] | number[]\n;\nbut for a freshly produced value there is less risk of something \u201cgoing wrong\u201d.\nThis means lots of methods like filter\n, find\n, some\n, every\n, and reduce\nshould all be invokable on unions of arrays in cases where they were not previously.\nYou can read up more details on the implementing pull request.\nType-Only Import Paths with TypeScript Implementation File Extensions\nTypeScript now allows both declaration and implementation file extensions to be included in type-only import paths, regardless of whether allowImportingTsExtensions\nis enabled.\nThis means that you can now write import type\nstatements that use .ts\n, .mts\n, .cts\n, and .tsx\nfile extensions.\nts\nimport type { JustAType } from \"./justTypes.ts\";export function f(param: JustAType) {// ...}\nIt also means that import()\ntypes, which can be used in both TypeScript and JavaScript with JSDoc, can use those file extensions.\njs\n/*** @param {import(\"./justTypes.ts\").JustAType} param*/export function f(param) {// ...}\nFor more information, see the change here.\nComma Completions for Object Members\nIt can be easy to forget to add a comma when adding a new property to an object. Previously, if you forgot a comma and requested auto-completion, TypeScript would confusingly give poor unrelated completion results.\nTypeScript 5.2 now gracefully provides object member completions when you\u2019re missing a comma. But to just skip past hitting you with a syntax error, it will also auto-insert the missing comma.\nFor more information, see the implementation here.\nInline Variable Refactoring\nTypeScript 5.2 now has a refactoring to inline the contents of a variable to all usage sites.\n.\nUsing the \u201cinline variable\u201d refactoring will eliminate the variable and replace all the variable\u2019s usages with its initializer. Note that this may cause that initializer\u2019s side-effects to run at a different time, and as many times as the variable has been used.\nFor more details, see the implementing pull request.\nOptimized Checks for Ongoing Type Compatibility\nBecause TypeScript is a structural type system, types occasionally need to be compared in a member-wise fashion; however, recursive types add some issues here. For example:\nts\ninterface A {value: A;other: string;}interface B {value: B;other: number;}\nWhen checking whether the type A\nis compatible with the type B\n, TypeScript will end up checking whether the types of value\nin A\nand B\nare respectively compatible.\nAt this point, the type system needs to stop checking any further and proceed to check other members.\nTo do this, the type system has to track when any two types are already being related.\nPreviously TypeScript already kept a stack of type pairs, and iterated through that to determine whether those types are being related. When this stack is shallow that\u2019s not a problem; but when the stack isn\u2019t shallow, that, uh, is a problem.\nIn TypeScript 5.3, a simple Set\nhelps track this information.\nThis reduced the time spent on a reported test case that used the drizzle library by over 33%!\nBenchmark 1: oldTime (mean \u00b1 \u03c3): 3.115 s \u00b1 0.067 s [User: 4.403 s, System: 0.124 s]Range (min \u2026 max): 3.018 s \u2026 3.196 s 10 runsBenchmark 2: newTime (mean \u00b1 \u03c3): 2.072 s \u00b1 0.050 s [User: 3.355 s, System: 0.135 s]Range (min \u2026 max): 1.985 s \u2026 2.150 s 10 runsSummary'new' ran1.50 \u00b1 0.05 times faster than 'old'\nBreaking Changes and Correctness Fixes\nTypeScript strives not to unnecessarily introduce breaks; however, occasionally we must make corrections and improvements so that code can be better-analyzed.\nlib.d.ts\nChanges\nTypes generated for the DOM may have an impact on your codebase. For more information, see the DOM updates for TypeScript 5.2.\nlabeledElementDeclarations\nMay Hold undefined\nElements\nIn order to support a mixture of labeled and unlabeled elements, TypeScript\u2019s API has changed slightly.\nThe labeledElementDeclarations\nproperty of TupleType\nmay hold undefined\nfor at each position where an element is unlabeled.\ndiff\ninterface TupleType {- labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];+ labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];}\nmodule\nand moduleResolution\nMust Match Under Recent Node.js settings\nThe --module\nand --moduleResolution\noptions each support a node16\nand nodenext\nsetting.\nThese are effectively \u201cmodern Node.js\u201d settings that should be used on any recent Node.js project.\nWhat we\u2019ve found is that when these two options don\u2019t agree on whether they are using Node.js-related settings, projects are effectively misconfigured.\nIn TypeScript 5.2, when using node16\nor nodenext\nfor either of the --module\nand --moduleResolution\noptions, TypeScript now requires the other to have a similar Node.js-related setting.\nIn cases where the settings diverge, you\u2019ll likely get an error message like either\nOption 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'.\nor\nOption 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'.\nSo for example --module esnext --moduleResolution node16\nwill be rejected \u2014 but you may be better off just using --module nodenext\nalone, or --module esnext --moduleResolution bundler\n.\nFor more information, see the change here.\nConsistent Export Checking for Merged Symbols\nWhen two declarations merge, they must agree on whether they are both exported.\nDue to a bug, TypeScript missed specific cases in ambient contexts, like in declaration files or declare module\nblocks.\nFor example, it would not issue an error on a case like the following, where replaceInFile\nis declared once as an exported function, and one as an un-exported namespace.\nts\ndeclare module 'replace-in-file' {export function replaceInFile(config: unknown): Promise<unknown[]>;export {};namespace replaceInFile {export function sync(config: unknown): unknown[];}}\nIn an ambient module, adding an export { ... }\nor a similar construct like export default ...\nimplicitly changes whether all declarations are automatically exported.\nTypeScript now recognizes these unfortunately confusing semantics more consistently, and issues an error on the fact that all declarations of replaceInFile\nneed to agree in their modifiers, and will issue the following error:\nIndividual declarations in merged declaration 'replaceInFile' must be all exported or all local.\nFor more information, see the change here."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html", "title": "Documentation - TypeScript 5.3", "text": "Import Attributes\nTypeScript 5.3 supports the latest updates to the import attributes proposal.\nOne use-case of import attributes is to provide information about the expected format of a module to the runtime.\nts\n// We only want this to be interpreted as JSON,// not a runnable/malicious JavaScript file with a `.json` extension.import obj from \"./something.json\" with { type: \"json\" };\nThe contents of these attributes are not checked by TypeScript since they\u2019re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\nts\n// TypeScript is fine with this.// But your browser? Probably not.import * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };\nDynamic import()\ncalls can also use import attributes through a second argument.\nts\nconst obj = await import(\"./something.json\", {with: { type: \"json\" }});\nThe expected type of that second argument is defined by a type called ImportCallOptions\n, which by default just expects a property called with\n.\nNote that import attributes are an evolution of an earlier proposal called \u201cimport assertions\u201d, which were implemented in TypeScript 4.5.\nThe most obvious difference is the use of the with\nkeyword over the assert\nkeyword.\nBut the less-visible difference is that runtimes are now free to use attributes to guide the resolution and interpretation of import paths, whereas import assertions could only assert some characteristics after loading a module.\nOver time, TypeScript will be deprecating the old syntax for import assertions in favor of the proposed syntax for import attributes.\nExisting code using assert\nshould migrate towards the with\nkeyword.\nNew code that needs an import attribute should use with\nexclusively.\nWe\u2019d like to thank Oleksandr Tarasiuk for implementing this proposal! And we\u2019d also like to call out Wenlu Wang for their implementation of import assertions!\nStable Support resolution-mode\nin Import Types\nIn TypeScript 4.7, TypeScript added support for a resolution-mode\nattribute in /// <reference types=\"...\" />\nto control whether a specifier should be resolved via import\nor require\nsemantics.\nts\n/// <reference types=\"pkg\" resolution-mode=\"require\" />// or/// <reference types=\"pkg\" resolution-mode=\"import\" />\nA corresponding field was added to import assertions on type-only imports as well; however, it was only supported in nightly versions of TypeScript. The rationale was that in spirit, import assertions were not intended to guide module resolution. So this feature was shipped experimentally in a nightly-only mode to get more feedback.\nBut given that import attributes can guide resolution, and that we\u2019ve seen reasonable use-cases, TypeScript 5.3 now supports the resolution-mode\nattribute for import type\n.\nts\n// Resolve `pkg` as if we were importing with a `require()`import type { TypeFromRequire } from \"pkg\" with {\"resolution-mode\": \"require\"};// Resolve `pkg` as if we were importing with an `import`import type { TypeFromImport } from \"pkg\" with {\"resolution-mode\": \"import\"};export interface MergedType extends TypeFromRequire, TypeFromImport {}\nThese import attributes can also be used on import()\ntypes.\nts\nexport type TypeFromRequire =import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;export type TypeFromImport =import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;export interface MergedType extends TypeFromRequire, TypeFromImport {}\nFor more information, check out the change here\nresolution-mode\nSupported in All Module Modes\nPreviously, using resolution-mode\nwas only allowed under the moduleResolution\noptions node16\nand nodenext\n.\nTo make it easier to look up modules specifically for type purposes, resolution-mode\nnow works appropriately in all other moduleResolution\noptions like bundler\n, node10\n, and simply doesn\u2019t error under classic\n.\nFor more information, see the implementing pull request.\nswitch (true)\nNarrowing\nTypeScript 5.3 now can perform narrowing based on conditions in each case\nclause within a switch (true)\n.\nts\nfunction f(x: unknown) {switch (true) {case typeof x === \"string\":// 'x' is a 'string' hereconsole.log(x.toUpperCase());// falls through...case Array.isArray(x):// 'x' is a 'string | any[]' here.console.log(x.length);// falls through...default:// 'x' is 'unknown' here.// ...}}\nThis feature was spearheaded initial work by Mateusz Burzy\u0144ski We\u2019d like to extend a \u201cthank you!\u201d for this contribution.\nNarrowing On Comparisons to Booleans\nOccasionally you may find yourself performing a direct comparison with true\nor false\nin a condition.\nUsually these are unnecessary comparisons, but you might prefer it as a point of style, or to avoid certain issues around JavaScript truthiness.\nRegardless, previously TypeScript just didn\u2019t recognize such forms when performing narrowing.\nTypeScript 5.3 now keeps up and understands these expressions when narrowing variables.\nts\ninterface A {a: string;}interface B {b: string;}type MyType = A | B;function isA(x: MyType): x is A {return \"a\" in x;}function someFn(x: MyType) {if (isA(x) === true) {console.log(x.a); // works!}}\nWe\u2019d like to thank Mateusz Burzy\u0144ski for the pull request that implemented this.\ninstanceof\nNarrowing Through Symbol.hasInstance\nA slightly esoteric feature of JavaScript is that it is possible to override the behavior of the instanceof\noperator.\nTo do so, the value on the right side of the instanceof\noperator needs to have a specific method named by Symbol.hasInstance\n.\njs\nclass Weirdo {static [Symbol.hasInstance](testedValue) {// wait, what?return testedValue === undefined;}}// falseconsole.log(new Thing() instanceof Weirdo);// trueconsole.log(undefined instanceof Weirdo);\nTo better model this behavior in instanceof\n, TypeScript now checks if such a [Symbol.hasInstance]\nmethod exists and is declared as a type predicate function.\nIf it does, the tested value on the left side of the instanceof\noperator will be narrowed appropriately by that type predicate.\nts\ninterface PointLike {x: number;y: number;}class Point implements PointLike {x: number;y: number;constructor(x: number, y: number) {this.x = x;this.y = y;}distanceFromOrigin() {return Math.sqrt(this.x ** 2 + this.y ** 2);}static [Symbol.hasInstance](val: unknown): val is PointLike {return !!val && typeof val === \"object\" &&\"x\" in val && \"y\" in val &&typeof val.x === \"number\" &&typeof val.y === \"number\";}}function f(value: unknown) {if (value instanceof Point) {// Can access both of these - correct!value.x;value.y;// Can't access this - we have a 'PointLike',// but we don't *actually* have a 'Point'.value.distanceFromOrigin();}}\nAs you can see in this example, Point\ndefines its own [Symbol.hasInstance]\nmethod.\nIt actually acts as a custom type guard over a separate type called PointLike\n.\nIn the function f\n, we were able to narrow value\ndown to a PointLike\nwith instanceof\n, but not a Point\n.\nThat means that we can access the properties x\nand y\n, but not the method distanceFromOrigin\n.\nFor more information, you can read up on this change here.\nChecks for super\nProperty Accesses on Instance Fields\nIn JavaScript, it\u2019s possible to access a declaration in a base class through the super\nkeyword.\njs\nclass Base {someMethod() {console.log(\"Base method called!\");}}class Derived extends Base {someMethod() {console.log(\"Derived method called!\");super.someMethod();}}new Derived().someMethod();// Prints:// Derived method called!// Base method called!\nThis is different from writing something like this.someMethod()\n, since that could invoke an overridden method.\nThis is a subtle distinction, made more subtle by the fact that often the two can be interchangeable if a declaration is never overridden at all.\njs\nclass Base {someMethod() {console.log(\"someMethod called!\");}}class Derived extends Base {someOtherMethod() {// These act identically.this.someMethod();super.someMethod();}}new Derived().someOtherMethod();// Prints:// someMethod called!// someMethod called!\nThe problem is using them interchangeably is that super\nonly works on members declared on the prototype \u2014 not instance properties.\nThat means that if you wrote super.someMethod()\n, but someMethod\nwas defined as a field, you\u2019d get a runtime error!\nts\nclass Base {someMethod = () => {console.log(\"someMethod called!\");}}class Derived extends Base {someOtherMethod() {super.someMethod();}}new Derived().someOtherMethod();// \ud83d\udca5// Doesn't work because 'super.someMethod' is 'undefined'.\nTypeScript 5.3 now more-closely inspects super\nproperty accesses/method calls to see if they correspond to class fields.\nIf they do, we\u2019ll now get a type-checking error.\nThis check was contributed thanks to Jack Works!\nInteractive Inlay Hints for Types\nTypeScript\u2019s inlay hints now support jumping to the definition of types! This makes it easier to casually navigate your code.\nSee more at the implementation here.\nSettings to Prefer type\nAuto-Imports\nPreviously when TypeScript generated auto-imports for something in a type position, it would add a type\nmodifier based on your settings.\nFor example, when getting an auto-import on Person\nin the following:\nts\nexport let p: Person\nTypeScript\u2019s editing experience would usually add an import for Person\nas:\nts\nimport { Person } from \"./types\";export let p: Person\nand under certain settings like verbatimModuleSyntax\n, it would add the type\nmodifier:\nts\nimport { type Person } from \"./types\";export let p: Person\nHowever, maybe your codebase isn\u2019t able to use some of these options; or you just have a preference for explicit type\nimports when possible.\nWith a recent change, TypeScript now enables this to be an editor-specific option.\nIn Visual Studio Code, you can enable it in the UI under \u201cTypeScript \u203a Preferences: Prefer Type Only Auto Imports\u201d, or as the JSON configuration option typescript.preferences.preferTypeOnlyAutoImports\nOptimizations by Skipping JSDoc Parsing\nWhen running TypeScript via tsc\n, the compiler will now avoid parsing JSDoc.\nThis drops parsing time on its own, but also reduces memory usage to store comments along with time spent in garbage collection.\nAll-in-all, you should see slightly faster compiles and quicker feedback in --watch\nmode.\nThe specific changes can be viewed here.\nBecause not every tool using TypeScript will need to store JSDoc (e.g. typescript-eslint and Prettier), this parsing strategy has been surfaced as part of the API itself.\nThis can enable these tools to gain the same memory and speed improvements we\u2019ve brought to the TypeScript compiler.\nThe new options for comment parsing strategy are described in JSDocParsingMode\n.\nMore information is available on this pull request.\nOptimizations by Comparing Non-Normalized Intersections\nIn TypeScript, unions and intersections always follow a specific form, where intersections can\u2019t contain union types.\nThat means that when we create an intersection over a union like A & (B | C)\n, that intersection will be normalized into (A & B) | (A & C)\n.\nStill, in some cases the type system will maintain the original form for display purposes.\nIt turns out that the original form can be used for some clever fast-path comparisons between types.\nFor example, let\u2019s say we have SomeType & (Type1 | Type2 | ... | Type99999NINE)\nand we want to see if that\u2019s assignable to SomeType\n.\nRecall that we don\u2019t really have an intersection as our source type \u2014 we have a union that looks like (SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE)\n.\nWhen checking if a union is assignable to some target type, we have to check if every member of the union is assignable to the target type, and that can be very slow.\nIn TypeScript 5.3, we peek at the original intersection form that we were able to tuck away. When we compare the types, we do a quick check to see if the target exists in any constituent of the source intersection.\nFor more information, see this pull request.\nConsolidation Between tsserverlibrary.js\nand typescript.js\nTypeScript itself ships two library files: tsserverlibrary.js\nand typescript.js\n.\nThere are certain APIs available only in tsserverlibrary.js\n(like the ProjectService\nAPI), which may be useful to some importers.\nStill, the two are distinct bundles with a lot of overlap, duplicating code in the package.\nWhat\u2019s more, it can be challenging to consistently use one over the other due to auto-imports or muscle memory.\nAccidentally loading both modules is far too easy, and code may not work properly on a different instance of the API.\nEven if it does work, loading a second bundle increases resource usage.\nGiven this, we\u2019ve decided to consolidate the two.\ntypescript.js\nnow contains what tsserverlibrary.js\nused to contain, and tsserverlibrary.js\nnow simply re-exports typescript.js\n.\nComparing the before/after of this consolidation, we saw the following reduction in package size:\n| Before | After | Diff | Diff (percent) | |\n|---|---|---|---|---|\n| Packed | 6.90 MiB | 5.48 MiB | -1.42 MiB | -20.61% |\n| Unpacked | 38.74 MiB | 30.41 MiB | -8.33 MiB | -21.50% |\n| Before | After | Diff | Diff (percent) | |\n|---|---|---|---|---|\nlib/tsserverlibrary.d.ts |\n570.95 KiB | 865.00 B | -570.10 KiB | -99.85% |\nlib/tsserverlibrary.js |\n8.57 MiB | 1012.00 B | -8.57 MiB | -99.99% |\nlib/typescript.d.ts |\n396.27 KiB | 570.95 KiB | +174.68 KiB | +44.08% |\nlib/typescript.js |\n7.95 MiB | 8.57 MiB | +637.53 KiB | +7.84% |\nIn other words, this is over a 20.5% reduction in package size.\nFor more information, you can see the work involved here.\nBreaking Changes and Correctness Improvements\nlib.d.ts\nChanges\nTypes generated for the DOM may have an impact on your codebase. For more information, see the DOM updates for TypeScript 5.3.\nChecks for super\nAccesses on Instance Properties\nTypeScript 5.3 now detects when the declaration referenced by a super.\nproperty access is a class field and issues an error.\nThis prevents errors that might occur at runtime."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html", "title": "Documentation - TypeScript 5.4", "text": "Preserved Narrowing in Closures Following Last Assignments\nTypeScript can usually figure out a more specific type for a variable based on checks that you might perform. This process is called narrowing.\nts\nfunction uppercaseStrings(x: string | number) {if (typeof x === \"string\") {// TypeScript knows 'x' is a 'string' here.return x.toUpperCase();}}\nOne common pain point was that these narrowed types weren\u2019t always preserved within function closures.\nts\nfunction getUrls(url: string | URL, names: string[]) {if (typeof url === \"string\") {url = new URL(url);}return names.map(name => {url.searchParams.set(\"name\", name)// ~~~~~~~~~~~~// error!// Property 'searchParams' does not exist on type 'string | URL'.return url.toString();});}\nHere, TypeScript decided that it wasn\u2019t \u201csafe\u201d to assume that url\nwas actually a URL\nobject in our callback function because it was mutated elsewhere;\nhowever, in this instance, that arrow function is always created after that assignment to url\n, and it\u2019s also the last assignment to url\n.\nTypeScript 5.4 takes advantage of this to make narrowing a little smarter.\nWhen parameters and let\nvariables are used in non-hoisted functions, the type-checker will look for a last assignment point.\nIf one is found, TypeScript can safely narrow from outside the containing function.\nWhat that means is the above example just works now.\nNote that narrowing analysis doesn\u2019t kick in if the variable is assigned anywhere in a nested function. This is because there\u2019s no way to know for sure whether the function will be called later.\nts\nfunction printValueLater(value: string | undefined) {if (value === undefined) {value = \"missing!\";}setTimeout(() => {// Modifying 'value', even in a way that shouldn't affect// its type, will invalidate type refinements in closures.value = value;}, 500);setTimeout(() => {console.log(value.toUpperCase());// ~~~~~// error! 'value' is possibly 'undefined'.}, 1000);}\nThis should make lots of typical JavaScript code easier to express. You can read more about the change on GitHub.\nThe NoInfer\nUtility Type\nWhen calling generic functions, TypeScript is able to infer type arguments from whatever you pass in.\nts\nfunction doSomething<T>(arg: T) {// ...}// We can explicitly say that 'T' should be 'string'.doSomething<string>(\"hello!\");// We can also just let the type of 'T' get inferred.doSomething(\"hello!\");\nOne challenge, however, is that it is not always clear what the \u201cbest\u201d type is to infer. This might lead to TypeScript rejecting valid calls, accepting questionable calls, or just reporting worse error messages when it catches a bug.\nFor example, let\u2019s imagine a createStreetLight\nfunction that takes a list of color names, along with an optional default color.\nts\nfunction createStreetLight<C extends string>(colors: C[], defaultColor?: C) {// ...}createStreetLight([\"red\", \"yellow\", \"green\"], \"red\");\nWhat happens when we pass in a defaultColor\nthat wasn\u2019t in the original colors\narray?\nIn this function, colors\nis supposed to be the \u201csource of truth\u201d and describe what can be passed to defaultColor\n.\nts\n// Oops! This is undesirable, but is allowed!createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");\nIn this call, type inference decided that \"blue\"\nwas just as valid of a type as \"red\"\nor \"yellow\"\nor \"green\"\n.\nSo instead of rejecting the call, TypeScript infers the type of C\nas \"red\" | \"yellow\" | \"green\" | \"blue\"\n.\nYou might say that inference just blue up in our faces!\nOne way people currently deal with this is to add a separate type parameter that\u2019s bounded by the existing type parameter.\nts\nfunction createStreetLight<C extends string, D extends C>(colors: C[], defaultColor?: D) {}createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");// ~~~~~~// error!// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.\nThis works, but is a little bit awkward because D\nprobably won\u2019t be used anywhere else in the signature for createStreetLight\n.\nWhile not bad in this case, using a type parameter only once in a signature is often a code smell.\nThat\u2019s why TypeScript 5.4 introduces a new NoInfer<T>\nutility type.\nSurrounding a type in NoInfer<...>\ngives a signal to TypeScript not to dig in and match against the inner types to find candidates for type inference.\nUsing NoInfer\n, we can rewrite createStreetLight\nas something like this:\nts\nfunction createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {// ...}createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");// ~~~~~~// error!// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.\nExcluding the type of defaultColor\nfrom being explored for inference means that \"blue\"\nnever ends up as an inference candidate, and the type-checker can reject it.\nYou can see the specific changes in the implementing pull request, along with the initial implementation provided thanks to Mateusz Burzy\u0144ski!\nObject.groupBy\nand Map.groupBy\nTypeScript 5.4 adds declarations for JavaScript\u2019s new Object.groupBy\nand Map.groupBy\nstatic methods.\nObject.groupBy\ntakes an iterable, and a function that decides which \u201cgroup\u201d each element should be placed in.\nThe function needs to make a \u201ckey\u201d for each distinct group, and Object.groupBy\nuses that key to make an object where every key maps to an array with the original element in it.\nSo the following JavaScript:\njs\nconst array = [0, 1, 2, 3, 4, 5];const myObj = Object.groupBy(array, (num, index) => {return num % 2 === 0 ? \"even\": \"odd\";});\nis basically equivalent to writing this:\njs\nconst myObj = {even: [0, 2, 4],odd: [1, 3, 5],};\nMap.groupBy\nis similar, but produces a Map\ninstead of a plain object.\nThis might be more desirable if you need the guarantees of Map\ns, you\u2019re dealing with APIs that expect Map\ns, or you need to use any kind of key for grouping - not just keys that can be used as property names in JavaScript.\njs\nconst myObj = Map.groupBy(array, (num, index) => {return num % 2 === 0 ? \"even\" : \"odd\";});\nand just as before, you could have created myObj\nin an equivalent way:\njs\nconst myObj = new Map();myObj.set(\"even\", [0, 2, 4]);myObj.set(\"odd\", [1, 3, 5]);\nNote that in the above example of Object.groupBy\n, the object produced uses all optional properties.\nts\ninterface EvenOdds {even?: number[];odd?: number[];}const myObj: EvenOdds = Object.groupBy(...);myObj.even;// ~~~~// Error to access this under 'strictNullChecks'.\nThis is because there\u2019s no way to guarantee in a general way that all the keys were produced by groupBy\n.\nNote also that these methods are only accessible by configuring your target\nto esnext\nor adjusting your lib\nsettings.\nWe expect they will eventually be available under a stable es2024\ntarget.\nWe\u2019d like to extend a thanks to Kevin Gibbons for adding the declarations to these groupBy\nmethods.\nSupport for require()\ncalls in --moduleResolution bundler\nand --module preserve\nTypeScript has a moduleResolution\noption called bundler\nthat is meant to model the way modern bundlers figure out which file an import path refers to.\nOne of the limitations of the option is that it had to be paired with --module esnext\n, making it impossible to use the import ... = require(...)\nsyntax.\nts\n// previously erroredimport myModule = require(\"module/path\");\nThat might not seem like a big deal if you\u2019re planning on just writing standard ECMAScript import\ns, but there\u2019s a difference when using a package with conditional exports.\nIn TypeScript 5.4, require()\ncan now be used when setting the module\nsetting to a new option called preserve\n.\nBetween --module preserve\nand --moduleResolution bundler\n, the two more accurately model what bundlers and runtimes like Bun will allow, and how they\u2019ll perform module lookups.\nIn fact, when using --module preserve\n, the bundler\noption will be implicitly set for --moduleResolution\n(along with --esModuleInterop\nand --resolveJsonModule\n)\njson\n{\"compilerOptions\": {\"module\": \"preserve\",// ^ also implies:// \"moduleResolution\": \"bundler\",// \"esModuleInterop\": true,// \"resolveJsonModule\": true,// ...}}\nUnder --module preserve\n, an ECMAScript import\nwill always be emitted as-is, and import ... = require(...)\nwill be emitted as a require()\ncall (though in practice you may not even use TypeScript for emit, since it\u2019s likely you\u2019ll be using a bundler for your code).\nThis holds true regardless of the file extension of the containing file.\nSo the output of this code:\nts\nimport * as foo from \"some-package/foo\";import bar = require(\"some-package/bar\");\nshould look something like this:\njs\nimport * as foo from \"some-package/foo\";var bar = require(\"some-package/bar\");\nWhat this also means is that the syntax you choose directs how conditional exports are matched.\nSo in the above example, if the package.json\nof some-package\nlooks like this:\njson\n{\"name\": \"some-package\",\"version\": \"0.0.1\",\"exports\": {\"./foo\": {\"import\": \"./esm/foo-from-import.mjs\",\"require\": \"./cjs/foo-from-require.cjs\"},\"./bar\": {\"import\": \"./esm/bar-from-import.mjs\",\"require\": \"./cjs/bar-from-require.cjs\"}}}\nTypeScript will resolve these paths to [...]/some-package/esm/foo-from-import.mjs\nand [...]/some-package/cjs/bar-from-require.cjs\n.\nFor more information, you can read up on these new settings here.\nChecked Import Attributes and Assertions\nImport attributes and assertions are now checked against the global ImportAttributes\ntype.\nThis means that runtimes can now more accurately describe the import attributes\nts\n// In some global file.interface ImportAttributes {type: \"json\";}// In some other moduleimport * as ns from \"foo\" with { type: \"not-json\" };// ~~~~~~~~~~// error!//// Type '{ type: \"not-json\"; }' is not assignable to type 'ImportAttributes'.// Types of property 'type' are incompatible.// Type '\"not-json\"' is not assignable to type '\"json\"'.\nThis change was provided thanks to Oleksandr Tarasiuk.\nQuick Fix for Adding Missing Parameters\nTypeScript now has a quick fix to add a new parameter to functions that are called with too many arguments.\nThis can be useful when threading a new argument through several existing functions, which can be cumbersome today.\nThis quick fix was provided courtsey of Oleksandr Tarasiuk.\nUpcoming Changes from TypeScript 5.0 Deprecations\nTypeScript 5.0 deprecated the following options and behaviors:\ncharset\ntarget: ES3\nimportsNotUsedAsValues\nnoImplicitUseStrict\nnoStrictGenericChecks\nkeyofStringsOnly\nsuppressExcessPropertyErrors\nsuppressImplicitAnyIndexErrors\nout\npreserveValueImports\nprepend\nin project references- implicitly OS-specific\nnewLine\nTo continue using them, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called ignoreDeprecations\nwith the value \"5.0\"\n.\nHowever, TypScript 5.4 will be the last version in which these will continue to function as normal. By TypeScript 5.5 (likely June 2024), these will become hard errors, and code using them will need to be migrated away.\nFor more information, you can read up on this plan on GitHub, which contains suggestions in how to best adapt your codebase.\nNotable Behavioral Changes\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\nlib.d.ts\nChanges\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, see the DOM updates for TypeScript 5.4.\nMore Accurate Conditional Type Constraints\nThe following code no longer allows the second variable declaration in the function foo\n.\nts\ntype IsArray<T> = T extends any[] ? true : false;function foo<U extends object>(x: IsArray<U>) {let first: true = x; // Errorlet second: false = x; // Error, but previously wasn't}\nPreviously, when TypeScript checked the initializer for second\n, it needed to determine whether IsArray<U>\nwas assignable to the unit type false\n.\nWhile IsArray<U>\nisn\u2019t compatible any obvious way, TypeScript looks at the constraint of that type as well.\nIn a conditional type like T extends Foo ? TrueBranch : FalseBranch\n, where T\nis generic, the type system would look at the constraint of T\n, substitute it in for T\nitself, and decide on either the true or false branch.\nBut this behavior was inaccurate because it was overly eager.\nEven if the constraint of T\nisn\u2019t assignable to Foo\n, that doesn\u2019t mean that it won\u2019t be instantiated with something that is.\nAnd so the more correct behavior is to produce a union type for the constraint of the conditional type in cases where it can\u2019t be proven that T\nnever or always extends Foo.\nTypeScript 5.4 adopts this more accurate behavior. What this means in practice is that you may begin to find that some conditional type instances are no longer compatible with their branches.\nYou can read about the specific changes here.\nMore Aggressive Reduction of Intersections Between Type Variables and Primitive Types\nTypeScript now reduces intersections with type variables and primitives more aggressively, depending on how the type variable\u2019s constraint overlaps with those primitives.\nts\ndeclare function intersect<T, U>(x: T, y: U): T & U;function foo<T extends \"abc\" | \"def\">(x: T, str: string, num: number) {// Was 'T & string', now is just 'T'let a = intersect(x, str);// Was 'T & number', now is just 'never'let b = intersect(x, num)// Was '(T & \"abc\") | (T & \"def\")', now is just 'T'let c = Math.random() < 0.5 ?intersect(x, \"abc\") :intersect(x, \"def\");}\nFor more information, see the change here.\nImproved Checking Against Template Strings with Interpolations\nTypeScript now more accurately checks whether or not strings are assignable to the placeholder slots of a template string type.\nts\nfunction a<T extends {id: string}>() {let x: `-${keyof T & string}`;// Used to error, now doesn't.x = \"-id\";}\nThis behavior is more desirable, but may cause breaks in code using constructs like conditional types, where these rule changes are easy to witness.\nSee this change for more details.\nErrors When Type-Only Imports Conflict with Local Values\nPreviously, TypeScript would permit the following code under isolatedModules\nif the import to Something\nonly referred to a type.\nts\nimport { Something } from \"./some/path\";let Something = 123;\nHowever, it\u2019s not safe for single-file compilers to assume whether it\u2019s \u201csafe\u201d to drop the import\n, even if the code is guaranteed to fail at runtime.\nIn TypeScript 5.4, this code will trigger an error like the following:\nImport 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled.\nThe fix should be to either make a local rename, or, as the error states, add the type\nmodifier to the import:\nts\nimport type { Something } from \"./some/path\";// orimport { type Something } from \"./some/path\";\nSee more information on the change itself.\nNew Enum Assignability Restrictions\nWhen two enums have the same declared names and enum member names, they were previously always considered compatible; however, when the values were known, TypeScript would silently allow them to have differing values.\nTypeScript 5.4 tightens this restriction by requiring the values to be identical when they are known.\nts\nnamespace First {export enum SomeEnum {A = 0,B = 1,}}namespace Second {export enum SomeEnum {A = 0,B = 2,}}function foo(x: First.SomeEnum, y: Second.SomeEnum) {// Both used to be compatible - no longer the case,// TypeScript errors with something like://// Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.x = y;y = x;}\nAdditionally, there are new restrictions for when one of the enum members does not have a statically known value. In these cases, the other enum must at least be implicitly numeric (e.g. it has no statically resolved initializer), or it is explicitly numeric (meaning TypeScript could resolve the value to something numeric). Practically speaking, what this means is that string enum members are only ever compatible with other string enums of the same value.\nts\nnamespace First {export declare enum SomeEnum {A,B,}}namespace Second {export declare enum SomeEnum {A,B = \"some known string\",}}function foo(x: First.SomeEnum, y: Second.SomeEnum) {// Both used to be compatible - no longer the case,// TypeScript errors with something like://// One value of 'SomeEnum.B' is the string '\"some known string\"', and the other is assumed to be an unknown numeric value.x = y;y = x;}\nFor more information, see the pull request that introduced this change.\nName Restrictions on Enum Members\nTypeScript no longer allows enum members to use the names Infinity\n, -Infinity\n, or NaN\n.\nts\n// Errors on all of these://// An enum member cannot have a numeric name.enum E {Infinity = 0,\"-Infinity\" = 1,NaN = 2,}\nBetter Mapped Type Preservation Over Tuples with any\nRest Elements\nPreviously, applying a mapped type with any\ninto a tuple would create an any\nelement type.\nThis is undesirable and is now fixed.\nts\nPromise.all([\"\", ...([] as any)]).then((result) => {const head = result[0]; // 5.3: any, 5.4: stringconst tail = result.slice(1); // 5.3 any, 5.4: any[]});\nFor more information, see the fix along with the follow-on discussion around behavioral changes and further tweaks.\nEmit Changes\nWhile not a breaking change per se, developers may have implicitly taken dependencies on TypeScript\u2019s JavaScript or declaration emit outputs. The following are notable changes."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html", "title": "Documentation - TypeScript 5.5", "text": "Inferred Type Predicates\nThis section was written by Dan Vanderkam, who implemented this feature in TypeScript 5.5. Thanks Dan!\nTypeScript\u2019s control flow analysis does a great job of tracking how the type of a variable changes as it moves through your code:\ntsx\ninterface Bird {commonName: string;scientificName: string;sing(): void;}// Maps country names -> national bird.// Not all nations have official birds (looking at you, Canada!)declare const nationalBirds: Map<string, Bird>;function makeNationalBirdCall(country: string) {const bird = nationalBirds.get(country); // bird has a declared type of Bird | undefinedif (bird) {bird.sing(); // bird has type Bird inside the if statement} else {// bird has type undefined here.}}\nBy making you handle the undefined\ncase, TypeScript pushes you to write more robust code.\nIn the past, this sort of type refinement was more difficult to apply to arrays. This would have been an error in all previous versions of TypeScript:\ntsx\nfunction makeBirdCalls(countries: string[]) {// birds: (Bird | undefined)[]const birds = countries.map(country => nationalBirds.get(country)).filter(bird => bird !== undefined);for (const bird of birds) {bird.sing(); // error: 'bird' is possibly 'undefined'.}}\nThis code is perfectly fine: we\u2019ve filtered all the undefined\nvalues out of the list.\nBut TypeScript hasn\u2019t been able to follow along.\nWith TypeScript 5.5, the type checker is fine with this code:\ntsx\nfunction makeBirdCalls(countries: string[]) {// birds: Bird[]const birds = countries.map(country => nationalBirds.get(country)).filter(bird => bird !== undefined);for (const bird of birds) {bird.sing(); // ok!}}\nNote the more precise type for birds\n.\nThis works because TypeScript now infers a type predicate for the filter\nfunction.\nYou can see what\u2019s going on more clearly by pulling it out into a standalone function:\ntsx\n// function isBirdReal(bird: Bird | undefined): bird is Birdfunction isBirdReal(bird: Bird | undefined) {return bird !== undefined;}\nbird is Bird\nis the type predicate.\nIt means that, if the function returns true\n, then it\u2019s a Bird\n(if the function returns false\nthen it\u2019s undefined\n).\nThe type declarations for Array.prototype.filter\nknow about type predicates, so the net result is that you get a more precise type and the code passes the type checker.\nTypeScript will infer that a function returns a type predicate if these conditions hold:\n- The function does not have an explicit return type or type predicate annotation.\n- The function has a single\nreturn\nstatement and no implicit returns. - The function does not mutate its parameter.\n- The function returns a\nboolean\nexpression that\u2019s tied to a refinement on the parameter.\nGenerally this works how you\u2019d expect. Here\u2019s a few more examples of inferred type predicates:\ntsx\n// const isNumber: (x: unknown) => x is numberconst isNumber = (x: unknown) => typeof x === 'number';// const isNonNullish: <T>(x: T) => x is NonNullable<T>const isNonNullish = <T,>(x: T) => x != null;\nPreviously, TypeScript would have just inferred that these functions return boolean\n.\nIt now infers signatures with type predicates like x is number\nor x is NonNullable<T>\n.\nType predicates have \u201cif and only if\u201d semantics.\nIf a function returns x is T\n, then it means that:\n- If the function returns\ntrue\nthenx\nhas the typeT\n. - If the function returns\nfalse\nthenx\ndoes not have typeT\n.\nIf you\u2019re expecting a type predicate to be inferred but it\u2019s not, then you may be running afoul of the second rule. This often comes up with \u201ctruthiness\u201d checks:\ntsx\nfunction getClassroomAverage(students: string[], allScores: Map<string, number>) {const studentScores = students.map(student => allScores.get(student)).filter(score => !!score);return studentScores.reduce((a, b) => a + b) / studentScores.length;// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// error: Object is possibly 'undefined'.}\nTypeScript did not infer a type predicate for score => !!score\n, and rightly so: if this returns true\nthen score\nis a number\n.\nBut if it returns false\n, then score\ncould be either undefined\nor a number\n(specifically, 0\n).\nThis is a real bug: if any student got a zero on the test, then filtering out their score will skew the average upwards.\nFewer will be above average and more will be sad!\nAs with the first example, it\u2019s better to explicitly filter out undefined\nvalues:\ntsx\nfunction getClassroomAverage(students: string[], allScores: Map<string, number>) {const studentScores = students.map(student => allScores.get(student)).filter(score => score !== undefined);return studentScores.reduce((a, b) => a + b) / studentScores.length; // ok!}\nA truthiness check will infer a type predicate for object types, where there\u2019s no ambiguity.\nRemember that functions must return a boolean\nto be a candidate for an inferred type predicate: x => !!x\nmight infer a type predicate, but x => x\ndefinitely won\u2019t.\nExplicit type predicates continue to work exactly as before. TypeScript will not check whether it would infer the same type predicate. Explicit type predicates (\u201cis\u201d) are no safer than a type assertion (\u201cas\u201d).\nIt\u2019s possible that this feature will break existing code if TypeScript now infers a more precise type than you want. For example:\ntsx\n// Previously, nums: (number | null)[]// Now, nums: number[]const nums = [1, 2, 3, null, 5].filter(x => x !== null);nums.push(null); // ok in TS 5.4, error in TS 5.5\nThe fix is to tell TypeScript the type that you want using an explicit type annotation:\ntsx\nconst nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null);nums.push(null); // ok in all versions\nFor more information, check out the implementing pull request and Dan\u2019s blog post about implementing this feature.\nControl Flow Narrowing for Constant Indexed Accesses\nTypeScript is now able to narrow expressions of the form obj[key]\nwhen both obj\nand key\nare effectively constant.\nts\nfunction f1(obj: Record<string, unknown>, key: string) {if (typeof obj[key] === \"string\") {// Now okay, previously was errorobj[key].toUpperCase();}}\nIn the above, neither obj\nnor key\nare ever mutated, so TypeScript can narrow the type of obj[key]\nto string\nafter the typeof\ncheck.\nFor more information, see the implementing pull request here.\nThe JSDoc @import\nTag\nToday, if you want to import something only for type-checking in a JavaScript file, it is cumbersome.\nJavaScript developers can\u2019t simply import a type named SomeType\nif it\u2019s not there at runtime.\njs\n// ./some-module.d.tsexport interface SomeType {// ...}// ./index.jsimport { SomeType } from \"./some-module\"; // \u274c runtime error!/*** @param {SomeType} myValue*/function doSomething(myValue) {// ...}\nSomeType\nwon\u2019t exist at runtime, so the import will fail.\nDevelopers can instead use a namespace import instead.\njs\nimport * as someModule from \"./some-module\";/*** @param {someModule.SomeType} myValue*/function doSomething(myValue) {// ...}\nBut ./some-module\nis still imported at runtime - which might also not be desirable.\nTo avoid this, developers typically had to use import(...)\ntypes in JSDoc comments.\njs\n/*** @param {import(\"./some-module\").SomeType} myValue*/function doSomething(myValue) {// ...}\nIf you wanted to reuse the same type in multiple places, you could use a typedef\nto avoid repeating the import.\njs\n/*** @typedef {import(\"./some-module\").SomeType} SomeType*//*** @param {SomeType} myValue*/function doSomething(myValue) {// ...}\nThis helps with local uses of SomeType\n, but it gets repetitive for many imports and can be a bit verbose.\nThat\u2019s why TypeScript now supports a new @import\ncomment tag that has the same syntax as ECMAScript imports.\njs\n/** @import { SomeType } from \"some-module\" *//*** @param {SomeType} myValue*/function doSomething(myValue) {// ...}\nHere, we used named imports. We could also have written our import as a namespace import.\njs\n/** @import * as someModule from \"some-module\" *//*** @param {someModule.SomeType} myValue*/function doSomething(myValue) {// ...}\nBecause these are just JSDoc comments, they don\u2019t affect runtime behavior at all.\nWe would like to extend a big thanks to Oleksandr Tarasiuk who contributed this change!\nRegular Expression Syntax Checking\nUntil now, TypeScript has typically skipped over most regular expressions in code. This is because regular expressions technically have an extensible grammar and TypeScript never made any effort to compile regular expressions to earlier versions of JavaScript. Still, this meant that lots of common problems would go undiscovered in regular expressions, and they would either turn into errors at runtime, or silently fail.\nBut TypeScript now does basic syntax checking on regular expressions!\nts\nlet myRegex = /@robot(\\s+(please|immediately)))? do some task/;// ~// error!// Unexpected ')'. Did you mean to escape it with backslash?\nThis is a simple example, but this checking can catch a lot of common mistakes. In fact, TypeScript\u2019s checking goes slightly beyond syntactic checks. For instance, TypeScript can now catch issues around backreferences that don\u2019t exist.\nts\nlet myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;// ~// error!// This backreference refers to a group that does not exist.// There are only 2 capturing groups in this regular expression.\nThe same applies to named capturing groups.\nts\nlet myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<namedImport>/;// ~~~~~~~~~~~// error!// There is no capturing group named 'namedImport' in this regular expression.\nTypeScript\u2019s checking is now also aware of when certain RegExp features are used when newer than your target version of ECMAScript. For example, if we use named capturing groups like the above in an ES5 target, we\u2019ll get an error.\nts\nlet myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<importedEntity>/;// ~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~// error!// Named capturing groups are only available when targeting 'ES2018' or later.\nThe same is true for certain regular expression flags as well.\nNote that TypeScript\u2019s regular expression support is limited to regular expression literals.\nIf you try calling new RegExp\nwith a string literal, TypeScript will not check the provided string.\nWe would like to thank GitHub user graphemecluster who iterated a ton with us to get this feature into TypeScript.\nSupport for New ECMAScript Set\nMethods\nTypeScript 5.5 declares new proposed methods for the ECMAScript Set\ntype.\nSome of these methods, like union\n, intersection\n, difference\n, and symmetricDifference\n, take another Set\nand return a new Set\nas the result.\nThe other methods, isSubsetOf\n, isSupersetOf\n, and isDisjointFrom\n, take another Set\nand return a boolean\n.\nNone of these methods mutate the original Set\ns.\nHere\u2019s a quick example of how you might use these methods and how they behave:\nts\nlet fruits = new Set([\"apples\", \"bananas\", \"pears\", \"oranges\"]);let applesAndBananas = new Set([\"apples\", \"bananas\"]);let applesAndOranges = new Set([\"apples\", \"oranges\"]);let oranges = new Set([\"oranges\"]);let emptySet = new Set();////// union////// Set(4) {'apples', 'bananas', 'pears', 'oranges'}console.log(fruits.union(oranges));// Set(3) {'apples', 'bananas', 'oranges'}console.log(applesAndBananas.union(oranges));////// intersection////// Set(2) {'apples', 'bananas'}console.log(fruits.intersection(applesAndBananas));// Set(0) {}console.log(applesAndBananas.intersection(oranges));// Set(1) {'apples'}console.log(applesAndBananas.intersection(applesAndOranges));////// difference////// Set(3) {'apples', 'bananas', 'pears'}console.log(fruits.difference(oranges));// Set(2) {'pears', 'oranges'}console.log(fruits.difference(applesAndBananas));// Set(1) {'bananas'}console.log(applesAndBananas.difference(applesAndOranges));////// symmetricDifference////// Set(2) {'bananas', 'oranges'}console.log(applesAndBananas.symmetricDifference(applesAndOranges)); // no apples////// isDisjointFrom////// trueconsole.log(applesAndBananas.isDisjointFrom(oranges));// falseconsole.log(applesAndBananas.isDisjointFrom(applesAndOranges));// trueconsole.log(fruits.isDisjointFrom(emptySet));// trueconsole.log(emptySet.isDisjointFrom(emptySet));////// isSubsetOf////// trueconsole.log(applesAndBananas.isSubsetOf(fruits));// falseconsole.log(fruits.isSubsetOf(applesAndBananas));// falseconsole.log(applesAndBananas.isSubsetOf(oranges));// trueconsole.log(fruits.isSubsetOf(fruits));// trueconsole.log(emptySet.isSubsetOf(fruits));////// isSupersetOf////// trueconsole.log(fruits.isSupersetOf(applesAndBananas));// falseconsole.log(applesAndBananas.isSupersetOf(fruits));// falseconsole.log(applesAndBananas.isSupersetOf(oranges));// trueconsole.log(fruits.isSupersetOf(fruits));// falseconsole.log(emptySet.isSupersetOf(fruits));\nWe\u2019d like to thank Kevin Gibbons who not only co-championed the feature in ECMAScript, but also provided the declarations for Set\n, ReadonlySet\n, and ReadonlySetLike\nin TypeScript!\nIsolated Declarations\nThis section was co-authored by Rob Palmer who supported the design of isolated declarations.\nDeclaration files (a.k.a. .d.ts\nfiles) describe the shape of existing libraries and modules to TypeScript.\nThis lightweight description includes the library\u2019s type signatures and excludes implementation details such as the function bodies.\nThey are published so that TypeScript can efficiently check your usage of a library without needing to analyse the library itself.\nWhilst it is possible to handwrite declaration files, if you are authoring typed code, it\u2019s much safer and simpler to let TypeScript generate them automatically from source files using --declaration\n.\nThe TypeScript compiler and its APIs have always had the job of generating declaration files; however, there are some use-cases where you might want to use other tools, or where the traditional build process doesn\u2019t scale.\nUse-case: Faster Declaration Emit Tools\nImagine if you wanted to create a faster tool to generate declaration files, perhaps as part of a publishing service or a new bundler. Whilst there is a thriving ecosystem of blazing fast tools that can turn TypeScript into JavaScript, the same is not true for turning TypeScript into declaration files. The reason is that TypeScript\u2019s inference allows us to write code without explicitly declaring types, meaning declaration emit can be complex.\nLet\u2019s consider a simple example of a function that adds two imported variables.\nts\n// util.tsexport let one = \"1\";export let two = \"2\";// add.tsimport { one, two } from \"./util\";export function add() { return one + two; }\nEven if the only thing we want to do is generate add.d.ts\n, TypeScript needs to crawl into another imported file (util.ts\n), infer that the type of one\nand two\nare strings, and then calculate that the +\noperator on two strings will lead to a string\nreturn type.\nts\n// add.d.tsexport declare function add(): string;\nWhile this inference is important for the developer experience, it means that tools that want to generate declaration files would need to replicate parts of the type-checker including inference and the ability to resolve module specifiers to follow the imports.\nUse-case: Parallel Declaration Emit and Parallel Checking\nImagine if you had a monorepo containing many projects and a multi-core CPU that just wished it could help you check your code faster. Wouldn\u2019t it be great if we could check all those projects at the same time by running each project on a different core?\nUnfortunately we don\u2019t have the freedom to do all the work in parallel. The reason is that we have to build those projects in dependency order, because each project is checking against the declaration files of their dependencies. So we must build the dependency first to generate the declaration files. TypeScript\u2019s project references feature works the same way, building the set of projects in \u201ctopological\u201d dependency order.\nAs an example, if we have two projects called backend\nand frontend\n, and they both depend on a project called core\n, TypeScript can\u2019t start type-checking either frontend\nor backend\nuntil core\nhas been built and its declaration files have been generated.\nIn the above graph, you can see that we have a bottleneck.\nWhilst we can build frontend\nand backend\nin parallel, we need to first wait for core\nto finish building before either can start.\nHow could we improve upon this?\nWell, if a fast tool could generate all those declaration files for core\nin parallel, TypeScript then could immediately follow that by type-checking core\n, frontend\n, and backend\nalso in parallel.\nSolution: Explicit Types!\nThe common requirement in both use-cases is that we need a cross-file type-checker to generate declaration files. Which is a lot to ask from the tooling community.\nAs a more complex example, if we want a declaration file for the following code\u2026\nts\nimport { add } from \"./add\";const x = add();export function foo() {return x;}\n\u2026we would need to generate a signature for foo\n.\nWell that requires looking at the implementation of foo\n.\nfoo\njust returns x\n, so getting the type of x\nrequires looking at the implementation of add\n.\nBut that might require looking at the implementation of add\n\u2019s dependencies, and so on.\nWhat we\u2019re seeing here is that generating declaration files requires a whole lot of logic to figure out the types of different places that might not even be local to the current file.\nStill, for developers looking for fast iteration time and fully parallel builds, there is another way of thinking about this problem. A declaration file only requires the types of the public API of a module - in other words, the types of the things that are exported. If, controversially, developers are willing to explicitly write out the types of the things they export, tools could generate declaration files without needing to look at the implementation of the module - and without reimplementing a full type-checker.\nThis is where the new --isolatedDeclarations\noption comes in.\n--isolatedDeclarations\nreports errors when a module can\u2019t be reliably transformed without a type-checker.\nMore plainly, it makes TypeScript report errors if you have a file that isn\u2019t sufficiently annotated on its exports.\nThat means in the above example, we would see an error like the following:\nts\nexport function foo() {// ~~~// error! Function must have an explicit// return type annotation with --isolatedDeclarations.return x;}\nWhy are errors desirable?\nBecause it means that TypeScript can\n- Tell us up-front whether other tools will have issues with generating declaration files\n- Provide a quick fix to help add these missing annotations.\nThis mode doesn\u2019t require annotations everywhere though. For locals, these can be ignored, since they don\u2019t affect the public API. For example, the following code would not produce an error:\nts\nimport { add } from \"./add\";const x = add(\"1\", \"2\"); // no error on 'x', it's not exported.export function foo(): string {return x;}\nThere are also certain expressions where the type is \u201ctrivial\u201d to calculate.\nts\n// No error on 'x'.// It's trivial to calculate the type is 'number'export let x = 10;// No error on 'y'.// We can get the type from the return expression.export function y() {return 20;}// No error on 'z'.// The type assertion makes it clear what the type is.export function z() {return Math.max(x, y()) as number;}\nUsing isolatedDeclarations\nisolatedDeclarations\nrequires that either the declaration\nor composite\nflags are also set.\nNote that isolatedDeclarations\ndoes not change how TypeScript performs emit - just how it reports errors.\nImportantly, and similar to isolatedModules\n, enabling the feature in TypeScript won\u2019t immediately bring about the potential benefits discussed here.\nSo please be patient and look forward to future developments in this space.\nKeeping tool authors in mind, we should also recognize that today, not all of TypeScript\u2019s declaration emit can be easily replicated by other tools wanting to use it as a guide.\nThat\u2019s something we\u2019re actively working on improving.\nOn top of this, isolated declarations are still a new feature, and we\u2019re actively working on improving the experience.\nSome scenarios, like using computed property declarations in classes and object literals, are not yet supported under isolatedDeclarations\n.\nKeep an eye on this space, and feel free to provide us with feedback.\nWe also feel it is worth calling out that isolatedDeclarations\nshould be adopted on a case-by-case basis.\nThere are some developer ergonomics that are lost when using isolatedDeclarations\n, and thus it may not be the right choice if your setup is not leveraging the two scenarios mentioned earlier.\nFor others, the work on isolatedDeclarations\nhas already uncovered many optimizations and opportunities to unlock different parallel build strategies.\nIn the meantime, if you\u2019re willing to make the trade-offs, we believe isolatedDeclarations\ncan be a powerful tool to speed up your build process as external tooling becomes more widely available.\nFor more information, read up on the Isolated Declarations: State of the Feature discussion on the TypeScript issue tracker.\nCredit\nWork on isolatedDeclarations\nhas been a long-time collaborative effort between the TypeScript team and the infrastructure and tooling teams within Bloomberg and Google.\nIndividuals like Hana Joo from Google who implemented the quick fix for isolated declaration errors (more on that soon), as well as Ashley Claymore, Jan K\u00fchle, Lisa Velden, Rob Palmer, and Thomas Chetwin have been involved in discussion, specification, and implementation for many months.\nBut we feel it is specifically worth calling out the tremendous amount of work provided by Titian Cernicova-Dragomir from Bloomberg.\nTitian has been instrumental in driving the implementation of isolatedDeclarations\nand has been a contributor to the TypeScript project for years prior.\nWhile the feature involved many changes, you can see the core work for Isolated Declarations here.\nThe ${configDir}\nTemplate Variable for Configuration Files\nIt\u2019s common in many codebases to reuse a shared tsconfig.json\nfile that acts as a \u201cbase\u201d for other configuration files.\nThis is done by using the extends\nfield in a tsconfig.json\nfile.\njson\n{\"extends\": \"../../tsconfig.base.json\",\"compilerOptions\": {\"outDir\": \"./dist\"}}\nOne of the issues with this is that all paths in the tsconfig.json\nfile are relative to the location of the file itself.\nThis means that if you have a shared tsconfig.base.json\nfile that is used by multiple projects, relative paths often won\u2019t be useful in the derived projects.\nFor example, imagine the following tsconfig.base.json\n:\njson\n{\"compilerOptions\": {\"typeRoots\": [\"./node_modules/@types\"\"./custom-types\"],\"outDir\": \"dist\"}}\nIf author\u2019s intent was that every tsconfig.json\nthat extends this file should\n- output to a\ndist\ndirectory relative to the derivedtsconfig.json\n, and - have a\ncustom-types\ndirectory relative to the derivedtsconfig.json\n,\nthen this would not work.\nThe typeRoots\npaths would be relative to the location of the shared tsconfig.base.json\nfile, not the project that extends it.\nEach project that extends this shared file would need to declare its own outDir\nand typeRoots\nwith identical contents.\nThis could be frustrating and hard to keep in sync between projects, and while the example above is using typeRoots\n, this is a common problem for paths\nand other options.\nTo solve this, TypeScript 5.5 introduces a new template variable ${configDir}\n.\nWhen ${configDir}\nis written in certain path fields of a tsconfig.json\nor jsconfig.json\nfiles, this variable is substituted with the containing directory of the configuration file in a given compilation.\nThis means that the above tsconfig.base.json\ncould be rewritten as:\njson\n{\"compilerOptions\": {\"typeRoots\": [\"${configDir}/node_modules/@types\"\"${configDir}/custom-types\"],\"outDir\": \"${configDir}/dist\"}}\nNow, when a project extends this file, the paths will be relative to the derived tsconfig.json\n, not the shared tsconfig.base.json\nfile.\nThis makes it easier to share configuration files across projects and ensures that the configuration files are more portable.\nIf you intend to make a tsconfig.json\nfile extendable, consider if a ./\nshould instead be written with ${configDir}\n.\nFor more information, see the proposal issue and the implementing pull request.\nConsulting package.json\nDependencies for Declaration File Generation\nPreviously, TypeScript would often issue an error message like\nThe inferred type of \"X\" cannot be named without a reference to \"Y\". This is likely not portable. A type annotation is necessary.\nThis was often due to TypeScript\u2019s declaration file generation finding itself in the contents of files that were never explicitly imported in a program.\nGenerating an import to such a file could be risky if the path ended up being relative.\nStill, for codebases with explicit dependencies in the dependencies\n(or peerDependencies\nand optionalDependencies\n) of a package.json\n, generating such an import should be safe under certain resolution modes.\nSo in TypeScript 5.5, we\u2019re more lenient when that\u2019s the case, and many occurrences of this error should disappear.\nSee this pull request for more details on the change.\nEditor and Watch-Mode Reliability Improvements\nTypeScript has either added some new functionality or fixed existing logic that makes --watch\nmode and TypeScript\u2019s editor integration feel more reliable.\nThat should hopefully translate to fewer TSServer/editor restarts.\nCorrectly Refresh Editor Errors in Configuration Files\nTypeScript can generate errors for tsconfig.json\nfiles;\nhowever, those errors are actually generated from loading a project, and editors typically don\u2019t directly request those errors for tsconfig.json\nfiles.\nWhile this sounds like a technical detail, it means that when all errors issued in a tsconfig.json\nare fixed, TypeScript doesn\u2019t issue a new fresh empty set of errors, and users are left with stale errors unless they reload their editor.\nTypeScript 5.5 now intentionally issues an event to clear these out. See more here.\nBetter Handling for Deletes Followed by Immediate Writes\nInstead of overwriting files, some tools will opt to delete them and then create new files from scratch.\nThis is the case when running npm ci\n, for instance.\nWhile this can be efficient for those tools, it can be problematic for TypeScript\u2019s editor scenarios where deleting a watched might dispose of it and all of its transitive dependencies. Deleting and creating a file in quick succession could lead to TypeScript tearing down an entire project and then rebuilding it from scratch.\nTypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted project around until it picks up on a new creation event.\nThis should make operations like npm ci\nwork a lot better with TypeScript.\nSee more information on the approach here.\nSymlinks are Tracked in Failed Resolutions\nWhen TypeScript fails to resolve a module, it will still need to watch for any failed lookup paths in case the module is added later. Previously this was not done for symlinked directories, which could cause reliability issues in monorepo-like scenarios when a build occurred in one project but was not witnessed in the other. This should be fixed in TypeScript 5.5, and means you won\u2019t need to restart your editor as often.\nProject References Contribute to Auto-Imports\nAuto-imports no longer requires at least one explicit import to dependent projects in a project reference setup.\nInstead, auto-import completions should just work across anything you\u2019ve listed in the references\nfield of your tsconfig.json\n.\nSee more on the implementing pull request.\nPerformance and Size Optimizations\nMonomorphized Objects in Language Service and Public API\nIn TypeScript 5.0, we ensured that our Node\nand Symbol\nobjects had a consistent set of properties with a consistent initialization order.\nDoing so helps reduce polymorphism in different operations, which allows runtimes to fetch properties more quickly.\nBy making this change, we witnessed impressive speed wins in the compiler; however, most of these changes were performed on internal allocators for our data structures. The language service, along with TypeScript\u2019s public API, uses a different set of allocators for certain objects. This allowed the TypeScript compiler to be a bit leaner, as data used only for the language service would never be used in the compiler.\nIn TypeScript 5.5, the same monomorphization work has been done for the language service and public API. What this means is that your editor experience, and any build tools that use the TypeScript API, will get a decent amount faster. In fact, in our benchmarks, we\u2019ve seen a 5-8% speedup in build times when using the public TypeScript API\u2019s allocators, and language service operations getting 10-20% faster. While this does imply an increase in memory, we believe that tradeoff is worth it and hope to find ways to reduce that memory overhead. Things should feel a lot snappier now.\nFor more information, see the change here.\nMonomorphized Control Flow Nodes\nIn TypeScript 5.5, nodes of the control flow graph have been monomorphized so that they always hold a consistent shape. By doing so, check times will often be reduced by about 1%.\nOptimizations on our Control Flow Graph\nIn many cases, control flow analysis will traverse nodes that don\u2019t provide any new information. We observed that in the absence of any early termination or effects in the antecedents (or \u201cdominators\u201d) of certain nodes meant that those nodes could always be skipped over. As such, TypeScript now constructs its control flow graphs to take advantage of this by linking to an earlier node that does provide interesting information for control flow analysis. This yields a flatter control flow graph, which can be more efficient to traverse. This optimization has yielded modest gains, but with up to 2% reductions in build time on certain codebases.\nYou can read more here.\nSkipped Checking in transpileModule\nand transpileDeclaration\nTypeScript\u2019s transpileModule\nAPI can be used for compiling a single TypeScript file\u2019s contents into JavaScript.\nSimilarly, the transpileDeclaration\nAPI (see below) can be used to generate a declaration file for a single TypeScript file.\nOne of the issues with these APIs is that TypeScript internally would perform a full type-checking pass over the entire contents of the file before emitting the output.\nThis was necessary to collect certain information which would later be used for the emit phase.\nIn TypeScript 5.5, we\u2019ve found a way to avoid performing a full check, only lazily collecting this information as necessary, and transpileModule\nand transpileDeclaration\nboth enable this functionality by default.\nAs a result, tools that integrate with these APIs, like ts-loader with transpileOnly\nand ts-jest, should see a noticeable speedup.\nIn our testing, we generally witness around a 2x speed-up in build time using transpileModule\n.\nTypeScript Package Size Reduction\nFurther leveraging our transition to modules in 5.0, we\u2019ve significantly reduced TypeScript\u2019s overall package size by making tsserver.js\nand typingsInstaller.js\nimport from a common API library instead of having each of them produce standalone bundles.\nThis reduces TypeScript\u2019s size on disk from 30.2 MB to 20.4 MB, and reduces its packed size from 5.5 MB to 3.7 MB!\nNode Reuse in Declaration Emit\nAs part of the work to enable isolatedDeclarations\n, we\u2019ve substantially improved how often TypeScript can directly copy your input source code when producing declaration files.\nFor example, let\u2019s say you wrote\nts\nexport const strBool: string | boolean = \"hello\";export const boolStr: boolean | string = \"world\";\nNote that the union types are equivalent, but the order of the union is different. When emitting the declaration file, TypeScript has two equivalent output possibilities.\nThe first is to use a consistent canonical representation for each type:\nts\nexport const strBool: string | boolean;export const boolStr: string | boolean;\nThe second is to re-use the type annotations exactly as written:\nts\nexport const strBool: string | boolean;export const boolStr: boolean | string;\nThe second approach is generally preferable for a few reasons:\n- Many equivalent representations still encode some level of intent that is better to preserve in the declaration file\n- Producing a fresh representation of a type can be somewhat expensive, so avoiding is better\n- User-written types are usually shorter than generated type representations\nIn 5.5, we\u2019ve greatly improved the number of places where TypeScript can correctly identify places where it\u2019s safe and correct to print back types exactly as they were written in the input file. Many of these cases are invisible performance improvements - TypeScript would generate fresh sets of syntax nodes and serialize them into a string. Instead, TypeScript can now operate over the original syntax nodes directly, which is much cheaper and faster.\nCaching Contextual Types from Discriminated Unions\nWhen TypeScript asks for the contextual type of an expression like an object literal, it will often encounter a union type. In those cases, TypeScript tries to filter out members of the union based on known properties with well known values (i.e. discriminant properties). This work can be fairly expensive, especially if you end up with an object consisting of many many properties. In TypeScript 5.5, much of the computation is cached once so that TypeScript doesn\u2019t need to recompute it for every property in the object literal. Performing this optimization shaved 250ms off of compiling the TypeScript compiler itself.\nEasier API Consumption from ECMAScript Modules\nPreviously, if you were writing an ECMAScript module in Node.js, named imports were not available from the typescript\npackage.\nts\nimport { createSourceFile } from \"typescript\"; // \u274c errorimport * as ts from \"typescript\";ts.createSourceFile // \u274c undefined???ts.default.createSourceFile // \u2705 works - but ugh!\nThis is because cjs-module-lexer did not recognize the pattern of TypeScript\u2019s generated CommonJS code. This has been fixed, and users can now use named imports from the TypeScript npm package with ECMAScript modules in Node.js.\nts\nimport { createSourceFile } from \"typescript\"; // \u2705 works now!import * as ts from \"typescript\";ts.createSourceFile // \u2705 works now!\nFor more information, see the change here.\nThe transpileDeclaration\nAPI\nTypeScript\u2019s API exposes a function called transpileModule\n.\nIt\u2019s intended to make it easy to compile a single file of TypeScript code.\nBecause it doesn\u2019t have access to an entire program, the caveat is that it may not produce the right output if the code violates any errors under the isolatedModules\noption.\nIn TypeScript 5.5, we\u2019ve added a new similar API called transpileDeclaration\n.\nThis API is similar to transpileModule\n, but it\u2019s specifically designed to generate a single declaration file based on some input source text.\nJust like transpileModule\n, it doesn\u2019t have access to a full program, and a similar caveat applies: it only generates an accurate declaration file if the input code is free of errors under the new isolatedDeclarations\noption.\nIf desired, this function can be used to parallelize declaration emit across all files under isolatedDeclarations\nmode.\nFor more information, see the implementation here.\nNotable Behavioral Changes\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\nDisabling Features Deprecated in TypeScript 5.0\nTypeScript 5.0 deprecated the following options and behaviors:\ncharset\ntarget: ES3\nimportsNotUsedAsValues\nnoImplicitUseStrict\nnoStrictGenericChecks\nkeyofStringsOnly\nsuppressExcessPropertyErrors\nsuppressImplicitAnyIndexErrors\nout\npreserveValueImports\nprepend\nin project references- implicitly OS-specific\nnewLine\nTo continue using the deprecated options above, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called ignoreDeprecations\nwith the value \"5.0\"\n.\nIn TypeScript 5.5, these options no longer have any effect. To help with a smooth upgrade path, you may still specify them in your tsconfig, but these will be an error to specify in TypeScript 6.0. See also the Flag Deprecation Plan which outlines our deprecation strategy.\nMore information around these deprecation plans is available on GitHub, which contains suggestions in how to best adapt your codebase.\nlib.d.ts\nChanges\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, see the DOM updates for TypeScript 5.5.\nStricter Parsing for Decorators\nSince TypeScript originally introduced support for decorators, the specified grammar for the proposal has been tightened up. TypeScript is now stricter about what forms it allows. While rare, existing decorators may need to be parenthesized to avoid errors.\nts\nclass DecoratorProvider {decorate(...args: any[]) { }}class D extends DecoratorProvider {m() {class C {@super.decorate // \u274c errormethod1() { }@(super.decorate) // \u2705 okaymethod2() { }}}}\nSee more information on the change here.\nundefined\nis No Longer a Definable Type Name\nTypeScript has always disallowed type alias names that conflict with built-in types:\nts\n// Illegaltype null = any;// Illegaltype number = any;// Illegaltype object = any;// Illegaltype any = any;\nDue to a bug, this logic didn\u2019t also apply to the built-in type undefined\n.\nIn 5.5, this is now correctly identified as an error:\nts\n// Now also illegaltype undefined = any;\nBare references to type aliases named undefined\nnever actually worked in the first place.\nYou could define them, but you couldn\u2019t use them as an unqualified type name.\nts\nexport type undefined = string;export const m: undefined = \"\";// ^// Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted.\nFor more information, see the change here.\nSimplified Reference Directive Declaration Emit\nWhen producing a declaration file, TypeScript would synthesize a reference directive when it believed one was required. For example, all Node.js modules are declared ambiently, so cannot be loaded by module resolution alone. A file like:\ntsx\nimport path from \"path\";export const myPath = path.parse(__filename);\nWould emit a declaration file like:\ntsx\n/// <reference types=\"node\" />import path from \"path\";export declare const myPath: path.ParsedPath;\nEven though the reference directive never appeared in the original source.\nSimilarly, TypeScript also removed reference directives that it did not believe needed to be a part of the output.\nFor example, let\u2019s imagine we had a reference directive to jest\n;\nhowever, imagine the reference directive isn\u2019t necessary to generate the declaration file.\nTypeScript would simply drop it.\nSo in the following example:\ntsx\n/// <reference types=\"jest\" />import path from \"path\";export const myPath = path.parse(__filename);\nTypeScript would still emit:\ntsx\n/// <reference types=\"node\" />import path from \"path\";export declare const myPath: path.ParsedPath;\nIn the course of working on isolatedDeclarations\n, we realized that this logic was untenable for anyone attempting to implement a declaration emitter without type checking or using more than a single file\u2019s context.\nThis behavior is also hard to understand from a user\u2019s perspective; whether or not a reference directive appeared in the emitted file seems inconsistent and difficult to predict unless you understand exactly what\u2019s going on during typechecking.\nTo prevent declaration emit from being different when isolatedDeclarations\nwas enabled, we knew that our emit needed to change.\nThrough experimentation, we found that nearly all cases where TypeScript synthesized reference directives were just to pull in node\nor react\n.\nThese are cases where the expectation is that a downstream user already references those types through tsconfig.json \"types\"\nor library imports, so no longer synthesizing these reference directives would be unlikely to break anyone.\nIt\u2019s worth noting that this is already how it works for lib.d.ts\n; TypeScript doesn\u2019t synthesize a reference to lib=\"es2015\"\nwhen a module exports a WeakMap\n, instead assuming that a downstream user will have included that as part of their environment.\nFor reference directives that had been written by library authors (not synthesized), further experimentation showed that nearly all were removed, never showing up in the output. Most reference directives that were preserved were broken and likely not intended to be preserved.\nGiven those results, we decided to greatly simplfy reference directives in declaration emit in TypeScript 5.5. A more consistent strategy will help library authors and consumers have better control of their declaration files.\nReference directives are no longer synthesized.\nUser-written reference directives are no longer preserved, unless annotated with a new preserve=\"true\"\nattribute.\nConcretely, an input file like:\ntsx\n/// <reference types=\"some-lib\" preserve=\"true\" />/// <reference types=\"jest\" />import path from \"path\";export const myPath = path.parse(__filename);\nwill emit:\ntsx\n/// <reference types=\"some-lib\" preserve=\"true\" />import path from \"path\";export declare const myPath: path.ParsedPath;\nAdding preserve=\"true\"\nis backwards compatible with older versions of TypeScript as unknown attributes are ignored.\nThis change also improved performance; in our benchmarks, the emit stage saw a 1-4% improvement in projects with declaration emit enabled."}]