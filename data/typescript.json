[{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html", "title": "Documentation - TypeScript 5.6", "text": "Disallowed Nullish and Truthy Checks Maybe you\u2019ve written a regex and forgotten to call .test(...) on it: ts if (/0x[0-9a-f]/) {// Oops! This block always runs.// ...} or maybe you\u2019ve accidentally written => (which creates an arrow function) instead of >= (the greater-than-or-equal-to operator): ts if (x => 0) {// Oops! This block always runs.// ...} or maybe you\u2019ve tried to use a default value with ?? , but mixed up the precedence of ?? and a comparison operator like < : ts function isValid(value: string | number, options: any, strictness: \"strict\" | \"loose\") {if (strictness === \"loose\") {value = +value}return value < options.max ?? 100;// Oops! This is parsed as (value < options.max) ?? 100} or maybe you\u2019ve misplaced a parenthesis in a complex expression: ts if (isValid(primaryValue, \"strict\") || isValid(secondaryValue, \"strict\") ||isValid(primaryValue, \"loose\" || isValid(secondaryValue, \"loose\"))) {// ^^^^ \ud83d\udc40 Did we forget a closing ')'?} None of these examples do what the author intended, but they\u2019re all valid JavaScript code. Previously TypeScript also quietly accepted these examples. But with a little bit of experimentation, we found that many many bugs could be caught from flagging down suspicious examples like above. In TypeScript 5.6, the compiler now errors when it can syntactically determine a truthy or nullish check will always evaluate in a specific way. So in the above examples, you\u2019ll start to see errors: ts if (/0x[0-9a-f]/) {// ~~~~~~~~~~~~// error: This kind of expression is always truthy.}if (x => 0) {// ~~~~~~// error: This kind of expression is always truthy.}function isValid(value: string | number, options: any, strictness: \"strict\" | \"loose\") {if (strictness === \"loose\") {value = +value}return value < options.max ?? 100;// ~~~~~~~~~~~~~~~~~~~// error: Right operand of ?? is unreachable because the left operand is never nullish.}if (isValid(primaryValue, \"strict\") || isValid(secondaryValue, \"strict\") ||isValid(primaryValue, \"loose\" || isValid(secondaryValue, \"loose\"))) {// ~~~~~~~// error: This kind of expression is always truthy.} Similar results can be achieved by enabling the ESLint no-constant-binary-expression rule, and you can see some of the results they achieved in their blog post; but the new checks TypeScript performs does not have perfect overlap with the ESLint rule, and we also believe there is a lot of value in having these checks built into TypeScript itself. Note that certain expressions are still allowed, even if they are always truthy or nullish. Specifically, true , false , 0 , and 1 are all still allowed despite always being truthy or falsy, since code like the following: ts while (true) {doStuff();if (something()) {break;}doOtherStuff();} is still idiomatic and useful, and code like the following: ts if (true || inDebuggingOrDevelopmentEnvironment()) {// ...} is useful while iterating/debugging code. If you\u2019re curious about the implementation or the sorts of bugs it catches, take a look at the pull request that implemented this feature. Iterator Helper Methods JavaScript has a notion of iterables (things which we can iterate over by calling a [Symbol.iterator]() and getting an iterator) and iterators (things which have a next() method which we can call to try to get the next value as we iterate). By and large, you don\u2019t typically have to think about these things when you toss them into a for /of loop, or [...spread] them into a new array. But TypeScript does model these with the types Iterable and Iterator (and even IterableIterator which acts as both!), and these types describe the minimal set of members you need for constructs like for /of to work on them. Iterable s (and IterableIterator s) are nice because they can be used in all sorts of places in JavaScript - but a lot of people found themselves missing methods on Array s like map , filter , and for some reason reduce . That\u2019s why a recent proposal was brought forward in ECMAScript to add many methods (and more) from Array onto most of the IterableIterator s that are produced in JavaScript. For example, every generator now produces an object that also has a map method and a take method. ts function* positiveIntegers() {let i = 1;while (true) {yield i;i++;}}const evenNumbers = positiveIntegers().map(x => x * 2);// Output:// 2// 4// 6// 8// 10for (const value of evenNumbers.take(5)) {console.log(value);} The same is true for methods like keys() , values() , and entries() on Map s and Set s. ts function invertKeysAndValues<K, V>(map: Map<K, V>): Map<V, K> {return new Map(map.entries().map(([k, v]) => [v, k]));} You can also extend the new Iterator object: ts /*** Provides an endless stream of `0`s.*/class Zeroes extends Iterator<number> {next() {return { value: 0, done: false } as const;}}const zeroes = new Zeroes();// Transform into an endless stream of `1`s.const ones = zeroes.map(x => x + 1); And you can adapt any existing Iterable s or Iterator s into this new type with Iterator.from : ts Iterator.from(...).filter(someFunction); Now, we have to talk about naming. Earlier we mentioned that TypeScript has types for Iterable and Iterator ; however, like we mentioned, these act sort of like \u201cprotocols\u201d to ensure certain operations work. That means that not every value that is declared Iterable or Iterator in TypeScript will have those methods we mentioned above. But there is still a new runtime value called Iterator . You can reference Iterator , as well as Iterator.prototype , as actual values in JavaScript. This is a bit awkward since TypeScript already defines its own thing called Iterator purely for type-checking. So due to this unfortunate name clash, TypeScript needs to introduce a separate type to describe these native/built-in iterable iterators. TypeScript 5.6 introduces a new type called IteratorObject . It is defined as follows: ts interface IteratorObject<T, TReturn = unknown, TNext = unknown> extends Iterator<T, TReturn, TNext> {[Symbol.iterator](): IteratorObject<T, TReturn, TNext>;} Lots of built-in collections and methods produce subtypes of IteratorObject s (like ArrayIterator , SetIterator , MapIterator , and more), and both the core JavaScript and DOM types in lib.d.ts , along with @types/node , have been updated to use this new type. Similarly, there is a AsyncIteratorObject type for parity. AsyncIterator does not yet exist as a runtime value in JavaScript that brings the same methods for AsyncIterable s, but it is an active proposal and this new type prepares for it. We\u2019d like to thank Kevin Gibbons who contributed the changes for these types, and who is one of the co-authors of the proposal. Strict Builtin Iterator Checks (and --strictBuiltinIteratorReturn ) When you call the next() method on an Iterator<T, TReturn> , it returns an object with a value and a done property. This is modeled with the type IteratorResult . ts type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> | IteratorReturnResult<TReturn>;interface IteratorYieldResult<TYield> {done?: false;value: TYield;}interface IteratorReturnResult<TReturn> {done: true;value: TReturn;} The naming here is inspired by the way a generator function works. Generator functions can yield values, and then return a final value - but the types between the two can be unrelated. ts function abc123() {yield \"a\";yield \"b\";yield \"c\";return 123;}const iter = abc123();iter.next(); // { value: \"a\", done: false }iter.next(); // { value: \"b\", done: false }iter.next(); // { value: \"c\", done: false }iter.next(); // { value: 123, done: true } With the new IteratorObject type, we discovered some difficulties in allowing safe implementations of IteratorObject s. At the same time, there\u2019s been a long standing unsafety with IteratorResult in cases where TReturn was any (the default!). For example, let\u2019s say we have an IteratorResult<string, any> . If we end up reaching for the value of this type, we\u2019ll end up with string | any , which is just any . ts function* uppercase(iter: Iterator<string, any>) {while (true) {const { value, done } = iter.next();yield value.toUppercase(); // oops! forgot to check for `done` first and misspelled `toUpperCase`if (done) {return;}}} It would be hard to fix this on every Iterator today without introducing a lot of breaks, but we can at least fix it with most IteratorObject s that get created. TypeScript 5.6 introduces a new intrinsic type called BuiltinIteratorReturn and a new --strict -mode flag called --strictBuiltinIteratorReturn . Whenever IteratorObject s are used in places like lib.d.ts , they are always written with BuiltinIteratorReturn type for TReturn (though you\u2019ll see the more-specific MapIterator , ArrayIterator , SetIterator more often). ts interface MapIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {[Symbol.iterator](): MapIterator<T>;}// ...interface Map<K, V> {// .../*** Returns an iterable of key, value pairs for every entry in the map.*/entries(): MapIterator<[K, V]>;/*** Returns an iterable of keys in the map*/keys(): MapIterator<K>;/*** Returns an iterable of values in the map*/values(): MapIterator<V>;} By default, BuiltinIteratorReturn is any , but when --strictBuiltinIteratorReturn is enabled (possibly via --strict ), it is undefined . Under this new mode, if we use BuiltinIteratorReturn , our earlier example now correctly errors: ts function* uppercase(iter: Iterator<string, BuiltinIteratorReturn>) {while (true) {const { value, done } = iter.next();yield value.toUppercase();// ~~~~~ ~~~~~~~~~~~// error! \u2503 \u2503// \u2503 \u2517\u2501 Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?// \u2503// \u2517\u2501 'value' is possibly 'undefined'.if (done) {return;}}} You\u2019ll typically see BuiltinIteratorReturn paired up with IteratorObject throughout lib.d.ts . In general, we recommend being more explicit around the TReturn in your own code when possible. For more information, you can read up on the feature here. Support for Arbitrary Module Identifiers JavaScript allows modules to export bindings with invalid identifier names as string literals: ts const banana = \"\ud83c\udf4c\";export { banana as \"\ud83c\udf4c\" }; Likewise, it allows modules to grab imports with these arbitrary names and bind them to valid identifiers: ts import { \"\ud83c\udf4c\" as banana } from \"./foo\"/*** om nom nom*/function eat(food: string) {console.log(\"Eating\", food);};eat(banana); This seems like a cute party trick (if you\u2019re as fun as we are at parties), but it has its uses for interoperability with other languages (typically via JavaScript/WebAssembly boundaries), since other languages may have different rules for what constitutes a valid identifier. It can also be useful for tools that generate code, like esbuild with its inject feature. TypeScript 5.6 now allows you to use these arbitrary module identifiers in your code! We\u2019d like to thank Evan Wallace who contributed this change to TypeScript! The --noUncheckedSideEffectImports Option In JavaScript it\u2019s possible to import a module without actually importing any values from it. ts import \"some-module\"; These imports are often called side effect imports because the only useful behavior they can provide is by executing some side effect (like registering a global variable, or adding a polyfill to a prototype). In TypeScript, this syntax has had a pretty strange quirk: if the import could be resolved to a valid source file, then TypeScript would load and check the file. On the other hand, if no source file could be found, TypeScript would silently ignore the import ! This is surprising behavior, but it partially stems from modeling patterns in the JavaScript ecosystem. For example, this syntax has also been used with special loaders in bundlers to load CSS or other assets. Your bundler might be configured in such a way where you can include specific .css files by writing something like the following: tsx import \"./button-component.css\";export function Button() {// ...} Still, this masks potential typos on side effect imports. That\u2019s why TypeScript 5.6 introduces a new compiler option called --noUncheckedSideEffectImports , to catch these cases. When --noUncheckedSideEffectImports is enabled, TypeScript will now error if it can\u2019t find a source file for a side effect import. ts import \"oops-this-module-does-not-exist\";// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations. When enabling this option, some working code may now receive an error, like in the CSS example above. To work around this, users who want to just write side effect import s for assets might be better served by writing what\u2019s called an ambient module declaration with a wildcard specifier. It would go in a global file and look something like the following: ts // ./src/globals.d.ts// Recognize all CSS files as module imports.declare module \"*.css\" {} In fact, you might already have a file like this in your project! For example, running something like vite init might create a similar vite-env.d.ts . While this option is currently off by default, we encourage users to give it a try! For more information, check out the implementation here. The --noCheck Option TypeScript 5.6 introduces a new compiler option, --noCheck , which allows you to skip type checking for all input files. This avoids unnecessary type-checking when performing any semantic analysis necessary for emitting output files. One scenario for this is to separate JavaScript file generation from type-checking so that the two can be run as separate phases. For example, you could run tsc --noCheck while iterating, and then tsc --noEmit for a thorough type check. You could also run the two tasks in parallel, even in --watch mode, though note you\u2019d probably want to specify a separate --tsBuildInfoFile path if you\u2019re truly running them at the same time. --noCheck is also useful for emitting declaration files in a similar fashion. In a project where --noCheck is specified on a project that conforms to --isolatedDeclarations , TypeScript can quickly generate declaration files without a type-checking pass. The generated declaration files will rely purely on quick syntactic transformations. Note that in cases where --noCheck is specified, but a project does not use --isolatedDeclarations , TypeScript may still perform as much type-checking as necessary to generate .d.ts files. In this sense, --noCheck is a bit of a misnomer; however, the process will be lazier than a full type-check, only calculating the types of unannotated declarations. This should be much faster than a full type-check. noCheck is also available via the TypeScript API as a standard option. Internally, transpileModule and transpileDeclaration already used noCheck to speed things up (at least as of TypeScript 5.5). Now any build tool should be able to leverage the flag, taking a variety of custom strategies to coordinate and speed up builds. For more information, see the work done in TypeScript 5.5 to power up noCheck internally, along with the relevant work to make it publicly available on the command line and Allow --build with Intermediate Errors TypeScript\u2019s concept of project references allows you to organize your codebase into multiple projects and create dependencies between them. Running the TypeScript compiler in --build mode (or tsc -b for short) is the built-in way of actually conducting that build across projects and figuring out which projects and files need to be compiled. Previously, using --build mode would assume --noEmitOnError and immediately stop the build if any errors were encountered. This meant that \u201cdownstream\u201d projects could never be checked and built if any of their \u201cupstream\u201d dependencies had build errors. In theory, this is a very cromulent approach - if a project has errors, it is not necessarily in a coherent state for its dependencies. In reality, this sort of rigidity made things like upgrades a pain. For example, if projectB depends on projectA , then people more familiar with projectB can\u2019t proactively upgrade their code until their dependencies are upgraded. They are blocked by work on upgrading projectA first. As of TypeScript 5.6, --build mode will continue to build projects even if there are intermediate errors in dependencies. In the face of intermediate errors, they will be reported consistently and output files will be generated on a best-effort basis; however, the build will continue to completion on the specified project. If you want to stop the build on the first project with errors, you can use a new flag called --stopOnBuildErrors . This can be useful when running in a CI environment, or when iterating on a project that\u2019s heavily depended upon by other projects. Note that to accomplish this, TypeScript now always emits a .tsbuildinfo file for any project in a --build invocation (even if --incremental /--composite is not specified). This is to keep track of the state of how --build was invoked and what work needs to be performed in the future. You can read more about this change here on the implementation. Region-Prioritized Diagnostics in Editors When TypeScript\u2019s language service is asked for the diagnostics for a file (things like errors, suggestions, and deprecations), it would typically require checking the entire file. Most of the time this is fine, but in extremely large files it can incur a delay. That can be frustrating because fixing a typo should feel like a quick operation, but can take seconds in a big-enough file. To address this, TypeScript 5.6 introduces a new feature called region-prioritized diagnostics or region-prioritized checking. Instead of just requesting diagnostics for a set of files, editors can now also provide a relevant region of a given file - and the intent is that this will typically be the region of the file that is currently visible to a user. The TypeScript language server can then choose to provide two sets of diagnostics: one for the region, and one for the file in its entirety. This allows editing to feel way more responsive in large files so you\u2019re not waiting as long for thoes red squiggles to disappear. For some specific numbers, in our testing on TypeScript\u2019s own checker.ts , a full semantic diagnostics response took 3330ms. In contrast, the response for the first region-based diagnostics response took 143ms! While the remaining whole-file response took about 3200ms, this can make a huge difference for quick edits. This feature also includes quite a bit of work to also make diagnostics report more consistently throughout your experience. Due the way our type-checker leverages caching to avoid work, subsequent checks between the same types could often have a different (typically shorter) error message. Technically, lazy out-of-order checking could cause diagnostics to report differently between two locations in an editor - even before this feature - but we didn\u2019t want to exacerbate the issue. With recent work, we\u2019ve ironed out many of these error inconsistencies. Currently, this functionality is available in Visual Studio Code for TypeScript 5.6 and later. For more detailed information, take a look at the implementation and write-up here. Granular Commit Characters TypeScript\u2019s language service now provides its own commit characters for each completion item. Commit characters are specific characters that, when typed, will automatically commit the currently-suggested completion item. What this means is that over time your editor will now more frequently commit to the currently-suggested completion item when you type certain characters. For example, take the following code: ts declare let food: {eat(): any;}let f = (foo/**/ If our cursor is at /**/ , it\u2019s unclear if the code we\u2019re writing is going to be something like let f = (food.eat()) or let f = (foo, bar) => foo + bar . You could imagine that the editor might be able to auto-complete differently depending on which character we type out next. For instance, if we type in the period/dot character (. ), we probably want the editor to complete with the variable food ; but if we type the comma character (, ), we might be writing out a parameter in an arrow function. Unfortunately, previously TypeScript just signaled to editors that the current text might define a new parameter name so that no commit characters were safe. So hitting a . wouldn\u2019t do anything even if it was \u201cobvious\u201d that the editor should auto-complete with the word food . TypeScript now explicitly lists which characters are safe to commit for each completion item. While this won\u2019t immediately change your day-to-day experience, editors that support these commit characters should see behavioral improvements over time. To see those improvements right now, you can now use the TypeScript nightly extension with Visual Studio Code Insiders. Hitting . in the code above correctly auto-completes with food . For more information, see the pull request that added commit characters along with our adjustments to commit characters depending on context. Exclude Patterns for Auto-Imports TypeScript\u2019s language service now allows you to specify a list of regular expression patterns which will filter away auto-import suggestions from certain specifiers. For example, if you want to exclude all \u201cdeep\u201d imports from a package like lodash , you could configure the following preference in Visual Studio Code: json {\"typescript.preferences.autoImportSpecifierExcludeRegexes\": [\"^lodash/.*$\"]} Or going the other way, you might want to disallow importing from the entry-point of a package: json {\"typescript.preferences.autoImportSpecifierExcludeRegexes\": [\"^lodash$\"]} One could even avoid node: imports by using the following setting: json {\"typescript.preferences.autoImportSpecifierExcludeRegexes\": [\"^node:\"]} Note that if you want to specify certain flags like i or u , you will need to surround your regular expression with slashes. When providing surrounding slashes, you\u2019ll need to escape other inner slashes. json {\"typescript.preferences.autoImportSpecifierExcludeRegexes\": [\"^./lib/internal\", // no escaping needed\"/^.\\\\/lib\\\\/internal/\", // escaping needed - note the leading and trailing slashes\"/^.\\\\/lib\\\\/internal/i\" // escaping needed - we needed slashes to provide the 'i' regex flag]} In Visual Studio Code, the same settings can be applied for JavaScript through javascript.preferences.autoImportSpecifierExcludeRegexes . For more information, see the implementation here. Notable Behavioral Changes This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors. lib.d.ts Types generated for the DOM may have an impact on type-checking your codebase. For more information, see linked issues related to DOM and lib.d.ts updates for this version of TypeScript. .tsbuildinfo is Always Written To enable --build to continue building projects even if there are intermediate errors in dependencies, and to support --noCheck on the command line, TypeScript now always emits a .tsbuildinfo file for any project in a --build invocation. This happens regardless of whether --incremental is actually on. See more information here. Respecting File Extensions and package.json from within node_modules Before Node.js implemented support for ECMAScript modules in v12, there was never a good way for TypeScript to know whether .d.ts files it found in node_modules represented JavaScript files authored as CommonJS or ECMAScript modules. When the vast majority of npm was CommonJS-only, this didn\u2019t cause many problems - if in doubt, TypeScript could just assume that everything behaved like CommonJS. Unfortunately, if that assumption was wrong it could allow unsafe imports: ts // node_modules/dep/index.d.tsexport declare function doSomething(): void;// index.ts// Okay if \"dep\" is a CommonJS module, but fails if// it's an ECMAScript module - even in bundlers!import dep from \"dep\";dep.doSomething(); In practice, this didn\u2019t come up very often. But in the years since Node.js started supporting ECMAScript modules, the share of ESM on npm has grown. Fortunately, Node.js also introduced a mechanism that can help TypeScript determine if a file is an ECMAScript module or a CommonJS module: the .mjs and .cjs file extensions and the package.json \"type\" field. TypeScript 4.7 added support for understanding these indicators, as well as authoring .mts and .cts files; however, TypeScript would only read those indicators under --module node16 and --module nodenext , so the unsafe import above was still a problem for anyone using --module esnext and --moduleResolution bundler , for example. To solve this, TypeScript 5.6 collects module format information and uses it to resolve ambiguities like the one in the example above in all module modes (except amd , umd , and system ). Format-specific file extensions (.mts and .cts ) are respected anywhere they\u2019re found, and the package.json \"type\" field is consulted inside node_modules dependencies, regardless of the module setting. Previously, it was technically possible to produce CommonJS output into a .mjs file or vice versa: ts // main.mtsexport default \"oops\";// $ tsc --module commonjs main.mts// main.mjsObject.defineProperty(exports, \"__esModule\", { value: true });exports.default = \"oops\"; Now, .mts files never emit CommonJS output, and .cts files never emit ESM output. Note that much of this behavior was provided in pre-release versions of TypeScript 5.5 (implementation details here), but in 5.6 this behavior is only extended to files within node_modules . More details are available on the change here. Correct override Checks on Computed Properties Previously, computed properties marked with override did not correctly check for the existence of a base class member. Similarly, if you used noImplicitOverride , you would not get an error if you forgot to add an override modifier to a computed property. TypeScript 5.6 now correctly checks computed properties in both cases. ts const foo = Symbol(\"foo\");const bar = Symbol(\"bar\");class Base {[bar]() {}}class Derived extends Base {override [foo]() {}// ~~~~~// error: This member cannot have an 'override' modifier because it is not declared in the base class 'Base'.[bar]() {}// ~~~~~// error under noImplicitOverride: This member must have an 'override' modifier because it overrides a member in the base class 'Base'.} This fix was contributed thanks to Oleksandr Tarasiuk in this pull request."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html", "title": "Documentation - TypeScript 5.7", "text": "Checks for Never-Initialized Variables For a long time, TypeScript has been able to catch issues when a variable has not yet been initialized in all prior branches. ts let result: numberif (someCondition()) {result = doSomeWork();}else {let temporaryWork = doSomeWork();temporaryWork *= 2;// forgot to assign to 'result'}console.log(result); // error: Variable 'result' is used before being assigned. Unfortunately, there are some places where this analysis doesn\u2019t work. For example, if the variable is accessed in a separate function, the type system doesn\u2019t know when the function will be called, and instead takes an \u201coptimistic\u201d view that the variable will be initialized. ts function foo() {let result: numberif (someCondition()) {result = doSomeWork();}else {let temporaryWork = doSomeWork();temporaryWork *= 2;// forgot to assign to 'result'}printResult();function printResult() {console.log(result); // no error here.}} While TypeScript 5.7 is still lenient on variables that have possibly been initialized, the type system is able to report errors when variables have never been initialized at all. ts function foo() {let result: number// do work, but forget to assign to 'result'function printResult() {console.log(result); // error: Variable 'result' is used before being assigned.}} This change was contributed thanks to the work of GitHub user Zzzen! Path Rewriting for Relative Paths There are several tools and runtimes that allow you to run TypeScript code \u201cin-place\u201d, meaning they do not require a build step which generates output JavaScript files. For example, ts-node, tsx, Deno, and Bun all support running .ts files directly. More recently, Node.js has been investigating such support with --experimental-strip-types (soon to be unflagged!) and --experimental-transform-types . This is extremely convenient because it allows us to iterate faster without worrying about re-running a build task. There is some complexity to be aware of when using these modes though. To be maximally compatible with all these tools, a TypeScript file that\u2019s imported \u201cin-place\u201d must be imported with the appropriate TypeScript extension at runtime. For example, to import a file called foo.ts , we have to write the following in Node\u2019s new experimental support: ts // main.tsimport * as foo from \"./foo.ts\"; // <- we need foo.ts here, not foo.js Typically, TypeScript would issue an error if we did this, because it expects us to import the output file. Because some tools do allow .ts imports, TypeScript has supported this import style with an option called --allowImportingTsExtensions for a while now. This works fine, but what happens if we need to actually generate .js files out of these .ts files? This is a requirement for library authors who will need to be able to distribute just .js files, but up until now TypeScript has avoided rewriting any paths. To support this scenario, we\u2019ve added a new compiler option called --rewriteRelativeImportExtensions . When an import path is relative (starts with ./ or ../ ), ends in a TypeScript extension (.ts , .tsx , .mts , .cts ), and is a non-declaration file, the compiler will rewrite the path to the corresponding JavaScript extension (.js , .jsx , .mjs , .cjs ). ts // Under --rewriteRelativeImportExtensions...// these will be rewritten.import * as foo from \"./foo.ts\";import * as bar from \"../someFolder/bar.mts\";// these will NOT be rewritten in any way.import * as a from \"./foo\";import * as b from \"some-package/file.ts\";import * as c from \"@some-scope/some-package/file.ts\";import * as d from \"#/file.ts\";import * as e from \"./file.js\"; This allows us to write TypeScript code that can be run in-place and then compiled into JavaScript when we\u2019re ready. Now, we noted that TypeScript generally avoided rewriting paths. There are several reasons for this, but the most obvious one is dynamic imports. If a developer writes the following, it\u2019s not trivial to handle the path that import receives. In fact, it\u2019s impossible to override the behavior of import within any dependencies. ts function getPath() {if (Math.random() < 0.5) {return \"./foo.ts\";}else {return \"./foo.js\";}}let myImport = await import(getPath()); Another issue is that (as we saw above) only relative paths are rewritten, and they are written \u201cnaively\u201d. This means that any path that relies on TypeScript\u2019s baseUrl and paths will not get rewritten: json // tsconfig.json{\"compilerOptions\": {\"module\": \"nodenext\",// ...\"paths\": {\"@/*\": [\"./src/*\"]}}} ts // Won't be transformed, won't work.import * as utilities from \"@/utilities.ts\"; Nor will any path that might resolve through the exports and imports fields of a package.json . json // package.json{\"name\": \"my-package\",\"imports\": {\"#root/*\": \"./dist/*\"}} ts // Won't be transformed, won't work.import * as utilities from \"#root/utilities.ts\"; As a result, if you\u2019ve been using a workspace-style layout with multiple packages referencing each other, you might need to use conditional exports with scoped custom conditions to make this work: json // my-package/package.json{\"name\": \"my-package\",\"exports\": {\".\": {\"@my-package/development\": \"./src/index.ts\",\"import\": \"./lib/index.js\"},\"./*\": {\"@my-package/development\": \"./src/*.ts\",\"import\": \"./lib/*.js\"}}} Any time you want to import the .ts files, you can run it with node --conditions=@my-package/development . Note the \u201cnamespace\u201d or \u201cscope\u201d we used for the condition @my-package/development . This is a bit of a makeshift solution to avoid conflicts from dependencies that might also use the development condition. If everyone ships a development in their package, then resolution may try to resolve to a .ts file which will not necessarily work. This idea is similar to what\u2019s described in Colin McDonnell\u2019s essay Live types in a TypeScript monorepo, along with tshy\u2019s guidance for loading from source. For more specifics on how this feature works, read up on the change here. Support for --target es2024 and --lib es2024 TypeScript 5.7 now supports --target es2024 , which allows users to target ECMAScript 2024 runtimes. This target primarily enables specifying the new --lib es2024 which contains many features for SharedArrayBuffer and ArrayBuffer , Object.groupBy , Map.groupBy , Promise.withResolvers , and more. It also moves Atomics.waitAsync from --lib es2022 to --lib es2024 . Note that as part of the changes to SharedArrayBuffer and ArrayBuffer , the two now diverge a bit. To bridge the gap and preserve the underlying buffer type, all TypedArrays (like Uint8Array and others) are now also generic. ts interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {// ...} Each TypedArray now contains a type parameter named TArrayBuffer , though that type parameter has a default type argument so that we can continue to refer to Int32Array without explicitly writing out Int32Array<ArrayBufferLike> . If you encounter any issues as part of this update, you may need to update @types/node . This work was primarily provided thanks to Kenta Moriuchi! Searching Ancestor Configuration Files for Project Ownership When a TypeScript file is loaded in an editor using TSServer (like Visual Studio or VS Code), the editor will try to find the relevant tsconfig.json file that \u201cowns\u201d the file. To do this, it walks up the directory tree from the file being edited, looking for any file named tsconfig.json . Previously, this search would stop at the first tsconfig.json file found; however, imagine a project structure like the following: project/\u251c\u2500\u2500 src/\u2502 \u251c\u2500\u2500 foo.ts\u2502 \u251c\u2500\u2500 foo-test.ts\u2502 \u251c\u2500\u2500 tsconfig.json\u2502 \u2514\u2500\u2500 tsconfig.test.json\u2514\u2500\u2500 tsconfig.json Here, the idea is that src/tsconfig.json is the \u201cmain\u201d configuration file for the project, and src/tsconfig.test.json is a configuration file for running tests. json // src/tsconfig.json{\"compilerOptions\": {\"outDir\": \"../dist\"},\"exclude\": [\"**/*.test.ts\"]} json // src/tsconfig.test.json{\"compilerOptions\": {\"outDir\": \"../dist/test\"},\"include\": [\"**/*.test.ts\"],\"references\": [{ \"path\": \"./tsconfig.json\" }]} json // tsconfig.json{// This is a \"workspace-style\" or \"solution-style\" tsconfig.// Instead of specifying any files, it just references all the actual projects.\"files\": [],\"references\": [{ \"path\": \"./src/tsconfig.json\" },{ \"path\": \"./src/tsconfig.test.json\" },]} The problem here is that when editing foo-test.ts , the editor would find project/src/tsconfig.json as the \u201cowning\u201d configuration file - but that\u2019s not the one we want! If the walk stops at this point, that might not be desirable. The only way to avoid this previously was to rename src/tsconfig.json to something like src/tsconfig.src.json , and then all files would hit the top-level tsconfig.json which references every possible project. project/\u251c\u2500\u2500 src/\u2502 \u251c\u2500\u2500 foo.ts\u2502 \u251c\u2500\u2500 foo-test.ts\u2502 \u251c\u2500\u2500 tsconfig.src.json\u2502 \u2514\u2500\u2500 tsconfig.test.json\u2514\u2500\u2500 tsconfig.json Instead of forcing developers to do this, TypeScript 5.7 now continues walking up the directory tree to find other appropriate tsconfig.json files for editor scenarios. This can provide more flexibility in how projects are organized and how configuration files are structured. You can get more specifics on the implementation on GitHub here and here. Faster Project Ownership Checks in Editors for Composite Projects Imagine a large codebase with the following structure: packages\u251c\u2500\u2500 graphics/\u2502 \u251c\u2500\u2500 tsconfig.json\u2502 \u2514\u2500\u2500 src/\u2502 \u2514\u2500\u2500 ...\u251c\u2500\u2500 sound/\u2502 \u251c\u2500\u2500 tsconfig.json\u2502 \u2514\u2500\u2500 src/\u2502 \u2514\u2500\u2500 ...\u251c\u2500\u2500 networking/\u2502 \u251c\u2500\u2500 tsconfig.json\u2502 \u2514\u2500\u2500 src/\u2502 \u2514\u2500\u2500 ...\u251c\u2500\u2500 input/\u2502 \u251c\u2500\u2500 tsconfig.json\u2502 \u2514\u2500\u2500 src/\u2502 \u2514\u2500\u2500 ...\u2514\u2500\u2500 app/\u251c\u2500\u2500 tsconfig.json\u251c\u2500\u2500 some-script.js\u2514\u2500\u2500 src/\u2514\u2500\u2500 ... Each directory in packages is a separate TypeScript project, and the app directory is the main project that depends on all the other projects. json // app/tsconfig.json{\"compilerOptions\": {// ...},\"include\": [\"src\"],\"references\": [{ \"path\": \"../graphics/tsconfig.json\" },{ \"path\": \"../sound/tsconfig.json\" },{ \"path\": \"../networking/tsconfig.json\" },{ \"path\": \"../input/tsconfig.json\" }]} Now notice we have the file some-script.js in the app directory. When we open some-script.js in the editor, the TypeScript language service (which also handles the editor experience for JavaScript files!) has to figure out which project the file belongs to so it can apply the right settings. In this case, the nearest tsconfig.json does not include some-script.js , but TypeScript will proceed to ask \u201ccould one of the projects referenced by app/tsconfig.json include some-script.js ?\u201c. To do so, TypeScript would previously load up each project, one-by-one, and stop as soon as it found a project which contained some-script.js . Even if some-script.js isn\u2019t included in the root set of files, TypeScript would still parse all the files within a project because some of the root set of files can still transitively reference some-script.js . What we found over time was that this behavior caused extreme and unpredictable behavior in larger codebases. Developers would open up stray script files and find themselves waiting for their entire codebase to be opened up. Thankfully, every project that can be referenced by another (non-workspace) project must enable a flag called composite , which enforces a rule that all input source files must be known up-front. So when probing a composite project, TypeScript 5.7 will only check if a file belongs to the root set of files of that project. This should avoid this common worst-case behavior. For more information, see the change here. Validated JSON Imports in --module nodenext When importing from a .json file under --module nodenext , TypeScript will now enforce certain rules to prevent runtime errors. For one, an import attribute containing type: \"json\" needs to be present for any JSON file import. ts import myConfig from \"./myConfig.json\";// ~~~~~~~~~~~~~~~~~// \u274c error: Importing a JSON file into an ECMAScript module requires a 'type: \"json\"' import attribute when 'module' is set to 'NodeNext'.import myConfig from \"./myConfig.json\" with { type: \"json\" };// ^^^^^^^^^^^^^^^^// \u2705 This is fine because we provided `type: \"json\"` On top of this validation, TypeScript will not generate \u201cnamed\u201d exports, and the contents of a JSON import will only be accessible via a default. ts // \u2705 This is okay:import myConfigA from \"./myConfig.json\" with { type: \"json\" };let version = myConfigA.version;///////////import * as myConfigB from \"./myConfig.json\" with { type: \"json\" };// \u274c This is not:let version = myConfig.version;// \u2705 This is okay:let version = myConfig.default.version; See here for more information on this change. Support for V8 Compile Caching in Node.js Node.js 22 supports a new API called module.enableCompileCache() . This API allows the runtime to reuse some of the parsing and compilation work done after the first run of a tool. TypeScript 5.7 now leverages the API so that it can start doing useful work sooner. In some of our own testing, we\u2019ve witnessed about a 2.5x speed-up in running tsc --version . Benchmark 1: node ./built/local/_tsc.js --version (*without* caching)Time (mean \u00b1 \u03c3): 122.2 ms \u00b1 1.5 ms [User: 101.7 ms, System: 13.0 ms]Range (min \u2026 max): 119.3 ms \u2026 132.3 ms 200 runsBenchmark 2: node ./built/local/tsc.js --version (*with* caching)Time (mean \u00b1 \u03c3): 48.4 ms \u00b1 1.0 ms [User: 34.0 ms, System: 11.1 ms]Range (min \u2026 max): 45.7 ms \u2026 52.8 ms 200 runsSummarynode ./built/local/tsc.js --version ran2.52 \u00b1 0.06 times faster than node ./built/local/_tsc.js --version For more information, see the pull request here. Notable Behavioral Changes This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors. lib.d.ts Types generated for the DOM may have an impact on type-checking your codebase. For more information, see linked issues related to DOM and lib.d.ts updates for this version of TypeScript. TypedArray s Are Now Generic Over ArrayBufferLike In ECMAScript 2024, SharedArrayBuffer and ArrayBuffer have types that slightly diverge. To bridge the gap and preserve the underlying buffer type, all TypedArrays (like Uint8Array and others) are now also generic. ts interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {// ...} Each TypedArray now contains a type parameter named TArrayBuffer , though that type parameter has a default type argument so that users can continue to refer to Int32Array without explicitly writing out Int32Array<ArrayBufferLike> . If you encounter any issues as part of this update, such as error TS2322: Type 'Buffer' is not assignable to type 'Uint8Array<ArrayBufferLike>'.error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'Uint8Array<ArrayBufferLike>'.error TS2345: Argument of type 'ArrayBufferLike' is not assignable to parameter of type 'ArrayBuffer'.error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'string | ArrayBufferView | Stream | Iterable<string | ArrayBufferView> | AsyncIterable<string | ArrayBufferView>'. then you may need to update @types/node . You can read the specifics about this change on GitHub. Creating Index Signatures from Non-Literal Method Names in Classes TypeScript now has a more consistent behavior for methods in classes when they are declared with non-literal computed property names. For example, in the following: ts declare const symbolMethodName: symbol;export class A {[symbolMethodName]() { return 1 };} Previously TypeScript just viewed the class in a way like the following: ts export class A {} In other words, from the type system\u2019s perspective, [symbolMethodName] contributed nothing to the type of A TypeScript 5.7 now views the method [symbolMethodName]() {} more meaningfully, and generates an index signature. As a result, the code above is interpreted as something like the following code: ts export class A {[x: symbol]: () => number;} This provides behavior that is consistent with properties and methods in object literals. Read up more on this change here. More Implicit any Errors on Functions Returning null and undefined When a function expression is contextually typed by a signature returning a generic type, TypeScript now appropriately provides an implicit any error under noImplicitAny , but outside of strictNullChecks . ts declare var p: Promise<number>;const p2 = p.catch(() => null);// ~~~~~~~~~~// error TS7011: Function expression, which lacks return-type annotation, implicitly has an 'any' return type."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html", "title": "Documentation - TypeScript 5.8", "text": "Granular Checks for Branches in Return Expressions Consider some code like the following: ts declare const untypedCache: Map<any, any>;function getUrlObject(urlString: string): URL {return untypedCache.has(urlString) ?untypedCache.get(urlString) :urlString;} The intent of this code is to retrieve a URL object from a cache if it exists, or to create a new URL object if it doesn\u2019t. However, there\u2019s a bug: we forgot to actually construct a new URL object with the input. Unfortunately, TypeScript generally didn\u2019t catch this sort of bug. When TypeScript checks conditional expressions like cond ? trueBranch : falseBranch , its type is treated as a union of the types of the two branches. In other words, it gets the type of trueBranch and falseBranch , and combines them into a union type. In this case, the type of untypedCache.get(urlString) is any , and the type of urlString is string . This is where things go wrong because any is so infectious in how it interacts with other types. The union any | string is simplified to any , so by the time TypeScript starts checking whether the expression in our return statement is compatible with the expected return type of URL , the type system has lost any information that would have caught the bug in this code. In TypeScript 5.8, the type system special-cases conditional expressions directly inside return statements. Each branch of the conditional is checked against the declared return type of the containing functions (if one exists), so the type system can catch the bug in the example above. ts declare const untypedCache: Map<any, any>;function getUrlObject(urlString: string): URL {return untypedCache.has(urlString) ?untypedCache.get(urlString) :urlString;// ~~~~~~~~~// error! Type 'string' is not assignable to type 'URL'.} This change was made within this pull request, as part of a broader set of future improvements for TypeScript. Support for require() of ECMAScript Modules in --module nodenext For years, Node.js supported ECMAScript modules (ESM) alongside CommonJS modules. Unfortunately, the interoperability between the two had some challenges. - ESM files could import CommonJS files - CommonJS files could not require() ESM files In other words, consuming CommonJS files from ESM files was possible, but not the other way around. This introduced many challenges for library authors who wanted to provide ESM support. These library authors would either have to break compatibility with CommonJS users, \u201cdual-publish\u201d their libraries (providing separate entry-points for ESM and CommonJS), or just stay on CommonJS indefinitely. While dual-publishing might sound like a good middle-ground, it is a complex and error-prone process that also roughly doubles the amount of code within a package. Node.js 22 relaxes some of these restrictions and permits require(\"esm\") calls from CommonJS modules to ECMAScript modules. Node.js still does not permit require() on ESM files that contain a top-level await , but most other ESM files are now consumable from CommonJS files. This presents a major opportunity for library authors to provide ESM support without having to dual-publish their libraries. TypeScript 5.8 supports this behavior under the --module nodenext flag. When --module nodenext is enabled, TypeScript will avoid issuing errors on these require() calls to ESM files. Because this feature may be back-ported to older versions of Node.js, there is currently no stable --module nodeXXXX option that enables this behavior; however, we predict future versions of TypeScript may be able to stabilize the feature under node20 . In the meantime, we encourage users of Node.js 22 and newer to use --module nodenext , while library authors and users of older Node.js versions should remain on --module node16 (or make the minor update to --module node18 ). For more information, see our support for require(\u201cesm\u201d) here. --module node18 TypeScript 5.8 introduces a stable --module node18 flag. For users who are fixed on using Node.js 18, this flag provides a stable point of reference that does not incorporate certain behaviors that are in --module nodenext . Specifically: require() of ECMAScript modules is disallowed undernode18 , but allowed undernodenext - import assertions (deprecated in favor of import attributes) are allowed under node18 , but are disallowed undernodenext See more at both the --module node18 pull request and changes made to --module nodenext . The --erasableSyntaxOnly Option Recently, Node.js 23.6 unflagged experimental support for running TypeScript files directly; however, only certain constructs are supported under this mode. Node.js has unflagged a mode called --experimental-strip-types which requires that any TypeScript-specific syntax cannot have runtime semantics. Phrased differently, it must be possible to easily erase or \u201cstrip out\u201d any TypeScript-specific syntax from a file, leaving behind a valid JavaScript file. That means constructs like the following are not supported: enum declarationsnamespace s andmodule s with runtime code- parameter properties in classes - Non-ECMAScript import = andexport = assignments Here are some examples of what does not work: ts // \u274c error: An `import ... = require(...)` aliasimport foo = require(\"foo\");// \u274c error: A namespace with runtime code.namespace container {}// \u274c error: An `import =` aliasimport Bar = container.Bar;class Point {// \u274c error: Parameter propertiesconstructor(public x: number, public y: number) { }}// \u274c error: An `export =` assignment.export = Point;// \u274c error: An enum declaration.enum Direction {Up,Down,Left,Right,} Similar tools like ts-blank-space or Amaro (the underlying library for type-stripping in Node.js) have the same limitations. These tools will provide helpful error messages if they encounter code that doesn\u2019t meet these requirements, but you still won\u2019t find out your code doesn\u2019t work until you actually try to run it. That\u2019s why TypeScript 5.8 introduces the --erasableSyntaxOnly flag. When this flag is enabled, TypeScript will error on most TypeScript-specific constructs that have runtime behavior. ts class C {constructor(public x: number) { }// ~~~~~~~~~~~~~~~~// error! This syntax is not allowed when 'erasableSyntaxOnly' is enabled.}} Typically, you will want to combine this flag with the --verbatimModuleSyntax , which ensures that a module contains the appropriate import syntax, and that import elision does not take place. For more information, see the implementation here. The --libReplacement Flag In TypeScript 4.5, we introduced the possibility of substituting the default lib files with custom ones. This was based on the possibility of resolving a library file from packages named @typescript/lib-* . For example, you could lock your dom libraries onto a specific version of the @types/web package with the following package.json : json {\"devDependencies\": {\"@typescript/lib-dom\": \"npm:@types/web@0.0.199\"}} When installed, a package called @typescript/lib-dom should exist, and TypeScript will currently always look it up when dom is implied by your settings. This is a powerful feature, but it also incurs a bit of extra work. Even if you\u2019re not using this feature, TypeScript always performs this lookup, and has to watch for changes in node_modules in case a lib -replacement package begins to exist. TypeScript 5.8 introduces the --libReplacement flag, which allows you to disable this behavior. If you\u2019re not using --libReplacement , you can now disable it with --libReplacement false . In the future --libReplacement false may become the default, so if you currently rely on the behavior you should consider explicitly enabling it with --libReplacement true . For more information, see the change here. Preserved Computed Property Names in Declaration Files In an effort to make computed properties have more predictable emit in declaration files, TypeScript 5.8 will consistently preserve entity names (bareVariables and dotted.names.that.look.like.this ) in computed property names in classes. For example, consider the following code: ts export let propName = \"theAnswer\";export class MyClass {[propName] = 42;// ~~~~~~~~~~// error!// A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type.} Previous versions of TypeScript would issue an error when generating a declaration file for this module, and a best-effort declaration file would generate an index signature. ts export declare let propName: string;export declare class MyClass {[x: string]: number;} In TypeScript 5.8, the example code is now allowed, and the emitted declaration file will match what you wrote: ts export declare let propName: string;export declare class MyClass {[propName]: number;} Note that this does not create statically-named properties on the class. You\u2019ll still end up with what is effectively an index signature like [x: string]: number , so for that use case, you\u2019d need to use unique symbol s or literal types. Note that writing this code was and currently is an error under the --isolatedDeclarations flag; but we expect that thanks to this change, computed property names will generally be permitted in declaration emit. Note that it\u2019s possible (though unlikely) that a file compiled in TypeScript 5.8 may generate a declaration file that is not backward compatible in TypeScript 5.7 or earlier. For more information, see the implementing PR. Optimizations on Program Loads and Updates TypeScript 5.8 introduces a number of optimizations that can both improve the time to build up a program, and also to update a program based on a file change in either --watch mode or editor scenarios. First, TypeScript now avoids array allocations that would be involved while normalizing paths. Typically, path normalization would involve segmenting each portion of a path into an array of strings, normalizing the resulting path based on relative segments, and then joining them back together using a canonical separator. For projects with many files, this can be a significant and repetitive amount of work. TypeScript now avoids allocating an array, and operates more directly on indexes of the original path. Additionally, when edits are made that don\u2019t change the fundamental structure of a project, TypeScript now avoids re-validating the options provided to it (e.g. the contents of a tsconfig.json ). This means, for example, that a simple edit might not require checking that the output paths of a project don\u2019t conflict with the input paths. Instead, the results of the last check can be used. This should make edits in large projects feel more responsive. Notable Behavioral Changes This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors. lib.d.ts Types generated for the DOM may have an impact on type-checking your codebase. For more information, see linked issues related to DOM and lib.d.ts updates for this version of TypeScript. Restrictions on Import Assertions Under --module nodenext Import assertions were a proposed addition to ECMAScript to ensure certain properties of an import (e.g. \u201cthis module is JSON, and is not intended to be executable JavaScript code\u201d). They were reinvented as a proposal called import attributes. As part of the transition, they swapped from using the assert keyword to using the with keyword. ts // An import assertion \u274c - not future-compatible with most runtimes.import data from \"./data.json\" assert { type: \"json\" };// An import attribute \u2705 - the preferred way to import a JSON file.import data from \"./data.json\" with { type: \"json\" }; Node.js 22 no longer accepts import assertions using the assert syntax. In turn when --module nodenext is enabled in TypeScript 5.8, TypeScript will issue an error if it encounters an import assertion. ts import data from \"./data.json\" assert { type: \"json\" };// ~~~~~~// error! Import assertions have been replaced by import attributes. Use 'with' instead of 'assert' For more information, see the change here"}]