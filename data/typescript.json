{
    "name": "https://www.typescriptlang.org",
    "url": "https://https://www.typescriptlang.org",
    "pages": [
        {
            "url": "https://www.typescriptlang.org/docs",
            "title": "TypeScript: The starting point for learning TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Quick introductions based on your background or preference."
                },
                {
                    "type": "list",
                    "items": [
                        "TS for the New Programmer",
                        "TypeScript for JS Programmers",
                        "TS for Java/C# Programmers",
                        "TS for Functional Programmers",
                        "TypeScript Tooling in 5 minutes"
                    ]
                },
                {
                    "type": "p",
                    "text": "A great first read for your daily TS work."
                },
                {
                    "type": "list",
                    "items": [
                        "The TypeScript Handbook",
                        "The Basics",
                        "Everyday Types",
                        "Narrowing",
                        "More on Functions",
                        "Object Types",
                        "Type Manipulation",
                        "Creating Types from Types Generics Keyof Type Operator Typeof Type Operator Indexed Access Types Conditional Types Mapped Types Template Literal Types",
                        "Creating Types from Types",
                        "Generics",
                        "Keyof Type Operator",
                        "Typeof Type Operator",
                        "Indexed Access Types",
                        "Conditional Types",
                        "Mapped Types",
                        "Template Literal Types",
                        "Classes",
                        "Modules"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Utility Types",
                        "Cheat Sheets",
                        "Decorators",
                        "Declaration Merging",
                        "Enums",
                        "Iterators and Generators",
                        "JSX",
                        "Mixins",
                        "Namespaces",
                        "Namespaces and Modules",
                        "Symbols",
                        "Triple-Slash Directives",
                        "Type Compatibility",
                        "Type Inference",
                        "Variable Declaration"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Theory",
                        "Guides",
                        "Choosing Compiler Options",
                        "Choosing Compiler Options",
                        "Reference",
                        "Appendices",
                        "ESM/CJS Interoperability",
                        "ESM/CJS Interoperability"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET Core",
                        "Gulp",
                        "DOM Manipulation",
                        "Migrating from JavaScript",
                        "Using Babel with TypeScript"
                    ]
                },
                {
                    "type": "p",
                    "text": "Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions."
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Declaration Reference",
                        "Library Structures",
                        ".d.ts Templates",
                        "Modules .d.ts Module: Plugin Module: Class Module: Function Global .d.ts Global: Modifying Module",
                        "Modules .d.ts",
                        "Module: Plugin",
                        "Module: Class",
                        "Module: Function",
                        "Global .d.ts",
                        "Global: Modifying Module",
                        "Do's and Don'ts",
                        "Deep Dive",
                        "Publishing",
                        "Consumption"
                    ]
                },
                {
                    "type": "p",
                    "text": "How to use TypeScript-powered JavaScript tooling."
                },
                {
                    "type": "list",
                    "items": [
                        "JS Projects Utilizing TypeScript",
                        "Type Checking JavaScript Files",
                        "JSDoc Reference",
                        "Creating .d.ts Files from .js files"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "What is a tsconfig.json",
                        "Compiler Options in MSBuild",
                        "TSConfig Reference",
                        "tsc CLI Options",
                        "Project References",
                        "Integrating with Build Tools",
                        "Configuring Watch",
                        "Nightly Builds"
                    ]
                },
                {
                    "type": "p",
                    "text": "Downloadable syntax reference pages for different parts of everyday TypeScript code."
                },
                {
                    "type": "list",
                    "items": [
                        "Control Flow Analysis",
                        "Classes",
                        "Interfaces",
                        "Types",
                        "Download PDFs and PNGs"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "JS to TS",
                        "New to Programming",
                        "OOP to JS",
                        "Functional to JS",
                        "Installation"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Everyday Types",
                        "Creating Types from Types",
                        "Object Types",
                        "Variable Declarations",
                        "More on Functions"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Playground",
                        "TSConfig Reference"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET",
                        "Migrating from JS",
                        "Working with the DOM",
                        "React & Webpack"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/basic-types.html",
            "title": "TypeScript: Documentation - The Basics",
            "content": [
                {
                    "type": "p",
                    "text": "Welcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ' Getting Started ' guides Each and every value in JavaScript has a set of behaviors you can observe from running different operations.\nThat sounds abstract, but as a quick example, consider some operations we might run on a variable named message ."
                },
                {
                    "type": "code",
                    "code": "js // Accessing the property 'toLowerCase' // on 'message' and then calling it message . toLowerCase (); // Calling 'message' message ();"
                },
                {
                    "type": "p",
                    "text": "If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it.\nThe second one tries to call message directly. But assuming we don’t know the value of message - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code.\nThe behavior of each operation depends entirely on what value we had in the first place."
                },
                {
                    "type": "list",
                    "items": [
                        "Is message callable?",
                        "Does it have a property called toLowerCase on it?",
                        "If it does, is toLowerCase even callable?",
                        "If both of these values are callable, what do they return?"
                    ]
                },
                {
                    "type": "p",
                    "text": "The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right. Let’s say message was defined in the following way."
                },
                {
                    "type": "code",
                    "code": "js const message = \"Hello World!\" ;"
                },
                {
                    "type": "p",
                    "text": "As you can probably guess, if we try to run message.toLowerCase() , we’ll get the same string only in lower-case. What about that second line of code?\nIf you’re familiar with JavaScript, you’ll know this fails with an exception:"
                },
                {
                    "type": "code",
                    "code": "txt TypeError: message is not a function"
                },
                {
                    "type": "p",
                    "text": "It’d be great if we could avoid mistakes like this. When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has.\nThat’s part of what that TypeError is alluding to - it’s saying that the string \"Hello World!\" cannot be called as a function. For some values, such as the primitives string and number , we can identify their type at runtime using the typeof operator.\nBut for other things like functions, there’s no corresponding runtime mechanism to identify their types.\nFor example, consider this function:"
                },
                {
                    "type": "code",
                    "code": "js function fn ( x ) { return x . flip (); }"
                },
                {
                    "type": "p",
                    "text": "We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesn’t surface this information in a way that we can check while the code is running.\nThe only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens.\nThis kind of behavior makes it hard to predict what the code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it. Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash.\nJavaScript only truly provides dynamic typing - running the code to see what happens. The alternative is to use a static type system to make predictions about what the code is expected to do before it runs. Think back to that TypeError we got earlier from trying to call a string as a function. Most people don’t like to get any sorts of errors when running their code - those are considered bugs!\nAnd when we write new code, we try our best to avoid introducing new bugs. If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case.\nWe might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown!\nOr if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through. Ideally, we could have a tool that helps us find these bugs before our code runs.\nThat’s what a static type-checker like TypeScript does. Static types systems describe the shapes and behaviors of what our values will be when we run our programs.\nA type-checker like TypeScript uses that information and tells us when things might be going off the rails."
                },
                {
                    "type": "code",
                    "code": "ts const message = \"hello!\" ; message (); This expression is not callable.\n  Type 'String' has no call signatures. 2349 This expression is not callable.\n  Type 'String' has no call signatures. Try"
                },
                {
                    "type": "p",
                    "text": "Running that last sample with TypeScript will give us an error message before we run the code in the first place. So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical.\nThose cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected. For example, the specification says that trying to call something that isn’t callable should throw an error.\nMaybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too.\nInstead, JavaScript gives us different behavior and returns the value undefined :"
                },
                {
                    "type": "code",
                    "code": "js const user = { name: \"Daniel\" , age: 26 , }; user . location ; // returns undefined"
                },
                {
                    "type": "p",
                    "text": "Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error.\nIn TypeScript, the following code produces an error about location not being defined:"
                },
                {
                    "type": "code",
                    "code": "ts const user = { name : \"Daniel\" , age : 26 , }; user . location ; Property 'location' does not exist on type '{ name: string; age: number; }'. 2339 Property 'location' does not exist on type '{ name: string; age: number; }'. Try"
                },
                {
                    "type": "p",
                    "text": "While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs.\nAnd TypeScript catches a lot of legitimate bugs."
                },
                {
                    "type": "code",
                    "code": "ts const announcement = \"Hello World!\" ; // How quickly can you spot the typos? announcement . toLocaleLowercase (); announcement . toLocalLowerCase (); // We probably meant to write this... announcement . toLocaleLowerCase (); Try"
                },
                {
                    "type": "code",
                    "code": "ts function flipCoin () { // Meant to be Math.random() return Math . random < 0.5 ; Operator '<' cannot be applied to types '() => number' and 'number'. 2365 Operator '<' cannot be applied to types '() => number' and 'number'. } Try"
                },
                {
                    "type": "code",
                    "code": "ts const value = Math . random () < 0.5 ? \"a\" : \"b\" ; if ( value !== \"a\" ) { // ... } else if ( value === \"b\" ) { This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap. 2367 This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap. // Oops, unreachable } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript can catch bugs when we make mistakes in our code.\nThat’s great, but TypeScript can also prevent us from making those mistakes in the first place. The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties.\nOnce it has that information, it can also start suggesting which properties you might want to use. That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor.\nThat’s part of what people often refer to when they talk about tooling in TypeScript."
                },
                {
                    "type": "code",
                    "code": "ts import express from \"express\" ; const app = express (); app . get ( \"/\" , function ( req , res ) { res . sen sen d sen dDate sen dfile sen dFile sen dStatus }); app . listen ( 3000 ); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript takes tooling seriously, and that goes beyond completions and errors as you type.\nAn editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable.\nAll of this is built on top of the type-checker and is fully cross-platform, so it’s likely that your favorite editor has TypeScript support available . We’ve been talking about type-checking, but we haven’t yet used our type- checker .\nLet’s get acquainted with our new friend tsc , the TypeScript compiler.\nFirst we’ll need to grab it via npm."
                },
                {
                    "type": "code",
                    "code": "sh npm install -g typescript"
                },
                {
                    "type": "p",
                    "text": "This installs the TypeScript Compiler tsc globally.\nYou can use npx or similar tools if you’d prefer to run tsc from a local node_modules package instead. Now let’s move to an empty folder and try writing our first TypeScript program: hello.ts :"
                },
                {
                    "type": "code",
                    "code": "ts // Greets the world. console . log ( \"Hello world!\" ); Try"
                },
                {
                    "type": "p",
                    "text": "Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript.\nAnd now let’s type-check it by running the command tsc which was installed for us by the typescript package."
                },
                {
                    "type": "code",
                    "code": "sh tsc hello.ts"
                },
                {
                    "type": "p",
                    "text": "Wait, “tada” what exactly?\nWe ran tsc and nothing happened!\nWell, there were no type errors, so we didn’t get any output in our console since there was nothing to report. But check again - we got some file output instead.\nIf we look in our current directory, we’ll see a hello.js file next to hello.ts .\nThat’s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file.\nAnd if we check the contents, we’ll see what TypeScript spits out after it processes a .ts file:"
                },
                {
                    "type": "code",
                    "code": "js // Greets the world. console . log ( \"Hello world!\" );"
                },
                {
                    "type": "p",
                    "text": "In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote.\nThe compiler tries to emit clean readable code that looks like something a person would write.\nWhile that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around. What about if we did introduce a type-checking error?\nLet’s rewrite hello.ts :"
                },
                {
                    "type": "code",
                    "code": "ts // This is an industrial-grade general-purpose greeter function: function greet ( person , date ) { console . log ( `Hello ${ person } , today is ${ date } !` ); } greet ( \"Brendan\" ); Try"
                },
                {
                    "type": "p",
                    "text": "If we run tsc hello.ts again, notice that we get an error on the command line!"
                },
                {
                    "type": "code",
                    "code": "txt Expected 2 arguments, but got 1."
                },
                {
                    "type": "p",
                    "text": "TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so.\nSo far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code.\nThanks TypeScript! One thing you might not have noticed from the last example was that our hello.js file changed again.\nIf we open that file up then we’ll see that the contents still basically look the same as our input file.\nThat might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know better than TypeScript. To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable.\nMost of the time that’s okay, but there are scenarios where those checks get in the way.\nFor example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors.\nEventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working!\nWhy should converting it over to TypeScript stop you from running it? So TypeScript doesn’t get in your way.\nOf course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly.\nIn that case, you can use the noEmitOnError compiler option.\nTry changing your hello.ts file and running tsc with that flag:"
                },
                {
                    "type": "code",
                    "code": "sh tsc --noEmitOnError hello.ts"
                },
                {
                    "type": "p",
                    "text": "You’ll notice that hello.js never gets updated. Up until now, we haven’t told TypeScript what person or date are.\nLet’s edit the code to tell TypeScript that person is a string , and that date should be a Date object.\nWe’ll also use the toDateString() method on date ."
                },
                {
                    "type": "code",
                    "code": "ts function greet ( person : string , date : Date ) { console . log ( `Hello ${ person } , today is ${ date . toDateString () } !` ); } Try"
                },
                {
                    "type": "p",
                    "text": "What we did was add type annotations on person and date to describe what types of values greet can be called with.\nYou can read that signature as ” greet takes a person of type string , and a date of type Date “. With this, TypeScript can tell us about other cases where greet might have been called incorrectly.\nFor example…"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( person : string , date : Date ) { console . log ( `Hello ${ person } , today is ${ date . toDateString () } !` ); } greet ( \"Maddison\" , Date ()); Argument of type 'string' is not assignable to parameter of type 'Date'. 2345 Argument of type 'string' is not assignable to parameter of type 'Date'. Try"
                },
                {
                    "type": "p",
                    "text": "Huh?\nTypeScript reported an error on our second argument, but why? Perhaps surprisingly, calling Date() in JavaScript returns a string .\nOn the other hand, constructing a Date with new Date() actually gives us what we were expecting. Anyway, we can quickly fix up the error:"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( person : string , date : Date ) { console . log ( `Hello ${ person } , today is ${ date . toDateString () } !` ); } greet ( \"Maddison\" , new Date ()); Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind, we don’t always have to write explicit type annotations.\nIn many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them."
                },
                {
                    "type": "code",
                    "code": "ts let msg = \"hello there!\" ; let msg: string Try"
                },
                {
                    "type": "p",
                    "text": "Even though we didn’t tell TypeScript that msg had the type string it was able to figure that out.\nThat’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway. Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word. Let’s take a look at what happens when we compile the above function greet with tsc to output JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts \"use strict\" ; function greet ( person , date ) { console . log ( \"Hello \" . concat ( person , \", today is \" ). concat ( date . toDateString (), \"!\" )); } greet ( \"Maddison\" , new Date ()); Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Our person and date parameters no longer have type annotations.",
                        "Our “template string” - that string that used backticks (the ` character) - was converted to plain strings with concatenations."
                    ]
                },
                {
                    "type": "p",
                    "text": "More on that second point later, but let’s now focus on that first point.\nType annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified.\nThat’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it.\nMost TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased. Remember : Type annotations never change the runtime behavior of your program. One other difference from the above was that our template string was rewritten from"
                },
                {
                    "type": "code",
                    "code": "js `Hello ${ person } , today is ${ date . toDateString () } !` ;"
                },
                {
                    "type": "code",
                    "code": "js \"Hello \" . concat ( person , \", today is \" ). concat ( date . toDateString (), \"!\" );"
                },
                {
                    "type": "p",
                    "text": "Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - don’t ask ).\nTypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5).\nThis process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling . By default TypeScript targets ES5, an extremely old version of ECMAScript.\nWe could have chosen something a little bit more recent by using the target option.\nRunning with --target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported.\nSo running tsc --target es2015 hello.ts gives us the following output:"
                },
                {
                    "type": "code",
                    "code": "js function greet ( person , date ) { console . log ( `Hello ${ person } , today is ${ date . toDateString () } !` ); } greet ( \"Maddison\" , new Date ());"
                },
                {
                    "type": "p",
                    "text": "While the default target is ES5, the great majority of current browsers support ES2015.\nMost developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important. Different users come to TypeScript looking for different things in a type-checker.\nSome people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling.\nThis is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially null / undefined values.\nMuch like how tsc emits in the face of errors, these defaults are put in place to stay out of your way.\nIf you’re migrating existing JavaScript, that might be a desirable first step. In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well.\nThese strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial.\nThe further you turn this dial up, the more TypeScript will check for you.\nThis can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling.\nWhen possible, a new codebase should always turn these strictness checks on. TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated.\nThe strict flag in the CLI, or \"strict\": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually.\nThe two biggest ones you should know about are noImplicitAny and strictNullChecks . Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: any .\nThis isn’t the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway. However, using any often defeats the purpose of using TypeScript in the first place.\nThe more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code.\nTurning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any . By default, values like null and undefined are assignable to any other type.\nThis can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it a billion dollar mistake !\nThe strictNullChecks flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined . Your first step to learn TypeScript The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
            "title": "TypeScript: Documentation - Classes",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript offers full support for the class keyword introduced in ES2015. As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types. Here’s the most basic class - an empty one:"
                },
                {
                    "type": "code",
                    "code": "ts class Point {} Try"
                },
                {
                    "type": "p",
                    "text": "This class isn’t very useful yet, so let’s start adding some members. A field declaration creates a public writeable property on a class:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { x : number ; y : number ; } const pt = new Point (); pt . x = 0 ; pt . y = 0 ; Try"
                },
                {
                    "type": "p",
                    "text": "As with other locations, the type annotation is optional, but will be an implicit any if not specified. Fields can also have initializers ; these will run automatically when the class is instantiated:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { x = 0 ; y = 0 ; } const pt = new Point (); // Prints 0, 0 console . log ( ` ${ pt . x } , ${ pt . y } ` ); Try"
                },
                {
                    "type": "p",
                    "text": "Just like with const , let , and var , the initializer of a class property will be used to infer its type:"
                },
                {
                    "type": "code",
                    "code": "ts const pt = new Point (); pt . x = \"0\" ; Type 'string' is not assignable to type 'number'. 2322 Type 'string' is not assignable to type 'number'. Try"
                },
                {
                    "type": "p",
                    "text": "The strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor."
                },
                {
                    "type": "code",
                    "code": "ts class BadGreeter { name : string ; Property 'name' has no initializer and is not definitely assigned in the constructor. 2564 Property 'name' has no initializer and is not definitely assigned in the constructor. } Try"
                },
                {
                    "type": "code",
                    "code": "ts class GoodGreeter { name : string ; constructor () { this . name = \"hello\" ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Note that the field needs to be initialized in the constructor itself .\r\nTypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members. If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator , ! :"
                },
                {
                    "type": "code",
                    "code": "ts class OKGreeter { // Not initialized, but no error name !: string ; } Try"
                },
                {
                    "type": "p",
                    "text": "Fields may be prefixed with the readonly modifier.\r\nThis prevents assignments to the field outside of the constructor."
                },
                {
                    "type": "code",
                    "code": "ts class Greeter { readonly name : string = \"world\" ; constructor ( otherName ?: string ) { if ( otherName !== undefined ) { this . name = otherName ; } } err () { this . name = \"not ok\" ; Cannot assign to 'name' because it is a read-only property. 2540 Cannot assign to 'name' because it is a read-only property. } } const g = new Greeter (); g . name = \"also not ok\" ; Cannot assign to 'name' because it is a read-only property. 2540 Cannot assign to 'name' because it is a read-only property. Try"
                },
                {
                    "type": "p",
                    "text": "Class constructors are very similar to functions.\r\nYou can add parameters with type annotations, default values, and overloads:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { x : number ; y : number ; // Normal signature with defaults constructor ( x = 0 , y = 0 ) { this . x = x ; this . y = y ; } } Try"
                },
                {
                    "type": "code",
                    "code": "ts class Point { x : number = 0 ; y : number = 0 ; // Constructor overloads constructor ( x : number , y : number ); constructor ( xy : string ); constructor ( x : string | number , y : number = 0 ) { // Code logic here } } Try"
                },
                {
                    "type": "p",
                    "text": "There are just a few differences between class constructor signatures and function signatures:"
                },
                {
                    "type": "list",
                    "items": [
                        "Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later",
                        "Constructors can’t have return type annotations - the class instance type is always what’s returned"
                    ]
                },
                {
                    "type": "p",
                    "text": "Just as in JavaScript, if you have a base class, you’ll need to call super(); in your constructor body before using any this. members:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { k = 4 ; } class Derived extends Base { constructor () { // Prints a wrong value in ES5; throws exception in ES6 console . log ( this . k ); 'super' must be called before accessing 'this' in the constructor of a derived class. 17009 'super' must be called before accessing 'this' in the constructor of a derived class. super (); } } Try"
                },
                {
                    "type": "p",
                    "text": "Forgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary. A function property on a class is called a method .\r\nMethods can use all the same type annotations as functions and constructors:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { x = 10 ; y = 10 ; scale ( n : number ): void { this . x *= n ; this . y *= n ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Other than the standard type annotations, TypeScript doesn’t add anything else new to methods. Note that inside a method body, it is still mandatory to access fields and other methods via this. .\r\nAn unqualified name in a method body will always refer to something in the enclosing scope:"
                },
                {
                    "type": "code",
                    "code": "ts let x : number = 0 ; class C { x : string = \"hello\" ; m () { // This is trying to modify 'x' from line 1, not the class property x = \"world\" ; Type 'string' is not assignable to type 'number'. 2322 Type 'string' is not assignable to type 'number'. } } Try"
                },
                {
                    "type": "p",
                    "text": "Classes can also have accessors :"
                },
                {
                    "type": "code",
                    "code": "ts class C { _length = 0 ; get length () { return this . _length ; } set length ( value ) { this . _length = value ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript.\r\nIt’s fine to expose public fields if you don’t need to add additional logic during the get/set operations. TypeScript has some special inference rules for accessors:"
                },
                {
                    "type": "list",
                    "items": [
                        "If get exists but no set , the property is automatically readonly",
                        "If the type of the setter parameter is not specified, it is inferred from the return type of the getter"
                    ]
                },
                {
                    "type": "p",
                    "text": "Since TypeScript 4.3 , it is possible to have accessors with different types for getting and setting."
                },
                {
                    "type": "code",
                    "code": "ts class Thing { _size = 0 ; get size (): number { return this . _size ; } set size ( value : string | number | boolean ) { let num = Number ( value ); // Don't allow NaN, Infinity, etc if (! Number . isFinite ( num )) { this . _size = 0 ; return ; } this . _size = num ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Classes can declare index signatures; these work the same as Index Signatures for other object types :"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { [ s : string ]: boolean | (( s : string ) => boolean ); check ( s : string ) { return this [ s ] as boolean ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Because the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types.\r\nGenerally it’s better to store indexed data in another place instead of on the class instance itself. Like other languages with object-oriented features, classes in JavaScript can inherit from base classes. You can use an implements clause to check that a class satisfies a particular interface .\r\nAn error will be issued if a class fails to correctly implement it:"
                },
                {
                    "type": "code",
                    "code": "ts interface Pingable { ping (): void ; } class Sonar implements Pingable { ping () { console . log ( \"ping!\" ); } } class Ball implements Pingable { Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'. 2420 Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'. pong () { console . log ( \"pong!\" ); } } Try"
                },
                {
                    "type": "p",
                    "text": "Classes may also implement multiple interfaces, e.g. class C implements A, B { . It’s important to understand that an implements clause is only a check that the class can be treated as the interface type.\r\nIt doesn’t change the type of the class or its methods at all .\r\nA common source of error is to assume that an implements clause will change the class type - it doesn’t!"
                },
                {
                    "type": "code",
                    "code": "ts interface Checkable { check ( name : string ): boolean ; } class NameChecker implements Checkable { check ( s ) { Parameter 's' implicitly has an 'any' type. 7006 Parameter 's' implicitly has an 'any' type. // Notice no error here return s . toLowerCase () === \"ok\" ; any } } Try"
                },
                {
                    "type": "p",
                    "text": "In this example, we perhaps expected that s ’s type would be influenced by the name: string parameter of check .\r\nIt is not - implements clauses don’t change how the class body is checked or its type inferred. Similarly, implementing an interface with an optional property doesn’t create that property:"
                },
                {
                    "type": "code",
                    "code": "ts interface A { x : number ; y ?: number ; } class C implements A { x = 0 ; } const c = new C (); c . y = 10 ; Property 'y' does not exist on type 'C'. 2339 Property 'y' does not exist on type 'C'. Try"
                },
                {
                    "type": "p",
                    "text": "Classes may extend from a base class.\r\nA derived class has all the properties and methods of its base class, and can also define additional members."
                },
                {
                    "type": "code",
                    "code": "ts class Animal { move () { console . log ( \"Moving along!\" ); } } class Dog extends Animal { woof ( times : number ) { for ( let i = 0 ; i < times ; i ++) { console . log ( \"woof!\" ); } } } const d = new Dog (); // Base class method d . move (); // Derived class method d . woof ( 3 ); Try"
                },
                {
                    "type": "p",
                    "text": "A derived class can also override a base class field or property.\r\nYou can use the super. syntax to access base class methods.\r\nNote that because JavaScript classes are a simple lookup object, there is no notion of a “super field”. TypeScript enforces that a derived class is always a subtype of its base class. For example, here’s a legal way to override a method:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { greet () { console . log ( \"Hello, world!\" ); } } class Derived extends Base { greet ( name ?: string ) { if ( name === undefined ) { super . greet (); } else { console . log ( `Hello, ${ name . toUpperCase () } ` ); } } } const d = new Derived (); d . greet (); d . greet ( \"reader\" ); Try"
                },
                {
                    "type": "p",
                    "text": "It’s important that a derived class follow its base class contract.\r\nRemember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:"
                },
                {
                    "type": "code",
                    "code": "ts // Alias the derived instance through a base class reference const b : Base = d ; // No problem b . greet (); Try"
                },
                {
                    "type": "p",
                    "text": "What if Derived didn’t follow Base ’s contract?"
                },
                {
                    "type": "code",
                    "code": "ts class Base { greet () { console . log ( \"Hello, world!\" ); } } class Derived extends Base { // Make this parameter required greet ( name : string ) { Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0. 2416 Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0. console . log ( `Hello, ${ name . toUpperCase () } ` ); } } Try"
                },
                {
                    "type": "p",
                    "text": "If we compiled this code despite the error, this sample would then crash:"
                },
                {
                    "type": "code",
                    "code": "ts const b : Base = new Derived (); // Crashes because \"name\" will be undefined b . greet (); Try"
                },
                {
                    "type": "p",
                    "text": "When target >= ES2022 or useDefineForClassFields is true , class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration."
                },
                {
                    "type": "code",
                    "code": "ts interface Animal { dateOfBirth : any ; } interface Dog extends Animal { breed : any ; } class AnimalHouse { resident : Animal ; constructor ( animal : Animal ) { this . resident = animal ; } } class DogHouse extends AnimalHouse { // Does not emit JavaScript code, // only ensures the types are correct declare resident : Dog ; constructor ( dog : Dog ) { super ( dog ); } } Try"
                },
                {
                    "type": "p",
                    "text": "The order that JavaScript classes initialize can be surprising in some cases.\r\nLet’s consider this code:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { name = \"base\" ; constructor () { console . log ( \"My name is \" + this . name ); } } class Derived extends Base { name = \"derived\" ; } // Prints \"base\", not \"derived\" const d = new Derived (); Try"
                },
                {
                    "type": "p",
                    "text": "The order of class initialization, as defined by JavaScript, is:"
                },
                {
                    "type": "list",
                    "items": [
                        "The base class fields are initialized",
                        "The base class constructor runs",
                        "The derived class fields are initialized",
                        "The derived class constructor runs"
                    ]
                },
                {
                    "type": "p",
                    "text": "This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadn’t run yet. Note: If you don’t plan to inherit from built-in types like Array , Error , Map , etc. or your compilation target is explicitly set to ES6 / ES2015 or above, you may skip this section In ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(...) .\r\nIt is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this . As a result, subclassing Error , Array , and others may no longer work as expected.\r\nThis is due to the fact that constructor functions for Error , Array , and the like use ECMAScript 6’s new.target to adjust the prototype chain;\r\nhowever, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5.\r\nOther downlevel compilers generally have the same limitation by default. For a subclass like the following:"
                },
                {
                    "type": "code",
                    "code": "ts class MsgError extends Error { constructor ( m : string ) { super ( m ); } sayHello () { return \"hello \" + this . message ; } } Try"
                },
                {
                    "type": "list",
                    "items": [
                        "methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error.",
                        "instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false ."
                    ]
                },
                {
                    "type": "p",
                    "text": "As a recommendation, you can manually adjust the prototype immediately after any super(...) calls."
                },
                {
                    "type": "code",
                    "code": "ts class MsgError extends Error { constructor ( m : string ) { super ( m ); // Set the prototype explicitly. Object . setPrototypeOf ( this , MsgError . prototype ); } sayHello () { return \"hello \" + this . message ; } } Try"
                },
                {
                    "type": "p",
                    "text": "However, any subclass of MsgError will have to manually set the prototype as well.\r\nFor runtimes that don’t support Object.setPrototypeOf , you may instead be able to use __proto__ . Unfortunately, these workarounds will not work on Internet Explorer 10 and prior .\r\nOne can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this ), but the prototype chain itself cannot be fixed. You can use TypeScript to control whether certain methods or properties are visible to code outside the class. The default visibility of class members is public .\r\nA public member can be accessed anywhere:"
                },
                {
                    "type": "code",
                    "code": "ts class Greeter { public greet () { console . log ( \"hi!\" ); } } const g = new Greeter (); g . greet (); Try"
                },
                {
                    "type": "p",
                    "text": "Because public is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style/readability reasons. protected members are only visible to subclasses of the class they’re declared in."
                },
                {
                    "type": "code",
                    "code": "ts class Greeter { public greet () { console . log ( \"Hello, \" + this . getName ()); } protected getName () { return \"hi\" ; } } class SpecialGreeter extends Greeter { public howdy () { // OK to access protected member here console . log ( \"Howdy, \" + this . getName ()); } } const g = new SpecialGreeter (); g . greet (); // OK g . getName (); Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses. 2445 Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses. Try"
                },
                {
                    "type": "p",
                    "text": "Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities.\r\nThis includes making protected members public :"
                },
                {
                    "type": "code",
                    "code": "ts class Base { protected m = 10 ; } class Derived extends Base { // No modifier, so default is 'public' m = 15 ; } const d = new Derived (); console . log ( d . m ); // OK Try"
                },
                {
                    "type": "p",
                    "text": "Note that Derived was already able to freely read and write m , so this doesn’t meaningfully alter the “security” of this situation.\r\nThe main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isn’t intentional. TypeScript doesn’t allow accessing protected members of a sibling class in a class hierarchy:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { protected x : number = 1 ; } class Derived1 extends Base { protected x : number = 5 ; } class Derived2 extends Base { f1 ( other : Derived2 ) { other . x = 10 ; } f2 ( other : Derived1 ) { other . x = 10 ; Property 'x' is protected and only accessible within class 'Derived1' and its subclasses. 2445 Property 'x' is protected and only accessible within class 'Derived1' and its subclasses. } } Try"
                },
                {
                    "type": "p",
                    "text": "This is because accessing x in Derived2 should only be legal from Derived2 ’s subclasses, and Derived1 isn’t one of them.\r\nMoreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation. See also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning on the same topic. private is like protected , but doesn’t allow access to the member even from subclasses:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { private x = 0 ; } const b = new Base (); // Can't access from outside the class console . log ( b . x ); Property 'x' is private and only accessible within class 'Base'. 2341 Property 'x' is private and only accessible within class 'Base'. Try"
                },
                {
                    "type": "code",
                    "code": "ts class Derived extends Base { showX () { // Can't access in subclasses console . log ( this . x ); Property 'x' is private and only accessible within class 'Base'. 2341 Property 'x' is private and only accessible within class 'Base'. } } Try"
                },
                {
                    "type": "p",
                    "text": "Because private members aren’t visible to derived classes, a derived class can’t increase their visibility:"
                },
                {
                    "type": "code",
                    "code": "ts class Base { private x = 0 ; } class Derived extends Base { Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'. 2415 Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'. x = 1 ; } Try"
                },
                {
                    "type": "p",
                    "text": "Different OOP languages disagree about whether different instances of the same class may access each others’ private members.\r\nWhile languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not. TypeScript does allow cross-instance private access:"
                },
                {
                    "type": "code",
                    "code": "ts class A { private x = 10 ; public sameAs ( other : A ) { // No error return other . x === this . x ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Like other aspects of TypeScript’s type system, private and protected are only enforced during type checking . This means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member:"
                },
                {
                    "type": "code",
                    "code": "ts class MySafe { private secretKey = 12345 ; } Try"
                },
                {
                    "type": "code",
                    "code": "js // In a JavaScript file... const s = new MySafe (); // Will print 12345 console . log ( s . secretKey );"
                },
                {
                    "type": "p",
                    "text": "private also allows access using bracket notation during type checking. This makes private -declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy."
                },
                {
                    "type": "code",
                    "code": "ts class MySafe { private secretKey = 12345 ; } const s = new MySafe (); // Not allowed during type checking console . log ( s . secretKey ); Property 'secretKey' is private and only accessible within class 'MySafe'. 2341 Property 'secretKey' is private and only accessible within class 'MySafe'. // OK console . log ( s [ \"secretKey\" ]); Try"
                },
                {
                    "type": "p",
                    "text": "Unlike TypeScripts’s private , JavaScript’s private fields ( # ) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private ."
                },
                {
                    "type": "code",
                    "code": "ts class Dog { #barkAmount = 0 ; personality = \"happy\" ; constructor () {} } Try"
                },
                {
                    "type": "code",
                    "code": "ts \"use strict\" ; class Dog { #barkAmount = 0 ; personality = \"happy\" ; constructor () { } } Try"
                },
                {
                    "type": "p",
                    "text": "When compiling to ES2021 or less, TypeScript will use WeakMaps in place of # ."
                },
                {
                    "type": "code",
                    "code": "ts \"use strict\" ; var _Dog_barkAmount ; class Dog { constructor () { _Dog_barkAmount . set ( this , 0 ); this . personality = \"happy\" ; } } _Dog_barkAmount = new WeakMap (); Try"
                },
                {
                    "type": "p",
                    "text": "If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance. Classes may have static members.\r\nThese members aren’t associated with a particular instance of the class.\r\nThey can be accessed through the class constructor object itself:"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { static x = 0 ; static printX () { console . log ( MyClass . x ); } } console . log ( MyClass . x ); MyClass . printX (); Try"
                },
                {
                    "type": "p",
                    "text": "Static members can also use the same public , protected , and private visibility modifiers:"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { private static x = 0 ; } console . log ( MyClass . x ); Property 'x' is private and only accessible within class 'MyClass'. 2341 Property 'x' is private and only accessible within class 'MyClass'. Try"
                },
                {
                    "type": "code",
                    "code": "ts class Base { static getGreeting () { return \"Hello world\" ; } } class Derived extends Base { myGreeting = Derived . getGreeting (); } Try"
                },
                {
                    "type": "p",
                    "text": "It’s generally not safe/possible to overwrite properties from the Function prototype.\r\nBecause classes are themselves functions that can be invoked with new , certain static names can’t be used.\r\nFunction properties like name , length , and call aren’t valid to define as static members:"
                },
                {
                    "type": "code",
                    "code": "ts class S { static name = \"S!\" ; Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'. 2699 Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'. } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does. Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them.\r\nA class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript. For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:"
                },
                {
                    "type": "code",
                    "code": "ts // Unnecessary \"static\" class class MyStaticClass { static doSomething () {} } // Preferred (alternative 1) function doSomething () {} // Preferred (alternative 2) const MyHelperObject = { dosomething () {}, }; Try"
                },
                {
                    "type": "p",
                    "text": "Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals."
                },
                {
                    "type": "code",
                    "code": "ts class Foo { static #count = 0 ; get count () { return Foo . #count ; } static { try { const lastInstances = loadLastInstances (); Foo . #count += lastInstances . length ; } catch {} } } Try"
                },
                {
                    "type": "p",
                    "text": "Classes, much like interfaces, can be generic.\r\nWhen a generic class is instantiated with new , its type parameters are inferred the same way as in a function call:"
                },
                {
                    "type": "code",
                    "code": "ts class Box < Type > { contents : Type ; constructor ( value : Type ) { this . contents = value ; } } const b = new Box ( \"hello!\" ); const b: Box<string> Try"
                },
                {
                    "type": "p",
                    "text": "Classes can use generic constraints and defaults the same way as interfaces. This code isn’t legal, and it may not be obvious why:"
                },
                {
                    "type": "code",
                    "code": "ts class Box < Type > { static defaultValue : Type ; Static members cannot reference class type parameters. 2302 Static members cannot reference class type parameters. } Try"
                },
                {
                    "type": "p",
                    "text": "Remember that types are always fully erased!\r\nAt runtime, there’s only one Box.defaultValue property slot.\r\nThis means that setting Box<string>.defaultValue (if that were possible) would also change Box<number>.defaultValue - not good.\r\nThe static members of a generic class can never refer to the class’s type parameters. It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors. JavaScript’s handling of this is indeed unusual:"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { name = \"MyClass\" ; getName () { return this . name ; } } const c = new MyClass (); const obj = { name : \"obj\" , getName : c . getName , }; // Prints \"obj\", not \"MyClass\" console . log ( obj . getName ()); Try"
                },
                {
                    "type": "p",
                    "text": "Long story short, by default, the value of this inside a function depends on how the function was called .\r\nIn this example, because the function was called through the obj reference, its value of this was obj rather than the class instance. This is rarely what you want to happen!\r\nTypeScript provides some ways to mitigate or prevent this kind of error. If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition:"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { name = \"MyClass\" ; getName = () => { return this . name ; }; } const c = new MyClass (); const g = c . getName ; // Prints \"MyClass\" instead of crashing console . log ( g ()); Try"
                },
                {
                    "type": "list",
                    "items": [
                        "The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript",
                        "This will use more memory, because each class instance will have its own copy of each function defined this way",
                        "You can’t use super.getName in a derived class, because there’s no entry in the prototype chain to fetch the base class method from"
                    ]
                },
                {
                    "type": "p",
                    "text": "In a method or function definition, an initial parameter named this has special meaning in TypeScript.\r\nThese parameters are erased during compilation:"
                },
                {
                    "type": "code",
                    "code": "ts // TypeScript input with 'this' parameter function fn ( this : SomeType , x : number ) { /* ... */ } Try"
                },
                {
                    "type": "code",
                    "code": "js // JavaScript output function fn ( x ) { /* ... */ }"
                },
                {
                    "type": "p",
                    "text": "TypeScript checks that calling a function with a this parameter is done so with a correct context.\r\nInstead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly:"
                },
                {
                    "type": "code",
                    "code": "ts class MyClass { name = \"MyClass\" ; getName ( this : MyClass ) { return this . name ; } } const c = new MyClass (); // OK c . getName (); // Error, would crash const g = c . getName ; console . log ( g ()); The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'. 2684 The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'. Try"
                },
                {
                    "type": "p",
                    "text": "This method makes the opposite trade-offs of the arrow function approach:"
                },
                {
                    "type": "list",
                    "items": [
                        "JavaScript callers might still use the class method incorrectly without realizing it",
                        "Only one function per class definition gets allocated, rather than one per class instance",
                        "Base method definitions can still be called via super ."
                    ]
                },
                {
                    "type": "p",
                    "text": "In classes, a special type called this refers dynamically to the type of the current class.\r\nLet’s see how this is useful:"
                },
                {
                    "type": "code",
                    "code": "ts class Box { contents : string = \"\" ; set ( value : string ) { (method) Box.set(value: string): this this . contents = value ; return this ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Here, TypeScript inferred the return type of set to be this , rather than Box .\r\nNow let’s make a subclass of Box :"
                },
                {
                    "type": "code",
                    "code": "ts class ClearableBox extends Box { clear () { this . contents = \"\" ; } } const a = new ClearableBox (); const b = a . set ( \"hello\" ); const b: ClearableBox Try"
                },
                {
                    "type": "p",
                    "text": "You can also use this in a parameter type annotation:"
                },
                {
                    "type": "code",
                    "code": "ts class Box { content : string = \"\" ; sameAs ( other : this ) { return other . content === this . content ; } } Try"
                },
                {
                    "type": "p",
                    "text": "This is different from writing other: Box — if you have a derived class, its sameAs method will now only accept other instances of that same derived class:"
                },
                {
                    "type": "code",
                    "code": "ts class Box { content : string = \"\" ; sameAs ( other : this ) { return other . content === this . content ; } } class DerivedBox extends Box { otherContent : string = \"?\" ; } const base = new Box (); const derived = new DerivedBox (); derived . sameAs ( base ); Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'. 2345 Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'. Try"
                },
                {
                    "type": "p",
                    "text": "You can use this is Type in the return position for methods in classes and interfaces.\r\nWhen mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type ."
                },
                {
                    "type": "code",
                    "code": "ts class FileSystemObject { isFile (): this is FileRep { return this instanceof FileRep ; } isDirectory (): this is Directory { return this instanceof Directory ; } isNetworked (): this is Networked & this { return this . networked ; } constructor ( public path : string , private networked : boolean ) {} } class FileRep extends FileSystemObject { constructor ( path : string , public content : string ) { super ( path , false ); } } class Directory extends FileSystemObject { children : FileSystemObject []; } interface Networked { host : string ; } const fso : FileSystemObject = new FileRep ( \"foo/bar.txt\" , \"foo\" ); if ( fso . isFile ()) { fso . content ; const fso: FileRep } else if ( fso . isDirectory ()) { fso . children ; const fso: Directory } else if ( fso . isNetworked ()) { fso . host ; const fso: Networked & FileSystemObject } Try"
                },
                {
                    "type": "p",
                    "text": "A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true:"
                },
                {
                    "type": "code",
                    "code": "ts class Box < T > { value ?: T ; hasValue (): this is { value : T } { return this . value !== undefined ; } } const box = new Box < string >(); box . value = \"Gameboy\" ; box . value ; (property) Box<string>.value?: string if ( box . hasValue ()) { box . value ; (property) value: string } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value.\r\nThese are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public , private , protected , or readonly .\r\nThe resulting field gets those modifier(s):"
                },
                {
                    "type": "code",
                    "code": "ts class Params { constructor ( public readonly x : number , protected y : number , private z : number ) { // No body necessary } } const a = new Params ( 1 , 2 , 3 ); console . log ( a . x ); (property) Params.x: number console . log ( a . z ); Property 'z' is private and only accessible within class 'Params'. 2341 Property 'z' is private and only accessible within class 'Params'. Try"
                },
                {
                    "type": "p",
                    "text": "Class expressions are very similar to class declarations.\r\nThe only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:"
                },
                {
                    "type": "code",
                    "code": "ts const someClass = class < Type > { content : Type ; constructor ( value : Type ) { this . content = value ; } }; const m = new someClass ( \"Hello, world\" ); const m: someClass<string> Try"
                },
                {
                    "type": "p",
                    "text": "JavaScript classes are instantiated with the new operator. Given the type of a class itself, the InstanceType utility type models this operation."
                },
                {
                    "type": "code",
                    "code": "ts class Point { createdAt : number ; x : number ; y : number constructor ( x : number , y : number ) { this . createdAt = Date . now () this . x = x ; this . y = y ; } } type PointInstance = InstanceType < typeof Point > function moveRight ( point : PointInstance ) { point . x += 5 ; } const point = new Point ( 3 , 4 ); moveRight ( point ); point . x ; // => 8 Try"
                },
                {
                    "type": "p",
                    "text": "Classes, methods, and fields in TypeScript may be abstract . An abstract method or abstract field is one that hasn’t had an implementation provided.\r\nThese members must exist inside an abstract class , which cannot be directly instantiated. The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members.\r\nWhen a class doesn’t have any abstract members, it is said to be concrete ."
                },
                {
                    "type": "code",
                    "code": "ts abstract class Base { abstract getName (): string ; printName () { console . log ( \"Hello, \" + this . getName ()); } } const b = new Base (); Cannot create an instance of an abstract class. 2511 Cannot create an instance of an abstract class. Try"
                },
                {
                    "type": "p",
                    "text": "We can’t instantiate Base with new because it’s abstract.\r\nInstead, we need to make a derived class and implement the abstract members:"
                },
                {
                    "type": "code",
                    "code": "ts class Derived extends Base { getName () { return \"world\" ; } } const d = new Derived (); d . printName (); Try"
                },
                {
                    "type": "p",
                    "text": "Notice that if we forget to implement the base class’s abstract members, we’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "ts class Derived extends Base { Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'. 2515 Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'. // forgot to do anything } Try"
                },
                {
                    "type": "p",
                    "text": "Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class. For example, you might want to write this code:"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( ctor : typeof Base ) { const instance = new ctor (); Cannot create an instance of an abstract class. 2511 Cannot create an instance of an abstract class. instance . printName (); } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript is correctly telling you that you’re trying to instantiate an abstract class.\r\nAfter all, given the definition of greet , it’s perfectly legal to write this code, which would end up constructing an abstract class:"
                },
                {
                    "type": "code",
                    "code": "ts // Bad! greet ( Base ); Try"
                },
                {
                    "type": "p",
                    "text": "Instead, you want to write a function that accepts something with a construct signature:"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( ctor : new () => Base ) { const instance = new ctor (); instance . printName (); } greet ( Derived ); greet ( Base ); Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type. 2345 Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type. Try"
                },
                {
                    "type": "p",
                    "text": "Now TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because it’s concrete, but Base cannot. In most cases, classes in TypeScript are compared structurally, the same as other types. For example, these two classes can be used in place of each other because they’re identical:"
                },
                {
                    "type": "code",
                    "code": "ts class Point1 { x = 0 ; y = 0 ; } class Point2 { x = 0 ; y = 0 ; } // OK const p : Point1 = new Point2 (); Try"
                },
                {
                    "type": "p",
                    "text": "Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:"
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; age : number ; } class Employee { name : string ; age : number ; salary : number ; } // OK const p : Person = new Employee (); Try"
                },
                {
                    "type": "p",
                    "text": "This sounds straightforward, but there are a few cases that seem stranger than others. Empty classes have no members.\r\nIn a structural type system, a type with no members is generally a supertype of anything else.\r\nSo if you write an empty class (don’t!), anything can be used in place of it:"
                },
                {
                    "type": "code",
                    "code": "ts class Empty {} function fn ( x : Empty ) { // can't do anything with 'x', so I won't } // All OK! fn ( window ); fn ({}); fn ( fn ); Try"
                },
                {
                    "type": "p",
                    "text": "How JavaScript handles communicating across file boundaries. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",
            "title": "TypeScript: Documentation - Conditional Types",
            "content": [
                {
                    "type": "p",
                    "text": "At the heart of most useful programs, we have to make decisions based on input.\nJavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs."
                },
                {
                    "type": "code",
                    "code": "ts interface Animal { live (): void ; } interface Dog extends Animal { woof (): void ; } type Example1 = Dog extends Animal ? number : string ; type Example1 = number type Example2 = RegExp extends Animal ? number : string ; type Example2 = string Try"
                },
                {
                    "type": "p",
                    "text": "Conditional types take a form that looks a little like conditional expressions ( condition ? trueExpression : falseExpression ) in JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts SomeType extends OtherType ? TrueType : FalseType ; Try"
                },
                {
                    "type": "p",
                    "text": "When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch). From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string !\nBut the power of conditional types comes from using them with generics. For example, let’s take the following createLabel function:"
                },
                {
                    "type": "code",
                    "code": "ts interface IdLabel { id : number /* some fields */ ; } interface NameLabel { name : string /* other fields */ ; } function createLabel ( id : number ): IdLabel ; function createLabel ( name : string ): NameLabel ; function createLabel ( nameOrId : string | number ): IdLabel | NameLabel ; function createLabel ( nameOrId : string | number ): IdLabel | NameLabel { throw \"unimplemented\" ; } Try"
                },
                {
                    "type": "p",
                    "text": "These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:"
                },
                {
                    "type": "list",
                    "items": [
                        "If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.",
                        "We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number ), and one for the most general case (taking a string | number ). For every new type createLabel can handle, the number of overloads grows exponentially."
                    ]
                },
                {
                    "type": "p",
                    "text": "Instead, we can encode that logic in a conditional type:"
                },
                {
                    "type": "code",
                    "code": "ts type NameOrId < T extends number | string > = T extends number ? IdLabel : NameLabel ; Try"
                },
                {
                    "type": "p",
                    "text": "We can then use that conditional type to simplify our overloads down to a single function with no overloads."
                },
                {
                    "type": "code",
                    "code": "ts function createLabel < T extends number | string >( idOrName : T ): NameOrId < T > { throw \"unimplemented\" ; } let a = createLabel ( \"typescript\" ); let a: NameLabel let b = createLabel ( 2.8 ); let b: IdLabel let c = createLabel ( Math . random () ? \"hello\" : 42 ); let c: NameLabel | IdLabel Try"
                },
                {
                    "type": "p",
                    "text": "Often, the checks in a conditional type will provide us with some new information.\nJust like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against. For example, let’s take the following:"
                },
                {
                    "type": "code",
                    "code": "ts type MessageOf < T > = T [ \"message\" ]; Type '\"message\"' cannot be used to index type 'T'. 2536 Type '\"message\"' cannot be used to index type 'T'. Try"
                },
                {
                    "type": "p",
                    "text": "In this example, TypeScript errors because T isn’t known to have a property called message .\nWe could constrain T , and TypeScript would no longer complain:"
                },
                {
                    "type": "code",
                    "code": "ts type MessageOf < T extends { message : unknown }> = T [ \"message\" ]; interface Email { message : string ; } type EmailMessageContents = MessageOf < Email >; type EmailMessageContents = string Try"
                },
                {
                    "type": "p",
                    "text": "However, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available?\nWe can do this by moving the constraint out and introducing a conditional type:"
                },
                {
                    "type": "code",
                    "code": "ts type MessageOf < T > = T extends { message : unknown } ? T [ \"message\" ] : never ; interface Email { message : string ; } interface Dog { bark (): void ; } type EmailMessageContents = MessageOf < Email >; type EmailMessageContents = string type DogMessageContents = MessageOf < Dog >; type DogMessageContents = never Try"
                },
                {
                    "type": "p",
                    "text": "Within the true branch, TypeScript knows that T will have a message property. As another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:"
                },
                {
                    "type": "code",
                    "code": "ts type Flatten < T > = T extends any [] ? T [ number ] : T ; // Extracts out the element type. type Str = Flatten < string []>; type Str = string // Leaves the type alone. type Num = Flatten < number >; type Num = number Try"
                },
                {
                    "type": "p",
                    "text": "When Flatten is given an array type, it uses an indexed access with number to fetch out string[] ’s element type.\nOtherwise, it just returns the type it was given. We just found ourselves using conditional types to apply constraints and then extract out types.\nThis ends up being such a common operation that conditional types make it easier. Conditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword.\nFor example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:"
                },
                {
                    "type": "code",
                    "code": "ts type Flatten < Type > = Type extends Array < infer Item > ? Item : Type ; Try"
                },
                {
                    "type": "p",
                    "text": "Here, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of Type within the true branch.\nThis frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in. We can write some useful helper type aliases using the infer keyword.\nFor example, for simple cases, we can extract the return type out from function types:"
                },
                {
                    "type": "code",
                    "code": "ts type GetReturnType < Type > = Type extends (... args : never []) => infer Return ? Return : never ; type Num = GetReturnType <() => number >; type Num = number type Str = GetReturnType <( x : string ) => string >; type Str = string type Bools = GetReturnType <( a : boolean , b : boolean ) => boolean []>; type Bools = boolean[] Try"
                },
                {
                    "type": "p",
                    "text": "When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types."
                },
                {
                    "type": "code",
                    "code": "ts declare function stringOrNum ( x : string ): number ; declare function stringOrNum ( x : number ): string ; declare function stringOrNum ( x : string | number ): string | number ; type T1 = ReturnType < typeof stringOrNum >; type T1 = string | number Try"
                },
                {
                    "type": "p",
                    "text": "When conditional types act on a generic type, they become distributive when given a union type.\nFor example, take the following:"
                },
                {
                    "type": "code",
                    "code": "ts type ToArray < Type > = Type extends any ? Type [] : never ; Try"
                },
                {
                    "type": "p",
                    "text": "If we plug a union type into ToArray , then the conditional type will be applied to each member of that union."
                },
                {
                    "type": "code",
                    "code": "ts type ToArray < Type > = Type extends any ? Type [] : never ; type StrArrOrNumArr = ToArray < string | number >; type StrArrOrNumArr = string[] | number[] Try"
                },
                {
                    "type": "p",
                    "text": "What happens here is that ToArray distributes on:"
                },
                {
                    "type": "code",
                    "code": "ts string | number ; Try"
                },
                {
                    "type": "p",
                    "text": "and maps over each member type of the union, to what is effectively:"
                },
                {
                    "type": "code",
                    "code": "ts ToArray < string > | ToArray < number >; Try"
                },
                {
                    "type": "code",
                    "code": "ts string [] | number []; Try"
                },
                {
                    "type": "p",
                    "text": "Typically, distributivity is the desired behavior.\nTo avoid that behavior, you can surround each side of the extends keyword with square brackets."
                },
                {
                    "type": "code",
                    "code": "ts type ToArrayNonDist < Type > = [ Type ] extends [ any ] ? Type [] : never ; // 'ArrOfStrOrNum' is no longer a union. type ArrOfStrOrNum = ToArrayNonDist < string | number >; type ArrOfStrOrNum = (string | number)[] Try"
                },
                {
                    "type": "p",
                    "text": "Using Type['a'] syntax to access a subset of a type. Generating types by re-using an existing type. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html",
            "title": "TypeScript: Documentation - Everyday Types",
            "content": [
                {
                    "type": "p",
                    "text": "In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript.\r\nThis isn’t an exhaustive list, and future chapters will describe more ways to name and use other types. Types can also appear in many more places than just type annotations.\r\nAs we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs. We’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code.\r\nThese will later form the core building blocks of more complex types. JavaScript has three very commonly used primitives : string , number , and boolean .\r\nEach has a corresponding type in TypeScript.\r\nAs you might expect, these are the same names you’d see if you used the JavaScript typeof operator on a value of those types:"
                },
                {
                    "type": "list",
                    "items": [
                        "string represents string values like \"Hello, world\"",
                        "number is for numbers like 42 . JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply number",
                        "boolean is for the two values true and false"
                    ]
                },
                {
                    "type": "p",
                    "text": "The type names String , Number , and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string , number , or boolean for types. To specify the type of an array like [1, 2, 3] , you can use the syntax number[] ; this syntax works for any type (e.g. string[] is an array of strings, and so on).\r\nYou may also see this written as Array<number> , which means the same thing.\r\nWe’ll learn more about the syntax T<U> when we cover generics . Note that [number] is a different thing; refer to the section on Tuples . TypeScript also has a special type, any , that you can use whenever you don’t want a particular value to cause typechecking errors. When a value is of type any , you can access any properties of it (which will in turn be of type any ), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:"
                },
                {
                    "type": "code",
                    "code": "ts let obj : any = { x : 0 }; // None of the following lines of code will throw compiler errors. // Using `any` disables all further type checking, and it is assumed // you know the environment better than TypeScript. obj . foo (); obj (); obj . bar = 100 ; obj = \"hello\" ; const n : number = obj ; Try"
                },
                {
                    "type": "p",
                    "text": "The any type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay. When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any . You usually want to avoid this, though, because any isn’t type-checked.\r\nUse the compiler flag noImplicitAny to flag any implicit any as an error. When you declare a variable using const , var , or let , you can optionally add a type annotation to explicitly specify the type of the variable:"
                },
                {
                    "type": "code",
                    "code": "ts let myName : string = \"Alice\" ; Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t use “types on the left”-style declarations like int x = 0; Type annotations will always go after the thing being typed. In most cases, though, this isn’t needed.\r\nWherever possible, TypeScript tries to automatically infer the types in your code.\r\nFor example, the type of a variable is inferred based on the type of its initializer:"
                },
                {
                    "type": "code",
                    "code": "ts // No type annotation needed -- 'myName' inferred as type 'string' let myName = \"Alice\" ; Try"
                },
                {
                    "type": "p",
                    "text": "For the most part you don’t need to explicitly learn the rules of inference.\r\nIf you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on. Functions are the primary means of passing data around in JavaScript.\r\nTypeScript allows you to specify the types of both the input and output values of functions. When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts.\r\nParameter type annotations go after the parameter name:"
                },
                {
                    "type": "code",
                    "code": "ts // Parameter type annotation function greet ( name : string ) { console . log ( \"Hello, \" + name . toUpperCase () + \"!!\" ); } Try"
                },
                {
                    "type": "p",
                    "text": "When a parameter has a type annotation, arguments to that function will be checked:"
                },
                {
                    "type": "code",
                    "code": "ts // Would be a runtime error if executed! greet ( 42 ); Argument of type 'number' is not assignable to parameter of type 'string'. 2345 Argument of type 'number' is not assignable to parameter of type 'string'. Try"
                },
                {
                    "type": "p",
                    "text": "Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments. You can also add return type annotations.\r\nReturn type annotations appear after the parameter list:"
                },
                {
                    "type": "code",
                    "code": "ts function getFavoriteNumber (): number { return 26 ; } Try"
                },
                {
                    "type": "p",
                    "text": "Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements.\r\nThe type annotation in the above example doesn’t change anything.\r\nSome codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference. If you want to annotate the return type of a function which returns a promise, you should use the Promise type:"
                },
                {
                    "type": "code",
                    "code": "ts async function getFavoriteNumber (): Promise < number > { return 26 ; } Try"
                },
                {
                    "type": "p",
                    "text": "Anonymous functions are a little bit different from function declarations.\r\nWhen a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types."
                },
                {
                    "type": "code",
                    "code": "ts const names = [ \"Alice\" , \"Bob\" , \"Eve\" ]; // Contextual typing for function - parameter s inferred to have type string names . forEach ( function ( s ) { console . log ( s . toUpperCase ()); }); // Contextual typing also applies to arrow functions names . forEach (( s ) => { console . log ( s . toUpperCase ()); }); Try"
                },
                {
                    "type": "p",
                    "text": "Even though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have. This process is called contextual typing because the context that the function occurred within informs what type it should have. Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed.\r\nLater, we’ll see more examples of how the context that a value occurs in can affect its type. Apart from primitives, the most common sort of type you’ll encounter is an object type .\r\nThis refers to any JavaScript value with properties, which is almost all of them!\r\nTo define an object type, we simply list its properties and their types. For example, here’s a function that takes a point-like object:"
                },
                {
                    "type": "code",
                    "code": "ts // The parameter's type annotation is an object type function printCoord ( pt : { x : number ; y : number }) { console . log ( \"The coordinate's x value is \" + pt . x ); console . log ( \"The coordinate's y value is \" + pt . y ); } printCoord ({ x : 3 , y : 7 }); Try"
                },
                {
                    "type": "p",
                    "text": "Here, we annotated the parameter with a type with two properties - x and y - which are both of type number .\r\nYou can use , or ; to separate the properties, and the last separator is optional either way. The type part of each property is also optional.\r\nIf you don’t specify a type, it will be assumed to be any . Object types can also specify that some or all of their properties are optional .\r\nTo do this, add a ? after the property name:"
                },
                {
                    "type": "code",
                    "code": "ts function printName ( obj : { first : string ; last ?: string }) { // ... } // Both OK printName ({ first : \"Bob\" }); printName ({ first : \"Alice\" , last : \"Alisson\" }); Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, if you access a property that doesn’t exist, you’ll get the value undefined rather than a runtime error.\r\nBecause of this, when you read from an optional property, you’ll have to check for undefined before using it."
                },
                {
                    "type": "code",
                    "code": "ts function printName ( obj : { first : string ; last ?: string }) { // Error - might crash if 'obj.last' wasn't provided! console . log ( obj . last . toUpperCase ()); 'obj.last' is possibly 'undefined'. 18048 'obj.last' is possibly 'undefined'. if ( obj . last !== undefined ) { // OK console . log ( obj . last . toUpperCase ()); } // A safe alternative using modern JavaScript syntax: console . log ( obj . last ?. toUpperCase ()); } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators.\r\nNow that we know how to write a few types, it’s time to start combining them in interesting ways. The first way to combine types you might see is a union type.\r\nA union type is a type formed from two or more other types, representing values that may be any one of those types.\r\nWe refer to each of these types as the union’s members . Let’s write a function that can operate on strings or numbers:"
                },
                {
                    "type": "code",
                    "code": "ts function printId ( id : number | string ) { console . log ( \"Your ID is: \" + id ); } // OK printId ( 101 ); // OK printId ( \"202\" ); // Error printId ({ myID : 22342 }); Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'. 2345 Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'. Try"
                },
                {
                    "type": "p",
                    "text": "The separator of the union members is allowed before the first element, so you could also write this:"
                },
                {
                    "type": "code",
                    "code": "ts function printTextOrNumberOrBool ( textOrNumberOrBool : | string | number | boolean ) { console . log ( textOrNumberOrBool ); } Try"
                },
                {
                    "type": "p",
                    "text": "It’s easy to provide a value matching a union type - simply provide a type matching any of the union’s members.\r\nIf you have a value of a union type, how do you work with it? TypeScript will only allow an operation if it is valid for every member of the union.\r\nFor example, if you have the union string | number , you can’t use methods that are only available on string :"
                },
                {
                    "type": "code",
                    "code": "ts function printId ( id : number | string ) { console . log ( id . toUpperCase ()); Property 'toUpperCase' does not exist on type 'string | number'.\n  Property 'toUpperCase' does not exist on type 'number'. 2339 Property 'toUpperCase' does not exist on type 'string | number'.\n  Property 'toUpperCase' does not exist on type 'number'. } Try"
                },
                {
                    "type": "p",
                    "text": "The solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code. For example, TypeScript knows that only a string value will have a typeof value \"string\" :"
                },
                {
                    "type": "code",
                    "code": "ts function printId ( id : number | string ) { if ( typeof id === \"string\" ) { // In this branch, id is of type 'string' console . log ( id . toUpperCase ()); } else { // Here, id is of type 'number' console . log ( id ); } } Try"
                },
                {
                    "type": "p",
                    "text": "Another example is to use a function like Array.isArray :"
                },
                {
                    "type": "code",
                    "code": "ts function welcomePeople ( x : string [] | string ) { if ( Array . isArray ( x )) { // Here: 'x' is 'string[]' console . log ( \"Hello, \" + x . join ( \" and \" )); } else { // Here: 'x' is 'string' console . log ( \"Welcome lone traveler \" + x ); } } Try"
                },
                {
                    "type": "p",
                    "text": "Notice that in the else branch, we don’t need to do anything special - if x wasn’t a string[] , then it must have been a string . Sometimes you’ll have a union where all the members have something in common.\r\nFor example, both arrays and strings have a slice method.\r\nIf every member in a union has a property in common, you can use that property without narrowing:"
                },
                {
                    "type": "code",
                    "code": "ts // Return type is inferred as number[] | string function getFirstThree ( x : number [] | string ) { return x . slice ( 0 , 3 ); } Try"
                },
                {
                    "type": "p",
                    "text": "It might be confusing that a union of types appears to have the intersection of those types’ properties.\r\nThis is not an accident - the name union comes from type theory.\r\nThe union number | string is composed by taking the union of the values from each type.\r\nNotice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves.\r\nFor example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat. We’ve been using object types and union types by writing them directly in type annotations.\r\nThis is convenient, but it’s common to want to use the same type more than once and refer to it by a single name. A type alias is exactly that - a name for any type .\r\nThe syntax for a type alias is:"
                },
                {
                    "type": "code",
                    "code": "ts type Point = { x : number ; y : number ; }; // Exactly the same as the earlier example function printCoord ( pt : Point ) { console . log ( \"The coordinate's x value is \" + pt . x ); console . log ( \"The coordinate's y value is \" + pt . y ); } printCoord ({ x : 100 , y : 100 }); Try"
                },
                {
                    "type": "p",
                    "text": "You can actually use a type alias to give a name to any type at all, not just an object type.\r\nFor example, a type alias can name a union type:"
                },
                {
                    "type": "code",
                    "code": "ts type ID = number | string ; Try"
                },
                {
                    "type": "p",
                    "text": "Note that aliases are only aliases - you cannot use type aliases to create different/distinct “versions” of the same type.\r\nWhen you use the alias, it’s exactly as if you had written the aliased type.\r\nIn other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:"
                },
                {
                    "type": "code",
                    "code": "ts type UserInputSanitizedString = string ; function sanitizeInput ( str : string ): UserInputSanitizedString { return sanitize ( str ); } // Create a sanitized input let userInput = sanitizeInput ( getInput ()); // Can still be re-assigned with a string though userInput = \"new input\" ; Try"
                },
                {
                    "type": "p",
                    "text": "An interface declaration is another way to name an object type:"
                },
                {
                    "type": "code",
                    "code": "ts interface Point { x : number ; y : number ; } function printCoord ( pt : Point ) { console . log ( \"The coordinate's x value is \" + pt . x ); console . log ( \"The coordinate's y value is \" + pt . y ); } printCoord ({ x : 100 , y : 100 }); Try"
                },
                {
                    "type": "p",
                    "text": "Just like when we used a type alias above, the example works just as if we had used an anonymous object type.\r\nTypeScript is only concerned with the structure of the value we passed to printCoord - it only cares that it has the expected properties.\r\nBeing concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system. Type aliases and interfaces are very similar, and in many cases you can choose between them freely.\r\nAlmost all features of an interface are available in type , the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable."
                },
                {
                    "type": "code",
                    "code": "interface Animal {\r\n  name: string;\r\n} interface Bear extends Animal {\r\n  honey: boolean;\r\n} const bear = getBear();\r\nbear.name;\r\nbear.honey;"
                },
                {
                    "type": "code",
                    "code": "type Animal = {\r\n  name: string;\r\n} type Bear = Animal & { \r\n  honey: boolean;\r\n} const bear = getBear();\r\nbear.name;\r\nbear.honey;"
                },
                {
                    "type": "p",
                    "text": "Adding new fields to an existing interface"
                },
                {
                    "type": "code",
                    "code": "interface Window {\r\n  title: string;\r\n} interface Window {\r\n  ts: TypeScriptAPI;\r\n} const src = 'const a = \"Hello World\"';\r\nwindow.ts.transpileModule(src, {});"
                },
                {
                    "type": "p",
                    "text": "A type cannot be changed after being created"
                },
                {
                    "type": "code",
                    "code": "type Window = {\r\n  title: string;\r\n} type Window = {\r\n  ts: TypeScriptAPI;\r\n} // Error: Duplicate identifier 'Window'."
                },
                {
                    "type": "p",
                    "text": "You’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away."
                },
                {
                    "type": "list",
                    "items": [
                        "Prior to TypeScript version 4.2, type alias names may appear in error messages , sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.",
                        "Type aliases may not participate in declaration merging, but interfaces can .",
                        "Interfaces may only be used to declare the shapes of objects, not rename primitives .",
                        "Interface names will always appear in their original form in error messages, but only when they are used by name.",
                        "Using interfaces with extends can often be more performant for the compiler than type aliases with intersections"
                    ]
                },
                {
                    "type": "p",
                    "text": "For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type . Sometimes you will have information about the type of a value that TypeScript can’t know about. For example, if you’re using document.getElementById , TypeScript only knows that this will return some kind of HTMLElement , but you might know that your page will always have an HTMLCanvasElement with a given ID. In this situation, you can use a type assertion to specify a more specific type:"
                },
                {
                    "type": "code",
                    "code": "ts const myCanvas = document . getElementById ( \"main_canvas\" ) as HTMLCanvasElement ; Try"
                },
                {
                    "type": "p",
                    "text": "Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code. You can also use the angle-bracket syntax (except if the code is in a .tsx file), which is equivalent:"
                },
                {
                    "type": "code",
                    "code": "ts const myCanvas = < HTMLCanvasElement > document . getElementById ( \"main_canvas\" ); Try"
                },
                {
                    "type": "p",
                    "text": "Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion.\r\nThere won’t be an exception or null generated if the type assertion is wrong. TypeScript only allows type assertions which convert to a more specific or less specific version of a type.\r\nThis rule prevents “impossible” coercions like:"
                },
                {
                    "type": "code",
                    "code": "ts const x = \"hello\" as number ; Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. 2352 Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Try"
                },
                {
                    "type": "p",
                    "text": "Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid.\r\nIf this happens, you can use two assertions, first to any (or unknown , which we’ll introduce later), then to the desired type:"
                },
                {
                    "type": "code",
                    "code": "ts const a = expr as any as T ; Try"
                },
                {
                    "type": "p",
                    "text": "In addition to the general types string and number , we can refer to specific strings and numbers in type positions. One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both var and let allow for changing what is held inside the variable, and const does not. This is reflected in how TypeScript creates types for literals."
                },
                {
                    "type": "code",
                    "code": "ts let changingString = \"Hello World\" ; changingString = \"Olá Mundo\" ; // Because `changingString` can represent any possible string, that // is how TypeScript describes it in the type system changingString ; let changingString: string const constantString = \"Hello World\" ; // Because `constantString` can only represent 1 possible string, it // has a literal type representation constantString ; const constantString: \"Hello World\" Try"
                },
                {
                    "type": "p",
                    "text": "By themselves, literal types aren’t very valuable:"
                },
                {
                    "type": "code",
                    "code": "ts let x : \"hello\" = \"hello\" ; // OK x = \"hello\" ; // ... x = \"howdy\" ; Type '\"howdy\"' is not assignable to type '\"hello\"'. 2322 Type '\"howdy\"' is not assignable to type '\"hello\"'. Try"
                },
                {
                    "type": "p",
                    "text": "It’s not much use to have a variable that can only have one value! But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:"
                },
                {
                    "type": "code",
                    "code": "ts function printText ( s : string , alignment : \"left\" | \"right\" | \"center\" ) { // ... } printText ( \"Hello, world\" , \"left\" ); printText ( \"G'day, mate\" , \"centre\" ); Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'. 2345 Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'. Try"
                },
                {
                    "type": "p",
                    "text": "Numeric literal types work the same way:"
                },
                {
                    "type": "code",
                    "code": "ts function compare ( a : string , b : string ): - 1 | 0 | 1 { return a === b ? 0 : a > b ? 1 : - 1 ; } Try"
                },
                {
                    "type": "p",
                    "text": "Of course, you can combine these with non-literal types:"
                },
                {
                    "type": "code",
                    "code": "ts interface Options { width : number ; } function configure ( x : Options | \"auto\" ) { // ... } configure ({ width : 100 }); configure ( \"auto\" ); configure ( \"automatic\" ); Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'. 2345 Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'. Try"
                },
                {
                    "type": "p",
                    "text": "There’s one more kind of literal type: boolean literals.\r\nThere are only two boolean literal types, and as you might guess, they are the types true and false .\r\nThe type boolean itself is actually just an alias for the union true | false . When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later.\r\nFor example, if you wrote code like this:"
                },
                {
                    "type": "code",
                    "code": "ts const obj = { counter : 0 }; if ( someCondition ) { obj . counter = 1 ; } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t assume the assignment of 1 to a field which previously had 0 is an error.\r\nAnother way of saying this is that obj.counter must have the type number , not 0 , because types are used to determine both reading and writing behavior."
                },
                {
                    "type": "code",
                    "code": "ts declare function handleRequest ( url : string , method : \"GET\" | \"POST\" ): void ; const req = { url : \"https://example.com\" , method : \"GET\" }; handleRequest ( req . url , req . method ); Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'. 2345 Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'. Try"
                },
                {
                    "type": "p",
                    "text": "In the above example req.method is inferred to be string , not \"GET\" . Because code can be evaluated between the creation of req and the call of handleRequest which could assign a new string like \"GUESS\" to req.method , TypeScript considers this code to have an error. There are two ways to work around this."
                },
                {
                    "type": "list",
                    "items": [
                        "You can change the inference by adding a type assertion in either location: ts // Change 1: const req = { url : \"https://example.com\" , method : \"GET\" as \"GET\" }; // Change 2 handleRequest ( req . url , req . method as \"GET\" ); Try Change 1 means “I intend for req.method to always have the literal type \"GET\" ”, preventing the possible assignment of \"GUESS\" to that field after.\r\nChange 2 means “I know for other reasons that req.method has the value \"GET\" “.",
                        "You can use as const to convert the entire object to be type literals: ts const req = { url : \"https://example.com\" , method : \"GET\" } as const ; handleRequest ( req . url , req . method ); Try"
                    ]
                },
                {
                    "type": "p",
                    "text": "The as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number . JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined . TypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on. With strictNullChecks off , values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type.\r\nThis is similar to how languages without null checks (e.g. C#, Java) behave.\r\nThe lack of checking for these values tends to be a major source of bugs; we always recommend people turn strictNullChecks on if it’s practical to do so in their codebase. With strictNullChecks on , when a value is null or undefined , you will need to test for those values before using methods or properties on that value.\r\nJust like checking for undefined before using an optional property, we can use narrowing to check for values that might be null :"
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( x : string | null ) { if ( x === null ) { // do nothing } else { console . log ( \"Hello, \" + x . toUpperCase ()); } } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking.\r\nWriting ! after any expression is effectively a type assertion that the value isn’t null or undefined :"
                },
                {
                    "type": "code",
                    "code": "ts function liveDangerously ( x ?: number | null ) { // No error console . log ( x !. toFixed ()); } Try"
                },
                {
                    "type": "p",
                    "text": "Just like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use ! when you know that the value can’t be null or undefined . Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page . It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system.\r\nThough we will not go into depth here. From ES2020 onwards, there is a primitive in JavaScript used for very large integers, BigInt :"
                },
                {
                    "type": "code",
                    "code": "ts // Creating a bigint via the BigInt function const oneHundred : bigint = BigInt ( 100 ); // Creating a BigInt via the literal syntax const anotherHundred : bigint = 100 n ; Try"
                },
                {
                    "type": "p",
                    "text": "You can learn more about BigInt in the TypeScript 3.2 release notes . There is a primitive in JavaScript used to create a globally unique reference via the function Symbol() :"
                },
                {
                    "type": "code",
                    "code": "ts const firstName = Symbol ( \"name\" ); const secondName = Symbol ( \"name\" ); if ( firstName === secondName ) { This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap. 2367 This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap. // Can't ever happen } Try"
                },
                {
                    "type": "p",
                    "text": "You can learn more about them in Symbols reference page . Step one in learning TypeScript: The basic types. Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
            "title": "TypeScript: Documentation - More on Functions",
            "content": [
                {
                    "type": "p",
                    "text": "Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class.\r\nThey’re also values, and just like other values, TypeScript has many ways to describe how functions can be called.\r\nLet’s learn about how to write types that describe functions. The simplest way to describe a function is with a function type expression .\r\nThese types are syntactically similar to arrow functions:"
                },
                {
                    "type": "code",
                    "code": "ts function greeter ( fn : ( a : string ) => void ) { fn ( \"Hello, World\" ); } function printToConsole ( s : string ) { console . log ( s ); } greeter ( printToConsole ); Try"
                },
                {
                    "type": "p",
                    "text": "The syntax (a: string) => void means “a function with one parameter, named a , of type string , that doesn’t have a return value”.\r\nJust like with function declarations, if a parameter type isn’t specified, it’s implicitly any . Note that the parameter name is required . The function type (string) => void means “a function with a parameter named string of type any “! Of course, we can use a type alias to name a function type:"
                },
                {
                    "type": "code",
                    "code": "ts type GreetFunction = ( a : string ) => void ; function greeter ( fn : GreetFunction ) { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, functions can have properties in addition to being callable.\r\nHowever, the function type expression syntax doesn’t allow for declaring properties.\r\nIf we want to describe something callable with properties, we can write a call signature in an object type:"
                },
                {
                    "type": "code",
                    "code": "ts type DescribableFunction = { description : string ; ( someArg : number ): boolean ; }; function doSomething ( fn : DescribableFunction ) { console . log ( fn . description + \" returned \" + fn ( 6 )); } function myFunc ( someArg : number ) { return someArg > 3 ; } myFunc . description = \"default description\" ; doSomething ( myFunc ); Try"
                },
                {
                    "type": "p",
                    "text": "Note that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than => . JavaScript functions can also be invoked with the new operator.\r\nTypeScript refers to these as constructors because they usually create a new object.\r\nYou can write a construct signature by adding the new keyword in front of a call signature:"
                },
                {
                    "type": "code",
                    "code": "ts type SomeConstructor = { new ( s : string ): SomeObject ; }; function fn ( ctor : SomeConstructor ) { return new ctor ( \"hello\" ); } Try"
                },
                {
                    "type": "p",
                    "text": "Some objects, like JavaScript’s Date object, can be called with or without new .\r\nYou can combine call and construct signatures in the same type arbitrarily:"
                },
                {
                    "type": "code",
                    "code": "ts interface CallOrConstruct { ( n ?: number ): string ; new ( s : string ): Date ; } function fn ( ctor : CallOrConstruct ) { // Passing an argument of type `number` to `ctor` matches it against // the first definition in the `CallOrConstruct` interface. console . log ( ctor ( 10 )); (parameter) ctor: CallOrConstruct\n(n?: number) => string // Similarly, passing an argument of type `string` to `ctor` matches it // against the second definition in the `CallOrConstruct` interface. console . log ( new ctor ( \"10\" )); (parameter) ctor: CallOrConstruct\nnew (s: string) => Date } fn ( Date ); Try"
                },
                {
                    "type": "p",
                    "text": "It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.\r\nLet’s consider for a moment a function that returns the first element of an array:"
                },
                {
                    "type": "code",
                    "code": "ts function firstElement ( arr : any []) { return arr [ 0 ]; } Try"
                },
                {
                    "type": "p",
                    "text": "This function does its job, but unfortunately has the return type any .\r\nIt’d be better if the function returned the type of the array element. In TypeScript, generics are used when we want to describe a correspondence between two values.\r\nWe do this by declaring a type parameter in the function signature:"
                },
                {
                    "type": "code",
                    "code": "ts function firstElement < Type >( arr : Type []): Type | undefined { return arr [ 0 ]; } Try"
                },
                {
                    "type": "p",
                    "text": "By adding a type parameter Type to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value).\r\nNow when we call it, a more specific type comes out:"
                },
                {
                    "type": "code",
                    "code": "ts // s is of type 'string' const s = firstElement ([ \"a\" , \"b\" , \"c\" ]); // n is of type 'number' const n = firstElement ([ 1 , 2 , 3 ]); // u is of type undefined const u = firstElement ([]); Try"
                },
                {
                    "type": "p",
                    "text": "Note that we didn’t have to specify Type in this sample.\r\nThe type was inferred - chosen automatically - by TypeScript. We can use multiple type parameters as well.\r\nFor example, a standalone version of map would look like this:"
                },
                {
                    "type": "code",
                    "code": "ts function map < Input , Output >( arr : Input [], func : ( arg : Input ) => Output ): Output [] { return arr . map ( func ); } // Parameter 'n' is of type 'string' // 'parsed' is of type 'number[]' const parsed = map ([ \"1\" , \"2\" , \"3\" ], ( n ) => parseInt ( n )); Try"
                },
                {
                    "type": "p",
                    "text": "Note that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression ( number ). We’ve written some generic functions that can work on any kind of value.\r\nSometimes we want to relate two values, but can only operate on a certain subset of values.\r\nIn this case, we can use a constraint to limit the kinds of types that a type parameter can accept. Let’s write a function that returns the longer of two values.\r\nTo do this, we need a length property that’s a number.\r\nWe constrain the type parameter to that type by writing an extends clause:"
                },
                {
                    "type": "code",
                    "code": "ts function longest < Type extends { length : number }>( a : Type , b : Type ) { if ( a . length >= b . length ) { return a ; } else { return b ; } } // longerArray is of type 'number[]' const longerArray = longest ([ 1 , 2 ], [ 1 , 2 , 3 ]); // longerString is of type 'alice' | 'bob' const longerString = longest ( \"alice\" , \"bob\" ); // Error! Numbers don't have a 'length' property const notOK = longest ( 10 , 100 ); Argument of type 'number' is not assignable to parameter of type '{ length: number; }'. 2345 Argument of type 'number' is not assignable to parameter of type '{ length: number; }'. Try"
                },
                {
                    "type": "p",
                    "text": "There are a few interesting things to note in this example.\r\nWe allowed TypeScript to infer the return type of longest .\r\nReturn type inference also works on generic functions. Because we constrained Type to { length: number } , we were allowed to access the .length property of the a and b parameters.\r\nWithout the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property. The types of longerArray and longerString were inferred based on the arguments.\r\nRemember, generics are all about relating two or more values with the same type! Finally, just as we’d like, the call to longest(10, 100) is rejected because the number type doesn’t have a .length property. Here’s a common error when working with generic constraints:"
                },
                {
                    "type": "code",
                    "code": "ts function minimumLength < Type extends { length : number }>( obj : Type , minimum : number ): Type { if ( obj . length >= minimum ) { return obj ; } else { return { length : minimum }; Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'. 2322 Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'. } } Try"
                },
                {
                    "type": "p",
                    "text": "It might look like this function is OK - Type is constrained to { length: number } , and the function either returns Type or a value matching that constraint.\r\nThe problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint.\r\nIf this code were legal, you could write code that definitely wouldn’t work:"
                },
                {
                    "type": "code",
                    "code": "ts // 'arr' gets value { length: 6 } const arr = minimumLength ([ 1 , 2 , 3 ], 6 ); // and crashes here because arrays have // a 'slice' method, but not the returned object! console . log ( arr . slice ( 0 )); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript can usually infer the intended type arguments in a generic call, but not always.\r\nFor example, let’s say you wrote a function to combine two arrays:"
                },
                {
                    "type": "code",
                    "code": "ts function combine < Type >( arr1 : Type [], arr2 : Type []): Type [] { return arr1 . concat ( arr2 ); } Try"
                },
                {
                    "type": "p",
                    "text": "Normally it would be an error to call this function with mismatched arrays:"
                },
                {
                    "type": "code",
                    "code": "ts const arr = combine ([ 1 , 2 , 3 ], [ \"hello\" ]); Type 'string' is not assignable to type 'number'. 2322 Type 'string' is not assignable to type 'number'. Try"
                },
                {
                    "type": "p",
                    "text": "If you intended to do this, however, you could manually specify Type :"
                },
                {
                    "type": "code",
                    "code": "ts const arr = combine < string | number >([ 1 , 2 , 3 ], [ \"hello\" ]); Try"
                },
                {
                    "type": "p",
                    "text": "Writing generic functions is fun, and it can be easy to get carried away with type parameters.\r\nHaving too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function. Here are two ways of writing a function that appear similar:"
                },
                {
                    "type": "code",
                    "code": "ts function firstElement1 < Type >( arr : Type []) { return arr [ 0 ]; } function firstElement2 < Type extends any []>( arr : Type ) { return arr [ 0 ]; } // a: number (good) const a = firstElement1 ([ 1 , 2 , 3 ]); // b: any (bad) const b = firstElement2 ([ 1 , 2 , 3 ]); Try"
                },
                {
                    "type": "p",
                    "text": "These might seem identical at first glance, but firstElement1 is a much better way to write this function.\r\nIts inferred return type is Type , but firstElement2 ’s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than “waiting” to resolve the element during a call. Rule : When possible, use the type parameter itself rather than constraining it Here’s another pair of similar functions:"
                },
                {
                    "type": "code",
                    "code": "ts function filter1 < Type >( arr : Type [], func : ( arg : Type ) => boolean ): Type [] { return arr . filter ( func ); } function filter2 < Type , Func extends ( arg : Type ) => boolean >( arr : Type [], func : Func ): Type [] { return arr . filter ( func ); } Try"
                },
                {
                    "type": "p",
                    "text": "We’ve created a type parameter Func that doesn’t relate two values .\r\nThat’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesn’t do anything but make the function harder to read and reason about! Rule : Always use as few type parameters as possible Sometimes we forget that a function might not need to be generic:"
                },
                {
                    "type": "code",
                    "code": "ts function greet < Str extends string >( s : Str ) { console . log ( \"Hello, \" + s ); } greet ( \"world\" ); Try"
                },
                {
                    "type": "p",
                    "text": "We could just as easily have written a simpler version:"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( s : string ) { console . log ( \"Hello, \" + s ); } Try"
                },
                {
                    "type": "p",
                    "text": "Remember, type parameters are for relating the types of multiple values .\r\nIf a type parameter is only used once in the function signature, it’s not relating anything.\r\nThis includes the inferred return type; for example, if Str was part of the inferred return type of greet , it would be relating the argument and return types, so would be used twice despite appearing only once in the written code. Rule : If a type parameter only appears in one location, strongly reconsider if you actually need it Functions in JavaScript often take a variable number of arguments.\r\nFor example, the toFixed method of number takes an optional digit count:"
                },
                {
                    "type": "code",
                    "code": "ts function f ( n : number ) { console . log ( n . toFixed ()); // 0 arguments console . log ( n . toFixed ( 3 )); // 1 argument } Try"
                },
                {
                    "type": "p",
                    "text": "We can model this in TypeScript by marking the parameter as optional with ? :"
                },
                {
                    "type": "code",
                    "code": "ts function f ( x ?: number ) { // ... } f (); // OK f ( 10 ); // OK Try"
                },
                {
                    "type": "p",
                    "text": "Although the parameter is specified as type number , the x parameter will actually have the type number | undefined because unspecified parameters in JavaScript get the value undefined . You can also provide a parameter default :"
                },
                {
                    "type": "code",
                    "code": "ts function f ( x = 10 ) { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Now in the body of f , x will have type number because any undefined argument will be replaced with 10 .\r\nNote that when a parameter is optional, callers can always pass undefined , as this simply simulates a “missing” argument:"
                },
                {
                    "type": "code",
                    "code": "ts // All OK f (); f ( 10 ); f ( undefined ); Try"
                },
                {
                    "type": "p",
                    "text": "Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:"
                },
                {
                    "type": "code",
                    "code": "ts function myForEach ( arr : any [], callback : ( arg : any , index ?: number ) => void ) { for ( let i = 0 ; i < arr . length ; i ++) { callback ( arr [ i ], i ); } } Try"
                },
                {
                    "type": "p",
                    "text": "What people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal:"
                },
                {
                    "type": "code",
                    "code": "ts myForEach ([ 1 , 2 , 3 ], ( a ) => console . log ( a )); myForEach ([ 1 , 2 , 3 ], ( a , i ) => console . log ( a , i )); Try"
                },
                {
                    "type": "p",
                    "text": "What this actually means is that callback might get invoked with one argument .\r\nIn other words, the function definition says that the implementation might look like this:"
                },
                {
                    "type": "code",
                    "code": "ts function myForEach ( arr : any [], callback : ( arg : any , index ?: number ) => void ) { for ( let i = 0 ; i < arr . length ; i ++) { // I don't feel like providing the index today callback ( arr [ i ]); } } Try"
                },
                {
                    "type": "p",
                    "text": "In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:"
                },
                {
                    "type": "code",
                    "code": "ts myForEach ([ 1 , 2 , 3 ], ( a , i ) => { console . log ( i . toFixed ()); 'i' is possibly 'undefined'. 18048 'i' is possibly 'undefined'. }); Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored.\r\nTypeScript behaves the same way.\r\nFunctions with fewer parameters (of the same types) can always take the place of functions with more parameters. Rule : When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument Some JavaScript functions can be called in a variety of argument counts and types.\r\nFor example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month/day/year specification (three arguments). In TypeScript, we can specify a function that can be called in different ways by writing overload signatures .\r\nTo do this, write some number of function signatures (usually two or more), followed by the body of the function:"
                },
                {
                    "type": "code",
                    "code": "ts function makeDate ( timestamp : number ): Date ; function makeDate ( m : number , d : number , y : number ): Date ; function makeDate ( mOrTimestamp : number , d ?: number , y ?: number ): Date { if ( d !== undefined && y !== undefined ) { return new Date ( y , mOrTimestamp , d ); } else { return new Date ( mOrTimestamp ); } } const d1 = makeDate ( 12345678 ); const d2 = makeDate ( 5 , 5 , 5 ); const d3 = makeDate ( 1 , 3 ); No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. 2575 No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. Try"
                },
                {
                    "type": "p",
                    "text": "In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments.\r\nThese first two signatures are called the overload signatures . Then, we wrote a function implementation with a compatible signature.\r\nFunctions have an implementation signature, but this signature can’t be called directly.\r\nEven though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters! This is a common source of confusion.\r\nOften people will write code like this and not understand why there is an error:"
                },
                {
                    "type": "code",
                    "code": "ts function fn ( x : string ): void ; function fn () { // ... } // Expected to be able to call with zero arguments fn (); Expected 1 arguments, but got 0. 2554 Expected 1 arguments, but got 0. Try"
                },
                {
                    "type": "p",
                    "text": "Again, the signature used to write the function body can’t be “seen” from the outside. The signature of the implementation is not visible from the outside.\r\nWhen writing an overloaded function, you should always have two or more signatures above the implementation of the function. The implementation signature must also be compatible with the overload signatures.\r\nFor example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:"
                },
                {
                    "type": "code",
                    "code": "ts function fn ( x : boolean ): void ; // Argument type isn't right function fn ( x : string ): void ; This overload signature is not compatible with its implementation signature. 2394 This overload signature is not compatible with its implementation signature. function fn ( x : boolean ) {} Try"
                },
                {
                    "type": "code",
                    "code": "ts function fn ( x : string ): string ; // Return type isn't right function fn ( x : number ): boolean ; This overload signature is not compatible with its implementation signature. 2394 This overload signature is not compatible with its implementation signature. function fn ( x : string | number ) { return \"oops\" ; } Try"
                },
                {
                    "type": "p",
                    "text": "Like generics, there are a few guidelines you should follow when using function overloads.\r\nFollowing these principles will make your function easier to call, easier to understand, and easier to implement. Let’s consider a function that returns the length of a string or an array:"
                },
                {
                    "type": "code",
                    "code": "ts function len ( s : string ): number ; function len ( arr : any []): number ; function len ( x : any ) { return x . length ; } Try"
                },
                {
                    "type": "p",
                    "text": "This function is fine; we can invoke it with strings or arrays.\r\nHowever, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:"
                },
                {
                    "type": "code",
                    "code": "ts len ( \"\" ); // OK len ([ 0 ]); // OK len ( Math . random () > 0.5 ? \"hello\" : [ 0 ]); No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'. 2769 No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'. Try"
                },
                {
                    "type": "p",
                    "text": "Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:"
                },
                {
                    "type": "code",
                    "code": "ts function len ( x : any [] | string ) { return x . length ; } Try"
                },
                {
                    "type": "p",
                    "text": "This is much better!\r\nCallers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature. Always prefer parameters with union types instead of overloads when possible TypeScript will infer what the this should be in a function via code flow analysis, for example in the following:"
                },
                {
                    "type": "code",
                    "code": "ts const user = { id : 123 , admin : false , becomeAdmin : function () { this . admin = true ; }, }; Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user . this , heh , can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this , and so TypeScript uses that syntax space to let you declare the type for this in the function body."
                },
                {
                    "type": "code",
                    "code": "ts interface DB { filterUsers ( filter : ( this : User ) => boolean ): User []; } const db = getDB (); const admins = db . filterUsers ( function ( this : User ) { return this . admin ; }); Try"
                },
                {
                    "type": "p",
                    "text": "This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior:"
                },
                {
                    "type": "code",
                    "code": "ts interface DB { filterUsers ( filter : ( this : User ) => boolean ): User []; } const db = getDB (); const admins = db . filterUsers (() => this . admin ); The containing arrow function captures the global value of 'this'. Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature. 7041 7017 The containing arrow function captures the global value of 'this'. Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature. Try"
                },
                {
                    "type": "p",
                    "text": "There are some additional types you’ll want to recognize that appear often when working with function types.\r\nLike all types, you can use them everywhere, but these are especially relevant in the context of functions. void represents the return value of functions which don’t return a value.\r\nIt’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements:"
                },
                {
                    "type": "code",
                    "code": "ts // The inferred return type is void function noop () { return ; } Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, a function that doesn’t return any value will implicitly return the value undefined .\r\nHowever, void and undefined are not the same thing in TypeScript.\r\nThere are further details at the end of this chapter. void is not the same as undefined . The special type object refers to any value that isn’t a primitive ( string , number , bigint , boolean , symbol , null , or undefined ).\r\nThis is different from the empty object type { } , and also different from the global type Object .\r\nIt’s very likely you will never use Object . object is not Object . Always use object ! Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object , you can call Object.keys on them, and so on.\r\nFor this reason, function types are considered to be object s in TypeScript. The unknown type represents any value.\r\nThis is similar to the any type, but is safer because it’s not legal to do anything with an unknown value:"
                },
                {
                    "type": "code",
                    "code": "ts function f1 ( a : any ) { a . b (); // OK } function f2 ( a : unknown ) { a . b (); 'a' is of type 'unknown'. 18046 'a' is of type 'unknown'. } Try"
                },
                {
                    "type": "p",
                    "text": "This is useful when describing function types because you can describe functions that accept any value without having any values in your function body. Conversely, you can describe a function that returns a value of unknown type:"
                },
                {
                    "type": "code",
                    "code": "ts function safeParse ( s : string ): unknown { return JSON . parse ( s ); } // Need to be careful with 'obj'! const obj = safeParse ( someRandomString ); Try"
                },
                {
                    "type": "p",
                    "text": "Some functions never return a value:"
                },
                {
                    "type": "code",
                    "code": "ts function fail ( msg : string ): never { throw new Error ( msg ); } Try"
                },
                {
                    "type": "p",
                    "text": "The never type represents values which are never observed.\r\nIn a return type, this means that the function throws an exception or terminates execution of the program. never also appears when TypeScript determines there’s nothing left in a union."
                },
                {
                    "type": "code",
                    "code": "ts function fn ( x : string | number ) { if ( typeof x === \"string\" ) { // do something } else if ( typeof x === \"number\" ) { // do something else } else { x ; // has type 'never'! } } Try"
                },
                {
                    "type": "p",
                    "text": "The global type Function describes properties like bind , call , apply , and others present on all function values in JavaScript.\r\nIt also has the special property that values of type Function can always be called; these calls return any :"
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( f : Function ) { return f ( 1 , 2 , 3 ); } Try"
                },
                {
                    "type": "p",
                    "text": "This is an untyped function call and is generally best avoided because of the unsafe any return type. If you need to accept an arbitrary function but don’t intend to call it, the type () => void is generally safer. Background Reading: Rest Parameters Spread Syntax In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters . A rest parameter appears after all other parameters, and uses the ... syntax:"
                },
                {
                    "type": "code",
                    "code": "ts function multiply ( n : number , ... m : number []) { return m . map (( x ) => n * x ); } // 'a' gets value [10, 20, 30, 40] const a = multiply ( 10 , 1 , 2 , 3 , 4 ); Try"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, the type annotation on these parameters is implicitly any[] instead of any , and any type annotation given must be of the form Array<T> or T[] , or a tuple type (which we’ll learn about later). Conversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax.\r\nFor example, the push method of arrays takes any number of arguments:"
                },
                {
                    "type": "code",
                    "code": "ts const arr1 = [ 1 , 2 , 3 ]; const arr2 = [ 4 , 5 , 6 ]; arr1 . push (... arr2 ); Try"
                },
                {
                    "type": "p",
                    "text": "Note that in general, TypeScript does not assume that arrays are immutable.\r\nThis can lead to some surprising behavior:"
                },
                {
                    "type": "code",
                    "code": "ts // Inferred type is number[] -- \"an array with zero or more numbers\", // not specifically two numbers const args = [ 8 , 5 ]; const angle = Math . atan2 (... args ); A spread argument must either have a tuple type or be passed to a rest parameter. 2556 A spread argument must either have a tuple type or be passed to a rest parameter. Try"
                },
                {
                    "type": "p",
                    "text": "The best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution:"
                },
                {
                    "type": "code",
                    "code": "ts // Inferred as 2-length tuple const args = [ 8 , 5 ] as const ; // OK const angle = Math . atan2 (... args ); Try"
                },
                {
                    "type": "p",
                    "text": "Using rest arguments may require turning on downlevelIteration when targeting older runtimes. You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body.\r\nIn JavaScript, it looks like this:"
                },
                {
                    "type": "code",
                    "code": "js function sum ({ a , b , c }) { console . log ( a + b + c ); } sum ({ a: 10 , b: 3 , c: 9 });"
                },
                {
                    "type": "p",
                    "text": "The type annotation for the object goes after the destructuring syntax:"
                },
                {
                    "type": "code",
                    "code": "ts function sum ({ a , b , c }: { a : number ; b : number ; c : number }) { console . log ( a + b + c ); } Try"
                },
                {
                    "type": "p",
                    "text": "This can look a bit verbose, but you can use a named type here as well:"
                },
                {
                    "type": "code",
                    "code": "ts // Same as prior example type ABC = { a : number ; b : number ; c : number }; function sum ({ a , b , c }: ABC ) { console . log ( a + b + c ); } Try"
                },
                {
                    "type": "p",
                    "text": "The void return type for functions can produce some unusual, but expected behavior. Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type ( type voidFunc = () => void ), when implemented, can return any other value, but it will be ignored. Thus, the following implementations of the type () => void are valid:"
                },
                {
                    "type": "code",
                    "code": "ts type voidFunc = () => void ; const f1 : voidFunc = () => { return true ; }; const f2 : voidFunc = () => true ; const f3 : voidFunc = function () { return true ; }; Try"
                },
                {
                    "type": "p",
                    "text": "And when the return value of one of these functions is assigned to another variable, it will retain the type of void :"
                },
                {
                    "type": "code",
                    "code": "ts const v1 = f1 (); const v2 = f2 (); const v3 = f3 (); Try"
                },
                {
                    "type": "p",
                    "text": "This behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void ."
                },
                {
                    "type": "code",
                    "code": "ts const src = [ 1 , 2 , 3 ]; const dst = [ 0 ]; src . forEach (( el ) => dst . push ( el )); Try"
                },
                {
                    "type": "p",
                    "text": "There is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything."
                },
                {
                    "type": "code",
                    "code": "ts function f2 (): void { // @ts-expect-error return true ; } const f3 = function (): void { // @ts-expect-error return true ; }; Try"
                },
                {
                    "type": "p",
                    "text": "For more on void please refer to these other documentation entries:"
                },
                {
                    "type": "list",
                    "items": [
                        "v2 handbook",
                        "FAQ - “Why are functions returning non-void assignable to function returning void?”"
                    ]
                },
                {
                    "type": "p",
                    "text": "Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects. How TypeScript describes the shapes of JavaScript objects. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
            "title": "TypeScript: Documentation - Generics",
            "content": [
                {
                    "type": "p",
                    "text": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable.\nComponents that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems. In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is generics , that is, being able to create a component that can work over a variety of types rather than a single one.\nThis allows users to consume these components and use their own types. To start off, let’s do the “hello world” of generics: the identity function.\nThe identity function is a function that will return back whatever is passed in.\nYou can think of this in a similar way to the echo command. Without generics, we would either have to give the identity function a specific type:"
                },
                {
                    "type": "code",
                    "code": "ts function identity ( arg : number ): number { return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "Or, we could describe the identity function using the any type:"
                },
                {
                    "type": "code",
                    "code": "ts function identity ( arg : any ): any { return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg , we actually are losing the information about what that type was when the function returns.\nIf we passed in a number, the only information we have is that any type could be returned. Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned.\nHere, we will use a type variable , a special kind of variable that works on types rather than values."
                },
                {
                    "type": "code",
                    "code": "ts function identity < Type >( arg : Type ): Type { return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "We’ve now added a type variable Type to the identity function.\nThis Type allows us to capture the type the user provides (e.g. number ), so that we can use that information later.\nHere, we use Type again as the return type. On inspection, we can now see the same type is used for the argument and the return type.\nThis allows us to traffic that type information in one side of the function and out the other. We say that this version of the identity function is generic, as it works over a range of types.\nUnlike using any , it’s also just as precise (i.e., it doesn’t lose any information) as the first identity function that used numbers for the argument and return type. Once we’ve written the generic identity function, we can call it in one of two ways.\nThe first way is to pass all of the arguments, including the type argument, to the function:"
                },
                {
                    "type": "code",
                    "code": "ts let output = identity < string >( \"myString\" ); let output: string Try"
                },
                {
                    "type": "p",
                    "text": "Here we explicitly set Type to be string as one of the arguments to the function call, denoted using the <> around the arguments rather than () . The second way is also perhaps the most common. Here we use type argument inference — that is, we want the compiler to set the value of Type for us automatically based on the type of the argument we pass in:"
                },
                {
                    "type": "code",
                    "code": "ts let output = identity ( \"myString\" ); let output: string Try"
                },
                {
                    "type": "p",
                    "text": "Notice that we didn’t have to explicitly pass the type in the angle brackets ( <> ); the compiler just looked at the value \"myString\" , and set Type to its type.\nWhile type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples. When you begin to use generics, you’ll notice that when you create generic functions like identity , the compiler will enforce that you use any generically typed parameters in the body of the function correctly.\nThat is, that you actually treat these parameters as if they could be any and all types. Let’s take our identity function from earlier:"
                },
                {
                    "type": "code",
                    "code": "ts function identity < Type >( arg : Type ): Type { return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "What if we want to also log the length of the argument arg to the console with each call?\nWe might be tempted to write this:"
                },
                {
                    "type": "code",
                    "code": "ts function loggingIdentity < Type >( arg : Type ): Type { console . log ( arg . length ); Property 'length' does not exist on type 'Type'. 2339 Property 'length' does not exist on type 'Type'. return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "When we do, the compiler will give us an error that we’re using the .length member of arg , but nowhere have we said that arg has this member.\nRemember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member. Let’s say that we’ve actually intended this function to work on arrays of Type rather than Type directly. Since we’re working with arrays, the .length member should be available.\nWe can describe this just like we would create arrays of other types:"
                },
                {
                    "type": "code",
                    "code": "ts function loggingIdentity < Type >( arg : Type []): Type [] { console . log ( arg . length ); return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "You can read the type of loggingIdentity as “the generic function loggingIdentity takes a type parameter Type , and an argument arg which is an array of Type s, and returns an array of Type s.”\nIf we passed in an array of numbers, we’d get an array of numbers back out, as Type would bind to number .\nThis allows us to use our generic type variable Type as part of the types we’re working with, rather than the whole type, giving us greater flexibility. We can alternatively write the sample example this way:"
                },
                {
                    "type": "code",
                    "code": "ts function loggingIdentity < Type >( arg : Array < Type >): Array < Type > { console . log ( arg . length ); // Array has a .length, so no more error return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "You may already be familiar with this style of type from other languages.\nIn the next section, we’ll cover how you can create your own generic types like Array<Type> . In previous sections, we created generic identity functions that worked over a range of types.\nIn this section, we’ll explore the type of the functions themselves and how to create generic interfaces. The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:"
                },
                {
                    "type": "code",
                    "code": "ts function identity < Type >( arg : Type ): Type { return arg ; } let myIdentity : < Type >( arg : Type ) => Type = identity ; Try"
                },
                {
                    "type": "p",
                    "text": "We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up."
                },
                {
                    "type": "code",
                    "code": "ts function identity < Type >( arg : Type ): Type { return arg ; } let myIdentity : < Input >( arg : Input ) => Input = identity ; Try"
                },
                {
                    "type": "p",
                    "text": "We can also write the generic type as a call signature of an object literal type:"
                },
                {
                    "type": "code",
                    "code": "ts function identity < Type >( arg : Type ): Type { return arg ; } let myIdentity : { < Type >( arg : Type ): Type } = identity ; Try"
                },
                {
                    "type": "p",
                    "text": "Which leads us to writing our first generic interface.\nLet’s take the object literal from the previous example and move it to an interface:"
                },
                {
                    "type": "code",
                    "code": "ts interface GenericIdentityFn { < Type >( arg : Type ): Type ; } function identity < Type >( arg : Type ): Type { return arg ; } let myIdentity : GenericIdentityFn = identity ; Try"
                },
                {
                    "type": "p",
                    "text": "In a similar example, we may want to move the generic parameter to be a parameter of the whole interface.\nThis lets us see what type(s) we’re generic over (e.g. Dictionary<string> rather than just Dictionary ).\nThis makes the type parameter visible to all the other members of the interface."
                },
                {
                    "type": "code",
                    "code": "ts interface GenericIdentityFn < Type > { ( arg : Type ): Type ; } function identity < Type >( arg : Type ): Type { return arg ; } let myIdentity : GenericIdentityFn < number > = identity ; Try"
                },
                {
                    "type": "p",
                    "text": "Notice that our example has changed to be something slightly different.\nInstead of describing a generic function, we now have a non-generic function signature that is a part of a generic type.\nWhen we use GenericIdentityFn , we now will also need to specify the corresponding type argument (here: number ), effectively locking in what the underlying call signature will use.\nUnderstanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic. In addition to generic interfaces, we can also create generic classes.\nNote that it is not possible to create generic enums and namespaces. A generic class has a similar shape to a generic interface.\nGeneric classes have a generic type parameter list in angle brackets ( <> ) following the name of the class."
                },
                {
                    "type": "code",
                    "code": "ts class GenericNumber < NumType > { zeroValue : NumType ; add : ( x : NumType , y : NumType ) => NumType ; } let myGenericNumber = new GenericNumber < number >(); myGenericNumber . zeroValue = 0 ; myGenericNumber . add = function ( x , y ) { return x + y ; }; Try"
                },
                {
                    "type": "p",
                    "text": "This is a pretty literal use of the GenericNumber class, but you may have noticed that nothing is restricting it to only use the number type.\nWe could have instead used string or even more complex objects."
                },
                {
                    "type": "code",
                    "code": "ts let stringNumeric = new GenericNumber < string >(); stringNumeric . zeroValue = \"\" ; stringNumeric . add = function ( x , y ) { return x + y ; }; console . log ( stringNumeric . add ( stringNumeric . zeroValue , \"test\" )); Try"
                },
                {
                    "type": "p",
                    "text": "Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type. As we cover in our section on classes , a class has two sides to its type: the static side and the instance side.\nGeneric classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter. If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have.\nIn our loggingIdentity example, we wanted to be able to access the .length property of arg , but the compiler could not prove that every type had a .length property, so it warns us that we can’t make this assumption."
                },
                {
                    "type": "code",
                    "code": "ts function loggingIdentity < Type >( arg : Type ): Type { console . log ( arg . length ); Property 'length' does not exist on type 'Type'. 2339 Property 'length' does not exist on type 'Type'. return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "Instead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the .length property.\nAs long as the type has this member, we’ll allow it, but it’s required to have at least this member.\nTo do so, we must list our requirement as a constraint on what Type can be. To do so, we’ll create an interface that describes our constraint.\nHere, we’ll create an interface that has a single .length property and then we’ll use this interface and the extends keyword to denote our constraint:"
                },
                {
                    "type": "code",
                    "code": "ts interface Lengthwise { length : number ; } function loggingIdentity < Type extends Lengthwise >( arg : Type ): Type { console . log ( arg . length ); // Now we know it has a .length property, so no more error return arg ; } Try"
                },
                {
                    "type": "p",
                    "text": "Because the generic function is now constrained, it will no longer work over any and all types:"
                },
                {
                    "type": "code",
                    "code": "ts loggingIdentity ( 3 ); Argument of type 'number' is not assignable to parameter of type 'Lengthwise'. 2345 Argument of type 'number' is not assignable to parameter of type 'Lengthwise'. Try"
                },
                {
                    "type": "p",
                    "text": "Instead, we need to pass in values whose type has all the required properties:"
                },
                {
                    "type": "code",
                    "code": "ts loggingIdentity ({ length : 10 , value : 3 }); Try"
                },
                {
                    "type": "p",
                    "text": "You can declare a type parameter that is constrained by another type parameter.\nFor example, here we’d like to get a property from an object given its name.\nWe’d like to ensure that we’re not accidentally grabbing a property that does not exist on the obj , so we’ll place a constraint between the two types:"
                },
                {
                    "type": "code",
                    "code": "ts function getProperty < Type , Key extends keyof Type >( obj : Type , key : Key ) { return obj [ key ]; } let x = { a : 1 , b : 2 , c : 3 , d : 4 }; getProperty ( x , \"a\" ); getProperty ( x , \"m\" ); Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. 2345 Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. Try"
                },
                {
                    "type": "p",
                    "text": "When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,"
                },
                {
                    "type": "code",
                    "code": "ts function create < Type >( c : { new (): Type }): Type { return new c (); } Try"
                },
                {
                    "type": "p",
                    "text": "A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types."
                },
                {
                    "type": "code",
                    "code": "ts class BeeKeeper { hasMask : boolean = true ; } class ZooKeeper { nametag : string = \"Mikle\" ; } class Animal { numLegs : number = 4 ; } class Bee extends Animal { numLegs = 6 ; keeper : BeeKeeper = new BeeKeeper (); } class Lion extends Animal { keeper : ZooKeeper = new ZooKeeper (); } function createInstance < A extends Animal >( c : new () => A ): A { return new c (); } createInstance ( Lion ). keeper . nametag ; createInstance ( Bee ). keeper . hasMask ; Try"
                },
                {
                    "type": "p",
                    "text": "This pattern is used to power the mixins design pattern. By declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new HTMLElement . Calling the function with no arguments generates a HTMLDivElement ; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:"
                },
                {
                    "type": "code",
                    "code": "ts declare function create (): Container < HTMLDivElement , HTMLDivElement []>; declare function create < T extends HTMLElement >( element : T ): Container < T , T []>; declare function create < T extends HTMLElement , U extends HTMLElement >( element : T , children : U [] ): Container < T , U []>; Try"
                },
                {
                    "type": "p",
                    "text": "With generic parameter defaults we can reduce it to:"
                },
                {
                    "type": "code",
                    "code": "ts declare function create < T extends HTMLElement = HTMLDivElement , U extends HTMLElement [] = T []>( element ?: T , children ?: U ): Container < T , U >; const div = create (); const div: Container<HTMLDivElement, HTMLDivElement[]> const p = create ( new HTMLParagraphElement ()); const p: Container<HTMLParagraphElement, HTMLParagraphElement[]> Try"
                },
                {
                    "type": "p",
                    "text": "A generic parameter default follows the following rules:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type parameter is deemed optional if it has a default.",
                        "Required type parameters must not follow optional type parameters.",
                        "Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.",
                        "When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.",
                        "If a default type is specified and inference cannot choose a candidate, the default type is inferred.",
                        "A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.",
                        "A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default."
                    ]
                },
                {
                    "type": "p",
                    "text": "This is an advanced feature for solving a very specific problem, and should only be used in situations where you’ve identified a reason to use it Covariance and contravariance are type theory terms that describe what the relationship between two generic types is.\nHere’s a brief primer on the concept. For example, if you have an interface representing an object that can make a certain type:"
                },
                {
                    "type": "code",
                    "code": "ts interface Producer < T > { make (): T ; }"
                },
                {
                    "type": "p",
                    "text": "We can use a Producer<Cat> where a Producer<Animal> is expected, because a Cat is an Animal .\nThis relationship is called covariance : the relationship from Producer<T> to Producer<U> is the same as the relationship from T to U . Conversely, if you have an interface that can consume a certain type:"
                },
                {
                    "type": "code",
                    "code": "ts interface Consumer < T > { consume : ( arg : T ) => void ; }"
                },
                {
                    "type": "p",
                    "text": "Then we can use a Consumer<Animal> where a Consumer<Cat> is expected, because any function that is capable of accepting an Animal must also be capable of accepting a Cat .\nThis relationship is called contravariance : the relationship from Consumer<T> to Consumer<U> is the same as the relationship from U to T .\nNote the reversal of direction as compared to covariance! This is why contravariance “cancels itself out” but covariance doesn’t. In a structural type system like TypeScript’s, covariance and contravariance are naturally emergent behaviors that follow from the definition of types.\nEven in the absence of generics, we would see covariant (and contravariant) relationships:"
                },
                {
                    "type": "code",
                    "code": "ts interface AnimalProducer { make (): Animal ; } // A CatProducer can be used anywhere an // Animal producer is expected interface CatProducer { make (): Cat ; }"
                },
                {
                    "type": "p",
                    "text": "TypeScript has a structural type system, so when comparing two types, e.g. to see if a Producer<Cat> can be used where a Producer<Animal> is expected, the usual algorithm would be structurally expand both of those definitions, and compare their structures.\nHowever, variance allows for an extremely useful optimization: if Producer<T> is covariant on T , then we can simply check Cat and Animal instead, as we know they’ll have the same relationship as Producer<Cat> and Producer<Animal> . Note that this logic can only be used when we’re examining two instantiations of the same type.\nIf we have a Producer<T> and a FastProducer<U> , there’s no guarantee that T and U necessarily refer to the same positions in these types, so this check will always be performed structurally. Because variance is a naturally emergent property of structural types, TypeScript automatically infers the variance of every generic type. In extremely rare cases involving certain kinds of circular types, this measurement can be inaccurate.\nIf this happens, you can add a variance annotation to a type parameter to force a particular variance:"
                },
                {
                    "type": "code",
                    "code": "ts // Contravariant annotation interface Consumer < in T > { consume : ( arg : T ) => void ; } // Covariant annotation interface Producer < out T > { make (): T ; } // Invariant annotation interface ProducerConsumer < in out T > { consume : ( arg : T ) => void ; make (): T ; }"
                },
                {
                    "type": "p",
                    "text": "Only do this if you are writing the same variance that should occur structurally. Never write a variance annotation that doesn’t match the structural variance! It’s critical to reinforce that variance annotations are only in effect during an instantiation-based comparison.\nThey have no effect during a structural comparison.\nFor example, you can’t use variance annotations to “force” a type to be actually invariant:"
                },
                {
                    "type": "code",
                    "code": "ts // DON'T DO THIS - variance annotation // does not match structural behavior interface Producer < in out T > { make (): T ; } // Not a type error -- this is a structural // comparison, so variance annotations are // not in effect const p : Producer < string | number > = { make (): number { return 42 ; } }"
                },
                {
                    "type": "p",
                    "text": "Here, the object literal’s make function returns number , which we might expect to cause an error because number isn’t string | number .\nHowever, this isn’t an instantiation-based comparison, because the object literal is an anonymous type, not a Producer<string | number> . Variance annotations don’t change structural behavior and are only consulted in specific situations It’s very important to only write variance annotations if you absolutely know why you’re doing it, what their limitations are, and when they aren’t in effect.\nWhether TypeScript uses an instantiation-based comparison or structural comparison is not a specified behavior and may change from version to version for correctness or performance reasons, so you should only ever write variance annotations when they match the structural behavior of a type.\nDon’t use variance annotations to try to “force” a particular variance; this will cause unpredictable behavior in your code. Do NOT write variance annotations unless they match the structural behavior of a type Remember, TypeScript can automatically infer variance from your generic types.\nIt’s almost never necessary to write a variance annotation, and you should only do so when you’ve identified a specific need.\nVariance annotations do not change the structural behavior of a type, and depending on the situation, you might see a structural comparison made when you expected an instantiation-based comparison.\nVariance annotations can’t be used to modify how types behave in these structural contexts, and shouldn’t be written unless the annotation is the same as the structural definition.\nBecause this is difficult to get right, and TypeScript can correctly infer variance in the vast majority of cases, you should not find yourself writing variance annotations in normal code. Don’t try to use variance annotations to change typechecking behavior; this is not what they are for You may find temporary variance annotations useful in a “type debugging” situation, because variance annotations are checked.\nTypeScript will issue an error if the annotated variance is identifiably wrong:"
                },
                {
                    "type": "code",
                    "code": "ts // Error, this interface is definitely contravariant on T interface Foo < out T > { consume : ( arg : T ) => void ; }"
                },
                {
                    "type": "p",
                    "text": "However, variance annotations are allowed to be stricter (e.g. in out is valid if the actual variance is covariant).\nBe sure to remove your variance annotations once you’re done debugging. Lastly, if you’re trying to maximize your typechecking performance, and have run a profiler, and have identified a specific type that’s slow, and have identified variance inference specifically is slow, and have carefully validated the variance annotation you want to write, you may see a small performance benefit in extraordinarily complex types by adding variance annotations. Don’t try to use variance annotations to change typechecking behavior; this is not what they are for An overview of the ways in which you can create more types from existing types. Using the keyof operator in type contexts. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html",
            "title": "TypeScript: Documentation - Indexed Access Types",
            "content": [
                {
                    "type": "p",
                    "text": "We can use an indexed access type to look up a specific property on another type:"
                },
                {
                    "type": "code",
                    "code": "ts type Person = { age : number ; name : string ; alive : boolean }; type Age = Person [ \"age\" ]; type Age = number Try"
                },
                {
                    "type": "p",
                    "text": "The indexing type is itself a type, so we can use unions, keyof , or other types entirely:"
                },
                {
                    "type": "code",
                    "code": "ts type I1 = Person [ \"age\" | \"name\" ]; type I1 = string | number type I2 = Person [ keyof Person ]; type I2 = string | number | boolean type AliveOrName = \"alive\" | \"name\" ; type I3 = Person [ AliveOrName ]; type I3 = string | boolean Try"
                },
                {
                    "type": "p",
                    "text": "You’ll even see an error if you try to index a property that doesn’t exist:"
                },
                {
                    "type": "code",
                    "code": "ts type I1 = Person [ \"alve\" ]; Property 'alve' does not exist on type 'Person'. 2339 Property 'alve' does not exist on type 'Person'. Try"
                },
                {
                    "type": "p",
                    "text": "Another example of indexing with an arbitrary type is using number to get the type of an array’s elements.\nWe can combine this with typeof to conveniently capture the element type of an array literal:"
                },
                {
                    "type": "code",
                    "code": "ts const MyArray = [ { name : \"Alice\" , age : 15 }, { name : \"Bob\" , age : 23 }, { name : \"Eve\" , age : 38 }, ]; type Person = typeof MyArray [ number ]; type Person = {\n    name: string;\n    age: number;\n} type Age = typeof MyArray [ number ][ \"age\" ]; type Age = number // Or type Age2 = Person [ \"age\" ]; type Age2 = number Try"
                },
                {
                    "type": "p",
                    "text": "You can only use types when indexing, meaning you can’t use a const to make a variable reference:"
                },
                {
                    "type": "code",
                    "code": "ts const key = \"age\" ; type Age = Person [ key ]; Type 'key' cannot be used as an index type. 'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'? 2538 2749 Type 'key' cannot be used as an index type. 'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'? Try"
                },
                {
                    "type": "p",
                    "text": "However, you can use a type alias for a similar style of refactor:"
                },
                {
                    "type": "code",
                    "code": "ts type key = \"age\" ; type Age = Person [ key ]; Try"
                },
                {
                    "type": "p",
                    "text": "Using the typeof operator in type contexts. Create types which act like if statements in the type system. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html",
            "title": "TypeScript: Documentation - Keyof Type Operator",
            "content": [
                {
                    "type": "p",
                    "text": "The keyof operator takes an object type and produces a string or numeric literal union of its keys.\nThe following type P is the same type as type P = \"x\" | \"y\" :"
                },
                {
                    "type": "code",
                    "code": "ts type Point = { x : number ; y : number }; type P = keyof Point ; type P = keyof Point Try"
                },
                {
                    "type": "p",
                    "text": "If the type has a string or number index signature, keyof will return those types instead:"
                },
                {
                    "type": "code",
                    "code": "ts type Arrayish = { [ n : number ]: unknown }; type A = keyof Arrayish ; type A = number type Mapish = { [ k : string ]: boolean }; type M = keyof Mapish ; type M = string | number Try"
                },
                {
                    "type": "p",
                    "text": "Note that in this example, M is string | number — this is because JavaScript object keys are always coerced to a string, so obj[0] is always the same as obj[\"0\"] . keyof types become especially useful when combined with mapped types, which we’ll learn more about later. Using the typeof operator in type contexts. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html",
            "title": "TypeScript: Documentation - Mapped Types",
            "content": [
                {
                    "type": "p",
                    "text": "When you don’t want to repeat yourself, sometimes a type needs to be based on another type. Mapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:"
                },
                {
                    "type": "code",
                    "code": "ts type OnlyBoolsAndHorses = { [ key : string ]: boolean | Horse ; }; const conforms : OnlyBoolsAndHorses = { del : true , rodney : false , }; Try"
                },
                {
                    "type": "p",
                    "text": "A mapped type is a generic type which uses a union of PropertyKey s (frequently created via a keyof ) to iterate through keys to create a type:"
                },
                {
                    "type": "code",
                    "code": "ts type OptionsFlags < Type > = { [ Property in keyof Type ]: boolean ; }; Try"
                },
                {
                    "type": "p",
                    "text": "In this example, OptionsFlags will take all the properties from the type Type and change their values to be a boolean."
                },
                {
                    "type": "code",
                    "code": "ts type Features = { darkMode : () => void ; newUserProfile : () => void ; }; type FeatureOptions = OptionsFlags < Features >; type FeatureOptions = {\n    darkMode: boolean;\n    newUserProfile: boolean;\n} Try"
                },
                {
                    "type": "p",
                    "text": "There are two additional modifiers which can be applied during mapping: readonly and ? which affect mutability and optionality respectively. You can remove or add these modifiers by prefixing with - or + . If you don’t add a prefix, then + is assumed."
                },
                {
                    "type": "code",
                    "code": "ts // Removes 'readonly' attributes from a type's properties type CreateMutable < Type > = { - readonly [ Property in keyof Type ]: Type [ Property ]; }; type LockedAccount = { readonly id : string ; readonly name : string ; }; type UnlockedAccount = CreateMutable < LockedAccount >; type UnlockedAccount = {\n    id: string;\n    name: string;\n} Try"
                },
                {
                    "type": "code",
                    "code": "ts // Removes 'optional' attributes from a type's properties type Concrete < Type > = { [ Property in keyof Type ]-?: Type [ Property ]; }; type MaybeUser = { id : string ; name ?: string ; age ?: number ; }; type User = Concrete < MaybeUser >; type User = {\n    id: string;\n    name: string;\n    age: number;\n} Try"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 4.1 and onwards, you can re-map keys in mapped types with an as clause in a mapped type:"
                },
                {
                    "type": "code",
                    "code": "ts type MappedTypeWithNewProperties < Type > = { [ Properties in keyof Type as NewKeyType ]: Type [ Properties ] }"
                },
                {
                    "type": "p",
                    "text": "You can leverage features like template literal types to create new property names from prior ones:"
                },
                {
                    "type": "code",
                    "code": "ts type Getters < Type > = { [ Property in keyof Type as `get ${ Capitalize < string & Property > } ` ]: () => Type [ Property ] }; interface Person { name : string ; age : number ; location : string ; } type LazyPerson = Getters < Person >; type LazyPerson = {\n    getName: () => string;\n    getAge: () => number;\n    getLocation: () => string;\n} Try"
                },
                {
                    "type": "p",
                    "text": "You can filter out keys by producing never via a conditional type:"
                },
                {
                    "type": "code",
                    "code": "ts // Remove the 'kind' property type RemoveKindField < Type > = { [ Property in keyof Type as Exclude < Property , \"kind\" >]: Type [ Property ] }; interface Circle { kind : \"circle\" ; radius : number ; } type KindlessCircle = RemoveKindField < Circle >; type KindlessCircle = {\n    radius: number;\n} Try"
                },
                {
                    "type": "p",
                    "text": "You can map over arbitrary unions, not just unions of string | number | symbol , but unions of any type:"
                },
                {
                    "type": "code",
                    "code": "ts type EventConfig < Events extends { kind : string }> = { [ E in Events as E [ \"kind\" ]]: ( event : E ) => void ; } type SquareEvent = { kind : \"square\" , x : number , y : number }; type CircleEvent = { kind : \"circle\" , radius : number }; type Config = EventConfig < SquareEvent | CircleEvent > type Config = {\n    square: (event: SquareEvent) => void;\n    circle: (event: CircleEvent) => void;\n} Try"
                },
                {
                    "type": "p",
                    "text": "Mapped types work well with other features in this type manipulation section, for example here is a mapped type using a conditional type which returns either a true or false depending on whether an object has the property pii set to the literal true :"
                },
                {
                    "type": "code",
                    "code": "ts type ExtractPII < Type > = { [ Property in keyof Type ]: Type [ Property ] extends { pii : true } ? true : false ; }; type DBFields = { id : { format : \"incrementing\" }; name : { type : string ; pii : true }; }; type ObjectsNeedingGDPRDeletion = ExtractPII < DBFields >; type ObjectsNeedingGDPRDeletion = {\n    id: false;\n    name: true;\n} Try"
                },
                {
                    "type": "p",
                    "text": "Create types which act like if statements in the type system. Generating mapping types which change properties via template literal strings. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html",
            "title": "TypeScript: Documentation - Narrowing",
            "content": [
                {
                    "type": "p",
                    "text": "Imagine we have a function called padLeft ."
                },
                {
                    "type": "code",
                    "code": "ts function padLeft ( padding : number | string , input : string ): string { throw new Error ( \"Not implemented yet!\" ); } Try"
                },
                {
                    "type": "p",
                    "text": "If padding is a number , it will treat that as the number of spaces we want to prepend to input .\nIf padding is a string , it should just prepend padding to input .\nLet’s try to implement the logic for when padLeft is passed a number for padding ."
                },
                {
                    "type": "code",
                    "code": "ts function padLeft ( padding : number | string , input : string ): string { return \" \" . repeat ( padding ) + input ; Argument of type 'string | number' is not assignable to parameter of type 'number'.\n  Type 'string' is not assignable to type 'number'. 2345 Argument of type 'string | number' is not assignable to parameter of type 'number'.\n  Type 'string' is not assignable to type 'number'. } Try"
                },
                {
                    "type": "p",
                    "text": "Uh-oh, we’re getting an error on padding .\nTypeScript is warning us that we’re passing a value with type number | string to the repeat function, which only accepts a number , and it’s right.\nIn other words, we haven’t explicitly checked if padding is a number first, nor are we handling the case where it’s a string , so let’s do exactly that."
                },
                {
                    "type": "code",
                    "code": "ts function padLeft ( padding : number | string , input : string ): string { if ( typeof padding === \"number\" ) { return \" \" . repeat ( padding ) + input ; } return padding + input ; } Try"
                },
                {
                    "type": "p",
                    "text": "If this mostly looks like uninteresting JavaScript code, that’s sort of the point.\nApart from the annotations we put in place, this TypeScript code looks like JavaScript.\nThe idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety. While it might not look like much, there’s actually a lot going on under the covers here.\nMuch like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like if/else , conditional ternaries, loops, truthiness checks, etc., which can all affect those types. Within our if check, TypeScript sees typeof padding === \"number\" and understands that as a special form of code called a type guard .\nTypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position.\nIt looks at these special checks (called type guards ) and assignments, and the process of refining types to more specific types than declared is called narrowing .\nIn many editors we can observe these types as they change, and we’ll even do so in our examples."
                },
                {
                    "type": "code",
                    "code": "ts function padLeft ( padding : number | string , input : string ): string { if ( typeof padding === \"number\" ) { return \" \" . repeat ( padding ) + input ; (parameter) padding: number } return padding + input ; (parameter) padding: string } Try"
                },
                {
                    "type": "p",
                    "text": "There are a couple of different constructs TypeScript understands for narrowing. As we’ve seen, JavaScript supports a typeof operator which can give very basic information about the type of values we have at runtime.\nTypeScript expects this to return a certain set of strings:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"string\"",
                        "\"number\"",
                        "\"bigint\"",
                        "\"boolean\"",
                        "\"symbol\"",
                        "\"undefined\"",
                        "\"object\"",
                        "\"function\""
                    ]
                },
                {
                    "type": "p",
                    "text": "Like we saw with padLeft , this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches. In TypeScript, checking against the value returned by typeof is a type guard.\nBecause TypeScript encodes how typeof operates on different values, it knows about some of its quirks in JavaScript.\nFor example, notice that in the list above, typeof doesn’t return the string null .\nCheck out the following example:"
                },
                {
                    "type": "code",
                    "code": "ts function printAll ( strs : string | string [] | null ) { if ( typeof strs === \"object\" ) { for ( const s of strs ) { 'strs' is possibly 'null'. 18047 'strs' is possibly 'null'. console . log ( s ); } } else if ( typeof strs === \"string\" ) { console . log ( strs ); } else { // do nothing } } Try"
                },
                {
                    "type": "p",
                    "text": "In the printAll function, we try to check if strs is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript).\nBut it turns out that in JavaScript, typeof null is actually \"object\" !\nThis is one of those unfortunate accidents of history. Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that strs was only narrowed down to string[] | null instead of just string[] . This might be a good segue into what we’ll call “truthiness” checking. Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript. In JavaScript, we can use any expression in conditionals, && s, || s, if statements, Boolean negations ( ! ), and more.\nAs an example, if statements don’t expect their condition to always have the type boolean ."
                },
                {
                    "type": "code",
                    "code": "ts function getUsersOnlineMessage ( numUsersOnline : number ) { if ( numUsersOnline ) { return `There are ${ numUsersOnline } online now!` ; } return \"Nobody's here. :(\" ; } Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, constructs like if first “coerce” their conditions to boolean s to make sense of them, and then choose their branches depending on whether the result is true or false .\nValues like"
                },
                {
                    "type": "list",
                    "items": [
                        "0",
                        "NaN",
                        "\"\" (the empty string)",
                        "0n (the bigint version of zero)",
                        "null",
                        "undefined"
                    ]
                },
                {
                    "type": "p",
                    "text": "all coerce to false , and other values get coerced to true .\nYou can always coerce values to boolean s by running them through the Boolean function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type true , while inferring the first as type boolean .)"
                },
                {
                    "type": "code",
                    "code": "ts // both of these result in 'true' Boolean ( \"hello\" ); // type: boolean, value: true !! \"world\" ; // type: true,    value: true This kind of expression is always truthy. 2872 This kind of expression is always truthy. Try"
                },
                {
                    "type": "p",
                    "text": "It’s fairly popular to leverage this behavior, especially for guarding against values like null or undefined .\nAs an example, let’s try using it for our printAll function."
                },
                {
                    "type": "code",
                    "code": "ts function printAll ( strs : string | string [] | null ) { if ( strs && typeof strs === \"object\" ) { for ( const s of strs ) { console . log ( s ); } } else if ( typeof strs === \"string\" ) { console . log ( strs ); } } Try"
                },
                {
                    "type": "p",
                    "text": "You’ll notice that we’ve gotten rid of the error above by checking if strs is truthy.\nThis at least prevents us from dreaded errors when we run our code like:"
                },
                {
                    "type": "code",
                    "code": "txt TypeError: null is not iterable"
                },
                {
                    "type": "p",
                    "text": "Keep in mind though that truthiness checking on primitives can often be error prone.\nAs an example, consider a different attempt at writing printAll"
                },
                {
                    "type": "code",
                    "code": "ts function printAll ( strs : string | string [] | null ) { // !!!!!!!!!!!!!!!! //  DON'T DO THIS! //   KEEP READING // !!!!!!!!!!!!!!!! if ( strs ) { if ( typeof strs === \"object\" ) { for ( const s of strs ) { console . log ( s ); } } else if ( typeof strs === \"string\" ) { console . log ( strs ); } } } Try"
                },
                {
                    "type": "p",
                    "text": "We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly. TypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript.\nTypeScript can often help you catch bugs early on, but if you choose to do nothing with a value, there’s only so much that it can do without being overly prescriptive.\nIf you want, you can make sure you handle situations like these with a linter. One last word on narrowing by truthiness is that Boolean negations with ! filter out from negated branches."
                },
                {
                    "type": "code",
                    "code": "ts function multiplyAll ( values : number [] | undefined , factor : number ): number [] | undefined { if (! values ) { return values ; } else { return values . map (( x ) => x * factor ); } } Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript also uses switch statements and equality checks like === , !== , == , and != to narrow types.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts function example ( x : string | number , y : string | boolean ) { if ( x === y ) { // We can now call any 'string' method on 'x' or 'y'. x . toUpperCase (); (method) String.toUpperCase(): string y . toLowerCase (); (method) String.toLowerCase(): string } else { console . log ( x ); (parameter) x: string | number console . log ( y ); (parameter) y: string | boolean } } Try"
                },
                {
                    "type": "p",
                    "text": "When we checked that x and y are both equal in the above example, TypeScript knew their types also had to be equal.\nSince string is the only common type that both x and y could take on, TypeScript knows that x and y must be string s in the first branch. Checking against specific literal values (as opposed to variables) works also.\nIn our section about truthiness narrowing, we wrote a printAll function which was error-prone because it accidentally didn’t handle empty strings properly.\nInstead we could have done a specific check to block out null s, and TypeScript still correctly removes null from the type of strs ."
                },
                {
                    "type": "code",
                    "code": "ts function printAll ( strs : string | string [] | null ) { if ( strs !== null ) { if ( typeof strs === \"object\" ) { for ( const s of strs ) { (parameter) strs: string[] console . log ( s ); } } else if ( typeof strs === \"string\" ) { console . log ( strs ); (parameter) strs: string } } } Try"
                },
                {
                    "type": "p",
                    "text": "JavaScript’s looser equality checks with == and != also get narrowed correctly.\nIf you’re unfamiliar, checking whether something == null actually not only checks whether it is specifically the value null - it also checks whether it’s potentially undefined .\nThe same applies to == undefined : it checks whether a value is either null or undefined ."
                },
                {
                    "type": "code",
                    "code": "ts interface Container { value : number | null | undefined ; } function multiplyValue ( container : Container , factor : number ) { // Remove both 'null' and 'undefined' from the type. if ( container . value != null ) { console . log ( container . value ); (property) Container.value: number // Now we can safely multiply 'container.value'. container . value *= factor ; } } Try"
                },
                {
                    "type": "p",
                    "text": "JavaScript has an operator for determining if an object or its prototype chain has a property with a name: the in operator.\nTypeScript takes this into account as a way to narrow down potential types. For example, with the code: \"value\" in x . where \"value\" is a string literal and x is a union type.\nThe “true” branch narrows x ’s types which have either an optional or required property value , and the “false” branch narrows to types which have an optional or missing property value ."
                },
                {
                    "type": "code",
                    "code": "ts type Fish = { swim : () => void }; type Bird = { fly : () => void }; function move ( animal : Fish | Bird ) { if ( \"swim\" in animal ) { return animal . swim (); } return animal . fly (); } Try"
                },
                {
                    "type": "p",
                    "text": "To reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the in check:"
                },
                {
                    "type": "code",
                    "code": "ts type Fish = { swim : () => void }; type Bird = { fly : () => void }; type Human = { swim ?: () => void ; fly ?: () => void }; function move ( animal : Fish | Bird | Human ) { if ( \"swim\" in animal ) { animal ; (parameter) animal: Fish | Human } else { animal ; (parameter) animal: Bird | Human } } Try"
                },
                {
                    "type": "p",
                    "text": "JavaScript has an operator for checking whether or not a value is an “instance” of another value.\nMore specifically, in JavaScript x instanceof Foo checks whether the prototype chain of x contains Foo.prototype .\nWhile we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with new .\nAs you might have guessed, instanceof is also a type guard, and TypeScript narrows in branches guarded by instanceof s."
                },
                {
                    "type": "code",
                    "code": "ts function logValue ( x : Date | string ) { if ( x instanceof Date ) { console . log ( x . toUTCString ()); (parameter) x: Date } else { console . log ( x . toUpperCase ()); (parameter) x: string } } Try"
                },
                {
                    "type": "p",
                    "text": "As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately."
                },
                {
                    "type": "code",
                    "code": "ts let x = Math . random () < 0.5 ? 10 : \"hello world!\" ; let x: string | number x = 1 ; console . log ( x ); let x: number x = \"goodbye!\" ; console . log ( x ); let x: string Try"
                },
                {
                    "type": "p",
                    "text": "Notice that each of these assignments is valid.\nEven though the observed type of x changed to number after our first assignment, we were still able to assign a string to x .\nThis is because the declared type of x - the type that x started with - is string | number , and assignability is always checked against the declared type. If we’d assigned a boolean to x , we’d have seen an error since that wasn’t part of the declared type."
                },
                {
                    "type": "code",
                    "code": "ts let x = Math . random () < 0.5 ? 10 : \"hello world!\" ; let x: string | number x = 1 ; console . log ( x ); let x: number x = true ; Type 'boolean' is not assignable to type 'string | number'. 2322 Type 'boolean' is not assignable to type 'string | number'. console . log ( x ); let x: string | number Try"
                },
                {
                    "type": "p",
                    "text": "Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches.\nBut there’s a bit more going on than just walking up from every variable and looking for type guards in if s, while s, conditionals, etc.\nFor example"
                },
                {
                    "type": "code",
                    "code": "ts function padLeft ( padding : number | string , input : string ) { if ( typeof padding === \"number\" ) { return \" \" . repeat ( padding ) + input ; } return padding + input ; } Try"
                },
                {
                    "type": "p",
                    "text": "padLeft returns from within its first if block.\nTypeScript was able to analyze this code and see that the rest of the body ( return padding + input; ) is unreachable in the case where padding is a number .\nAs a result, it was able to remove number from the type of padding (narrowing from string | number to string ) for the rest of the function. This analysis of code based on reachability is called control flow analysis , and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments.\nWhen a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point."
                },
                {
                    "type": "code",
                    "code": "ts function example () { let x : string | number | boolean ; x = Math . random () < 0.5 ; console . log ( x ); let x: boolean if ( Math . random () < 0.5 ) { x = \"hello\" ; console . log ( x ); let x: string } else { x = 100 ; console . log ( x ); let x: number } return x ; let x: string | number } Try"
                },
                {
                    "type": "p",
                    "text": "We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code. To define a user-defined type guard, we simply need to define a function whose return type is a type predicate :"
                },
                {
                    "type": "code",
                    "code": "ts function isFish ( pet : Fish | Bird ): pet is Fish { return ( pet as Fish ). swim !== undefined ; } Try"
                },
                {
                    "type": "p",
                    "text": "pet is Fish is our type predicate in this example.\nA predicate takes the form parameterName is Type , where parameterName must be the name of a parameter from the current function signature. Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible."
                },
                {
                    "type": "code",
                    "code": "ts // Both calls to 'swim' and 'fly' are now okay. let pet = getSmallPet (); if ( isFish ( pet )) { pet . swim (); } else { pet . fly (); } Try"
                },
                {
                    "type": "p",
                    "text": "Notice that TypeScript not only knows that pet is a Fish in the if branch;\nit also knows that in the else branch, you don’t have a Fish , so you must have a Bird . You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish :"
                },
                {
                    "type": "code",
                    "code": "ts const zoo : ( Fish | Bird )[] = [ getSmallPet (), getSmallPet (), getSmallPet ()]; const underWater1 : Fish [] = zoo . filter ( isFish ); // or, equivalently const underWater2 : Fish [] = zoo . filter ( isFish ) as Fish []; // The predicate may need repeating for more complex examples const underWater3 : Fish [] = zoo . filter (( pet ): pet is Fish => { if ( pet . name === \"sharkey\" ) return false ; return isFish ( pet ); }); Try"
                },
                {
                    "type": "p",
                    "text": "In addition, classes can use this is Type to narrow their type. Types can also be narrowed using Assertion functions . Most of the examples we’ve looked at so far have focused around narrowing single variables with simple types like string , boolean , and number .\nWhile this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures. For some motivation, let’s imagine we’re trying to encode shapes like circles and squares.\nCircles keep track of their radiuses and squares keep track of their side lengths.\nWe’ll use a field called kind to tell which shape we’re dealing with.\nHere’s a first attempt at defining Shape ."
                },
                {
                    "type": "code",
                    "code": "ts interface Shape { kind : \"circle\" | \"square\" ; radius ?: number ; sideLength ?: number ; } Try"
                },
                {
                    "type": "p",
                    "text": "Notice we’re using a union of string literal types: \"circle\" and \"square\" to tell us whether we should treat the shape as a circle or square respectively.\nBy using \"circle\" | \"square\" instead of string , we can avoid misspelling issues."
                },
                {
                    "type": "code",
                    "code": "ts function handleShape ( shape : Shape ) { // oops! if ( shape . kind === \"rect\" ) { This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap. 2367 This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap. // ... } } Try"
                },
                {
                    "type": "p",
                    "text": "We can write a getArea function that applies the right logic based on if it’s dealing with a circle or square.\nWe’ll first try dealing with circles."
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { return Math . PI * shape . radius ** 2 ; 'shape.radius' is possibly 'undefined'. 18048 'shape.radius' is possibly 'undefined'. } Try"
                },
                {
                    "type": "p",
                    "text": "Under strictNullChecks that gives us an error - which is appropriate since radius might not be defined.\nBut what if we perform the appropriate checks on the kind property?"
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { if ( shape . kind === \"circle\" ) { return Math . PI * shape . radius ** 2 ; 'shape.radius' is possibly 'undefined'. 18048 'shape.radius' is possibly 'undefined'. } } Try"
                },
                {
                    "type": "p",
                    "text": "Hmm, TypeScript still doesn’t know what to do here.\nWe’ve hit a point where we know more about our values than the type checker does.\nWe could try to use a non-null assertion (a ! after shape.radius ) to say that radius is definitely present."
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { if ( shape . kind === \"circle\" ) { return Math . PI * shape . radius ! ** 2 ; } } Try"
                },
                {
                    "type": "p",
                    "text": "But this doesn’t feel ideal.\nWe had to shout a bit at the type-checker with those non-null assertions ( ! ) to convince it that shape.radius was defined, but those assertions are error-prone if we start to move code around.\nAdditionally, outside of strictNullChecks we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them).\nWe can definitely do better. The problem with this encoding of Shape is that the type-checker doesn’t have any way to know whether or not radius or sideLength are present based on the kind property.\nWe need to communicate what we know to the type checker.\nWith that in mind, let’s take another swing at defining Shape ."
                },
                {
                    "type": "code",
                    "code": "ts interface Circle { kind : \"circle\" ; radius : number ; } interface Square { kind : \"square\" ; sideLength : number ; } type Shape = Circle | Square ; Try"
                },
                {
                    "type": "p",
                    "text": "Here, we’ve properly separated Shape out into two types with different values for the kind property, but radius and sideLength are declared as required properties in their respective types. Let’s see what happens here when we try to access the radius of a Shape ."
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { return Math . PI * shape . radius ** 2 ; Property 'radius' does not exist on type 'Shape'.\n  Property 'radius' does not exist on type 'Square'. 2339 Property 'radius' does not exist on type 'Shape'.\n  Property 'radius' does not exist on type 'Square'. } Try"
                },
                {
                    "type": "p",
                    "text": "Like with our first definition of Shape , this is still an error.\nWhen radius was optional, we got an error (with strictNullChecks enabled) because TypeScript couldn’t tell whether the property was present.\nNow that Shape is a union, TypeScript is telling us that shape might be a Square , and Square s don’t have radius defined on them!\nBoth interpretations are correct, but only the union encoding of Shape will cause an error regardless of how strictNullChecks is configured. But what if we tried checking the kind property again?"
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { if ( shape . kind === \"circle\" ) { return Math . PI * shape . radius ** 2 ; (parameter) shape: Circle } } Try"
                },
                {
                    "type": "p",
                    "text": "That got rid of the error!\nWhen every type in a union contains a common property with literal types, TypeScript considers that to be a discriminated union , and can narrow out the members of the union. In this case, kind was that common property (which is what’s considered a discriminant property of Shape ).\nChecking whether the kind property was \"circle\" got rid of every type in Shape that didn’t have a kind property with the type \"circle\" .\nThat narrowed shape down to the type Circle . The same checking works with switch statements as well.\nNow we can try to write our complete getArea without any pesky ! non-null assertions."
                },
                {
                    "type": "code",
                    "code": "ts function getArea ( shape : Shape ) { switch ( shape . kind ) { case \"circle\" : return Math . PI * shape . radius ** 2 ; (parameter) shape: Circle case \"square\" : return shape . sideLength ** 2 ; (parameter) shape: Square } } Try"
                },
                {
                    "type": "p",
                    "text": "The important thing here was the encoding of Shape .\nCommunicating the right information to TypeScript - that Circle and Square were really two separate types with specific kind fields - was crucial.\nDoing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise.\nFrom there, the type system was able to do the “right” thing and figure out the types in each branch of our switch statement. As an aside, try playing around with the above example and remove some of the return keywords.\nYou’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a switch statement. Discriminated unions are useful for more than just talking about circles and squares.\nThey’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework. When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left.\nIn those cases, TypeScript will use a never type to represent a state which shouldn’t exist. The never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement. For example, adding a default to our getArea function which tries to assign the shape to never will not raise an error when every possible case has been handled."
                },
                {
                    "type": "code",
                    "code": "ts type Shape = Circle | Square ; function getArea ( shape : Shape ) { switch ( shape . kind ) { case \"circle\" : return Math . PI * shape . radius ** 2 ; case \"square\" : return shape . sideLength ** 2 ; default : const _exhaustiveCheck : never = shape ; return _exhaustiveCheck ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Adding a new member to the Shape union, will cause a TypeScript error:"
                },
                {
                    "type": "code",
                    "code": "ts interface Triangle { kind : \"triangle\" ; sideLength : number ; } type Shape = Circle | Square | Triangle ; function getArea ( shape : Shape ) { switch ( shape . kind ) { case \"circle\" : return Math . PI * shape . radius ** 2 ; case \"square\" : return shape . sideLength ** 2 ; default : const _exhaustiveCheck : never = shape ; Type 'Triangle' is not assignable to type 'never'. 2322 Type 'Triangle' is not assignable to type 'never'. return _exhaustiveCheck ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Learn about how Functions work in TypeScript. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
            "title": "TypeScript: Documentation - Object Types",
            "content": [
                {
                    "type": "p",
                    "text": "In JavaScript, the fundamental way that we group and pass around data is through objects.\nIn TypeScript, we represent those through object types . As we’ve seen, they can be anonymous:"
                },
                {
                    "type": "code",
                    "code": "ts function greet ( person : { name : string ; age : number }) { return \"Hello \" + person . name ; } Try"
                },
                {
                    "type": "p",
                    "text": "or they can be named by using either an interface:"
                },
                {
                    "type": "code",
                    "code": "ts interface Person { name : string ; age : number ; } function greet ( person : Person ) { return \"Hello \" + person . name ; } Try"
                },
                {
                    "type": "code",
                    "code": "ts type Person = { name : string ; age : number ; }; function greet ( person : Person ) { return \"Hello \" + person . name ; } Try"
                },
                {
                    "type": "p",
                    "text": "In all three examples above, we’ve written functions that take objects that contain the property name (which must be a string ) and age (which must be a number ). We have cheat-sheets available for both type and interface , if you want a quick look at the important every-day syntax at a glance. Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to. Much of the time, we’ll find ourselves dealing with objects that might have a property set.\nIn those cases, we can mark those properties as optional by adding a question mark ( ? ) to the end of their names."
                },
                {
                    "type": "code",
                    "code": "ts interface PaintOptions { shape : Shape ; xPos ?: number ; yPos ?: number ; } function paintShape ( opts : PaintOptions ) { // ... } const shape = getShape (); paintShape ({ shape }); paintShape ({ shape , xPos : 100 }); paintShape ({ shape , yPos : 100 }); paintShape ({ shape , xPos : 100 , yPos : 100 }); Try"
                },
                {
                    "type": "p",
                    "text": "In this example, both xPos and yPos are considered optional.\nWe can choose to provide either of them, so every call above to paintShape is valid.\nAll optionality really says is that if the property is set, it better have a specific type. We can also read from those properties - but when we do under strictNullChecks , TypeScript will tell us they’re potentially undefined ."
                },
                {
                    "type": "code",
                    "code": "ts function paintShape ( opts : PaintOptions ) { let xPos = opts . xPos ; (property) PaintOptions.xPos?: number | undefined let yPos = opts . yPos ; (property) PaintOptions.yPos?: number | undefined // ... } Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value undefined .\nWe can just handle undefined specially by checking for it."
                },
                {
                    "type": "code",
                    "code": "ts function paintShape ( opts : PaintOptions ) { let xPos = opts . xPos === undefined ? 0 : opts . xPos ; let xPos: number let yPos = opts . yPos === undefined ? 0 : opts . yPos ; let yPos: number // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it."
                },
                {
                    "type": "code",
                    "code": "ts function paintShape ({ shape , xPos = 0 , yPos = 0 }: PaintOptions ) { console . log ( \"x coordinate at\" , xPos ); (parameter) xPos: number console . log ( \"y coordinate at\" , yPos ); (parameter) yPos: number // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Here we used a destructuring pattern for paintShape ’s parameter, and provided default values for xPos and yPos .\nNow xPos and yPos are both definitely present within the body of paintShape , but optional for any callers to paintShape . Note that there is currently no way to place type annotations within destructuring patterns.\nThis is because the following syntax already means something different in JavaScript."
                },
                {
                    "type": "code",
                    "code": "ts function draw ({ shape : Shape , xPos : number = 100 /*...*/ }) { render ( shape ); Cannot find name 'shape'. Did you mean 'Shape'? 2552 Cannot find name 'shape'. Did you mean 'Shape'? render ( xPos ); Cannot find name 'xPos'. 2304 Cannot find name 'xPos'. } Try"
                },
                {
                    "type": "p",
                    "text": "In an object destructuring pattern, shape: Shape means “grab the property shape and redefine it locally as a variable named Shape .”\nLikewise xPos: number creates a variable named number whose value is based on the parameter’s xPos . Properties can also be marked as readonly for TypeScript.\nWhile it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking."
                },
                {
                    "type": "code",
                    "code": "ts interface SomeType { readonly prop : string ; } function doSomething ( obj : SomeType ) { // We can read from 'obj.prop'. console . log ( `prop has the value ' ${ obj . prop } '.` ); // But we can't re-assign it. obj . prop = \"hello\" ; Cannot assign to 'prop' because it is a read-only property. 2540 Cannot assign to 'prop' because it is a read-only property. } Try"
                },
                {
                    "type": "p",
                    "text": "Using the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed.\nIt just means the property itself can’t be re-written to."
                },
                {
                    "type": "code",
                    "code": "ts interface Home { readonly resident : { name : string ; age : number }; } function visitForBirthday ( home : Home ) { // We can read and update properties from 'home.resident'. console . log ( `Happy birthday ${ home . resident . name } !` ); home . resident . age ++; } function evict ( home : Home ) { // But we can't write to the 'resident' property itself on a 'Home'. home . resident = { Cannot assign to 'resident' because it is a read-only property. 2540 Cannot assign to 'resident' because it is a read-only property. name : \"Victor the Evictor\" , age : 42 , }; } Try"
                },
                {
                    "type": "p",
                    "text": "It’s important to manage expectations of what readonly implies.\nIt’s useful to signal intent during development time for TypeScript on how an object should be used.\nTypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing."
                },
                {
                    "type": "code",
                    "code": "ts interface Person { name : string ; age : number ; } interface ReadonlyPerson { readonly name : string ; readonly age : number ; } let writablePerson : Person = { name : \"Person McPersonface\" , age : 42 , }; // works let readonlyPerson : ReadonlyPerson = writablePerson ; console . log ( readonlyPerson . age ); // prints '42' writablePerson . age ++; console . log ( readonlyPerson . age ); // prints '43' Try"
                },
                {
                    "type": "p",
                    "text": "Using mapping modifiers , you can remove readonly attributes. Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example:"
                },
                {
                    "type": "code",
                    "code": "ts interface StringArray { [ index : number ]: string ; } const myArray : StringArray = getStringArray (); const secondItem = myArray [ 1 ]; const secondItem: string Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have a StringArray interface which has an index signature.\nThis index signature states that when a StringArray is indexed with a number , it will return a string . Only some types are allowed for index signature properties: string , number , symbol , template string patterns, and union types consisting only of these. It is possible to support multiple types of indexers. Note that when using both `number` and `string` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a number , JavaScript will actually convert that to a string before indexing into an object. That means that indexing with 100 (a number ) is the same thing as indexing with \"100\" (a string ), so the two need to be consistent."
                },
                {
                    "type": "code",
                    "code": "ts interface Animal { name : string ; } interface Dog extends Animal { breed : string ; } // Error: indexing with a numeric string might get you a completely separate type of Animal! interface NotOkay { [ x : number ]: Animal ; 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. 2413 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [ x : string ]: Dog ; } Try"
                },
                {
                    "type": "p",
                    "text": "While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type.\nThis is because a string index declares that obj.property is also available as obj[\"property\"] .\nIn the following example, name ’s type does not match the string index’s type, and the type checker gives an error:"
                },
                {
                    "type": "code",
                    "code": "ts interface NumberDictionary { [ index : string ]: number ; length : number ; // ok name : string ; Property 'name' of type 'string' is not assignable to 'string' index type 'number'. 2411 Property 'name' of type 'string' is not assignable to 'string' index type 'number'. } Try"
                },
                {
                    "type": "p",
                    "text": "However, properties of different types are acceptable if the index signature is a union of the property types:"
                },
                {
                    "type": "code",
                    "code": "ts interface NumberOrStringDictionary { [ index : string ]: number | string ; length : number ; // ok, length is a number name : string ; // ok, name is a string } Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can make index signatures readonly in order to prevent assignment to their indices:"
                },
                {
                    "type": "code",
                    "code": "ts interface ReadonlyStringArray { readonly [ index : number ]: string ; } let myArray : ReadonlyStringArray = getReadOnlyStringArray (); myArray [ 2 ] = \"Mallory\" ; Index signature in type 'ReadonlyStringArray' only permits reading. 2542 Index signature in type 'ReadonlyStringArray' only permits reading. Try"
                },
                {
                    "type": "p",
                    "text": "You can’t set myArray[2] because the index signature is readonly . Where and how an object is assigned a type can make a difference in the type system.\nOne of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation."
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; } function createSquare ( config : SquareConfig ): { color : string ; area : number } { return { color : config . color || \"red\" , area : config . width ? config . width * config . width : 20 , }; } let mySquare = createSquare ({ colour : \"red\" , width : 100 }); Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 2561 Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? Try"
                },
                {
                    "type": "p",
                    "text": "Notice the given argument to createSquare is spelled colour instead of color .\nIn plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since the width properties are compatible, there’s no color property present, and the extra colour property is insignificant. However, TypeScript takes the stance that there’s probably a bug in this code.\nObject literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments.\nIf an object literal has any properties that the “target type” doesn’t have, you’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "ts let mySquare = createSquare ({ colour : \"red\" , width : 100 }); Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 2561 Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? Try"
                },
                {
                    "type": "p",
                    "text": "Getting around these checks is actually really simple.\nThe easiest method is to just use a type assertion:"
                },
                {
                    "type": "code",
                    "code": "ts let mySquare = createSquare ({ width : 100 , opacity : 0.5 } as SquareConfig ); Try"
                },
                {
                    "type": "p",
                    "text": "However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way.\nIf SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so:"
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; [ propName : string ]: unknown ; } Try"
                },
                {
                    "type": "p",
                    "text": "Here we’re saying that SquareConfig can have any number of properties, and as long as they aren’t color or width , their types don’t matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable:\nSince assigning squareOptions won’t undergo excess property checks, the compiler won’t give you an error:"
                },
                {
                    "type": "code",
                    "code": "ts let squareOptions = { colour : \"red\" , width : 100 }; let mySquare = createSquare ( squareOptions ); Try"
                },
                {
                    "type": "p",
                    "text": "The above workaround will work as long as you have a common property between squareOptions and SquareConfig .\nIn this example, it was the property width . It will however, fail if the variable does not have any common object property. For example:"
                },
                {
                    "type": "code",
                    "code": "ts let squareOptions = { colour : \"red\" }; let mySquare = createSquare ( squareOptions ); Type '{ colour: string; }' has no properties in common with type 'SquareConfig'. 2559 Type '{ colour: string; }' has no properties in common with type 'SquareConfig'. Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks.\nFor more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations.\nIn this instance, if it’s okay to pass an object with both a color or colour property to createSquare , you should fix up the definition of SquareConfig to reflect that. It’s pretty common to have types that might be more specific versions of other types.\nFor example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S."
                },
                {
                    "type": "code",
                    "code": "ts interface BasicAddress { name ?: string ; street : string ; city : string ; country : string ; postalCode : string ; } Try"
                },
                {
                    "type": "p",
                    "text": "In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units.\nWe can then describe an AddressWithUnit ."
                },
                {
                    "type": "code",
                    "code": "ts interface AddressWithUnit { name ?: string ; unit : string ; street : string ; city : string ; country : string ; postalCode : string ; } Try"
                },
                {
                    "type": "p",
                    "text": "This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive.\nInstead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit ."
                },
                {
                    "type": "code",
                    "code": "ts interface BasicAddress { name ?: string ; street : string ; city : string ; country : string ; postalCode : string ; } interface AddressWithUnit extends BasicAddress { unit : string ; } Try"
                },
                {
                    "type": "p",
                    "text": "The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want.\nThis can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related.\nFor example, AddressWithUnit didn’t need to repeat the street property, and because street originates from BasicAddress , a reader will know that those two types are related in some way. interface s can also extend from multiple types."
                },
                {
                    "type": "code",
                    "code": "ts interface Colorful { color : string ; } interface Circle { radius : number ; } interface ColorfulCircle extends Colorful , Circle {} const cc : ColorfulCircle = { color : \"red\" , radius : 42 , }; Try"
                },
                {
                    "type": "p",
                    "text": "interface s allowed us to build up new types from other types by extending them.\nTypeScript provides another construct called intersection types that is mainly used to combine existing object types. An intersection type is defined using the & operator."
                },
                {
                    "type": "code",
                    "code": "ts interface Colorful { color : string ; } interface Circle { radius : number ; } type ColorfulCircle = Colorful & Circle ; Try"
                },
                {
                    "type": "p",
                    "text": "Here, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle ."
                },
                {
                    "type": "code",
                    "code": "ts function draw ( circle : Colorful & Circle ) { console . log ( `Color was ${ circle . color } ` ); console . log ( `Radius was ${ circle . radius } ` ); } // okay draw ({ color : \"blue\" , radius : 42 }); // oops draw ({ color : \"red\" , raidus : 42 }); Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'? 2561 Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'? Try"
                },
                {
                    "type": "p",
                    "text": "We just looked at two ways to combine types which are similar, but are actually subtly different.\nWith interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias.\nThe principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type. If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error. In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results. For example, the following code will throw an error because the properties are incompatible:"
                },
                {
                    "type": "code",
                    "code": "ts interface Person { name : string ; } interface Person { name : number ; }"
                },
                {
                    "type": "p",
                    "text": "In contrast, the following code will compile, but it results in a never type:"
                },
                {
                    "type": "code",
                    "code": "ts interface Person1 { name : string ; } interface Person2 { name : number ; } type Staff = Person1 & Person2 declare const staffer : Staff ; staffer . name ; (property) name: never Try"
                },
                {
                    "type": "p",
                    "text": "In this case, Staff would require the name property to be both a string and a number, which results in property being of type never . Let’s imagine a Box type that can contain any value - string s, number s, Giraffe s, whatever."
                },
                {
                    "type": "code",
                    "code": "ts interface Box { contents : any ; } Try"
                },
                {
                    "type": "p",
                    "text": "Right now, the contents property is typed as any , which works, but can lead to accidents down the line. We could instead use unknown , but that would mean that in cases where we already know the type of contents , we’d need to do precautionary checks, or use error-prone type assertions."
                },
                {
                    "type": "code",
                    "code": "ts interface Box { contents : unknown ; } let x : Box = { contents : \"hello world\" , }; // we could check 'x.contents' if ( typeof x . contents === \"string\" ) { console . log ( x . contents . toLowerCase ()); } // or we could use a type assertion console . log (( x . contents as string ). toLowerCase ()); Try"
                },
                {
                    "type": "p",
                    "text": "One type safe approach would be to instead scaffold out different Box types for every type of contents ."
                },
                {
                    "type": "code",
                    "code": "ts interface NumberBox { contents : number ; } interface StringBox { contents : string ; } interface BooleanBox { contents : boolean ; } Try"
                },
                {
                    "type": "p",
                    "text": "But that means we’ll have to create different functions, or overloads of functions, to operate on these types."
                },
                {
                    "type": "code",
                    "code": "ts function setContents ( box : StringBox , newContents : string ): void ; function setContents ( box : NumberBox , newContents : number ): void ; function setContents ( box : BooleanBox , newContents : boolean ): void ; function setContents ( box : { contents : any }, newContents : any ) { box . contents = newContents ; } Try"
                },
                {
                    "type": "p",
                    "text": "That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads.\nThis is frustrating, since our box types and overloads are all effectively the same. Instead, we can make a generic Box type which declares a type parameter ."
                },
                {
                    "type": "code",
                    "code": "ts interface Box < Type > { contents : Type ; } Try"
                },
                {
                    "type": "p",
                    "text": "You might read this as “A Box of Type is something whose contents have type Type ”.\nLater on, when we refer to Box , we have to give a type argument in place of Type ."
                },
                {
                    "type": "code",
                    "code": "ts let box : Box < string >; Try"
                },
                {
                    "type": "p",
                    "text": "Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type.\nWhen TypeScript sees Box<string> , it will replace every instance of Type in Box<Type> with string , and end up working with something like { contents: string } .\nIn other words, Box<string> and our earlier StringBox work identically."
                },
                {
                    "type": "code",
                    "code": "ts interface Box < Type > { contents : Type ; } interface StringBox { contents : string ; } let boxA : Box < string > = { contents : \"hello\" }; boxA . contents ; (property) Box<string>.contents: string let boxB : StringBox = { contents : \"world\" }; boxB . contents ; (property) StringBox.contents: string Try"
                },
                {
                    "type": "p",
                    "text": "Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new Box type at all (though we certainly could if we wanted to)."
                },
                {
                    "type": "code",
                    "code": "ts interface Box < Type > { contents : Type ; } interface Apple { // .... } // Same as '{ contents: Apple }'. type AppleBox = Box < Apple >; Try"
                },
                {
                    "type": "p",
                    "text": "This also means that we can avoid overloads entirely by instead using generic functions ."
                },
                {
                    "type": "code",
                    "code": "ts function setContents < Type >( box : Box < Type >, newContents : Type ) { box . contents = newContents ; } Try"
                },
                {
                    "type": "p",
                    "text": "It is worth noting that type aliases can also be generic. We could have defined our new Box<Type> interface, which was:"
                },
                {
                    "type": "code",
                    "code": "ts interface Box < Type > { contents : Type ; } Try"
                },
                {
                    "type": "p",
                    "text": "by using a type alias instead:"
                },
                {
                    "type": "code",
                    "code": "ts type Box < Type > = { contents : Type ; }; Try"
                },
                {
                    "type": "p",
                    "text": "Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types."
                },
                {
                    "type": "code",
                    "code": "ts type OrNull < Type > = Type | null ; type OneOrMany < Type > = Type | Type []; type OneOrManyOrNull < Type > = OrNull < OneOrMany < Type >>; type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull < string >; type OneOrManyOrNullStrings = OneOrMany<string> | null Try"
                },
                {
                    "type": "p",
                    "text": "We’ll circle back to type aliases in just a little bit. Generic object types are often some sort of container type that work independently of the type of elements they contain.\nIt’s ideal for data structures to work this way so that they’re re-usable across different data types. It turns out we’ve been working with a type just like that throughout this handbook: the Array type.\nWhenever we write out types like number[] or string[] , that’s really just a shorthand for Array<number> and Array<string> ."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( value : Array < string >) { // ... } let myArray : string [] = [ \"hello\" , \"world\" ]; // either of these work! doSomething ( myArray ); doSomething ( new Array ( \"hello\" , \"world\" )); Try"
                },
                {
                    "type": "p",
                    "text": "Much like the Box type above, Array itself is a generic type."
                },
                {
                    "type": "code",
                    "code": "ts interface Array < Type > { Global type 'Array' must have 1 type parameter(s). All declarations of 'Array' must have identical type parameters. 2317 2428 Global type 'Array' must have 1 type parameter(s). All declarations of 'Array' must have identical type parameters. /** * Gets or sets the length of the array. */ length : number ; /** * Removes the last element from an array and returns it. */ pop (): Type | undefined ; /** * Appends new elements to an array, and returns the new length of the array. */ push (... items : Type []): number ; A rest parameter must be of an array type. 2370 A rest parameter must be of an array type. // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Modern JavaScript also provides other data structures which are generic, like Map<K, V> , Set<T> , and Promise<T> .\nAll this really means is that because of how Map , Set , and Promise behave, they can work with any sets of types. The ReadonlyArray is a special type that describes arrays that shouldn’t be changed."
                },
                {
                    "type": "code",
                    "code": "ts function doStuff ( values : ReadonlyArray < string >) { // We can read from 'values'... const copy = values . slice (); console . log ( `The first value is ${ values [ 0 ] } ` ); // ...but we can't mutate 'values'. values . push ( \"hello!\" ); Property 'push' does not exist on type 'readonly string[]'. 2339 Property 'push' does not exist on type 'readonly string[]'. } Try"
                },
                {
                    "type": "p",
                    "text": "Much like the readonly modifier for properties, it’s mainly a tool we can use for intent.\nWhen we see a function that returns ReadonlyArray s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArray s, it tells us that we can pass any array into that function without worrying that it will change its contents. Unlike Array , there isn’t a ReadonlyArray constructor that we can use."
                },
                {
                    "type": "code",
                    "code": "ts new ReadonlyArray ( \"red\" , \"green\" , \"blue\" ); 'ReadonlyArray' only refers to a type, but is being used as a value here. 2693 'ReadonlyArray' only refers to a type, but is being used as a value here. Try"
                },
                {
                    "type": "p",
                    "text": "Instead, we can assign regular Array s to ReadonlyArray s."
                },
                {
                    "type": "code",
                    "code": "ts const roArray : ReadonlyArray < string > = [ \"red\" , \"green\" , \"blue\" ]; Try"
                },
                {
                    "type": "p",
                    "text": "Just as TypeScript provides a shorthand syntax for Array<Type> with Type[] , it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[] ."
                },
                {
                    "type": "code",
                    "code": "ts function doStuff ( values : readonly string []) { // We can read from 'values'... const copy = values . slice (); console . log ( `The first value is ${ values [ 0 ] } ` ); // ...but we can't mutate 'values'. values . push ( \"hello!\" ); Property 'push' does not exist on type 'readonly string[]'. 2339 Property 'push' does not exist on type 'readonly string[]'. } Try"
                },
                {
                    "type": "p",
                    "text": "One last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Array s and ReadonlyArray s."
                },
                {
                    "type": "code",
                    "code": "ts let x : readonly string [] = []; let y : string [] = []; x = y ; y = x ; The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'. 4104 The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'. Try"
                },
                {
                    "type": "p",
                    "text": "A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions."
                },
                {
                    "type": "code",
                    "code": "ts type StringNumberPair = [ string , number ]; Try"
                },
                {
                    "type": "p",
                    "text": "Here, StringNumberPair is a tuple type of string and number .\nLike ReadonlyArray , it has no representation at runtime, but is significant to TypeScript.\nTo the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number ."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( pair : [ string , number ]) { const a = pair [ 0 ]; const a: string const b = pair [ 1 ]; const b: number // ... } doSomething ([ \"hello\" , 42 ]); Try"
                },
                {
                    "type": "p",
                    "text": "If we try to index past the number of elements, we’ll get an error."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( pair : [ string , number ]) { // ... const c = pair [ 2 ]; Tuple type '[string, number]' of length '2' has no element at index '2'. 2493 Tuple type '[string, number]' of length '2' has no element at index '2'. } Try"
                },
                {
                    "type": "p",
                    "text": "We can also destructure tuples using JavaScript’s array destructuring."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( stringHash : [ string , number ]) { const [ inputString , hash ] = stringHash ; console . log ( inputString ); const inputString: string console . log ( hash ); const hash: number } Try"
                },
                {
                    "type": "p",
                    "text": "Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”.\nThis gives us flexibility in whatever we want to name our variables when we destructure them.\nIn the above example, we were able to name elements 0 and 1 to whatever we wanted. However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API. Other than those length checks, simple tuple types like these are equivalent to types which are versions of Array s that declare properties for specific indexes, and that declare length with a numeric literal type."
                },
                {
                    "type": "code",
                    "code": "ts interface StringNumberPair { // specialized properties length : 2 ; 0 : string ; 1 : number ; // Other 'Array<string | number>' members... slice ( start ?: number , end ?: number ): Array < string | number >; } Try"
                },
                {
                    "type": "p",
                    "text": "Another thing you may be interested in is that tuples can have optional properties by writing out a question mark ( ? after an element’s type).\nOptional tuple elements can only come at the end, and also affect the type of length ."
                },
                {
                    "type": "code",
                    "code": "ts type Either2dOr3d = [ number , number , number ?]; function setCoordinate ( coord : Either2dOr3d ) { const [ x , y , z ] = coord ; const z: number | undefined console . log ( `Provided coordinates had ${ coord . length } dimensions` ); (property) length: 2 | 3 } Try"
                },
                {
                    "type": "p",
                    "text": "Tuples can also have rest elements, which have to be an array/tuple type."
                },
                {
                    "type": "code",
                    "code": "ts type StringNumberBooleans = [ string , number , ... boolean []]; type StringBooleansNumber = [ string , ... boolean [], number ]; type BooleansStringNumber = [... boolean [], string , number ]; Try"
                },
                {
                    "type": "list",
                    "items": [
                        "StringNumberBooleans describes a tuple whose first two elements are string and number respectively, but which may have any number of boolean s following.",
                        "StringBooleansNumber describes a tuple whose first element is string and then any number of boolean s and ending with a number .",
                        "BooleansStringNumber describes a tuple whose starting elements are any number of boolean s and ending with a string then a number ."
                    ]
                },
                {
                    "type": "p",
                    "text": "A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions."
                },
                {
                    "type": "code",
                    "code": "ts const a : StringNumberBooleans = [ \"hello\" , 1 ]; const b : StringNumberBooleans = [ \"beautiful\" , 2 , true ]; const c : StringNumberBooleans = [ \"world\" , 3 , true , false , true , false , true ]; Try"
                },
                {
                    "type": "p",
                    "text": "Why might optional and rest elements be useful?\nWell, it allows TypeScript to correspond tuples with parameter lists.\nTuples types can be used in rest parameters and arguments , so that the following:"
                },
                {
                    "type": "code",
                    "code": "ts function readButtonInput (... args : [ string , number , ... boolean []]) { const [ name , version , ... input ] = args ; // ... } Try"
                },
                {
                    "type": "code",
                    "code": "ts function readButtonInput ( name : string , version : number , ... input : boolean []) { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables. One final note about tuple types - tuple types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( pair : readonly [ string , number ]) { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "As you might expect, writing to any property of a readonly tuple isn’t allowed in TypeScript."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething ( pair : readonly [ string , number ]) { pair [ 0 ] = \"hello!\" ; Cannot assign to '0' because it is a read-only property. 2540 Cannot assign to '0' because it is a read-only property. } Try"
                },
                {
                    "type": "p",
                    "text": "Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default.\nThis is also important given that array literals with const assertions will be inferred with readonly tuple types."
                },
                {
                    "type": "code",
                    "code": "ts let point = [ 3 , 4 ] as const ; function distanceFromOrigin ([ x , y ]: [ number , number ]) { return Math . sqrt ( x ** 2 + y ** 2 ); } distanceFromOrigin ( point ); Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. 2345 Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. Try"
                },
                {
                    "type": "p",
                    "text": "Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple.\nSince point ’s type was inferred as readonly [3, 4] , it won’t be compatible with [number, number] since that type can’t guarantee point ’s elements won’t be mutated. Learn about how Functions work in TypeScript. An overview of the ways in which you can create more types from existing types. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html",
            "title": "TypeScript: Documentation - Template Literal Types",
            "content": [
                {
                    "type": "p",
                    "text": "Template literal types build on string literal types , and have the ability to expand into many strings via unions. They have the same syntax as template literal strings in JavaScript , but are used in type positions.\nWhen used with concrete literal types, a template literal produces a new string literal type by concatenating the contents."
                },
                {
                    "type": "code",
                    "code": "ts type World = \"world\" ; type Greeting = `hello ${ World } ` ; type Greeting = \"hello world\" Try"
                },
                {
                    "type": "p",
                    "text": "When a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:"
                },
                {
                    "type": "code",
                    "code": "ts type EmailLocaleIDs = \"welcome_email\" | \"email_heading\" ; type FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\" ; type AllLocaleIDs = ` ${ EmailLocaleIDs | FooterLocaleIDs } _id` ; type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\" Try"
                },
                {
                    "type": "p",
                    "text": "For each interpolated position in the template literal, the unions are cross multiplied:"
                },
                {
                    "type": "code",
                    "code": "ts type AllLocaleIDs = ` ${ EmailLocaleIDs | FooterLocaleIDs } _id` ; type Lang = \"en\" | \"ja\" | \"pt\" ; type LocaleMessageIDs = ` ${ Lang } _ ${ AllLocaleIDs } ` ; type LocaleMessageIDs = \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\" Try"
                },
                {
                    "type": "p",
                    "text": "We generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases. The power in template literals comes when defining a new string based on information inside a type. Consider the case where a function ( makeWatchedObject ) adds a new function\ncalled on() to a passed object.  In JavaScript, its call might look like: makeWatchedObject(baseObject) . We can imagine the base object as looking\nlike:"
                },
                {
                    "type": "code",
                    "code": "ts const passedObject = { firstName : \"Saoirse\" , lastName : \"Ronan\" , age : 26 , }; Try"
                },
                {
                    "type": "p",
                    "text": "The on function that will be added to the base object expects two arguments, an eventName (a string ) and a callback (a function ). The eventName should be of the form attributeInThePassedObject + \"Changed\" ; thus, firstNameChanged as derived from the attribute firstName in the base object."
                },
                {
                    "type": "list",
                    "items": [
                        "Should be passed a value of the type associated with the name attributeInThePassedObject ; thus, since firstName is typed as string , the callback for the firstNameChanged event expects a string to be passed to it at call time. Similarly events associated with age should expect to be called with a number argument",
                        "Should have void return type (for simplicity of demonstration)"
                    ]
                },
                {
                    "type": "p",
                    "text": "The naive function signature of on() might thus be: on(eventName: string, callback: (newValue: any) => void) . However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code."
                },
                {
                    "type": "code",
                    "code": "ts const person = makeWatchedObject ({ firstName : \"Saoirse\" , lastName : \"Ronan\" , age : 26 , }); // makeWatchedObject has added `on` to the anonymous Object person . on ( \"firstNameChanged\" , ( newValue ) => { console . log ( `firstName was changed to ${ newValue } !` ); }); Try"
                },
                {
                    "type": "p",
                    "text": "Notice that on listens on the event \"firstNameChanged\" , not just \"firstName\" . Our naive specification of on() could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e. Object.keys(passedObject).map(x => `${x}Changed`) , template literals inside the type system provide a similar approach to string manipulation:"
                },
                {
                    "type": "code",
                    "code": "ts type PropEventSource < Type > = { on ( eventName : ` ${ string & keyof Type } Changed` , callback : ( newValue : any ) => void ): void ; }; /// Create a \"watched object\" with an `on` method /// so that you can watch for changes to properties. declare function makeWatchedObject < Type >( obj : Type ): Type & PropEventSource < Type >; Try"
                },
                {
                    "type": "p",
                    "text": "With this, we can build something that errors when given the wrong property:"
                },
                {
                    "type": "code",
                    "code": "ts const person = makeWatchedObject ({ firstName : \"Saoirse\" , lastName : \"Ronan\" , age : 26 }); person . on ( \"firstNameChanged\" , () => {}); // Prevent easy human error (using the key instead of the event name) person . on ( \"firstName\" , () => {}); Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'. 2345 Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'. // It's typo-resistant person . on ( \"frstNameChanged\" , () => {}); Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'. 2345 Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'. Try"
                },
                {
                    "type": "p",
                    "text": "Notice that we did not benefit from all the information provided in the original passed object. Given change of a firstName (i.e. a firstNameChanged event),  we should expect that the callback will receive an argument of type string . Similarly, the callback for a change to age should receive a number argument. We’re naively using any to type the callback ’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument. The key insight that makes this possible is this: we can use a function with a generic such that:"
                },
                {
                    "type": "list",
                    "items": [
                        "The literal used in the first argument is captured as a literal type",
                        "That literal type can be validated as being in the union of valid attributes in the generic",
                        "The type of the validated attribute can be looked up in the generic’s structure using Indexed Access",
                        "This typing information can then be applied to ensure the argument to the\ncallback function is of the same type"
                    ]
                },
                {
                    "type": "code",
                    "code": "ts type PropEventSource < Type > = { on < Key extends string & keyof Type > ( eventName : ` ${ Key } Changed` , callback : ( newValue : Type [ Key ]) => void ): void ; }; declare function makeWatchedObject < Type >( obj : Type ): Type & PropEventSource < Type >; const person = makeWatchedObject ({ firstName : \"Saoirse\" , lastName : \"Ronan\" , age : 26 }); person . on ( \"firstNameChanged\" , newName => { (parameter) newName: string console . log ( `new name is ${ newName . toUpperCase () } ` ); }); person . on ( \"ageChanged\" , newAge => { (parameter) newAge: number if ( newAge < 0) { console . warn ( \"warning! negative age\" ); } }) Try"
                },
                {
                    "type": "p",
                    "text": "Here we made on into a generic method. When a user calls with the string \"firstNameChanged\" , TypeScript will try to infer the right type for Key .\nTo do that, it will match Key against the content before \"Changed\" and infer the string \"firstName\" .\nOnce TypeScript figures that out, the on method can fetch the type of firstName on the original object, which is string in this case.\nSimilarly, when called with \"ageChanged\" , TypeScript finds the type for the property age which is number . Inference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways. To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the .d.ts files included with TypeScript. Converts each character in the string to the uppercase version."
                },
                {
                    "type": "code",
                    "code": "ts type Greeting = \"Hello, world\" type ShoutyGreeting = Uppercase < Greeting > type ShoutyGreeting = \"HELLO, WORLD\" type ASCIICacheKey < Str extends string > = `ID- ${ Uppercase < Str > } ` type MainID = ASCIICacheKey < \"my_app\" > type MainID = \"ID-MY_APP\" Try"
                },
                {
                    "type": "p",
                    "text": "Converts each character in the string to the lowercase equivalent."
                },
                {
                    "type": "code",
                    "code": "ts type Greeting = \"Hello, world\" type QuietGreeting = Lowercase < Greeting > type QuietGreeting = \"hello, world\" type ASCIICacheKey < Str extends string > = `id- ${ Lowercase < Str > } ` type MainID = ASCIICacheKey < \"MY_APP\" > type MainID = \"id-my_app\" Try"
                },
                {
                    "type": "p",
                    "text": "Converts the first character in the string to an uppercase equivalent."
                },
                {
                    "type": "code",
                    "code": "ts type LowercaseGreeting = \"hello, world\" ; type Greeting = Capitalize < LowercaseGreeting >; type Greeting = \"Hello, world\" Try"
                },
                {
                    "type": "p",
                    "text": "Converts the first character in the string to a lowercase equivalent."
                },
                {
                    "type": "code",
                    "code": "ts type UppercaseGreeting = \"HELLO WORLD\" ; type UncomfortableGreeting = Uncapitalize < UppercaseGreeting >; type UncomfortableGreeting = \"hELLO WORLD\" Try"
                },
                {
                    "type": "p",
                    "text": "The code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware."
                },
                {
                    "type": "code",
                    "code": "function applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}"
                },
                {
                    "type": "p",
                    "text": "Generating types by re-using an existing type. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/typeof-types.html",
            "title": "TypeScript: Documentation - Typeof Type Operator",
            "content": [
                {
                    "type": "p",
                    "text": "JavaScript already has a typeof operator you can use in an expression context:"
                },
                {
                    "type": "code",
                    "code": "ts // Prints \"string\" console . log ( typeof \"Hello world\" ); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds a typeof operator you can use in a type context to refer to the type of a variable or property:"
                },
                {
                    "type": "code",
                    "code": "ts let s = \"hello\" ; let n : typeof s ; let n: string Try"
                },
                {
                    "type": "p",
                    "text": "This isn’t very useful for basic types, but combined with other type operators, you can use typeof to conveniently express many patterns.\nFor an example, let’s start by looking at the predefined type ReturnType<T> .\nIt takes a function type and produces its return type:"
                },
                {
                    "type": "code",
                    "code": "ts type Predicate = ( x : unknown ) => boolean ; type K = ReturnType < Predicate >; type K = boolean Try"
                },
                {
                    "type": "p",
                    "text": "If we try to use ReturnType on a function name, we see an instructive error:"
                },
                {
                    "type": "code",
                    "code": "ts function f () { return { x : 10 , y : 3 }; } type P = ReturnType < f >; 'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'? 2749 'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'? Try"
                },
                {
                    "type": "p",
                    "text": "Remember that values and types aren’t the same thing.\nTo refer to the type that the value f has, we use typeof :"
                },
                {
                    "type": "code",
                    "code": "ts function f () { return { x : 10 , y : 3 }; } type P = ReturnType < typeof f >; type P = {\n    x: number;\n    y: number;\n} Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript intentionally limits the sorts of expressions you can use typeof on. Specifically, it’s only legal to use typeof on identifiers (i.e. variable names) or their properties.\nThis helps avoid the confusing trap of writing code you think is executing, but isn’t:"
                },
                {
                    "type": "code",
                    "code": "ts // Meant to use = ReturnType<typeof msgbox> let shouldContinue : typeof msgbox ( \"Are you sure you want to continue?\" ); ',' expected. 1005 ',' expected. Try"
                },
                {
                    "type": "p",
                    "text": "Using the keyof operator in type contexts. Using Type['a'] syntax to access a subset of a type. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
            "title": "TypeScript: Documentation - Creating Types from Types",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript’s type system is very powerful because it allows expressing types in terms of other types . The simplest form of this idea is generics. Additionally, we have a wide variety of type operators available to use.\nIt’s also possible to express types in terms of values that we already have. By combining various type operators, we can express complex operations and values in a succinct, maintainable way.\nIn this section we’ll cover ways to express a new type in terms of an existing type or value."
                },
                {
                    "type": "list",
                    "items": [
                        "Generics - Types which take parameters",
                        "Keyof Type Operator - Using the keyof operator to create new types",
                        "Typeof Type Operator - Using the typeof operator to create new types",
                        "Indexed Access Types - Using Type['a'] syntax to access a subset of a type",
                        "Conditional Types - Types which act like if statements in the type system",
                        "Mapped Types - Creating types by mapping each property in an existing type",
                        "Template Literal Types - Mapped types which change properties via template literal strings"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/asp-net-core.html",
            "title": "TypeScript: Documentation - ASP.NET Core",
            "content": [
                {
                    "type": "p",
                    "text": "First, install ASP.NET Core if you need it. This quick-start guide requires Visual Studio 2015 or 2017. Next, if your version of Visual Studio does not already have the latest TypeScript, you can install it ."
                },
                {
                    "type": "list",
                    "items": [
                        "Choose File",
                        "Choose New Project (Ctrl + Shift + N)",
                        "Search for .NET Core in the project search bar",
                        "Select ASP.NET Core Web Application and press the Next button"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Name your project and solution. After select the Create button"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "In the last window, select the Empty template and press the Create button"
                    ]
                },
                {
                    "type": "p",
                    "text": "Run the application and make sure that it works. Open Dependencies > Manage NuGet Packages > Browse. Search and install Microsoft.AspNetCore.StaticFiles and Microsoft.TypeScript.MSBuild : Open up your Startup.cs file and edit your Configure function to look like this:"
                },
                {
                    "type": "code",
                    "code": "public void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}"
                },
                {
                    "type": "p",
                    "text": "You may need to restart VS for the red squiggly lines below UseDefaultFiles and UseStaticFiles to disappear. Next we will add a new folder and call it scripts . Right click on scripts and click New Item . Then choose TypeScript File and name the file app.ts Add the following code to the app.ts file."
                },
                {
                    "type": "code",
                    "code": "ts function sayHello () { const compiler = ( document . getElementById ( \"compiler\" ) as HTMLInputElement ) . value ; const framework = ( document . getElementById ( \"framework\" ) as HTMLInputElement ) . value ; return `Hello from ${ compiler } and ${ framework } !` ; }"
                },
                {
                    "type": "p",
                    "text": "First we need to tell TypeScript how to build. Right click on scripts and click New Item . Then choose TypeScript Configuration File and use the default name of tsconfig.json Replace the contents of the tsconfig.json file with:"
                },
                {
                    "type": "code",
                    "code": "{ \" compilerOptions \" : { \" noEmitOnError \" : true , \" noImplicitAny \" : true , \" sourceMap \" : true , \" target \" : \"es6\" }, \" files \" : [ \"./app.ts\" ], \"compileOnSave\" : true }"
                },
                {
                    "type": "list",
                    "items": [
                        "noEmitOnError : Do not emit outputs if any errors were reported.",
                        "noImplicitAny : Raise error on expressions and declarations with an implied any type.",
                        "sourceMap : Generates corresponding .map file.",
                        "target : Specify ECMAScript target version."
                    ]
                },
                {
                    "type": "p",
                    "text": "noImplicitAny is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. \"compileOnSave\" makes it easy to update your code in a running web app. We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select New Item . Then choose NPM Configuration File and use the default name of package.json . Inside the \"devDependencies\" section of the package.json file, add gulp and del"
                },
                {
                    "type": "code",
                    "code": "\"devDependencies\" : { \"gulp\" : \"4.0.2\" , \"del\" : \"5.1.0\" }"
                },
                {
                    "type": "p",
                    "text": "Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages. After you should see an npm folder in your solution explorer Right click on the project and click New Item . Then choose JavaScript File and use the name of gulpfile.js"
                },
                {
                    "type": "code",
                    "code": "js /// <binding AfterBuild='default' Clean='clean' /> /* This file is the main entry point for defining Gulp tasks and using Gulp plugins. Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007 */ var gulp = require ( \"gulp\" ); var del = require ( \"del\" ); var paths = { scripts: [ \"scripts/**/*.js\" , \"scripts/**/*.ts\" , \"scripts/**/*.map\" ], }; gulp . task ( \"clean\" , function () { return del ([ \"wwwroot/scripts/**/*\" ]); }); gulp . task ( \"default\" , function ( done ) { gulp . src ( paths . scripts ). pipe ( gulp . dest ( \"wwwroot/scripts\" )); done (); });"
                },
                {
                    "type": "p",
                    "text": "The first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build. Now right-click on gulpfile.js and click Task Runner Explorer. If ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer: Right click on the wwwroot folder (if you don’t see the folder try building the project) and add a New Item named index.html inside. Use the following code for index.html"
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <script src=\"scripts/app.js\"></script> <title></title> </head> <body> <div id=\"message\"></div> <div> Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br /> Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /> </div> </body> </html>"
                },
                {
                    "type": "list",
                    "items": [
                        "Run the project",
                        "As you type on the boxes you should see the message appear/change!"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "In Edge, press F12 and click the Debugger tab.",
                        "Look in the first localhost folder, then scripts/app.ts",
                        "Put a breakpoint on the line with return.",
                        "Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly."
                    ]
                },
                {
                    "type": "p",
                    "text": "Congrats you’ve built your own .NET Core project with a TypeScript frontend. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html",
            "title": "TypeScript: Documentation - Using Babel with TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript? A lot of the time the answer is “it depends” , or “someone may have decided for you” depending on the project. If you are building your project with an existing framework like tsdx , Angular , NestJS or any framework mentioned in the Getting Started then this decision is handled for you. However, a useful heuristic could be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Is your build output mostly the same as your source input files? Use tsc",
                        "Do you need a build pipeline with multiple potential outputs? Use babel for transpiling and tsc for type checking"
                    ]
                },
                {
                    "type": "p",
                    "text": "This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript. This technique is a hybrid approach, using Babel’s preset-typescript to generate your JS files, and then using TypeScript to do type checking and .d.ts file generation. By using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code. The downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code. In addition to that, Babel cannot create .d.ts files for your TypeScript which can make it harder to work with your project if it is a library. To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding tsconfig.json and ensuring these flags are enabled:"
                },
                {
                    "type": "code",
                    "code": "\"compilerOptions\" : { // Ensure that .d.ts files are created by tsc, but not .js files \" declaration \" : true , \" emitDeclarationOnly \" : true , // Ensure that Babel can safely transpile files in the TypeScript project \" isolatedModules \" : true }"
                },
                {
                    "type": "p",
                    "text": "For more information on these flags:"
                },
                {
                    "type": "list",
                    "items": [
                        "isolatedModules",
                        "declaration , emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html",
            "title": "TypeScript: Documentation - Compiler Options in MSBuild",
            "content": [
                {
                    "type": "p",
                    "text": "When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a tsconfig.json or via the project settings. We recommend using a tsconfig.json for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio. The new tsconfig.json will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn about how TSConfigs works here and there is a comprehensive reference here . You can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your .csproj to define PropertyGroups which describe how the build can work:"
                },
                {
                    "type": "code",
                    "code": "xml <PropertyGroup> <TypeScriptNoEmitOnError> true </TypeScriptNoEmitOnError> <TypeScriptNoImplicitReturns> true </TypeScriptNoImplicitReturns> </PropertyGroup>"
                },
                {
                    "type": "p",
                    "text": "There is a series of mappings for common TypeScript settings, these are settings which map directly to TypeScript cli options and are used to help you write a more understandable project file. You can use the TSConfig reference to get more information on what values and defaults are for each mapping. Allow JavaScript files to be a part of your program. Use the checkJS option to get errors from these files. Enable error reporting for expressions and declarations with an implied any type.. Generate .d.ts files from TypeScript and JavaScript files in your project. Specify what module code is generated. Specify what JSX code is generated. Specify an output folder for all emitted files. Create source map files for emitted JavaScript files. Set the JavaScript language version for emitted JavaScript and include compatible library declarations. Disallow import s, require s or <reference> s from expanding the number of files TypeScript should add to a project. Specify the location where debugger should locate map files instead of generated locations. Specify the root path for debuggers to find the reference source code. No longer supported. In early versions, manually set the text encoding for reading files. Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. Disable including any library files, including the default lib.d.ts. Disable erasing const enum declarations in generated code. Suppress noImplicitAny errors when indexing objects that lack index signatures. Disable generating custom helper functions like __extends in compiled output. Include sourcemap files inside the emitted JavaScript. Include source code in the sourcemaps inside the emitted JavaScript. Set the newline character for emitting files. Ensure that each file can be safely transpiled without relying on other imports. Emit design-type metadata for decorated declarations in source files. Specify the root folder within your source files. Enable experimental support for TC39 stage 2 draft decorators. Specify how TypeScript looks up a file from a given module specifier. Disable reporting of excess property errors during the creation of object literals. Specify the object invoked for createElement . This only applies when targeting react JSX emit. Skip type checking .d.ts files that are included with TypeScript. Disable error reporting for unused labels. Enable error reporting for codepaths that do not explicitly return in a function. Enable error reporting for fallthrough cases in switch statements. Disable error reporting for unreachable code. Ensure that casing is correct in imports. Allow 'import x from y' when a module doesn't have a default export. Disable adding 'use strict' directives in emitted JavaScript files. Specify a set of bundled library declaration files that describe the target runtime environment. Specify the base directory to resolve bare specifier module names. Specify the output directory for generated declaration files. Enable error reporting when this is given the type any . Skip type checking all .d.ts files. When type checking, take into account null and undefined . Enable error reporting when a local variables aren't read. Raise an error when a function parameter isn't read Ensure 'use strict' is always emitted. Allow importing helper functions from tslib once per project, instead of including them per-file. Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' Disable emitting declarations that have @internal in their JSDoc comments. Enable error reporting in type-checked JavaScript files. Emit more compliant, but verbose and less performant JavaScript for iteration. Enable all strict type checking options. Disable strict checking of generic signatures in function types. Disable resolving symlinks to their realpath. This correlates to the same flag in node. When assigning functions, check to ensure parameters and the return values are subtype-compatible. Check for class properties that are declared but not set in the constructor. Emit additional JavaScript to ease support for importing CommonJS modules. This enables allowSyntheticDefaultImports for type compatibility. Only output d.ts files and not JavaScript files. Make keyof only return strings instead of string, numbers or symbols. Legacy option. Check that the arguments for bind , call , and apply methods match the original function. Disable emitting files if any type checking errors are reported. Because the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option TypeScriptAdditionalFlags to provide specific flags which don’t have a mapping above. For example, this would turn on noPropertyAccessFromIndexSignature :"
                },
                {
                    "type": "code",
                    "code": "xml <TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature </TypeScriptAdditionalFlags>"
                },
                {
                    "type": "p",
                    "text": "You can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:"
                },
                {
                    "type": "code",
                    "code": "xml <PropertyGroup Condition = \"'$(Configuration)' == 'Debug'\" > <TypeScriptRemoveComments> false </TypeScriptRemoveComments> <TypeScriptSourceMap> true </TypeScriptSourceMap> </PropertyGroup> <PropertyGroup Condition = \"'$(Configuration)' == 'Release'\" > <TypeScriptRemoveComments> true </TypeScriptRemoveComments> <TypeScriptSourceMap> false </TypeScriptSourceMap> </PropertyGroup> <Import Project = \"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\" Condition = \"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />"
                },
                {
                    "type": "p",
                    "text": "The value of <TypeScriptToolsVersion>1.7</TypeScriptToolsVersion> property in the project file identifies the compiler version to use to build (1.7 in this example).\nThis allows a project to build against the same versions of the compiler on different machines. If TypeScriptToolsVersion is not specified, the latest compiler version installed on the machine will be used to build. Users using newer versions of TS, will see a prompt to upgrade their project on first load. If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set <TypeScriptCompileBlocked>true</TypeScriptCompileBlocked> in your project.\nThis should give you all the editing support, but not the build when you hit F5. By default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation.\nHowever, if this behavior is causing issues, such as when TypeScript’s incremental option is enabled, set <TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild> to ensure the TypeScript compiler is invoked with every run of MSBuild. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html",
            "title": "TypeScript: Documentation - tsc CLI Options",
            "content": [
                {
                    "type": "p",
                    "text": "Running tsc locally will compile the closest project defined by a tsconfig.json , or you can compile a set of TypeScript\nfiles by passing in a glob of files you want. When input files are specified on the command line, tsconfig.json files are\nignored."
                },
                {
                    "type": "code",
                    "code": "sh # Run a compile based on a backwards look through the fs for a tsconfig.json tsc # Emit JS for just the index.ts with the compiler defaults tsc index.ts # Emit JS for any .ts files in the folder src, with the default settings tsc src/*.ts # Emit files referenced in with the compiler settings from tsconfig.production.json tsc --project tsconfig.production.json # Emit d.ts files for a js file with showing compiler options which are booleans tsc index.js --declaration --emitDeclarationOnly # Emit a single .js file from two files via compiler options which take string arguments tsc app.ts util.ts --target esnext --outfile index.js"
                },
                {
                    "type": "p",
                    "text": "If you’re looking for more information about the compiler options in a tsconfig, check out the TSConfig Reference Gives local information for help on the CLI. Initializes a TypeScript project and creates a tsconfig.json file. Print names of files that are part of the compilation and then stop processing. Set the language of the messaging from TypeScript. This does not affect emit. Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. Print the final configuration instead of building. Build one or more projects and their dependencies, if out of date Delete the outputs of all projects. Show what would be built (or deleted, if specified with '--clean') Build all projects, including those that appear to be up to date. Remove a list of directories from the watch process. Remove a list of files from the watch mode's processing. fixedinterval , priorityinterval , dynamicpriority , or fixedchunksize Specify what approach the watcher should use if the system runs out of native file watchers. Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively. usefsevents , fixedpollinginterval , dynamicprioritypolling , or fixedchunksizepolling Specify how directories are watched on systems that lack recursive file-watching functionality. fixedpollinginterval , prioritypollinginterval , dynamicprioritypolling , fixedchunksizepolling , usefsevents , or usefseventsonparentdirectory Specify how the TypeScript watch mode works. Enable importing files with any extension, provided a declaration file is present. Allow imports to include TypeScript file extensions. Allow JavaScript files to be a part of your program. Use the checkJS option to get errors from these files. true if esModuleInterop is enabled, module is system , or moduleResolution is bundler ; false otherwise. Allow 'import x from y' when a module doesn't have a default export. Allow accessing UMD globals from modules. Disable error reporting for unreachable code. Disable error reporting for unused labels. true if strict ; false otherwise. Ensure 'use strict' is always emitted. Have recompiles in projects that use incremental and watch mode assume that changes within a file will only affect files directly depending on it. Specify the base directory to resolve bare specifier module names. No longer supported. In early versions, manually set the text encoding for reading files. Enable error reporting in type-checked JavaScript files. Enable constraints that allow a TypeScript project to be used with project references. Conditions to set in addition to the resolver-specific defaults when resolving imports. true if composite ; false otherwise. Generate .d.ts files from TypeScript and JavaScript files in your project. Specify the output directory for generated declaration files. Output compiler performance information after building. Reduce the number of projects loaded automatically by TypeScript. Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server. Opt a project out of multi-project reference checking when editing. Disable preferring source files instead of declaration files when referencing composite projects. Emit more compliant, but verbose and less performant JavaScript for iteration. Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. Only output d.ts files and not JavaScript files. Emit design-type metadata for decorated declarations in source files. true if module is node16 or nodenext ; false otherwise. Emit additional JavaScript to ease support for importing CommonJS modules. This enables allowSyntheticDefaultImports for type compatibility. Interpret optional property types as written, rather than adding undefined . Enable experimental support for TC39 stage 2 draft decorators. Print files read during the compilation including why it was included. Output more detailed compiler performance information after building. Ensure that casing is correct in imports. Emit a v8 CPU profile of the compiler run for debugging. Generates an event trace and a list of types. Allow importing helper functions from tslib once per project, instead of including them per-file. remove , preserve , or error Specify emit/checking behavior for imports that are only used for types. true if composite ; false otherwise. Save .tsbuildinfo files to allow for incremental compilation of projects. Include sourcemap files inside the emitted JavaScript. Include source code in the sourcemaps inside the emitted JavaScript. Require sufficient annotation on exports so other tools can trivially generate declaration files. true if verbatimModuleSyntax ; false otherwise. Ensure that each file can be safely transpiled without relying on other imports. preserve , react , react-native , react-jsx , or react-jsxdev Specify what JSX code is generated. Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. Specify module specifier used to import the JSX factory functions when using jsx: react-jsx* . Make keyof only return strings instead of string, numbers or symbols. Legacy option. Specify a set of bundled library declaration files that describe the target runtime environment. Print the names of emitted files after a compilation. Print all of the files read during the compilation. Specify the location where debugger should locate map files instead of generated locations. Specify the maximum folder depth used for checking JavaScript files from node_modules . Only applicable with allowJs . none , commonjs , amd , umd , system , es6 / es2015 , es2020 , es2022 , esnext , node16 , nodenext , or preserve CommonJS if target is ES5 ; ES6 / ES2015 otherwise. Specify what module code is generated. legacy , auto , or force \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules. Specify what method is used to detect whether a file is a script or a module. classic , node10 / node , node16 , nodenext , or bundler Classic if module is AMD , UMD , System , or ES6 / ES2015 ; Matches if module is node16 or nodenext ; Node otherwise. Specify how TypeScript looks up a file from a given module specifier. List of file name suffixes to search when resolving a module. Set the newline character for emitting files. Disable full type checking (only critical parse and emit errors will be reported). Disable emitting files from a compilation. Disable generating custom helper functions like __extends in compiled output. Disable emitting files if any type checking errors are reported. Disable truncating types in error messages. Enable error reporting for fallthrough cases in switch statements. true if strict ; false otherwise. Enable error reporting for expressions and declarations with an implied any type. Ensure overriding members in derived classes are marked with an override modifier. Enable error reporting for codepaths that do not explicitly return in a function. true if strict ; false otherwise. Enable error reporting when this is given the type any . Disable adding 'use strict' directives in emitted JavaScript files. Disable including any library files, including the default lib.d.ts. Enforces using indexed accessors for keys declared using an indexed type. Disallow import s, require s or <reference> s from expanding the number of files TypeScript should add to a project. Disable strict checking of generic signatures in function types. Add undefined to a type when accessed using an index. Enable error reporting when local variables aren't read. Raise an error when a function parameter isn't read. Specify an output folder for all emitted files. Specify a file that bundles all outputs into one JavaScript file. If declaration is true, also designates a file that bundles all .d.ts output. Specify a set of entries that re-map imports to additional lookup locations. Specify a list of language service plugins to include. true if isolatedModules ; false otherwise. Disable erasing const enum declarations in generated code. Disable resolving symlinks to their realpath. This correlates to the same flag in node. Preserve unused imported values in the JavaScript output that would otherwise be removed. Disable wiping the console in watch mode. Enable color and formatting in TypeScript's output to make compiler errors easier to read. Specify the object invoked for createElement . This only applies when targeting react JSX emit. true when moduleResolution is node16 , nodenext , or bundler ; otherwise false Use the package.json 'exports' field when resolving package imports. true when moduleResolution is node16 , nodenext , or bundler ; otherwise false Use the package.json 'imports' field when resolving imports. Computed from the list of input files. Specify the root folder within your source files. Computed from the list of input files. Allow multiple folders to be treated as one when resolving modules. Skip type checking .d.ts files that are included with TypeScript. Skip type checking all .d.ts files. Create source map files for emitted JavaScript files. Specify the root path for debuggers to find the reference source code. Skip building downstream projects on error in upstream project. true if strict ; false otherwise. Check that the arguments for bind , call , and apply methods match the original function. false , unless strict is set Built-in iterators are instantiated with a TReturn type of undefined instead of any. true if strict ; false otherwise. When assigning functions, check to ensure parameters and the return values are subtype-compatible. true if strict ; false otherwise. When type checking, take into account null and undefined . true if strict ; false otherwise. Check for class properties that are declared but not set in the constructor. Disable emitting declarations that have @internal in their JSDoc comments. Disable reporting of excess property errors during the creation of object literals. Suppress noImplicitAny errors when indexing objects that lack index signatures. es3 , es5 , es6 / es2015 , es2016 , es2017 , es2018 , es2019 , es2020 , es2021 , es2022 , es2023 , or esnext Set the JavaScript language version for emitted JavaScript and include compatible library declarations. Log paths used during the moduleResolution process. The file to store .tsbuildinfo incremental build information in. Specify multiple folders that act like ./node_modules/@types . Specify type package names to be included without being referenced in a source file. true if target is ES2022 or higher, including ESNext ; false otherwise. true if strict ; false otherwise. Default catch clause variables as unknown instead of any . Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting."
                },
                {
                    "type": "list",
                    "items": [
                        "Every option is fully explained in the TSConfig Reference .",
                        "Learn how to use a tsconfig.json file.",
                        "Learn how to work in an MSBuild project ."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/configuring-watch.html",
            "title": "TypeScript: Documentation - Configuring Watch",
            "content": [
                {
                    "type": "p",
                    "text": "As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available. The --watch implementation of the compiler relies on Node’s fs.watch and fs.watchFile . Each of these methods has pros and cons. fs.watch relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of Linux ). Heavy use of fs.watch in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses fs.watch to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching. fs.watchFile uses polling and thus costs CPU cycles. However, fs.watchFile is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses fs.watchFile to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using fs.watchFile depends directly on number of files watched in the codebase. The suggested method of configuring watch behavior is through the new watchOptions section of tsconfig.json . We provide an example configuration below. See the following section for detailed descriptions of the settings available."
                },
                {
                    "type": "code",
                    "code": "{ // Some typical compiler options \" compilerOptions \" : { \" target \" : \"es2020\" , \" moduleResolution \" : \"node\" // ... }, // NEW: Options for file/directory watching \"watchOptions\" : { // Use native file system events for files and directories \" watchFile \" : \"useFsEvents\" , \" watchDirectory \" : \"useFsEvents\" , // Poll files for updates more frequently // when they're updated a lot. \" fallbackPolling \" : \"dynamicPriority\" , // Don't coalesce watch notification \" synchronousWatchDirectory \" : true , // Finally, two additional settings for reducing the amount of possible // files to track  work from these directories \" excludeDirectories \" : [ \"**/node_modules\" , \"_build\" ], \" excludeFiles \" : [ \"build/fileWhichChangesOften.ts\" ] } }"
                },
                {
                    "type": "p",
                    "text": "For further details, see the release notes for Typescript 3.8 . For directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by TSC_WATCHDIRECTORY . NOTE: On platforms which support native recursive directory watching, the value of TSC_WATCHDIRECTORY is ignored. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html",
            "title": "TypeScript: Documentation - Declaration Merging",
            "content": [
                {
                    "type": "p",
                    "text": "Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level.\nOne example that is especially unique to TypeScript is the concept of ‘declaration merging’.\nUnderstanding this concept will give you an advantage when working with existing JavaScript.\nIt also opens the door to more advanced abstraction concepts. For the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition.\nThis merged definition has the features of both of the original declarations.\nAny number of declarations can be merged; it’s not limited to just two declarations. In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value.\nNamespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation.\nType-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name.\nLastly, value-creating declarations create values that are visible in the output JavaScript. Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge. The simplest, and perhaps most common, type of declaration merging is interface merging.\nAt the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name."
                },
                {
                    "type": "code",
                    "code": "ts interface Box { height : number ; width : number ; } interface Box { scale : number ; } let box : Box = { height: 5 , width: 6 , scale: 10 };"
                },
                {
                    "type": "p",
                    "text": "Non-function members of the interfaces should be unique.\nIf they are not unique, they must be of the same type.\nThe compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types. For function members, each function member of the same name is treated as describing an overload of the same function.\nOf note, too, is that in the case of interface A merging with later interface A , the second interface will have a higher precedence than the first."
                },
                {
                    "type": "code",
                    "code": "ts interface Cloner { clone ( animal : Animal ): Animal ; } interface Cloner { clone ( animal : Sheep ): Sheep ; } interface Cloner { clone ( animal : Dog ): Dog ; clone ( animal : Cat ): Cat ; }"
                },
                {
                    "type": "p",
                    "text": "The three interfaces will merge to create a single declaration as so:"
                },
                {
                    "type": "code",
                    "code": "ts interface Cloner { clone ( animal : Dog ): Dog ; clone ( animal : Cat ): Cat ; clone ( animal : Sheep ): Sheep ; clone ( animal : Animal ): Animal ; }"
                },
                {
                    "type": "p",
                    "text": "Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first. One exception to this rule is specialized signatures.\nIf a signature has a parameter whose type is a single string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list. For instance, the following interfaces will merge together:"
                },
                {
                    "type": "code",
                    "code": "ts interface Document { createElement ( tagName : any ): Element ; } interface Document { createElement ( tagName : \"div\" ): HTMLDivElement ; createElement ( tagName : \"span\" ): HTMLSpanElement ; } interface Document { createElement ( tagName : string ): HTMLElement ; createElement ( tagName : \"canvas\" ): HTMLCanvasElement ; }"
                },
                {
                    "type": "p",
                    "text": "The resulting merged declaration of Document will be the following:"
                },
                {
                    "type": "code",
                    "code": "ts interface Document { createElement ( tagName : \"canvas\" ): HTMLCanvasElement ; createElement ( tagName : \"div\" ): HTMLDivElement ; createElement ( tagName : \"span\" ): HTMLSpanElement ; createElement ( tagName : string ): HTMLElement ; createElement ( tagName : any ): Element ; }"
                },
                {
                    "type": "p",
                    "text": "Similarly to interfaces, namespaces of the same name will also merge their members.\nSince namespaces create both a namespace and a value, we need to understand how both merge. To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside. To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first. The declaration merge of Animals in this example:"
                },
                {
                    "type": "code",
                    "code": "ts namespace Animals { export class Zebra {} } namespace Animals { export interface Legged { numberOfLegs : number ; } export class Dog {} }"
                },
                {
                    "type": "code",
                    "code": "ts namespace Animals { export interface Legged { numberOfLegs : number ; } export class Zebra {} export class Dog {} }"
                },
                {
                    "type": "p",
                    "text": "This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members.\nNon-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members. We can see this more clearly in this example:"
                },
                {
                    "type": "code",
                    "code": "ts namespace Animal { let haveMuscles = true ; export function animalsHaveMuscles () { return haveMuscles ; } } namespace Animal { export function doAnimalsHaveMuscles () { return haveMuscles ; // Error, because haveMuscles is not accessible here } }"
                },
                {
                    "type": "p",
                    "text": "Because haveMuscles is not exported, only the animalsHaveMuscles function that shares the same un-merged namespace can see the symbol.\nThe doAnimalsHaveMuscles function, even though it’s part of the merged Animal namespace can not see this un-exported member. Namespaces are flexible enough to also merge with other types of declarations.\nTo do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types.\nTypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages. This gives the user a way of describing inner classes."
                },
                {
                    "type": "code",
                    "code": "ts class Album { label : Album . AlbumLabel ; } namespace Album { export class AlbumLabel {} }"
                },
                {
                    "type": "p",
                    "text": "The visibility rules for merged members is the same as described in the Merging Namespaces section, so we must export the AlbumLabel class for the merged class to see it.\nThe end result is a class managed inside of another class.\nYou can also use namespaces to add more static members to an existing class. In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function.\nTypeScript uses declaration merging to build up definitions like this in a type-safe way."
                },
                {
                    "type": "code",
                    "code": "ts function buildLabel ( name : string ): string { return buildLabel . prefix + name + buildLabel . suffix ; } namespace buildLabel { export let suffix = \"\" ; export let prefix = \"Hello, \" ; } console . log ( buildLabel ( \"Sam Smith\" ));"
                },
                {
                    "type": "p",
                    "text": "Similarly, namespaces can be used to extend enums with static members:"
                },
                {
                    "type": "code",
                    "code": "ts enum Color { red = 1 , green = 2 , blue = 4 , } namespace Color { export function mixColor ( colorName : string ) { if ( colorName == \"yellow\" ) { return Color . red + Color . green ; } else if ( colorName == \"white\" ) { return Color . red + Color . green + Color . blue ; } else if ( colorName == \"magenta\" ) { return Color . red + Color . blue ; } else if ( colorName == \"cyan\" ) { return Color . green + Color . blue ; } } }"
                },
                {
                    "type": "p",
                    "text": "Not all merges are allowed in TypeScript.\nCurrently, classes can not merge with other classes or with variables.\nFor information on mimicking class merging, see the Mixins in TypeScript section. Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them.\nLet’s look at a toy Observable example:"
                },
                {
                    "type": "code",
                    "code": "ts // observable.ts export class Observable < T > { // ... implementation left as an exercise for the reader ... } // map.ts import { Observable } from \"./observable\" ; Observable . prototype . map = function ( f ) { // ... another exercise for the reader };"
                },
                {
                    "type": "p",
                    "text": "This works fine in TypeScript too, but the compiler doesn’t know about Observable.prototype.map .\nYou can use module augmentation to tell the compiler about it:"
                },
                {
                    "type": "code",
                    "code": "ts // observable.ts export class Observable < T > { // ... implementation left as an exercise for the reader ... } // map.ts import { Observable } from \"./observable\" ; declare module \"./observable\" { interface Observable < T > { map < U >( f : ( x : T ) => U ): Observable < U >; } } Observable . prototype . map = function ( f ) { // ... another exercise for the reader }; // consumer.ts import { Observable } from \"./observable\" ; import \"./map\" ; let o : Observable < number >; o . map (( x ) => x . toFixed ());"
                },
                {
                    "type": "p",
                    "text": "The module name is resolved the same way as module specifiers in import / export .\nSee Modules for more information.\nThen the declarations in an augmentation are merged as if they were declared in the same file as the original. However, there are two limitations to keep in mind:"
                },
                {
                    "type": "list",
                    "items": [
                        "You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.",
                        "Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and default is a reserved word - see #14080 for details)"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can also add declarations to the global scope from inside a module:"
                },
                {
                    "type": "code",
                    "code": "ts // observable.ts export class Observable < T > { // ... still no implementation ... } declare global { interface Array < T > { toObservable (): Observable < T >; } } Array . prototype . toObservable = function () { // ... };"
                },
                {
                    "type": "p",
                    "text": "Global augmentations have the same behavior and limits as module augmentations. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/decorators.html",
            "title": "TypeScript: Documentation - Decorators",
            "content": [
                {
                    "type": "p",
                    "text": "NOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0.\nSee: Decorators in Typescript 5.0 With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members.\nDecorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Further Reading (stage 2): A Complete Guide to TypeScript Decorators To enable experimental support for decorators, you must enable the experimentalDecorators compiler option either on the command line or in your tsconfig.json :"
                },
                {
                    "type": "code",
                    "code": "shell tsc --target ES5 --experimentalDecorators"
                },
                {
                    "type": "code",
                    "code": "{ \" compilerOptions \" : { \" target \" : \"ES5\" , \" experimentalDecorators \" : true } }"
                },
                {
                    "type": "p",
                    "text": "A Decorator is a special kind of declaration that can be attached to a class declaration , method , accessor , property , or parameter .\nDecorators use the form @expression , where expression must evaluate to a function that will be called at runtime with information about the decorated declaration. For example, given the decorator @sealed we might write the sealed function as follows:"
                },
                {
                    "type": "code",
                    "code": "ts function sealed ( target ) { // do something with 'target' ... }"
                },
                {
                    "type": "p",
                    "text": "If we want to customize how a decorator is applied to a declaration, we can write a decorator factory.\nA Decorator Factory is simply a function that returns the expression that will be called by the decorator at runtime. We can write a decorator factory in the following fashion:"
                },
                {
                    "type": "code",
                    "code": "ts function color ( value : string ) { // this is the decorator factory, it sets up // the returned decorator function return function ( target ) { // this is the decorator // do something with 'target' and 'value'... }; }"
                },
                {
                    "type": "p",
                    "text": "Multiple decorators can be applied to a declaration, for example on a single line:"
                },
                {
                    "type": "code",
                    "code": "ts @ f @ g x Try"
                },
                {
                    "type": "code",
                    "code": "ts @ f @ g x Try"
                },
                {
                    "type": "p",
                    "text": "When multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics . In this model, when composing functions f and g , the resulting composite ( f ∘ g )( x ) is equivalent to f ( g ( x )). As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "The expressions for each decorator are evaluated top-to-bottom.",
                        "The results are then called as functions from bottom-to-top."
                    ]
                },
                {
                    "type": "p",
                    "text": "If we were to use decorator factories , we can observe this evaluation order with the following example:"
                },
                {
                    "type": "code",
                    "code": "ts function first () { console . log ( \"first(): factory evaluated\" ); return function ( target : any , propertyKey : string , descriptor : PropertyDescriptor ) { console . log ( \"first(): called\" ); }; } function second () { console . log ( \"second(): factory evaluated\" ); return function ( target : any , propertyKey : string , descriptor : PropertyDescriptor ) { console . log ( \"second(): called\" ); }; } class ExampleClass { @ first () @ second () method () {} } Try"
                },
                {
                    "type": "p",
                    "text": "Which would print this output to the console:"
                },
                {
                    "type": "code",
                    "code": "shell first (): factory evaluated second (): factory evaluated second (): called first (): called"
                },
                {
                    "type": "p",
                    "text": "There is a well defined order to how decorators applied to various declarations inside of a class are applied:"
                },
                {
                    "type": "list",
                    "items": [
                        "Parameter Decorators , followed by Method , Accessor , or Property Decorators are applied for each instance member.",
                        "Parameter Decorators , followed by Method , Accessor , or Property Decorators are applied for each static member.",
                        "Parameter Decorators are applied for the constructor.",
                        "Class Decorators are applied for the class."
                    ]
                },
                {
                    "type": "p",
                    "text": "A Class Decorator is declared just before a class declaration.\nThe class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition.\nA class decorator cannot be used in a declaration file, or in any other ambient context (such as on a declare class). The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument. If the class decorator returns a value, it will replace the class declaration with the provided constructor function. NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype.\nThe logic that applies decorators at runtime will not do this for you. The following is an example of a class decorator ( @sealed ) applied to a BugReport class:"
                },
                {
                    "type": "code",
                    "code": "ts @ sealed class BugReport { type = \"report\" ; title : string ; constructor ( t : string ) { this . title = t ; } } Try"
                },
                {
                    "type": "p",
                    "text": "We can define the @sealed decorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "ts function sealed ( constructor : Function ) { Object . seal ( constructor ); Object . seal ( constructor . prototype ); }"
                },
                {
                    "type": "p",
                    "text": "When @sealed is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing BugReport.prototype or by defining properties on BugReport itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does not prevent classes from sub-classing BugReport . Next we have an example of how to override the constructor to set new defaults."
                },
                {
                    "type": "code",
                    "code": "ts function reportableClassDecorator < T extends { new (... args : any []): {} }>( constructor : T ) { return class extends constructor { reportingURL = \"http://www...\" ; }; } @ reportableClassDecorator class BugReport { type = \"report\" ; title : string ; constructor ( t : string ) { this . title = t ; } } const bug = new BugReport ( \"Needs dark mode\" ); console . log ( bug . title ); // Prints \"Needs dark mode\" console . log ( bug . type ); // Prints \"report\" // Note that the decorator _does not_ change the TypeScript type // and so the new property `reportingURL` is not known // to the type system: bug . reportingURL ; Property 'reportingURL' does not exist on type 'BugReport'. 2339 Property 'reportingURL' does not exist on type 'BugReport'. Try"
                },
                {
                    "type": "p",
                    "text": "A Method Decorator is declared just before a method declaration.\nThe decorator is applied to the Property Descriptor for the method, and can be used to observe, modify, or replace a method definition.\nA method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a declare class). The expression for the method decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "The Property Descriptor for the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  The Property Descriptor will be undefined if your script target is less than ES5 . If the method decorator returns a value, it will be used as the Property Descriptor for the method. NOTE  The return value is ignored if your script target is less than ES5 . The following is an example of a method decorator ( @enumerable ) applied to a method on the Greeter class:"
                },
                {
                    "type": "code",
                    "code": "ts class Greeter { greeting : string ; constructor ( message : string ) { this . greeting = message ; } @ enumerable ( false ) greet () { return \"Hello, \" + this . greeting ; } } Try"
                },
                {
                    "type": "p",
                    "text": "We can define the @enumerable decorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "ts function enumerable ( value : boolean ) { return function ( target : any , propertyKey : string , descriptor : PropertyDescriptor ) { descriptor . enumerable = value ; }; } Try"
                },
                {
                    "type": "p",
                    "text": "The @enumerable(false) decorator here is a decorator factory .\nWhen the @enumerable(false) decorator is called, it modifies the enumerable property of the property descriptor. An Accessor Decorator is declared just before an accessor declaration.\nThe accessor decorator is applied to the Property Descriptor for the accessor and can be used to observe, modify, or replace an accessor’s definitions.\nAn accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a declare class). NOTE  TypeScript disallows decorating both the get and set accessor for a single member.\nInstead, all decorators for the member must be applied to the first accessor specified in document order.\nThis is because decorators apply to a Property Descriptor , which combines both the get and set accessor, not each declaration separately. The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "The Property Descriptor for the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  The Property Descriptor will be undefined if your script target is less than ES5 . If the accessor decorator returns a value, it will be used as the Property Descriptor for the member. NOTE  The return value is ignored if your script target is less than ES5 . The following is an example of an accessor decorator ( @configurable ) applied to a member of the Point class:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { private _x : number ; private _y : number ; constructor ( x : number , y : number ) { this . _x = x ; this . _y = y ; } @ configurable ( false ) get x () { return this . _x ; } @ configurable ( false ) get y () { return this . _y ; } } Try"
                },
                {
                    "type": "p",
                    "text": "We can define the @configurable decorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "ts function configurable ( value : boolean ) { return function ( target : any , propertyKey : string , descriptor : PropertyDescriptor ) { descriptor . configurable = value ; }; }"
                },
                {
                    "type": "p",
                    "text": "A Property Decorator is declared just before a property declaration.\nA property decorator cannot be used in a declaration file, or in any other ambient context (such as in a declare class). The expression for the property decorator will be called as a function at runtime, with the following two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  A Property Descriptor is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript.\nThis is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too.\nAs such, a property decorator can only be used to observe that a property of a specific name has been declared for a class. We can use this information to record metadata about the property, as in the following example:"
                },
                {
                    "type": "code",
                    "code": "ts class Greeter { @ format ( \"Hello, %s\" ) greeting : string ; constructor ( message : string ) { this . greeting = message ; } greet () { let formatString = getFormat ( this , \"greeting\" ); return formatString . replace ( \"%s\" , this . greeting ); } }"
                },
                {
                    "type": "p",
                    "text": "We can then define the @format decorator and getFormat functions using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "ts import \"reflect-metadata\" ; const formatMetadataKey = Symbol ( \"format\" ); function format ( formatString : string ) { return Reflect . metadata ( formatMetadataKey , formatString ); } function getFormat ( target : any , propertyKey : string ) { return Reflect . getMetadata ( formatMetadataKey , target , propertyKey ); }"
                },
                {
                    "type": "p",
                    "text": "The @format(\"Hello, %s\") decorator here is a decorator factory .\nWhen @format(\"Hello, %s\") is called, it adds a metadata entry for the property using the Reflect.metadata function from the reflect-metadata library.\nWhen getFormat is called, it reads the metadata value for the format. NOTE  This example requires the reflect-metadata library.\nSee Metadata for more information about the reflect-metadata library. A Parameter Decorator is declared just before a parameter declaration.\nThe parameter decorator is applied to the function for a class constructor or method declaration.\nA parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a declare class). The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "The ordinal index of the parameter in the function’s parameter list."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method. The return value of the parameter decorator is ignored. The following is an example of a parameter decorator ( @required ) applied to parameter of a member of the BugReport class:"
                },
                {
                    "type": "code",
                    "code": "ts class BugReport { type = \"report\" ; title : string ; constructor ( t : string ) { this . title = t ; } @ validate print (@ required verbose : boolean ) { if ( verbose ) { return `type: ${ this . type } \\n title: ${ this . title } ` ; } else { return this . title ; } } } Try"
                },
                {
                    "type": "p",
                    "text": "We can then define the @required and @validate decorators using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "ts import \"reflect-metadata\" ; const requiredMetadataKey = Symbol ( \"required\" ); function required ( target : Object , propertyKey : string | symbol , parameterIndex : number ) { let existingRequiredParameters : number [] = Reflect . getOwnMetadata ( requiredMetadataKey , target , propertyKey ) || []; existingRequiredParameters . push ( parameterIndex ); Reflect . defineMetadata ( requiredMetadataKey , existingRequiredParameters , target , propertyKey ); } function validate ( target : any , propertyName : string , descriptor : TypedPropertyDescriptor < Function >) { let method = descriptor . value !; descriptor . value = function () { let requiredParameters : number [] = Reflect . getOwnMetadata ( requiredMetadataKey , target , propertyName ); if ( requiredParameters ) { for ( let parameterIndex of requiredParameters ) { if ( parameterIndex >= arguments . length || arguments [ parameterIndex ] === undefined ) { throw new Error ( \"Missing required argument.\" ); } } } return method . apply ( this , arguments ); }; } Try"
                },
                {
                    "type": "p",
                    "text": "The @required decorator adds a metadata entry that marks the parameter as required.\nThe @validate decorator then wraps the existing print method in a function that validates the arguments before invoking the original method. NOTE  This example requires the reflect-metadata library.\nSee Metadata for more information about the reflect-metadata library. Some examples use the reflect-metadata library which adds a polyfill for an experimental metadata API .\nThis library is not yet part of the ECMAScript (JavaScript) standard.\nHowever, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption. You can install this library via npm:"
                },
                {
                    "type": "code",
                    "code": "shell npm i reflect-metadata --save"
                },
                {
                    "type": "p",
                    "text": "TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators.\nTo enable this experimental support, you must set the emitDecoratorMetadata compiler option either on the command line or in your tsconfig.json :"
                },
                {
                    "type": "code",
                    "code": "shell tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata"
                },
                {
                    "type": "code",
                    "code": "{ \" compilerOptions \" : { \" target \" : \"ES5\" , \" experimentalDecorators \" : true , \" emitDecoratorMetadata \" : true } }"
                },
                {
                    "type": "p",
                    "text": "When enabled, as long as the reflect-metadata library has been imported, additional design-time type information will be exposed at runtime. We can see this in action in the following example:"
                },
                {
                    "type": "code",
                    "code": "ts import \"reflect-metadata\" ; class Point { constructor ( public x : number , public y : number ) {} } class Line { private _start : Point ; private _end : Point ; @ validate set start ( value : Point ) { this . _start = value ; } get start () { return this . _start ; } @ validate set end ( value : Point ) { this . _end = value ; } get end () { return this . _end ; } } function validate < T >( target : any , propertyKey : string , descriptor : TypedPropertyDescriptor < T >) { let set = descriptor . set !; descriptor . set = function ( value : T ) { let type = Reflect . getMetadata ( \"design:type\" , target , propertyKey ); if (!( value instanceof type )) { throw new TypeError ( `Invalid type, got ${ typeof value } not ${ type . name } .` ); } set . call ( this , value ); }; } const line = new Line () line . start = new Point ( 0 , 0 ) // @ts-ignore // line.end = {} // Fails at runtime with: // > Invalid type, got object not Point Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler will inject design-time type information using the @Reflect.metadata decorator.\nYou could consider it the equivalent of the following TypeScript:"
                },
                {
                    "type": "code",
                    "code": "ts class Line { private _start : Point ; private _end : Point ; @ validate @ Reflect . metadata ( \"design:type\" , Point ) set start ( value : Point ) { this . _start = value ; } get start () { return this . _start ; } @ validate @ Reflect . metadata ( \"design:type\" , Point ) set end ( value : Point ) { this . _end = value ; } get end () { return this . _end ; } }"
                },
                {
                    "type": "p",
                    "text": "NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/dom-manipulation.html",
            "title": "TypeScript: Documentation - DOM Manipulation",
            "content": [
                {
                    "type": "p",
                    "text": "In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers. Websites are made up of HTML and/or XML documents. These documents are static, they do not change. The Document Object Model (DOM) is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop. TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in lib.dom.d.ts , one stands out among the rest: HTMLElement . This type is the backbone for DOM manipulation with TypeScript. You can explore the source code for the DOM type definitions"
                },
                {
                    "type": "code",
                    "code": "html <!DOCTYPE html > <html lang = \"en\" > <head><title> TypeScript Dom Manipulation </title></head> <body> <div id = \"app\" ></div> <!-- Assume index.js is the compiled output of index.ts --> <script src = \"index.js\" ></script> </body> </html>"
                },
                {
                    "type": "p",
                    "text": "Let’s explore a TypeScript script that adds a <p>Hello, World!</p> element to the #app element."
                },
                {
                    "type": "code",
                    "code": "ts // 1. Select the div element using the id property const app = document . getElementById ( \"app\" ); // 2. Create a new <p></p> element programmatically const p = document . createElement ( \"p\" ); // 3. Add the text content p . textContent = \"Hello, World!\" ; // 4. Append the p element to the div element app ?. appendChild ( p );"
                },
                {
                    "type": "p",
                    "text": "After compiling and running the index.html page, the resulting HTML will be:"
                },
                {
                    "type": "code",
                    "code": "html <div id = \"app\" > <p> Hello, World! </p> </div>"
                },
                {
                    "type": "p",
                    "text": "The first line of the TypeScript code uses a global variable document . Inspecting the variable shows it is defined by the Document interface from the lib.dom.d.ts file. The code snippet contains calls to two methods, getElementById and createElement . The definition for this method is as follows:"
                },
                {
                    "type": "code",
                    "code": "ts getElementById ( elementId : string ): HTMLElement | null ;"
                },
                {
                    "type": "p",
                    "text": "Pass it an element id string and it will return either HTMLElement or null . This method introduces one of the most important types, HTMLElement . It serves as the base interface for every other element interface. For example, the p variable in the code example is of type HTMLParagraphElement . Also, take note that this method can return null . This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new optional chaining operator is used to call appendChild . The definition for this method is (I have omitted the deprecated definition):"
                },
                {
                    "type": "code",
                    "code": "ts createElement < K extends keyof HTMLElementTagNameMap >( tagName : K , options ?: ElementCreationOptions ): HTMLElementTagNameMap [ K ]; createElement ( tagName : string , options ?: ElementCreationOptions ): HTMLElement ;"
                },
                {
                    "type": "p",
                    "text": "This is an overloaded function definition. The second overload is simplest and works a lot like the getElementById method does. Pass it any string and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags. For example document.createElement('xyz') returns a <xyz></xyz> element, clearly not an element that is specified by the HTML specification. For those interested, you can interact with custom tag elements using the document.getElementsByTagName For the first definition of createElement , it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: <K extends keyof HTMLElementTagNameMap> . This expression defines a generic parameter K that is constrained to the keys of the interface HTMLElementTagNameMap . The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:"
                },
                {
                    "type": "code",
                    "code": "ts interface HTMLElementTagNameMap { \"a\" : HTMLAnchorElement ; \"abbr\" : HTMLElement ; \"address\" : HTMLElement ; \"applet\" : HTMLAppletElement ; \"area\" : HTMLAreaElement ; ... }"
                },
                {
                    "type": "p",
                    "text": "Some elements do not exhibit unique properties and so they just return HTMLElement , but other types do have unique properties and methods so they return their specific interface (which will extend from or implement HTMLElement ). Now, for the remainder of the createElement definition: (tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K] . The first argument tagName is defined as the generic parameter K . The TypeScript interpreter is smart enough to infer the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the tagName argument will be inferred as K and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value HTMLElementTagNameMap[K] takes the tagName argument and uses it to return the corresponding type. This definition is how the p variable from the code snippet gets a type of HTMLParagraphElement . And if the code was document.createElement('a') , then it would be an element of type HTMLAnchorElement . The document.getElementById function returns an HTMLElement . HTMLElement interface extends the Element interface which extends the Node interface. This prototypal extension allows for all HTMLElements to utilize a subset of standard methods. In the code snippet, we use a property defined on the Node interface to append the new p element to the website. The last line of the code snippet is app?.appendChild(p) . The previous, document.getElementById , section detailed that the optional chaining operator is used here because app can potentially be null at runtime. The appendChild method is defined by:"
                },
                {
                    "type": "code",
                    "code": "ts appendChild < T extends Node >( newChild : T ): T ;"
                },
                {
                    "type": "p",
                    "text": "This method works similarly to the createElement method as the generic parameter T is inferred from the newChild argument. T is constrained to another base interface Node . Previously, this document details the HTMLElement interface extends from Element which extends from Node . In the DOM API there is a concept of children elements. For example in the following HTML, the p tags are children of the div element"
                },
                {
                    "type": "code",
                    "code": "tsx <div> <p> Hello, World </p> <p> TypeScript! </p> </div> ; const div = document . getElementsByTagName ( \"div\" )[ 0 ]; div . children ; // HTMLCollection(2) [p, p] div . childNodes ; // NodeList(2) [p, p]"
                },
                {
                    "type": "p",
                    "text": "After capturing the div element, the children prop will return an HTMLCollection list containing the HTMLParagraphElements . The childNodes property will return a similar NodeList list of nodes. Each p tag will still be of type HTMLParagraphElements , but the NodeList can contain additional HTML nodes that the HTMLCollection list cannot. Modify the HTML by removing one of the p tags, but keep the text."
                },
                {
                    "type": "code",
                    "code": "tsx <div> <p> Hello, World </p> TypeScript! </div> ; const div = document . getElementsByTagName ( \"div\" )[ 0 ]; div . children ; // HTMLCollection(1) [p] div . childNodes ; // NodeList(2) [p, text]"
                },
                {
                    "type": "p",
                    "text": "See how both lists change. children now only contains the <p>Hello, World</p> element, and the childNodes contains a text node rather than two p nodes. The text part of the NodeList is the literal Node containing the text TypeScript! . The children list does not contain this Node because it is not considered an HTMLElement . Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in lib.dom.d.ts as:"
                },
                {
                    "type": "code",
                    "code": "ts /** * Returns the first element that is a descendant of node that matches selectors. */ querySelector < K extends keyof HTMLElementTagNameMap >( selectors : K ): HTMLElementTagNameMap [ K ] | null ; querySelector < K extends keyof SVGElementTagNameMap >( selectors : K ): SVGElementTagNameMap [ K ] | null ; querySelector < E extends Element = Element >( selectors : string ): E | null ; /** * Returns all element descendants of node that match selectors. */ querySelectorAll < K extends keyof HTMLElementTagNameMap >( selectors : K ): NodeListOf < HTMLElementTagNameMap [ K ]>; querySelectorAll < K extends keyof SVGElementTagNameMap >( selectors : K ): NodeListOf < SVGElementTagNameMap [ K ]>; querySelectorAll < E extends Element = Element >( selectors : string ): NodeListOf < E >;"
                },
                {
                    "type": "p",
                    "text": "The querySelectorAll definition is similar to getElementsByTagName , except it returns a new type: NodeListOf . This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing NodeListOf<E> with E[] would result in a very similar user experience. NodeListOf only implements the following properties and methods: length , item(index) , forEach((value, key, parent) => void) , and numeric indexing. Additionally, this method returns a list of elements , not nodes , which is what NodeList was returning from the .childNodes method. While this may appear as a discrepancy, take note that interface Element extends from Node . To see these methods in action modify the existing code to:"
                },
                {
                    "type": "code",
                    "code": "tsx <ul> <li> First :) </li> <li> Second! </li> <li> Third times a charm. </li> </ul> ; const first = document . querySelector ( \"li\" ); // returns the first li element const all = document . querySelectorAll ( \"li\" ); // returns the list of all li elements"
                },
                {
                    "type": "p",
                    "text": "The best part about the lib.dom.d.ts type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the HTMLElement interface is documented by this HTMLElement page on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the W3C Recommendation for HTMLElement ."
                },
                {
                    "type": "list",
                    "items": [
                        "ECMA-262 Standard",
                        "Introduction to the DOM"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/enums.html",
            "title": "TypeScript: Handbook - Enums",
            "content": [
                {
                    "type": "p",
                    "text": "Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript. Enums allow a developer to define a set of named constants.\nUsing enums can make it easier to document intent, or create a set of distinct cases.\nTypeScript provides both numeric and string-based enums. We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages.\nAn enum can be defined using the enum keyword."
                },
                {
                    "type": "code",
                    "code": "ts enum Direction { Up = 1 , Down , Left , Right , } Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have a numeric enum where Up is initialized with 1 .\nAll of the following members are auto-incremented from that point on.\nIn other words, Direction.Up has the value 1 , Down has 2 , Left has 3 , and Right has 4 . If we wanted, we could leave off the initializers entirely:"
                },
                {
                    "type": "code",
                    "code": "ts enum Direction { Up , Down , Left , Right , } Try"
                },
                {
                    "type": "p",
                    "text": "Here, Up would have the value 0 , Down would have 1 , etc.\nThis auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum. Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:"
                },
                {
                    "type": "code",
                    "code": "ts enum UserResponse { No = 0 , Yes = 1 , } function respond ( recipient : string , message : UserResponse ): void { // ... } respond ( \"Princess Caroline\" , UserResponse . Yes ); Try"
                },
                {
                    "type": "p",
                    "text": "Numeric enums can be mixed in computed and constant members (see below) .\nThe short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members.\nIn other words, the following isn’t allowed:"
                },
                {
                    "type": "code",
                    "code": "ts enum E { A = getSomeValue (), B , Enum member must have initializer. 1061 Enum member must have initializer. } Try"
                },
                {
                    "type": "p",
                    "text": "String enums are a similar concept, but have some subtle runtime differences as documented below.\nIn a string enum, each member has to be constant-initialized with a string literal, or with another string enum member."
                },
                {
                    "type": "code",
                    "code": "ts enum Direction { Up = \"UP\" , Down = \"DOWN\" , Left = \"LEFT\" , Right = \"RIGHT\" , } Try"
                },
                {
                    "type": "p",
                    "text": "While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well.\nIn other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though reverse mapping can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself. Technically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:"
                },
                {
                    "type": "code",
                    "code": "ts enum BooleanLikeHeterogeneousEnum { No = 0 , Yes = \"YES\" , } Try"
                },
                {
                    "type": "p",
                    "text": "Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this. Each enum member has a value associated with it which can be either constant or computed .\nAn enum member is considered constant if:"
                },
                {
                    "type": "list",
                    "items": [
                        "It is the first member in the enum and it has no initializer, in which case it’s assigned the value 0 : ts // E.X is constant: enum E { X , } Try",
                        "It does not have an initializer and the preceding enum member was a numeric constant.\nIn this case the value of the current enum member will be the value of the preceding enum member plus one. ts // All enum members in 'E1' and 'E2' are constant. enum E1 { X , Y , Z , } enum E2 { A = 1 , B , C , } Try",
                        "The enum member is initialized with a constant enum expression.\nA constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time.\nAn expression is a constant enum expression if it is: a literal enum expression (basically a string literal or a numeric literal) a reference to previously defined constant enum member (which can originate from a different enum) a parenthesized constant enum expression one of the + , - , ~ unary operators applied to constant enum expression + , - , * , / , % , << , >> , >>> , & , | , ^ binary operators with constant enum expressions as operands It is a compile time error for constant enum expressions to be evaluated to NaN or Infinity .",
                        "a literal enum expression (basically a string literal or a numeric literal)",
                        "a reference to previously defined constant enum member (which can originate from a different enum)",
                        "a parenthesized constant enum expression",
                        "one of the + , - , ~ unary operators applied to constant enum expression",
                        "+ , - , * , / , % , << , >> , >>> , & , | , ^ binary operators with constant enum expressions as operands"
                    ]
                },
                {
                    "type": "p",
                    "text": "In all other cases enum member is considered computed."
                },
                {
                    "type": "code",
                    "code": "ts enum FileAccess { // constant members None , Read = 1 << 1 , Write = 1 << 2 , ReadWrite = Read | Write , // computed member G = \"123\" . length , } Try"
                },
                {
                    "type": "p",
                    "text": "There is a special subset of constant enum members that aren’t calculated: literal enum members.\nA literal enum member is a constant enum member with no initialized value, or with values that are initialized to"
                },
                {
                    "type": "list",
                    "items": [
                        "any string literal (e.g. \"foo\" , \"bar\" , \"baz\" )",
                        "any numeric literal (e.g. 1 , 100 )",
                        "a unary minus applied to any numeric literal (e.g. -1 , -100 )"
                    ]
                },
                {
                    "type": "p",
                    "text": "When all members in an enum have literal enum values, some special semantics come into play. The first is that enum members also become types as well!\nFor example, we can say that certain members can only have the value of an enum member:"
                },
                {
                    "type": "code",
                    "code": "ts enum ShapeKind { Circle , Square , } interface Circle { kind : ShapeKind . Circle ; radius : number ; } interface Square { kind : ShapeKind . Square ; sideLength : number ; } let c : Circle = { kind : ShapeKind . Square , Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'. 2322 Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'. radius : 100 , }; Try"
                },
                {
                    "type": "p",
                    "text": "The other change is that enum types themselves effectively become a union of each enum member.\nWith union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself.\nBecause of that, TypeScript can catch bugs where we might be comparing values incorrectly.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts enum E { Foo , Bar , } function f ( x : E ) { if ( x !== E . Foo || x !== E . Bar ) { This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap. 2367 This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap. // } } Try"
                },
                {
                    "type": "p",
                    "text": "In that example, we first checked whether x was not E.Foo .\nIf that check succeeds, then our || will short-circuit, and the body of the ‘if’ will run.\nHowever, if the check didn’t succeed, then x can only be E.Foo , so it doesn’t make sense to see whether it’s not equal to E.Bar . Enums are real objects that exist at runtime.\nFor example, the following enum"
                },
                {
                    "type": "code",
                    "code": "ts enum E { X , Y , Z , } Try"
                },
                {
                    "type": "p",
                    "text": "can actually be passed around to functions"
                },
                {
                    "type": "code",
                    "code": "ts enum E { X , Y , Z , } function f ( obj : { X : number }) { return obj . X ; } // Works, since 'E' has a property named 'X' which is a number. f ( E ); Try"
                },
                {
                    "type": "p",
                    "text": "Even though Enums are real objects that exist at runtime, the keyof keyword works differently than you might expect for typical objects. Instead, use keyof typeof to get a Type that represents all Enum keys as strings."
                },
                {
                    "type": "code",
                    "code": "ts enum LogLevel { ERROR , WARN , INFO , DEBUG , } /** * This is equivalent to: * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG'; */ type LogLevelStrings = keyof typeof LogLevel ; function printImportant ( key : LogLevelStrings , message : string ) { const num = LogLevel [ key ]; if ( num <= LogLevel . WARN ) { console . log ( \"Log level key is:\" , key ); console . log ( \"Log level value is:\" , num ); console . log ( \"Log level message is:\" , message ); } } printImportant ( \"ERROR\" , \"This is a message\" ); Try"
                },
                {
                    "type": "p",
                    "text": "In addition to creating an object with property names for members, numeric enums members also get a reverse mapping from enum values to enum names.\nFor example, in this example:"
                },
                {
                    "type": "code",
                    "code": "ts enum Enum { A , } let a = Enum . A ; let nameOfA = Enum [ a ]; // \"A\" Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript compiles this down to the following JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts \"use strict\" ; var Enum ; ( function ( Enum ) { Enum [ Enum [ \"A\" ] = 0 ] = \"A\" ; })( Enum || ( Enum = {})); let a = Enum . A ; let nameOfA = Enum [ a ]; // \"A\" Try"
                },
                {
                    "type": "p",
                    "text": "In this generated code, an enum is compiled into an object that stores both forward ( name -> value ) and reverse ( value -> name ) mappings.\nReferences to other enum members are always emitted as property accesses and never inlined. Keep in mind that string enum members do not get a reverse mapping generated at all. In most cases, enums are a perfectly valid solution.\nHowever sometimes requirements are tighter.\nTo avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use const enums.\nConst enums are defined using the const modifier on our enums:"
                },
                {
                    "type": "code",
                    "code": "ts const enum Enum { A = 1 , B = A * 2 , } Try"
                },
                {
                    "type": "p",
                    "text": "Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation.\nConst enum members are inlined at use sites.\nThis is possible since const enums cannot have computed members."
                },
                {
                    "type": "code",
                    "code": "ts const enum Direction { Up , Down , Left , Right , } let directions = [ Direction . Up , Direction . Down , Direction . Left , Direction . Right , ]; Try"
                },
                {
                    "type": "code",
                    "code": "ts \"use strict\" ; let directions = [ 0 /* Direction.Up */ , 1 /* Direction.Down */ , 2 /* Direction.Left */ , 3 /* Direction.Right */ , ]; Try"
                },
                {
                    "type": "p",
                    "text": "Inlining enum values is straightforward at first, but comes with subtle implications.\nThese pitfalls pertain to ambient const enums only (basically const enums in .d.ts files) and sharing them between projects, but if you are publishing or consuming .d.ts files, these pitfalls likely apply to you, because tsc --declaration transforms .ts files into .d.ts files."
                },
                {
                    "type": "list",
                    "items": [
                        "For the reasons laid out in the isolatedModules documentation , that mode is fundamentally incompatible with ambient const enums.\nThis means if you publish ambient const enums, downstream consumers will not be able to use isolatedModules and those enum values at the same time.",
                        "You can easily inline values from version A of a dependency at compile time, and import version B at runtime.\nVersion A and B’s enums can have different values, if you are not very careful, resulting in surprising bugs , like taking the wrong branches of if statements.\nThese bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.",
                        "importsNotUsedAsValues: \"preserve\" will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime .js files exist.\nThe unresolvable imports cause errors at runtime.\nThe usual way to unambiguously elide imports, type-only imports , does not allow const enum values , currently."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here are two approaches to avoiding these pitfalls:"
                },
                {
                    "type": "list",
                    "items": [
                        "Do not use const enums at all.\nYou can easily ban const enums with the help of a linter.\nObviously this avoids any issues with const enums, but prevents your project from inlining its own enums.\nUnlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.",
                        "Do not publish ambient const enums, by deconstifying them with the help of preserveConstEnums .\nThis is the approach taken internally by the TypeScript project itself . preserveConstEnums emits the same JavaScript for const enums as plain enums.\nYou can then safely strip the const modifier from .d.ts files in a build step . This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely."
                    ]
                },
                {
                    "type": "p",
                    "text": "Ambient enums are used to describe the shape of already existing enum types."
                },
                {
                    "type": "code",
                    "code": "ts declare enum Enum { A = 1 , B , C = 2 , } Try"
                },
                {
                    "type": "p",
                    "text": "One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant.\nBy contrast, an ambient (and non-const) enum member that does not have an initializer is always considered computed. In modern TypeScript, you may not need an enum when an object with as const could suffice:"
                },
                {
                    "type": "code",
                    "code": "ts const enum EDirection { Up , Down , Left , Right , } const ODirection = { Up : 0 , Down : 1 , Left : 2 , Right : 3 , } as const ; EDirection . Up ; (enum member) EDirection.Up = 0 ODirection . Up ; (property) Up: 0 // Using the enum as a parameter function walk ( dir : EDirection ) {} // It requires an extra line to pull out the values type Direction = typeof ODirection [ keyof typeof ODirection ]; function run ( dir : Direction ) {} walk ( EDirection . Left ); run ( ODirection . Right ); Try"
                },
                {
                    "type": "p",
                    "text": "The biggest argument in favour of this format over TypeScript’s enum is that it keeps your codebase aligned with the state of JavaScript, and when/if enums are added to JavaScript then you can move to the additional syntax. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/gulp.html",
            "title": "TypeScript: Documentation - Gulp",
            "content": [
                {
                    "type": "p",
                    "text": "This quick start guide will teach you how to build TypeScript with gulp and then add Browserify , terser , or Watchify to the gulp pipeline.\nThis guide also shows how to add Babel functionality using Babelify . We assume that you’re already using Node.js with npm . Let’s start out with a new directory.\nWe’ll name it proj for now, but you can change it to whatever you want."
                },
                {
                    "type": "code",
                    "code": "shell mkdir proj cd proj"
                },
                {
                    "type": "p",
                    "text": "To start, we’re going to structure our project in the following way:"
                },
                {
                    "type": "code",
                    "code": "proj/ ├─ src/ └─ dist/"
                },
                {
                    "type": "p",
                    "text": "TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist ."
                },
                {
                    "type": "code",
                    "code": "shell mkdir src mkdir dist"
                },
                {
                    "type": "p",
                    "text": "Now we’ll turn this folder into an npm package."
                },
                {
                    "type": "code",
                    "code": "shell npm init"
                },
                {
                    "type": "p",
                    "text": "You’ll be given a series of prompts.\nYou can use the defaults except for your entry point.\nFor your entry point, use ./dist/main.js .\nYou can always go back and change these in the package.json file that’s been generated for you. Now we can use npm install to install packages.\nFirst install gulp-cli globally (if you use a Unix system, you may need to prefix the npm install commands in this guide with sudo )."
                },
                {
                    "type": "code",
                    "code": "shell npm install -g gulp-cli"
                },
                {
                    "type": "p",
                    "text": "Then install typescript , gulp and gulp-typescript in your project’s dev dependencies. Gulp-typescript is a gulp plugin for TypeScript."
                },
                {
                    "type": "code",
                    "code": "shell npm install --save-dev typescript gulp@4.0.0 gulp-typescript"
                },
                {
                    "type": "p",
                    "text": "Let’s write a Hello World program.\nIn src , create the file main.ts :"
                },
                {
                    "type": "code",
                    "code": "ts function hello ( compiler : string ) { console . log ( `Hello from ${ compiler } ` ); } hello ( \"TypeScript\" );"
                },
                {
                    "type": "p",
                    "text": "In the project root, proj , create the file tsconfig.json :"
                },
                {
                    "type": "code",
                    "code": "{ \" files \" : [ \"src/main.ts\" ], \" compilerOptions \" : { \" noImplicitAny \" : true , \" target \" : \"es5\" } }"
                },
                {
                    "type": "p",
                    "text": "In the project root, create the file gulpfile.js :"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var ts = require ( \"gulp-typescript\" ); var tsProject = ts . createProject ( \"tsconfig.json\" ); gulp . task ( \"default\" , function () { return tsProject . src (). pipe ( tsProject ()). js . pipe ( gulp . dest ( \"dist\" )); });"
                },
                {
                    "type": "code",
                    "code": "shell gulp node dist/main.js"
                },
                {
                    "type": "p",
                    "text": "The program should print “Hello from TypeScript!“. Before we get to Browserify, let’s build our code out and add modules to the mix.\nThis is the structure you’re more likely to use for a real app. Create a file called src/greet.ts :"
                },
                {
                    "type": "code",
                    "code": "ts export function sayHello ( name : string ) { return `Hello from ${ name } ` ; }"
                },
                {
                    "type": "p",
                    "text": "Now change the code in src/main.ts to import sayHello from greet.ts :"
                },
                {
                    "type": "code",
                    "code": "ts import { sayHello } from \"./greet\" ; console . log ( sayHello ( \"TypeScript\" ));"
                },
                {
                    "type": "p",
                    "text": "Finally, add src/greet.ts to tsconfig.json :"
                },
                {
                    "type": "code",
                    "code": "{ \" files \" : [ \"src/main.ts\" , \"src/greet.ts\" ], \" compilerOptions \" : { \" noImplicitAny \" : true , \" target \" : \"es5\" } }"
                },
                {
                    "type": "p",
                    "text": "Make sure that the modules work by running gulp and then testing in Node:"
                },
                {
                    "type": "code",
                    "code": "shell gulp node dist/main.js"
                },
                {
                    "type": "p",
                    "text": "Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses.\nWe’ll stick with CommonJS for this tutorial, but you could set module in the options object to change this. Now let’s move this project from Node to the browser.\nTo do this, we’d like to bundle all our modules into one JavaScript file.\nFortunately, that’s exactly what Browserify does.\nEven better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit.\nThat means our TypeScript and Node setup will transfer to the browser basically unchanged. First, install browserify, tsify , and vinyl-source-stream.\ntsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler.\nvinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called vinyl ."
                },
                {
                    "type": "code",
                    "code": "shell npm install --save-dev browserify tsify vinyl-source-stream"
                },
                {
                    "type": "p",
                    "text": "Create a file in src named index.html :"
                },
                {
                    "type": "code",
                    "code": "html <!DOCTYPE html > <html> <head> <meta charset = \"UTF-8\" /> <title> Hello World! </title> </head> <body> <p id = \"greeting\" > Loading ... </p> <script src = \"bundle.js\" ></script> </body> </html>"
                },
                {
                    "type": "p",
                    "text": "Now change main.ts to update the page:"
                },
                {
                    "type": "code",
                    "code": "ts import { sayHello } from \"./greet\" ; function showHello ( divName : string , name : string ) { const elt = document . getElementById ( divName ); elt . innerText = sayHello ( name ); } showHello ( \"greeting\" , \"TypeScript\" );"
                },
                {
                    "type": "p",
                    "text": "Calling showHello calls sayHello to change the paragraph’s text.\nNow change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var browserify = require ( \"browserify\" ); var source = require ( \"vinyl-source-stream\" ); var tsify = require ( \"tsify\" ); var paths = { pages: [ \"src/*.html\" ], }; gulp . task ( \"copy-html\" , function () { return gulp . src ( paths . pages ). pipe ( gulp . dest ( \"dist\" )); }); gulp . task ( \"default\" , gulp . series ( gulp . parallel ( \"copy-html\" ), function () { return browserify ({ basedir: \".\" , debug: true , entries: [ \"src/main.ts\" ], cache: {}, packageCache: {}, }) . plugin ( tsify ) . bundle () . pipe ( source ( \"bundle.js\" )) . pipe ( gulp . dest ( \"dist\" )); }) );"
                },
                {
                    "type": "p",
                    "text": "This adds the copy-html task and adds it as a dependency of default .\nThat means any time default is run, copy-html has to run first.\nWe’ve also changed default to call Browserify with the tsify plugin instead of gulp-typescript.\nConveniently, they both allow us to pass the same options object to the TypeScript compiler. After calling bundle we use source (our alias for vinyl-source-stream) to name our output bundle bundle.js . Test the page by running gulp and then opening dist/index.html in a browser.\nYou should see “Hello from TypeScript” on the page. Notice that we specified debug: true to Browserify.\nThis causes tsify to emit source maps inside the bundled JavaScript file.\nSource maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript.\nYou can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside main.ts .\nWhen you refresh the page the breakpoint should pause the page and let you debug greet.ts . Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins."
                },
                {
                    "type": "list",
                    "items": [
                        "Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file.\nThis lets you keep an edit-save-refresh cycle going in the browser.",
                        "Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3.\nThis lets you add extensive and customized transformations that TypeScript doesn’t support.",
                        "Terser compacts your code so that it takes less time to download."
                    ]
                },
                {
                    "type": "p",
                    "text": "We’ll start with Watchify to provide background compilation:"
                },
                {
                    "type": "code",
                    "code": "shell npm install --save-dev watchify fancy-log"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var browserify = require ( \"browserify\" ); var source = require ( \"vinyl-source-stream\" ); var watchify = require ( \"watchify\" ); var tsify = require ( \"tsify\" ); var fancy_log = require ( \"fancy-log\" ); var paths = { pages: [ \"src/*.html\" ], }; var watchedBrowserify = watchify ( browserify ({ basedir: \".\" , debug: true , entries: [ \"src/main.ts\" ], cache: {}, packageCache: {}, }). plugin ( tsify ) ); gulp . task ( \"copy-html\" , function () { return gulp . src ( paths . pages ). pipe ( gulp . dest ( \"dist\" )); }); function bundle () { return watchedBrowserify . bundle () . on ( \"error\" , fancy_log ) . pipe ( source ( \"bundle.js\" )) . pipe ( gulp . dest ( \"dist\" )); } gulp . task ( \"default\" , gulp . series ( gulp . parallel ( \"copy-html\" ), bundle )); watchedBrowserify . on ( \"update\" , bundle ); watchedBrowserify . on ( \"log\" , fancy_log );"
                },
                {
                    "type": "p",
                    "text": "There are basically three changes here, but they require you to refactor your code a bit."
                },
                {
                    "type": "list",
                    "items": [
                        "We wrapped our browserify instance in a call to watchify , and then held on to the result.",
                        "We called watchedBrowserify.on('update', bundle); so that Browserify will run the bundle function every time one of your TypeScript files changes.",
                        "We called watchedBrowserify.on('log', fancy_log); to log to the console."
                    ]
                },
                {
                    "type": "p",
                    "text": "Together (1) and (2) mean that we have to move our call to browserify out of the default task.\nAnd we have to give the function for default a name since both Watchify and Gulp need to call it.\nAdding logging with (3) is optional but very useful for debugging your setup. Now when you run Gulp, it should start and stay running.\nTry changing the code for showHello in main.ts and saving it.\nYou should see output that looks like this:"
                },
                {
                    "type": "code",
                    "code": "shell proj$ gulp [10:34:20] Using gulpfile ~/src/proj/gulpfile.js [10:34:20] Starting 'copy-html' ... [10:34:20] Finished 'copy-html' after 26 ms [10:34:20] Starting 'default' ... [10:34:21] 2824 bytes written (0.13 seconds) [10:34:21] Finished 'default' after 1.36 s [10:35:22] 2261 bytes written (0.02 seconds) [10:35:24] 2808 bytes written (0.05 seconds)"
                },
                {
                    "type": "p",
                    "text": "First install Terser.\nSince the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working."
                },
                {
                    "type": "code",
                    "code": "shell npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var browserify = require ( \"browserify\" ); var source = require ( \"vinyl-source-stream\" ); var terser = require ( \"gulp-terser\" ); var tsify = require ( \"tsify\" ); var sourcemaps = require ( \"gulp-sourcemaps\" ); var buffer = require ( \"vinyl-buffer\" ); var paths = { pages: [ \"src/*.html\" ], }; gulp . task ( \"copy-html\" , function () { return gulp . src ( paths . pages ). pipe ( gulp . dest ( \"dist\" )); }); gulp . task ( \"default\" , gulp . series ( gulp . parallel ( \"copy-html\" ), function () { return browserify ({ basedir: \".\" , debug: true , entries: [ \"src/main.ts\" ], cache: {}, packageCache: {}, }) . plugin ( tsify ) . bundle () . pipe ( source ( \"bundle.js\" )) . pipe ( buffer ()) . pipe ( sourcemaps . init ({ loadMaps: true })) . pipe ( terser ()) . pipe ( sourcemaps . write ( \"./\" )) . pipe ( gulp . dest ( \"dist\" )); }) );"
                },
                {
                    "type": "p",
                    "text": "Notice that terser itself has just one call — the calls to buffer and sourcemaps exist to make sure sourcemaps keep working.\nThese calls give us a separate sourcemap file instead of using inline sourcemaps like before.\nNow you can run Gulp and check that bundle.js does get minified into an unreadable mess:"
                },
                {
                    "type": "code",
                    "code": "shell gulp cat dist/bundle.js"
                },
                {
                    "type": "p",
                    "text": "First install Babelify and the Babel preset for ES2015.\nLike Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps.\nBy default Babelify will only process files with extensions of .js , .es , .es6 and .jsx so we need to add the .ts extension as an option to Babelify."
                },
                {
                    "type": "code",
                    "code": "shell npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var browserify = require ( \"browserify\" ); var source = require ( \"vinyl-source-stream\" ); var tsify = require ( \"tsify\" ); var sourcemaps = require ( \"gulp-sourcemaps\" ); var buffer = require ( \"vinyl-buffer\" ); var paths = { pages: [ \"src/*.html\" ], }; gulp . task ( \"copy-html\" , function () { return gulp . src ( paths . pages ). pipe ( gulp . dest ( \"dist\" )); }); gulp . task ( \"default\" , gulp . series ( gulp . parallel ( \"copy-html\" ), function () { return browserify ({ basedir: \".\" , debug: true , entries: [ \"src/main.ts\" ], cache: {}, packageCache: {}, }) . plugin ( tsify ) . transform ( \"babelify\" , { presets: [ \"es2015\" ], extensions: [ \".ts\" ], }) . bundle () . pipe ( source ( \"bundle.js\" )) . pipe ( buffer ()) . pipe ( sourcemaps . init ({ loadMaps: true })) . pipe ( sourcemaps . write ( \"./\" )) . pipe ( gulp . dest ( \"dist\" )); }) );"
                },
                {
                    "type": "p",
                    "text": "We also need to have TypeScript target ES2015.\nBabel will then produce ES5 from the ES2015 code that TypeScript emits.\nLet’s modify tsconfig.json :"
                },
                {
                    "type": "code",
                    "code": "{ \" files \" : [ \"src/main.ts\" ], \" compilerOptions \" : { \" noImplicitAny \" : true , \" target \" : \"es2015\" } }"
                },
                {
                    "type": "p",
                    "text": "Babel’s ES5 output should be very similar to TypeScript’s output for such a simple script. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html",
            "title": "TypeScript: Documentation - Integrating with Build Tools",
            "content": [
                {
                    "type": "code",
                    "code": "sh npm install @babel/cli @babel/core @babel/preset-typescript --save-dev"
                },
                {
                    "type": "code",
                    "code": "js { \"presets\" : [ \"@babel/preset-typescript\" ] }"
                },
                {
                    "type": "code",
                    "code": "sh ./node_modules/.bin/babel --out-file bundle.js src/index.ts"
                },
                {
                    "type": "code",
                    "code": "js { \"scripts\" : { \"build\" : \"babel --out-file bundle.js main.ts\" }, }"
                },
                {
                    "type": "code",
                    "code": "sh npm run build"
                },
                {
                    "type": "code",
                    "code": "sh npm install tsify"
                },
                {
                    "type": "code",
                    "code": "sh browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js"
                },
                {
                    "type": "code",
                    "code": "js var browserify = require ( \"browserify\" ); var tsify = require ( \"tsify\" ); browserify () . add ( \"main.ts\" ) . plugin ( \"tsify\" , { noImplicitAny: true }) . bundle () . pipe ( process . stdout );"
                },
                {
                    "type": "code",
                    "code": "sh npm install grunt-ts --save-dev"
                },
                {
                    "type": "code",
                    "code": "js module . exports = function ( grunt ) { grunt . initConfig ({ ts: { default: { src: [ \"**/*.ts\" , \"!node_modules/**/*.ts\" ], }, }, }); grunt . loadNpmTasks ( \"grunt-ts\" ); grunt . registerTask ( \"default\" , [ \"ts\" ]); };"
                },
                {
                    "type": "code",
                    "code": "sh npm install grunt-browserify tsify --save-dev"
                },
                {
                    "type": "code",
                    "code": "js module . exports = function ( grunt ) { grunt . initConfig ({ browserify: { all: { src: \"src/main.ts\" , dest: \"dist/main.js\" , options: { plugin: [ \"tsify\" ], }, }, }, }); grunt . loadNpmTasks ( \"grunt-browserify\" ); grunt . registerTask ( \"default\" , [ \"browserify\" ]); };"
                },
                {
                    "type": "code",
                    "code": "sh npm install gulp-typescript"
                },
                {
                    "type": "code",
                    "code": "js var gulp = require ( \"gulp\" ); var ts = require ( \"gulp-typescript\" ); gulp . task ( \"default\" , function () { var tsResult = gulp . src ( \"src/*.ts\" ). pipe ( ts ({ noImplicitAny: true , out: \"output.js\" , }) ); return tsResult . js . pipe ( gulp . dest ( \"built/local\" )); });"
                },
                {
                    "type": "code",
                    "code": "sh npm install -g jspm@beta"
                },
                {
                    "type": "p",
                    "text": "Note: Currently TypeScript support in jspm is in 0.16beta Update project file to include locally installed Microsoft.TypeScript.Default.props (at the top) and Microsoft.TypeScript.targets (at the bottom) files:"
                },
                {
                    "type": "code",
                    "code": "xml <?xml version = \"1.0\" encoding = \"utf-8\" ?> <Project ToolsVersion = \"4.0\" DefaultTargets = \"Build\" xmlns = \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- Include default props at the top --> <Import Project = \"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\" Condition = \"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" /> <!-- TypeScript configurations go here --> <PropertyGroup Condition = \"'$(Configuration)' == 'Debug'\" > <TypeScriptRemoveComments> false </TypeScriptRemoveComments> <TypeScriptSourceMap> true </TypeScriptSourceMap> </PropertyGroup> <PropertyGroup Condition = \"'$(Configuration)' == 'Release'\" > <TypeScriptRemoveComments> true </TypeScriptRemoveComments> <TypeScriptSourceMap> false </TypeScriptSourceMap> </PropertyGroup> <!-- Include default targets at the bottom --> <Import Project = \"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\" Condition = \"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" /> </Project>"
                },
                {
                    "type": "p",
                    "text": "More details about defining MSBuild compiler options: Setting Compiler Options in MSBuild projects"
                },
                {
                    "type": "list",
                    "items": [
                        "Right-Click -> Manage NuGet Packages",
                        "Search for Microsoft.TypeScript.MSBuild",
                        "Hit Install",
                        "When install is complete, rebuild!"
                    ]
                },
                {
                    "type": "p",
                    "text": "More details can be found at Package Manager Dialog and using nightly builds with NuGet"
                },
                {
                    "type": "code",
                    "code": "npm install @rollup/plugin-typescript --save-dev"
                },
                {
                    "type": "p",
                    "text": "Note that both typescript and tslib are peer dependencies of this plugin that need to be installed separately. Create a rollup.config.js configuration file and import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js // rollup.config.js import typescript from '@rollup/plugin-typescript' ; export default { input: 'src/index.ts' , output: { dir: 'output' , format: 'cjs' }, plugins: [ typescript ()] };"
                },
                {
                    "type": "code",
                    "code": "npm install --save-dev svelte-preprocess"
                },
                {
                    "type": "p",
                    "text": "Note that typescript is an optional peer dependencies of this plugin and needs to be installed separately. tslib is not provided either. You may also consider svelte-check for CLI type checking. Create a svelte.config.js configuration file and import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js // svelte.config.js import preprocess from 'svelte-preprocess' ; const config = { // Consult https://github.com/sveltejs/svelte-preprocess // for more information about preprocessors preprocess: preprocess () }; export default config ;"
                },
                {
                    "type": "p",
                    "text": "You can now specify that script blocks are written in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "<script lang=\"ts\">"
                },
                {
                    "type": "p",
                    "text": "Vite supports importing .ts files out-of-the-box. It only performs transpilation and not type checking. It also requires that some compilerOptions have certain values. See the Vite docs for more details."
                },
                {
                    "type": "code",
                    "code": "sh npm install ts-loader --save-dev"
                },
                {
                    "type": "code",
                    "code": "js const path = require ( 'path' ); module . exports = { entry: './src/index.ts' , module: { rules: [ { test: / \\. tsx ? $ / , use: 'ts-loader' , exclude: /node_modules/ , }, ], }, resolve: { extensions: [ '.tsx' , '.ts' , '.js' ], }, output: { filename: 'bundle.js' , path: path . resolve ( __dirname , 'dist' ), }, };"
                },
                {
                    "type": "p",
                    "text": "See more details on ts-loader here . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/interfaces.html",
            "title": "TypeScript: Handbook - Interfaces",
            "content": [
                {
                    "type": "p",
                    "text": "This handbook page has been replaced, go to the new page One of TypeScript’s core principles is that type checking focuses on the shape that values have.\nThis is sometimes called “duck typing” or “structural subtyping”.\nIn TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project. The easiest way to see how interfaces work is to start with a simple example:"
                },
                {
                    "type": "code",
                    "code": "ts function printLabel ( labeledObj : { label : string }) { console . log ( labeledObj . label ); } let myObj = { size : 10 , label : \"Size 10 Object\" }; printLabel ( myObj ); Try"
                },
                {
                    "type": "p",
                    "text": "The type checker checks the call to printLabel .\nThe printLabel function has a single parameter that requires that the object passed in has a property called label of type string .\nNotice that our object actually has more properties than this, but the compiler only checks that at least the ones required are present and match the types required.\nThere are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit. We can write the same example again, this time using an interface to describe the requirement of having the label property that is a string:"
                },
                {
                    "type": "code",
                    "code": "ts interface LabeledValue { label : string ; } function printLabel ( labeledObj : LabeledValue ) { console . log ( labeledObj . label ); } let myObj = { size : 10 , label : \"Size 10 Object\" }; printLabel ( myObj ); Try"
                },
                {
                    "type": "p",
                    "text": "The interface LabeledValue is a name we can now use to describe the requirement in the previous example.\nIt still represents having a single property called label that is of type string .\nNotice we didn’t have to explicitly say that the object we pass to printLabel implements this interface like we might have to in other languages.\nHere, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed. It’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type. Not all properties of an interface may be required.\nSome exist under certain conditions or may not be there at all.\nThese optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in. Here’s an example of this pattern:"
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; } function createSquare ( config : SquareConfig ): { color : string ; area : number } { let newSquare = { color : \"white\" , area : 100 }; if ( config . color ) { newSquare . color = config . color ; } if ( config . width ) { newSquare . area = config . width * config . width ; } return newSquare ; } let mySquare = createSquare ({ color : \"black\" }); Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a ? at the end of the property name in the declaration. The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface.\nFor example, had we mistyped the name of the color property in createSquare , we would get an error message letting us know:"
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; } function createSquare ( config : SquareConfig ): { color : string ; area : number } { let newSquare = { color : \"white\" , area : 100 }; if ( config . clor ) { Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'? 2551 Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'? // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare . color = config . clor ; Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'? 2551 Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'? } if ( config . width ) { newSquare . area = config . width * config . width ; } return newSquare ; } let mySquare = createSquare ({ color : \"black\" }); Try"
                },
                {
                    "type": "p",
                    "text": "Some properties should only be modifiable when an object is first created.\nYou can specify this by putting readonly before the name of the property:"
                },
                {
                    "type": "code",
                    "code": "ts interface Point { readonly x : number ; readonly y : number ; } Try"
                },
                {
                    "type": "p",
                    "text": "You can construct a Point by assigning an object literal.\nAfter the assignment, x and y can’t be changed."
                },
                {
                    "type": "code",
                    "code": "ts let p1 : Point = { x : 10 , y : 20 }; p1 . x = 5 ; // error! Cannot assign to 'x' because it is a read-only property. 2540 Cannot assign to 'x' because it is a read-only property. Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript comes with a ReadonlyArray<T> type that is the same as Array<T> with all mutating methods removed, so you can make sure you don’t change your arrays after creation:"
                },
                {
                    "type": "code",
                    "code": "ts let a : number [] = [ 1 , 2 , 3 , 4 ]; let ro : ReadonlyArray < number > = a ; ro [ 0 ] = 12 ; // error! Index signature in type 'readonly number[]' only permits reading. 2542 Index signature in type 'readonly number[]' only permits reading. ro . push ( 5 ); // error! Property 'push' does not exist on type 'readonly number[]'. 2339 Property 'push' does not exist on type 'readonly number[]'. ro . length = 100 ; // error! Cannot assign to 'length' because it is a read-only property. 2540 Cannot assign to 'length' because it is a read-only property. a = ro ; // error! The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. 4104 The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. Try"
                },
                {
                    "type": "p",
                    "text": "On the last line of the snippet you can see that even assigning the entire ReadonlyArray back to a normal array is illegal.\nYou can still override it with a type assertion, though:"
                },
                {
                    "type": "code",
                    "code": "ts let a : number [] = [ 1 , 2 , 3 , 4 ]; let ro : ReadonlyArray < number > = a ; a = ro as number []; Try"
                },
                {
                    "type": "p",
                    "text": "The easiest way to remember whether to use readonly or const is to ask whether you’re using it on a variable or a property.\nVariables use const whereas properties use readonly . In our first example using interfaces, TypeScript lets us pass { size: number; label: string; } to something that only expected a { label: string; } .\nWe also just learned about optional properties, and how they’re useful when describing so-called “option bags”. However, combining the two naively would allow an error to sneak in. For example, taking our last example using createSquare :"
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; } function createSquare ( config : SquareConfig ): { color : string ; area : number } { return { color : config . color || \"red\" , area : config . width ? config . width * config . width : 20 , }; } let mySquare = createSquare ({ colour : \"red\" , width : 100 }); Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 2561 Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? Try"
                },
                {
                    "type": "p",
                    "text": "Notice the given argument to createSquare is spelled colour instead of color .\nIn plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since the width properties are compatible, there’s no color property present, and the extra colour property is insignificant. However, TypeScript takes the stance that there’s probably a bug in this code.\nObject literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments.\nIf an object literal has any properties that the “target type” doesn’t have, you’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "ts let mySquare = createSquare ({ colour : \"red\" , width : 100 }); Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 2561 Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? Try"
                },
                {
                    "type": "p",
                    "text": "Getting around these checks is actually really simple.\nThe easiest method is to just use a type assertion:"
                },
                {
                    "type": "code",
                    "code": "ts let mySquare = createSquare ({ width : 100 , opacity : 0.5 } as SquareConfig ); Try"
                },
                {
                    "type": "p",
                    "text": "However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way.\nIf SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so:"
                },
                {
                    "type": "code",
                    "code": "ts interface SquareConfig { color ?: string ; width ?: number ; [ propName : string ]: any ; } Try"
                },
                {
                    "type": "p",
                    "text": "We’ll discuss index signatures in a bit, but here we’re saying a SquareConfig can have any number of properties, and as long as they aren’t color or width , their types don’t matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable:\nSince squareOptions won’t undergo excess property checks, the compiler won’t give you an error."
                },
                {
                    "type": "code",
                    "code": "ts let squareOptions = { colour : \"red\" , width : 100 }; let mySquare = createSquare ( squareOptions ); Try"
                },
                {
                    "type": "p",
                    "text": "The above workaround will work as long as you have a common property between squareOptions and SquareConfig .\nIn this example, it was the property width . It will however, fail if the variable does not have any common object property. For example:"
                },
                {
                    "type": "code",
                    "code": "ts let squareOptions = { colour : \"red\" }; let mySquare = createSquare ( squareOptions ); Type '{ colour: string; }' has no properties in common with type 'SquareConfig'. 2559 Type '{ colour: string; }' has no properties in common with type 'SquareConfig'. Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks.\nFor more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations.\nIn this instance, if it’s okay to pass an object with both a color or colour property to createSquare , you should fix up the definition of SquareConfig to reflect that. Interfaces are capable of describing the wide range of shapes that JavaScript objects can take.\nIn addition to describing an object with properties, interfaces are also capable of describing function types. To describe a function type with an interface, we give the interface a call signature.\nThis is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type."
                },
                {
                    "type": "code",
                    "code": "ts interface SearchFunc { ( source : string , subString : string ): boolean ; } Try"
                },
                {
                    "type": "p",
                    "text": "Once defined, we can use this function type interface like we would other interfaces.\nHere, we show how you can create a variable of a function type and assign it a function value of the same type."
                },
                {
                    "type": "code",
                    "code": "ts let mySearch : SearchFunc ; mySearch = function ( source : string , subString : string ): boolean { let result = source . search ( subString ); return result > - 1 ; }; Try"
                },
                {
                    "type": "p",
                    "text": "For function types to correctly type check, the names of the parameters do not need to match.\nWe could have, for example, written the above example like this:"
                },
                {
                    "type": "code",
                    "code": "ts let mySearch : SearchFunc ; mySearch = function ( src : string , sub : string ): boolean { let result = src . search ( sub ); return result > - 1 ; }; Try"
                },
                {
                    "type": "p",
                    "text": "Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other.\nIf you do not want to specify types at all, TypeScript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of type SearchFunc .\nHere, also, the return type of our function expression is implied by the values it returns (here false and true )."
                },
                {
                    "type": "code",
                    "code": "ts let mySearch : SearchFunc ; mySearch = function ( src , sub ) { let result = src . search ( sub ); return result > - 1 ; }; Try"
                },
                {
                    "type": "p",
                    "text": "Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn’t match the return type described in the SearchFunc interface."
                },
                {
                    "type": "code",
                    "code": "ts let mySearch : SearchFunc ; mySearch = function ( src , sub ) { Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'. 2322 Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'. let result = src . search ( sub ); return \"string\" ; }; Try"
                },
                {
                    "type": "p",
                    "text": "Similarly to how we can use interfaces to describe function types, we can also describe types that we can “index into” like a[10] , or ageMap[\"daniel\"] .\nIndexable types have an index signature that describes the types we can use to index into the object, along with the corresponding return types when indexing."
                },
                {
                    "type": "code",
                    "code": "ts interface StringArray { [ index : number ]: string ; } let myArray : StringArray ; myArray = [ \"Bob\" , \"Fred\" ]; let myStr : string = myArray [ 0 ]; Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have a StringArray interface that has an index signature.\nThis index signature states that when a StringArray is indexed with a number , it will return a string . There are four types of supported index signatures: string, number, symbol and template strings.\nIt is possible to support many types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a number , JavaScript will actually convert that to a string before indexing into an object.\nThat means that indexing with 100 (a number ) is the same thing as indexing with \"100\" (a string ), so the two need to be consistent."
                },
                {
                    "type": "code",
                    "code": "ts interface Animal { name : string ; } interface Dog extends Animal { breed : string ; } // Error: indexing with a numeric string might get you a completely separate type of Animal! interface NotOkay { [ x : number ]: Animal ; 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. 2413 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [ x : string ]: Dog ; } Try"
                },
                {
                    "type": "p",
                    "text": "While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type.\nThis is because a string index declares that obj.property is also available as obj[\"property\"] .\nIn the following example, name ’s type does not match the string index’s type, and the type checker gives an error:"
                },
                {
                    "type": "code",
                    "code": "ts interface NumberDictionary { [ index : string ]: number ; length : number ; // ok, length is a number name : string ; // error, the type of 'name' is not a subtype of the indexer Property 'name' of type 'string' is not assignable to 'string' index type 'number'. 2411 Property 'name' of type 'string' is not assignable to 'string' index type 'number'. } Try"
                },
                {
                    "type": "p",
                    "text": "However, properties of different types are acceptable if the index signature is a union of the property types:"
                },
                {
                    "type": "code",
                    "code": "ts interface NumberOrStringDictionary { [ index : string ]: number | string ; length : number ; // ok, length is a number name : string ; // ok, name is a string } Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can make index signatures readonly in order to prevent assignment to their indices:"
                },
                {
                    "type": "code",
                    "code": "ts interface ReadonlyStringArray { readonly [ index : number ]: string ; } let myArray : ReadonlyStringArray = [ \"Alice\" , \"Bob\" ]; myArray [ 2 ] = \"Mallory\" ; // error! Index signature in type 'ReadonlyStringArray' only permits reading. 2542 Index signature in type 'ReadonlyStringArray' only permits reading. Try"
                },
                {
                    "type": "p",
                    "text": "You can’t set myArray[2] because the index signature is readonly . A template string can be used to indicate that a particular pattern is allowed, but not all. For example, a HTTP headers object may have a set list of known headers and support any custom defined properties which are prefixed with x- ."
                },
                {
                    "type": "code",
                    "code": "ts interface HeadersResponse { \"content-type\" : string , date : string , \"content-length\" : string // Permit any property starting with 'x-'. [ headerName : `x- ${ string } ` ]: string ; } function handleResponse ( r : HeadersResponse ) { // Handle known, and x- prefixed const type = r [ \"content-type\" ] const poweredBy = r [ \"x-powered-by\" ] // Unknown keys without the prefix raise errors const origin = r . origin Property 'origin' does not exist on type 'HeadersResponse'. 2339 Property 'origin' does not exist on type 'HeadersResponse'. } Try"
                },
                {
                    "type": "p",
                    "text": "One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript."
                },
                {
                    "type": "code",
                    "code": "ts interface ClockInterface { currentTime : Date ; } class Clock implements ClockInterface { currentTime : Date = new Date (); constructor ( h : number , m : number ) {} } Try"
                },
                {
                    "type": "p",
                    "text": "You can also describe methods in an interface that are implemented in the class, as we do with setTime in the below example:"
                },
                {
                    "type": "code",
                    "code": "ts interface ClockInterface { currentTime : Date ; setTime ( d : Date ): void ; } class Clock implements ClockInterface { currentTime : Date = new Date (); setTime ( d : Date ) { this . currentTime = d ; } constructor ( h : number , m : number ) {} } Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces describe the public side of the class, rather than both the public and private side.\nThis prohibits you from using them to check that a class also has particular types for the private side of the class instance. When working with classes and interfaces, it helps to keep in mind that a class has two types: the type of the static side and the type of the instance side.\nYou may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:"
                },
                {
                    "type": "code",
                    "code": "ts interface ClockConstructor { new ( hour : number , minute : number ); } class Clock implements ClockConstructor { Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. 2420 Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. currentTime : Date ; constructor ( h : number , m : number ) {} } Try"
                },
                {
                    "type": "p",
                    "text": "This is because when a class implements an interface, only the instance side of the class is checked.\nSince the constructor sits in the static side, it is not included in this check. Instead, you would need to work with the static side of the class directly.\nIn this example, we define two interfaces, ClockConstructor for the constructor and ClockInterface for the instance methods.\nThen, for convenience, we define a constructor function createClock that creates instances of the type that is passed to it:"
                },
                {
                    "type": "code",
                    "code": "ts interface ClockConstructor { new ( hour : number , minute : number ): ClockInterface ; } interface ClockInterface { tick (): void ; } function createClock ( ctor : ClockConstructor , hour : number , minute : number ): ClockInterface { return new ctor ( hour , minute ); } class DigitalClock implements ClockInterface { constructor ( h : number , m : number ) {} tick () { console . log ( \"beep beep\" ); } } class AnalogClock implements ClockInterface { constructor ( h : number , m : number ) {} tick () { console . log ( \"tick tock\" ); } } let digital = createClock ( DigitalClock , 12 , 17 ); let analog = createClock ( AnalogClock , 7 , 32 ); Try"
                },
                {
                    "type": "p",
                    "text": "Because createClock ’s first parameter is of type ClockConstructor , in createClock(AnalogClock, 7, 32) , it checks that AnalogClock has the correct constructor signature. Another simple way is to use class expressions:"
                },
                {
                    "type": "code",
                    "code": "ts interface ClockConstructor { new ( hour : number , minute : number ): ClockInterface ; } interface ClockInterface { tick (): void ; } const Clock : ClockConstructor = class Clock implements ClockInterface { constructor ( h : number , m : number ) {} tick () { console . log ( \"beep beep\" ); } }; let clock = new Clock ( 12 , 17 ); clock . tick (); Try"
                },
                {
                    "type": "p",
                    "text": "Like classes, interfaces can extend each other.\nThis allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components."
                },
                {
                    "type": "code",
                    "code": "ts interface Shape { color : string ; } interface Square extends Shape { sideLength : number ; } let square = {} as Square ; square . color = \"blue\" ; square . sideLength = 10 ; Try"
                },
                {
                    "type": "p",
                    "text": "An interface can extend multiple interfaces, creating a combination of all of the interfaces."
                },
                {
                    "type": "code",
                    "code": "ts interface Shape { color : string ; } interface PenStroke { penWidth : number ; } interface Square extends Shape , PenStroke { sideLength : number ; } let square = {} as Square ; square . color = \"blue\" ; square . sideLength = 10 ; square . penWidth = 5.0 ; Try"
                },
                {
                    "type": "p",
                    "text": "As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript.\nBecause of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above. One such example is an object that acts as both a function and an object, with additional properties:"
                },
                {
                    "type": "code",
                    "code": "ts interface Counter { ( start : number ): string ; interval : number ; reset (): void ; } function getCounter (): Counter { let counter = function ( start : number ) {} as Counter ; counter . interval = 123 ; counter . reset = function () {}; return counter ; } let c = getCounter (); c ( 10 ); c . reset (); c . interval = 5.0 ; Try"
                },
                {
                    "type": "p",
                    "text": "When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type. When an interface type extends a class type it inherits the members of the class but not their implementations.\nIt is as if the interface had declared all of the members of the class without providing an implementation.\nInterfaces inherit even the private and protected members of a base class.\nThis means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties.\nThe subclasses don’t have to be related besides inheriting from the base class.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts class Control { private state : any ; } interface SelectableControl extends Control { select (): void ; } class Button extends Control implements SelectableControl { select () {} } class TextBox extends Control { select () {} } class ImageControl implements SelectableControl { Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'. 2420 Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'. private state : any ; select () {} } Try"
                },
                {
                    "type": "p",
                    "text": "In the above example, SelectableControl contains all of the members of Control , including the private state property.\nSince state is a private member it is only possible for descendants of Control to implement SelectableControl .\nThis is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible. Within the Control class it is possible to access the state private member through an instance of SelectableControl .\nEffectively, a SelectableControl acts like a Control that is known to have a select method.\nThe Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has its own state private member rather than extending Control , so it cannot implement SelectableControl . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html",
            "title": "TypeScript: Documentation - JS Projects Utilizing TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "The type system in TypeScript has different levels of strictness when working with a codebase:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type-system based only on inference with JavaScript code",
                        "Incremental typing in JavaScript via JSDoc",
                        "Using // @ts-check in a JavaScript file",
                        "TypeScript code",
                        "TypeScript with strict enabled"
                    ]
                },
                {
                    "type": "p",
                    "text": "Each step represents a move towards a safer type-system, but not every project needs that level of verification. This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename.\nThe homepage has a list of editors which have TypeScript plugins. In a .js file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax. JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {number} */ var x ; x = 0 ; // OK x = false ; // OK?! Try"
                },
                {
                    "type": "p",
                    "text": "You can find the full list of supported JSDoc patterns in JSDoc Supported Types . The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project.\nTo enable errors in your JavaScript files add: // @ts-check to the first line in your .js files to have TypeScript raise it as an error."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** @type {number} */ var x ; x = 0 ; // OK x = false ; // Not OK Type 'boolean' is not assignable to type 'number'. 2322 Type 'boolean' is not assignable to type 'number'. Try"
                },
                {
                    "type": "p",
                    "text": "If you have a lot of JavaScript files you want to add errors to then you can switch to using a jsconfig.json .\nYou can skip checking some files by adding a // @ts-nocheck comment to files. TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding // @ts-ignore or // @ts-expect-error on the preceding line."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** @type {number} */ var x ; x = 0 ; // OK // @ts-expect-error x = false ; // Not OK Try"
                },
                {
                    "type": "p",
                    "text": "To learn more about how JavaScript is interpreted by TypeScript read How TS Type Checks JS How to add type checking to JavaScript files using TypeScript The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro.html",
            "title": "TypeScript: Handbook - The TypeScript Handbook",
            "content": [
                {
                    "type": "p",
                    "text": "Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale. The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked). If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the Microsoft Learn JavaScript tutorial or read JavaScript at the Mozilla Web Docs .\nIf you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook. The handbook is split into two sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "The Handbook The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation. You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors. A reader who completes the walkthrough should be able to: Read and understand commonly-used TypeScript syntax and patterns Explain the effects of important compiler options Correctly predict type system behavior in most cases In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.",
                        "Read and understand commonly-used TypeScript syntax and patterns",
                        "Explain the effects of important compiler options",
                        "Correctly predict type system behavior in most cases",
                        "Reference Files The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity."
                    ]
                },
                {
                    "type": "p",
                    "text": "The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short. Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts. The Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet. Finally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web. Before getting started with The Basics , we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages."
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript for the New Programmer",
                        "TypeScript for JavaScript Programmers",
                        "TypeScript for Java/C# Programmers",
                        "TypeScript for Functional Programmers"
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise, jump to The Basics . Step one in learning TypeScript: The basic types. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html",
            "title": "TypeScript: Documentation - Iterators and Generators",
            "content": [
                {
                    "type": "p",
                    "text": "An object is deemed iterable if it has an implementation for the Symbol.iterator property.\nSome built-in types like Array , Map , Set , String , Int32Array , Uint32Array , etc. have their Symbol.iterator property already implemented. Symbol.iterator function on an object is responsible for returning the list of values to iterate on. Iterable is a type we can use if we want to take in types listed above which are iterable. Here is an example:"
                },
                {
                    "type": "code",
                    "code": "ts function toArray < X >( xs : Iterable < X >): X [] { return [... xs ] }"
                },
                {
                    "type": "p",
                    "text": "for..of loops over an iterable object, invoking the Symbol.iterator property on the object.\nHere is a simple for..of loop on an array:"
                },
                {
                    "type": "code",
                    "code": "ts let someArray = [ 1 , \"string\" , false ]; for ( let entry of someArray ) { console . log ( entry ); // 1, \"string\", false }"
                },
                {
                    "type": "p",
                    "text": "Both for..of and for..in statements iterate over lists; the values iterated on are different though, for..in returns a list of keys on the object being iterated, whereas for..of returns a list of values of the numeric properties of the object being iterated. Here is an example that demonstrates this distinction:"
                },
                {
                    "type": "code",
                    "code": "ts let list = [ 4 , 5 , 6 ]; for ( let i in list ) { console . log ( i ); // \"0\", \"1\", \"2\", } for ( let i of list ) { console . log ( i ); // 4, 5, 6 }"
                },
                {
                    "type": "p",
                    "text": "Another distinction is that for..in operates on any object; it serves as a way to inspect properties on this object. for..of on the other hand, is mainly interested in values of iterable objects. Built-in objects like Map and Set implement Symbol.iterator property allowing access to stored values."
                },
                {
                    "type": "code",
                    "code": "ts let pets = new Set ([ \"Cat\" , \"Dog\" , \"Hamster\" ]); pets [ \"species\" ] = \"mammals\" ; for ( let pet in pets ) { console . log ( pet ); // \"species\" } for ( let pet of pets ) { console . log ( pet ); // \"Cat\", \"Dog\", \"Hamster\" }"
                },
                {
                    "type": "p",
                    "text": "When targeting an ES5-compliant engine, iterators are only allowed on values of Array type.\nIt is an error to use for..of loops on non-Array values, even if these non-Array values implement the Symbol.iterator property. The compiler will generate a simple for loop for a for..of loop, for instance:"
                },
                {
                    "type": "code",
                    "code": "ts let numbers = [ 1 , 2 , 3 ]; for ( let num of numbers ) { console . log ( num ); }"
                },
                {
                    "type": "code",
                    "code": "js var numbers = [ 1 , 2 , 3 ]; for ( var _i = 0 ; _i < numbers . length ; _i ++) { var num = numbers [ _i ]; console . log ( num ); }"
                },
                {
                    "type": "p",
                    "text": "When targeting an ECMAScript 2015-compliant engine, the compiler will generate for..of loops to target the built-in iterator implementation in the engine. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
            "title": "TypeScript: Documentation - JSDoc Reference",
            "content": [
                {
                    "type": "p",
                    "text": "The list below outlines which constructs are currently supported\nwhen using JSDoc annotations to provide type information in JavaScript files."
                },
                {
                    "type": "list",
                    "items": [
                        "Any tags which are not explicitly listed below (such as @async ) are not yet supported.",
                        "Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "@type",
                        "@param (or @arg or @argument )",
                        "@returns (or @return )",
                        "@typedef",
                        "@callback",
                        "@template",
                        "@satisfies"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Property Modifiers @public , @private , @protected , @readonly",
                        "@override",
                        "@extends (or @augments )",
                        "@implements",
                        "@class (or @constructor )",
                        "@this"
                    ]
                },
                {
                    "type": "p",
                    "text": "Documentation tags work in both TypeScript and JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "@deprecated",
                        "@see",
                        "@link"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "@enum",
                        "@author",
                        "Other supported patterns",
                        "Unsupported patterns",
                        "Unsupported tags"
                    ]
                },
                {
                    "type": "p",
                    "text": "The meaning is usually the same, or a superset, of the meaning of the tag given at jsdoc.app .\nThe code below describes the differences and gives some example usage of each tag. Note: You can use the playground to explore JSDoc support . You can reference types with the “@type” tag. The type can be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Primitive, like string or number .",
                        "Declared in a TypeScript declaration, either global or imported.",
                        "Declared in a JSDoc @typedef tag."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use most JSDoc type syntax and any TypeScript syntax, from the most basic like string to the most advanced, like conditional types ."
                },
                {
                    "type": "code",
                    "code": "js /** * @type {string} */ var s ; /** @type {Window} */ var win ; /** @type {PromiseLike<string>} */ var promisedString ; // You can specify an HTML Element with DOM properties /** @type {HTMLElement} */ var myElement = document . querySelector ( selector ); element . dataset . myData = \"\" ; Try"
                },
                {
                    "type": "p",
                    "text": "@type can specify a union type — for example, something can be either a string or a boolean."
                },
                {
                    "type": "code",
                    "code": "js /** * @type {string | boolean} */ var sb ; Try"
                },
                {
                    "type": "p",
                    "text": "You can specify array types using a variety of syntaxes:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {number[]} */ var ns ; /** @type {Array.<number>} */ var jsdoc ; /** @type {Array<number>} */ var nas ; Try"
                },
                {
                    "type": "p",
                    "text": "You can also specify object literal types.\nFor example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {{ a: string, b: number }} */ var var9 ; Try"
                },
                {
                    "type": "p",
                    "text": "You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax."
                },
                {
                    "type": "code",
                    "code": "js /** * A map-like object that maps arbitrary `string` properties to `number`s. * * @type {Object.<string, number>} */ var stringToNumber ; /** @type {Object.<number, object>} */ var arrayLike ; Try"
                },
                {
                    "type": "p",
                    "text": "The preceding two types are equivalent to the TypeScript types { [x: string]: number } and { [x: number]: any } . The compiler understands both syntaxes. You can specify function types using either TypeScript or Google Closure syntax:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {function(string, boolean): number} Closure syntax */ var sbn ; /** @type {(s: string, b: boolean) => number} TypeScript syntax */ var sbn2 ; Try"
                },
                {
                    "type": "p",
                    "text": "Or you can just use the unspecified Function type:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {Function} */ var fn7 ; /** @type {function} */ var fn6 ; Try"
                },
                {
                    "type": "p",
                    "text": "Other types from Closure also work:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {*} - can be 'any' type */ var star ; /** * @type {?} - unknown type (same as 'any') */ var question ; Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript borrows cast syntax from Google Closure.\nThis lets you cast types to other types by adding a @type tag before any parenthesized expression."
                },
                {
                    "type": "code",
                    "code": "js /** * @type {number | string} */ var numberOrString = Math . random () < 0.5 ? \"hello\" : 100 ; var typeAssertedNumber = /** @type {number} */ ( numberOrString ); Try"
                },
                {
                    "type": "p",
                    "text": "You can even cast to const just like TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js let one = /** @type {const} */ ( 1 ); Try"
                },
                {
                    "type": "p",
                    "text": "You can import declarations from other files using import types.\nThis syntax is TypeScript-specific and differs from the JSDoc standard:"
                },
                {
                    "type": "code",
                    "code": "js // @filename: types.d.ts export type Pet = { name : string , }; // @filename: main.js /** * @param {import(\"./types\").Pet} p */ function walk ( p ) { console . log ( `Walking ${ p . name } ...` ); } Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used in type alias declarations:"
                },
                {
                    "type": "code",
                    "code": "js /** * @typedef {import(\"./types\").Pet} Pet */ /** * @type {Pet} */ var myPet ; myPet . name ; Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {typeof import(\"./accounts\").userAccount} */ var x = require ( \"./accounts\" ). userAccount ; Try"
                },
                {
                    "type": "p",
                    "text": "@param uses the same type syntax as @type , but adds a parameter name.\nThe parameter may also be declared optional by surrounding the name with square brackets:"
                },
                {
                    "type": "code",
                    "code": "js // Parameters may be declared in a variety of syntactic forms /** * @param {string} p1 - A string param. * @param {string=} p2 - An optional param (Google Closure syntax) * @param {string} [p3] - Another optional param (JSDoc syntax). * @param {string} [p4 = \"test\"] - An optional param with a default value * @returns {string} This is the result */ function stringsStringStrings ( p1 , p2 , p3 , p4 ) { // TODO } Try"
                },
                {
                    "type": "p",
                    "text": "Likewise, for the return type of a function:"
                },
                {
                    "type": "code",
                    "code": "js /** * @return {PromiseLike<string>} */ function ps () {} /** * @returns {{ a: string, b: number }} - May use ' @returns ' as well as ' @return ' */ function ab () {} Try"
                },
                {
                    "type": "p",
                    "text": "You can define complex types with @typedef .\nSimilar syntax works with @param ."
                },
                {
                    "type": "code",
                    "code": "js /** * @typedef {Object} SpecialType - creates a new type named 'SpecialType' * @property {string} prop1 - a string property of SpecialType * @property {number} prop2 - a number property of SpecialType * @property {number=} prop3 - an optional number property of SpecialType * @prop {number} [prop4] - an optional number property of SpecialType * @prop {number} [prop5 = 42] - an optional number property of SpecialType with default */ /** @type {SpecialType} */ var specialTypeObject ; specialTypeObject . prop3 ; Try"
                },
                {
                    "type": "p",
                    "text": "You can use either object or Object on the first line."
                },
                {
                    "type": "code",
                    "code": "js /** * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1' * @property {string} prop1 - a string property of SpecialType1 * @property {number} prop2 - a number property of SpecialType1 * @property {number=} prop3 - an optional number property of SpecialType1 */ /** @type {SpecialType1} */ var specialTypeObject1 ; Try"
                },
                {
                    "type": "p",
                    "text": "@param allows a similar syntax for one-off type specifications.\nNote that the nested property names must be prefixed with the name of the parameter:"
                },
                {
                    "type": "code",
                    "code": "js /** * @param {Object} options - The shape is the same as SpecialType above * @param {string} options.prop1 * @param {number} options.prop2 * @param {number=} options.prop3 * @param {number} [options.prop4] * @param {number} [options.prop5 = 42] */ function special ( options ) { return ( options . prop4 || 1001 ) + options . prop5 ; } Try"
                },
                {
                    "type": "p",
                    "text": "@callback is similar to @typedef , but it specifies a function type instead of an object type:"
                },
                {
                    "type": "code",
                    "code": "js /** * @callback Predicate * @param {string} data * @param {number} [index] * @returns {boolean} */ /** @type {Predicate} */ const ok = ( s ) => !( s . length % 2 ); Try"
                },
                {
                    "type": "p",
                    "text": "Of course, any of these types can be declared using TypeScript syntax in a single-line @typedef :"
                },
                {
                    "type": "code",
                    "code": "js /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */ /** @typedef {(data: string, index?: number) => boolean} Predicate */"
                },
                {
                    "type": "p",
                    "text": "You can declare type parameters with the @template tag.\nThis lets you make functions, classes, or types that are generic:"
                },
                {
                    "type": "code",
                    "code": "js /** * @template T * @param {T} x - A generic parameter that flows through to the return type * @returns {T} */ function id ( x ) { return x ; } const a = id ( \"string\" ); const b = id ( 123 ); const c = id ({}); Try"
                },
                {
                    "type": "p",
                    "text": "Use comma or multiple tags to declare multiple type parameters:"
                },
                {
                    "type": "code",
                    "code": "js /** * @template T,U,V * @template W,X */"
                },
                {
                    "type": "p",
                    "text": "You can also specify a type constraint before the type parameter name.\nOnly the first type parameter in a list is constrained:"
                },
                {
                    "type": "code",
                    "code": "js /** * @template {string} K - K must be a string or string literal * @template {{ serious(): string }} Seriousalizable - must have a serious method * @param {K} key * @param {Seriousalizable} object */ function seriousalize ( key , object ) { // ???? } Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can specify a default for a type parameter:"
                },
                {
                    "type": "code",
                    "code": "js /** @template [T=object] */ class Cache { /** @param {T} initial */ constructor ( initial ) { } } let c = new Cache () Try"
                },
                {
                    "type": "p",
                    "text": "@satisfies provides access to the postfix operator satisfies in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** * @typedef {\"hello world\" | \"Hello, world\"} WelcomeMessage */ /** @satisfies {WelcomeMessage} */ const message = \"hello world\" const message: \"hello world\" /** @ satisfies {WelcomeMessage} */ Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'. 1360 Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'. const failingMessage = \"Hello world!\" /** @type {WelcomeMessage} */ const messageUsingType = \"hello world\" const messageUsingType: WelcomeMessage Try"
                },
                {
                    "type": "p",
                    "text": "Classes can be declared as ES6 classes."
                },
                {
                    "type": "code",
                    "code": "js class C { /** * @param {number} data */ constructor ( data ) { // property types can be inferred this . name = \"foo\" ; // or set explicitly /** @type {string | null} */ this . title = null ; // or simply annotated, if they're set elsewhere /** @type {number} */ this . size ; this . initialize ( data ); // Should error, initializer expects a string } /** * @param {string} s */ initialize = function ( s ) { this . size = s . length ; }; } var c = new C ( 0 ); // C should only be called with new, but // because it is JavaScript, this is allowed and // considered an 'any'. var result = C ( 1 ); Try"
                },
                {
                    "type": "p",
                    "text": "They can also be declared as constructor functions; use @constructor along with @this for this. @public , @private , and @protected work exactly like public , private , and protected in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js // @ts-check class Car { constructor () { /** @private */ this . identifier = 100 ; } printIdentifier () { console . log ( this . identifier ); } } const c = new Car (); console . log ( c . identifier ); Property 'identifier' is private and only accessible within class 'Car'. 2341 Property 'identifier' is private and only accessible within class 'Car'. Try"
                },
                {
                    "type": "list",
                    "items": [
                        "@public is always implied and can be left off, but means that a property can be reached from anywhere.",
                        "@private means that a property can only be used within the containing class.",
                        "@protected means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class."
                    ]
                },
                {
                    "type": "p",
                    "text": "@public , @private , and @protected do not work in constructor functions. The @readonly modifier ensures that a property is only ever written to during initialization."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check class Car { constructor () { /** @readonly */ this . identifier = 100 ; } printIdentifier () { console . log ( this . identifier ); } } const c = new Car (); console . log ( c . identifier ); Try"
                },
                {
                    "type": "p",
                    "text": "@override works the same way as in TypeScript; use it on methods that override a method from a base class:"
                },
                {
                    "type": "code",
                    "code": "js export class C { m () { } } class D extends C { /** @override */ m () { } } Try"
                },
                {
                    "type": "p",
                    "text": "Set noImplicitOverride: true in tsconfig to check overrides. When JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The @extends tag allows this:"
                },
                {
                    "type": "code",
                    "code": "js /** * @template T * @extends {Set<T>} */ class SortableSet extends Set { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Note that @extends only works with classes. Currently, there is no way for a constructor function to extend a class. In the same way, there is no JavaScript syntax for implementing a TypeScript interface. The @implements tag works just like in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js /** @implements {Print} */ class TextBook { print () { // TODO } } Try"
                },
                {
                    "type": "p",
                    "text": "The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a @constructor tag:"
                },
                {
                    "type": "code",
                    "code": "js /** * @constructor * @param {number} data */ function C ( data ) { // property types can be inferred this . name = \"foo\" ; // or set explicitly /** @type {string | null} */ this . title = null ; // or simply annotated, if they're set elsewhere /** @type {number} */ this . size ; this . initialize ( data ); Argument of type 'number' is not assignable to parameter of type 'string'. 2345 Argument of type 'number' is not assignable to parameter of type 'string'. } /** * @param {string} s */ C . prototype . initialize = function ( s ) { this . size = s . length ; }; var c = new C ( 0 ); c . size ; var result = C ( 1 ); Value of type 'typeof C' is not callable. Did you mean to include 'new'? 2348 Value of type 'typeof C' is not callable. Did you mean to include 'new'? Try"
                },
                {
                    "type": "p",
                    "text": "Note: Error messages only show up in JS codebases with a JSConfig and checkJs enabled. With @constructor , this is checked inside the constructor function C , so you will get suggestions for the initialize method and an error if you pass it a number. Your editor may also show warnings if you call C instead of constructing it. Unfortunately, this means that constructor functions that are also callable cannot use @constructor . The compiler can usually figure out the type of this when it has some context to work with. When it doesn’t, you can explicitly specify the type of this with @this :"
                },
                {
                    "type": "code",
                    "code": "js /** * @this {HTMLElement} * @param {*} e */ function callbackForLater ( e ) { this . clientHeight = parseInt ( e ); // should be fine! } Try"
                },
                {
                    "type": "p",
                    "text": "When a function, method, or property is deprecated you can let users know by marking it with a /** @deprecated */ JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style like this ."
                },
                {
                    "type": "code",
                    "code": "js /** @deprecated */ const apiV1 = {}; const apiV2 = {}; apiV ; api V1 api V2 Try"
                },
                {
                    "type": "p",
                    "text": "@see lets you link to other names in your program:"
                },
                {
                    "type": "code",
                    "code": "ts type Box < T > = { t : T } /** @see Box for implementation details */ type Boxify < T > = { [ K in keyof T ]: Box < T > }; Try"
                },
                {
                    "type": "p",
                    "text": "Some editors will turn Box into a link to make it easy to jump there and back. @link is like @see , except that it can be used inside other tags:"
                },
                {
                    "type": "code",
                    "code": "ts type Box < T > = { t : T } /** @returns A { @link Box } containing the parameter. */ function box < U >( u : U ): Box < U > { return { t : u }; } Try"
                },
                {
                    "type": "p",
                    "text": "You can also link a property:"
                },
                {
                    "type": "code",
                    "code": "ts type Pet = { name : string hello : () => string } /** * Note: you should implement the { @link Pet.hello } method of Pet. */ function hello ( p : Pet ) { p . hello () } Try"
                },
                {
                    "type": "code",
                    "code": "ts type Pet = { name : string hello : () => string } /** * Note: you should implement the { @link Pet.hello | hello} method of Pet. */ function hello ( p : Pet ) { p . hello () } Try"
                },
                {
                    "type": "p",
                    "text": "The @enum tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. @enum is intended for compatibility with Google Closure’s @enum tag."
                },
                {
                    "type": "code",
                    "code": "js /** @enum {number} */ const JSDocState = { BeginningOfLine : 0 , SawAsterisk : 1 , SavingComments : 2 , }; JSDocState . SawAsterisk ; Try"
                },
                {
                    "type": "p",
                    "text": "Note that @enum is quite different from, and much simpler than, TypeScript’s enum . However, unlike TypeScript’s enums, @enum can have any type:"
                },
                {
                    "type": "code",
                    "code": "js /** @enum {function(number): number} */ const MathFuncs = { add1 : ( n ) => n + 1 , id : ( n ) => - n , sub1 : ( n ) => n - 1 , }; MathFuncs . add1 ; Try"
                },
                {
                    "type": "p",
                    "text": "You can specify the author of an item with @author :"
                },
                {
                    "type": "code",
                    "code": "ts /** * Welcome to awesome.ts * @author Ian Awesome <i.am.awesome@example.com> */ Try"
                },
                {
                    "type": "p",
                    "text": "Remember to surround the email address with angle brackets.\nOtherwise, @example will be parsed as a new tag."
                },
                {
                    "type": "code",
                    "code": "js var someObj = { /** * @param {string} param1 - JSDocs on property assignments work */ x : function ( param1 ) {}, }; /** * As do jsdocs on variable assignments * @return {Window} */ let someFunc = function () {}; /** * And class methods * @param {string} greeting The greeting to use */ Foo . prototype . sayHi = ( greeting ) => console . log ( \"Hi!\" ); /** * And arrow function expressions * @param {number} x - A multiplier */ let myArrow = ( x ) => x * x ; /** * Which means it works for function components in JSX too * @param {{a: string, b: number}} props - Some param */ var fc = ( props ) => < div > { props . a . charAt ( 0 ) } </ div > ; /** * A parameter can be a class constructor, using Google Closure syntax. * * @param {{new(...args: any[]): object}} C - The class to register */ function registerClass ( C ) {} /** * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any') */ function fn10 ( p1 ) {} /** * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any') */ function fn9 ( p1 ) { return p1 . join (); } Try"
                },
                {
                    "type": "p",
                    "text": "Postfix equals on a property type in an object literal type doesn’t specify an optional property:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {{ a: string, b: number= }} */ var wrong ; /** * Use postfix question on the property name instead: * @type {{ a: string, b?: number }} */ var right ; Try"
                },
                {
                    "type": "p",
                    "text": "Nullable types only have meaning if strictNullChecks is on:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {?number} * With strictNullChecks: true  -- number | null * With strictNullChecks: false -- number */ var nullable ; Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript-native syntax is a union type:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {number | null} * With strictNullChecks: true  -- number | null * With strictNullChecks: false -- number */ var unionNullable ; Try"
                },
                {
                    "type": "p",
                    "text": "Non-nullable types have no meaning and are treated just as their original type:"
                },
                {
                    "type": "code",
                    "code": "js /** * @type {!number} * Just has type number */ var normal ; Try"
                },
                {
                    "type": "p",
                    "text": "Unlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not.\nThere is no explicit non-nullability — if strictNullChecks is on, then number is not nullable.\nIf it is off, then number is nullable. TypeScript ignores any unsupported JSDoc tags. The following tags have open issues to support them:"
                },
                {
                    "type": "list",
                    "items": [
                        "@memberof ( issue #7237 )",
                        "@yields ( issue #23857 )",
                        "@member ( issue #56674 )"
                    ]
                },
                {
                    "type": "p",
                    "text": "A number of common types are given aliases for compatibility with old JavaScript code.\nSome of the aliases are the same as existing types, although most of those are rarely used.\nFor example, String is treated as an alias for string .\nEven though String is a type in TypeScript, old JSDoc often uses it to mean string .\nBesides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use.\nSo the compiler treats these types as synonyms based on usage in old JSDoc:"
                },
                {
                    "type": "list",
                    "items": [
                        "String -> string",
                        "Number -> number",
                        "Boolean -> boolean",
                        "Void -> void",
                        "Undefined -> undefined",
                        "Null -> null",
                        "function -> Function",
                        "array -> Array<any>",
                        "promise -> Promise<any>",
                        "Object -> any",
                        "object -> any"
                    ]
                },
                {
                    "type": "p",
                    "text": "The last four aliases are turned off when noImplicitAny: true :"
                },
                {
                    "type": "list",
                    "items": [
                        "object and Object are built-in types, although Object is rarely used.",
                        "array and promise are not built-in, but might be declared somewhere in your program."
                    ]
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript How to add d.ts generation to JavaScript projects The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsx.html",
            "title": "TypeScript: Documentation - JSX",
            "content": [
                {
                    "type": "p",
                    "text": "JSX is an embeddable XML-like syntax.\nIt is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific.\nJSX rose to popularity with the React framework, but has since seen other implementations as well.\nTypeScript supports embedding, type checking, and compiling JSX directly to JavaScript. In order to use JSX you must do two things."
                },
                {
                    "type": "list",
                    "items": [
                        "Name your files with a .tsx extension",
                        "Enable the jsx option"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript ships with several JSX modes: preserve , react (classic runtime), react-jsx (automatic runtime), react-jsxdev (automatic development runtime), and react-native .\nThe preserve mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. Babel ).\nAdditionally the output will have a .jsx file extension.\nThe react mode will emit React.createElement , does not need to go through a JSX transformation before use, and the output will have a .js file extension.\nThe react-native mode is the equivalent of preserve in that it keeps all JSX, but the output will instead have a .js file extension. You can specify this mode using either the jsx command line flag or the corresponding option jsx in your tsconfig.json file. *Note: You can specify the JSX factory function to use when targeting react JSX emit with jsxFactory option (defaults to React.createElement ) Recall how to write a type assertion:"
                },
                {
                    "type": "code",
                    "code": "ts const foo = < Foo > bar ;"
                },
                {
                    "type": "p",
                    "text": "This asserts the variable bar to have the type Foo .\nSince TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in .tsx files. Since the above syntax cannot be used in .tsx files, an alternate type assertion operator should be used: as .\nThe example can easily be rewritten with the as operator."
                },
                {
                    "type": "code",
                    "code": "ts const foo = bar as Foo ;"
                },
                {
                    "type": "p",
                    "text": "The as operator is available in both .ts and .tsx files, and is identical in behavior to the angle-bracket type assertion style. In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements.\nGiven a JSX expression <expr /> , expr may either refer to something intrinsic to the environment (e.g. a div or span in a DOM environment) or to a custom component that you’ve created.\nThis is important for two reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "For React, intrinsic elements are emitted as strings ( React.createElement(\"div\") ), whereas a component you’ve created is not ( React.createElement(MyComponent) ).",
                        "The types of the attributes being passed in the JSX element should be looked up differently.\nIntrinsic element attributes should be known intrinsically whereas components will likely want to specify their own set of attributes."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript uses the same convention that React does for distinguishing between these.\nAn intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter. JSX in TypeScript is typed by the JSX namespace. The JSX namespace may be defined in various places, depending on the jsx compiler option. The jsx options preserve , react , and react-native use the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by the jsxFactory compiler option. The JSX namespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factory React.createElement . This means its JSX namespace should be defined as React.JSX ."
                },
                {
                    "type": "code",
                    "code": "ts export function createElement (): any ; export namespace JSX { // … }"
                },
                {
                    "type": "p",
                    "text": "And the user should always import React as React ."
                },
                {
                    "type": "code",
                    "code": "ts import * as React from 'react' ;"
                },
                {
                    "type": "p",
                    "text": "Preact uses the JSX factory h . That means its types should be defined as the h.JSX ."
                },
                {
                    "type": "code",
                    "code": "ts export function h ( props : any ): any ; export namespace h . JSX { // … }"
                },
                {
                    "type": "p",
                    "text": "The user should use a named import to import h ."
                },
                {
                    "type": "code",
                    "code": "ts import { h } from 'preact' ;"
                },
                {
                    "type": "p",
                    "text": "For the jsx options react-jsx and react-jsxdev , the JSX namespace should be exported from the matching entry points. For react-jsx this is ${jsxImportSource}/jsx-runtime . For react-jsxdev , this is ${jsxImportSource}/jsx-dev-runtime . Since these don’t use a file extension, you must use the exports field in package.json map in order to support ESM users."
                },
                {
                    "type": "code",
                    "code": "json { \"exports\" : { \"./jsx-runtime\" : \"./jsx-runtime.js\" , \"./jsx-dev-runtime\" : \"./jsx-dev-runtime.js\" , } }"
                },
                {
                    "type": "p",
                    "text": "Then in jsx-runtime.d.ts and jsx-dev-runtime.d.ts :"
                },
                {
                    "type": "code",
                    "code": "ts export namespace JSX { // … }"
                },
                {
                    "type": "p",
                    "text": "Note that while exporting the JSX namespace is sufficient for type checking, the production runtime needs the jsx , jsxs , and Fragment exports at runtime, and the development runtime needs jsxDEV and Fragment . Ideally you add types for those too. If the JSX namespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the global JSX namespace. Intrinsic elements are looked up on the special interface JSX.IntrinsicElements .\nBy default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked.\nHowever, if this interface is present, then the name of the intrinsic element is looked up as a property on the JSX.IntrinsicElements interface.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsx declare namespace JSX { interface IntrinsicElements { foo : any ; } } <foo /> ; // ok <bar /> ; // error"
                },
                {
                    "type": "p",
                    "text": "In the above example, <foo /> will work fine but <bar /> will result in an error since it has not been specified on JSX.IntrinsicElements . Note: You can also specify a catch-all string indexer on JSX.IntrinsicElements as follows:"
                },
                {
                    "type": "code",
                    "code": "ts declare namespace JSX { interface IntrinsicElements { [ elemName : string ]: any ; } }"
                },
                {
                    "type": "p",
                    "text": "Value-based elements are simply looked up by identifiers that are in scope."
                },
                {
                    "type": "code",
                    "code": "tsx import MyComponent from \"./myComponent\" ; < MyComponent /> ; // ok < SomeOtherComponent /> ; // error"
                },
                {
                    "type": "p",
                    "text": "There are two ways to define a value-based element:"
                },
                {
                    "type": "list",
                    "items": [
                        "Function Component (FC)",
                        "Class Component"
                    ]
                },
                {
                    "type": "p",
                    "text": "Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error. As the name suggests, the component is defined as a JavaScript function where its first argument is a props object.\nTS enforces that its return type must be assignable to JSX.Element ."
                },
                {
                    "type": "code",
                    "code": "tsx interface FooProp { name : string ; X : number ; Y : number ; } declare function AnotherComponent ( prop : { name : string }); function ComponentFoo ( prop : FooProp ) { return < AnotherComponent name = { prop . name } /> ; } const Button = ( prop : { value : string }, context : { color : string }) => ( <button /> );"
                },
                {
                    "type": "p",
                    "text": "Because a Function Component is simply a JavaScript function, function overloads may be used here as well:"
                },
                {
                    "type": "code",
                    "code": "ts interface ClickableProps { children : JSX . Element [] | JSX . Element ; } interface HomeProps extends ClickableProps { home : JSX . Element ; } interface SideProps extends ClickableProps { side : JSX . Element | string ; } function MainButton ( prop : HomeProps ): JSX . Element ; function MainButton ( prop : SideProps ): JSX . Element ; function MainButton ( prop : ClickableProps ): JSX . Element { // ... } Try"
                },
                {
                    "type": "p",
                    "text": "Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type SFC and its alias StatelessComponent were deprecated. It is possible to define the type of a class component.\nHowever, to do so it is best to understand two new terms: the element class type and the element instance type . Given <Expr /> , the element class type is the type of Expr .\nSo in the example above, if MyComponent was an ES6 class the class type would be that class’s constructor and statics.\nIf MyComponent was a factory function, the class type would be that function. Once the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present).\nSo again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function."
                },
                {
                    "type": "code",
                    "code": "ts class MyComponent { render () {} } // use a construct signature const myComponent = new MyComponent (); // element class type => MyComponent // element instance type => { render: () => void } function MyFactoryFunction () { return { render : () => {}, }; } // use a call signature const myComponent = MyFactoryFunction (); // element class type => MyFactoryFunction // element instance type => { render: () => void }"
                },
                {
                    "type": "p",
                    "text": "The element instance type is interesting because it must be assignable to JSX.ElementClass or it will result in an error.\nBy default JSX.ElementClass is {} , but it can be augmented to limit the use of JSX to only those types that conform to the proper interface."
                },
                {
                    "type": "code",
                    "code": "tsx declare namespace JSX { interface ElementClass { render : any ; } } class MyComponent { render () {} } function MyFactoryFunction () { return { render : () => {} }; } < MyComponent /> ; // ok < MyFactoryFunction /> ; // ok class NotAValidComponent {} function NotAValidFactoryFunction () { return {}; } < NotAValidComponent /> ; // error < NotAValidFactoryFunction /> ; // error"
                },
                {
                    "type": "p",
                    "text": "The first step to type checking attributes is to determine the element attributes type .\nThis is slightly different between intrinsic and value-based elements. For intrinsic elements, it is the type of the property on JSX.IntrinsicElements"
                },
                {
                    "type": "code",
                    "code": "tsx declare namespace JSX { interface IntrinsicElements { foo : { bar ?: boolean }; } } // element attributes type for 'foo' is '{bar?: boolean}' <foo bar /> ;"
                },
                {
                    "type": "p",
                    "text": "For value-based elements, it is a bit more complex.\nIt is determined by the type of a property on the element instance type that was previously determined.\nWhich property to use is determined by JSX.ElementAttributesProperty .\nIt should be declared with a single property.\nThe name of that property is then used.\nAs of TypeScript 2.8, if JSX.ElementAttributesProperty is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead."
                },
                {
                    "type": "code",
                    "code": "tsx declare namespace JSX { interface ElementAttributesProperty { props ; // specify the property name to use } } class MyComponent { // specify the property on the element instance type props : { foo ?: string ; }; } // element attributes type for 'MyComponent' is '{foo?: string}' < MyComponent foo = \"bar\" /> ;"
                },
                {
                    "type": "p",
                    "text": "The element attribute type is used to type check the attributes in the JSX.\nOptional and required properties are supported."
                },
                {
                    "type": "code",
                    "code": "tsx declare namespace JSX { interface IntrinsicElements { foo : { requiredProp : string ; optionalProp ?: number }; } } <foo requiredProp = \"bar\" /> ; // ok <foo requiredProp = \"bar\" optionalProp = { 0 } /> ; // ok <foo /> ; // error, requiredProp is missing <foo requiredProp = { 0 } /> ; // error, requiredProp should be a string <foo requiredProp = \"bar\" unknownProp /> ; // error, unknownProp does not exist <foo requiredProp = \"bar\" some-unknown-prop /> ; // ok, because 'some-unknown-prop' is not a valid identifier"
                },
                {
                    "type": "p",
                    "text": "Note: If an attribute name is not a valid JS identifier (like a data-* attribute), it is not considered to be an error if it is not found in the element attributes type. Additionally, the JSX.IntrinsicAttributes interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance key in React. Specializing further, the generic JSX.IntrinsicClassAttributes<T> type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the ref attribute of type Ref<T> . Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag."
                },
                {
                    "type": "code",
                    "code": "tsx const props = { requiredProp: \"bar\" }; <foo { ... props } /> ; // ok const badProps = {}; <foo { ... badProps } /> ; // error"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 2.3, TS introduced type checking of children . children is a special property in an element attributes type where child JSXExpression s are taken to be inserted into the attributes.\nSimilar to how TS uses JSX.ElementAttributesProperty to determine the name of props , TS uses JSX.ElementChildrenAttribute to determine the name of children within those props. JSX.ElementChildrenAttribute should be declared with a single property."
                },
                {
                    "type": "code",
                    "code": "ts declare namespace JSX { interface ElementChildrenAttribute { children : {}; // specify children name to use } }"
                },
                {
                    "type": "code",
                    "code": "tsx <div> <h1> Hello </h1> </div> ; <div> <h1> Hello </h1> World </div> ; const CustomComp = ( props ) => <div> { props . children } </div> < CustomComp > <div> Hello World </div> { \"This is just a JS expression...\" + 1000 } </ CustomComp >"
                },
                {
                    "type": "p",
                    "text": "You can specify the type of children like any other attribute. This will override the default type from, e.g. the React typings if you use them."
                },
                {
                    "type": "code",
                    "code": "tsx interface PropsType { children : JSX . Element name : string } class Component extends React . Component < PropsType , {}> { render () { return ( <h2> {this . props . children } </h2> ) } } // OK < Component name = \"foo\" > <h1> Hello World </h1> </ Component > // Error: children is of type JSX.Element not array of JSX.Element < Component name = \"bar\" > <h1> Hello World </h1> <h2> Hello World </h2> </ Component > // Error: children is of type JSX.Element not array of JSX.Element or string. < Component name = \"baz\" > <h1> Hello </h1> World </ Component >"
                },
                {
                    "type": "p",
                    "text": "By default the result of a JSX expression is typed as any .\nYou can customize the type by specifying the JSX.Element interface.\nHowever, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface.\nIt is a black box. By default, function components must return JSX.Element | null . However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specify JSX.ElementType to override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:"
                },
                {
                    "type": "code",
                    "code": "ts namespace JSX { export type ElementType = // All the valid lowercase tags | keyof IntrinsicElements // Function components | ( props : any ) => Element // Class components | new ( props : any ) => ElementClass ; export interface IntrinsicAttributes extends /*...*/ {} export type Element = /*...*/ ; export type ElementClass = /*...*/ ; }"
                },
                {
                    "type": "p",
                    "text": "JSX allows you to embed expressions between tags by surrounding the expressions with curly braces ( { } )."
                },
                {
                    "type": "code",
                    "code": "tsx const a = ( <div> { [ \"foo\" , \"bar\" ]. map (( i ) => ( <span> { i / 2 } </span> )) } </div> );"
                },
                {
                    "type": "p",
                    "text": "The above code will result in an error since you cannot divide a string by a number.\nThe output, when using the preserve option, looks like:"
                },
                {
                    "type": "code",
                    "code": "tsx const a = ( <div> { [ \"foo\" , \"bar\" ]. map ( function ( i ) { return <span> { i / 2 } </span> ; }) } </div> );"
                },
                {
                    "type": "p",
                    "text": "To use JSX with React you should use the React typings .\nThese typings define the JSX namespace appropriately for use with React."
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference path = \"react.d.ts\" /> interface Props { foo : string ; } class MyComponent extends React . Component < Props , {}> { render () { return <span> {this . props . foo } </span> ; } } < MyComponent foo = \"bar\" /> ; // ok < MyComponent foo = { 0 } /> ; // error"
                },
                {
                    "type": "p",
                    "text": "There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:"
                },
                {
                    "type": "list",
                    "items": [
                        "jsxFactory",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
            "title": "TypeScript: Documentation - Migrating from JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript doesn’t exist in a vacuum.\nIt was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today.\nConverting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging.\nIn this tutorial, we’re going to look at how you might start out.\nWe assume you’ve read enough of the handbook to write new TypeScript code. If you’re looking to convert a React project, we recommend looking at the React Conversion Guide first. If you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly,\nwhere your .js files are in a src , lib , or dist directory, and then run as desired. If that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces.\nDuring our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them.\nIf your output files need to reside in a specific directory, then that will be your output directory. You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel.\nIn this case, you might already have a folder structure like this set up. From this point on, we’re going to assume that your directory is set up something like this:"
                },
                {
                    "type": "code",
                    "code": "projectRoot ├── src │   ├── file1.js │   └── file2.js ├── built └── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "If you have a tests folder outside of your src directory, you might have one tsconfig.json in src , and one in tests as well. TypeScript uses a file called tsconfig.json for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform.\nLet’s create a bare-bones one for our project:"
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"outDir\" : \"./built\" , \"allowJs\" : true , \"target\" : \"es5\" }, \"include\" : [ \"./src/**/*\" ] }"
                },
                {
                    "type": "p",
                    "text": "Here we’re specifying a few things to TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read in any files it understands in the src directory (with include ).",
                        "Accept JavaScript files as inputs (with allowJs ).",
                        "Emit all of the output files in built (with outDir ).",
                        "Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using target )."
                    ]
                },
                {
                    "type": "p",
                    "text": "At this point, if you try running tsc at the root of your project, you should see output files in the built directory.\nThe layout of files in built should look identical to the layout of src .\nYou should now have TypeScript working with your project. Even at this point you can get some great benefits from TypeScript understanding your project.\nIf you open up an editor like VS Code or Visual Studio , you’ll see that you can often get some tooling support like completion.\nYou can also catch certain bugs with options like:"
                },
                {
                    "type": "list",
                    "items": [
                        "noImplicitReturns which prevents you from forgetting to return at the end of a function.",
                        "noFallthroughCasesInSwitch which is helpful if you never want to forget a break statement between case s in a switch block."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript will also warn about unreachable code and labels, which you can disable with allowUnreachableCode and allowUnusedLabels respectively. You might have some more build steps in your pipeline.\nPerhaps you concatenate something to each of your files.\nEach build tool is different, but we’ll do our best to cover the gist of things. If you’re using Gulp in some fashion, we have a tutorial on using Gulp with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify.\nYou can read more there. Webpack integration is pretty simple.\nYou can use ts-loader , a TypeScript loader, combined with source-map-loader for easier debugging.\nSimply run"
                },
                {
                    "type": "code",
                    "code": "shell npm install ts-loader source-map-loader"
                },
                {
                    "type": "p",
                    "text": "and merge in options from the following into your webpack.config.js file:"
                },
                {
                    "type": "code",
                    "code": "js module . exports = { entry: \"./src/index.ts\" , output: { filename: \"./dist/bundle.js\" , }, // Enable sourcemaps for debugging webpack's output. devtool: \"source-map\" , resolve: { // Add '.ts' and '.tsx' as resolvable extensions. extensions: [ \"\" , \".webpack.js\" , \".web.js\" , \".ts\" , \".tsx\" , \".js\" ], }, module: { rules: [ // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'. { test: / \\. tsx ? $ / , loader: \"ts-loader\" }, // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'. { test: / \\. js $ / , loader: \"source-map-loader\" }, ], }, // Other options... };"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that ts-loader will need to run before any other loader that deals with .js files. You can see an example of using Webpack in our tutorial on React and Webpack . At this point, you’re probably ready to start using TypeScript files.\nThe first step is to rename one of your .js files to .ts .\nIf your file uses JSX, you’ll need to rename it to .tsx . Finished with that step?\nGreat!\nYou’ve successfully migrated a file from JavaScript to TypeScript! Of course, that might not feel right.\nIf you open that file in an editor with TypeScript support (or if you run tsc --pretty ), you might see red squiggles on certain lines.\nYou should think of these the same way you’d think of red squiggles in an editor like Microsoft Word.\nTypeScript will still translate your code, just like Word will still let you print your documents. If that sounds too lax for you, you can tighten that behavior up.\nIf, for instance, you don’t want TypeScript to compile to JavaScript in the face of errors, you can use the noEmitOnError option.\nIn that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want. If you plan on using the stricter settings that are available, it’s best to turn them on now (see Getting Stricter Checks below).\nFor instance, if you never want TypeScript to silently infer any for a type without you explicitly saying so, you can use noImplicitAny before you start modifying your files.\nWhile it might feel somewhat overwhelming, the long-term gains become apparent much more quickly. Like we mentioned, it’s not unexpected to get error messages after conversion.\nThe important thing is to actually go one by one through these and decide how to deal with the errors.\nOften these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript. You might start out getting a bunch of errors like Cannot find name 'require'. , and Cannot find name 'define'. .\nIn these cases, it’s likely that you’re using modules.\nWhile you can just convince TypeScript that these exist by writing out"
                },
                {
                    "type": "code",
                    "code": "ts // For Node/CommonJS declare function require ( path : string ): any ;"
                },
                {
                    "type": "code",
                    "code": "ts // For RequireJS/AMD declare function define (... args : any []): any ;"
                },
                {
                    "type": "p",
                    "text": "it’s better to get rid of those calls and use TypeScript syntax for imports. First, you’ll need to enable some module system by setting TypeScript’s module option.\nValid options are commonjs , amd , system , and umd . If you had the following Node/CommonJS code:"
                },
                {
                    "type": "code",
                    "code": "js var foo = require ( \"foo\" ); foo . doStuff ();"
                },
                {
                    "type": "code",
                    "code": "js define ([ \"foo\" ], function ( foo ) { foo . doStuff (); });"
                },
                {
                    "type": "p",
                    "text": "then you would write the following TypeScript code:"
                },
                {
                    "type": "code",
                    "code": "ts import foo = require ( \"foo\" ); foo . doStuff ();"
                },
                {
                    "type": "p",
                    "text": "If you started converting over to TypeScript imports, you’ll probably run into errors like Cannot find module 'foo'. .\nThe issue here is that you likely don’t have declaration files to describe your library.\nLuckily this is pretty easy.\nIf TypeScript complains about a package like lodash , you can just write"
                },
                {
                    "type": "code",
                    "code": "shell npm install -S @types/lodash"
                },
                {
                    "type": "p",
                    "text": "If you’re using a module option other than commonjs , you’ll need to set your moduleResolution option to node . After that, you’ll be able to import lodash with no issues, and get accurate completions. Typically, exporting from a module involves adding properties to a value like exports or module.exports .\nTypeScript allows you to use top-level export statements.\nFor instance, if you exported a function like so:"
                },
                {
                    "type": "code",
                    "code": "js module . exports . feedPets = function ( pets ) { // ... };"
                },
                {
                    "type": "p",
                    "text": "you could write that out as the following:"
                },
                {
                    "type": "code",
                    "code": "ts export function feedPets ( pets ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll entirely overwrite the exports object.\nThis is a common pattern people use to make their modules immediately callable like in this snippet:"
                },
                {
                    "type": "code",
                    "code": "js var express = require ( \"express\" ); var app = express ();"
                },
                {
                    "type": "p",
                    "text": "You might have previously written that like so:"
                },
                {
                    "type": "code",
                    "code": "js function foo () { // ... } module . exports = foo ;"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, you can model this with the export = construct."
                },
                {
                    "type": "code",
                    "code": "ts function foo () { // ... } export = foo ;"
                },
                {
                    "type": "p",
                    "text": "You’ll sometimes find yourself calling a function with too many/few arguments.\nTypically, this is a bug, but in some cases, you might have declared a function that uses the arguments object instead of writing out any parameters:"
                },
                {
                    "type": "code",
                    "code": "js function myCoolFunction () { if ( arguments . length == 2 && ! Array . isArray ( arguments [ 1 ])) { var f = arguments [ 0 ]; var arr = arguments [ 1 ]; // ... } // ... } myCoolFunction ( function ( x ) { console . log ( x ); }, [ 1 , 2 , 3 , 4 ] ); myCoolFunction ( function ( x ) { console . log ( x ); }, 1 , 2 , 3 , 4 );"
                },
                {
                    "type": "p",
                    "text": "In this case, we need to use TypeScript to tell any of our callers about the ways myCoolFunction can be called using function overloads."
                },
                {
                    "type": "code",
                    "code": "ts function myCoolFunction ( f : ( x : number ) => void , nums : number []): void ; function myCoolFunction ( f : ( x : number ) => void , ... nums : number []): void ; function myCoolFunction () { if ( arguments . length == 2 && ! Array . isArray ( arguments [ 1 ])) { var f = arguments [ 0 ]; var arr = arguments [ 1 ]; // ... } // ... }"
                },
                {
                    "type": "p",
                    "text": "We added two overload signatures to myCoolFunction .\nThe first checks states that myCoolFunction takes a function (which takes a number ), and then a list of number s.\nThe second one says that it will take a function as well, and then uses a rest parameter ( ...nums ) to state that any number of arguments after that need to be number s. Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:"
                },
                {
                    "type": "code",
                    "code": "js var options = {}; options . color = \"red\" ; options . volume = 11 ;"
                },
                {
                    "type": "p",
                    "text": "TypeScript will say that you can’t assign to color and volume because it first figured out the type of options as {} which doesn’t have any properties.\nIf you instead moved the declarations into the object literal themselves, you’d get no errors:"
                },
                {
                    "type": "code",
                    "code": "ts let options = { color: \"red\" , volume: 11 , };"
                },
                {
                    "type": "p",
                    "text": "You could also define the type of options and add a type assertion on the object literal."
                },
                {
                    "type": "code",
                    "code": "ts interface Options { color : string ; volume : number ; } let options = {} as Options ; options . color = \"red\" ; options . volume = 11 ;"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can just say options has the type any which is the easiest thing to do, but which will benefit you the least. You might be tempted to use Object or {} to say that a value can have any property on it because Object is, for most purposes, the most general type.\nHowever any is actually the type you want to use in those situations, since it’s the most flexible type. For instance, if you have something that’s typed as Object you won’t be able to call methods like toLowerCase() on it.\nBeing more general usually means you can do less with a type, but any is special in that it is the most general type while still allowing you to do anything with it.\nThat means you can call it, construct it, access properties on it, etc.\nKeep in mind though, whenever you use any , you lose out on most of the error checking and editor support that TypeScript gives you. If a decision ever comes down to Object and {} , you should prefer {} .\nWhile they are mostly the same, technically {} is a more general type than Object in certain esoteric cases. TypeScript comes with certain checks to give you more safety and analysis of your program.\nOnce you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety. There are certain cases where TypeScript can’t figure out what certain types should be.\nTo be as lenient as possible, it will decide to use the type any in its place.\nWhile this is great for migration, using any means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere.\nYou can tell TypeScript to flag these locations down and give an error with the noImplicitAny option. By default, TypeScript assumes that null and undefined are in the domain of every type.\nThat means anything declared with the type number could be null or undefined .\nSince null and undefined are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the strictNullChecks option to spare you the stress of worrying about these issues. When strictNullChecks is enabled, null and undefined get their own types called null and undefined respectively.\nWhenever anything is possibly null , you can use a union type with the original type.\nSo for instance, if something could be a number or null , you’d write the type out as number | null . If you ever have a value that TypeScript thinks is possibly null / undefined , but you know better, you can use the postfix ! operator to tell it otherwise."
                },
                {
                    "type": "code",
                    "code": "ts declare var foo : string [] | null ; foo . length ; // error - 'foo' is possibly 'null' foo !. length ; // okay - 'foo!' just has type 'string[]'"
                },
                {
                    "type": "p",
                    "text": "As a heads up, when using strictNullChecks , your dependencies may need to be updated to use strictNullChecks as well. When you use the this keyword outside of classes, it has the type any by default.\nFor instance, imagine a Point class, and imagine a function that we wish to add as a method:"
                },
                {
                    "type": "code",
                    "code": "ts class Point { constructor ( public x , public y ) {} getDistance ( p : Point ) { let dx = p . x - this . x ; let dy = p . y - this . y ; return Math . sqrt ( dx ** 2 + dy ** 2 ); } } // ... // Reopen the interface. interface Point { distanceFromOrigin (): number ; } Point . prototype . distanceFromOrigin = function () { return this . getDistance ({ x: 0 , y: 0 }); };"
                },
                {
                    "type": "p",
                    "text": "This has the same problems we mentioned above - we could easily have misspelled getDistance and not gotten an error.\nFor this reason, TypeScript has the noImplicitThis option.\nWhen that option is set, TypeScript will issue an error when this is used without an explicit (or inferred) type.\nThe fix is to use a this -parameter to give an explicit type in the interface or in the function itself:"
                },
                {
                    "type": "code",
                    "code": "ts Point . prototype . distanceFromOrigin = function ( this : Point ) { return this . getDistance ({ x: 0 , y: 0 }); };"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/mixins.html",
            "title": "TypeScript: Documentation - Mixins",
            "content": [
                {
                    "type": "p",
                    "text": "Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes.\nYou may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community. The pattern relies on using generics with class inheritance to extend a base class.\nTypeScript’s best mixin support is done via the class expression pattern.\nYou can read more about how this pattern works in JavaScript here . To get started, we’ll need a class which will have the mixins applied on top of:"
                },
                {
                    "type": "code",
                    "code": "ts class Sprite { name = \"\" ; x = 0 ; y = 0 ; constructor ( name : string ) { this . name = name ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Then you need a type and a factory function which returns a class expression extending the base class."
                },
                {
                    "type": "code",
                    "code": "ts // To get started, we need a type which we'll use to extend // other classes from. The main responsibility is to declare // that the type being passed in is a class. type Constructor = new (... args : any []) => {}; // This mixin adds a scale property, with getters and setters // for changing it with an encapsulated private property: function Scale < TBase extends Constructor >( Base : TBase ) { return class Scaling extends Base { // Mixins may not declare private/protected properties // however, you can use ES2020 private fields _scale = 1 ; setScale ( scale : number ) { this . _scale = scale ; } get scale (): number { return this . _scale ; } }; } Try"
                },
                {
                    "type": "p",
                    "text": "With these all set up, then you can create a class which represents the base class with mixins applied:"
                },
                {
                    "type": "code",
                    "code": "ts // Compose a new class from the Sprite class, // with the Mixin Scale applier: const EightBitSprite = Scale ( Sprite ); const flappySprite = new EightBitSprite ( \"Bird\" ); flappySprite . setScale ( 0.8 ); console . log ( flappySprite . scale ); Try"
                },
                {
                    "type": "p",
                    "text": "In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want. To model this, we modify the original constructor type to accept a generic argument."
                },
                {
                    "type": "code",
                    "code": "ts // This was our previous constructor: type Constructor = new (... args : any []) => {}; // Now we use a generic version which can apply a constraint on // the class which this mixin is applied to type GConstructor < T = {}> = new (... args : any []) => T ; Try"
                },
                {
                    "type": "p",
                    "text": "This allows for creating classes which only work with constrained base classes:"
                },
                {
                    "type": "code",
                    "code": "ts type Positionable = GConstructor <{ setPos : ( x : number , y : number ) => void }>; type Spritable = GConstructor < Sprite >; type Loggable = GConstructor <{ print : () => void }>; Try"
                },
                {
                    "type": "p",
                    "text": "Then you can create mixins which only work when you have a particular base to build on:"
                },
                {
                    "type": "code",
                    "code": "ts function Jumpable < TBase extends Positionable >( Base : TBase ) { return class Jumpable extends Base { jump () { // This mixin will only work if it is passed a base // class which has setPos defined because of the // Positionable constraint. this . setPos ( 0 , 20 ); } }; } Try"
                },
                {
                    "type": "p",
                    "text": "Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:"
                },
                {
                    "type": "code",
                    "code": "ts // Each mixin is a traditional ES class class Jumpable { jump () {} } class Duckable { duck () {} } // Including the base class Sprite { x = 0 ; y = 0 ; } // Then you create an interface which merges // the expected mixins with the same name as your base interface Sprite extends Jumpable , Duckable {} // Apply the mixins into the base class via // the JS at runtime applyMixins ( Sprite , [ Jumpable , Duckable ]); let player = new Sprite (); player . jump (); console . log ( player . x , player . y ); // This can live anywhere in your codebase: function applyMixins ( derivedCtor : any , constructors : any []) { constructors . forEach (( baseCtor ) => { Object . getOwnPropertyNames ( baseCtor . prototype ). forEach (( name ) => { Object . defineProperty ( derivedCtor . prototype , name , Object . getOwnPropertyDescriptor ( baseCtor . prototype , name ) || Object . create ( null ) ); }); }); } Try"
                },
                {
                    "type": "p",
                    "text": "This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync. The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis.\nThere are a few cases where you can hit the edges of the native support. You cannot use decorators to provide mixins via code flow analysis:"
                },
                {
                    "type": "code",
                    "code": "ts // A decorator function which replicates the mixin pattern: const Pausable = ( target : typeof Player ) => { return class Pausable extends target { shouldFreeze = false ; }; }; @ Pausable class Player { x = 0 ; y = 0 ; } // The Player class does not have the decorator's type merged: const player = new Player (); player . shouldFreeze ; Property 'shouldFreeze' does not exist on type 'Player'. 2339 Property 'shouldFreeze' does not exist on type 'Player'. // The runtime aspect could be manually replicated via // type composition or interface merging. type FreezablePlayer = Player & { shouldFreeze : boolean }; const playerTwo = ( new Player () as unknown ) as FreezablePlayer ; playerTwo . shouldFreeze ; Try"
                },
                {
                    "type": "p",
                    "text": "More of a gotcha than a constraint.\nThe class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types. You can work around this by using functions to return your classes which differ based on a generic:"
                },
                {
                    "type": "code",
                    "code": "ts function base < T >() { class Base { static prop : T ; } return Base ; } function derived < T >() { class Derived extends base < T >() { static anotherProp : T ; } return Derived ; } class Spec extends derived < string >() {} Spec . prop ; // string Spec . anotherProp ; // string Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
            "title": "TypeScript: Documentation - Namespaces",
            "content": [
                {
                    "type": "p",
                    "text": "A note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed.\n“Internal modules” are now “namespaces”.\n“External modules” are now simply “modules”, as to align with ECMAScript 2015 ’s terminology, (namely that module X { is equivalent to the now-preferred namespace X { ). This post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript.\nAs we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”.\nAdditionally, anywhere the module keyword was used when declaring an internal module, the namespace keyword can and should be used instead.\nThis avoids confusing new users by overloading them with similarly named terms. Let’s start with the program we’ll be using as our example throughout this page.\nWe’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file."
                },
                {
                    "type": "code",
                    "code": "ts interface StringValidator { isAcceptable ( s : string ): boolean ; } let lettersRegexp = / ^ [ A-Za-z ] + $ / ; let numberRegexp = / ^ [ 0-9 ] + $ / ; class LettersOnlyValidator implements StringValidator { isAcceptable ( s : string ) { return lettersRegexp . test ( s ); } } class ZipCodeValidator implements StringValidator { isAcceptable ( s : string ) { return s . length === 5 && numberRegexp . test ( s ); } } // Some samples to try let strings = [ \"Hello\" , \"98052\" , \"101\" ]; // Validators to use let validators : { [ s : string ]: StringValidator } = {}; validators [ \"ZIP code\" ] = new ZipCodeValidator (); validators [ \"Letters only\" ] = new LettersOnlyValidator (); // Show whether each string passed each validator for ( let s of strings ) { for ( let name in validators ) { let isMatch = validators [ name ]. isAcceptable ( s ); console . log ( `' ${ s } ' ${ isMatch ? \"matches\" : \"does not match\" } ' ${ name } '.` ); } }"
                },
                {
                    "type": "p",
                    "text": "As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects.\nInstead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace. In this example, we’ll move all validator-related entities into a namespace called Validation .\nBecause we want the interfaces and classes here to be visible outside the namespace, we preface them with export .\nConversely, the variables lettersRegexp and numberRegexp are implementation details, so they are left unexported and will not be visible to code outside the namespace.\nIn the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. Validation.LettersOnlyValidator ."
                },
                {
                    "type": "code",
                    "code": "ts namespace Validation { export interface StringValidator { isAcceptable ( s : string ): boolean ; } const lettersRegexp = / ^ [ A-Za-z ] + $ / ; const numberRegexp = / ^ [ 0-9 ] + $ / ; export class LettersOnlyValidator implements StringValidator { isAcceptable ( s : string ) { return lettersRegexp . test ( s ); } } export class ZipCodeValidator implements StringValidator { isAcceptable ( s : string ) { return s . length === 5 && numberRegexp . test ( s ); } } } // Some samples to try let strings = [ \"Hello\" , \"98052\" , \"101\" ]; // Validators to use let validators : { [ s : string ]: Validation . StringValidator } = {}; validators [ \"ZIP code\" ] = new Validation . ZipCodeValidator (); validators [ \"Letters only\" ] = new Validation . LettersOnlyValidator (); // Show whether each string passed each validator for ( let s of strings ) { for ( let name in validators ) { console . log ( `\" ${ s } \" - ${ validators [ name ]. isAcceptable ( s ) ? \"matches\" : \"does not match\" } ${ name } ` ); } }"
                },
                {
                    "type": "p",
                    "text": "As our application grows, we’ll want to split the code across multiple files to make it easier to maintain. Here, we’ll split our Validation namespace across many files.\nEven though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place.\nBecause there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files.\nOur test code is otherwise unchanged."
                },
                {
                    "type": "code",
                    "code": "ts namespace Validation { export interface StringValidator { isAcceptable ( s : string ): boolean ; } }"
                },
                {
                    "type": "code",
                    "code": "ts /// <reference path = \"Validation.ts\" /> namespace Validation { const lettersRegexp = / ^ [ A-Za-z ] + $ / ; export class LettersOnlyValidator implements StringValidator { isAcceptable ( s : string ) { return lettersRegexp . test ( s ); } } }"
                },
                {
                    "type": "code",
                    "code": "ts /// <reference path = \"Validation.ts\" /> namespace Validation { const numberRegexp = / ^ [ 0-9 ] + $ / ; export class ZipCodeValidator implements StringValidator { isAcceptable ( s : string ) { return s . length === 5 && numberRegexp . test ( s ); } } }"
                },
                {
                    "type": "code",
                    "code": "ts /// <reference path = \"Validation.ts\" /> /// <reference path = \"LettersOnlyValidator.ts\" /> /// <reference path = \"ZipCodeValidator.ts\" /> // Some samples to try let strings = [ \"Hello\" , \"98052\" , \"101\" ]; // Validators to use let validators : { [ s : string ]: Validation . StringValidator } = {}; validators [ \"ZIP code\" ] = new Validation . ZipCodeValidator (); validators [ \"Letters only\" ] = new Validation . LettersOnlyValidator (); // Show whether each string passed each validator for ( let s of strings ) { for ( let name in validators ) { console . log ( `\" ${ s } \" - ${ validators [ name ]. isAcceptable ( s ) ? \"matches\" : \"does not match\" } ${ name } ` ); } }"
                },
                {
                    "type": "p",
                    "text": "Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded.\nThere are two ways of doing this. First, we can use concatenated output using the outFile option to compile all of the input files into a single JavaScript output file:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Test.ts"
                },
                {
                    "type": "p",
                    "text": "The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts"
                },
                {
                    "type": "p",
                    "text": "Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file.\nIf multiple JS files get produced, we’ll need to use <script> tags on our webpage to load each emitted file in the appropriate order, for example:"
                },
                {
                    "type": "code",
                    "code": "html <script src = \"Validation.js\" type = \"text/javascript\" / > <script src = \"LettersOnlyValidator.js\" type = \"text/javascript\" /> <script src = \"ZipCodeValidator.js\" type = \"text/javascript\" /> <script src = \"Test.js\" type = \"text/javascript\" />"
                },
                {
                    "type": "p",
                    "text": "Another way that you can simplify working with namespaces is to use import q = x.y.z to create shorter names for commonly-used objects.\nNot to be confused with the import x = require(\"name\") syntax used to load modules, this syntax simply creates an alias for the specified symbol.\nYou can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports."
                },
                {
                    "type": "code",
                    "code": "ts namespace Shapes { export namespace Polygons { export class Triangle {} export class Square {} } } import polygons = Shapes . Polygons ; let sq = new polygons . Square (); // Same as 'new Shapes.Polygons.Square()'"
                },
                {
                    "type": "p",
                    "text": "Notice that we don’t use the require keyword; instead we assign directly from the qualified name of the symbol we’re importing.\nThis is similar to using var , but also works on the type and namespace meanings of the imported symbol.\nImportantly, for values, import is a distinct reference from the original symbol, so changes to an aliased var will not be reflected in the original variable. To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.\nBecause most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them. We call declarations that don’t define an implementation “ambient”.\nTypically these are defined in .d.ts files.\nIf you’re familiar with C/C++, you can think of these as .h files.\nLet’s look at a few examples. The popular library D3 defines its functionality in a global object called d3 .\nBecause this library is loaded through a <script> tag (instead of a module loader), its declaration uses namespaces to define its shape.\nFor the TypeScript compiler to see this shape, we use an ambient namespace declaration.\nFor example, we could begin writing it as follows:"
                },
                {
                    "type": "code",
                    "code": "ts declare namespace D3 { export interface Selectors { select : { ( selector : string ): Selection ; ( element : EventTarget ): Selection ; }; } export interface Event { x : number ; y : number ; } export interface Base extends Selectors { event : Event ; } } declare var d3 : D3 . Base ;"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/nightly-builds.html",
            "title": "TypeScript: Documentation - Nightly Builds",
            "content": [
                {
                    "type": "p",
                    "text": "A nightly build from the TypeScript’s main branch is published by midnight PST to npm.\nHere is how you can get it and use it with your tools."
                },
                {
                    "type": "code",
                    "code": "shell npm install -D typescript@next"
                },
                {
                    "type": "p",
                    "text": "You can also update your editor/IDE to use the nightly drop.\nYou will typically need to install the package through npm.\nThe rest of this section mostly assumes typescript@next is already installed. The VS Code website has documentation on selecting a workspace version of TypeScript .\nAfter installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view.\nA direct way to do this is to open or create your workspace’s .vscode/settings.json and add the following property:"
                },
                {
                    "type": "code",
                    "code": "json \"typescript.tsdk\" : \"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "Alternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the JavaScript and TypeScript Nightly Extension Update the Settings - User file with the following:"
                },
                {
                    "type": "code",
                    "code": "json \"typescript_tsdk\" : \"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "More information is available at the TypeScript Plugin for Sublime Text installation documentation . Note: Most changes do not require you to install a new version of the VS TypeScript plugin. The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well."
                },
                {
                    "type": "list",
                    "items": [
                        "Download the VSDevMode.ps1 script. Also see our wiki page on using a custom language service file .",
                        "From a PowerShell command window, run:"
                    ]
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "p",
                    "text": "Go to Preferences > Languages & Frameworks > TypeScript : TypeScript Version: If you installed with npm: /usr/local/lib/node_modules/typescript/lib Go to File > Settings > Languages & Frameworks > TypeScript : TypeScript Version: If you installed with npm: C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
            "title": "TypeScript: Documentation - Project References",
            "content": [
                {
                    "type": "p",
                    "text": "Project references allows you to structure your TypeScript programs into smaller pieces, available in TypeScript 3.0 and newer. By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways. We’re also introducing a new mode for tsc , the --build flag, that works hand in hand with project references to enable faster TypeScript builds. Let’s look at a fairly normal program and see how project references can help us better organize it.\nImagine you have a project with two modules, converter and units , and a corresponding test file for each:"
                },
                {
                    "type": "code",
                    "code": "/ ├── src/ │   ├── converter.ts │   └── units.ts ├── test/ │   ├── converter-tests.ts │   └── units-tests.ts └── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "The test files import the implementation files and do some testing:"
                },
                {
                    "type": "code",
                    "code": "ts // converter-tests.ts import * as converter from \"../src/converter\" ; assert . areEqual ( converter . celsiusToFahrenheit ( 0 ), 32 );"
                },
                {
                    "type": "p",
                    "text": "Previously, this structure was rather awkward to work with if you used a single tsconfig file:"
                },
                {
                    "type": "list",
                    "items": [
                        "It was possible for the implementation files to import the test files",
                        "It wasn’t possible to build test and src at the same time without having src appear in the output folder name, which you probably don’t want",
                        "Changing just the internals in the implementation files required typechecking the tests again, even though this wouldn’t ever cause new errors",
                        "Changing just the tests required typechecking the implementation again, even if nothing changed"
                    ]
                },
                {
                    "type": "p",
                    "text": "You could use multiple tsconfig files to solve some of those problems, but new ones would appear:"
                },
                {
                    "type": "list",
                    "items": [
                        "There’s no built-in up-to-date checking, so you end up always running tsc twice",
                        "Invoking tsc twice incurs more startup time overhead",
                        "tsc -w can’t run on multiple config files at once"
                    ]
                },
                {
                    "type": "p",
                    "text": "Project references can solve all of these problems and more. tsconfig.json files have a new top-level property, references . It’s an array of objects that specifies projects to reference:"
                },
                {
                    "type": "code",
                    "code": "js { \"compilerOptions\" : { // The usual }, \"references\" : [ { \"path\" : \"../src\" } ] }"
                },
                {
                    "type": "p",
                    "text": "The path property of each reference can point to a directory containing a tsconfig.json file, or to the config file itself (which may have any name). When you reference a project, new things happen:"
                },
                {
                    "type": "list",
                    "items": [
                        "Importing modules from a referenced project will instead load its output declaration file ( .d.ts )",
                        "If the referenced project produces an outFile , the output file .d.ts file’s declarations will be visible in this project",
                        "Build mode (see below) will automatically build the referenced project if needed"
                    ]
                },
                {
                    "type": "p",
                    "text": "By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program. Referenced projects must have the new composite setting enabled.\nThis setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project.\nEnabling the composite flag changes a few things:"
                },
                {
                    "type": "list",
                    "items": [
                        "The rootDir setting, if not explicitly set, defaults to the directory containing the tsconfig file",
                        "All implementation files must be matched by an include pattern or listed in the files array. If this constraint is violated, tsc will inform you which files weren’t specified",
                        "declaration must be turned on"
                    ]
                },
                {
                    "type": "p",
                    "text": "We’ve also added support for declaration source maps .\nIf you enable declarationMap , you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors. Project references have a few trade-offs you should be aware of. Because dependent projects make use of .d.ts files that are built from their dependencies, you’ll either have to check in certain build outputs or build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory .d.ts generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using disableSourceOfProjectReferenceRedirect option . Additionally, to preserve compatibility with existing build workflows, tsc will not automatically build dependencies unless invoked with the --build switch.\nLet’s learn more about --build . A long-awaited feature is smart incremental builds for TypeScript projects.\nIn 3.0 you can use the --build flag with tsc .\nThis is effectively a new entry point for tsc that behaves more like a build orchestrator than a simple compiler. Running tsc --build ( tsc -b for short) will do the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Find all referenced projects",
                        "Detect if they are up-to-date",
                        "Build out-of-date projects in the correct order"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can provide tsc -b with multiple config file paths (e.g. tsc -b src test ).\nJust like tsc -p , specifying the config file name itself is unnecessary if it’s named tsconfig.json . You can specify any number of config files:"
                },
                {
                    "type": "code",
                    "code": "shell > tsc -b # Use the tsconfig.json in the current directory > tsc -b src # Use src/tsconfig.json > tsc -b foo/prd.tsconfig.json bar # Use foo/prd.tsconfig.json and bar/tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "Don’t worry about ordering the files you pass on the commandline - tsc will re-order them if needed so that dependencies are always built first. There are also some flags specific to tsc -b :"
                },
                {
                    "type": "list",
                    "items": [
                        "--verbose : Prints out verbose logging to explain what’s going on (may be combined with any other flag)",
                        "--dry : Shows what would be done but doesn’t actually build anything",
                        "--clean : Deletes the outputs of the specified projects (may be combined with --dry )",
                        "--force : Act as if all projects are out of date",
                        "--watch : Watch mode (may not be combined with any flag except --verbose )"
                    ]
                },
                {
                    "type": "p",
                    "text": "Normally, tsc will produce outputs ( .js and .d.ts ) in the presence of syntax or type errors, unless noEmitOnError is on.\nDoing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it once because a subsequent build would skip building the now up-to-date project.\nFor this reason, tsc -b effectively acts as if noEmitOnError is enabled for all projects. If you check in any build outputs ( .js , .d.ts , .d.ts.map , etc.), you may need to run a --force build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy. If you have an msbuild project, you can enable build mode by adding"
                },
                {
                    "type": "code",
                    "code": "xml <TypeScriptBuildMode> true </TypeScriptBuildMode>"
                },
                {
                    "type": "p",
                    "text": "to your proj file. This will enable automatic incremental build as well as cleaning. Note that as with tsconfig.json / -p , existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file. Some teams have set up msbuild-based workflows wherein tsconfig files have the same implicit graph ordering as the managed projects they are paired with.\nIf your solution is like this, you can continue to use msbuild with tsc -p along with project references; these are fully interoperable. With more tsconfig.json files, you’ll usually want to use Configuration file inheritance to centralize your common compiler options.\nThis way you can change a setting in one file rather than having to edit multiple files. Another good practice is to have a “solution” tsconfig.json file that simply has references to all of your leaf-node projects and sets files to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty files array if you have at least one reference in a tsconfig.json file. This presents a simple entry point; e.g. in the TypeScript repo we simply run tsc -b src to build all endpoints because we list all the subprojects in src/tsconfig.json You can see these patterns in the TypeScript repo - see src/tsconfig_base.json , src/tsconfig.json , and src/tsc/tsconfig.json as key examples. In general, not much is needed to transition a repo using relative modules.\nSimply place a tsconfig.json file in each subdirectory of a given parent folder, and add reference s to these config files to match the intended layering of the program.\nYou will need to either set the outDir to an explicit subfolder of the output folder, or set the rootDir to the common root of all project folders. Layout for compilations using outFile is more flexible because relative paths don’t matter as much.\nThe TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html",
            "title": "TypeScript: Documentation - TypeScript 5.0",
            "content": [
                {
                    "type": "p",
                    "text": "Decorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way."
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } greet () { console . log ( `Hello, my name is ${ this . name } .` ); } } const p = new Person ( \"Ray\" ); p . greet ();"
                },
                {
                    "type": "p",
                    "text": "greet is pretty simple here, but let’s imagine it’s something way more complicated - maybe it does some async logic, it’s recursive, it has side effects, etc.\nRegardless of what kind of ball-of-mud you’re imagining, let’s say you throw in some console.log calls to help debug greet ."
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } greet () { console . log ( \"LOG: Entering method.\" ); console . log ( `Hello, my name is ${ this . name } .` ); console . log ( \"LOG: Exiting method.\" ) } }"
                },
                {
                    "type": "p",
                    "text": "This pattern is fairly common.\nIt sure would be nice if there was a way we could do this for every method! This is where decorators come in.\nWe can write a function called loggedMethod that looks like the following:"
                },
                {
                    "type": "code",
                    "code": "ts function loggedMethod ( originalMethod : any , _context : any ) { function replacementMethod ( this : any , ... args : any []) { console . log ( \"LOG: Entering method.\" ) const result = originalMethod . call ( this , ... args ); console . log ( \"LOG: Exiting method.\" ) return result ; } return replacementMethod ; }"
                },
                {
                    "type": "p",
                    "text": "“What’s the deal with all of these any s?\nWhat is this, any Script!?” Just be patient - we’re keeping things simple for now so that we can focus on what this function is doing.\nNotice that loggedMethod takes the original method ( originalMethod ) and returns a function that"
                },
                {
                    "type": "list",
                    "items": [
                        "logs an “Entering…” message",
                        "passes along this and all of its arguments to the original method",
                        "logs an “Exiting…” message, and",
                        "returns whatever the original method returned."
                    ]
                },
                {
                    "type": "p",
                    "text": "Now we can use loggedMethod to decorate the method greet :"
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } @ loggedMethod greet () { console . log ( `Hello, my name is ${ this . name } .` ); } } const p = new Person ( \"Ray\" ); p . greet (); // Output: // //   LOG: Entering method. //   Hello, my name is Ray. //   LOG: Exiting method."
                },
                {
                    "type": "p",
                    "text": "We just used loggedMethod as a decorator above greet - and notice that we wrote it as @loggedMethod .\nWhen we did that, it got called with the method target and a context object .\nBecause loggedMethod returned a new function, that function replaced the original definition of greet . We didn’t mention it yet, but loggedMethod was defined with a second parameter.\nIt’s called a “context object”, and it has some useful information about how the decorated method was declared - like whether it was a #private member, or static , or what the name of the method was.\nLet’s rewrite loggedMethod to take advantage of that and print out the name of the method that was decorated."
                },
                {
                    "type": "code",
                    "code": "ts function loggedMethod ( originalMethod : any , context : ClassMethodDecoratorContext ) { const methodName = String ( context . name ); function replacementMethod ( this : any , ... args : any []) { console . log ( `LOG: Entering method ' ${ methodName } '.` ) const result = originalMethod . call ( this , ... args ); console . log ( `LOG: Exiting method ' ${ methodName } '.` ) return result ; } return replacementMethod ; }"
                },
                {
                    "type": "p",
                    "text": "We’re now using the context parameter - and that it’s the first thing in loggedMethod that has a type stricter than any and any[] .\nTypeScript provides a type called ClassMethodDecoratorContext that models the context object that method decorators take. Apart from metadata, the context object for methods also has a useful function called addInitializer .\nIt’s a way to hook into the beginning of the constructor (or the initialization of the class itself if we’re working with static s). As an example - in JavaScript, it’s common to write something like the following pattern:"
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; this . greet = this . greet . bind ( this ); } greet () { console . log ( `Hello, my name is ${ this . name } .` ); } }"
                },
                {
                    "type": "p",
                    "text": "Alternatively, greet might be declared as a property initialized to an arrow function."
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } greet = () => { console . log ( `Hello, my name is ${ this . name } .` ); }; }"
                },
                {
                    "type": "p",
                    "text": "This code is written to ensure that this isn’t re-bound if greet is called as a stand-alone function or passed as a callback."
                },
                {
                    "type": "code",
                    "code": "ts const greet = new Person ( \"Ray\" ). greet ; // We don't want this to fail! greet ();"
                },
                {
                    "type": "p",
                    "text": "We can write a decorator that uses addInitializer to call bind in the constructor for us."
                },
                {
                    "type": "code",
                    "code": "ts function bound ( originalMethod : any , context : ClassMethodDecoratorContext ) { const methodName = context . name ; if ( context . private ) { throw new Error ( `'bound' cannot decorate private properties like ${ methodName as string } .` ); } context . addInitializer ( function () { this [ methodName ] = this [ methodName ]. bind ( this ); }); }"
                },
                {
                    "type": "p",
                    "text": "bound isn’t returning anything - so when it decorates a method, it leaves the original alone.\nInstead, it will add logic before any other fields are initialized."
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } @ bound @ loggedMethod greet () { console . log ( `Hello, my name is ${ this . name } .` ); } } const p = new Person ( \"Ray\" ); const greet = p . greet ; // Works! greet ();"
                },
                {
                    "type": "p",
                    "text": "Notice that we stacked two decorators - @bound and @loggedMethod .\nThese decorations run in “reverse order”.\nThat is, @loggedMethod decorates the original method greet , and @bound decorates the result of @loggedMethod .\nIn this example, it doesn’t matter - but it could if your decorators have side-effects or expect a certain order. Also worth noting - if you’d prefer stylistically, you can put these decorators on the same line."
                },
                {
                    "type": "code",
                    "code": "ts @ bound @ loggedMethod greet () { console . log ( `Hello, my name is ${ this . name } .` ); }"
                },
                {
                    "type": "p",
                    "text": "Something that might not be obvious is that we can even make functions that return decorator functions.\nThat makes it possible to customize the final decorator just a little.\nIf we wanted, we could have made loggedMethod return a decorator and customize how it logs its messages."
                },
                {
                    "type": "code",
                    "code": "ts function loggedMethod ( headMessage = \"LOG:\" ) { return function actualDecorator ( originalMethod : any , context : ClassMethodDecoratorContext ) { const methodName = String ( context . name ); function replacementMethod ( this : any , ... args : any []) { console . log ( ` ${ headMessage } Entering method ' ${ methodName } '.` ) const result = originalMethod . call ( this , ... args ); console . log ( ` ${ headMessage } Exiting method ' ${ methodName } '.` ) return result ; } return replacementMethod ; } }"
                },
                {
                    "type": "p",
                    "text": "If we did that, we’d have to call loggedMethod before using it as a decorator.\nWe could then pass in any string as the prefix for messages that get logged to the console."
                },
                {
                    "type": "code",
                    "code": "ts class Person { name : string ; constructor ( name : string ) { this . name = name ; } @ loggedMethod ( \"⚠️\" ) greet () { console . log ( `Hello, my name is ${ this . name } .` ); } } const p = new Person ( \"Ray\" ); p . greet (); // Output: // //   ⚠️ Entering method 'greet'. //   Hello, my name is Ray. //   ⚠️ Exiting method 'greet'."
                },
                {
                    "type": "p",
                    "text": "Decorators can be used on more than just methods!\nThey can be used on properties/fields, getters, setters, and auto-accessors.\nEven classes themselves can be decorated for things like subclassing and registration. To learn more about decorators in-depth, you can read up on Axel Rauschmayer’s extensive summary . For more information about the changes involved, you can view the original pull request . If you’ve been using TypeScript for a while, you might be aware of the fact that it’s had support for “experimental” decorators for years.\nWhile these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called --experimentalDecorators .\nAny attempt to use decorators in TypeScript without this flag used to prompt an error message. --experimentalDecorators will continue to exist for the foreseeable future;\nhowever, without the flag, decorators will now be valid syntax for all new code.\nOutside of --experimentalDecorators , they will be type-checked and emitted differently.\nThe type-checking rules and emit are sufficiently different that while decorators can be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so. This new decorators proposal is not compatible with --emitDecoratorMetadata , and it does not allow decorating parameters.\nFuture ECMAScript proposals may be able to help bridge that gap. On a final note: in addition to allowing decorators to be placed before the export keyword, the proposal for decorators now provides the option of placing decorators after export or export default .\nThe only exception is that mixing the two styles is not allowed."
                },
                {
                    "type": "code",
                    "code": "js // ✅ allowed @ register export default class Foo { // ... } // ✅ also allowed export default @ register class Bar { // ... } // ❌ error - before *and* after is not allowed @ before export @ after class Bar { // ... }"
                },
                {
                    "type": "p",
                    "text": "The loggedMethod and bound decorator examples above are intentionally simple and omit lots of details about types. Typing decorators can be fairly complex.\nFor example, a well-typed version of loggedMethod from above might look something like this:"
                },
                {
                    "type": "code",
                    "code": "ts function loggedMethod < This , Args extends any [], Return >( target : ( this : This , ... args : Args ) => Return , context : ClassMethodDecoratorContext < This , ( this : This , ... args : Args ) => Return > ) { const methodName = String ( context . name ); function replacementMethod ( this : This , ... args : Args ): Return { console . log ( `LOG: Entering method ' ${ methodName } '.` ) const result = target . call ( this , ... args ); console . log ( `LOG: Exiting method ' ${ methodName } '.` ) return result ; } return replacementMethod ; }"
                },
                {
                    "type": "p",
                    "text": "We had to separately model out the type of this , the parameters, and the return type of the original method, using the type parameters This , Args , and Return . Exactly how complex your decorators functions are defined depends on what you want to guarantee.\nJust keep in mind, your decorators will be used more than they’re written, so a well-typed version will usually be preferable - but there’s clearly a trade-off with readability, so try to keep things simple. More documentation on writing decorators will be available in the future - but this post should have a good amount of detail for the mechanics of decorators. When inferring the type of an object, TypeScript will usually choose a type that’s meant to be general.\nFor example, in this case, the inferred type of names is string[] :"
                },
                {
                    "type": "code",
                    "code": "ts type HasNames = { names : readonly string [] }; function getNamesExactly < T extends HasNames >( arg : T ): T [ \"names\" ] { return arg . names ; } // Inferred type: string[] const names = getNamesExactly ({ names: [ \"Alice\" , \"Bob\" , \"Eve\" ]});"
                },
                {
                    "type": "p",
                    "text": "Usually the intent of this is to enable mutation down the line. However, depending on what exactly getNamesExactly does and how it’s intended to be used, it can often be the case that a more-specific type is desired. Up until now, API authors have typically had to recommend adding as const in certain places to achieve the desired inference:"
                },
                {
                    "type": "code",
                    "code": "ts // The type we wanted: //    readonly [\"Alice\", \"Bob\", \"Eve\"] // The type we got: //    string[] const names1 = getNamesExactly ({ names: [ \"Alice\" , \"Bob\" , \"Eve\" ]}); // Correctly gets what we wanted: //    readonly [\"Alice\", \"Bob\", \"Eve\"] const names2 = getNamesExactly ({ names: [ \"Alice\" , \"Bob\" , \"Eve\" ]} as const );"
                },
                {
                    "type": "p",
                    "text": "This can be cumbersome and easy to forget.\nIn TypeScript 5.0, you can now add a const modifier to a type parameter declaration to cause const -like inference to be the default:"
                },
                {
                    "type": "code",
                    "code": "ts type HasNames = { names : readonly string [] }; function getNamesExactly < const T extends HasNames >( arg : T ): T [ \"names\" ] { //                       ^^^^^ return arg . names ; } // Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"] // Note: Didn't need to write 'as const' here const names = getNamesExactly ({ names: [ \"Alice\" , \"Bob\" , \"Eve\" ] });"
                },
                {
                    "type": "p",
                    "text": "Note that the const modifier doesn’t reject mutable values, and doesn’t require immutable constraints.\nUsing a mutable type constraint might give surprising results.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts declare function fnBad < const T extends string []>( args : T ): void ; // 'T' is still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' is not assignable to 'string[]' fnBad ([ \"a\" , \"b\" , \"c\" ]);"
                },
                {
                    "type": "p",
                    "text": "Here, the inferred candidate for T is readonly [\"a\", \"b\", \"c\"] , and a readonly array can’t be used where a mutable one is needed.\nIn this case, inference falls back to the constraint, the array is treated as string[] , and the call still proceeds successfully. A better definition of this function should use readonly string[] :"
                },
                {
                    "type": "code",
                    "code": "ts declare function fnGood < const T extends readonly string []>( args : T ): void ; // T is readonly [\"a\", \"b\", \"c\"] fnGood ([ \"a\" , \"b\" , \"c\" ]);"
                },
                {
                    "type": "p",
                    "text": "Similarly, remember to keep in mind that the const modifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn’t (or couldn’t) be modified with as const won’t see any change in behavior:"
                },
                {
                    "type": "code",
                    "code": "ts declare function fnGood < const T extends readonly string []>( args : T ): void ; const arr = [ \"a\" , \"b\" , \"c\" ]; // 'T' is still 'string[]'-- the 'const' modifier has no effect here fnGood ( arr );"
                },
                {
                    "type": "p",
                    "text": "See the pull request and the ( first and second second ) motivating issues for more details. When managing multiple projects, it can be helpful to have a “base” configuration file that other tsconfig.json files can extend from.\nThat’s why TypeScript supports an extends field for copying over fields from compilerOptions ."
                },
                {
                    "type": "code",
                    "code": "jsonc // packages/front-end/src/tsconfig.json { \"extends\" : \"../../../tsconfig.base.json\" , \"compilerOptions\" : { \"outDir\" : \"../lib\" , // ... } }"
                },
                {
                    "type": "p",
                    "text": "However, there are scenarios where you might want to extend from multiple configuration files.\nFor example, imagine using a TypeScript base configuration file shipped to npm .\nIf you want all your projects to also use the options from the @tsconfig/strictest package on npm, then there’s a simple solution: have tsconfig.base.json extend from @tsconfig/strictest :"
                },
                {
                    "type": "code",
                    "code": "jsonc // tsconfig.base.json { \"extends\" : \"@tsconfig/strictest/tsconfig.json\" , \"compilerOptions\" : { // ... } }"
                },
                {
                    "type": "p",
                    "text": "This works to a point.\nIf you have any projects that don’t want to use @tsconfig/strictest , they have to either manually disable the options, or create a separate version of tsconfig.base.json that doesn’t extend from @tsconfig/strictest . To give some more flexibility here, Typescript 5.0 now allows the extends field to take multiple entries.\nFor example, in this configuration file:"
                },
                {
                    "type": "code",
                    "code": "jsonc { \"extends\" : [ \"a\" , \"b\" , \"c\" ], \"compilerOptions\" : { // ... } }"
                },
                {
                    "type": "p",
                    "text": "Writing this is kind of like extending c directly, where c extends b , and b extends a .\nIf any fields “conflict”, the latter entry wins. So in the following example, both strictNullChecks and noImplicitAny are enabled in the final tsconfig.json ."
                },
                {
                    "type": "code",
                    "code": "jsonc // tsconfig1.json { \"compilerOptions\" : { \"strictNullChecks\" : true } } // tsconfig2.json { \"compilerOptions\" : { \"noImplicitAny\" : true } } // tsconfig.json { \"extends\" : [ \"./tsconfig1.json\" , \"./tsconfig2.json\" ], \"files\" : [ \"./index.ts\" ] }"
                },
                {
                    "type": "p",
                    "text": "As another example, we can rewrite our original example in the following way."
                },
                {
                    "type": "code",
                    "code": "jsonc // packages/front-end/src/tsconfig.json { \"extends\" : [ \"@tsconfig/strictest/tsconfig.json\" , \"../../../tsconfig.base.json\" ], \"compilerOptions\" : { \"outDir\" : \"../lib\" , // ... } }"
                },
                {
                    "type": "p",
                    "text": "For more details, read more on the original pull request . When TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type."
                },
                {
                    "type": "code",
                    "code": "ts enum E { Foo = 10 , Bar = 20 , }"
                },
                {
                    "type": "p",
                    "text": "The only thing special about E.Foo and E.Bar was that they were assignable to anything expecting the type E .\nOther than that, they were pretty much just number s."
                },
                {
                    "type": "code",
                    "code": "ts function takeValue ( e : E ) {} takeValue ( E . Foo ); // works takeValue ( 123 ); // error!"
                },
                {
                    "type": "p",
                    "text": "It wasn’t until TypeScript 2.0 introduced enum literal types that enums got a bit more special.\nEnum literal types gave each enum member its own type, and turned the enum itself into a union of each member type.\nThey also allowed us to refer to only a subset of the types of an enum, and to narrow away those types."
                },
                {
                    "type": "code",
                    "code": "ts // Color is like a union of Red | Orange | Yellow | Green | Blue | Violet enum Color { Red , Orange , Yellow , Green , Blue , /* Indigo, */ Violet } // Each enum member has its own type that we can refer to! type PrimaryColor = Color . Red | Color . Green | Color . Blue ; function isPrimaryColor ( c : Color ): c is PrimaryColor { // Narrowing literal types can catch bugs. // TypeScript will error here because // we'll end up comparing 'Color.Red' to 'Color.Green'. // We meant to use ||, but accidentally wrote &&. return c === Color . Red && c === Color . Green && c === Color . Blue ; }"
                },
                {
                    "type": "p",
                    "text": "One issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member.\nIn some cases it’s not possible to compute that value - for instance, an enum member could be initialized by a function call."
                },
                {
                    "type": "code",
                    "code": "ts enum E { Blah = Math . random () }"
                },
                {
                    "type": "p",
                    "text": "Whenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy.\nThat meant giving up all the advantages of unions and literal types. TypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member.\nThat means that all enums can now be narrowed and have their members referenced as types as well. For more details on this change, you can read the specifics on GitHub . TypeScript 4.7 introduced the node16 and nodenext options for its --module and --moduleResolution settings.\nThe intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js;\nhowever, this mode has many restrictions that other tools don’t really enforce. For example, in an ECMAScript module in Node.js, any relative import needs to include a file extension."
                },
                {
                    "type": "code",
                    "code": "js // entry.mjs import * as utils from \"./utils\" ; // ❌ wrong - we need to include the file extension. import * as utils from \"./utils.mjs\" ; // ✅ works"
                },
                {
                    "type": "p",
                    "text": "There are certain reasons for this in Node.js and the browser - it makes file lookups faster and works better for naive file servers.\nBut for many developers using tools like bundlers, the node16 / nodenext settings were cumbersome because bundlers don’t have most of these restrictions.\nIn some ways, the node resolution mode was better for anyone using a bundler. But in some ways, the original node resolution mode was already out of date.\nMost modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js.\nFor example, extensionless imports work just fine just like in CommonJS, but when looking through the export conditions of a package, they’ll prefer an import condition just like in an ECMAScript file. To model how bundlers work, TypeScript now introduces a new strategy: --moduleResolution bundler ."
                },
                {
                    "type": "code",
                    "code": "jsonc { \"compilerOptions\" : { \"target\" : \"esnext\" , \"moduleResolution\" : \"bundler\" } }"
                },
                {
                    "type": "p",
                    "text": "If you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new bundler option should be a good fit for you. On the other hand, if you’re writing a library that’s meant to be published on npm, using the bundler option can hide compatibility issues that may arise for your users who aren’t using a bundler.\nSo in these cases, using the node16 or nodenext resolution options is likely to be a better path. To read more on --moduleResolution bundler , take a look at the implementing pull request . JavaScript tooling may now model “hybrid” resolution rules, like in the bundler mode we described above.\nBecause tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration. --allowImportingTsExtensions allows TypeScript files to import each other with a TypeScript-specific extension like .ts , .mts , or .tsx . This flag is only allowed when --noEmit or --emitDeclarationOnly is enabled, since these import paths would not be resolvable at runtime in JavaScript output files.\nThe expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between .ts files work. --resolvePackageJsonExports forces TypeScript to consult the exports field of package.json files if it ever reads from a package in node_modules . This option defaults to true under the node16 , nodenext , and bundler options for --moduleResolution . --resolvePackageJsonImports forces TypeScript to consult the imports field of package.json files when performing a lookup that starts with # from a file whose ancestor directory contains a package.json . This option defaults to true under the node16 , nodenext , and bundler options for --moduleResolution . In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of {file basename}.d.{extension}.ts .\nFor example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:"
                },
                {
                    "type": "code",
                    "code": "css /* app.css */ .cookie-banner { display : none ; }"
                },
                {
                    "type": "code",
                    "code": "ts // app.d.css.ts declare const css : { cookieBanner : string ; }; export default css ;"
                },
                {
                    "type": "code",
                    "code": "ts // App.tsx import styles from \"./app.css\" ; styles . cookieBanner ; // string"
                },
                {
                    "type": "p",
                    "text": "By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it.\nBut if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new --allowArbitraryExtensions compiler option. Note that historically, a similar effect has often been achievable by adding a declaration file named app.css.d.ts instead of app.d.css.ts - however, this just worked through Node’s require resolution rules for CommonJS.\nStrictly speaking, the former is interpreted as a declaration file for a JavaScript file named app.css.js .\nBecause relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under --moduleResolution node16 or nodenext . For more information, read up the proposal for this feature and its corresponding pull request . --customConditions takes a list of additional conditions that should succeed when TypeScript resolves from an exports or imports field of a package.json .\nThese conditions are added to whatever existing conditions a resolver will use by default. For example, when this field is set in a tsconfig.json as so:"
                },
                {
                    "type": "code",
                    "code": "jsonc { \"compilerOptions\" : { \"target\" : \"es2022\" , \"moduleResolution\" : \"bundler\" , \"customConditions\" : [ \"my-condition\" ] } }"
                },
                {
                    "type": "p",
                    "text": "Any time an exports or imports field is referenced in package.json , TypeScript will consider conditions called my-condition . So when importing from a package with the following package.json"
                },
                {
                    "type": "code",
                    "code": "jsonc { // ... \"exports\" : { \".\" : { \"my-condition\" : \"./foo.mjs\" , \"node\" : \"./bar.mjs\" , \"import\" : \"./baz.mjs\" , \"require\" : \"./biz.mjs\" } } }"
                },
                {
                    "type": "p",
                    "text": "TypeScript will try to look for files corresponding to foo.mjs . This field is only valid under the node16 , nodenext , and bundler options for --moduleResolution By default, TypeScript does something called import elision .\nBasically, if you write something like"
                },
                {
                    "type": "code",
                    "code": "ts import { Car } from \"./car\" ; export function drive ( car : Car ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "TypeScript detects that you’re only using an import for types and drops the import entirely.\nYour output JavaScript might look something like this:"
                },
                {
                    "type": "code",
                    "code": "js export function drive ( car ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "Most of the time this is good, because if Car isn’t a value that’s exported from ./car , we’ll get a runtime error. But it does add a layer of complexity for certain edge cases.\nFor example, notice there’s no statement like import \"./car\"; - the import was dropped entirely.\nThat actually makes a difference for modules that have side-effects or not. TypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well.\nSo it’s not always clear whether code like the following"
                },
                {
                    "type": "code",
                    "code": "ts export { Car } from \"./car\" ;"
                },
                {
                    "type": "p",
                    "text": "should be preserved or dropped.\nIf Car is declared with something like a class , then it can be preserved in the resulting JavaScript file.\nBut if Car is only declared as a type alias or interface , then the JavaScript file shouldn’t export Car at all. While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can. The type modifier on imports and exports helps with these situations a bit.\nWe can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the type modifier."
                },
                {
                    "type": "code",
                    "code": "ts // This statement can be dropped entirely in JS output import type * as car from \"./car\" ; // The named import/export 'Car' can be dropped in JS output import { type Car } from \"./car\" ; export { type Car } from \"./car\" ;"
                },
                {
                    "type": "p",
                    "text": "type modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between type and plain imports and exports.\nSo TypeScript has the flag --importsNotUsedAsValues to make sure you use the type modifier, --preserveValueImports to prevent some module elision behavior, and --isolatedModules to make sure that your TypeScript code works across different compilers.\nUnfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior. TypeScript 5.0 introduces a new option called --verbatimModuleSyntax to simplify the situation.\nThe rules are much simpler - any imports or exports without a type modifier are left around.\nAnything that uses the type modifier is dropped entirely."
                },
                {
                    "type": "code",
                    "code": "ts // Erased away entirely. import type { A } from \"a\" ; // Rewritten to 'import { b } from \"bcd\";' import { b , type c , type d } from \"bcd\" ; // Rewritten to 'import {} from \"xyz\";' import { type xyz } from \"xyz\" ;"
                },
                {
                    "type": "p",
                    "text": "With this new option, what you see is what you get. That does have some implications when it comes to module interop though.\nUnder this flag, ECMAScript import s and export s won’t be rewritten to require calls when your settings or file extension implied a different module system.\nInstead, you’ll get an error.\nIf you need to emit code that uses require and module.exports , you’ll have to use TypeScript’s module syntax that predates ES2015:"
                },
                {
                    "type": "code",
                    "code": "ts import foo = require ( \"foo\" );"
                },
                {
                    "type": "code",
                    "code": "js const foo = require ( \"foo\" );"
                },
                {
                    "type": "code",
                    "code": "ts function foo () {} function bar () {} function baz () {} export = { foo , bar , baz };"
                },
                {
                    "type": "code",
                    "code": "js function foo () {} function bar () {} function baz () {} module . exports = { foo , bar , baz };"
                },
                {
                    "type": "p",
                    "text": "While this is a limitation, it does help make some issues more obvious.\nFor example, it’s very common to forget to set the type field in package.json under --module node16 .\nAs a result, developers would start writing CommonJS modules instead of ES modules without realizing it, giving surprising lookup rules and JavaScript output.\nThis new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different. Because --verbatimModuleSyntax provides a more consistent story than --importsNotUsedAsValues and --preserveValueImports , those two existing flags are being deprecated in its favor. For more details, read up on [the original pull request] https://github.com/microsoft/TypeScript/pull/52203 and its proposal issue . When TypeScript 3.8 introduced type-only imports, the new syntax wasn’t allowed on export * from \"module\" or export * as ns from \"module\" re-exports. TypeScript 5.0 adds support for both of these forms:"
                },
                {
                    "type": "code",
                    "code": "ts // models/vehicles.ts export class Spaceship { // ... } // models/index.ts export type * as vehicles from \"./vehicles\" ; // main.ts import { vehicles } from \"./models\" ; function takeASpaceship ( s : vehicles . Spaceship ) { // ✅ ok - `vehicles` only used in a type position } function makeASpaceship () { return new vehicles . Spaceship (); //         ^^^^^^^^ // 'vehicles' cannot be used as a value because it was exported using 'export type'. }"
                },
                {
                    "type": "p",
                    "text": "You can read more about the implementation here . TypeScript 4.9 introduced the satisfies operator.\nIt made sure that the type of an expression was compatible, without affecting the type itself.\nFor example, let’s take the following code:"
                },
                {
                    "type": "code",
                    "code": "ts interface CompilerOptions { strict ?: boolean ; outDir ?: string ; // ... } interface ConfigSettings { compilerOptions ?: CompilerOptions ; extends ?: string | string []; // ... } let myConfigSettings = { compilerOptions: { strict: true , outDir: \"../lib\" , // ... }, extends: [ \"@tsconfig/strictest/tsconfig.json\" , \"../../../tsconfig.base.json\" ], } satisfies ConfigSettings ;"
                },
                {
                    "type": "p",
                    "text": "Here, TypeScript knows that myConfigSettings.extends was declared with an array - because while satisfies validated the type of our object, it didn’t bluntly change it to CompilerOptions and lose information.\nSo if we want to map over extends , that’s fine."
                },
                {
                    "type": "code",
                    "code": "ts declare function resolveConfig ( configPath : string ): CompilerOptions ; let inheritedConfigs = myConfigSettings . extends . map ( resolveConfig );"
                },
                {
                    "type": "p",
                    "text": "This was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations.\nThat’s why TypeScript 5.0 is supporting a new JSDoc tag called @satisfies that does exactly the same thing. /** @satisfies */ can catch type mismatches:"
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** * @typedef CompilerOptions * @prop {boolean} [strict] * @prop {string} [outDir] */ /** * @satisfies {CompilerOptions} */ let myCompilerOptions = { outdir: \"../lib\" , //  ~~~~~~ oops! we meant outDir };"
                },
                {
                    "type": "p",
                    "text": "But it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** * @typedef CompilerOptions * @prop {boolean} [strict] * @prop {string} [outDir] */ /** * @typedef ConfigSettings * @prop {CompilerOptions} [compilerOptions] * @prop {string | string[]} [extends] */ /** * @satisfies {ConfigSettings} */ let myConfigSettings = { compilerOptions: { strict: true , outDir: \"../lib\" , }, extends: [ \"@tsconfig/strictest/tsconfig.json\" , \"../../../tsconfig.base.json\" ], }; let inheritedConfigs = myConfigSettings . extends . map ( resolveConfig );"
                },
                {
                    "type": "p",
                    "text": "/** @satisfies */ can also be used inline on any parenthesized expression.\nWe could have written myCompilerOptions like this:"
                },
                {
                    "type": "code",
                    "code": "ts let myConfigSettings = /** @satisfies {ConfigSettings} */ ({ compilerOptions: { strict: true , outDir: \"../lib\" , }, extends: [ \"@tsconfig/strictest/tsconfig.json\" , \"../../../tsconfig.base.json\" ], });"
                },
                {
                    "type": "p",
                    "text": "Why?\nWell, it usually makes more sense when you’re deeper in some other code, like a function call."
                },
                {
                    "type": "code",
                    "code": "js compileCode ( /** @satisfies {CompilerOptions} */ ({ // ... }));"
                },
                {
                    "type": "p",
                    "text": "This feature was provided thanks to Oleksandr Tarasiuk ! In TypeScript, you can specify overloads for a function.\nOverloads give us a way to say that a function can be called with different arguments, and possibly return different results.\nThey can restrict how callers can actually use our functions, and refine what results they’ll get back."
                },
                {
                    "type": "code",
                    "code": "ts // Our overloads: function printValue ( str : string ): void ; function printValue ( num : number , maxFractionDigits ?: number ): void ; // Our implementation: function printValue ( value : string | number , maximumFractionDigits ?: number ) { if ( typeof value === \"number\" ) { const formatter = Intl . NumberFormat ( \"en-US\" , { maximumFractionDigits , }); value = formatter . format ( value ); } console . log ( value ); }"
                },
                {
                    "type": "p",
                    "text": "Here, we’ve said that printValue takes either a string or a number as its first argument.\nIf it takes a number , it can take a second argument to determine how many fractional digits we can print. TypeScript 5.0 now allows JSDoc to declare overloads with a new @overload tag.\nEach JSDoc comment with an @overload tag is treated as a distinct overload for the following function declaration."
                },
                {
                    "type": "code",
                    "code": "js // @ts-check /** * @overload * @param {string} value * @return {void} */ /** * @overload * @param {number} value * @param {number} [maximumFractionDigits] * @return {void} */ /** * @param {string | number} value * @param {number} [maximumFractionDigits] */ function printValue ( value , maximumFractionDigits ) { if ( typeof value === \"number\" ) { const formatter = Intl . NumberFormat ( \"en-US\" , { maximumFractionDigits , }); value = formatter . format ( value ); } console . log ( value ); }"
                },
                {
                    "type": "p",
                    "text": "Now regardless of whether we’re writing in a TypeScript or JavaScript file, TypeScript can let us know if we’ve called our functions incorrectly."
                },
                {
                    "type": "code",
                    "code": "ts // all allowed printValue ( \"hello!\" ); printValue ( 123.45 ); printValue ( 123.45 , 2 ); printValue ( \"hello!\" , 123 ); // error!"
                },
                {
                    "type": "p",
                    "text": "This new tag was implemented thanks to Tomasz Lenarcik . TypeScript now allows the following flags to be passed under --build mode"
                },
                {
                    "type": "list",
                    "items": [
                        "--declaration",
                        "--emitDeclarationOnly",
                        "--declarationMap",
                        "--sourceMap",
                        "--inlineSourceMap"
                    ]
                },
                {
                    "type": "p",
                    "text": "This makes it way easier to customize certain parts of a build where you might have different development and production builds. For example, a development build of a library might not need to produce declaration files, but a production build would.\nA project can configure declaration emit to be off by default and simply be built with"
                },
                {
                    "type": "code",
                    "code": "sh tsc --build -p ./my-project-dir"
                },
                {
                    "type": "p",
                    "text": "Once you’re done iterating in the inner loop, a “production” build can just pass the --declaration flag."
                },
                {
                    "type": "code",
                    "code": "sh tsc --build -p ./my-project-dir --declaration"
                },
                {
                    "type": "p",
                    "text": "More information on this change is available here . In editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports.\nOften though, there can be different interpretations of when a list is “sorted”. For example, is the following import list sorted?"
                },
                {
                    "type": "code",
                    "code": "ts import { Toggle , freeze , toBoolean , } from \"./utils\" ;"
                },
                {
                    "type": "p",
                    "text": "The answer might surprisingly be “it depends”.\nIf we don’t care about case-sensitivity, then this list is clearly not sorted.\nThe letter f comes before both t and T . But in most programming languages, sorting defaults to comparing the byte values of strings.\nThe way JavaScript compares strings means that \"Toggle\" always comes before \"freeze\" because according to the ASCII character encoding , uppercase letters come before lowercase.\nSo from that perspective, the import list is sorted. TypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort.\nThis could be a point of frustration for developers who preferred a case- insensitive ordering, or who used tools like ESLint which require case-insensitive ordering by default. TypeScript now detects case sensitivity by default.\nThis means that TypeScript and tools like ESLint typically won’t “fight” each other over how to best sort imports. Our team has also been experimenting with further sorting strategies which you can read about here .\nThese options may eventually be configurable by editors.\nFor now, they are still unstable and experimental, and you can opt into them in VS Code today by using the typescript.unstable entry in your JSON options.\nBelow are all of the options you can try out (set to their defaults):"
                },
                {
                    "type": "code",
                    "code": "jsonc { \"typescript.unstable\" : { // Should sorting be case-sensitive? Can be: // - true // - false // - \"auto\" (auto-detect) \"organizeImportsIgnoreCase\" : \"auto\" , // Should sorting be \"ordinal\" and use code points or consider Unicode rules? Can be: // - \"ordinal\" // - \"unicode\" \"organizeImportsCollation\" : \"ordinal\" , // Under `\"organizeImportsCollation\": \"unicode\"`, // what is the current locale? Can be: // - [any other locale code] // - \"auto\" (use the editor's locale) \"organizeImportsLocale\" : \"en\" , // Under `\"organizeImportsCollation\": \"unicode\"`, // should upper-case letters or lower-case letters come first? Can be: // - false (locale-specific) // - \"upper\" // - \"lower\" \"organizeImportsCaseFirst\" : false , // Under `\"organizeImportsCollation\": \"unicode\"`, // do runs of numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? Can be: // - true // - false \"organizeImportsNumericCollation\" : true , // Under `\"organizeImportsCollation\": \"unicode\"`, // do letters with accent marks/diacritics get sorted distinctly // from their \"base\" letter (i.e. is é different from e)? Can be // - true // - false \"organizeImportsAccentCollation\" : true }, \"javascript.unstable\" : { // same options valid here... }, }"
                },
                {
                    "type": "p",
                    "text": "You can read more details on the original work for auto-detecting and specifying case-insensitivity , followed by the the broader set of options . When writing a switch statement, TypeScript now detects when the value being checked has a literal type.\nIf so, it will offer a completion that scaffolds out each uncovered case . You can see specifics of the implementation on GitHub . TypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations.\nWhat these all mean is that your entire experience should be faster - not just running TypeScript, but even installing it. Here are a few interesting wins in speed and size that we’ve been able to capture relative to TypeScript 4.9. How?\nThere are a few notable improvements we’d like give more details on in the future.\nBut we won’t make you wait for that blog post. First off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting.\nUsing this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9’s 63.8 MB package size.\nIt also brought us a notable speed-up through direct function calls. TypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well.\nThis reduced polymorphic and megamorphic use sites, while offsetting most of the necessary memory consumption that was necessary for uniform shapes. We’ve also performed some caching when serializing information to strings.\nType display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive.\nTypeScript now caches some commonly used machinery to reuse across these operations. Another notable change we made that improved our parser was leveraging var to occasionally side-step the cost of using let and const across closures.\nThis improved some of our parsing performance. Overall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%.\nOf course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today! For more information, see some of our notable optimizations:"
                },
                {
                    "type": "list",
                    "items": [
                        "Migrate to Modules",
                        "Node Monomorphization",
                        "Symbol Monomorphization",
                        "Identifier Size Reduction",
                        "Printer Caching",
                        "Limited Usage of var"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript now targets ECMAScript 2018.\nFor Node users, that means a minimum version requirement of at least Node.js 10 and later. Changes to how types for the DOM are generated might have an impact on existing code.\nNotably, certain properties have been converted from number to numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces. In TypeScript 5.0, we moved to modules, removed some unnecessary interfaces, and made some correctness improvements.\nFor more details on what’s changed, see our API Breaking Changes page. Certain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:"
                },
                {
                    "type": "code",
                    "code": "ts function func ( ns : number | string ) { return ns * 4 ; // Error, possible implicit coercion }"
                },
                {
                    "type": "p",
                    "text": "In 5.0, this will also be applied to the relational operators > , < , <= , and >= :"
                },
                {
                    "type": "code",
                    "code": "ts function func ( ns : number | string ) { return ns > 4 ; // Now also an error }"
                },
                {
                    "type": "p",
                    "text": "To allow this if desired, you can explicitly coerce the operand to a number using + :"
                },
                {
                    "type": "code",
                    "code": "ts function func ( ns : number | string ) { return + ns > 4 ; // OK }"
                },
                {
                    "type": "p",
                    "text": "This correctness improvement was contributed courtesy of Mateusz Burzyński . TypeScript has had some long-standing oddities around enum s ever since its first release.\nIn 5.0, we’re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of enum s you can declare. There are two main new errors you might see as part of this.\nThe first is that assigning an out-of-domain literal to an enum type will now error as one might expect:"
                },
                {
                    "type": "code",
                    "code": "ts enum SomeEvenDigit { Zero = 0 , Two = 2 , Four = 4 } // Now correctly an error let m : SomeEvenDigit = 1 ;"
                },
                {
                    "type": "p",
                    "text": "The other is that declaration of certain kinds of indirected mixed string/number enum forms would, incorrectly, create an all-number enum :"
                },
                {
                    "type": "code",
                    "code": "ts enum Letters { A = \"a\" } enum Numbers { one = 1 , two = Letters . A } // Now correctly an error const t : number = Numbers . two ;"
                },
                {
                    "type": "p",
                    "text": "You can see more details in relevant change . TypeScript 5.0 makes type-checking more accurate for decorators under --experimentalDecorators .\nOne place where this becomes apparent is when using a decorator on a constructor parameter."
                },
                {
                    "type": "code",
                    "code": "ts export declare const inject : ( entity : any ) => ( target : object , key : string | symbol , index ?: number ) => void ; export class Foo {} export class C { constructor (@ inject ( Foo ) private x : any ) { } }"
                },
                {
                    "type": "p",
                    "text": "This call will fail because key expects a string | symbol , but constructor parameters receive a key of undefined .\nThe correct fix is to change the type of key within inject .\nA reasonable workaround if you’re using a library that can’t be upgraded is is to wrap inject in a more type-safe decorator function, and use a type-assertion on key . For more details, see this issue . In TypeScript 5.0, we’ve deprecated the following settings and setting values:"
                },
                {
                    "type": "list",
                    "items": [
                        "--target: ES3",
                        "--out",
                        "--noImplicitUseStrict",
                        "--keyofStringsOnly",
                        "--suppressExcessPropertyErrors",
                        "--suppressImplicitAnyIndexErrors",
                        "--noStrictGenericChecks",
                        "--charset",
                        "--importsNotUsedAsValues",
                        "--preserveValueImports",
                        "prepend in project references"
                    ]
                },
                {
                    "type": "p",
                    "text": "These configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings.\nIn TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify \"ignoreDeprecations\": \"5.0\" to silence those warnings.\nWe’ll also shortly be releasing a 4.9 patch to allow specifying ignoreDeprecations to allow for smoother upgrades.\nAside from deprecations, we’ve changed some settings to better improve cross-platform behavior in TypeScript. --newLine , which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified.\nWe think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is LF .\nThe old OS-specific inference behavior is no longer available. --forceConsistentCasingInFileNames , which ensured that all references to the same file name in a project agreed in casing, now defaults to true .\nThis can help catch differences issues with code written on case-insensitive file systems. You can leave feedback and view more information on the tracking issue for 5.0 deprecations The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html",
            "title": "TypeScript: Documentation - TypeScript 5.1",
            "content": [
                {
                    "type": "p",
                    "text": "In JavaScript, if a function finishes running without hitting a return , it returns the value undefined ."
                },
                {
                    "type": "code",
                    "code": "ts function foo () { // no return } // x = undefined let x = foo ();"
                },
                {
                    "type": "p",
                    "text": "However, in previous versions of TypeScript, the only functions that could have absolutely no return statements were void - and any -returning functions.\nThat meant that even if you explicitly said “this function returns undefined ” you were forced to have at least one return statement."
                },
                {
                    "type": "code",
                    "code": "ts // ✅ fine - we inferred that 'f1' returns 'void' function f1 () { // no returns } // ✅ fine - 'void' doesn't need a return statement function f2 (): void { // no returns } // ✅ fine - 'any' doesn't need a return statement function f3 (): any { // no returns } // ❌ error! // A function whose declared type is neither 'void' nor 'any' must return a value. function f4 (): undefined { // no returns }"
                },
                {
                    "type": "p",
                    "text": "This could be a pain if some API expected a function returning undefined - you would need to have either at least one explicit return of undefined or a return statement and an explicit annotation."
                },
                {
                    "type": "code",
                    "code": "ts declare function takesFunction ( f : () => undefined ): undefined ; // ❌ error! // Argument of type '() => void' is not assignable to parameter of type '() => undefined'. takesFunction (() => { // no returns }); // ❌ error! // A function whose declared type is neither 'void' nor 'any' must return a value. takesFunction ((): undefined => { // no returns }); // ❌ error! // Argument of type '() => void' is not assignable to parameter of type '() => undefined'. takesFunction (() => { return ; }); // ✅ works takesFunction (() => { return undefined ; }); // ✅ works takesFunction ((): undefined => { return ; });"
                },
                {
                    "type": "p",
                    "text": "This behavior was frustrating and confusing, especially when calling functions outside of one’s control.\nUnderstanding the interplay between inferring void over undefined , whether an undefined -returning function needs a return statement, etc. seems like a distraction. First, TypeScript 5.1 now allows undefined -returning functions to have no return statement."
                },
                {
                    "type": "code",
                    "code": "ts // ✅ Works in TypeScript 5.1! function f4 (): undefined { // no returns } // ✅ Works in TypeScript 5.1! takesFunction ((): undefined => { // no returns });"
                },
                {
                    "type": "p",
                    "text": "Second, if a function has no return expressions and is being passed to something expecting a function that returns undefined , TypeScript infers undefined for that function’s return type."
                },
                {
                    "type": "code",
                    "code": "ts // ✅ Works in TypeScript 5.1! takesFunction ( function f () { //                 ^ return type is undefined // no returns }); // ✅ Works in TypeScript 5.1! takesFunction ( function f () { //                 ^ return type is undefined return ; });"
                },
                {
                    "type": "p",
                    "text": "To address another similar pain-point, under TypeScript’s --noImplicitReturns option, functions returning only undefined now have a similar exception to void , in that not every single code path must end in an explicit return ."
                },
                {
                    "type": "code",
                    "code": "ts // ✅ Works in TypeScript 5.1 under '--noImplicitReturns'! function f (): undefined { if ( Math . random ()) { // do some stuff... return ; } }"
                },
                {
                    "type": "p",
                    "text": "For more information, you can read up on the original issue and the implementing pull request . TypeScript 4.3 made it possible to say that a get and set accessor pair might specify two different types."
                },
                {
                    "type": "code",
                    "code": "ts interface Serializer { set value ( v : string | number | boolean ); get value (): string ; } declare let box : Serializer ; // Allows writing a 'boolean' box . value = true ; // Comes out as a 'string' console . log ( box . value . toUpperCase ());"
                },
                {
                    "type": "p",
                    "text": "Initially we required that the get type had to be a subtype of the set type.\nThis meant that writing"
                },
                {
                    "type": "code",
                    "code": "ts box . value = box . value ;"
                },
                {
                    "type": "p",
                    "text": "However, there are plenty of existing and proposed APIs that have completely unrelated types between their getters and setters.\nFor example, consider one of the most common examples - the style property in the DOM and CSSStyleRule API.\nEvery style rule has a style property that is a CSSStyleDeclaration ;\nhowever, if you try to write to that property, it will only work correctly with a string! TypeScript 5.1 now allows completely unrelated types for get and set accessor properties, provided that they have explicit type annotations.\nAnd while this version of TypeScript does not yet change the types for these built-in interfaces, CSSStyleRule can now be defined in the following way:"
                },
                {
                    "type": "code",
                    "code": "ts interface CSSStyleRule { // ... /** Always reads as a `CSSStyleDeclaration` */ get style (): CSSStyleDeclaration ; /** Can only write a `string` here. */ set style ( newValue : string ); // ... }"
                },
                {
                    "type": "p",
                    "text": "This also allows other patterns like requiring set accessors to accept only “valid” data, but specifying that get accessors may return undefined if some underlying state hasn’t been initialized yet."
                },
                {
                    "type": "code",
                    "code": "ts class SafeBox { #value : string | undefined ; // Only accepts strings! set value ( newValue : string ) { } // Must check for 'undefined'! get value (): string | undefined { return this . #value ; } }"
                },
                {
                    "type": "p",
                    "text": "In fact, this is similar to how optional properties are checked under --exactOptionalProperties . You can read up more on the implementing pull request . One pain point TypeScript had with JSX was its requirements on the type of every JSX element’s tag. For context, a JSX element is either of the following:"
                },
                {
                    "type": "code",
                    "code": "tsx // A self-closing JSX tag < Foo /> // A regular element with an opening/closing tag < Bar ></ Bar >"
                },
                {
                    "type": "p",
                    "text": "When type-checking <Foo /> or <Bar></Bar> , TypeScript always looks up a namespace called JSX and fetches a type out of it called Element - or more directly, it looks up JSX.Element . But to check whether Foo or Bar themselves were valid to use as tag names, TypeScript would roughly just grab the types returned or constructed by Foo or Bar and check for compatibility with JSX.Element (or another type called JSX.ElementClass if the type is constructable). The limitations here meant that components could not be used if they returned or “rendered” a more broad type than just JSX.Element .\nFor example, a JSX library might be fine with a component returning string s or Promise s. As a more concrete example, React is considering adding limited support for components that return Promise s , but existing versions of TypeScript cannot express that without someone drastically loosening the type of JSX.Element ."
                },
                {
                    "type": "code",
                    "code": "tsx import * as React from \"react\" ; async function Foo () { return <div></div> ; } let element = < Foo /> ; //             ~~~ // 'Foo' cannot be used as a JSX component. //   Its return type 'Promise<Element>' is not a valid JSX element."
                },
                {
                    "type": "p",
                    "text": "To provide libraries with a way to express this, TypeScript 5.1 now looks up a type called JSX.ElementType . ElementType specifies precisely what is valid to use as a tag in a JSX element.\nSo it might be typed today as something like"
                },
                {
                    "type": "code",
                    "code": "tsx namespace JSX { export type ElementType = // All the valid lowercase tags keyof IntrinsicAttributes // Function components ( props : any ) => Element // Class components new ( props : any ) => ElementClass ; export interface IntrinsicAttributes extends /*...*/ {} export type Element = /*...*/ ; export type ElementClass = /*...*/ ; }"
                },
                {
                    "type": "p",
                    "text": "We’d like to extend our thanks to Sebastian Silbermann who contributed this change ! TypeScript now supports namespaced attribute names when using JSX."
                },
                {
                    "type": "code",
                    "code": "tsx import * as React from \"react\" ; // Both of these are equivalent: const x = < Foo a : b = \"hello\" /> ; const y = < Foo a : b = \"hello\" /> ; interface FooProps { \"a:b\" : string ; } function Foo ( props : FooProps ) { return <div> { props [ \"a:b\" ] } </div> ; }"
                },
                {
                    "type": "p",
                    "text": "Namespaced tag names are looked up in a similar way on JSX.IntrinsicAttributes when the first segment of the name is a lowercase name."
                },
                {
                    "type": "code",
                    "code": "tsx // In some library's code or in an augmentation of that library: namespace JSX { interface IntrinsicElements { [ \"a:b\" ]: { prop : string }; } } // In our code: let x = <a : b prop = \"hello!\" /> ;"
                },
                {
                    "type": "p",
                    "text": "This contribution was provided thanks to Oleksandr Tarasiuk . When TypeScript’s specified module lookup strategy is unable to resolve a path, it will now resolve packages relative to the specified typeRoots . See this pull request for more details. In addition to moving declarations to new files, TypeScript now ships a preview feature for moving declarations to existing files as well.\nYou can try this functionality out in a recent version of Visual Studio Code. Keep in mind that this feature is currently in preview, and we are seeking further feedback on it. TypeScript now supports linked editing for JSX tag names.\nLinked editing (occasionally called “mirrored cursors”) allows an editor to edit multiple locations at the same time automatically. This new feature should work in both TypeScript and JavaScript files, and can be enabled in Visual Studio Code Insiders.\nIn Visual Studio Code, you can either edit the Editor: Linked Editing option in the Settings UI: or configure editor.linkedEditing in your JSON settings file:"
                },
                {
                    "type": "code",
                    "code": "jsonc { // ... \"editor.linkedEditing\" : true , }"
                },
                {
                    "type": "p",
                    "text": "This feature will also be supported by Visual Studio 17.7 Preview 1. You can take a look at our implementation of linked editing here! TypeScript now provides snippet completions when typing out a @param tag in both TypeScript and JavaScript files.\nThis can help cut down on some typing and jumping around text as you document your code or add JSDoc types in JavaScript. You can check out how this new feature was implemented on GitHub . TypeScript 5.1 now avoids performing type instantiation within object types that are known not to contain references to outer type parameters.\nThis has the potential to cut down on many unnecessary computations, and reduced the type-checking time of material-ui’s docs directory by over 50%. You can see the changes involved for this change on GitHub . When checking if a source type is part of a union type, TypeScript will first do a fast look-up using an internal type identifier for that source.\nIf that look-up fails, then TypeScript checks for compatibility against every type within the union. When relating a literal type to a union of purely literal types, TypeScript can now avoid that full walk against every other type in the union.\nThis assumption is safe because TypeScript always interns/caches literal types - though there are some edge cases to handle relating to “fresh” literal types. This optimization was able to reduce the type-checking time of the code in this issue from about 45 seconds to about 0.4 seconds. When older versions of TypeScript parsed out a JSDoc comment, they would use the scanner/tokenizer to break the comment into fine-grained tokens and piece the contents back together.\nThis could be helpful for normalizing comment text, so that multiple spaces would just collapse into one;\nbut it was extremely “chatty” and meant the parser and scanner would jump back and forth very often, adding overhead to JSDoc parsing. TypeScript 5.1 has moved more logic around breaking down JSDoc comments into the scanner/tokenizer.\nThe scanner now returns larger chunks of content directly to the parser to do as it needs. These changes have brought down the parse time of several 10Mb mostly-prose-comment JavaScript files by about half.\nFor a more realistic example, our performance suite’s snapshot of xstate dropped about 300ms of parse time, making it faster to load and analyze. TypeScript 5.1 now ships JavaScript functionality that was introduced in ECMAScript 2020.\nAs a result, at minimum TypeScript must be run in a reasonably modern runtime.\nFor most users, this means TypeScript now only runs on Node.js 14.17 and later. If you try running TypeScript 5.1 under an older version of Node.js such as Node 10 or 12, you may see an error like the following from running either tsc.js or tsserver.js :"
                },
                {
                    "type": "code",
                    "code": "node_modules/typescript/lib/tsserver.js:2406 for (let i = startIndex ?? 0; i < array.length; i++) { ^ SyntaxError: Unexpected token '?' at wrapSafe (internal/modules/cjs/loader.js:915:16) at Module._compile (internal/modules/cjs/loader.js:963:27) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10) at Module.load (internal/modules/cjs/loader.js:863:32) at Function.Module._load (internal/modules/cjs/loader.js:708:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12) at internal/main/run_main_module.js:17:47"
                },
                {
                    "type": "p",
                    "text": "Additionally, if you try installing TypeScript you’ll get something like the following error messages from npm:"
                },
                {
                    "type": "code",
                    "code": "npm WARN EBADENGINE Unsupported engine { npm WARN EBADENGINE   package: 'typescript@5.1.1-rc', npm WARN EBADENGINE   required: { node: '>=14.17' }, npm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' } npm WARN EBADENGINE }"
                },
                {
                    "type": "code",
                    "code": "error typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\" error Found incompatible module."
                },
                {
                    "type": "p",
                    "text": "See more information around this change here . Previously, when the typeRoots option was specified in a tsconfig.json but resolution to any typeRoots directories had failed, TypeScript would still continue walking up parent directories, trying to resolve packages within each parent’s node_modules/@types folder. This behavior could prompt excessive look-ups and has been disabled in TypeScript 5.1.\nAs a result, you may begin to see errors like the following based on entries in your tsconfig.json ’s types option or /// <reference > directives"
                },
                {
                    "type": "code",
                    "code": "error TS2688: Cannot find type definition file for 'node'. error TS2688: Cannot find type definition file for 'mocha'. error TS2688: Cannot find type definition file for 'jasmine'. error TS2688: Cannot find type definition file for 'chai-http'. error TS2688: Cannot find type definition file for 'webpack-env\"'."
                },
                {
                    "type": "p",
                    "text": "The solution is typically to add specific entries for node_modules/@types to your typeRoots :"
                },
                {
                    "type": "code",
                    "code": "jsonc { \"compilerOptions\" : { \"types\" : [ \"node\" , \"mocha\" ], \"typeRoots\" : [ // Keep whatever you had around before. \"./some-custom-types/\" , // You might need your local 'node_modules/@types'. \"./node_modules/@types\" , // You might also need to specify a shared 'node_modules/@types' // if you're using a \"monorepo\" layout. \"../../node_modules/@types\" , ] } }"
                },
                {
                    "type": "p",
                    "text": "More information is available on the original change on our issue tracker . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html",
            "title": "TypeScript: Documentation - TypeScript 5.2",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript 5.2 adds support for the upcoming Explicit Resource Management feature in ECMAScript.\nLet’s explore some of the motivations and understand what the feature brings us. It’s common to need to do some sort of “clean-up” after creating an object.\nFor example, you might need to close network connections, delete temporary files, or just free up some memory. Let’s imagine a function that creates a temporary file, reads and writes to it for various operations, and then closes and deletes it."
                },
                {
                    "type": "code",
                    "code": "ts import * as fs from \"fs\" ; export function doSomeWork () { const path = \".some_temp_file\" ; const file = fs . openSync ( path , \"w+\" ); // use file... // Close the file and delete it. fs . closeSync ( file ); fs . unlinkSync ( path ); }"
                },
                {
                    "type": "p",
                    "text": "This is fine, but what happens if we need to perform an early exit?"
                },
                {
                    "type": "code",
                    "code": "ts export function doSomeWork () { const path = \".some_temp_file\" ; const file = fs . openSync ( path , \"w+\" ); // use file... if ( someCondition ()) { // do some more work... // Close the file and delete it. fs . closeSync ( file ); fs . unlinkSync ( path ); return ; } // Close the file and delete it. fs . closeSync ( file ); fs . unlinkSync ( path ); }"
                },
                {
                    "type": "p",
                    "text": "We’re starting to see some duplication of clean-up which can be easy to forget.\nWe’re also not guaranteed to close and delete the file if an error gets thrown.\nThis could be solved by wrapping this all in a try / finally block."
                },
                {
                    "type": "code",
                    "code": "ts export function doSomeWork () { const path = \".some_temp_file\" ; const file = fs . openSync ( path , \"w+\" ); try { // use file... if ( someCondition ()) { // do some more work... return ; } } finally { // Close the file and delete it. fs . closeSync ( file ); fs . unlinkSync ( path ); } }"
                },
                {
                    "type": "p",
                    "text": "While this is more robust, it’s added quite a bit of “noise” to our code.\nThere are also other foot-guns we can run into if we start adding more clean-up logic to our finally block — for example, exceptions preventing other resources from being disposed.\nThis is what the explicit resource management proposal aims to solve.\nThe key idea of the proposal is to support resource disposal — this clean-up work we’re trying to deal with — as a first class idea in JavaScript. This starts by adding a new built-in symbol called Symbol.dispose , and we can create objects with methods named by Symbol.dispose .\nFor convenience, TypeScript defines a new global type called Disposable which describes these."
                },
                {
                    "type": "code",
                    "code": "ts class TempFile implements Disposable { #path : string ; #handle : number ; constructor ( path : string ) { this . #path = path ; this . #handle = fs . openSync ( path , \"w+\" ); } // other methods [ Symbol . dispose ]() { // Close the file and delete it. fs . closeSync ( this . #handle ); fs . unlinkSync ( this . #path ); } }"
                },
                {
                    "type": "p",
                    "text": "Later on we can call those methods."
                },
                {
                    "type": "code",
                    "code": "ts export function doSomeWork () { const file = new TempFile ( \".some_temp_file\" ); try { // ... } finally { file [ Symbol . dispose ](); } }"
                },
                {
                    "type": "p",
                    "text": "Moving the clean-up logic to TempFile itself doesn’t buy us much;\nwe’ve basically just moved all the clean-up work from the finally block into a method, and that’s always been possible.\nBut having a well-known “name” for this method means that JavaScript can build other features on top of it. That brings us to the first star of the feature: using declarations! using is a new keyword that lets us declare new fixed bindings, kind of like const .\nThe key difference is that variables declared with using get their Symbol.dispose method called at the end of the scope! So we could simply have written our code like this:"
                },
                {
                    "type": "code",
                    "code": "ts export function doSomeWork () { using file = new TempFile ( \".some_temp_file\" ); // use file... if ( someCondition ()) { // do some more work... return ; } }"
                },
                {
                    "type": "p",
                    "text": "Check it out — no try / finally blocks!\nAt least, none that we see.\nFunctionally, that’s exactly what using declarations will do for us, but we don’t have to deal with that. You might be familiar with using declarations in C# , with statements in Python , or try -with-resource declarations in Java .\nThese are all similar to JavaScript’s new using keyword, and provide a similar explicit way to perform a “tear-down” of an object at the end of a scope. using declarations do this clean-up at the very end of their containing scope or right before an “early return” like a return or a throw n error.\nThey also dispose in a first-in-last-out order like a stack."
                },
                {
                    "type": "code",
                    "code": "ts function loggy ( id : string ): Disposable { console . log ( `Creating ${ id } ` ); return { [ Symbol . dispose ]() { console . log ( `Disposing ${ id } ` ); } } } function func () { using a = loggy ( \"a\" ); using b = loggy ( \"b\" ); { using c = loggy ( \"c\" ); using d = loggy ( \"d\" ); } using e = loggy ( \"e\" ); return ; // Unreachable. // Never created, never disposed. using f = loggy ( \"f\" ); } func (); // Creating a // Creating b // Creating c // Creating d // Disposing d // Disposing c // Creating e // Disposing e // Disposing b // Disposing a"
                },
                {
                    "type": "p",
                    "text": "using declarations are supposed to be resilient to exceptions;\nif an error is thrown, it’s rethrown after disposal.\nOn the other hand, the body of your function might execute as expected, but the Symbol.dispose might throw.\nIn that case, that exception is rethrown as well. But what happens if both the logic before and during disposal throws an error?\nFor those cases, SuppressedError has been introduced as a new subtype of Error .\nIt features a suppressed property that holds the last-thrown error, and an error property for the most-recently thrown error."
                },
                {
                    "type": "code",
                    "code": "ts class ErrorA extends Error { name = \"ErrorA\" ; } class ErrorB extends Error { name = \"ErrorB\" ; } function throwy ( id : string ) { return { [ Symbol . dispose ]() { throw new ErrorA ( `Error from ${ id } ` ); } }; } function func () { using a = throwy ( \"a\" ); throw new ErrorB ( \"oops!\" ) } try { func (); } catch ( e : any ) { console . log ( e . name ); // SuppressedError console . log ( e . message ); // An error was suppressed during disposal. console . log ( e . error . name ); // ErrorA console . log ( e . error . message ); // Error from a console . log ( e . suppressed . name ); // ErrorB console . log ( e . suppressed . message ); // oops! }"
                },
                {
                    "type": "p",
                    "text": "You might have noticed that we’re using synchronous methods in these examples.\nHowever, lots of resource disposal involves asynchronous operations, and we need to wait for those to complete before we continue running any other code. That’s why there is also a new Symbol.asyncDispose , and it brings us to the next star of the show — await using declarations.\nThese are similar to using declarations, but the key is that they look up whose disposal must be await ed.\nThey use a different method named by Symbol.asyncDispose , though they can operate on anything with a Symbol.dispose as well.\nFor convenience, TypeScript also introduces a global type called AsyncDisposable that describes any object with an asynchronous dispose method."
                },
                {
                    "type": "code",
                    "code": "ts async function doWork () { // Do fake work for half a second. await new Promise ( resolve => setTimeout ( resolve , 500 )); } function loggy ( id : string ): AsyncDisposable { console . log ( `Constructing ${ id } ` ); return { async [ Symbol . asyncDispose ]() { console . log ( `Disposing (async) ${ id } ` ); await doWork (); }, } } async function func () { await using a = loggy ( \"a\" ); await using b = loggy ( \"b\" ); { await using c = loggy ( \"c\" ); await using d = loggy ( \"d\" ); } await using e = loggy ( \"e\" ); return ; // Unreachable. // Never created, never disposed. await using f = loggy ( \"f\" ); } func (); // Constructing a // Constructing b // Constructing c // Constructing d // Disposing (async) d // Disposing (async) c // Constructing e // Disposing (async) e // Disposing (async) b // Disposing (async) a"
                },
                {
                    "type": "p",
                    "text": "Defining types in terms of Disposable and AsyncDisposable can make your code much easier to work with if you expect others to do tear-down logic consistently.\nIn fact, lots of existing types exist in the wild which have a dispose() or close() method.\nFor example, the Visual Studio Code APIs even define their own Disposable interface .\nAPIs in the browser and in runtimes like Node.js, Deno, and Bun might also choose to use Symbol.dispose and Symbol.asyncDispose for objects which already have clean-up methods, like file handles, connections, and more. Now maybe this all sounds great for libraries, but a little bit heavy-weight for your scenarios.\nIf you’re doing a lot of ad-hoc clean-up, creating a new type might introduce a lot of over-abstraction and questions about best-practices.\nFor example, take our TempFile example again."
                },
                {
                    "type": "code",
                    "code": "ts class TempFile implements Disposable { #path : string ; #handle : number ; constructor ( path : string ) { this . #path = path ; this . #handle = fs . openSync ( path , \"w+\" ); } // other methods [ Symbol . dispose ]() { // Close the file and delete it. fs . closeSync ( this . #handle ); fs . unlinkSync ( this . #path ); } } export function doSomeWork () { using file = new TempFile ( \".some_temp_file\" ); // use file... if ( someCondition ()) { // do some more work... return ; } }"
                },
                {
                    "type": "p",
                    "text": "All we wanted was to remember to call two functions — but was this the best way to write it?\nShould we be calling openSync in the constructor, create an open() method, or pass in the handle ourselves?\nShould we expose a method for every possible operation we need to perform, or should we just make the properties public? That brings us to the final stars of the feature: DisposableStack and AsyncDisposableStack .\nThese objects are useful for doing both one-off clean-up, along with arbitrary amounts of cleanup.\nA DisposableStack is an object that has several methods for keeping track of Disposable objects, and can be given functions for doing arbitrary clean-up work.\nWe can also assign them to using variables because — get this — they’re also Disposable !\nSo here’s how we could’ve written the original example."
                },
                {
                    "type": "code",
                    "code": "ts function doSomeWork () { const path = \".some_temp_file\" ; const file = fs . openSync ( path , \"w+\" ); using cleanup = new DisposableStack (); cleanup . defer (() => { fs . closeSync ( file ); fs . unlinkSync ( path ); }); // use file... if ( someCondition ()) { // do some more work... return ; } // ... }"
                },
                {
                    "type": "p",
                    "text": "Here, the defer() method just takes a callback, and that callback will be run once cleanup is disposed of.\nTypically, defer (and other DisposableStack methods like use and adopt )\nshould be called immediately after creating a resource.\nAs the name suggests, DisposableStack disposes of everything it keeps track of like a stack, in a first-in-last-out order, so defer ing immediately after creating a value helps avoid odd dependency issues. AsyncDisposableStack works similarly, but can keep track of async functions and AsyncDisposable s, and is itself an AsyncDisposable. The defer method is similar in many ways to the defer keyword in Go , Swift , Zig , Odin , and others, where the conventions should be similar. Because this feature is so recent, most runtimes will not support it natively.\nTo use it, you will need runtime polyfills for the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Symbol.dispose",
                        "Symbol.asyncDispose",
                        "DisposableStack",
                        "AsyncDisposableStack",
                        "SuppressedError"
                    ]
                },
                {
                    "type": "p",
                    "text": "However, if all you’re interested in is using and await using , you should be able to get away with only polyfilling the built-in symbol s.\nSomething as simple as the following should work for most cases:"
                },
                {
                    "type": "code",
                    "code": "ts Symbol . dispose ??= Symbol ( \"Symbol.dispose\" ); Symbol . asyncDispose ??= Symbol ( \"Symbol.asyncDispose\" );"
                },
                {
                    "type": "p",
                    "text": "You will also need to set your compilation target to es2022 or below, and configure your lib setting to either include \"esnext\" or \"esnext.disposable\" ."
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"target\" : \"es2022\" , \"lib\" : [ \"es2022\" , \"esnext.disposable\" , \"dom\" ] } }"
                },
                {
                    "type": "p",
                    "text": "For more information on this feature, take a look at the work on GitHub ! TypeScript 5.2 implements an upcoming ECMAScript feature called decorator metadata . The key idea of this feature is to make it easy for decorators to create and consume metadata on any class they’re used on or within. Whenever decorator functions are used, they now have access to a new metadata property on their context object.\nThe metadata property just holds a simple object.\nSince JavaScript lets us add properties arbitrarily, it can be used as a dictionary that is updated by each decorator.\nAlternatively, since every metadata object will be identical for each decorated portion of a class, it can be used as a key into a Map .\nAfter all decorators on or in a class get run, that object can be accessed on the class via Symbol.metadata ."
                },
                {
                    "type": "code",
                    "code": "ts interface Context { name : string ; metadata : Record < PropertyKey , unknown >; } function setMetadata ( _target : any , context : Context ) { context . metadata [ context . name ] = true ; } class SomeClass { @ setMetadata foo = 123 ; @ setMetadata accessor bar = \"hello!\" ; @ setMetadata baz () { } } const ourMetadata = SomeClass [ Symbol . metadata ]; console . log ( JSON . stringify ( ourMetadata )); // { \"bar\": true, \"baz\": true, \"foo\": true }"
                },
                {
                    "type": "p",
                    "text": "This can be useful in a number of different scenarios.\nMetadata could possibly be attached for lots of uses like debugging, serialization, or performing dependency injection with decorators.\nSince metadata objects are created per decorated class, frameworks can either privately use them as keys into a Map or WeakMap , or tack properties on as necessary. For example, let’s say we wanted to use decorators to keep track of which properties and accessors are serializable when using JSON.stringify like so:"
                },
                {
                    "type": "code",
                    "code": "ts import { serialize , jsonify } from \"./serializer\" ; class Person { firstName : string ; lastName : string ; @ serialize age : number @ serialize get fullName () { return ` ${ this . firstName } ${ this . lastName } ` ; } toJSON () { return jsonify ( this ) } constructor ( firstName : string , lastName : string , age : number ) { // ... } }"
                },
                {
                    "type": "p",
                    "text": "Here, the intent is that only age and fullName should be serialized because they are marked with the @serialize decorator.\nWe define a toJSON method for this purpose, but it just calls out to jsonify which uses the metadata that @serialize created. Here’s an example of how the module ./serialize.ts might be defined:"
                },
                {
                    "type": "code",
                    "code": "ts const serializables = Symbol (); type Context = | ClassAccessorDecoratorContext | ClassGetterDecoratorContext | ClassFieldDecoratorContext ; export function serialize ( _target : any , context : Context ): void { if ( context . static || context . private ) { throw new Error ( \"Can only serialize public instance members.\" ) } if ( typeof context . name === \"symbol\" ) { throw new Error ( \"Cannot serialize symbol-named properties.\" ); } const propNames = ( context . metadata [ serializables ] as string [] | undefined ) ??= []; propNames . push ( context . name ); } export function jsonify ( instance : object ): string { const metadata = instance . constructor [ Symbol . metadata ]; const propNames = metadata ?.[ serializables ] as string [] | undefined ; if (! propNames ) { throw new Error ( \"No members marked with @serialize.\" ); } const pairStrings = propNames . map ( key => { const strKey = JSON . stringify ( key ); const strValue = JSON . stringify (( instance as any )[ key ]); return ` ${ strKey } : ${ strValue } ` ; }); return `{ ${ pairStrings . join ( \", \" ) } }` ; }"
                },
                {
                    "type": "p",
                    "text": "This module has a local symbol called serializables to store and retrieve the names of properties marked @serializable .\nIt stores a list of these property names on the metadata on each invocation of @serializable .\nWhen jsonify is called, the list of properties is fetched off of the metadata and used to retrieve the actual values from the instance, eventually serializing those names and values. Using a symbol technically makes this data accessible to others.\nAn alternative might be to use a WeakMap using the metadata object as a key.\nThis keeps data private and happens to use fewer type assertions in this case, but is otherwise similar."
                },
                {
                    "type": "code",
                    "code": "ts const serializables = new WeakMap < object , string []>(); type Context = | ClassAccessorDecoratorContext | ClassGetterDecoratorContext | ClassFieldDecoratorContext ; export function serialize ( _target : any , context : Context ): void { if ( context . static || context . private ) { throw new Error ( \"Can only serialize public instance members.\" ) } if ( typeof context . name !== \"string\" ) { throw new Error ( \"Can only serialize string properties.\" ); } let propNames = serializables . get ( context . metadata ); if ( propNames === undefined ) { serializables . set ( context . metadata , propNames = []); } propNames . push ( context . name ); } export function jsonify ( instance : object ): string { const metadata = instance . constructor [ Symbol . metadata ]; const propNames = metadata && serializables . get ( metadata ); if (! propNames ) { throw new Error ( \"No members marked with @serialize.\" ); } const pairStrings = propNames . map ( key => { const strKey = JSON . stringify ( key ); const strValue = JSON . stringify (( instance as any )[ key ]); return ` ${ strKey } : ${ strValue } ` ; }); return `{ ${ pairStrings . join ( \", \" ) } }` ; }"
                },
                {
                    "type": "p",
                    "text": "As a note, these implementations don’t handle subclassing and inheritance.\nThat’s left as an exercise to you (and you might find that it is easier in one version of the file than the other!). Because this feature is still fresh, most runtimes will not support it natively.\nTo use it, you will need a polyfill for Symbol.metadata .\nSomething as simple as the following should work for most cases:"
                },
                {
                    "type": "code",
                    "code": "ts Symbol . metadata ??= Symbol ( \"Symbol.metadata\" );"
                },
                {
                    "type": "p",
                    "text": "You will also need to set your compilation target to es2022 or below, and configure your lib setting to either include \"esnext\" or \"esnext.decorators\" ."
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"target\" : \"es2022\" , \"lib\" : [ \"es2022\" , \"esnext.decorators\" , \"dom\" ] } }"
                },
                {
                    "type": "p",
                    "text": "We’d like to thank Oleksandr Tarasiuk for contributing the implementation of decorator metadata for TypeScript 5.2! Tuple types have supported optional labels or names for each element."
                },
                {
                    "type": "code",
                    "code": "ts type Pair < T > = [first: T , second: T ];"
                },
                {
                    "type": "p",
                    "text": "These labels don’t change what you’re allowed to do with them — they’re solely to help with readability and tooling. However, TypeScript previously had a rule that tuples could not mix and match between labeled and unlabeled elements.\nIn other words, either no element could have a label in a tuple, or all elements needed one."
                },
                {
                    "type": "code",
                    "code": "ts // ✅ fine - no labels type Pair1 < T > = [ T , T ]; // ✅ fine - all fully labeled type Pair2 < T > = [first: T , second: T ]; // ❌ previously an error type Pair3 < T > = [first: T , T ]; //                         ~ // Tuple members must all have names // or all not have names."
                },
                {
                    "type": "p",
                    "text": "This could be annoying for rest elements where we’d be forced to just add a label like rest or tail ."
                },
                {
                    "type": "code",
                    "code": "ts // ❌ previously an error type TwoOrMore_A < T > = [first: T , second: T , ... T []]; //                                          ~~~~~~ // Tuple members must all have names // or all not have names. // ✅ type TwoOrMore_B < T > = [first: T , second: T , rest: ... T []];"
                },
                {
                    "type": "p",
                    "text": "It also meant that this restriction had to be enforced internally in the type system, meaning TypeScript would lose labels."
                },
                {
                    "type": "code",
                    "code": "ts type HasLabels = [a: string , b: string ]; type HasNoLabels = [ number , number ]; type Merged = [... HasNoLabels , ... HasLabels ]; //   ^ [number, number, string, string] // //     'a' and 'b' were lost in 'Merged'"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 5.2, the all-or-nothing restriction on tuple labels has been lifted.\nThe language can now also preserve labels when spreading into an unlabeled tuple. We’d like to extend our thanks to Josh Goldberg and Mateusz Burzyński who collaborated to lift this restriction . In previous versions of TypeScript, calling a method on a union of arrays could end in pain."
                },
                {
                    "type": "code",
                    "code": "ts declare let array : string [] | number []; array . filter ( x => !! x ); //    ~~~~~~ error! // This expression is not callable. //   Each member of the union type '...' has signatures, //   but none of those signatures are compatible //   with each other."
                },
                {
                    "type": "p",
                    "text": "In this example, TypeScript would try to see if each version of filter is compatible across string[] and number[] .\nWithout a coherent strategy, TypeScript threw its hands in the air and said “I can’t make it work”. In TypeScript 5.2, before giving up in these cases, unions of arrays are treated as a special case.\nA new array type is constructed out of each member’s element type, and then the method is invoked on that. Taking the above example, string[] | number[] is transformed into (string | number)[] (or Array<string | number> ), and filter is invoked on that type.\nThere is a slight caveat which is that filter will produce an Array<string | number> instead of a string[] | number[] ;\nbut for a freshly produced value there is less risk of something “going wrong”. This means lots of methods like filter , find , some , every , and reduce should all be invokable on unions of arrays in cases where they were not previously. You can read up more details on the implementing pull request . TypeScript now allows both declaration and implementation file extensions to be included in type-only import paths, regardless of whether allowImportingTsExtensions is enabled. This means that you can now write import type statements that use .ts , .mts , .cts , and .tsx file extensions."
                },
                {
                    "type": "code",
                    "code": "ts import type { JustAType } from \"./justTypes.ts\" ; export function f ( param : JustAType ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "It also means that import() types, which can be used in both TypeScript and JavaScript with JSDoc, can use those file extensions."
                },
                {
                    "type": "code",
                    "code": "js /** * @param {import(\"./justTypes.ts\").JustAType} param */ export function f ( param ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "For more information, see the change here . It can be easy to forget to add a comma when adding a new property to an object.\nPreviously, if you forgot a comma and requested auto-completion, TypeScript would confusingly give poor unrelated completion results. TypeScript 5.2 now gracefully provides object member completions when you’re missing a comma.\nBut to just skip past hitting you with a syntax error, it will also auto-insert the missing comma. For more information, see the implementation here . TypeScript 5.2 now has a refactoring to inline the contents of a variable to all usage sites. Using the “inline variable” refactoring will eliminate the variable and replace all the variable’s usages with its initializer.\nNote that this may cause that initializer’s side-effects to run at a different time, and as many times as the variable has been used. For more details, see the implementing pull request . Because TypeScript is a structural type system, types occasionally need to be compared in a member-wise fashion;\nhowever, recursive types add some issues here.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts interface A { value : A ; other : string ; } interface B { value : B ; other : number ; }"
                },
                {
                    "type": "p",
                    "text": "When checking whether the type A is compatible with the type B , TypeScript will end up checking whether the types of value in A and B are respectively compatible.\nAt this point, the type system needs to stop checking any further and proceed to check other members.\nTo do this, the type system has to track when any two types are already being related. Previously TypeScript already kept a stack of type pairs, and iterated through that to determine whether those types are being related.\nWhen this stack is shallow that’s not a problem; but when the stack isn’t shallow, that, uh, is a problem . In TypeScript 5.3, a simple Set helps track this information.\nThis reduced the time spent on a reported test case that used the drizzle library by over 33%!"
                },
                {
                    "type": "code",
                    "code": "Benchmark 1: old Time (mean ± σ):      3.115 s ±  0.067 s    [User: 4.403 s, System: 0.124 s] Range (min … max):    3.018 s …  3.196 s    10 runs Benchmark 2: new Time (mean ± σ):      2.072 s ±  0.050 s    [User: 3.355 s, System: 0.135 s] Range (min … max):    1.985 s …  2.150 s    10 runs Summary 'new' ran 1.50 ± 0.05 times faster than 'old'"
                },
                {
                    "type": "p",
                    "text": "Read more on the change here . TypeScript strives not to unnecessarily introduce breaks;\nhowever, occasionally we must make corrections and improvements so that code can be better-analyzed. Types generated for the DOM may have an impact on your codebase.\nFor more information, see the DOM updates for TypeScript 5.2 . In order to support a mixture of labeled and unlabeled elements , TypeScript’s API has changed slightly.\nThe labeledElementDeclarations property of TupleType may hold undefined for at each position where an element is unlabeled."
                },
                {
                    "type": "code",
                    "code": "diff interface TupleType { -     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[]; +     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[]; }"
                },
                {
                    "type": "p",
                    "text": "The --module and --moduleResolution options each support a node16 and nodenext setting.\nThese are effectively “modern Node.js” settings that should be used on any recent Node.js project.\nWhat we’ve found is that when these two options don’t agree on whether they are using Node.js-related settings, projects are effectively misconfigured. In TypeScript 5.2, when using node16 or nodenext for either of the --module and --moduleResolution options, TypeScript now requires the other to have a similar Node.js-related setting.\nIn cases where the settings diverge, you’ll likely get an error message like either"
                },
                {
                    "type": "code",
                    "code": "Option 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'."
                },
                {
                    "type": "code",
                    "code": "Option 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'."
                },
                {
                    "type": "p",
                    "text": "So for example --module esnext --moduleResolution node16 will be rejected — but you may be better off just using --module nodenext alone, or --module esnext --moduleResolution bundler . For more information, see the change here . When two declarations merge, they must agree on whether they are both exported.\nDue to a bug, TypeScript missed specific cases in ambient contexts, like in declaration files or declare module blocks.\nFor example, it would not issue an error on a case like the following, where replaceInFile is declared once as an exported function, and one as an un-exported namespace."
                },
                {
                    "type": "code",
                    "code": "ts declare module 'replace-in-file' { export function replaceInFile ( config : unknown ): Promise < unknown []>; export {}; namespace replaceInFile { export function sync ( config : unknown ): unknown []; } }"
                },
                {
                    "type": "p",
                    "text": "In an ambient module, adding an export { ... } or a similar construct like export default ... implicitly changes whether all declarations are automatically exported.\nTypeScript now recognizes these unfortunately confusing semantics more consistently, and issues an error on the fact that all declarations of replaceInFile need to agree in their modifiers, and will issue the following error:"
                },
                {
                    "type": "code",
                    "code": "Individual declarations in merged declaration 'replaceInFile' must be all exported or all local."
                },
                {
                    "type": "p",
                    "text": "For more information, see the change here . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html",
            "title": "TypeScript: Documentation - TypeScript 5.3",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript 5.3 supports the latest updates to the import attributes proposal. One use-case of import attributes is to provide information about the expected format of a module to the runtime."
                },
                {
                    "type": "code",
                    "code": "ts // We only want this to be interpreted as JSON, // not a runnable/malicious JavaScript file with a `.json` extension. import obj from \"./something.json\" with { type : \" json \" };"
                },
                {
                    "type": "p",
                    "text": "The contents of these attributes are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error)."
                },
                {
                    "type": "code",
                    "code": "ts // TypeScript is fine with this. // But your browser? Probably not. import * as foo from \"./foo.js\" with { type : \" fluffy bunny \" };"
                },
                {
                    "type": "p",
                    "text": "Dynamic import() calls can also use import attributes through a second argument."
                },
                {
                    "type": "code",
                    "code": "ts const obj = await import ( \"./something.json\" , { with: { type: \"json\" } });"
                },
                {
                    "type": "p",
                    "text": "The expected type of that second argument is defined by a type called ImportCallOptions , which by default just expects a property called with . Note that import attributes are an evolution of an earlier proposal called “import assertions”, which were implemented in TypeScript 4.5 .\nThe most obvious difference is the use of the with keyword over the assert keyword.\nBut the less-visible difference is that runtimes are now free to use attributes to guide the resolution and interpretation of import paths, whereas import assertions could only assert some characteristics after loading a module. Over time, TypeScript will be deprecating the old syntax for import assertions in favor of the proposed syntax for import attributes.\nExisting code using assert should migrate towards the with keyword.\nNew code that needs an import attribute should use with exclusively. We’d like to thank Oleksandr Tarasiuk for implementing this proposal !\nAnd we’d also like to call out Wenlu Wang for their implementation of import assertions ! In TypeScript 4.7, TypeScript added support for a resolution-mode attribute in /// <reference types=\"...\" /> to control whether a specifier should be resolved via import or require semantics."
                },
                {
                    "type": "code",
                    "code": "ts /// <reference types=\"pkg\" resolution-mode=\"require\" /> // or /// <reference types=\"pkg\" resolution-mode=\"import\" />"
                },
                {
                    "type": "p",
                    "text": "A corresponding field was added to import assertions on type-only imports as well;\nhowever, it was only supported in nightly versions of TypeScript.\nThe rationale was that in spirit, import assertions were not intended to guide module resolution.\nSo this feature was shipped experimentally in a nightly-only mode to get more feedback. But given that import attributes can guide resolution, and that we’ve seen reasonable use-cases, TypeScript 5.3 now supports the resolution-mode attribute for import type ."
                },
                {
                    "type": "code",
                    "code": "ts // Resolve `pkg` as if we were importing with a `require()` import type { TypeFromRequire } from \"pkg\" with { \" resolution - mode \": \" require \" }; // Resolve `pkg` as if we were importing with an `import` import type { TypeFromImport } from \"pkg\" with { \" resolution - mode \": \" import \" }; export interface MergedType extends TypeFromRequire , TypeFromImport {}"
                },
                {
                    "type": "p",
                    "text": "These import attributes can also be used on import() types."
                },
                {
                    "type": "code",
                    "code": "ts export type TypeFromRequire = import ( \"pkg\" , { with: { \"resolution-mode\" : \"require\" } }). TypeFromRequire ; export type TypeFromImport = import ( \"pkg\" , { with: { \"resolution-mode\" : \"import\" } }). TypeFromImport ; export interface MergedType extends TypeFromRequire , TypeFromImport {}"
                },
                {
                    "type": "p",
                    "text": "For more information, check out the change here Previously, using resolution-mode was only allowed under the moduleResolution options node16 and nodenext .\nTo make it easier to look up modules specifically for type purposes, resolution-mode now works appropriately in all other moduleResolution options like bundler , node10 , and simply doesn’t error under classic . For more information, see the implementing pull request . TypeScript 5.3 now can perform narrowing based on conditions in each case clause within a switch (true) ."
                },
                {
                    "type": "code",
                    "code": "ts function f ( x : unknown ) { switch ( true ) { case typeof x === \"string\" : // 'x' is a 'string' here console . log ( x . toUpperCase ()); // falls through... case Array . isArray ( x ): // 'x' is a 'string | any[]' here. console . log ( x . length ); // falls through... default : // 'x' is 'unknown' here. // ... } }"
                },
                {
                    "type": "p",
                    "text": "This feature was spearheaded initial work by Mateusz Burzyński We’d like to extend a “thank you!” for this contribution. Occasionally you may find yourself performing a direct comparison with true or false in a condition.\nUsually these are unnecessary comparisons, but you might prefer it as a point of style, or to avoid certain issues around JavaScript truthiness.\nRegardless, previously TypeScript just didn’t recognize such forms when performing narrowing. TypeScript 5.3 now keeps up and understands these expressions when narrowing variables."
                },
                {
                    "type": "code",
                    "code": "ts interface A { a : string ; } interface B { b : string ; } type MyType = A | B ; function isA ( x : MyType ): x is A { return \"a\" in x ; } function someFn ( x : MyType ) { if ( isA ( x ) === true ) { console . log ( x . a ); // works! } }"
                },
                {
                    "type": "p",
                    "text": "We’d like to thank Mateusz Burzyński for the pull request that implemented this. A slightly esoteric feature of JavaScript is that it is possible to override the behavior of the instanceof operator.\nTo do so, the value on the right side of the instanceof operator needs to have a specific method named by Symbol.hasInstance ."
                },
                {
                    "type": "code",
                    "code": "js class Weirdo { static [ Symbol . hasInstance ]( testedValue ) { // wait, what? return testedValue === undefined ; } } // false console . log ( new Thing () instanceof Weirdo ); // true console . log ( undefined instanceof Weirdo );"
                },
                {
                    "type": "p",
                    "text": "To better model this behavior in instanceof , TypeScript now checks if such a [Symbol.hasInstance] method exists and is declared as a type predicate function.\nIf it does, the tested value on the left side of the instanceof operator will be narrowed appropriately by that type predicate."
                },
                {
                    "type": "code",
                    "code": "ts interface PointLike { x : number ; y : number ; } class Point implements PointLike { x : number ; y : number ; constructor ( x : number , y : number ) { this . x = x ; this . y = y ; } distanceFromOrigin () { return Math . sqrt ( this . x ** 2 + this . y ** 2 ); } static [ Symbol . hasInstance ]( val : unknown ): val is PointLike { return !! val && typeof val === \"object\" && \"x\" in val && \"y\" in val && typeof val . x === \"number\" && typeof val . y === \"number\" ; } } function f ( value : unknown ) { if ( value instanceof Point ) { // Can access both of these - correct! value . x ; value . y ; // Can't access this - we have a 'PointLike', // but we don't *actually* have a 'Point'. value . distanceFromOrigin (); } }"
                },
                {
                    "type": "p",
                    "text": "As you can see in this example, Point defines its own [Symbol.hasInstance] method.\nIt actually acts as a custom type guard over a separate type called PointLike .\nIn the function f , we were able to narrow value down to a PointLike with instanceof , but not a Point .\nThat means that we can access the properties x and y , but not the method distanceFromOrigin . For more information, you can read up on this change here . In JavaScript, it’s possible to access a declaration in a base class through the super keyword."
                },
                {
                    "type": "code",
                    "code": "js class Base { someMethod () { console . log ( \"Base method called!\" ); } } class Derived extends Base { someMethod () { console . log ( \"Derived method called!\" ); super . someMethod (); } } new Derived (). someMethod (); // Prints: //   Derived method called! //   Base method called!"
                },
                {
                    "type": "p",
                    "text": "This is different from writing something like this.someMethod() , since that could invoke an overridden method.\nThis is a subtle distinction, made more subtle by the fact that often the two can be interchangeable if a declaration is never overridden at all."
                },
                {
                    "type": "code",
                    "code": "js class Base { someMethod () { console . log ( \"someMethod called!\" ); } } class Derived extends Base { someOtherMethod () { // These act identically. this . someMethod (); super . someMethod (); } } new Derived (). someOtherMethod (); // Prints: //   someMethod called! //   someMethod called!"
                },
                {
                    "type": "p",
                    "text": "The problem is using them interchangeably is that super only works on members declared on the prototype — not instance properties.\nThat means that if you wrote super.someMethod() , but someMethod was defined as a field, you’d get a runtime error!"
                },
                {
                    "type": "code",
                    "code": "ts class Base { someMethod = () => { console . log ( \"someMethod called!\" ); } } class Derived extends Base { someOtherMethod () { super . someMethod (); } } new Derived (). someOtherMethod (); // 💥 // Doesn't work because 'super.someMethod' is 'undefined'."
                },
                {
                    "type": "p",
                    "text": "TypeScript 5.3 now more-closely inspects super property accesses/method calls to see if they correspond to class fields.\nIf they do, we’ll now get a type-checking error. This check was contributed thanks to Jack Works ! TypeScript’s inlay hints now support jumping to the definition of types!\nThis makes it easier to casually navigate your code. See more at the implementation here . Previously when TypeScript generated auto-imports for something in a type position, it would add a type modifier based on your settings.\nFor example, when getting an auto-import on Person in the following:"
                },
                {
                    "type": "code",
                    "code": "ts export let p : Person"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s editing experience would usually add an import for Person as:"
                },
                {
                    "type": "code",
                    "code": "ts import { Person } from \"./types\" ; export let p : Person"
                },
                {
                    "type": "p",
                    "text": "and under certain settings like verbatimModuleSyntax , it would add the type modifier:"
                },
                {
                    "type": "code",
                    "code": "ts import { type Person } from \"./types\" ; export let p : Person"
                },
                {
                    "type": "p",
                    "text": "However, maybe your codebase isn’t able to use some of these options; or you just have a preference for explicit type imports when possible. With a recent change , TypeScript now enables this to be an editor-specific option.\nIn Visual Studio Code, you can enable it in the UI under “TypeScript › Preferences: Prefer Type Only Auto Imports”, or as the JSON configuration option typescript.preferences.preferTypeOnlyAutoImports When running TypeScript via tsc , the compiler will now avoid parsing JSDoc.\nThis drops parsing time on its own, but also reduces memory usage to store comments along with time spent in garbage collection.\nAll-in-all, you should see slightly faster compiles and quicker feedback in --watch mode. The specific changes can be viewed here . Because not every tool using TypeScript will need to store JSDoc (e.g. typescript-eslint and Prettier), this parsing strategy has been surfaced as part of the API itself.\nThis can enable these tools to gain the same memory and speed improvements we’ve brought to the TypeScript compiler.\nThe new options for comment parsing strategy are described in JSDocParsingMode .\nMore information is available on this pull request . In TypeScript, unions and intersections always follow a specific form, where intersections can’t contain union types.\nThat means that when we create an intersection over a union like A & (B | C) , that intersection will be normalized into (A & B) | (A & C) .\nStill, in some cases the type system will maintain the original form for display purposes. It turns out that the original form can be used for some clever fast-path comparisons between types. For example, let’s say we have SomeType & (Type1 | Type2 | ... | Type99999NINE) and we want to see if that’s assignable to SomeType .\nRecall that we don’t really have an intersection as our source type — we have a union that looks like (SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE) .\nWhen checking if a union is assignable to some target type, we have to check if every member of the union is assignable to the target type, and that can be very slow. In TypeScript 5.3, we peek at the original intersection form that we were able to tuck away.\nWhen we compare the types, we do a quick check to see if the target exists in any constituent of the source intersection. For more information, see this pull request . TypeScript itself ships two library files: tsserverlibrary.js and typescript.js .\nThere are certain APIs available only in tsserverlibrary.js (like the ProjectService API), which may be useful to some importers.\nStill, the two are distinct bundles with a lot of overlap, duplicating code in the package.\nWhat’s more, it can be challenging to consistently use one over the other due to auto-imports or muscle memory.\nAccidentally loading both modules is far too easy, and code may not work properly on a different instance of the API.\nEven if it does work, loading a second bundle increases resource usage. Given this, we’ve decided to consolidate the two. typescript.js now contains what tsserverlibrary.js used to contain, and tsserverlibrary.js now simply re-exports typescript.js .\nComparing the before/after of this consolidation, we saw the following reduction in package size: In other words, this is over a 20.5% reduction in package size. For more information, you can see the work involved here . Types generated for the DOM may have an impact on your codebase.\nFor more information, see the DOM updates for TypeScript 5.3 . TypeScript 5.3 now detects when the declaration referenced by a super. property access is a class field and issues an error.\nThis prevents errors that might occur at runtime. See more on this change here . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html",
            "title": "TypeScript: Documentation - TypeScript 5.4",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript can usually figure out a more specific type for a variable based on checks that you might perform.\nThis process is called narrowing."
                },
                {
                    "type": "code",
                    "code": "ts function uppercaseStrings ( x : string | number ) { if ( typeof x === \"string\" ) { // TypeScript knows 'x' is a 'string' here. return x . toUpperCase (); } }"
                },
                {
                    "type": "p",
                    "text": "One common pain point was that these narrowed types weren’t always preserved within function closures."
                },
                {
                    "type": "code",
                    "code": "ts function getUrls ( url : string | URL , names : string []) { if ( typeof url === \"string\" ) { url = new URL ( url ); } return names . map ( name => { url . searchParams . set ( \"name\" , name ) //  ~~~~~~~~~~~~ // error! // Property 'searchParams' does not exist on type 'string | URL'. return url . toString (); }); }"
                },
                {
                    "type": "p",
                    "text": "Here, TypeScript decided that it wasn’t “safe” to assume that url was actually a URL object in our callback function because it was mutated elsewhere;\nhowever, in this instance, that arrow function is always created after that assignment to url , and it’s also the last assignment to url . TypeScript 5.4 takes advantage of this to make narrowing a little smarter.\nWhen parameters and let variables are used in non- hoisted functions, the type-checker will look for a last assignment point.\nIf one is found, TypeScript can safely narrow from outside the containing function.\nWhat that means is the above example just works now. Note that narrowing analysis doesn’t kick in if the variable is assigned anywhere in a nested function.\nThis is because there’s no way to know for sure whether the function will be called later."
                },
                {
                    "type": "code",
                    "code": "ts function printValueLater ( value : string | undefined ) { if ( value === undefined ) { value = \"missing!\" ; } setTimeout (() => { // Modifying 'value', even in a way that shouldn't affect // its type, will invalidate type refinements in closures. value = value ; }, 500 ); setTimeout (() => { console . log ( value . toUpperCase ()); //          ~~~~~ // error! 'value' is possibly 'undefined'. }, 1000 ); }"
                },
                {
                    "type": "p",
                    "text": "This should make lots of typical JavaScript code easier to express.\nYou can read more about the change on GitHub . When calling generic functions, TypeScript is able to infer type arguments from whatever you pass in."
                },
                {
                    "type": "code",
                    "code": "ts function doSomething < T >( arg : T ) { // ... } // We can explicitly say that 'T' should be 'string'. doSomething < string >( \"hello!\" ); // We can also just let the type of 'T' get inferred. doSomething ( \"hello!\" );"
                },
                {
                    "type": "p",
                    "text": "One challenge, however, is that it is not always clear what the “best” type is to infer.\nThis might lead to TypeScript rejecting valid calls, accepting questionable calls, or just reporting worse error messages when it catches a bug. For example, let’s imagine a createStreetLight function that takes a list of color names, along with an optional default color."
                },
                {
                    "type": "code",
                    "code": "ts function createStreetLight < C extends string >( colors : C [], defaultColor ?: C ) { // ... } createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"red\" );"
                },
                {
                    "type": "p",
                    "text": "What happens when we pass in a defaultColor that wasn’t in the original colors array?\nIn this function, colors is supposed to be the “source of truth” and describe what can be passed to defaultColor ."
                },
                {
                    "type": "code",
                    "code": "ts // Oops! This is undesirable, but is allowed! createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"blue\" );"
                },
                {
                    "type": "p",
                    "text": "In this call, type inference decided that \"blue\" was just as valid of a type as \"red\" or \"yellow\" or \"green\" .\nSo instead of rejecting the call, TypeScript infers the type of C as \"red\" | \"yellow\" | \"green\" | \"blue\" .\nYou might say that inference just blue up in our faces! One way people currently deal with this is to add a separate type parameter that’s bounded by the existing type parameter."
                },
                {
                    "type": "code",
                    "code": "ts function createStreetLight < C extends string , D extends C >( colors : C [], defaultColor ?: D ) { } createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"blue\" ); //                                            ~~~~~~ // error! // Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'."
                },
                {
                    "type": "p",
                    "text": "This works, but is a little bit awkward because D probably won’t be used anywhere else in the signature for createStreetLight .\nWhile not bad in this case , using a type parameter only once in a signature is often a code smell. That’s why TypeScript 5.4 introduces a new NoInfer<T> utility type.\nSurrounding a type in NoInfer<...> gives a signal to TypeScript not to dig in and match against the inner types to find candidates for type inference. Using NoInfer , we can rewrite createStreetLight as something like this:"
                },
                {
                    "type": "code",
                    "code": "ts function createStreetLight < C extends string >( colors : C [], defaultColor ?: NoInfer < C >) { // ... } createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"blue\" ); //                                            ~~~~~~ // error! // Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'."
                },
                {
                    "type": "p",
                    "text": "Excluding the type of defaultColor from being explored for inference means that \"blue\" never ends up as an inference candidate, and the type-checker can reject it. You can see the specific changes in the implementing pull request , along with the initial implementation provided thanks to Mateusz Burzyński ! TypeScript 5.4 adds declarations for JavaScript’s new Object.groupBy and Map.groupBy static methods. Object.groupBy takes an iterable, and a function that decides which “group” each element should be placed in.\nThe function needs to make a “key” for each distinct group, and Object.groupBy uses that key to make an object where every key maps to an array with the original element in it."
                },
                {
                    "type": "code",
                    "code": "js const array = [ 0 , 1 , 2 , 3 , 4 , 5 ]; const myObj = Object . groupBy ( array , ( num , index ) => { return num % 2 === 0 ? \"even\" : \"odd\" ; });"
                },
                {
                    "type": "p",
                    "text": "is basically equivalent to writing this:"
                },
                {
                    "type": "code",
                    "code": "js const myObj = { even: [ 0 , 2 , 4 ], odd: [ 1 , 3 , 5 ], };"
                },
                {
                    "type": "p",
                    "text": "Map.groupBy is similar, but produces a Map instead of a plain object.\nThis might be more desirable if you need the guarantees of Map s, you’re dealing with APIs that expect Map s, or you need to use any kind of key for grouping - not just keys that can be used as property names in JavaScript."
                },
                {
                    "type": "code",
                    "code": "js const myObj = Map . groupBy ( array , ( num , index ) => { return num % 2 === 0 ? \"even\" : \"odd\" ; });"
                },
                {
                    "type": "p",
                    "text": "and just as before, you could have created myObj in an equivalent way:"
                },
                {
                    "type": "code",
                    "code": "js const myObj = new Map (); myObj . set ( \"even\" , [ 0 , 2 , 4 ]); myObj . set ( \"odd\" , [ 1 , 3 , 5 ]);"
                },
                {
                    "type": "p",
                    "text": "Note that in the above example of Object.groupBy , the object produced uses all optional properties."
                },
                {
                    "type": "code",
                    "code": "ts interface EvenOdds { even ?: number []; odd ?: number []; } const myObj : EvenOdds = Object . groupBy (...); myObj . even ; //    ~~~~ // Error to access this under 'strictNullChecks'."
                },
                {
                    "type": "p",
                    "text": "This is because there’s no way to guarantee in a general way that all the keys were produced by groupBy . Note also that these methods are only accessible by configuring your target to esnext or adjusting your lib settings.\nWe expect they will eventually be available under a stable es2024 target. We’d like to extend a thanks to Kevin Gibbons for adding the declarations to these groupBy methods . TypeScript has a moduleResolution option called bundler that is meant to model the way modern bundlers figure out which file an import path refers to.\nOne of the limitations of the option is that it had to be paired with --module esnext , making it impossible to use the import ... = require(...) syntax."
                },
                {
                    "type": "code",
                    "code": "ts // previously errored import myModule = require ( \"module/path\" );"
                },
                {
                    "type": "p",
                    "text": "That might not seem like a big deal if you’re planning on just writing standard ECMAScript import s, but there’s a difference when using a package with conditional exports . In TypeScript 5.4, require() can now be used when setting the module setting to a new option called preserve . Between --module preserve and --moduleResolution bundler , the two more accurately model what bundlers and runtimes like Bun will allow, and how they’ll perform module lookups.\nIn fact, when using --module preserve , the bundler option will be implicitly set for --moduleResolution (along with --esModuleInterop and --resolveJsonModule )"
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"module\" : \"preserve\" , // ^ also implies: // \"moduleResolution\": \"bundler\", // \"esModuleInterop\": true, // \"resolveJsonModule\": true, // ... } }"
                },
                {
                    "type": "p",
                    "text": "Under --module preserve , an ECMAScript import will always be emitted as-is, and import ... = require(...) will be emitted as a require() call (though in practice you may not even use TypeScript for emit, since it’s likely you’ll be using a bundler for your code).\nThis holds true regardless of the file extension of the containing file.\nSo the output of this code:"
                },
                {
                    "type": "code",
                    "code": "ts import * as foo from \"some-package/foo\" ; import bar = require ( \"some-package/bar\" );"
                },
                {
                    "type": "code",
                    "code": "js import * as foo from \"some-package/foo\" ; var bar = require ( \"some-package/bar\" );"
                },
                {
                    "type": "p",
                    "text": "What this also means is that the syntax you choose directs how conditional exports are matched.\nSo in the above example, if the package.json of some-package looks like this:"
                },
                {
                    "type": "code",
                    "code": "json { \"name\" : \"some-package\" , \"version\" : \"0.0.1\" , \"exports\" : { \"./foo\" : { \"import\" : \"./esm/foo-from-import.mjs\" , \"require\" : \"./cjs/foo-from-require.cjs\" }, \"./bar\" : { \"import\" : \"./esm/bar-from-import.mjs\" , \"require\" : \"./cjs/bar-from-require.cjs\" } } }"
                },
                {
                    "type": "p",
                    "text": "TypeScript will resolve these paths to [...]/some-package/esm/foo-from-import.mjs and [...]/some-package/cjs/bar-from-require.cjs . For more information, you can read up on these new settings here . Import attributes and assertions are now checked against the global ImportAttributes type.\nThis means that runtimes can now more accurately describe the import attributes"
                },
                {
                    "type": "code",
                    "code": "ts // In some global file. interface ImportAttributes { type : \"json\" ; } // In some other module import * as ns from \"foo\" with { type : \" not - json \" }; //                                     ~~~~~~~~~~ // error! // // Type '{ type: \"not-json\"; }' is not assignable to type 'ImportAttributes'. //  Types of property 'type' are incompatible. //    Type '\"not-json\"' is not assignable to type '\"json\"'."
                },
                {
                    "type": "p",
                    "text": "This change was provided thanks to Oleksandr Tarasiuk . TypeScript now has a quick fix to add a new parameter to functions that are called with too many arguments. This can be useful when threading a new argument through several existing functions, which can be cumbersome today. This quick fix was provided courtsey of Oleksandr Tarasiuk . TypeScript 5.0 deprecated the following options and behaviors:"
                },
                {
                    "type": "list",
                    "items": [
                        "charset",
                        "target: ES3",
                        "importsNotUsedAsValues",
                        "noImplicitUseStrict",
                        "noStrictGenericChecks",
                        "keyofStringsOnly",
                        "suppressExcessPropertyErrors",
                        "suppressImplicitAnyIndexErrors",
                        "out",
                        "preserveValueImports",
                        "prepend in project references",
                        "implicitly OS-specific newLine"
                    ]
                },
                {
                    "type": "p",
                    "text": "To continue using them, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called ignoreDeprecations with the value \"5.0\" . However, TypScript 5.4 will be the last version in which these will continue to function as normal.\nBy TypeScript 5.5 (likely June 2024), these will become hard errors, and code using them will need to be migrated away. For more information, you can read up on this plan on GitHub , which contains suggestions in how to best adapt your codebase. This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade.\nSometimes it will highlight deprecations, removals, and new restrictions.\nIt can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors. Types generated for the DOM may have an impact on type-checking your codebase.\nFor more information, see the DOM updates for TypeScript 5.4 . The following code no longer allows the second variable declaration in the function foo ."
                },
                {
                    "type": "code",
                    "code": "ts type IsArray < T > = T extends any [] ? true : false ; function foo < U extends object >( x : IsArray < U >) { let first : true = x ; // Error let second : false = x ; // Error, but previously wasn't }"
                },
                {
                    "type": "p",
                    "text": "Previously, when TypeScript checked the initializer for second , it needed to determine whether IsArray<U> was assignable to the unit type false .\nWhile IsArray<U> isn’t compatible any obvious way, TypeScript looks at the constraint of that type as well.\nIn a conditional type like T extends Foo ? TrueBranch : FalseBranch , where T is generic, the type system would look at the constraint of T , substitute it in for T itself, and decide on either the true or false branch. But this behavior was inaccurate because it was overly eager.\nEven if the constraint of T isn’t assignable to Foo , that doesn’t mean that it won’t be instantiated with something that is.\nAnd so the more correct behavior is to produce a union type for the constraint of the conditional type in cases where it can’t be proven that T never or always extends Foo. TypeScript 5.4 adopts this more accurate behavior.\nWhat this means in practice is that you may begin to find that some conditional type instances are no longer compatible with their branches. You can read about the specific changes here . TypeScript now reduces intersections with type variables and primitives more aggressively, depending on how the type variable’s constraint overlaps with those primitives."
                },
                {
                    "type": "code",
                    "code": "ts declare function intersect < T , U >( x : T , y : U ): T & U ; function foo < T extends \"abc\" | \"def\" >( x : T , str : string , num : number ) { // Was 'T & string', now is just 'T' let a = intersect ( x , str ); // Was 'T & number', now is just 'never' let b = intersect ( x , num ) // Was '(T & \"abc\") | (T & \"def\")', now is just 'T' let c = Math . random () < 0.5 ? intersect ( x , \"abc\" ) : intersect ( x , \"def\" ); }"
                },
                {
                    "type": "p",
                    "text": "For more information, see the change here . TypeScript now more accurately checks whether or not strings are assignable to the placeholder slots of a template string type."
                },
                {
                    "type": "code",
                    "code": "ts function a < T extends { id : string }>() { let x : `- ${ keyof T & string } ` ; // Used to error, now doesn't. x = \"-id\" ; }"
                },
                {
                    "type": "p",
                    "text": "This behavior is more desirable, but may cause breaks in code using constructs like conditional types, where these rule changes are easy to witness. See this change for more details. Previously, TypeScript would permit the following code under isolatedModules if the import to Something only referred to a type."
                },
                {
                    "type": "code",
                    "code": "ts import { Something } from \"./some/path\" ; let Something = 123 ;"
                },
                {
                    "type": "p",
                    "text": "However, it’s not safe for single-file compilers to assume whether it’s “safe” to drop the import , even if the code is guaranteed to fail at runtime.\nIn TypeScript 5.4, this code will trigger an error like the following:"
                },
                {
                    "type": "code",
                    "code": "Import 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled."
                },
                {
                    "type": "p",
                    "text": "The fix should be to either make a local rename, or, as the error states, add the type modifier to the import:"
                },
                {
                    "type": "code",
                    "code": "ts import type { Something } from \"./some/path\" ; // or import { type Something } from \"./some/path\" ;"
                },
                {
                    "type": "p",
                    "text": "See more information on the change itself . When two enums have the same declared names and enum member names, they were previously always considered compatible;\nhowever, when the values were known, TypeScript would silently allow them to have differing values. TypeScript 5.4 tightens this restriction by requiring the values to be identical when they are known."
                },
                {
                    "type": "code",
                    "code": "ts namespace First { export enum SomeEnum { A = 0 , B = 1 , } } namespace Second { export enum SomeEnum { A = 0 , B = 2 , } } function foo ( x : First . SomeEnum , y : Second . SomeEnum ) { // Both used to be compatible - no longer the case, // TypeScript errors with something like: // //  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given. x = y ; y = x ; }"
                },
                {
                    "type": "p",
                    "text": "Additionally, there are new restrictions for when one of the enum members does not have a statically known value.\nIn these cases, the other enum must at least be implicitly numeric (e.g. it has no statically resolved initializer), or it is explicitly numeric (meaning TypeScript could resolve the value to something numeric).\nPractically speaking, what this means is that string enum members are only ever compatible with other string enums of the same value."
                },
                {
                    "type": "code",
                    "code": "ts namespace First { export declare enum SomeEnum { A , B , } } namespace Second { export declare enum SomeEnum { A , B = \"some known string\" , } } function foo ( x : First . SomeEnum , y : Second . SomeEnum ) { // Both used to be compatible - no longer the case, // TypeScript errors with something like: // //  One value of 'SomeEnum.B' is the string '\"some known string\"', and the other is assumed to be an unknown numeric value. x = y ; y = x ; }"
                },
                {
                    "type": "p",
                    "text": "For more information, see the pull request that introduced this change . TypeScript no longer allows enum members to use the names Infinity , -Infinity , or NaN ."
                },
                {
                    "type": "code",
                    "code": "ts // Errors on all of these: // //  An enum member cannot have a numeric name. enum E { Infinity = 0 , \"-Infinity\" = 1 , NaN = 2 , }"
                },
                {
                    "type": "p",
                    "text": "Previously, applying a mapped type with any into a tuple would create an any element type.\nThis is undesirable and is now fixed."
                },
                {
                    "type": "code",
                    "code": "ts Promise . all ([ \"\" , ...([] as any )]) . then (( result ) => { const head = result [ 0 ]; // 5.3: any, 5.4: string const tail = result . slice ( 1 ); // 5.3 any, 5.4: any[] });"
                },
                {
                    "type": "p",
                    "text": "For more information, see the fix along with the follow-on discussion around behavioral changes and further tweaks . While not a breaking change per se, developers may have implicitly taken dependencies on TypeScript’s JavaScript or declaration emit outputs.\nThe following are notable changes."
                },
                {
                    "type": "list",
                    "items": [
                        "Preserve type parameter names more often when shadowed",
                        "Move complex parameter lists of async function into downlevel generator body",
                        "Do not remove binding alias in function declarations",
                        "ImportAttributes should go through the same emit phases when in an ImportTypeNode"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html",
            "title": "TypeScript: Documentation - TypeScript 5.5",
            "content": [
                {
                    "type": "p",
                    "text": "This section was written by Dan Vanderkam , who implemented this feature in TypeScript 5.5 . Thanks Dan! TypeScript’s control flow analysis does a great job of tracking how the type of a variable changes as it moves through your code:"
                },
                {
                    "type": "code",
                    "code": "tsx interface Bird { commonName : string ; scientificName : string ; sing (): void ; } // Maps country names -> national bird. // Not all nations have official birds (looking at you, Canada!) declare const nationalBirds : Map < string , Bird >; function makeNationalBirdCall ( country : string ) { const bird = nationalBirds . get ( country ); // bird has a declared type of Bird | undefined if ( bird ) { bird . sing (); // bird has type Bird inside the if statement } else { // bird has type undefined here. } }"
                },
                {
                    "type": "p",
                    "text": "By making you handle the undefined case, TypeScript pushes you to write more robust code. In the past, this sort of type refinement was more difficult to apply to arrays. This would have been an error in all previous versions of TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsx function makeBirdCalls ( countries : string []) { // birds: (Bird | undefined)[] const birds = countries . map ( country => nationalBirds . get ( country )) . filter ( bird => bird !== undefined ); for ( const bird of birds ) { bird . sing (); // error: 'bird' is possibly 'undefined'. } }"
                },
                {
                    "type": "p",
                    "text": "This code is perfectly fine: we’ve filtered all the undefined values out of the list.\r\nBut TypeScript hasn’t been able to follow along. With TypeScript 5.5, the type checker is fine with this code:"
                },
                {
                    "type": "code",
                    "code": "tsx function makeBirdCalls ( countries : string []) { // birds: Bird[] const birds = countries . map ( country => nationalBirds . get ( country )) . filter ( bird => bird !== undefined ); for ( const bird of birds ) { bird . sing (); // ok! } }"
                },
                {
                    "type": "p",
                    "text": "Note the more precise type for birds . This works because TypeScript now infers a type predicate for the filter function.\r\nYou can see what’s going on more clearly by pulling it out into a standalone function:"
                },
                {
                    "type": "code",
                    "code": "tsx // function isBirdReal(bird: Bird | undefined): bird is Bird function isBirdReal ( bird : Bird | undefined ) { return bird !== undefined ; }"
                },
                {
                    "type": "p",
                    "text": "bird is Bird is the type predicate.\r\nIt means that, if the function returns true , then it’s a Bird (if the function returns false then it’s undefined ).\r\nThe type declarations for Array.prototype.filter know about type predicates, so the net result is that you get a more precise type and the code passes the type checker. TypeScript will infer that a function returns a type predicate if these conditions hold:"
                },
                {
                    "type": "list",
                    "items": [
                        "The function does not have an explicit return type or type predicate annotation.",
                        "The function has a single return statement and no implicit returns.",
                        "The function does not mutate its parameter.",
                        "The function returns a boolean expression that’s tied to a refinement on the parameter."
                    ]
                },
                {
                    "type": "p",
                    "text": "Generally this works how you’d expect.\r\nHere’s a few more examples of inferred type predicates:"
                },
                {
                    "type": "code",
                    "code": "tsx // const isNumber: (x: unknown) => x is number const isNumber = ( x : unknown ) => typeof x === 'number' ; // const isNonNullish: <T>(x: T) => x is NonNullable<T> const isNonNullish = < T ,>( x : T ) => x != null ;"
                },
                {
                    "type": "p",
                    "text": "Previously, TypeScript would have just inferred that these functions return boolean .\r\nIt now infers signatures with type predicates like x is number or x is NonNullable<T> . Type predicates have “if and only if” semantics.\r\nIf a function returns x is T , then it means that:"
                },
                {
                    "type": "list",
                    "items": [
                        "If the function returns true then x has the type T .",
                        "If the function returns false then x does not have type T ."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you’re expecting a type predicate to be inferred but it’s not, then you may be running afoul of the second rule. This often comes up with “truthiness” checks:"
                },
                {
                    "type": "code",
                    "code": "tsx function getClassroomAverage ( students : string [], allScores : Map < string , number >) { const studentScores = students . map ( student => allScores . get ( student )) . filter ( score => !! score ); return studentScores . reduce (( a , b ) => a + b ) / studentScores . length ; //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // error: Object is possibly 'undefined'. }"
                },
                {
                    "type": "p",
                    "text": "TypeScript did not infer a type predicate for score => !!score , and rightly so: if this returns true then score is a number .\r\nBut if it returns false , then score could be either undefined or a number (specifically, 0 ).\r\nThis is a real bug: if any student got a zero on the test, then filtering out their score will skew the average upwards.\r\nFewer will be above average and more will be sad! As with the first example, it’s better to explicitly filter out undefined values:"
                },
                {
                    "type": "code",
                    "code": "tsx function getClassroomAverage ( students : string [], allScores : Map < string , number >) { const studentScores = students . map ( student => allScores . get ( student )) . filter ( score => score !== undefined ); return studentScores . reduce (( a , b ) => a + b ) / studentScores . length ; // ok! }"
                },
                {
                    "type": "p",
                    "text": "A truthiness check will infer a type predicate for object types, where there’s no ambiguity.\r\nRemember that functions must return a boolean to be a candidate for an inferred type predicate: x => !!x might infer a type predicate, but x => x definitely won’t. Explicit type predicates continue to work exactly as before.\r\nTypeScript will not check whether it would infer the same type predicate.\r\nExplicit type predicates (“is”) are no safer than a type assertion (“as”). It’s possible that this feature will break existing code if TypeScript now infers a more precise type than you want. For example:"
                },
                {
                    "type": "code",
                    "code": "tsx // Previously, nums: (number | null)[] // Now, nums: number[] const nums = [ 1 , 2 , 3 , null , 5 ]. filter ( x => x !== null ); nums . push ( null ); // ok in TS 5.4, error in TS 5.5"
                },
                {
                    "type": "p",
                    "text": "The fix is to tell TypeScript the type that you want using an explicit type annotation:"
                },
                {
                    "type": "code",
                    "code": "tsx const nums : ( number | null )[] = [ 1 , 2 , 3 , null , 5 ]. filter ( x => x !== null ); nums . push ( null ); // ok in all versions"
                },
                {
                    "type": "p",
                    "text": "For more information, check out the implementing pull request and Dan’s blog post about implementing this feature . TypeScript is now able to narrow expressions of the form obj[key] when both obj and key are effectively constant."
                },
                {
                    "type": "code",
                    "code": "ts function f1 ( obj : Record < string , unknown >, key : string ) { if ( typeof obj [ key ] === \"string\" ) { // Now okay, previously was error obj [ key ]. toUpperCase (); } }"
                },
                {
                    "type": "p",
                    "text": "In the above, neither obj nor key are ever mutated, so TypeScript can narrow the type of obj[key] to string after the typeof check.\r\nFor more information, see the implementing pull request here . Today, if you want to import something only for type-checking in a JavaScript file, it is cumbersome.\r\nJavaScript developers can’t simply import a type named SomeType if it’s not there at runtime."
                },
                {
                    "type": "code",
                    "code": "js // ./some-module.d.ts export interface SomeType { // ... } // ./index.js import { SomeType } from \"./some-module\" ; // ❌ runtime error! /** * @param {SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "SomeType won’t exist at runtime, so the import will fail.\r\nDevelopers can instead use a namespace import instead."
                },
                {
                    "type": "code",
                    "code": "js import * as someModule from \"./some-module\" ; /** * @param {someModule.SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "But ./some-module is still imported at runtime - which might also not be desirable. To avoid this, developers typically had to use import(...) types in JSDoc comments."
                },
                {
                    "type": "code",
                    "code": "js /** * @param {import(\"./some-module\").SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "If you wanted to reuse the same type in multiple places, you could use a typedef to avoid repeating the import."
                },
                {
                    "type": "code",
                    "code": "js /** * @typedef {import(\"./some-module\").SomeType} SomeType */ /** * @param {SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "This helps with local uses of SomeType , but it gets repetitive for many imports and can be a bit verbose. That’s why TypeScript now supports a new @import comment tag that has the same syntax as ECMAScript imports."
                },
                {
                    "type": "code",
                    "code": "js /** @import { SomeType } from \"some-module\" */ /** * @param {SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "Here, we used named imports.\r\nWe could also have written our import as a namespace import."
                },
                {
                    "type": "code",
                    "code": "js /** @import * as someModule from \"some-module\" */ /** * @param {someModule.SomeType} myValue */ function doSomething ( myValue ) { // ... }"
                },
                {
                    "type": "p",
                    "text": "Because these are just JSDoc comments, they don’t affect runtime behavior at all. We would like to extend a big thanks to Oleksandr Tarasiuk who contributed this change ! Until now, TypeScript has typically skipped over most regular expressions in code.\r\nThis is because regular expressions technically have an extensible grammar and TypeScript never made any effort to compile regular expressions to earlier versions of JavaScript.\r\nStill, this meant that lots of common problems would go undiscovered in regular expressions, and they would either turn into errors at runtime, or silently fail. But TypeScript now does basic syntax checking on regular expressions!"
                },
                {
                    "type": "code",
                    "code": "ts let myRegex = /@robot ( \\s + ( please | immediately )) ) ? do some task/ ; //                                            ~ // error! // Unexpected ')'. Did you mean to escape it with backslash?"
                },
                {
                    "type": "p",
                    "text": "This is a simple example, but this checking can catch a lot of common mistakes.\r\nIn fact, TypeScript’s checking goes slightly beyond syntactic checks.\r\nFor instance, TypeScript can now catch issues around backreferences that don’t exist."
                },
                {
                    "type": "code",
                    "code": "ts let myRegex = /@typedef \\{ import \\( ( . + ) \\)\\. ([ a-zA-Z_ ] + ) \\} \\3 / u ; //                                                        ~ // error! // This backreference refers to a group that does not exist. // There are only 2 capturing groups in this regular expression."
                },
                {
                    "type": "p",
                    "text": "The same applies to named capturing groups."
                },
                {
                    "type": "code",
                    "code": "ts let myRegex = /@typedef \\{ import \\( (?< importPath > . + ) \\)\\. (?< importedEntity >[ a-zA-Z_ ] + ) \\} \\k< namedImport > / ; //                                                                                        ~~~~~~~~~~~ // error! // There is no capturing group named 'namedImport' in this regular expression."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s checking is now also aware of when certain RegExp features are used when newer than your target version of ECMAScript.\r\nFor example, if we use named capturing groups like the above in an ES5 target, we’ll get an error."
                },
                {
                    "type": "code",
                    "code": "ts let myRegex = /@typedef \\{ import \\( (?< importPath > . + ) \\)\\. (?< importedEntity >[ a-zA-Z_ ] + ) \\} \\k< importedEntity > / ; //                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~ // error! // Named capturing groups are only available when targeting 'ES2018' or later."
                },
                {
                    "type": "p",
                    "text": "The same is true for certain regular expression flags as well. Note that TypeScript’s regular expression support is limited to regular expression literals .\r\nIf you try calling new RegExp with a string literal, TypeScript will not check the provided string. We would like to thank GitHub user graphemecluster who iterated a ton with us to get this feature into TypeScript . TypeScript 5.5 declares new proposed methods for the ECMAScript Set type . Some of these methods, like union , intersection , difference , and symmetricDifference , take another Set and return a new Set as the result.\r\nThe other methods, isSubsetOf , isSupersetOf , and isDisjointFrom , take another Set and return a boolean .\r\nNone of these methods mutate the original Set s. Here’s a quick example of how you might use these methods and how they behave:"
                },
                {
                    "type": "code",
                    "code": "ts let fruits = new Set ([ \"apples\" , \"bananas\" , \"pears\" , \"oranges\" ]); let applesAndBananas = new Set ([ \"apples\" , \"bananas\" ]); let applesAndOranges = new Set ([ \"apples\" , \"oranges\" ]); let oranges = new Set ([ \"oranges\" ]); let emptySet = new Set (); //// // union //// // Set(4) {'apples', 'bananas', 'pears', 'oranges'} console . log ( fruits . union ( oranges )); // Set(3) {'apples', 'bananas', 'oranges'} console . log ( applesAndBananas . union ( oranges )); //// // intersection //// // Set(2) {'apples', 'bananas'} console . log ( fruits . intersection ( applesAndBananas )); // Set(0) {} console . log ( applesAndBananas . intersection ( oranges )); // Set(1) {'apples'} console . log ( applesAndBananas . intersection ( applesAndOranges )); //// // difference //// // Set(3) {'apples', 'bananas', 'pears'} console . log ( fruits . difference ( oranges )); // Set(2) {'pears', 'oranges'} console . log ( fruits . difference ( applesAndBananas )); // Set(1) {'bananas'} console . log ( applesAndBananas . difference ( applesAndOranges )); //// // symmetricDifference //// // Set(2) {'bananas', 'oranges'} console . log ( applesAndBananas . symmetricDifference ( applesAndOranges )); // no apples //// // isDisjointFrom //// // true console . log ( applesAndBananas . isDisjointFrom ( oranges )); // false console . log ( applesAndBananas . isDisjointFrom ( applesAndOranges )); // true console . log ( fruits . isDisjointFrom ( emptySet )); // true console . log ( emptySet . isDisjointFrom ( emptySet )); //// // isSubsetOf //// // true console . log ( applesAndBananas . isSubsetOf ( fruits )); // false console . log ( fruits . isSubsetOf ( applesAndBananas )); // false console . log ( applesAndBananas . isSubsetOf ( oranges )); // true console . log ( fruits . isSubsetOf ( fruits )); // true console . log ( emptySet . isSubsetOf ( fruits )); //// // isSupersetOf //// // true console . log ( fruits . isSupersetOf ( applesAndBananas )); // false console . log ( applesAndBananas . isSupersetOf ( fruits )); // false console . log ( applesAndBananas . isSupersetOf ( oranges )); // true console . log ( fruits . isSupersetOf ( fruits )); // false console . log ( emptySet . isSupersetOf ( fruits ));"
                },
                {
                    "type": "p",
                    "text": "We’d like to thank Kevin Gibbons who not only co-championed the feature in ECMAScript, but also provided the declarations for Set , ReadonlySet , and ReadonlySetLike in TypeScript ! This section was co-authored by Rob Palmer who supported the design of isolated declarations. Declaration files (a.k.a. .d.ts files) describe the shape of existing libraries and modules to TypeScript.\r\nThis lightweight description includes the library’s type signatures and excludes implementation details such as the function bodies.\r\nThey are published so that TypeScript can efficiently check your usage of a library without needing to analyse the library itself.\r\nWhilst it is possible to handwrite declaration files, if you are authoring typed code, it’s much safer and simpler to let TypeScript generate them automatically from source files using --declaration . The TypeScript compiler and its APIs have always had the job of generating declaration files;\r\nhowever, there are some use-cases where you might want to use other tools, or where the traditional build process doesn’t scale. Imagine if you wanted to create a faster tool to generate declaration files, perhaps as part of a publishing service or a new bundler.\r\nWhilst there is a thriving ecosystem of blazing fast tools that can turn TypeScript into JavaScript, the same is not true for turning TypeScript into declaration files.\r\nThe reason is that TypeScript’s inference allows us to write code without explicitly declaring types, meaning declaration emit can be complex. Let’s consider a simple example of a function that adds two imported variables."
                },
                {
                    "type": "code",
                    "code": "ts // util.ts export let one = \"1\" ; export let two = \"2\" ; // add.ts import { one , two } from \"./util\" ; export function add () { return one + two ; }"
                },
                {
                    "type": "p",
                    "text": "Even if the only thing we want to do is generate add.d.ts , TypeScript needs to crawl into another imported file ( util.ts ), infer that the type of one and two are strings, and then calculate that the + operator on two strings will lead to a string return type."
                },
                {
                    "type": "code",
                    "code": "ts // add.d.ts export declare function add (): string ;"
                },
                {
                    "type": "p",
                    "text": "While this inference is important for the developer experience, it means that tools that want to generate declaration files would need to replicate parts of the type-checker including inference and the ability to resolve module specifiers to follow the imports. Imagine if you had a monorepo containing many projects and a multi-core CPU that just wished it could help you check your code faster.\r\nWouldn’t it be great if we could check all those projects at the same time by running each project on a different core? Unfortunately we don’t have the freedom to do all the work in parallel.\r\nThe reason is that we have to build those projects in dependency order, because each project is checking against the declaration files of their dependencies.\r\nSo we must build the dependency first to generate the declaration files.\r\nTypeScript’s project references feature works the same way, building the set of projects in “topological” dependency order. As an example, if we have two projects called backend and frontend , and they both depend on a project called core , TypeScript can’t start type-checking either frontend or backend until core has been built and its declaration files have been generated. In the above graph, you can see that we have a bottleneck.\r\nWhilst we can build frontend and backend in parallel, we need to first wait for core to finish building before either can start. How could we improve upon this?\r\nWell, if a fast tool could generate all those declaration files for core in parallel , TypeScript then could immediately follow that by type-checking core , frontend , and backend also in parallel . The common requirement in both use-cases is that we need a cross-file type-checker to generate declaration files.\r\nWhich is a lot to ask from the tooling community. As a more complex example, if we want a declaration file for the following code…"
                },
                {
                    "type": "code",
                    "code": "ts import { add } from \"./add\" ; const x = add (); export function foo () { return x ; }"
                },
                {
                    "type": "p",
                    "text": "…we would need to generate a signature for foo .\r\nWell that requires looking at the implementation of foo . foo just returns x , so getting the type of x requires looking at the implementation of add .\r\nBut that might require looking at the implementation of add ’s dependencies, and so on.\r\nWhat we’re seeing here is that generating declaration files requires a whole lot of logic to figure out the types of different places that might not even be local to the current file. Still, for developers looking for fast iteration time and fully parallel builds, there is another way of thinking about this problem.\r\nA declaration file only requires the types of the public API of a module - in other words, the types of the things that are exported.\r\nIf, controversially, developers are willing to explicitly write out the types of the things they export, tools could generate declaration files without needing to look at the implementation of the module - and without reimplementing a full type-checker. This is where the new --isolatedDeclarations option comes in. --isolatedDeclarations reports errors when a module can’t be reliably transformed without a type-checker.\r\nMore plainly, it makes TypeScript report errors if you have a file that isn’t sufficiently annotated on its exports. That means in the above example, we would see an error like the following:"
                },
                {
                    "type": "code",
                    "code": "ts export function foo () { //              ~~~ // error! Function must have an explicit // return type annotation with --isolatedDeclarations. return x ; }"
                },
                {
                    "type": "p",
                    "text": "Because it means that TypeScript can"
                },
                {
                    "type": "list",
                    "items": [
                        "Tell us up-front whether other tools will have issues with generating declaration files",
                        "Provide a quick fix to help add these missing annotations."
                    ]
                },
                {
                    "type": "p",
                    "text": "This mode doesn’t require annotations everywhere though.\r\nFor locals, these can be ignored, since they don’t affect the public API.\r\nFor example, the following code would not produce an error:"
                },
                {
                    "type": "code",
                    "code": "ts import { add } from \"./add\" ; const x = add ( \"1\" , \"2\" ); // no error on 'x', it's not exported. export function foo (): string { return x ; }"
                },
                {
                    "type": "p",
                    "text": "There are also certain expressions where the type is “trivial” to calculate."
                },
                {
                    "type": "code",
                    "code": "ts // No error on 'x'. // It's trivial to calculate the type is 'number' export let x = 10 ; // No error on 'y'. // We can get the type from the return expression. export function y () { return 20 ; } // No error on 'z'. // The type assertion makes it clear what the type is. export function z () { return Math . max ( x , y ()) as number ; }"
                },
                {
                    "type": "p",
                    "text": "isolatedDeclarations requires that either the declaration or composite flags are also set. Note that isolatedDeclarations does not change how TypeScript performs emit - just how it reports errors.\r\nImportantly, and similar to isolatedModules , enabling the feature in TypeScript won’t immediately bring about the potential benefits discussed here.\r\nSo please be patient and look forward to future developments in this space.\r\nKeeping tool authors in mind, we should also recognize that today, not all of TypeScript’s declaration emit can be easily replicated by other tools wanting to use it as a guide.\r\nThat’s something we’re actively working on improving. On top of this, isolated declarations are still a new feature, and we’re actively working on improving the experience.\r\nSome scenarios, like using computed property declarations in classes and object literals, are not yet supported under isolatedDeclarations .\r\nKeep an eye on this space, and feel free to provide us with feedback. We also feel it is worth calling out that isolatedDeclarations should be adopted on a case-by-case basis.\r\nThere are some developer ergonomics that are lost when using isolatedDeclarations , and thus it may not be the right choice if your setup is not leveraging the two scenarios mentioned earlier.\r\nFor others, the work on isolatedDeclarations has already uncovered many optimizations and opportunities to unlock different parallel build strategies.\r\nIn the meantime, if you’re willing to make the trade-offs, we believe isolatedDeclarations can be a powerful tool to speed up your build process as external tooling becomes more widely available. For more information, read up on the Isolated Declarations: State of the Feature discussion on the TypeScript issue tracker. Work on isolatedDeclarations has been a long-time collaborative effort between the TypeScript team and the infrastructure and tooling teams within Bloomberg and Google.\r\nIndividuals like Hana Joo from Google who implemented the quick fix for isolated declaration errors (more on that soon), as well as Ashley Claymore, Jan Kühle, Lisa Velden, Rob Palmer, and Thomas Chetwin have been involved in discussion, specification, and implementation for many months.\r\nBut we feel it is specifically worth calling out the tremendous amount of work provided by Titian Cernicova-Dragomir from Bloomberg.\r\nTitian has been instrumental in driving the implementation of isolatedDeclarations and has been a contributor to the TypeScript project for years prior. While the feature involved many changes, you can see the core work for Isolated Declarations here . It’s common in many codebases to reuse a shared tsconfig.json file that acts as a “base” for other configuration files.\r\nThis is done by using the extends field in a tsconfig.json file."
                },
                {
                    "type": "code",
                    "code": "json { \"extends\" : \"../../tsconfig.base.json\" , \"compilerOptions\" : { \"outDir\" : \"./dist\" } }"
                },
                {
                    "type": "p",
                    "text": "One of the issues with this is that all paths in the tsconfig.json file are relative to the location of the file itself.\r\nThis means that if you have a shared tsconfig.base.json file that is used by multiple projects, relative paths often won’t be useful in the derived projects.\r\nFor example, imagine the following tsconfig.base.json :"
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"typeRoots\" : [ \"./node_modules/@types\" \"./custom-types\" ], \"outDir\" : \"dist\" } }"
                },
                {
                    "type": "p",
                    "text": "If author’s intent was that every tsconfig.json that extends this file should"
                },
                {
                    "type": "list",
                    "items": [
                        "output to a dist directory relative to the derived tsconfig.json , and",
                        "have a custom-types directory relative to the derived tsconfig.json ,"
                    ]
                },
                {
                    "type": "p",
                    "text": "then this would not work.\r\nThe typeRoots paths would be relative to the location of the shared tsconfig.base.json file, not the project that extends it.\r\nEach project that extends this shared file would need to declare its own outDir and typeRoots with identical contents.\r\nThis could be frustrating and hard to keep in sync between projects, and while the example above is using typeRoots , this is a common problem for paths and other options. To solve this, TypeScript 5.5 introduces a new template variable ${configDir} .\r\nWhen ${configDir} is written in certain path fields of a tsconfig.json or jsconfig.json files, this variable is substituted with the containing directory of the configuration file in a given compilation.\r\nThis means that the above tsconfig.base.json could be rewritten as:"
                },
                {
                    "type": "code",
                    "code": "json { \"compilerOptions\" : { \"typeRoots\" : [ \"${configDir}/node_modules/@types\" \"${configDir}/custom-types\" ], \"outDir\" : \"${configDir}/dist\" } }"
                },
                {
                    "type": "p",
                    "text": "Now, when a project extends this file, the paths will be relative to the derived tsconfig.json , not the shared tsconfig.base.json file.\r\nThis makes it easier to share configuration files across projects and ensures that the configuration files are more portable. If you intend to make a tsconfig.json file extendable, consider if a ./ should instead be written with ${configDir} . For more information, see the proposal issue and the implementing pull request . Previously, TypeScript would often issue an error message like"
                },
                {
                    "type": "code",
                    "code": "The inferred type of \"X\" cannot be named without a reference to \"Y\". This is likely not portable. A type annotation is necessary."
                },
                {
                    "type": "p",
                    "text": "This was often due to TypeScript’s declaration file generation finding itself in the contents of files that were never explicitly imported in a program.\r\nGenerating an import to such a file could be risky if the path ended up being relative.\r\nStill, for codebases with explicit dependencies in the dependencies (or peerDependencies and optionalDependencies ) of a package.json , generating such an import should be safe under certain resolution modes.\r\nSo in TypeScript 5.5, we’re more lenient when that’s the case, and many occurrences of this error should disappear. See this pull request for more details on the change. TypeScript has either added some new functionality or fixed existing logic that makes --watch mode and TypeScript’s editor integration feel more reliable.\r\nThat should hopefully translate to fewer TSServer/editor restarts. TypeScript can generate errors for tsconfig.json files;\r\nhowever, those errors are actually generated from loading a project, and editors typically don’t directly request those errors for tsconfig.json files.\r\nWhile this sounds like a technical detail, it means that when all errors issued in a tsconfig.json are fixed, TypeScript doesn’t issue a new fresh empty set of errors, and users are left with stale errors unless they reload their editor. TypeScript 5.5 now intentionally issues an event to clear these out. See more here . Instead of overwriting files, some tools will opt to delete them and then create new files from scratch.\r\nThis is the case when running npm ci , for instance. While this can be efficient for those tools, it can be problematic for TypeScript’s editor scenarios where deleting a watched might dispose of it and all of its transitive dependencies.\r\nDeleting and creating a file in quick succession could lead to TypeScript tearing down an entire project and then rebuilding it from scratch. TypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted project around until it picks up on a new creation event.\r\nThis should make operations like npm ci work a lot better with TypeScript.\r\nSee more information on the approach here . When TypeScript fails to resolve a module, it will still need to watch for any failed lookup paths in case the module is added later.\r\nPreviously this was not done for symlinked directories, which could cause reliability issues in monorepo-like scenarios when a build occurred in one project but was not witnessed in the other.\r\nThis should be fixed in TypeScript 5.5, and means you won’t need to restart your editor as often. Auto-imports no longer requires at least one explicit import to dependent projects in a project reference setup.\r\nInstead, auto-import completions should just work across anything you’ve listed in the references field of your tsconfig.json . See more on the implementing pull request . In TypeScript 5.0, we ensured that our Node and Symbol objects had a consistent set of properties with a consistent initialization order.\r\nDoing so helps reduce polymorphism in different operations, which allows runtimes to fetch properties more quickly. By making this change, we witnessed impressive speed wins in the compiler;\r\nhowever, most of these changes were performed on internal allocators for our data structures.\r\nThe language service, along with TypeScript’s public API, uses a different set of allocators for certain objects.\r\nThis allowed the TypeScript compiler to be a bit leaner, as data used only for the language service would never be used in the compiler. In TypeScript 5.5, the same monomorphization work has been done for the language service and public API.\r\nWhat this means is that your editor experience, and any build tools that use the TypeScript API, will get a decent amount faster.\r\nIn fact, in our benchmarks, we’ve seen a 5-8% speedup in build times when using the public TypeScript API’s allocators, and language service operations getting 10-20% faster .\r\nWhile this does imply an increase in memory, we believe that tradeoff is worth it and hope to find ways to reduce that memory overhead.\r\nThings should feel a lot snappier now. For more information, see the change here . In TypeScript 5.5, nodes of the control flow graph have been monomorphized so that they always hold a consistent shape.\r\nBy doing so, check times will often be reduced by about 1%. In many cases, control flow analysis will traverse nodes that don’t provide any new information.\r\nWe observed that in the absence of any early termination or effects in the antecedents (or “dominators”) of certain nodes meant that those nodes could always be skipped over.\r\nAs such, TypeScript now constructs its control flow graphs to take advantage of this by linking to an earlier node that does provide interesting information for control flow analysis.\r\nThis yields a flatter control flow graph, which can be more efficient to traverse.\r\nThis optimization has yielded modest gains, but with up to 2% reductions in build time on certain codebases. You can read more here . TypeScript’s transpileModule API can be used for compiling a single TypeScript file’s contents into JavaScript.\r\nSimilarly, the transpileDeclaration API (see below) can be used to generate a declaration file for a single TypeScript file.\r\nOne of the issues with these APIs is that TypeScript internally would perform a full type-checking pass over the entire contents of the file before emitting the output.\r\nThis was necessary to collect certain information which would later be used for the emit phase. In TypeScript 5.5, we’ve found a way to avoid performing a full check, only lazily collecting this information as necessary, and transpileModule and transpileDeclaration both enable this functionality by default.\r\nAs a result, tools that integrate with these APIs, like ts-loader with transpileOnly and ts-jest , should see a noticeable speedup.\r\nIn our testing, we generally witness around a 2x speed-up in build time using transpileModule . Further leveraging our transition to modules in 5.0 , we’ve significantly reduced TypeScript’s overall package size by making tsserver.js and typingsInstaller.js import from a common API library instead of having each of them produce standalone bundles . This reduces TypeScript’s size on disk from 30.2 MB to 20.4 MB, and reduces its packed size from 5.5 MB to 3.7 MB! As part of the work to enable isolatedDeclarations , we’ve substantially improved how often TypeScript can directly copy your input source code when producing declaration files. For example, let’s say you wrote"
                },
                {
                    "type": "code",
                    "code": "ts export const strBool : string | boolean = \"hello\" ; export const boolStr : boolean | string = \"world\" ;"
                },
                {
                    "type": "p",
                    "text": "Note that the union types are equivalent, but the order of the union is different.\r\nWhen emitting the declaration file, TypeScript has two equivalent output possibilities. The first is to use a consistent canonical representation for each type:"
                },
                {
                    "type": "code",
                    "code": "ts export const strBool : string | boolean ; export const boolStr : string | boolean ;"
                },
                {
                    "type": "p",
                    "text": "The second is to re-use the type annotations exactly as written:"
                },
                {
                    "type": "code",
                    "code": "ts export const strBool : string | boolean ; export const boolStr : boolean | string ;"
                },
                {
                    "type": "p",
                    "text": "The second approach is generally preferable for a few reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "Many equivalent representations still encode some level of intent that is better to preserve in the declaration file",
                        "Producing a fresh representation of a type can be somewhat expensive, so avoiding is better",
                        "User-written types are usually shorter than generated type representations"
                    ]
                },
                {
                    "type": "p",
                    "text": "In 5.5, we’ve greatly improved the number of places where TypeScript can correctly identify places where it’s safe and correct to print back types exactly as they were written in the input file.\r\nMany of these cases are invisible performance improvements - TypeScript would generate fresh sets of syntax nodes and serialize them into a string.\r\nInstead, TypeScript can now operate over the original syntax nodes directly, which is much cheaper and faster. When TypeScript asks for the contextual type of an expression like an object literal, it will often encounter a union type.\r\nIn those cases, TypeScript tries to filter out members of the union based on known properties with well known values (i.e. discriminant properties).\r\nThis work can be fairly expensive, especially if you end up with an object consisting of many many properties.\r\nIn TypeScript 5.5, much of the computation is cached once so that TypeScript doesn’t need to recompute it for every property in the object literal .\r\nPerforming this optimization shaved 250ms off of compiling the TypeScript compiler itself. Previously, if you were writing an ECMAScript module in Node.js, named imports were not available from the typescript package."
                },
                {
                    "type": "code",
                    "code": "ts import { createSourceFile } from \"typescript\" ; // ❌ error import * as ts from \"typescript\" ; ts . createSourceFile // ❌ undefined??? ts . default . createSourceFile // ✅ works - but ugh!"
                },
                {
                    "type": "p",
                    "text": "This is because cjs-module-lexer did not recognize the pattern of TypeScript’s generated CommonJS code.\r\nThis has been fixed, and users can now use named imports from the TypeScript npm package with ECMAScript modules in Node.js."
                },
                {
                    "type": "code",
                    "code": "ts import { createSourceFile } from \"typescript\" ; // ✅ works now! import * as ts from \"typescript\" ; ts . createSourceFile // ✅ works now!"
                },
                {
                    "type": "p",
                    "text": "For more information, see the change here . TypeScript’s API exposes a function called transpileModule .\r\nIt’s intended to make it easy to compile a single file of TypeScript code.\r\nBecause it doesn’t have access to an entire program , the caveat is that it may not produce the right output if the code violates any errors under the isolatedModules option. In TypeScript 5.5, we’ve added a new similar API called transpileDeclaration .\r\nThis API is similar to transpileModule , but it’s specifically designed to generate a single declaration file based on some input source text.\r\nJust like transpileModule , it doesn’t have access to a full program, and a similar caveat applies: it only generates an accurate declaration file if the input code is free of errors under the new isolatedDeclarations option. If desired, this function can be used to parallelize declaration emit across all files under isolatedDeclarations mode. For more information, see the implementation here . This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade.\r\nSometimes it will highlight deprecations, removals, and new restrictions.\r\nIt can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors. TypeScript 5.0 deprecated the following options and behaviors:"
                },
                {
                    "type": "list",
                    "items": [
                        "charset",
                        "target: ES3",
                        "importsNotUsedAsValues",
                        "noImplicitUseStrict",
                        "noStrictGenericChecks",
                        "keyofStringsOnly",
                        "suppressExcessPropertyErrors",
                        "suppressImplicitAnyIndexErrors",
                        "out",
                        "preserveValueImports",
                        "prepend in project references",
                        "implicitly OS-specific newLine"
                    ]
                },
                {
                    "type": "p",
                    "text": "To continue using the deprecated options above, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called ignoreDeprecations with the value \"5.0\" . In TypeScript 5.5, these options no longer have any effect.\r\nTo help with a smooth upgrade path, you may still specify them in your tsconfig, but these will be an error to specify in TypeScript 6.0.\r\nSee also the Flag Deprecation Plan which outlines our deprecation strategy. More information around these deprecation plans is available on GitHub , which contains suggestions in how to best adapt your codebase. Types generated for the DOM may have an impact on type-checking your codebase.\r\nFor more information, see the DOM updates for TypeScript 5.5 . Since TypeScript originally introduced support for decorators, the specified grammar for the proposal has been tightened up.\r\nTypeScript is now stricter about what forms it allows.\r\nWhile rare, existing decorators may need to be parenthesized to avoid errors."
                },
                {
                    "type": "code",
                    "code": "ts class DecoratorProvider { decorate (... args : any []) { } } class D extends DecoratorProvider { m () { class C { @ super . decorate // ❌ error method1 () { } @( super . decorate ) // ✅ okay method2 () { } } } }"
                },
                {
                    "type": "p",
                    "text": "See more information on the change here . TypeScript has always disallowed type alias names that conflict with built-in types:"
                },
                {
                    "type": "code",
                    "code": "ts // Illegal type null = any ; // Illegal type number = any ; // Illegal type object = any ; // Illegal type any = any ;"
                },
                {
                    "type": "p",
                    "text": "Due to a bug, this logic didn’t also apply to the built-in type undefined .\r\nIn 5.5, this is now correctly identified as an error:"
                },
                {
                    "type": "code",
                    "code": "ts // Now also illegal type undefined = any ;"
                },
                {
                    "type": "p",
                    "text": "Bare references to type aliases named undefined never actually worked in the first place.\r\nYou could define them, but you couldn’t use them as an unqualified type name."
                },
                {
                    "type": "code",
                    "code": "ts export type undefined = string ; export const m : undefined = \"\" ; //           ^ // Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted."
                },
                {
                    "type": "p",
                    "text": "For more information, see the change here . When producing a declaration file, TypeScript would synthesize a reference directive when it believed one was required.\r\nFor example, all Node.js modules are declared ambiently, so cannot be loaded by module resolution alone.\r\nA file like:"
                },
                {
                    "type": "code",
                    "code": "tsx import path from \"path\" ; export const myPath = path . parse ( __filename );"
                },
                {
                    "type": "p",
                    "text": "Would emit a declaration file like:"
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference types = \"node\" /> import path from \"path\" ; export declare const myPath : path . ParsedPath ;"
                },
                {
                    "type": "p",
                    "text": "Even though the reference directive never appeared in the original source. Similarly, TypeScript also removed reference directives that it did not believe needed to be a part of the output.\r\nFor example, let’s imagine we had a reference directive to jest ;\r\nhowever, imagine the reference directive isn’t necessary to generate the declaration file.\r\nTypeScript would simply drop it.\r\nSo in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference types = \"jest\" /> import path from \"path\" ; export const myPath = path . parse ( __filename );"
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference types = \"node\" /> import path from \"path\" ; export declare const myPath : path . ParsedPath ;"
                },
                {
                    "type": "p",
                    "text": "In the course of working on isolatedDeclarations , we realized that this logic was untenable for anyone attempting to implement a declaration emitter without type checking or using more than a single file’s context.\r\nThis behavior is also hard to understand from a user’s perspective; whether or not a reference directive appeared in the emitted file seems inconsistent and difficult to predict unless you understand exactly what’s going on during typechecking.\r\nTo prevent declaration emit from being different when isolatedDeclarations was enabled, we knew that our emit needed to change. Through experimentation , we found that nearly all cases where TypeScript synthesized reference directives were just to pull in node or react .\r\nThese are cases where the expectation is that a downstream user already references those types through tsconfig.json \"types\" or library imports, so no longer synthesizing these reference directives would be unlikely to break anyone.\r\nIt’s worth noting that this is already how it works for lib.d.ts ; TypeScript doesn’t synthesize a reference to lib=\"es2015\" when a module exports a WeakMap , instead assuming that a downstream user will have included that as part of their environment. For reference directives that had been written by library authors (not synthesized), further experimentation showed that nearly all were removed, never showing up in the output.\r\nMost reference directives that were preserved were broken and likely not intended to be preserved. Given those results, we decided to greatly simplfy reference directives in declaration emit in TypeScript 5.5.\r\nA more consistent strategy will help library authors and consumers have better control of their declaration files. Reference directives are no longer synthesized.\r\nUser-written reference directives are no longer preserved, unless annotated with a new preserve=\"true\" attribute.\r\nConcretely, an input file like:"
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference types=\"some-lib\" preserve=\"true\" /> /// <reference types = \"jest\" /> import path from \"path\" ; export const myPath = path . parse ( __filename );"
                },
                {
                    "type": "code",
                    "code": "tsx /// <reference types=\"some-lib\" preserve=\"true\" /> import path from \"path\" ; export declare const myPath : path . ParsedPath ;"
                },
                {
                    "type": "p",
                    "text": "Adding preserve=\"true\" is backwards compatible with older versions of TypeScript as unknown attributes are ignored. This change also improved performance; in our benchmarks, the emit stage saw a 1-4% improvement in projects with declaration emit enabled. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/symbols.html",
            "title": "TypeScript: Documentation - Symbols",
            "content": [
                {
                    "type": "p",
                    "text": "Starting with ECMAScript 2015, symbol is a primitive data type, just like number and string . symbol values are created by calling the Symbol constructor."
                },
                {
                    "type": "code",
                    "code": "ts let sym1 = Symbol (); let sym2 = Symbol ( \"key\" ); // optional string key"
                },
                {
                    "type": "code",
                    "code": "ts let sym2 = Symbol ( \"key\" ); let sym3 = Symbol ( \"key\" ); sym2 === sym3 ; // false, symbols are unique"
                },
                {
                    "type": "p",
                    "text": "Just like strings, symbols can be used as keys for object properties."
                },
                {
                    "type": "code",
                    "code": "ts const sym = Symbol (); let obj = { [sym]: \"value\" , }; console . log ( obj [ sym ]); // \"value\""
                },
                {
                    "type": "p",
                    "text": "Symbols can also be combined with computed property declarations to declare object properties and class members."
                },
                {
                    "type": "code",
                    "code": "ts const getClassNameSymbol = Symbol (); class C { [ getClassNameSymbol ]() { return \"C\" ; } } let c = new C (); let className = c [ getClassNameSymbol ](); // \"C\""
                },
                {
                    "type": "p",
                    "text": "To enable treating symbols as unique literals a special type unique symbol is available. unique symbol is a subtype of symbol , and are produced only from calling Symbol() or Symbol.for() , or from explicit type annotations. This type is only allowed on const declarations and readonly static properties, and in order to reference a specific unique symbol, you’ll have to use the typeof operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration."
                },
                {
                    "type": "code",
                    "code": "ts declare const sym1 : unique symbol ; // sym2 can only be a constant reference. let sym2 : unique symbol = Symbol (); A variable whose type is a 'unique symbol' type must be 'const'. 1332 A variable whose type is a 'unique symbol' type must be 'const'. // Works - refers to a unique symbol, but its identity is tied to 'sym1'. let sym3 : typeof sym1 = sym1 ; // Also works. class C { static readonly StaticSymbol : unique symbol = Symbol (); } Try"
                },
                {
                    "type": "p",
                    "text": "Because each unique symbol has a completely separate identity, no two unique symbol types are assignable or comparable to each other."
                },
                {
                    "type": "code",
                    "code": "ts const sym2 = Symbol (); const sym3 = Symbol (); if ( sym2 === sym3 ) { This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap. 2367 This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap. // ... } Try"
                },
                {
                    "type": "p",
                    "text": "In addition to user-defined symbols, there are well-known built-in symbols.\nBuilt-in symbols are used to represent internal language behaviors. Here is a list of well-known symbols: A method that returns async iterator for an object, compatible to be used with for await..of loop. A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator. A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat. A method that returns the default iterator for an object. Called by the semantics of the for-of statement. A regular expression method that matches the regular expression against a string. Called by the String.prototype.match method. A regular expression method that replaces matched substrings of a string. Called by the String.prototype.replace method. A regular expression method that returns the index within a string that matches the regular expression. Called by the String.prototype.search method. A function valued property that is the constructor function that is used to create derived objects. A regular expression method that splits a string at the indices that match the regular expression.\nCalled by the String.prototype.split method. A method that converts an object to a corresponding primitive value.\nCalled by the ToPrimitive abstract operation. A String value that is used in the creation of the default string description of an object.\nCalled by the built-in method Object.prototype.toString . An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",
            "title": "TypeScript: Documentation - Triple-Slash Directives",
            "content": [
                {
                    "type": "p",
                    "text": "Triple-slash directives are single-line comments containing a single XML tag.\nThe contents of the comment are used as compiler directives. Triple-slash directives are only valid at the top of their containing file.\nA triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives.\nIf they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning. As of TypeScript 5.5, the compiler does not generate reference directives, and does not emit handwritten triple-slash directives to output files unless those directives are marked as preserve=\"true\" . The /// <reference path=\"...\" /> directive is the most common of this group.\nIt serves as a declaration of dependency between files. Triple-slash references instruct the compiler to include additional files in the compilation process. They also serve as a method to order the output when using out or outFile .\nFiles are emitted to the output file location in the same order as the input after preprocessing pass. The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives.\nDuring this process, additional files are added to the compilation. The process starts with a set of root files ;\nthese are the file names specified on the command-line or in the files list in the tsconfig.json file.\nThese root files are preprocessed in the same order they are specified.\nBefore a file is added to the list, all triple-slash references in it are processed, and their targets included.\nTriple-slash references are resolved in a depth-first manner, in the order they have been seen in the file. A triple-slash reference path is resolved relative to the containing file, if a relative path is used. It is an error to reference a file that does not exist.\nIt is an error for a file to have a triple-slash reference to itself. If the compiler flag noResolve is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided. Similar to a /// <reference path=\"...\" /> directive, which serves as a declaration of dependency , a /// <reference types=\"...\" /> directive declares a dependency on a package. The process of resolving these package names is similar to the process of resolving module names in an import statement.\nAn easy way to think of triple-slash-reference-types directives are as an import for declaration packages. For example, including /// <reference types=\"node\" /> in a declaration file declares that this file uses names declared in @types/node/index.d.ts ;\nand thus, this package needs to be included in the compilation along with the declaration file. For declaring a dependency on an @types package in a .ts file, use types on the command line or in your tsconfig.json instead.\nSee using @types , typeRoots and types in tsconfig.json files for more details. This directive allows a file to explicitly include an existing built-in lib file. Built-in lib files are referenced in the same fashion as the lib compiler option in tsconfig.json (e.g. use lib=\"es2015\" and not lib=\"lib.es2015.d.ts\" , etc.). For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like Symbol or Iterable , triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types. For example, adding /// <reference lib=\"es2017.string\" /> to one of the files in a compilation is equivalent to compiling with --lib es2017.string ."
                },
                {
                    "type": "code",
                    "code": "ts /// <reference lib = \"es2017.string\" /> \"foo\" . padStart ( 4 );"
                },
                {
                    "type": "p",
                    "text": "This directive marks a file as a default library .\nYou will see this comment at the top of lib.d.ts and its different variants. This directive instructs the compiler to not include the default library (i.e. lib.d.ts ) in the compilation.\nThe impact here is similar to passing noLib on the command line. Also note that when passing skipDefaultLibCheck , the compiler will only skip checking files with /// <reference no-default-lib=\"true\"/> . By default AMD modules are generated anonymous.\nThis can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. r.js ). The amd-module directive allows passing an optional module name to the compiler:"
                },
                {
                    "type": "code",
                    "code": "ts /// <amd-module name = \"NamedModule\" /> export class C {}"
                },
                {
                    "type": "p",
                    "text": "Will result in assigning the name NamedModule to the module as part of calling the AMD define :"
                },
                {
                    "type": "code",
                    "code": "js define ( \"NamedModule\" , [ \"require\" , \"exports\" ], function ( require , exports ) { var C = ( function () { function C () {} return C ; })(); exports . C = C ; });"
                },
                {
                    "type": "p",
                    "text": "Note : this directive has been deprecated. Use import \"moduleName\"; statements instead. /// <amd-dependency path=\"x\" /> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call. The amd-dependency directive can also have an optional name property; this allows passing an optional name for an amd-dependency:"
                },
                {
                    "type": "code",
                    "code": "ts /// <amd-dependency path = \"legacy/moduleA\" name = \"moduleA\" /> declare var moduleA : MyType ; moduleA . callStuff ();"
                },
                {
                    "type": "code",
                    "code": "js define ([ \"require\" , \"exports\" , \"legacy/moduleA\" ], function ( require , exports , moduleA ) { moduleA . callStuff (); });"
                },
                {
                    "type": "p",
                    "text": "Triple-slash directives can be marked with preserve=\"true\" to prevent the compiler from removing them from the output. For example, these will be erased in the output:"
                },
                {
                    "type": "code",
                    "code": "ts /// <reference path = \"...\" /> /// <reference types = \"...\" /> /// <reference lib = \"...\" />"
                },
                {
                    "type": "code",
                    "code": "ts /// <reference path=\"...\" preserve=\"true\" /> /// <reference types=\"...\" preserve=\"true\" /> /// <reference lib=\"...\" preserve=\"true\" />"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
            "title": "TypeScript: Documentation - What is a tsconfig.json",
            "content": [
                {
                    "type": "p",
                    "text": "The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project.\nThe tsconfig.json file specifies the root files and the compiler options required to compile the project. JavaScript projects can use a jsconfig.json file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default. A project is compiled in one of the following ways:"
                },
                {
                    "type": "list",
                    "items": [
                        "By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.",
                        "By invoking tsc with no input files and a --project (or just -p ) command line option that specifies the path of a directory containing a tsconfig.json file, or a path to a valid .json file containing the configurations."
                    ]
                },
                {
                    "type": "p",
                    "text": "When input files are specified on the command line, tsconfig.json files are ignored."
                },
                {
                    "type": "list",
                    "items": [
                        "Using the files property { \" compilerOptions \" : { \" module \" : \"commonjs\" , \" noImplicitAny \" : true , \" removeComments \" : true , \" preserveConstEnums \" : true , \" sourceMap \" : true }, \" files \" : [ \"core.ts\" , \"sys.ts\" , \"types.ts\" , \"scanner.ts\" , \"parser.ts\" , \"utilities.ts\" , \"binder.ts\" , \"checker.ts\" , \"emitter.ts\" , \"program.ts\" , \"commandLineParser.ts\" , \"tsc.ts\" , \"diagnosticInformationMap.generated.ts\" ] }",
                        "Using the include and exclude properties { \" compilerOptions \" : { \" module \" : \"system\" , \" noImplicitAny \" : true , \" removeComments \" : true , \" preserveConstEnums \" : true , \" outFile \" : \"../../built/local/tsc.js\" , \" sourceMap \" : true }, \" include \" : [ \"src/**/*\" ], \" exclude \" : [ \"**/*.spec.ts\" ] }"
                    ]
                },
                {
                    "type": "p",
                    "text": "Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at github.com/tsconfig/bases .\nThese are tsconfig.json files which your project extends from which simplifies your tsconfig.json by handling the runtime support. For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module @tsconfig/node12 :"
                },
                {
                    "type": "code",
                    "code": "{ \" extends \" : \"@tsconfig/node12/tsconfig.json\" , \" compilerOptions \" : { \" preserveConstEnums \" : true }, \" include \" : [ \"src/**/*\" ], \" exclude \" : [ \"**/*.spec.ts\" ] }"
                },
                {
                    "type": "p",
                    "text": "This lets your tsconfig.json focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments. The \"compilerOptions\" property can be omitted, in which case the compiler’s defaults are used. See our full list of supported Compiler Options . To learn more about the hundreds of configuration options in the TSConfig Reference . The tsconfig.json Schema can be found at the JSON Schema Store . The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html",
            "title": "TypeScript: Documentation - Type Checking JavaScript Files",
            "content": [
                {
                    "type": "p",
                    "text": "Here are some notable differences on how checking works in .js files compared to .ts files. ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals. In a .js file, the compiler infers properties from property assignments inside the class body.\nThe type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null.\nIn that case, the type is the union of the types of all the right-hand values in these assignments.\nProperties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional."
                },
                {
                    "type": "code",
                    "code": "js class C { constructor () { this . constructorOnly = 0 ; this . constructorUnknown = undefined ; } method () { this . constructorOnly = false ; Type 'boolean' is not assignable to type 'number'. 2322 Type 'boolean' is not assignable to type 'number'. this . constructorUnknown = \"plunkbat\" ; // ok, constructorUnknown is string | undefined this . methodOnly = \"ok\" ; // ok, but methodOnly could also be undefined } method2 () { this . methodOnly = true ; // also, ok, methodOnly's type is string | boolean | undefined } } Try"
                },
                {
                    "type": "p",
                    "text": "If properties are never set in the class body, they are considered unknown.\nIf your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type.\nYou don’t even have to give a value if it will be initialized later:"
                },
                {
                    "type": "code",
                    "code": "js class C { constructor () { /** @type {number | undefined} */ this . prop = undefined ; /** @type {number | undefined} */ this . count ; } } let c = new C (); c . prop = 0 ; // OK c . count = \"string\" ; Type 'string' is not assignable to type 'number'. 2322 Type 'string' is not assignable to type 'number'. Try"
                },
                {
                    "type": "p",
                    "text": "Before ES2015, JavaScript used constructor functions instead of classes.\nThe compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes.\nThe property inference rules described above work exactly the same way."
                },
                {
                    "type": "code",
                    "code": "js function C () { this . constructorOnly = 0 ; this . constructorUnknown = undefined ; } C . prototype . method = function () { this . constructorOnly = false ; Type 'boolean' is not assignable to type 'number'. 2322 Type 'boolean' is not assignable to type 'number'. this . constructorUnknown = \"plunkbat\" ; // OK, the type is string | undefined }; Try"
                },
                {
                    "type": "p",
                    "text": "In a .js file, TypeScript understands the CommonJS module format.\nAssignments to exports and module.exports are recognized as export declarations.\nSimilarly, require function calls are recognized as module imports. For example:"
                },
                {
                    "type": "code",
                    "code": "js // same as `import module \"fs\"` const fs = require ( \"fs\" ); // same as `export function readFile` module . exports . readFile = function ( f ) { return fs . readFileSync ( f ); };"
                },
                {
                    "type": "p",
                    "text": "The module support in JavaScript is much more syntactically forgiving than TypeScript’s module support.\nMost combinations of assignments and declarations are supported. Classes are namespaces in .js files.\nThis can be used to nest classes, for example:"
                },
                {
                    "type": "code",
                    "code": "js class C {} C . D = class {}; Try"
                },
                {
                    "type": "p",
                    "text": "And, for pre-ES2015 code, it can be used to simulate static methods:"
                },
                {
                    "type": "code",
                    "code": "js function Outer () { this . y = 2 ; } Outer . Inner = function () { this . yy = 2 ; }; Outer . Inner (); Try"
                },
                {
                    "type": "p",
                    "text": "It can also be used to create simple namespaces:"
                },
                {
                    "type": "code",
                    "code": "js var ns = {}; ns . C = class {}; ns . func = function () {}; ns ; Try"
                },
                {
                    "type": "p",
                    "text": "Other variants are allowed as well:"
                },
                {
                    "type": "code",
                    "code": "js // IIFE var ns = ( function ( n ) { return n || {}; })(); ns . CONST = 1 ; // defaulting to global var assign = assign || function () { // code goes here }; assign . extra = 1 ; Try"
                },
                {
                    "type": "p",
                    "text": "In a .ts file, an object literal that initializes a variable declaration gives its type to the declaration.\nNo new members can be added that were not specified in the original literal.\nThis rule is relaxed in a .js file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally.\nFor instance:"
                },
                {
                    "type": "code",
                    "code": "js var obj = { a : 1 }; obj . b = 2 ; // Allowed Try"
                },
                {
                    "type": "p",
                    "text": "Object literals behave as if they have an index signature [x:string]: any that allows them to be treated as open maps instead of closed objects. Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {{a: number}} */ var obj = { a : 1 }; obj . b = 2 ; Property 'b' does not exist on type '{ a: number; }'. 2339 Property 'b' does not exist on type '{ a: number; }'. Try"
                },
                {
                    "type": "p",
                    "text": "Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on.\nAny variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on.\nThe only exception is for properties that have multiple initializers as described above."
                },
                {
                    "type": "code",
                    "code": "js function Foo ( i = null ) { if (! i ) i = 1 ; var j = undefined ; j = 2 ; this . l = []; } var foo = new Foo (); foo . l . push ( foo . i ); foo . l . push ( \"end\" ); Try"
                },
                {
                    "type": "p",
                    "text": "Since there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in .js file are considered optional.\nCalls with fewer arguments than the declared number of parameters are allowed. It is important to note that it is an error to call a function with too many arguments."
                },
                {
                    "type": "code",
                    "code": "js function bar ( a , b ) { console . log ( a + \" \" + b ); } bar ( 1 ); // OK, second argument considered optional bar ( 1 , 2 ); bar ( 1 , 2 , 3 ); // Error, too many arguments Expected 0-2 arguments, but got 3. 2554 Expected 0-2 arguments, but got 3. Try"
                },
                {
                    "type": "p",
                    "text": "JSDoc annotated functions are excluded from this rule.\nUse JSDoc optional parameter syntax ( [ ] ) to express optionality. e.g.:"
                },
                {
                    "type": "code",
                    "code": "js /** * @param {string} [somebody] - Somebody's name. */ function sayHello ( somebody ) { if (! somebody ) { somebody = \"John Doe\" ; } console . log ( \"Hello \" + somebody ); } sayHello (); Try"
                },
                {
                    "type": "p",
                    "text": "A function whose body has a reference to the arguments reference is implicitly considered to have a var-arg parameter (i.e. (...arg: any[]) => any ). Use JSDoc var-arg syntax to specify the type of the arguments."
                },
                {
                    "type": "code",
                    "code": "js /** @param {...number} args */ function sum ( /* numbers */ ) { var total = 0 ; for ( var i = 0 ; i < arguments . length ; i ++) { total += arguments [ i ]; } return total ; } Try"
                },
                {
                    "type": "p",
                    "text": "Since there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to any . For instance, React.Component is defined to have two type parameters, Props and State .\nIn a .js file, there is no legal way to specify these in the extends clause. By default the type arguments will be any :"
                },
                {
                    "type": "code",
                    "code": "js import { Component } from \"react\" ; class MyComponent extends Component { render () { this . props . b ; // Allowed, since this.props is of type any } }"
                },
                {
                    "type": "p",
                    "text": "Use JSDoc @augments to specify the types explicitly. for instance:"
                },
                {
                    "type": "code",
                    "code": "js import { Component } from \"react\" ; /** * @augments {Component<{a: number}, State>} */ class MyComponent extends Component { render () { this . props . b ; // Error: b does not exist on {a:number} } }"
                },
                {
                    "type": "p",
                    "text": "An unspecified type argument in JSDoc defaults to any:"
                },
                {
                    "type": "code",
                    "code": "js /** @type {Array} */ var x = []; x . push ( 1 ); // OK x . push ( \"string\" ); // OK, x is of type Array<any> /** @type {Array.<number>} */ var y = []; y . push ( 1 ); // OK y . push ( \"string\" ); // Error, string is not assignable to number Try"
                },
                {
                    "type": "p",
                    "text": "A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to any . For example:"
                },
                {
                    "type": "code",
                    "code": "js var p = new Promise (( resolve , reject ) => { reject (); }); p ; // Promise<any>;"
                },
                {
                    "type": "p",
                    "text": "To learn all of the features available in JSDoc, see the reference . How to add type checking to JavaScript files using TypeScript What JSDoc does TypeScript-powered JavaScript support? The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html",
            "title": "TypeScript: Documentation - Type Compatibility",
            "content": [
                {
                    "type": "p",
                    "text": "Type compatibility in TypeScript is based on structural subtyping.\nStructural typing is a way of relating types based solely on their members.\nThis is in contrast with nominal typing.\nConsider the following code:"
                },
                {
                    "type": "code",
                    "code": "ts interface Pet { name : string ; } class Dog { name : string ; } let pet : Pet ; // OK, because of structural typing pet = new Dog ();"
                },
                {
                    "type": "p",
                    "text": "In nominally-typed languages like C# or Java, the equivalent code would be an error because the Dog class does not explicitly describe itself as being an implementer of the Pet interface. TypeScript’s structural type system was designed based on how JavaScript code is typically written.\nBecause JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one. TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them. The basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x . For example consider the following code involving an interface named Pet which has a name property:"
                },
                {
                    "type": "code",
                    "code": "ts interface Pet { name : string ; } let pet : Pet ; // dog's inferred type is { name: string; owner: string; } let dog = { name: \"Lassie\" , owner: \"Rudd Weatherwax\" }; pet = dog ;"
                },
                {
                    "type": "p",
                    "text": "To check whether dog can be assigned to pet , the compiler checks each property of pet to find a corresponding compatible property in dog .\nIn this case, dog must have a member called name that is a string. It does, so the assignment is allowed. The same rule for assignment is used when checking function call arguments:"
                },
                {
                    "type": "code",
                    "code": "ts interface Pet { name : string ; } let dog = { name: \"Lassie\" , owner: \"Rudd Weatherwax\" }; function greet ( pet : Pet ) { console . log ( \"Hello, \" + pet . name ); } greet ( dog ); // OK"
                },
                {
                    "type": "p",
                    "text": "Note that dog has an extra owner property, but this does not create an error.\nOnly members of the target type ( Pet in this case) are considered when\nchecking for compatibility. This comparison process proceeds recursively,\nexploring the type of each member and sub-member. Be aware, however, that object literals may only specify known properties .\nFor example, because we have explicitly specified that dog is\nof type Pet , the following code is invalid:"
                },
                {
                    "type": "code",
                    "code": "ts let dog : Pet = { name: \"Lassie\" , owner: \"Rudd Weatherwax\" }; // Error"
                },
                {
                    "type": "p",
                    "text": "While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved.\nLet’s start with a basic example of two functions that differ only in their parameter lists:"
                },
                {
                    "type": "code",
                    "code": "ts let x = ( a : number ) => 0 ; let y = ( b : number , s : string ) => 0 ; y = x ; // OK x = y ; // Error"
                },
                {
                    "type": "p",
                    "text": "To check if x is assignable to y , we first look at the parameter list.\nEach parameter in x must have a corresponding parameter in y with a compatible type.\nNote that the names of the parameters are not considered, only their types.\nIn this case, every parameter of x has a corresponding compatible parameter in y , so the assignment is allowed. The second assignment is an error, because y has a required second parameter that x does not have, so the assignment is disallowed. You may be wondering why we allow ‘discarding’ parameters like in the example y = x .\nThe reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript.\nFor example, Array#forEach provides three parameters to the callback function: the array element, its index, and the containing array.\nNevertheless, it’s very useful to provide a callback that only uses the first parameter:"
                },
                {
                    "type": "code",
                    "code": "ts let items = [ 1 , 2 , 3 ]; // Don't force these extra parameters items . forEach (( item , index , array ) => console . log ( item )); // Should be OK! items . forEach (( item ) => console . log ( item ));"
                },
                {
                    "type": "p",
                    "text": "Now let’s look at how return types are treated, using two functions that differ only by their return type:"
                },
                {
                    "type": "code",
                    "code": "ts let x = () => ({ name: \"Alice\" }); let y = () => ({ name: \"Alice\" , location: \"Seattle\" }); x = y ; // OK y = x ; // Error, because x() lacks a location property"
                },
                {
                    "type": "p",
                    "text": "The type system enforces that the source function’s return type be a subtype of the target type’s return type. When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa.\nThis is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type.\nIn practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:"
                },
                {
                    "type": "code",
                    "code": "ts enum EventType { Mouse , Keyboard , } interface Event { timestamp : number ; } interface MyMouseEvent extends Event { x : number ; y : number ; } interface MyKeyEvent extends Event { keyCode : number ; } function listenEvent ( eventType : EventType , handler : ( n : Event ) => void ) { /* ... */ } // Unsound, but useful and common listenEvent ( EventType . Mouse , ( e : MyMouseEvent ) => console . log ( e . x + \",\" + e . y )); // Undesirable alternatives in presence of soundness listenEvent ( EventType . Mouse , ( e : Event ) => console . log (( e as MyMouseEvent ). x + \",\" + ( e as MyMouseEvent ). y ) ); listenEvent ( EventType . Mouse , (( e : MyMouseEvent ) => console . log ( e . x + \",\" + e . y )) as ( e : Event ) => void ); // Still disallowed (clear error). Type safety enforced for wholly incompatible types listenEvent ( EventType . Mouse , ( e : number ) => console . log ( e ));"
                },
                {
                    "type": "p",
                    "text": "You can have TypeScript raise errors when this happens via the compiler flag strictFunctionTypes . When comparing functions for compatibility, optional and required parameters are interchangeable.\nExtra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error. When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters. This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing undefined in that position is equivalent for most functions. The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:"
                },
                {
                    "type": "code",
                    "code": "ts function invokeLater ( args : any [], callback : (... args : any []) => void ) { /* ... Invoke callback with 'args' ... */ } // Unsound - invokeLater \"might\" provide any number of arguments invokeLater ([ 1 , 2 ], ( x , y ) => console . log ( x + \", \" + y )); // Confusing (x and y are actually required) and undiscoverable invokeLater ([ 1 , 2 ], ( x ?, y ?) => console . log ( x + \", \" + y ));"
                },
                {
                    "type": "p",
                    "text": "When a function has overloads, each overload in the target type must be matched by a compatible signature on the source type.\nThis ensures that the source function can be called in all the same cases as the target function. Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,"
                },
                {
                    "type": "code",
                    "code": "ts enum Status { Ready , Waiting , } enum Color { Red , Blue , Green , } let status = Status . Ready ; status = Color . Green ; // Error"
                },
                {
                    "type": "p",
                    "text": "Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type.\nWhen comparing two objects of a class type, only members of the instance are compared.\nStatic members and constructors do not affect compatibility."
                },
                {
                    "type": "code",
                    "code": "ts class Animal { feet : number ; constructor ( name : string , numFeet : number ) {} } class Size { feet : number ; constructor ( numFeet : number ) {} } let a : Animal ; let s : Size ; a = s ; // OK s = a ; // OK"
                },
                {
                    "type": "p",
                    "text": "Private and protected members in a class affect their compatibility.\nWhen an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class.\nLikewise, the same applies for an instance with a protected member.\nThis allows a class to be assignment compatible with its super class, but not with classes from a different inheritance hierarchy which otherwise have the same shape. Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,"
                },
                {
                    "type": "code",
                    "code": "ts interface Empty < T > {} let x : Empty < number >; let y : Empty < string >; x = y ; // OK, because y matches structure of x"
                },
                {
                    "type": "p",
                    "text": "In the above, x and y are compatible because their structures do not use the type argument in a differentiating way.\nChanging this example by adding a member to Empty<T> shows how this works:"
                },
                {
                    "type": "code",
                    "code": "ts interface NotEmpty < T > { data : T ; } let x : NotEmpty < number >; let y : NotEmpty < string >; x = y ; // Error, because x and y are not compatible"
                },
                {
                    "type": "p",
                    "text": "In this way, a generic type that has its type arguments specified acts just like a non-generic type. For generic types that do not have their type arguments specified, compatibility is checked by specifying any in place of all unspecified type arguments.\nThe resulting types are then checked for compatibility, just as in the non-generic case."
                },
                {
                    "type": "code",
                    "code": "ts let identity = function < T >( x : T ): T { // ... }; let reverse = function < U >( y : U ): U { // ... }; identity = reverse ; // OK, because (x: any) => any matches (y: any) => any"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve used “compatible”, which is not a term defined in the language spec.\nIn TypeScript, there are two kinds of compatibility: subtype and assignment.\nThese differ only in that assignment extends subtype compatibility with rules to allow assignment to and from any , and to and from enum with corresponding numeric values. Different places in the language use one of the two compatibility mechanisms, depending on the situation.\nFor practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the implements and extends clauses. The following table summarizes assignability between some abstract types.\nRows indicate what each is assignable to, columns indicate what is assignable to them.\nA ” ✓ ” indicates a combination that is compatible only when strictNullChecks is off."
                },
                {
                    "type": "list",
                    "items": [
                        "Everything is assignable to itself.",
                        "any and unknown are the same in terms of what is assignable to them, different in that unknown is not assignable to anything except any .",
                        "unknown and never are like inverses of each other.\nEverything is assignable to unknown , never is assignable to everything.\nNothing is assignable to never , unknown is not assignable to anything (except any ).",
                        "void is not assignable to or from anything, with the following exceptions: any , unknown , never , undefined , and null (if strictNullChecks is off, see table for details).",
                        "When strictNullChecks is off, null and undefined are similar to never : assignable to most types, most types are not assignable to them.\nThey are assignable to each other.",
                        "When strictNullChecks is on, null and undefined behave more like void : not assignable to or from anything, except for any , unknown , and void ( undefined is always assignable to void )."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
            "title": "TypeScript: Documentation - Type Inference",
            "content": [
                {
                    "type": "p",
                    "text": "In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code"
                },
                {
                    "type": "code",
                    "code": "ts let x = 3 ; let x: number Try"
                },
                {
                    "type": "p",
                    "text": "The type of the x variable is inferred to be number .\nThis kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types. In most cases, type inference is straightforward.\nIn the following sections, we’ll explore some of the nuances in how types are inferred. When a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,"
                },
                {
                    "type": "code",
                    "code": "ts let x = [ 0 , 1 , null ]; let x: (number | null)[] Try"
                },
                {
                    "type": "p",
                    "text": "To infer the type of x in the example above, we must consider the type of each array element.\nHere we are given two choices for the type of the array: number and null .\nThe best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates. Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:"
                },
                {
                    "type": "code",
                    "code": "ts let zoo = [ new Rhino (), new Elephant (), new Snake ()]; let zoo: (Rhino | Elephant | Snake)[] Try"
                },
                {
                    "type": "p",
                    "text": "Ideally, we may want zoo to be inferred as an Animal[] , but because there is no object that is strictly of type Animal in the array, we make no inference about the array element type.\nTo correct this, explicitly provide the type when no one type is a super type of all other candidates:"
                },
                {
                    "type": "code",
                    "code": "ts let zoo : Animal [] = [ new Rhino (), new Elephant (), new Snake ()]; let zoo: Animal[] Try"
                },
                {
                    "type": "p",
                    "text": "When no best common type is found, the resulting inference is the union array type, (Rhino | Elephant | Snake)[] . Type inference also works in “the other direction” in some cases in TypeScript.\nThis is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:"
                },
                {
                    "type": "code",
                    "code": "ts window . onmousedown = function ( mouseEvent ) { console . log ( mouseEvent . button ); console . log ( mouseEvent . kangaroo ); Property 'kangaroo' does not exist on type 'MouseEvent'. 2339 Property 'kangaroo' does not exist on type 'MouseEvent'. }; Try"
                },
                {
                    "type": "p",
                    "text": "Here, the TypeScript type checker used the type of the Window.onmousedown function to infer the type of the function expression on the right hand side of the assignment.\nWhen it did so, it was able to infer the type of the mouseEvent parameter, which does contain a button property, but not a kangaroo property. This works because window already has onmousedown declared in its type:"
                },
                {
                    "type": "code",
                    "code": "ts // Declares there is a global variable called 'window' declare var window : Window & typeof globalThis ; // Which is declared as (simplified): interface Window extends GlobalEventHandlers { // ... } // Which defines a lot of known handler events interface GlobalEventHandlers { onmousedown : (( this : GlobalEventHandlers , ev : MouseEvent ) => any ) | null ; // ... }"
                },
                {
                    "type": "p",
                    "text": "TypeScript is smart enough to infer types in other contexts as well:"
                },
                {
                    "type": "code",
                    "code": "ts window . onscroll = function ( uiEvent ) { console . log ( uiEvent . button ); Property 'button' does not exist on type 'Event'. 2339 Property 'button' does not exist on type 'Event'. }; Try"
                },
                {
                    "type": "p",
                    "text": "Based on the fact that the above function is being assigned to Window.onscroll , TypeScript knows that uiEvent is a UIEvent , and not a MouseEvent like the previous example. UIEvent objects contain no button property, and so TypeScript will throw an error. If this function were not in a contextually typed position, the function’s argument would implicitly have type any , and no error would be issued (unless you are using the noImplicitAny option):"
                },
                {
                    "type": "code",
                    "code": "ts const handler = function ( uiEvent ) { console . log ( uiEvent . button ); // <- OK }; Try"
                },
                {
                    "type": "p",
                    "text": "We can also explicitly give type information to the function’s argument to override any contextual type:"
                },
                {
                    "type": "code",
                    "code": "ts window . onscroll = function ( uiEvent : any ) { console . log ( uiEvent . button ); // <- Now, no error is given }; Try"
                },
                {
                    "type": "p",
                    "text": "However, this code will log undefined , since uiEvent has no property called button . Contextual typing applies in many cases.\nCommon cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements.\nThe contextual type also acts as a candidate type in best common type. For example:"
                },
                {
                    "type": "code",
                    "code": "ts function createZoo (): Animal [] { return [ new Rhino (), new Elephant (), new Snake ()]; } Try"
                },
                {
                    "type": "p",
                    "text": "In this example, best common type has a set of four candidates: Animal , Rhino , Elephant , and Snake .\nOf these, Animal can be chosen by the best common type algorithm. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html",
            "title": "TypeScript: Documentation - TypeScript for the New Programmer",
            "content": [
                {
                    "type": "p",
                    "text": "Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions! You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript.\nThe relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript. JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers.\nAt the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual.\nDue to this, early web browsers executed such code pretty slowly.\nOver time, though, JS became more and more popular, and web developers started using it to create interactive experiences. Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more.\nOn modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code.\nThis is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich applications of all kinds. More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js.\nThe “run anywhere” nature of JS makes it an attractive choice for cross-platform development.\nThere are many developers these days that use only JavaScript to program their entire stack! To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines.\nEvery language has its own quirks — oddities and surprises, and JavaScript’s humble beginning makes it have many of these. Some examples:"
                },
                {
                    "type": "list",
                    "items": [
                        "JavaScript’s equality operator ( == ) coerces its operands, leading to unexpected behavior: js if ( \"\" == 0 ) { // It is! But why?? } if ( 1 < x < 3 ) { // True for *any* value of x! }",
                        "JavaScript also allows accessing properties which aren’t present: js const obj = { width: 10 , height: 15 }; // Why is this NaN? Spelling is hard! const area = obj . width * obj . heigth ;"
                    ]
                },
                {
                    "type": "p",
                    "text": "Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running.\nWhen writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem. We said earlier that some languages wouldn’t allow those buggy programs to run at all.\nDetecting errors in code without running it is referred to as static checking .\nDetermining what’s an error and what’s not based on the kinds of values being operated on is known as static type checking. TypeScript checks a program for errors before execution, and does so based on the kinds of values , making it a static type checker .\nFor example, the last example above has an error because of the type of obj .\nHere’s the error TypeScript found:"
                },
                {
                    "type": "code",
                    "code": "ts const obj = { width : 10 , height : 15 }; const area = obj . width * obj . heigth ; Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'? 2551 Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'? Try"
                },
                {
                    "type": "p",
                    "text": "How does TypeScript relate to JavaScript, though? TypeScript is a language that is a superset of JavaScript: JS syntax is therefore legal TS.\nSyntax refers to the way we write text to form a program.\nFor example, this code has a syntax error because it’s missing a ) :"
                },
                {
                    "type": "code",
                    "code": "ts let a = ( 4 ')' expected. 1005 ')' expected. Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t consider any JavaScript code to be an error because of its syntax.\nThis means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written. However, TypeScript is a typed superset, meaning that it adds rules about how different kinds of values can be used.\nThe earlier error about obj.heigth was not a syntax error: it is an error of using some kind of value (a type ) in an incorrect way. As another example, this is JavaScript code that you can run in your browser, and it will log a value:"
                },
                {
                    "type": "code",
                    "code": "js console . log ( 4 / []);"
                },
                {
                    "type": "p",
                    "text": "This syntactically-legal program logs Infinity .\nTypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:"
                },
                {
                    "type": "code",
                    "code": "ts console . log ( 4 / [] ); The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. 2363 The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. Try"
                },
                {
                    "type": "p",
                    "text": "It’s possible you really did intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake.\nTypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible.\n(Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.) If you move some code from a JavaScript file to a TypeScript file, you might see type errors depending on how the code is written.\nThese may be legitimate problems with the code, or TypeScript being overly conservative.\nThroughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors. TypeScript is also a programming language that preserves the runtime behavior of JavaScript.\nFor example, dividing by zero in JavaScript produces Infinity instead of throwing a runtime exception.\nAs a principle, TypeScript never changes the runtime behavior of JavaScript code. This means that if you move code from JavaScript to TypeScript, it is guaranteed to run the same way, even if TypeScript thinks that the code has type errors. Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working. Roughly speaking, once TypeScript’s compiler is done with checking your code, it erases the types to produce the resulting “compiled” code.\nThis means that once your code is compiled, the resulting plain JS code has no type information. This also means that TypeScript never changes the behavior of your program based on the types it inferred.\nThe bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs. Finally, TypeScript doesn’t provide any additional runtime libraries.\nYour programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn. We frequently see the question “Should I learn JavaScript or TypeScript?“. The answer is that you can’t learn TypeScript without learning JavaScript!\nTypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time. There are many, many resources available for programmers to learn JavaScript; you should not ignore these resources if you’re writing TypeScript.\nFor example, there are about 20 times more StackOverflow questions tagged javascript than typescript , but all of the javascript questions also apply to TypeScript. If you find yourself searching for something like “how to sort a list in TypeScript”, remember: TypeScript is JavaScript’s runtime with a compile-time type checker .\nThe way you sort a list in TypeScript is the same way you do so in JavaScript.\nIf you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks. This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Learn some of the JavaScript fundamentals, we recommend either: Microsoft’s JavaScript Resources or JavaScript guide at the Mozilla Web Docs",
                        "Microsoft’s JavaScript Resources or",
                        "JavaScript guide at the Mozilla Web Docs",
                        "Continue to TypeScript for JavaScript Programmers",
                        "Read the full Handbook from start to finish",
                        "Explore the Playground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html",
            "title": "TypeScript: Documentation - TypeScript for Functional Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional object-oriented programs to the web. As it has developed, TypeScript’s type\nsystem has evolved to model code written by native JavaScripters. The\nresulting system is powerful, interesting and messy. This introduction is designed for working Haskell or ML programmers\nwho want to learn TypeScript. It describes how the type system of\nTypeScript differs from Haskell’s type system. It also describes\nunique features of TypeScript’s type system that arise from its\nmodelling of JavaScript code. This introduction does not cover object-oriented programming. In\npractice, object-oriented programs in TypeScript are similar to those\nin other popular languages with OO features. In this introduction, I assume you know the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "How to program in JavaScript, the good parts.",
                        "Type syntax of a C-descended language."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts .\nYou may be able to skip the book if you know how to write programs in\na call-by-value lexically scoped language with lots of mutability and\nnot much else. R 4 RS Scheme is a good example. The C++ Programming Language is\na good place to learn about C-style type syntax. Unlike C++,\nTypeScript uses postfix types, like so: x: string instead of string x . See the MDN page for more detail . TypeScript has corresponding primitive types for the built-in types:"
                },
                {
                    "type": "list",
                    "items": [
                        "number",
                        "string",
                        "bigint",
                        "boolean",
                        "symbol",
                        "null",
                        "undefined",
                        "object"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Function syntax includes parameter names. This is pretty hard to get used to! ts let fst : ( a : any , b : any ) => any = ( a , b ) => a ; // or more precisely: let fst : < T , U >( a : T , b : U ) => T = ( a , b ) => a ;",
                        "Object literal type syntax closely mirrors object literal value syntax: ts let o : { n : number ; xs : object [] } = { n: 1 , xs: [] };",
                        "[T, T] is a subtype of T[] . This is different than Haskell, where tuples are not related to lists."
                    ]
                },
                {
                    "type": "p",
                    "text": "JavaScript has boxed equivalents of primitive types that contain the\nmethods that programmers associate with those types. TypeScript\nreflects this with, for example, the difference between the primitive\ntype number and the boxed type Number . The boxed types are rarely\nneeded, since their methods return primitives."
                },
                {
                    "type": "code",
                    "code": "ts ( 1 ). toExponential (); // equivalent to Number . prototype . toExponential . call ( 1 );"
                },
                {
                    "type": "p",
                    "text": "Note that calling a method on a numeric literal requires it to be in\nparentheses to aid the parser. TypeScript uses the type any whenever it can’t tell what the type of\nan expression should be. Compared to Dynamic , calling any a type\nis an overstatement. It just turns off the type checker\nwherever it appears. For example, you can push any value into an any[] without marking the value in any way:"
                },
                {
                    "type": "code",
                    "code": "ts // with \"noImplicitAny\": false in tsconfig.json, anys: any[] const anys = []; anys . push ( 1 ); anys . push ( \"oh no\" ); anys . push ({ anything : \"goes\" }); Try"
                },
                {
                    "type": "p",
                    "text": "And you can use an expression of type any anywhere:"
                },
                {
                    "type": "code",
                    "code": "ts anys . map ( anys [ 1 ]); // oh no, \"oh no\" is not a function"
                },
                {
                    "type": "p",
                    "text": "any is contagious, too — if you initialize a variable with an\nexpression of type any , the variable has type any too."
                },
                {
                    "type": "code",
                    "code": "ts let sepsis = anys [ 0 ] + anys [ 1 ]; // this could mean anything"
                },
                {
                    "type": "p",
                    "text": "To get an error when TypeScript produces an any , use \"noImplicitAny\": true , or \"strict\": true in tsconfig.json . Structural typing is a familiar concept to most functional\nprogrammers, although Haskell and most MLs are not\nstructurally typed. Its basic form is pretty simple:"
                },
                {
                    "type": "code",
                    "code": "ts // @strict: false let o = { x: \"hi\" , extra: 1 }; // ok let o2 : { x : string } = o ; // ok"
                },
                {
                    "type": "p",
                    "text": "Here, the object literal { x: \"hi\", extra: 1 } has a matching\nliteral type { x: string, extra: number } . That\ntype is assignable to { x: string } since\nit has all the required properties and those properties have\nassignable types. The extra property doesn’t prevent assignment, it\njust makes it a subtype of { x: string } . Named types just give a name to a type; for assignability purposes\nthere’s no difference between the type alias One and the interface\ntype Two below. They both have a property p: string . (Type aliases\nbehave differently from interfaces with respect to recursive\ndefinitions and type parameters, however.)"
                },
                {
                    "type": "code",
                    "code": "ts type One = { p : string }; interface Two { p : string ; } class Three { p = \"Hello\" ; } let x : One = { p : \"hi\" }; let two : Two = x ; two = new Three (); Try"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, union types are untagged. In other words, they are not\ndiscriminated unions like data in Haskell. However, you can often\ndiscriminate types in a union using built-in tags or other properties."
                },
                {
                    "type": "code",
                    "code": "ts function start ( arg : string | string [] | (() => string ) | { s : string } ): string { // this is super common in JavaScript if ( typeof arg === \"string\" ) { return commonCase ( arg ); } else if ( Array . isArray ( arg )) { return arg . map ( commonCase ). join ( \",\" ); } else if ( typeof arg === \"function\" ) { return commonCase ( arg ()); } else { return commonCase ( arg . s ); } function commonCase ( s : string ): string { // finally, just convert a string to another string return s ; } } Try"
                },
                {
                    "type": "p",
                    "text": "string , Array and Function have built-in type predicates,\nconveniently leaving the object type for the else branch. It is\npossible, however, to generate unions that are difficult to\ndifferentiate at runtime. For new code, it’s best to build only\ndiscriminated unions. The following types have built-in predicates: Note that functions and arrays are objects at runtime, but have their\nown predicates. In addition to unions, TypeScript also has intersections:"
                },
                {
                    "type": "code",
                    "code": "ts type Combined = { a : number } & { b : string }; type Conflicting = { a : number } & { a : string }; Try"
                },
                {
                    "type": "p",
                    "text": "Combined has two properties, a and b , just as if they had been\nwritten as one object literal type. Intersection and union are\nrecursive in case of conflicts, so Conflicting.a: number & string . Unit types are subtypes of primitive types that contain exactly one\nprimitive value. For example, the string \"foo\" has the type \"foo\" . Since JavaScript has no built-in enums, it is common to use a set of\nwell-known strings instead. Unions of string literal types allow\nTypeScript to type this pattern:"
                },
                {
                    "type": "code",
                    "code": "ts declare function pad ( s : string , n : number , direction : \"left\" | \"right\" ): string ; pad ( \"hi\" , 10 , \"left\" ); Try"
                },
                {
                    "type": "p",
                    "text": "When needed, the compiler widens — converts to a\nsupertype — the unit type to the primitive type, such as \"foo\" to string . This happens when using mutability, which can hamper some\nuses of mutable variables:"
                },
                {
                    "type": "code",
                    "code": "ts let s = \"right\" ; pad ( \"hi\" , 10 , s ); // error: 'string' is not assignable to '\"left\" | \"right\"' Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'. 2345 Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'. Try"
                },
                {
                    "type": "list",
                    "items": [
                        "\"right\": \"right\"",
                        "s: string because \"right\" widens to string on assignment to a mutable variable.",
                        "string is not assignable to \"left\" | \"right\""
                    ]
                },
                {
                    "type": "p",
                    "text": "You can work around this with a type annotation for s , but that\nin turn prevents assignments to s of variables that are not of type \"left\" | \"right\" ."
                },
                {
                    "type": "code",
                    "code": "ts let s : \"left\" | \"right\" = \"right\" ; pad ( \"hi\" , 10 , s ); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript has some obvious places where it can infer types, like\nvariable declarations:"
                },
                {
                    "type": "code",
                    "code": "ts let s = \"I'm a string!\" ; Try"
                },
                {
                    "type": "p",
                    "text": "But it also infers types in a few other places that you may not expect\nif you’ve worked with other C-syntax languages:"
                },
                {
                    "type": "code",
                    "code": "ts declare function map < T , U >( f : ( t : T ) => U , ts : T []): U []; let sns = map (( n ) => n . toString (), [ 1 , 2 , 3 ]); Try"
                },
                {
                    "type": "p",
                    "text": "Here, n: number in this example also, despite the fact that T and U have not been inferred before the call. In fact, after [1,2,3] has\nbeen used to infer T=number , the return type of n => n.toString() is used to infer U=string , causing sns to have the type string[] . Note that inference will work in any order, but intellisense will only\nwork left-to-right, so TypeScript prefers to declare map with the\narray first:"
                },
                {
                    "type": "code",
                    "code": "ts declare function map < T , U >( ts : T [], f : ( t : T ) => U ): U []; Try"
                },
                {
                    "type": "p",
                    "text": "Contextual typing also works recursively through object literals, and\non unit types that would otherwise be inferred as string or number . And it can infer return types from context:"
                },
                {
                    "type": "code",
                    "code": "ts declare function run < T >( thunk : ( t : T ) => void ): T ; let i : { inference : string } = run (( o ) => { o . inference = \"INSERT STATE HERE\" ; }); Try"
                },
                {
                    "type": "p",
                    "text": "The type of o is determined to be { inference: string } because"
                },
                {
                    "type": "list",
                    "items": [
                        "Declaration initializers are contextually typed by the\ndeclaration’s type: { inference: string } .",
                        "The return type of a call uses the contextual type for inferences,\nso the compiler infers that T={ inference: string } .",
                        "Arrow functions use the contextual type to type their parameters,\nso the compiler gives o: { inference: string } ."
                    ]
                },
                {
                    "type": "p",
                    "text": "And it does so while you are typing, so that after typing o. , you\nget completions for the property inference , along with any other\nproperties you’d have in a real program.\nAltogether, this feature can make TypeScript’s inference look a bit\nlike a unifying type inference engine, but it is not. Type aliases are mere aliases, just like type in Haskell. The\ncompiler will attempt to use the alias name wherever it was used in\nthe source code, but does not always succeed."
                },
                {
                    "type": "code",
                    "code": "ts type Size = [ number , number ]; let x : Size = [ 101.1 , 999.9 ]; Try"
                },
                {
                    "type": "p",
                    "text": "The closest equivalent to newtype is a tagged intersection :"
                },
                {
                    "type": "code",
                    "code": "ts type FString = string & { __compileTimeOnly : any };"
                },
                {
                    "type": "p",
                    "text": "An FString is just like a normal string, except that the compiler\nthinks it has a property named __compileTimeOnly that doesn’t\nactually exist. This means that FString can still be assigned to string , but not the other way round. The closest equivalent to data is a union of types with discriminant\nproperties, normally called discriminated unions in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "ts type Shape = | { kind : \"circle\" ; radius : number } | { kind : \"square\" ; x : number } | { kind : \"triangle\" ; x : number ; y : number };"
                },
                {
                    "type": "p",
                    "text": "Unlike Haskell, the tag, or discriminant, is just a property in each\nobject type. Each variant has an identical property with a different\nunit type. This is still a normal union type; the leading | is\nan optional part of the union type syntax. You can discriminate the\nmembers of the union using normal JavaScript code:"
                },
                {
                    "type": "code",
                    "code": "ts type Shape = | { kind : \"circle\" ; radius : number } | { kind : \"square\" ; x : number } | { kind : \"triangle\" ; x : number ; y : number }; function area ( s : Shape ) { if ( s . kind === \"circle\" ) { return Math . PI * s . radius * s . radius ; } else if ( s . kind === \"square\" ) { return s . x * s . x ; } else { return ( s . x * s . y ) / 2 ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Note that the return type of area is inferred to be number because\nTypeScript knows the function is total. If some variant is not\ncovered, the return type of area will be number | undefined instead. Also, unlike Haskell, common properties show up in any union, so you\ncan usefully discriminate multiple members of the union:"
                },
                {
                    "type": "code",
                    "code": "ts function height ( s : Shape ) { if ( s . kind === \"circle\" ) { return 2 * s . radius ; } else { // s.kind: \"square\" | \"triangle\" return s . x ; } } Try"
                },
                {
                    "type": "p",
                    "text": "Like most C-descended languages, TypeScript requires declaration of\ntype parameters:"
                },
                {
                    "type": "code",
                    "code": "ts function liftArray < T >( t : T ): Array < T > { return [ t ]; }"
                },
                {
                    "type": "p",
                    "text": "There is no case requirement, but type parameters are conventionally\nsingle uppercase letters. Type parameters can also be constrained to a\ntype, which behaves a bit like type class constraints:"
                },
                {
                    "type": "code",
                    "code": "ts function firstish < T extends { length : number }>( t1 : T , t2 : T ): T { return t1 . length > t2 . length ? t1 : t2 ; }"
                },
                {
                    "type": "p",
                    "text": "TypeScript can usually infer type arguments from a call based on the\ntype of the arguments, so type arguments are usually not needed. Because TypeScript is structural, it doesn’t need type parameters as\nmuch as nominal systems. Specifically, they are not needed to make a\nfunction polymorphic. Type parameters should only be used to propagate type information, such as constraining parameters to be\nthe same type:"
                },
                {
                    "type": "code",
                    "code": "ts function length < T extends ArrayLike < unknown >>( t : T ): number {} function length ( t : ArrayLike < unknown >): number {}"
                },
                {
                    "type": "p",
                    "text": "In the first length , T is not necessary; notice that it’s only\nreferenced once, so it’s not being used to constrain the type of the\nreturn value or other parameters. TypeScript does not have higher kinded types, so the following is not legal:"
                },
                {
                    "type": "code",
                    "code": "ts function length < T extends ArrayLike < unknown >, U >( m : T < U >) {}"
                },
                {
                    "type": "p",
                    "text": "Point-free programming — heavy use of currying and function\ncomposition — is possible in JavaScript, but can be verbose.\nIn TypeScript, type inference often fails for point-free programs, so\nyou’ll end up specifying type parameters instead of value parameters. The\nresult is so verbose that it’s usually better to avoid point-free\nprogramming. JavaScript’s modern module syntax is a bit like Haskell’s, except that\nany file with import or export is implicitly a module:"
                },
                {
                    "type": "code",
                    "code": "ts import { value , Type } from \"npm-package\" ; import { other , Types } from \"./local-package\" ; import * as prefix from \"../lib/third-package\" ;"
                },
                {
                    "type": "p",
                    "text": "You can also import commonjs modules — modules written using node.js’\nmodule system:"
                },
                {
                    "type": "code",
                    "code": "ts import f = require ( \"single-function-package\" );"
                },
                {
                    "type": "p",
                    "text": "You can export with an export list:"
                },
                {
                    "type": "code",
                    "code": "ts export { f }; function f () { return g (); } function g () {} // g is not exported"
                },
                {
                    "type": "p",
                    "text": "Or by marking each export individually:"
                },
                {
                    "type": "code",
                    "code": "ts export function f () { return g () } function g () { }"
                },
                {
                    "type": "p",
                    "text": "The latter style is more common but both are allowed, even in the same\nfile. In JavaScript, mutability is the default, although it allows variable\ndeclarations with const to declare that the reference is\nimmutable. The referent is still mutable:"
                },
                {
                    "type": "code",
                    "code": "js const a = [ 1 , 2 , 3 ]; a . push ( 102 ); // ): a [ 0 ] = 101 ; // D:"
                },
                {
                    "type": "p",
                    "text": "TypeScript additionally has a readonly modifier for properties."
                },
                {
                    "type": "code",
                    "code": "ts interface Rx { readonly x : number ; } let rx : Rx = { x: 1 }; rx . x = 12 ; // error"
                },
                {
                    "type": "p",
                    "text": "It also ships with a mapped type Readonly<T> that makes\nall properties readonly :"
                },
                {
                    "type": "code",
                    "code": "ts interface X { x : number ; } let rx : Readonly < X > = { x: 1 }; rx . x = 12 ; // error"
                },
                {
                    "type": "p",
                    "text": "And it has a specific ReadonlyArray<T> type that removes\nside-affecting methods and prevents writing to indices of the array,\nas well as special syntax for this type:"
                },
                {
                    "type": "code",
                    "code": "ts let a : ReadonlyArray < number > = [ 1 , 2 , 3 ]; let b : readonly number [] = [ 1 , 2 , 3 ]; a . push ( 102 ); // error b [ 0 ] = 101 ; // error"
                },
                {
                    "type": "p",
                    "text": "You can also use a const-assertion, which operates on arrays and\nobject literals:"
                },
                {
                    "type": "code",
                    "code": "ts let a = [ 1 , 2 , 3 ] as const ; a . push ( 102 ); // error a [ 0 ] = 101 ; // error"
                },
                {
                    "type": "p",
                    "text": "However, none of these options are the default, so they are not\nconsistently used in TypeScript code. This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbook from start to finish",
                        "Explore the Playground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html",
            "title": "TypeScript: Documentation - TypeScript for Java/C# Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java. TypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program.\nWhile TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages.\nUnderstanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into. If you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to.\nSome of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript. If you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript without types first to understand JavaScript’s runtime behaviors.\nBecause TypeScript doesn’t change how your code runs , you’ll still have to learn how JavaScript works in order to write code that actually does something! It’s important to remember that TypeScript uses the same runtime as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs.\nDon’t limit yourself to TypeScript-specific resources! C# and Java are what we might call mandatory OOP languages.\nIn these languages, the class is the basic unit of code organization, and also the basic container of all data and behavior at runtime.\nForcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain needs to be represented this way. In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined class or struct .\nThis flexibility is extremely powerful.\n“Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript. Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript. That said, you can still use classes if you like!\nSome problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful.\nTypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods. We’ll cover classes later in this guide. TypeScript’s understanding of a type is actually quite different from C# or Java’s.\nLet’s explore some differences. In C# or Java, any given value or object has one exact type - either null , a primitive, or a known class type.\nWe can call methods like value.GetType() or value.getClass() to query the exact type at runtime.\nThe definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface. These aspects describe a reified, nominal type system.\nThe types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures. In C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations. In TypeScript, it’s better to think of a type as a set of values that share something in common.\nBecause types are just sets, a particular value can belong to many sets at the same time. Once you start thinking of types as sets, certain operations become very natural.\nFor example, in C#, it’s awkward to pass around a value that is either a string or int , because there isn’t a single type that represents this sort of value. In TypeScript, this becomes very natural once you realize that every type is just a set.\nHow do you describe a value that either belongs in the string set or the number set?\nIt simply belongs to the union of those sets: string | number . TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets. In TypeScript, objects are not of a single exact type.\nFor example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two."
                },
                {
                    "type": "code",
                    "code": "ts interface Pointlike { x : number ; y : number ; } interface Named { name : string ; } function logPoint ( point : Pointlike ) { console . log ( \"x = \" + point . x + \", y = \" + point . y ); } function logName ( x : Named ) { console . log ( \"Hello, \" + x . name ); } const obj = { x : 0 , y : 0 , name : \"Origin\" , }; logPoint ( obj ); logName ( obj ); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system is structural , not nominal: We can use obj as a Pointlike because it has x and y properties that are both numbers.\nThe relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship. TypeScript’s type system is also not reified : There’s nothing at runtime that will tell us that obj is Pointlike .\nIn fact, the Pointlike type is not present in any form at runtime. Going back to the idea of types as sets , we can think of obj as being a member of both the Pointlike set of values and the Named set of values. OOP programmers are often surprised by two particular aspects of structural typing. The first is that the empty type seems to defy expectation:"
                },
                {
                    "type": "code",
                    "code": "ts class Empty {} function fn ( arg : Empty ) { // do something? } // No error, but this isn't an 'Empty' ? fn ({ k : 10 }); Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript determines if the call to fn here is valid by seeing if the provided argument is a valid Empty .\nIt does so by examining the structure of { k: 10 } and class Empty { } .\nWe can see that { k: 10 } has all of the properties that Empty does, because Empty has no properties.\nTherefore, this is a valid call! This may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages.\nA subclass cannot remove a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base.\nStructural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types. Another frequent source of surprise comes with identical types:"
                },
                {
                    "type": "code",
                    "code": "ts class Car { drive () { // hit the gas } } class Golfer { drive () { // hit the ball far } } // No error? let w : Car = new Golfer ();"
                },
                {
                    "type": "p",
                    "text": "Again, this isn’t an error because the structures of these classes are the same.\nWhile this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common. We’ll learn more about how classes relate to each other in the Classes chapter. OOP programmers are accustomed to being able to query the type of any value, even a generic one:"
                },
                {
                    "type": "code",
                    "code": "csharp // C# static void LogType < T >() { Console . WriteLine ( typeof ( T ). Name ); }"
                },
                {
                    "type": "p",
                    "text": "Because TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime. JavaScript does have some limited primitives like typeof and instanceof , but remember that these operators are still working on the values as they exist in the type-erased output code.\nFor example, typeof (new Car()) will be \"object\" , not Car or \"Car\" . This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbook from start to finish",
                        "Explore the Playground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript for JavaScript Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system. For example, JavaScript provides language primitives like string and number , but it doesn’t check that you’ve consistently assigned these. TypeScript does. This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs. This tutorial provides a brief overview of TypeScript, focusing on its type system. TypeScript knows the JavaScript language and will generate types for you in many cases.\nFor example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type."
                },
                {
                    "type": "code",
                    "code": "ts let helloWorld = \"Hello World\" ; let helloWorld: string Try"
                },
                {
                    "type": "p",
                    "text": "By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example. You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript. You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be. For example, to create an object with an inferred type which includes name: string and id: number , you can write:"
                },
                {
                    "type": "code",
                    "code": "ts const user = { name : \"Hayes\" , id : 0 , }; Try"
                },
                {
                    "type": "p",
                    "text": "You can explicitly describe this object’s shape using an interface declaration:"
                },
                {
                    "type": "code",
                    "code": "ts interface User { name : string ; id : number ; } Try"
                },
                {
                    "type": "p",
                    "text": "You can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:"
                },
                {
                    "type": "code",
                    "code": "ts const user : User = { name : \"Hayes\" , id : 0 , }; Try"
                },
                {
                    "type": "p",
                    "text": "If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:"
                },
                {
                    "type": "code",
                    "code": "ts interface User { name : string ; id : number ; } const user : User = { username : \"Hayes\" , Object literal may only specify known properties, and 'username' does not exist in type 'User'. 2353 Object literal may only specify known properties, and 'username' does not exist in type 'User'. id : 0 , }; Try"
                },
                {
                    "type": "p",
                    "text": "Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:"
                },
                {
                    "type": "code",
                    "code": "ts interface User { name : string ; id : number ; } class UserAccount { name : string ; id : number ; constructor ( name : string , id : number ) { this . name = name ; this . id = id ; } } const user : User = new UserAccount ( \"Murphy\" , 1 ); Try"
                },
                {
                    "type": "p",
                    "text": "You can use interfaces to annotate parameters and return values to functions:"
                },
                {
                    "type": "code",
                    "code": "ts function deleteUser ( user : User ) { // ... } function getAdminUser (): User { //... } Try"
                },
                {
                    "type": "p",
                    "text": "There is already a small set of primitive types available in JavaScript: boolean , bigint , null , number , string , symbol , and undefined , which you can use in an interface. TypeScript extends this list with a few more, such as any (allow anything), unknown (ensure someone using this type declares what the type is), never (it’s not possible that this type could happen), and void (a function which returns undefined or has no return value). You’ll see that there are two syntaxes for building types: Interfaces and Types . You should prefer interface . Use type when you need specific features. With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics. With a union, you can declare that a type could be one of many types. For example, you can describe a boolean type as being either true or false :"
                },
                {
                    "type": "code",
                    "code": "ts type MyBool = true | false ; Try"
                },
                {
                    "type": "p",
                    "text": "Note: If you hover over MyBool above, you’ll see that it is classed as boolean . That’s a property of the Structural Type System. More on this below. A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:"
                },
                {
                    "type": "code",
                    "code": "ts type WindowStates = \"open\" | \"closed\" | \"minimized\" ; type LockStates = \"locked\" | \"unlocked\" ; type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9 ; Try"
                },
                {
                    "type": "p",
                    "text": "Unions provide a way to handle different types too. For example, you may have a function that takes an array or a string :"
                },
                {
                    "type": "code",
                    "code": "ts function getLength ( obj : string | string []) { return obj . length ; } Try"
                },
                {
                    "type": "p",
                    "text": "To learn the type of a variable, use typeof : For example, you can make a function return different values depending on whether it is passed a string or an array:"
                },
                {
                    "type": "code",
                    "code": "ts function wrapInArray ( obj : string | string []) { if ( typeof obj === \"string\" ) { return [ obj ]; (parameter) obj: string } return obj ; } Try"
                },
                {
                    "type": "p",
                    "text": "Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains."
                },
                {
                    "type": "code",
                    "code": "ts type StringArray = Array < string >; type NumberArray = Array < number >; type ObjectWithNameArray = Array <{ name : string }>;"
                },
                {
                    "type": "p",
                    "text": "You can declare your own types that use generics:"
                },
                {
                    "type": "code",
                    "code": "ts interface Backpack < Type > { add : ( obj : Type ) => void ; get : () => Type ; } // This line is a shortcut to tell TypeScript there is a // constant called `backpack`, and to not worry about where it came from. declare const backpack : Backpack < string >; // object is a string, because we declared it above as the variable part of Backpack. const object = backpack . get (); // Since the backpack variable is a string, you can't pass a number to the add function. backpack . add ( 23 ); Argument of type 'number' is not assignable to parameter of type 'string'. 2345 Argument of type 'number' is not assignable to parameter of type 'string'. Try"
                },
                {
                    "type": "p",
                    "text": "One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”. In a structural type system, if two objects have the same shape, they are considered to be of the same type."
                },
                {
                    "type": "code",
                    "code": "ts interface Point { x : number ; y : number ; } function logPoint ( p : Point ) { console . log ( ` ${ p . x } , ${ p . y } ` ); } // logs \"12, 26\" const point = { x : 12 , y : 26 }; logPoint ( point ); Try"
                },
                {
                    "type": "p",
                    "text": "The point variable is never declared to be a Point type. However, TypeScript compares the shape of point to the shape of Point in the type-check. They have the same shape, so the code passes. The shape-matching only requires a subset of the object’s fields to match."
                },
                {
                    "type": "code",
                    "code": "ts const point3 = { x : 12 , y : 26 , z : 89 }; logPoint ( point3 ); // logs \"12, 26\" const rect = { x : 33 , y : 3 , width : 30 , height : 80 }; logPoint ( rect ); // logs \"33, 3\" const color = { hex : \"#187ABF\" }; logPoint ( color ); Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, y 2345 Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, y Try"
                },
                {
                    "type": "p",
                    "text": "There is no difference between how classes and objects conform to shapes:"
                },
                {
                    "type": "code",
                    "code": "ts class VirtualPoint { x : number ; y : number ; constructor ( x : number , y : number ) { this . x = x ; this . y = y ; } } const newVPoint = new VirtualPoint ( 13 , 56 ); logPoint ( newVPoint ); // logs \"13, 56\" Try"
                },
                {
                    "type": "p",
                    "text": "If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details. This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbook from start to finish",
                        "Explore the Playground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript Tooling in 5 minutes",
            "content": [
                {
                    "type": "p",
                    "text": "Let’s get started by building a simple web application with TypeScript. There are two main ways to add TypeScript to your project:"
                },
                {
                    "type": "list",
                    "items": [
                        "Via npm (the Node.js package manager)",
                        "By installing TypeScript’s Visual Studio plugins"
                    ]
                },
                {
                    "type": "p",
                    "text": "Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, tsc .\nIf you didn’t install TypeScript with Visual Studio, you can still download it ."
                },
                {
                    "type": "code",
                    "code": "shell > npm install -g typescript"
                },
                {
                    "type": "p",
                    "text": "In your editor, type the following JavaScript code in greeter.ts :"
                },
                {
                    "type": "code",
                    "code": "ts function greeter ( person ) { return \"Hello, \" + person ; } let user = \"Jane User\" ; document . body . textContent = greeter ( user ); Try"
                },
                {
                    "type": "p",
                    "text": "We used a .ts extension, but this code is just JavaScript.\nYou could have copy/pasted this straight out of an existing JavaScript app. At the command line, run the TypeScript compiler:"
                },
                {
                    "type": "code",
                    "code": "shell tsc greeter.ts"
                },
                {
                    "type": "p",
                    "text": "The result will be a file greeter.js which contains the same JavaScript that you fed in.\nWe’re up and running using TypeScript in our JavaScript app! Now we can start taking advantage of some of the new tools TypeScript offers.\nAdd a : string type annotation to the ‘person’ function parameter as shown here:"
                },
                {
                    "type": "code",
                    "code": "ts function greeter ( person : string ) { return \"Hello, \" + person ; } let user = \"Jane User\" ; document . body . textContent = greeter ( user ); Try"
                },
                {
                    "type": "p",
                    "text": "Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable.\nIn this case, we intend the greeter function to be called with a single string parameter.\nWe can try changing the call greeter to pass an array instead:"
                },
                {
                    "type": "code",
                    "code": "ts function greeter ( person : string ) { return \"Hello, \" + person ; } let user = [ 0 , 1 , 2 ]; document . body . textContent = greeter ( user ); Argument of type 'number[]' is not assignable to parameter of type 'string'. 2345 Argument of type 'number[]' is not assignable to parameter of type 'string'. Try"
                },
                {
                    "type": "p",
                    "text": "Re-compiling, you’ll now see an error:"
                },
                {
                    "type": "code",
                    "code": "shell error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string' ."
                },
                {
                    "type": "p",
                    "text": "Similarly, try removing all the arguments to the greeter call.\nTypeScript will let you know that you have called this function with an unexpected number of arguments.\nIn both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide. Notice that although there were errors, the greeter.js file is still created.\nYou can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected. Let’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field.\nIn TypeScript, two types are compatible if their internal structure is compatible.\nThis allows us to implement an interface just by having the shape the interface requires, without an explicit implements clause."
                },
                {
                    "type": "code",
                    "code": "ts interface Person { firstName : string ; lastName : string ; } function greeter ( person : Person ) { return \"Hello, \" + person . firstName + \" \" + person . lastName ; } let user = { firstName : \"Jane\" , lastName : \"User\" }; document . body . textContent = greeter ( user ); Try"
                },
                {
                    "type": "p",
                    "text": "Finally, let’s extend the example one last time with classes.\nTypeScript supports new features in JavaScript, like support for class-based object-oriented programming. Here we’re going to create a Student class with a constructor and a few public fields.\nNotice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction. Also of note, the use of public on parameters to the constructor is a shorthand that allows us to automatically create properties with that name."
                },
                {
                    "type": "code",
                    "code": "ts class Student { fullName : string ; constructor ( public firstName : string , public middleInitial : string , public lastName : string ) { this . fullName = firstName + \" \" + middleInitial + \" \" + lastName ; } } interface Person { firstName : string ; lastName : string ; } function greeter ( person : Person ) { return \"Hello, \" + person . firstName + \" \" + person . lastName ; } let user = new Student ( \"Jane\" , \"M.\" , \"User\" ); document . body . textContent = greeter ( user ); Try"
                },
                {
                    "type": "p",
                    "text": "Re-run tsc greeter.ts and you’ll see the generated JavaScript is the same as the earlier code.\nClasses in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript. Now type the following in greeter.html :"
                },
                {
                    "type": "code",
                    "code": "html <!DOCTYPE html > <html> <head> <title> TypeScript Greeter </title> </head> <body> <script src = \"greeter.js\" ></script> </body> </html>"
                },
                {
                    "type": "p",
                    "text": "Open greeter.html in the browser to run your first simple TypeScript web application! Optional: Open greeter.ts in Visual Studio, or copy the code into the TypeScript playground.\nYou can hover over identifiers to see their types.\nNotice that in some cases these types are inferred automatically for you.\nRe-type the last line, and see completion lists and parameter help based on the types of the DOM elements.\nPut your cursor on the reference to the greeter function, and hit F12 to go to its definition.\nNotice, too, that you can right-click on a symbol and use refactoring to rename it. The type information provided works together with the tools to work with JavaScript at application scale.\nFor more examples of what’s possible in TypeScript, see the Samples section of the website. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
            "title": "TypeScript: Documentation - Utility Types",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally. This type is meant to model operations like await in async functions, or the .then() method on Promise s - specifically, the way that they recursively\nunwrap Promise s."
                },
                {
                    "type": "code",
                    "code": "ts type A = Awaited < Promise < string >>; type A = string type B = Awaited < Promise < Promise < number >>>; type B = number type C = Awaited < boolean | Promise < number >>; type C = number | boolean Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type."
                },
                {
                    "type": "code",
                    "code": "ts interface Todo { title : string ; description : string ; } function updateTodo ( todo : Todo , fieldsToUpdate : Partial < Todo >) { return { ... todo , ... fieldsToUpdate }; } const todo1 = { title : \"organize desk\" , description : \"clear clutter\" , }; const todo2 = updateTodo ( todo1 , { description : \"throw out trash\" , }); Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of all properties of Type set to required. The opposite of Partial ."
                },
                {
                    "type": "code",
                    "code": "ts interface Props { a ?: number ; b ?: string ; } const obj : Props = { a : 5 }; const obj2 : Required < Props > = { a : 5 }; Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'. 2741 Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'. Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties of Type set to readonly , meaning the properties of the constructed type cannot be reassigned."
                },
                {
                    "type": "code",
                    "code": "ts interface Todo { title : string ; } const todo : Readonly < Todo > = { title : \"Delete inactive users\" , }; todo . title = \"Hello\" ; Cannot assign to 'title' because it is a read-only property. 2540 Cannot assign to 'title' because it is a read-only property. Try"
                },
                {
                    "type": "p",
                    "text": "This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object )."
                },
                {
                    "type": "code",
                    "code": "ts function freeze < Type >( obj : Type ): Readonly < Type >;"
                },
                {
                    "type": "p",
                    "text": "Constructs an object type whose property keys are Keys and whose property values are Type . This utility can be used to map the properties of a type to another type."
                },
                {
                    "type": "code",
                    "code": "ts type CatName = \"miffy\" | \"boris\" | \"mordred\" ; interface CatInfo { age : number ; breed : string ; } const cats : Record < CatName , CatInfo > = { miffy : { age : 10 , breed : \"Persian\" }, boris : { age : 5 , breed : \"Maine Coon\" }, mordred : { age : 16 , breed : \"British Shorthair\" }, }; cats . boris ; const cats: Record<CatName, CatInfo> Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type ."
                },
                {
                    "type": "code",
                    "code": "ts interface Todo { title : string ; description : string ; completed : boolean ; } type TodoPreview = Pick < Todo , \"title\" | \"completed\" >; const todo : TodoPreview = { title : \"Clean room\" , completed : false , }; todo ; const todo: TodoPreview Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals). The opposite of Pick ."
                },
                {
                    "type": "code",
                    "code": "ts interface Todo { title : string ; description : string ; completed : boolean ; createdAt : number ; } type TodoPreview = Omit < Todo , \"description\" >; const todo : TodoPreview = { title : \"Clean room\" , completed : false , createdAt : 1615544252770 , }; todo ; const todo: TodoPreview type TodoInfo = Omit < Todo , \"completed\" | \"createdAt\" >; const todoInfo : TodoInfo = { title : \"Pick up kids\" , description : \"Kindergarten closes at 5pm\" , }; todoInfo ; const todoInfo: TodoInfo Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers ."
                },
                {
                    "type": "code",
                    "code": "ts type T0 = Exclude < \"a\" | \"b\" | \"c\" , \"a\" >; type T0 = \"b\" | \"c\" type T1 = Exclude < \"a\" | \"b\" | \"c\" , \"a\" | \"b\" >; type T1 = \"c\" type T2 = Exclude < string | number | (() => void ), Function >; type T2 = string | number type Shape = | { kind : \"circle\" ; radius : number } | { kind : \"square\" ; x : number } | { kind : \"triangle\" ; x : number ; y : number }; type T3 = Exclude < Shape , { kind : \"circle\" }> type T3 = {\n    kind: \"square\";\n    x: number;\n} | {\n    kind: \"triangle\";\n    x: number;\n    y: number;\n} Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by extracting from Type all union members that are assignable to Union ."
                },
                {
                    "type": "code",
                    "code": "ts type T0 = Extract < \"a\" | \"b\" | \"c\" , \"a\" | \"f\" >; type T0 = \"a\" type T1 = Extract < string | number | (() => void ), Function >; type T1 = () => void type Shape = | { kind : \"circle\" ; radius : number } | { kind : \"square\" ; x : number } | { kind : \"triangle\" ; x : number ; y : number }; type T2 = Extract < Shape , { kind : \"circle\" }> type T2 = {\n    kind: \"circle\";\n    radius: number;\n} Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excluding null and undefined from Type ."
                },
                {
                    "type": "code",
                    "code": "ts type T0 = NonNullable < string | number | undefined >; type T0 = string | number type T1 = NonNullable < string [] | null | undefined >; type T1 = string[] Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple type from the types used in the parameters of a function type Type . For overloaded functions, this will be the parameters of the last signature; see Inferring Within Conditional Types ."
                },
                {
                    "type": "code",
                    "code": "ts declare function f1 ( arg : { a : number ; b : string }): void ; type T0 = Parameters <() => string >; type T0 = [] type T1 = Parameters <( s : string ) => void >; type T1 = [s: string] type T2 = Parameters << T >( arg : T ) => T >; type T2 = [arg: unknown] type T3 = Parameters < typeof f1 >; type T3 = [arg: {\n    a: number;\n    b: string;\n}] type T4 = Parameters < any >; type T4 = unknown[] type T5 = Parameters < never >; type T5 = never type T6 = Parameters < string >; Type 'string' does not satisfy the constraint '(...args: any) => any'. 2344 Type 'string' does not satisfy the constraint '(...args: any) => any'. type T6 = never type T7 = Parameters < Function >; Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'. 2344 Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'. type T7 = never Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function)."
                },
                {
                    "type": "code",
                    "code": "ts type T0 = ConstructorParameters < ErrorConstructor >; type T0 = [message?: string] type T1 = ConstructorParameters < FunctionConstructor >; type T1 = string[] type T2 = ConstructorParameters < RegExpConstructor >; type T2 = [pattern: string | RegExp, flags?: string] class C { constructor ( a : number , b : string ) {} } type T3 = ConstructorParameters < typeof C >; type T3 = [a: number, b: string] type T4 = ConstructorParameters < any >; type T4 = unknown[] type T5 = ConstructorParameters < Function >; Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'. 2344 Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'. type T5 = never Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the return type of function Type . For overloaded functions, this will be the return type of the last signature; see Inferring Within Conditional Types ."
                },
                {
                    "type": "code",
                    "code": "ts declare function f1 (): { a : number ; b : string }; type T0 = ReturnType <() => string >; type T0 = string type T1 = ReturnType <( s : string ) => void >; type T1 = void type T2 = ReturnType << T >() => T >; type T2 = unknown type T3 = ReturnType << T extends U , U extends number []>() => T >; type T3 = number[] type T4 = ReturnType < typeof f1 >; type T4 = {\n    a: number;\n    b: string;\n} type T5 = ReturnType < any >; type T5 = any type T6 = ReturnType < never >; type T6 = never type T7 = ReturnType < string >; Type 'string' does not satisfy the constraint '(...args: any) => any'. 2344 Type 'string' does not satisfy the constraint '(...args: any) => any'. type T7 = any type T8 = ReturnType < Function >; Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'. 2344 Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'. type T8 = any Try"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the instance type of a constructor function in Type ."
                },
                {
                    "type": "code",
                    "code": "ts class C { x = 0 ; y = 0 ; } type T0 = InstanceType < typeof C >; type T0 = C type T1 = InstanceType < any >; type T1 = any type T2 = InstanceType < never >; type T2 = never type T3 = InstanceType < string >; Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'. 2344 Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'. type T3 = any type T4 = InstanceType < Function >; Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'. 2344 Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'. type T4 = any Try"
                },
                {
                    "type": "p",
                    "text": "Blocks inferences to the contained type. Other than blocking inferences, NoInfer<Type> is\nidentical to Type ."
                },
                {
                    "type": "code",
                    "code": "ts function createStreetLight < C extends string >( colors : C [], defaultColor ?: NoInfer < C >, ) { // ... } createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"red\" ); // OK createStreetLight ([ \"red\" , \"yellow\" , \"green\" ], \"blue\" ); // Error"
                },
                {
                    "type": "p",
                    "text": "Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter."
                },
                {
                    "type": "code",
                    "code": "ts function toHex ( this : Number ) { return this . toString ( 16 ); } function numberToString ( n : ThisParameterType < typeof toHex >) { return toHex . apply ( n ); } Try"
                },
                {
                    "type": "p",
                    "text": "Removes the this parameter from Type . If Type has no explicitly declared this parameter, the result is simply Type . Otherwise, a new function type with no this parameter is created from Type . Generics are erased and only the last overload signature is propagated into the new function type."
                },
                {
                    "type": "code",
                    "code": "ts function toHex ( this : Number ) { return this . toString ( 16 ); } const fiveToHex : OmitThisParameter < typeof toHex > = toHex . bind ( 5 ); console . log ( fiveToHex ()); Try"
                },
                {
                    "type": "p",
                    "text": "This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility."
                },
                {
                    "type": "code",
                    "code": "ts type ObjectDescriptor < D , M > = { data ?: D ; methods ?: M & ThisType < D & M >; // Type of 'this' in methods is D & M }; function makeObject < D , M >( desc : ObjectDescriptor < D , M >): D & M { let data : object = desc . data || {}; let methods : object = desc . methods || {}; return { ... data , ... methods } as D & M ; } let obj = makeObject ({ data : { x : 0 , y : 0 }, methods : { moveBy ( dx : number , dy : number ) { this . x += dx ; // Strongly typed this this . y += dy ; // Strongly typed this }, }, }); obj . x = 10 ; obj . y = 20 ; obj . moveBy ( 5 , 5 ); Try"
                },
                {
                    "type": "p",
                    "text": "In the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType<D & M> and therefore the type of this in methods within the methods object is { x: number, y: number } & { moveBy(dx: number, dy: number): void } . Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods. The ThisType<T> marker interface is simply an empty interface declared in lib.d.ts . Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface. To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/variable-declarations.html",
            "title": "TypeScript: Documentation - Variable Declaration",
            "content": [
                {
                    "type": "p",
                    "text": "let and const are two relatively new concepts for variable declarations in JavaScript. As we mentioned earlier , let is similar to var in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript. const is an augmentation of let in that it prevents re-assignment to a variable. With TypeScript being an extension of JavaScript, the language naturally supports let and const .\nHere we’ll elaborate more on these new declarations and why they’re preferable to var . If you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory.\nIf you’re intimately familiar with all the quirks of var declarations in JavaScript, you might find it easier to skip ahead. Declaring a variable in JavaScript has always traditionally been done with the var keyword."
                },
                {
                    "type": "code",
                    "code": "ts var a = 10 ;"
                },
                {
                    "type": "p",
                    "text": "As you might’ve figured out, we just declared a variable named a with the value 10 . We can also declare a variable inside of a function:"
                },
                {
                    "type": "code",
                    "code": "ts function f () { var message = \"Hello, world!\" ; return message ; }"
                },
                {
                    "type": "p",
                    "text": "and we can also access those same variables within other functions:"
                },
                {
                    "type": "code",
                    "code": "ts function f () { var a = 10 ; return function g () { var b = a + 1 ; return b ; }; } var g = f (); g (); // returns '11'"
                },
                {
                    "type": "p",
                    "text": "In this above example, g captured the variable a declared in f .\nAt any point that g gets called, the value of a will be tied to the value of a in f .\nEven if g is called once f is done running, it will be able to access and modify a ."
                },
                {
                    "type": "code",
                    "code": "ts function f () { var a = 1 ; a = 2 ; var b = g (); a = 3 ; return b ; function g () { return a ; } } f (); // returns '2'"
                },
                {
                    "type": "p",
                    "text": "var declarations have some odd scoping rules for those used to other languages.\nTake the following example:"
                },
                {
                    "type": "code",
                    "code": "ts function f ( shouldInitialize : boolean ) { if ( shouldInitialize ) { var x = 10 ; } return x ; } f ( true ); // returns '10' f ( false ); // returns 'undefined'"
                },
                {
                    "type": "p",
                    "text": "Some readers might do a double-take at this example.\nThe variable x was declared within the if block , and yet we were able to access it from outside that block.\nThat’s because var declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block.\nSome people call this var -scoping or function-scoping .\nParameters are also function scoped. These scoping rules can cause several types of mistakes.\nOne problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:"
                },
                {
                    "type": "code",
                    "code": "ts function sumMatrix ( matrix : number [][]) { var sum = 0 ; for ( var i = 0 ; i < matrix . length ; i ++) { var currentRow = matrix [ i ]; for ( var i = 0 ; i < currentRow . length ; i ++) { sum += currentRow [ i ]; } } return sum ; }"
                },
                {
                    "type": "p",
                    "text": "Maybe it was easy to spot out for some experienced JavaScript developers, but the inner for -loop will accidentally overwrite the variable i because i refers to the same function-scoped variable.\nAs experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration. Take a quick second to guess what the output of the following snippet is:"
                },
                {
                    "type": "code",
                    "code": "ts for ( var i = 0 ; i < 10 ; i ++) { setTimeout ( function () { console . log ( i ); }, 100 * i ); }"
                },
                {
                    "type": "p",
                    "text": "For those unfamiliar, setTimeout will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running)."
                },
                {
                    "type": "code",
                    "code": "10 10 10 10 10 10 10 10 10 10"
                },
                {
                    "type": "p",
                    "text": "Many JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone.\nMost people expect the output to be"
                },
                {
                    "type": "code",
                    "code": "0 1 2 3 4 5 6 7 8 9"
                },
                {
                    "type": "p",
                    "text": "Remember what we mentioned earlier about variable capturing?\nEvery function expression we pass to setTimeout actually refers to the same i from the same scope. Let’s take a minute to consider what that means. setTimeout will run a function after some number of milliseconds, but only after the for loop has stopped executing;\nBy the time the for loop has stopped executing, the value of i is 10 .\nSo each time the given function gets called, it will print out 10 ! A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture i at each iteration:"
                },
                {
                    "type": "code",
                    "code": "ts for ( var i = 0 ; i < 10 ; i ++) { // capture the current state of 'i' // by invoking a function with its current value ( function ( i ) { setTimeout ( function () { console . log ( i ); }, 100 * i ); })( i ); }"
                },
                {
                    "type": "p",
                    "text": "This odd-looking pattern is actually pretty common.\nThe i in the parameter list actually shadows the i declared in the for loop, but since we named them the same, we didn’t have to modify the loop body too much. By now you’ve figured out that var has some problems, which is precisely why let statements were introduced.\nApart from the keyword used, let statements are written the same way var statements are."
                },
                {
                    "type": "code",
                    "code": "ts let hello = \"Hello!\" ;"
                },
                {
                    "type": "p",
                    "text": "The key difference is not in the syntax, but in the semantics, which we’ll now dive into. When a variable is declared using let , it uses what some call lexical-scoping or block-scoping .\nUnlike variables declared with var whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or for -loop."
                },
                {
                    "type": "code",
                    "code": "ts function f ( input : boolean ) { let a = 100 ; if ( input ) { // Still okay to reference 'a' let b = a + 1 ; return b ; } // Error: 'b' doesn't exist here return b ; }"
                },
                {
                    "type": "p",
                    "text": "Here, we have two local variables a and b . a ’s scope is limited to the body of f while b ’s scope is limited to the containing if statement’s block. Variables declared in a catch clause also have similar scoping rules."
                },
                {
                    "type": "code",
                    "code": "ts try { throw \"oh no!\" ; } catch ( e ) { console . log ( \"Oh well.\" ); } // Error: 'e' doesn't exist here console . log ( e );"
                },
                {
                    "type": "p",
                    "text": "Another property of block-scoped variables is that they can’t be read or written to before they’re actually declared.\nWhile these variables are “present” throughout their scope, all points up until their declaration are part of their temporal dead zone .\nThis is just a sophisticated way of saying you can’t access them before the let statement, and luckily TypeScript will let you know that."
                },
                {
                    "type": "code",
                    "code": "ts a ++; // illegal to use 'a' before it's declared; let a ;"
                },
                {
                    "type": "p",
                    "text": "Something to note is that you can still capture a block-scoped variable before it’s declared.\nThe only catch is that it’s illegal to call that function before the declaration.\nIf targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error."
                },
                {
                    "type": "code",
                    "code": "ts function foo () { // okay to capture 'a' return a ; } // illegal call 'foo' before 'a' is declared // runtimes should throw an error here foo (); let a ;"
                },
                {
                    "type": "p",
                    "text": "For more information on temporal dead zones, see relevant content on the Mozilla Developer Network . With var declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one."
                },
                {
                    "type": "code",
                    "code": "ts function f ( x ) { var x ; var x ; if ( true ) { var x ; } }"
                },
                {
                    "type": "p",
                    "text": "In the above example, all declarations of x actually refer to the same x , and this is perfectly valid.\nThis often ends up being a source of bugs.\nThankfully, let declarations are not as forgiving."
                },
                {
                    "type": "code",
                    "code": "ts let x = 10 ; let x = 20 ; // error: can't re-declare 'x' in the same scope"
                },
                {
                    "type": "p",
                    "text": "The variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem."
                },
                {
                    "type": "code",
                    "code": "ts function f ( x ) { let x = 100 ; // error: interferes with parameter declaration } function g () { let x = 100 ; var x = 100 ; // error: can't have both declarations of 'x' }"
                },
                {
                    "type": "p",
                    "text": "That’s not to say that a block-scoped variable can never be declared with a function-scoped variable.\nThe block-scoped variable just needs to be declared within a distinctly different block."
                },
                {
                    "type": "code",
                    "code": "ts function f ( condition , x ) { if ( condition ) { let x = 100 ; return x ; } return x ; } f ( false , 0 ); // returns '0' f ( true , 0 ); // returns '100'"
                },
                {
                    "type": "p",
                    "text": "The act of introducing a new name in a more nested scope is called shadowing .\nIt is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs.\nFor instance, imagine we had written our earlier sumMatrix function using let variables."
                },
                {
                    "type": "code",
                    "code": "ts function sumMatrix ( matrix : number [][]) { let sum = 0 ; for ( let i = 0 ; i < matrix . length ; i ++) { var currentRow = matrix [ i ]; for ( let i = 0 ; i < currentRow . length ; i ++) { sum += currentRow [ i ]; } } return sum ; }"
                },
                {
                    "type": "p",
                    "text": "This version of the loop will actually perform the summation correctly because the inner loop’s i shadows i from the outer loop. Shadowing should usually be avoided in the interest of writing clearer code.\nWhile there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement. When we first touched on the idea of variable capturing with var declaration, we briefly went into how variables act once captured.\nTo give a better intuition of this, each time a scope is run, it creates an “environment” of variables.\nThat environment and its captured variables can exist even after everything within its scope has finished executing."
                },
                {
                    "type": "code",
                    "code": "ts function theCityThatAlwaysSleeps () { let getCity ; if ( true ) { let city = \"Seattle\" ; getCity = function () { return city ; }; } return getCity (); }"
                },
                {
                    "type": "p",
                    "text": "Because we’ve captured city from within its environment, we’re still able to access it despite the fact that the if block finished executing. Recall that with our earlier setTimeout example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the for loop.\nIn effect, what we were doing was creating a new variable environment for our captured variables.\nThat was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript. let declarations have drastically different behavior when declared as part of a loop.\nRather than just introducing a new environment to the loop itself, these declarations sort of create a new scope per iteration .\nSince this is what we were doing anyway with our IIFE, we can change our old setTimeout example to just use a let declaration."
                },
                {
                    "type": "code",
                    "code": "ts for ( let i = 0 ; i < 10 ; i ++) { setTimeout ( function () { console . log ( i ); }, 100 * i ); }"
                },
                {
                    "type": "p",
                    "text": "and as expected, this will print out"
                },
                {
                    "type": "code",
                    "code": "0 1 2 3 4 5 6 7 8 9"
                },
                {
                    "type": "p",
                    "text": "const declarations are another way of declaring variables."
                },
                {
                    "type": "code",
                    "code": "ts const numLivesForCat = 9 ;"
                },
                {
                    "type": "p",
                    "text": "They are like let declarations but, as their name implies, their value cannot be changed once they are bound.\nIn other words, they have the same scoping rules as let , but you can’t re-assign to them. This should not be confused with the idea that the values they refer to are immutable ."
                },
                {
                    "type": "code",
                    "code": "ts const numLivesForCat = 9 ; const kitty = { name: \"Aurora\" , numLives: numLivesForCat , }; // Error kitty = { name: \"Danielle\" , numLives: numLivesForCat , }; // all \"okay\" kitty . name = \"Rory\" ; kitty . name = \"Kitty\" ; kitty . name = \"Cat\" ; kitty . numLives --;"
                },
                {
                    "type": "p",
                    "text": "Unless you take specific measures to avoid it, the internal state of a const variable is still modifiable.\nFortunately, TypeScript allows you to specify that members of an object are readonly .\nThe chapter on Interfaces has the details. Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use.\nLike most broad questions, the answer is: it depends. Applying the principle of least privilege , all declarations other than those you plan to modify should use const .\nThe rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable.\nUsing const also makes code more predictable when reasoning about flow of data. Use your best judgement, and if applicable, consult the matter with the rest of your team. The majority of this handbook uses let declarations. Another ECMAScript 2015 feature that TypeScript has is destructuring.\nFor a complete reference, see the article on the Mozilla Developer Network .\nIn this section, we’ll give a short overview. The simplest form of destructuring is array destructuring assignment:"
                },
                {
                    "type": "code",
                    "code": "ts let input = [ 1 , 2 ]; let [ first , second ] = input ; console . log ( first ); // outputs 1 console . log ( second ); // outputs 2"
                },
                {
                    "type": "p",
                    "text": "This creates two new variables named first and second .\nThis is equivalent to using indexing, but is much more convenient:"
                },
                {
                    "type": "code",
                    "code": "ts first = input [ 0 ]; second = input [ 1 ];"
                },
                {
                    "type": "p",
                    "text": "Destructuring works with already-declared variables as well:"
                },
                {
                    "type": "code",
                    "code": "ts // swap variables [ first , second ] = [ second , first ];"
                },
                {
                    "type": "p",
                    "text": "And with parameters to a function:"
                },
                {
                    "type": "code",
                    "code": "ts function f ([ first , second ]: [ number , number ]) { console . log ( first ); console . log ( second ); } f ([ 1 , 2 ]);"
                },
                {
                    "type": "p",
                    "text": "You can create a variable for the remaining items in a list using the syntax ... :"
                },
                {
                    "type": "code",
                    "code": "ts let [ first , ... rest ] = [ 1 , 2 , 3 , 4 ]; console . log ( first ); // outputs 1 console . log ( rest ); // outputs [ 2, 3, 4 ]"
                },
                {
                    "type": "p",
                    "text": "Of course, since this is JavaScript, you can just ignore trailing elements you don’t care about:"
                },
                {
                    "type": "code",
                    "code": "ts let [ first ] = [ 1 , 2 , 3 , 4 ]; console . log ( first ); // outputs 1"
                },
                {
                    "type": "code",
                    "code": "ts let [, second , , fourth ] = [ 1 , 2 , 3 , 4 ]; console . log ( second ); // outputs 2 console . log ( fourth ); // outputs 4"
                },
                {
                    "type": "p",
                    "text": "Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:"
                },
                {
                    "type": "code",
                    "code": "ts let tuple : [ number , string , boolean ] = [ 7 , \"hello\" , true ]; let [ a , b , c ] = tuple ; // a: number, b: string, c: boolean"
                },
                {
                    "type": "p",
                    "text": "It’s an error to destructure a tuple beyond the range of its elements:"
                },
                {
                    "type": "code",
                    "code": "ts let [ a , b , c , d ] = tuple ; // Error, no element at index 3"
                },
                {
                    "type": "p",
                    "text": "As with arrays, you can destructure the rest of the tuple with ... , to get a shorter tuple:"
                },
                {
                    "type": "code",
                    "code": "ts let [ a , ... bc ] = tuple ; // bc: [string, boolean] let [ a , b , c , ... d ] = tuple ; // d: [], the empty tuple"
                },
                {
                    "type": "p",
                    "text": "Or ignore trailing elements, or other elements:"
                },
                {
                    "type": "code",
                    "code": "ts let [ a ] = tuple ; // a: number let [, b ] = tuple ; // b: string"
                },
                {
                    "type": "code",
                    "code": "ts let o = { a: \"foo\" , b: 12 , c: \"bar\" , }; let { a , b } = o ;"
                },
                {
                    "type": "p",
                    "text": "This creates new variables a and b from o.a and o.b .\nNotice that you can skip c if you don’t need it. Like array destructuring, you can have assignment without declaration:"
                },
                {
                    "type": "code",
                    "code": "ts ({ a , b } = { a: \"baz\" , b: 101 });"
                },
                {
                    "type": "p",
                    "text": "Notice that we had to surround this statement with parentheses.\nJavaScript normally parses a { as the start of block. You can create a variable for the remaining items in an object using the syntax ... :"
                },
                {
                    "type": "code",
                    "code": "ts let { a , ... passthrough } = o ; let total = passthrough . b + passthrough . c . length ;"
                },
                {
                    "type": "p",
                    "text": "You can also give different names to properties:"
                },
                {
                    "type": "code",
                    "code": "ts let { a : newName1 , b : newName2 } = o ;"
                },
                {
                    "type": "p",
                    "text": "Here the syntax starts to get confusing.\nYou can read a: newName1 as ” a as newName1 ”.\nThe direction is left-to-right, as if you had written:"
                },
                {
                    "type": "code",
                    "code": "ts let newName1 = o . a ; let newName2 = o . b ;"
                },
                {
                    "type": "p",
                    "text": "Confusingly, the colon here does not indicate the type.\nThe type, if you specify it, still needs to be written after the entire destructuring:"
                },
                {
                    "type": "code",
                    "code": "ts let { a : newName1 , b : newName2 }: { a : string ; b : number } = o ;"
                },
                {
                    "type": "p",
                    "text": "Default values let you specify a default value in case a property is undefined:"
                },
                {
                    "type": "code",
                    "code": "ts function keepWholeObject ( wholeObject : { a : string ; b ?: number }) { let { a , b = 1001 } = wholeObject ; }"
                },
                {
                    "type": "p",
                    "text": "In this example the b? indicates that b is optional, so it may be undefined . keepWholeObject now has a variable for wholeObject as well as the properties a and b , even if b is undefined. Destructuring also works in function declarations.\nFor simple cases this is straightforward:"
                },
                {
                    "type": "code",
                    "code": "ts type C = { a : string ; b ?: number }; function f ({ a , b }: C ): void { // ... }"
                },
                {
                    "type": "p",
                    "text": "But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky.\nFirst of all, you need to remember to put the pattern before the default value."
                },
                {
                    "type": "code",
                    "code": "ts function f ({ a = \"\" , b = 0 } = {}): void { // ... } f ();"
                },
                {
                    "type": "p",
                    "text": "The snippet above is an example of type inference, explained earlier in the handbook. Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer.\nRemember that C was defined with b optional:"
                },
                {
                    "type": "code",
                    "code": "ts function f ({ a , b = 0 } = { a: \"\" }): void { // ... } f ({ a: \"yes\" }); // ok, default b = 0 f (); // ok, default to { a: \"\" }, which then defaults b = 0 f ({}); // error, 'a' is required if you supply an argument"
                },
                {
                    "type": "p",
                    "text": "Use destructuring with care.\nAs the previous example demonstrates, anything but the simplest destructuring expression is confusing.\nThis is especially true with deeply nested destructuring, which gets really hard to understand even without piling on renaming, default values, and type annotations.\nTry to keep destructuring expressions small and simple.\nYou can always write the assignments that destructuring would generate yourself. The spread operator is the opposite of destructuring.\nIt allows you to spread an array into another array, or an object into another object.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "ts let first = [ 1 , 2 ]; let second = [ 3 , 4 ]; let bothPlus = [ 0 , ... first , ... second , 5 ];"
                },
                {
                    "type": "p",
                    "text": "This gives bothPlus the value [0, 1, 2, 3, 4, 5] .\nSpreading creates a shallow copy of first and second .\nThey are not changed by the spread."
                },
                {
                    "type": "code",
                    "code": "ts let defaults = { food: \"spicy\" , price: \"$$\" , ambiance: \"noisy\" }; let search = { ... defaults , food: \"rich\" };"
                },
                {
                    "type": "p",
                    "text": "Now search is { food: \"rich\", price: \"$$\", ambiance: \"noisy\" } .\nObject spreading is more complex than array spreading.\nLike array spreading, it proceeds from left-to-right, but the result is still an object.\nThis means that properties that come later in the spread object overwrite properties that come earlier.\nSo if we modify the previous example to spread at the end:"
                },
                {
                    "type": "code",
                    "code": "ts let defaults = { food: \"spicy\" , price: \"$$\" , ambiance: \"noisy\" }; let search = { food: \"rich\" , ... defaults };"
                },
                {
                    "type": "p",
                    "text": "Then the food property in defaults overwrites food: \"rich\" , which is not what we want in this case. Object spread also has a couple of other surprising limits.\nFirst, it only includes an objects’ own, enumerable properties .\nBasically, that means you lose methods when you spread instances of an object:"
                },
                {
                    "type": "code",
                    "code": "ts class C { p = 12 ; m () {} } let c = new C (); let clone = { ... c }; clone . p ; // ok clone . m (); // error!"
                },
                {
                    "type": "p",
                    "text": "Second, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions.\nThat feature is expected in future versions of the language. using declarations are an upcoming feature for JavaScript that are part of the Stage 3 Explicit Resource Management proposal. A using declaration is much like a const declaration, except that it couples the lifetime of the value bound to the\ndeclaration with the scope of the variable. When control exits the block containing a using declaration, the [Symbol.dispose]() method of the\ndeclared value is executed, which allows that value to perform cleanup:"
                },
                {
                    "type": "code",
                    "code": "ts function f () { using x = new C (); doSomethingWith ( x ); } // `x[Symbol.dispose]()` is called"
                },
                {
                    "type": "p",
                    "text": "At runtime, this has an effect roughly equivalent to the following:"
                },
                {
                    "type": "code",
                    "code": "ts function f () { const x = new C (); try { doSomethingWith ( x ); } finally { x [ Symbol . dispose ](); } }"
                },
                {
                    "type": "p",
                    "text": "using declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to\nnative references like file handles"
                },
                {
                    "type": "code",
                    "code": "ts { using file = await openFile (); file . write ( text ); doSomethingThatMayThrow (); } // `file` is disposed, even if an error is thrown"
                },
                {
                    "type": "code",
                    "code": "ts function f () { using activity = new TraceActivity ( \"f\" ); // traces entry into function // ... } // traces exit of function"
                },
                {
                    "type": "p",
                    "text": "Unlike var , let , and const , using declarations do not support destructuring. It’s important to note that the value can be null or undefined , in which case nothing is disposed at the end of the\nblock:"
                },
                {
                    "type": "code",
                    "code": "ts { using x = b ? new C () : null ; // ... }"
                },
                {
                    "type": "code",
                    "code": "ts { const x = b ? new C () : null ; try { // ... } finally { x ?.[ Symbol . dispose ](); } }"
                },
                {
                    "type": "p",
                    "text": "This allows you to conditionally acquire resources when declaring a using declaration without the need for complex\nbranching or repetition. You can indicate the classes or objects you produce are disposable by implementing the Disposable interface:"
                },
                {
                    "type": "code",
                    "code": "ts // from the default lib: interface Disposable { [ Symbol . dispose ](): void ; } // usage: class TraceActivity implements Disposable { readonly name : string ; constructor ( name : string ) { this . name = name ; console . log ( `Entering: ${ name } ` ); } [ Symbol . dispose ](): void { console . log ( `Exiting: ${ name } ` ); } } function f () { using _activity = new TraceActivity ( \"f\" ); console . log ( \"Hello world!\" ); } f (); // prints: //   Entering: f //   Hello world! //   Exiting: f"
                },
                {
                    "type": "p",
                    "text": "Some resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the Explicit Resource Management proposal also introduces\nthe await using declaration:"
                },
                {
                    "type": "code",
                    "code": "ts async function f () { await using x = new C (); } // `await x[Symbol.asyncDispose]()` is invoked"
                },
                {
                    "type": "p",
                    "text": "An await using declaration invokes, and awaits , its value’s [Symbol.asyncDispose]() method as control leaves the\ncontaining block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit,\nor a file stream flushing any pending writes to storage before it is closed. As with await , await using can only be used in an async function or method, or at the top level of a module. Just as using relies on objects that are Disposable , an await using relies on objects that are AsyncDisposable :"
                },
                {
                    "type": "code",
                    "code": "ts // from the default lib: interface AsyncDisposable { [ Symbol . asyncDispose ]: PromiseLike < void >; } // usage: class DatabaseTransaction implements AsyncDisposable { public success = false ; private db : Database | undefined ; private constructor ( db : Database ) { this . db = db ; } static async create ( db : Database ) { await db . execAsync ( \"BEGIN TRANSACTION\" ); return new DatabaseTransaction ( db ); } async [ Symbol . asyncDispose ]() { if ( this . db ) { const db = this . db : this . db = undefined ; if ( this . success ) { await db . execAsync ( \"COMMIT TRANSACTION\" ); } else { await db . execAsync ( \"ROLLBACK TRANSACTION\" ); } } } } async function transfer ( db : Database , account1 : Account , account2 : Account , amount : number ) { using tx = await DatabaseTransaction . create ( db ); if ( await debitAccount ( db , account1 , amount )) { await creditAccount ( db , account2 , amount ); } // if an exception is thrown before this line, the transaction will roll back tx . success = true ; // now the transaction will commit }"
                },
                {
                    "type": "p",
                    "text": "The await keyword that is part of the await using declaration only indicates that the disposal of the resource is await -ed. It does not await the value itself:"
                },
                {
                    "type": "code",
                    "code": "ts { await using x = getResourceSynchronously (); } // performs `await x[Symbol.asyncDispose]()` { await using y = await getResourceAsynchronously (); } // performs `await y[Symbol.asyncDispose]()`"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that there is a small caveat with this behavior if you are using an await using declaration in\nan async function that returns a Promise without first await -ing it:"
                },
                {
                    "type": "code",
                    "code": "ts function g () { return Promise . reject ( \"error!\" ); } async function f () { await using x = new C (); return g (); // missing an `await` }"
                },
                {
                    "type": "p",
                    "text": "Because the returned promise isn’t await -ed, it’s possible that the JavaScript runtime may report an unhandled\nrejection since execution pauses while await -ing the asynchronous disposal of x , without having subscribed to the\nreturned promise. This is not a problem that is unique to await using , however, as this can also occur in an async function that uses try..finally :"
                },
                {
                    "type": "code",
                    "code": "ts async function f () { try { return g (); // also reports an unhandled rejection } finally { await somethingElse (); } }"
                },
                {
                    "type": "p",
                    "text": "To avoid this situation, it is recommended that you await your return value if it may be a Promise :"
                },
                {
                    "type": "code",
                    "code": "ts async function f () { await using x = new C (); return await g (); }"
                },
                {
                    "type": "p",
                    "text": "Both using and await using can be used in a for statement:"
                },
                {
                    "type": "code",
                    "code": "ts for ( using x = getReader (); ! x . eof ; x . next ()) { // ... }"
                },
                {
                    "type": "p",
                    "text": "In this case, the lifetime of x is scoped to the entire for statement and is only disposed when control leaves the\nloop due to break , return , throw , or when the loop condition is false. In addition to for statements, both declarations can also be used in for..of statements:"
                },
                {
                    "type": "code",
                    "code": "ts function * g () { yield createResource1 (); yield createResource2 (); } for ( using x of g ()) { // ... }"
                },
                {
                    "type": "p",
                    "text": "Here, x is disposed at the end of each iteration of the loop , and is then reinitialized with the next value. This is\nespecially useful when consuming resources produced one at a time by a generator. using and await using declarations can be used when targeting older ECMAScript editions as long as you are using\na compatible polyfill for Symbol.dispose / Symbol.asyncDispose , such as the one provided by default in recent\neditions of NodeJS. The TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤"
                }
            ]
        }
    ]
}