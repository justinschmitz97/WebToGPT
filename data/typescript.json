{
    "name": "https://www.typescriptlang.org",
    "url": "https://https://www.typescriptlang.org",
    "pages": [
        {
            "url": "https://www.typescriptlang.org",
            "title": "TypeScript: JavaScript With Syntax For Types.",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript isJavaScript with syntax for types."
                },
                {
                    "type": "p",
                    "text": "TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale."
                },
                {
                    "type": "list",
                    "items": [
                        "Editor Checks",
                        "Auto-complete",
                        "Interfaces",
                        "JSX"
                    ]
                },
                {
                    "type": "code",
                    "code": "tsconstuser={firstName:\"Angela\",lastName:\"Davis\",role:\"Professor\",}console.log(user.name)Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'."
                },
                {
                    "type": "code",
                    "code": "tsconstuser={firstName:\"Angela\",lastName:\"Davis\",role:\"Professor\",}console.log(user.name)Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'."
                },
                {
                    "type": "p",
                    "text": "TypeScript5.6is now available,5.7is currently in beta."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What is TypeScript?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "JavaScript and More"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds additional syntax to JavaScript to support atighter integration with your editor. Catch errors early in your editor."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "A Result You Can Trust"
                },
                {
                    "type": "p",
                    "text": "TypeScript code converts to JavaScript, whichruns anywhere JavaScript runs: In a browser, on Node.js or Deno and in your apps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Safety at Scale"
                },
                {
                    "type": "p",
                    "text": "TypeScript understands JavaScript and usestype inference to give you great toolingwithout additional code."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Get Started"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adopt TypeScript Gradually"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Apply types to your JavaScript project incrementally,each step improves editor supportand improves your codebase."
                },
                {
                    "type": "p",
                    "text": "Let's take this incorrect JavaScript code, and see howTypeScript can catch mistakes in your editor."
                },
                {
                    "type": "code",
                    "code": "jsfunctioncompact(arr) {if(orr.length>10)returnarr.trim(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "No editor warnings in JavaScript filesThis code crashes at runtime!"
                },
                {
                    "type": "p",
                    "text": "JavaScript file"
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkfunctioncompact(arr) {if(orr.length>10)Cannot find name 'orr'.2304Cannot find name 'orr'.returnarr.trim(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "Adding this to a JS file shows errors in your editor"
                },
                {
                    "type": "p",
                    "text": "the param is arr, not orr!"
                },
                {
                    "type": "p",
                    "text": "JavaScript with TS Check"
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@param{any[]}arr*/functioncompact(arr) {if(arr.length>10)returnarr.trim(0,10)Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.returnarr}"
                },
                {
                    "type": "p",
                    "text": "Using JSDoc to give type information"
                },
                {
                    "type": "p",
                    "text": "Now TS has found a bad call. Arrays have slice, not trim."
                },
                {
                    "type": "p",
                    "text": "JavaScript with JSDoc"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncompact(arr:string[]) {if(arr.length>10)returnarr.slice(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds natural syntax for providing types"
                },
                {
                    "type": "p",
                    "text": "TypeScript file"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Describe Your Data"
                },
                {
                    "type": "p",
                    "text": "Describe the shape of objects and functionsin your code."
                },
                {
                    "type": "p",
                    "text": "Making it possible to seedocumentation and issues in your editor."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAccount{id:numberdisplayName:stringversion:1}functionwelcome(user:Account) {console.log(user.id)}"
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript becomes JavaScript via the delete key."
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "TypeScript file."
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "Types are removed."
                },
                {
                    "type": "code",
                    "code": "jsfunctionverify(result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "JavaScript file."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript Testimonials"
                },
                {
                    "type": "p",
                    "text": "First, we were surprised by the number of small bugs we found when converting our code."
                },
                {
                    "type": "p",
                    "text": "Second, we underestimated how powerful the editor integration is."
                },
                {
                    "type": "p",
                    "text": "TypeScript was such a boon to our stability and sanity that we started using it for all new code within days of starting the conversion."
                },
                {
                    "type": "p",
                    "text": "Felix Rieseberg at Slack covered the transition of their desktop app from JavaScript to TypeScript in their blog"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Open Source with TypeScript"
                },
                {
                    "type": "p",
                    "text": "Angular"
                },
                {
                    "type": "p",
                    "text": "Vue"
                },
                {
                    "type": "p",
                    "text": "Jest"
                },
                {
                    "type": "p",
                    "text": "Redux"
                },
                {
                    "type": "p",
                    "text": "Ionic"
                },
                {
                    "type": "p",
                    "text": "Probot"
                },
                {
                    "type": "p",
                    "text": "Deno"
                },
                {
                    "type": "p",
                    "text": "Vercel"
                },
                {
                    "type": "p",
                    "text": "Yarn"
                },
                {
                    "type": "p",
                    "text": "GitHubDesktop"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Loved by Developers"
                },
                {
                    "type": "p",
                    "text": "Voted2nd most loved programming languagein theStack Overflow 2020 Developer survey"
                },
                {
                    "type": "p",
                    "text": "TypeScript wasused by 78%of the2020 State of JSrespondents, with93% saying they would use it again."
                },
                {
                    "type": "p",
                    "text": "TypeScript was given the award for“Most Adopted Technology”based on year-on-year growth."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Get Started"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/branding",
            "title": "TypeScript: Branding",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Branding"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Logos and design assets for TypeScript"
                },
                {
                    "type": "p",
                    "text": "Click to download the asset pack"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recommendations"
                },
                {
                    "type": "p",
                    "text": "Please use the blue TypeScript mark above as the primary logo for TypeScript."
                },
                {
                    "type": "p",
                    "text": "This is the right logo for blog posts, news articles, giveaway stickers and general marketing for yourself."
                },
                {
                    "type": "p",
                    "text": "The “TS” in the logo is white, not transparent by default."
                },
                {
                    "type": "p",
                    "text": "There is a capital “S” in TypeScript, just like in JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "p",
                    "text": "Single color variant which has the “TS” cut out, useful for when you need a single color design."
                },
                {
                    "type": "p",
                    "text": "Full lettermark version of the TypeScript logo."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Palette"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Please Don't"
                },
                {
                    "type": "p",
                    "text": "Use the TypeScript logos for your application/product."
                },
                {
                    "type": "p",
                    "text": "Modify the shape of the logos when used."
                },
                {
                    "type": "p",
                    "text": "Integrate the TypeScript logo into your application's logo."
                },
                {
                    "type": "p",
                    "text": "Name a product which implies TypeScript's endorsement of the product."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/cheatsheets",
            "title": "TypeScript: Cheat Sheets",
            "content": [
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript Cheat Sheets"
                },
                {
                    "type": "p",
                    "text": "Downloadable syntax reference pages for different parts of everyday TypeScript code"
                },
                {
                    "type": "p",
                    "text": "Learn more about Classes, Interfaces, Types and Control Flow Analysis"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/community",
            "title": "TypeScript: TypeScript Community Resources",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Connect with us"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Online"
                },
                {
                    "type": "p",
                    "text": "Tell us what’s working well, what you want to see added or improved, and find out about new updates."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Stack Overflow"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Chat"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "GitHub"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Twitter"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Blog"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Definitely Typed"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Connect in person"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conferences"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "TSConf:EU"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conferences"
                },
                {
                    "type": "p",
                    "text": "Hello"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Meetups"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Boston TypeScript Club"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Hamburg TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Krakow TypeScript User Group"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Melbourne TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Milano TS"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Seattle TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Sevilla TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "San Francisco TypeScript Meetup"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Sydney TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "TypeScript NYC"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "TypeScript Brazil Meetup"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "TypeScript JP"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Paris TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Phoenix TypeScript"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Wroclaw TypeScript"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/bug-workbench",
            "title": "TypeScript: Bug Workbench",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/playground-plugins",
            "title": "TypeScript: Developers - Playground Plugins",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Your toys, our sandbox"
                },
                {
                    "type": "p",
                    "text": "The new TypeScript Playground allows people to hook into the Playground and extend it in ways in which the TypeScript team don't expect."
                },
                {
                    "type": "p",
                    "text": "The sidebar of the Playground uses the same plugin infrastructure as external plugins, so you have the same level of access as the playground to build interesting projects."
                },
                {
                    "type": "p",
                    "text": "Playground plugins are built via the DOM API and an expansive Design System, however, you're free to use a framework like React or Svelte at runtime."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Getting started is easy, we have a plugin template, and the Playground has a dev-mode for hooking directly to your local server, so you don't need to run a copy of the TypeScript website to have a working development environment."
                },
                {
                    "type": "p",
                    "text": "There is a repo of sample plugins atmicrosoft/TypeScript-Playground-Samplesand there are many existing open source plugins to look at too:Presentation Mode,ClippyTSQuery,CollaborateandTransformerwhich are available by default for you to investigate and understand."
                },
                {
                    "type": "p",
                    "text": "If you have questions as you are working on your plugin, ask in theTypeScript Community Discord. When it is polished, ship it to the npm registry and it will make its way into the plugins sidebar."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Quick Tutorial"
                },
                {
                    "type": "p",
                    "text": "You need about 5 minutes, Node.js, yarn and Firefox/Edge or Chrome."
                },
                {
                    "type": "p",
                    "text": "Step 1: Use the template to bootstrap:yarn create typescript-playground-plugin playground-my-plugin"
                },
                {
                    "type": "p",
                    "text": "Step 2: Runyarn startin the new repo, to start up the local dev server"
                },
                {
                    "type": "p",
                    "text": "Step 3: Open theplaygroundin your browser, click \"Options\" and enable\"Connect to localhost:5000/index.js\""
                },
                {
                    "type": "p",
                    "text": "Step 4: Refresh, and see the new tab. That's your plugin up and running"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "That's all the pieces working in tandem, now you can make changes to the template and build out your plugin. The plugin in dev mode will always become forefront when connected, so you can re-load without a lot of clicks. To understand the template's technology, read theCONTRIBUTING.md"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "p",
                    "text": "There are community-run templates for Playground plugins which bootstrap your plugin with well-known view libraries:"
                },
                {
                    "type": "list",
                    "items": [
                        "gojutin/typescript-playground-plugin-react",
                        "gojutin/typescript-playground-plugin-svelte"
                    ]
                },
                {
                    "type": "p",
                    "text": "They have their own up-to-date documentation in their READMEs."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/sandbox",
            "title": "TypeScript: Developers - Sandbox",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript Sandbox"
                },
                {
                    "type": "p",
                    "text": "A DOM library for interacting with TypeScript and JavaScript code, which powers the heart of theTypeScript playground"
                },
                {
                    "type": "p",
                    "text": "You can use the TypeScript sandbox for:"
                },
                {
                    "type": "list",
                    "items": [
                        "Building IDE-like experiences for people to explore your library's API",
                        "Building interactive web tools which use TypeScript, with a lot of the Playgrounds developer experience for free"
                    ]
                },
                {
                    "type": "p",
                    "text": "For example, the sandbox to the side has grabbed the Types forDangerJSwith no modifications for this code sample. This is because the Playground's Automatic Type Acquisition is enabled by default. It will also look for the same parameters for code, and selection indexes inside the URL."
                },
                {
                    "type": "p",
                    "text": "Try clickingthis URLto see that in action."
                },
                {
                    "type": "p",
                    "text": "This library builds on top of theMonaco Editor, providing a higher level API but offering access to all the lower-level APIs via a singlesandboxobject."
                },
                {
                    "type": "p",
                    "text": "You can find the code for the TypeScript Sandbox inside themicrosoft/TypeScript-Websitemono-repo."
                },
                {
                    "type": "p",
                    "text": "Downloading Sandbox..."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "A sandbox uses the same tools as monaco-editor, meaning this library is shipped as an AMD bundle which you can use theVSCode Loadertorequire."
                },
                {
                    "type": "p",
                    "text": "Because we need it for the TypeScript website, you can use our hosted copyhere."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Get Started"
                },
                {
                    "type": "p",
                    "text": "Create a new file:index.htmland paste this code into that file."
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n  <div id=\"loader\">Loading...</div>\n  <div id=\"monaco-editor-embed\" style=\"height: 800px;\" />\n  <script>\n    // First set up the VSCode loader in a script tag\n    const getLoaderScript = document.createElement('script')\n    getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'\n    getLoaderScript.async = true\n    getLoaderScript.onload = () => {\n      // Now the loader is ready, tell require where it can get the version of monaco, and the sandbox\n      // This version uses the latest version of the sandbox, which is used on the TypeScript website\n\n      // For the monaco version you can use unpkg or the TypeSCript web infra CDN\n      // You can see the available releases for TypeScript here:\n      // https://playgroundcdn.typescriptlang.org/indexes/releases.json\n      //\n      require.config({\n        paths: {\n          vs: 'https://playgroundcdn.typescriptlang.org/cdn/4.0.5/monaco/min/vs',\n          // vs: 'https://unpkg.com/@typescript-deploys/monaco-editor@4.0.5/min/vs',\n          sandbox: 'https://www.typescriptlang.org/js/sandbox',\n        },\n        // This is something you need for monaco to work\n        ignoreDuplicateModules: ['vs/editor/editor.main'],\n      })\n\n      // Grab a copy of monaco, TypeScript and the sandbox\n      require(['vs/editor/editor.main', 'vs/language/typescript/tsWorker', 'sandbox/index'], (\n        main,\n        _tsWorker,\n        sandboxFactory\n      ) => {\n        const initialCode = `import {markdown, danger} from \"danger\"\n\nexport default async function () {\n    // Check for new @types in devDependencies\n    const packageJSONDiff = await danger.git.JSONDiffForFile(\"package.json\")\n    const newDeps = packageJSONDiff.devDependencies.added\n    const newTypesDeps = newDeps?.filter(d => d.includes(\"@types\")) ?? []\n    if (newTypesDeps.length){\n        markdown(\"Added new types packages \" + newTypesDeps.join(\", \"))\n    }\n}\n`\n\n        const isOK = main && window.ts && sandboxFactory\n        if (isOK) {\n          document.getElementById('loader').parentNode.removeChild(document.getElementById('loader'))\n        } else {\n          console.error('Could not get all the dependencies of sandbox set up!')\n          console.error('main', !!main, 'ts', !!window.ts, 'sandbox', !!sandbox)\n          return\n        }\n\n        // Create a sandbox and embed it into the div #monaco-editor-embed\n        const sandboxConfig = {\n          text: initialCode,\n          compilerOptions: {},\n          domID: 'monaco-editor-embed',\n        }\n\n        const sandbox = sandboxFactory.createTypeScriptSandbox(sandboxConfig, main, window.ts)\n        sandbox.editor.focus()\n      })\n    }\n\n    document.body.appendChild(getLoaderScript)\n  </script>\n</html>"
                },
                {
                    "type": "p",
                    "text": "Opening the fileindex.htmlin a web browser will load up the same sandbox up at the top of the page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Some examples of the API"
                },
                {
                    "type": "p",
                    "text": "Converting the user's TypeScript into JavaScript"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Async because it needs to go  \nconst js = await sandbox.getRunnableJS()\nconsole.log(js)"
                },
                {
                    "type": "p",
                    "text": "Get the DTS for the user's editor"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\nconst dts = await sandbox.getDTSForCode()\nconsole.log(dts)"
                },
                {
                    "type": "p",
                    "text": "Make a request for an LSP response"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// A worker here is a web-worker, set up by monaco-typescript\n// which does the computation in the background \nconst worker = await sandbox.getWorkerProcess()\nconst definitions =  await client.getDefinitionAtPosition(model.uri.toString(), 6)"
                },
                {
                    "type": "p",
                    "text": "Change compiler flags using a few different APIs"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Hook in to all changes to the compiler\nsandbox.setDidUpdateCompilerSettings((newOptions) => {\n  console.log(\"Compiler settings changed: \", newOptions)\n})\n\n// Update via key value\nsandbox.updateCompilerSetting(\"allowJs\", true)\n// Update via an object\nsandbox.updateCompilerSettings({ jsx: 0 })\n// Replace the compiler settings\nsandbox.setCompilerSettings({})"
                },
                {
                    "type": "p",
                    "text": "Highlight some code in the editor"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\nconst start = {\n  lineNumber: 0,\n  column: 0\n}\n\nconst end = {\n  lineNumber: 0,\n  column: 4\n}\n\nconst decorations = sandbox.editor.deltaDecorations([], [\n  {\n    range: new sandbox.monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column),\n    options: { inlineClassName: 'error-highlight' },\n  },\n])"
                },
                {
                    "type": "p",
                    "text": "Create your own playground."
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Use a script to make a JSON file like:\n// { \n//   \"file:///node_modules/types/keyboard/index.d.ts\": \"export const enterKey: string\"\n// }\n//\n// Where the keys are the paths, and the values are the source-code. The sandbox\n// will use the node resolution lookup strategy by default.\n\nconst dtsFiles = {} \n\nObject.keys(dtsFiles).forEach(path => {\n  sandbox.languageServiceDefaults.addExtraLib(dts[path], path);\n});"
                },
                {
                    "type": "p",
                    "text": "The API is mainly a light shim over themonaco-editor APIwith themonaco-typescript API."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/sandbox?q=1#code/PTAEBUAsFMGdtAYwPYFtXQHYBdagO7QBOCiJAhttACagCWmo2MEAngA7QDKZd72oAAoAbcqwDmRZAFdM1AFAhQ5OUxiNmCAKoAlADKhI5WJALGkydnRqhkAN2JNkahJmj5QuvfMVgodPAwVPBVWUHYpACtoRAFpWAZxNk4eIj4BWBVqACNkAA84JBVfUGhjOmEw+FUUagRyKVlabGcyxFNkTSJQHxRMWAEYYWFnAF5QACIACWhh5wB1ZCJhagn5PthkYWgAOhHxAAohkYBKIA",
            "title": "TypeScript: Developers - Sandbox",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript Sandbox"
                },
                {
                    "type": "p",
                    "text": "A DOM library for interacting with TypeScript and JavaScript code, which powers the heart of theTypeScript playground"
                },
                {
                    "type": "p",
                    "text": "You can use the TypeScript sandbox for:"
                },
                {
                    "type": "list",
                    "items": [
                        "Building IDE-like experiences for people to explore your library's API",
                        "Building interactive web tools which use TypeScript, with a lot of the Playgrounds developer experience for free"
                    ]
                },
                {
                    "type": "p",
                    "text": "For example, the sandbox to the side has grabbed the Types forDangerJSwith no modifications for this code sample. This is because the Playground's Automatic Type Acquisition is enabled by default. It will also look for the same parameters for code, and selection indexes inside the URL."
                },
                {
                    "type": "p",
                    "text": "Try clickingthis URLto see that in action."
                },
                {
                    "type": "p",
                    "text": "This library builds on top of theMonaco Editor, providing a higher level API but offering access to all the lower-level APIs via a singlesandboxobject."
                },
                {
                    "type": "p",
                    "text": "You can find the code for the TypeScript Sandbox inside themicrosoft/TypeScript-Websitemono-repo."
                },
                {
                    "type": "p",
                    "text": "Downloading Sandbox..."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "A sandbox uses the same tools as monaco-editor, meaning this library is shipped as an AMD bundle which you can use theVSCode Loadertorequire."
                },
                {
                    "type": "p",
                    "text": "Because we need it for the TypeScript website, you can use our hosted copyhere."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Get Started"
                },
                {
                    "type": "p",
                    "text": "Create a new file:index.htmland paste this code into that file."
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n  <div id=\"loader\">Loading...</div>\n  <div id=\"monaco-editor-embed\" style=\"height: 800px;\" />\n  <script>\n    // First set up the VSCode loader in a script tag\n    const getLoaderScript = document.createElement('script')\n    getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'\n    getLoaderScript.async = true\n    getLoaderScript.onload = () => {\n      // Now the loader is ready, tell require where it can get the version of monaco, and the sandbox\n      // This version uses the latest version of the sandbox, which is used on the TypeScript website\n\n      // For the monaco version you can use unpkg or the TypeSCript web infra CDN\n      // You can see the available releases for TypeScript here:\n      // https://playgroundcdn.typescriptlang.org/indexes/releases.json\n      //\n      require.config({\n        paths: {\n          vs: 'https://playgroundcdn.typescriptlang.org/cdn/4.0.5/monaco/min/vs',\n          // vs: 'https://unpkg.com/@typescript-deploys/monaco-editor@4.0.5/min/vs',\n          sandbox: 'https://www.typescriptlang.org/js/sandbox',\n        },\n        // This is something you need for monaco to work\n        ignoreDuplicateModules: ['vs/editor/editor.main'],\n      })\n\n      // Grab a copy of monaco, TypeScript and the sandbox\n      require(['vs/editor/editor.main', 'vs/language/typescript/tsWorker', 'sandbox/index'], (\n        main,\n        _tsWorker,\n        sandboxFactory\n      ) => {\n        const initialCode = `import {markdown, danger} from \"danger\"\n\nexport default async function () {\n    // Check for new @types in devDependencies\n    const packageJSONDiff = await danger.git.JSONDiffForFile(\"package.json\")\n    const newDeps = packageJSONDiff.devDependencies.added\n    const newTypesDeps = newDeps?.filter(d => d.includes(\"@types\")) ?? []\n    if (newTypesDeps.length){\n        markdown(\"Added new types packages \" + newTypesDeps.join(\", \"))\n    }\n}\n`\n\n        const isOK = main && window.ts && sandboxFactory\n        if (isOK) {\n          document.getElementById('loader').parentNode.removeChild(document.getElementById('loader'))\n        } else {\n          console.error('Could not get all the dependencies of sandbox set up!')\n          console.error('main', !!main, 'ts', !!window.ts, 'sandbox', !!sandbox)\n          return\n        }\n\n        // Create a sandbox and embed it into the div #monaco-editor-embed\n        const sandboxConfig = {\n          text: initialCode,\n          compilerOptions: {},\n          domID: 'monaco-editor-embed',\n        }\n\n        const sandbox = sandboxFactory.createTypeScriptSandbox(sandboxConfig, main, window.ts)\n        sandbox.editor.focus()\n      })\n    }\n\n    document.body.appendChild(getLoaderScript)\n  </script>\n</html>"
                },
                {
                    "type": "p",
                    "text": "Opening the fileindex.htmlin a web browser will load up the same sandbox up at the top of the page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Some examples of the API"
                },
                {
                    "type": "p",
                    "text": "Converting the user's TypeScript into JavaScript"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Async because it needs to go  \nconst js = await sandbox.getRunnableJS()\nconsole.log(js)"
                },
                {
                    "type": "p",
                    "text": "Get the DTS for the user's editor"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\nconst dts = await sandbox.getDTSForCode()\nconsole.log(dts)"
                },
                {
                    "type": "p",
                    "text": "Make a request for an LSP response"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// A worker here is a web-worker, set up by monaco-typescript\n// which does the computation in the background \nconst worker = await sandbox.getWorkerProcess()\nconst definitions =  await client.getDefinitionAtPosition(model.uri.toString(), 6)"
                },
                {
                    "type": "p",
                    "text": "Change compiler flags using a few different APIs"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Hook in to all changes to the compiler\nsandbox.setDidUpdateCompilerSettings((newOptions) => {\n  console.log(\"Compiler settings changed: \", newOptions)\n})\n\n// Update via key value\nsandbox.updateCompilerSetting(\"allowJs\", true)\n// Update via an object\nsandbox.updateCompilerSettings({ jsx: 0 })\n// Replace the compiler settings\nsandbox.setCompilerSettings({})"
                },
                {
                    "type": "p",
                    "text": "Highlight some code in the editor"
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\nconst start = {\n  lineNumber: 0,\n  column: 0\n}\n\nconst end = {\n  lineNumber: 0,\n  column: 4\n}\n\nconst decorations = sandbox.editor.deltaDecorations([], [\n  {\n    range: new sandbox.monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column),\n    options: { inlineClassName: 'error-highlight' },\n  },\n])"
                },
                {
                    "type": "p",
                    "text": "Create your own playground."
                },
                {
                    "type": "code",
                    "code": "const sandbox = createTypeScriptSandbox(sandboxConfig, main, ts)\n\n// Use a script to make a JSON file like:\n// { \n//   \"file:///node_modules/types/keyboard/index.d.ts\": \"export const enterKey: string\"\n// }\n//\n// Where the keys are the paths, and the values are the source-code. The sandbox\n// will use the node resolution lookup strategy by default.\n\nconst dtsFiles = {} \n\nObject.keys(dtsFiles).forEach(path => {\n  sandbox.languageServiceDefaults.addExtraLib(dts[path], path);\n});"
                },
                {
                    "type": "p",
                    "text": "The API is mainly a light shim over themonaco-editor APIwith themonaco-typescript API."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/twoslash",
            "title": "TypeScript: Developers - Twoslash Code Samples",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript Twoslash"
                },
                {
                    "type": "p",
                    "text": "A markup format for TypeScript code, ideal for creating self-contained code samples which let the TypeScript compiler do the extra leg-work."
                },
                {
                    "type": "p",
                    "text": "If you know TypeScript, you basically know twoslash."
                },
                {
                    "type": "p",
                    "text": "Twoslash adds the ability to declare tsconfig options inline, split a sample into multiple files and a few other useful commands. You can see the full APIinside the README"
                },
                {
                    "type": "p",
                    "text": "The Twoslash markup language helps with:"
                },
                {
                    "type": "list",
                    "items": [
                        "Enforcing accurate errors from a TypeScript code sample, and leaving the messaging to the compiler",
                        "Splitting a code sample to hide distracting code",
                        "Declaratively highlighting symbols in your code sample",
                        "Replacing code with the results of transpilation to different files, or ancillary files like .d.ts or .map files",
                        "Handle multi-file imports in a single code sample",
                        "Creating a playground link for the code"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Markup"
                },
                {
                    "type": "p",
                    "text": "See how TS Twoslash will grab the highlight information for identifiers in your code"
                },
                {
                    "type": "p",
                    "text": "Downloading Sandbox..."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Results"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "Twoslash's usage guide is available on the npm README at@typescript/twoslash."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/dev/typescript-vfs",
            "title": "TypeScript: Developers - TypeScript VFS",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Easy access to the compiler API"
                },
                {
                    "type": "p",
                    "text": "TypeScript VFS lets you create a self-contained TypeScript environment entirely under your control. This library is used to power the Playground, and provides the underlying tooling fortwoslashcode samples."
                },
                {
                    "type": "p",
                    "text": "There are 3 main uses for TypeScript VFS:"
                },
                {
                    "type": "list",
                    "items": [
                        "Creating a TypeScript Program as an entry-point to the compiler API",
                        "Running TypeScript to emit files like*.js,*.d.tsor*.map",
                        "Using TypeScript's language service to make the same calls an editor would make"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can learn more in theTypeScript VFS README"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Setup with TypeScript from node_modules"
                },
                {
                    "type": "code",
                    "code": "import ts from 'typescript'\nimport tsvfs from '@typescript/vfs'\n\nconst fsMap = tsvfs.createDefaultMapFromNodeModules({ target: ts.ScriptTarget.ES2015 })\nfsMap.set('index.ts', 'console.log(\"Hello World\")')\n\n// ...."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Use the TypeScript CDN to get your lib.d.ts files"
                },
                {
                    "type": "code",
                    "code": "import ts from 'typescript'\nimport tsvfs from '@typescript/vfs'\n\nconst fsMap = await tsvfs.createDefaultMapFromCDN(compilerOptions, ts.version, true, ts)\nfsMap.set('index.ts', 'console.log(\"Hello World\")')\n\nconst system = tsvfs.createSystem(fsMap)\nconst host = tsvfs.createVirtualCompilerHost(system, compilerOptions, ts)\n\nconst program = ts.createProgram({\n  rootNames: [...fsMap.keys()],\n  options: compilerOptions,\n  host: host.compilerHost,\n})\n\n// This will update the fsMap with new files\n// for the .d.ts and .js files\nprogram.emit()\n\n// Now I can look at the AST for the .ts file too\nconst index = program.getSourceFile('index.ts')"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs",
            "title": "TypeScript: The starting point for learning TypeScript",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript Documentation"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Get Started"
                },
                {
                    "type": "p",
                    "text": "Quick introductions based on your background or preference."
                },
                {
                    "type": "list",
                    "items": [
                        "TS for the New Programmer",
                        "TypeScript for JS Programmers",
                        "TS for Java/C# Programmers",
                        "TS for Functional Programmers",
                        "TypeScript Tooling in 5 minutes"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Handbook"
                },
                {
                    "type": "p",
                    "text": "A great first read for your daily TS work."
                },
                {
                    "type": "list",
                    "items": [
                        "The TypeScript Handbook",
                        "The Basics",
                        "Everyday Types",
                        "Narrowing",
                        "More on Functions",
                        "Object Types",
                        "Type Manipulation",
                        "Creating Types from TypesGenericsKeyof Type OperatorTypeof Type OperatorIndexed Access TypesConditional TypesMapped TypesTemplate Literal Types",
                        "Creating Types from Types",
                        "Generics",
                        "Keyof Type Operator",
                        "Typeof Type Operator",
                        "Indexed Access Types",
                        "Conditional Types",
                        "Mapped Types",
                        "Template Literal Types",
                        "Classes",
                        "Modules"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Creating Types from Types",
                        "Generics",
                        "Keyof Type Operator",
                        "Typeof Type Operator",
                        "Indexed Access Types",
                        "Conditional Types",
                        "Mapped Types",
                        "Template Literal Types"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Reference"
                },
                {
                    "type": "p",
                    "text": "Deep dive reference materials."
                },
                {
                    "type": "list",
                    "items": [
                        "Utility Types",
                        "Cheat Sheets",
                        "Decorators",
                        "Declaration Merging",
                        "Enums",
                        "Iterators and Generators",
                        "JSX",
                        "Mixins",
                        "Namespaces",
                        "Namespaces and Modules",
                        "Symbols",
                        "Triple-Slash Directives",
                        "Type Compatibility",
                        "Type Inference",
                        "Variable Declaration"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Modules Reference"
                },
                {
                    "type": "p",
                    "text": "How TypeScript models JavaScript modules."
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Theory",
                        "Guides",
                        "Choosing Compiler Options",
                        "Choosing Compiler Options",
                        "Reference",
                        "Appendices",
                        "ESM/CJS Interoperability",
                        "ESM/CJS Interoperability"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Choosing Compiler Options"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ESM/CJS Interoperability"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Tutorials"
                },
                {
                    "type": "p",
                    "text": "Using TypeScript in several environments."
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET Core",
                        "Gulp",
                        "DOM Manipulation",
                        "Migrating from JavaScript",
                        "Using Babel with TypeScript"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Declaration Files"
                },
                {
                    "type": "p",
                    "text": "Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions."
                },
                {
                    "type": "list",
                    "items": [
                        "Introduction",
                        "Declaration Reference",
                        "Library Structures",
                        ".d.ts Templates",
                        "Modules .d.tsModule: PluginModule: ClassModule: FunctionGlobal .d.tsGlobal: Modifying Module",
                        "Modules .d.ts",
                        "Module: Plugin",
                        "Module: Class",
                        "Module: Function",
                        "Global .d.ts",
                        "Global: Modifying Module",
                        "Do's and Don'ts",
                        "Deep Dive",
                        "Publishing",
                        "Consumption"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Modules .d.ts",
                        "Module: Plugin",
                        "Module: Class",
                        "Module: Function",
                        "Global .d.ts",
                        "Global: Modifying Module"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "JavaScript"
                },
                {
                    "type": "p",
                    "text": "How to use TypeScript-powered JavaScript tooling."
                },
                {
                    "type": "list",
                    "items": [
                        "JS Projects Utilizing TypeScript",
                        "Type Checking JavaScript Files",
                        "JSDoc Reference",
                        "Creating .d.ts Files from .js files"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Project Configuration"
                },
                {
                    "type": "p",
                    "text": "Compiler configuration reference."
                },
                {
                    "type": "list",
                    "items": [
                        "What is a tsconfig.json",
                        "Compiler Options in MSBuild",
                        "TSConfig Reference",
                        "tsc CLI Options",
                        "Project References",
                        "Integrating with Build Tools",
                        "Configuring Watch",
                        "Nightly Builds"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Cheat Sheets"
                },
                {
                    "type": "p",
                    "text": "Downloadable syntax reference pages for different parts of everyday TypeScript code."
                },
                {
                    "type": "list",
                    "items": [
                        "Control Flow Analysis",
                        "Classes",
                        "Interfaces",
                        "Types",
                        "Download PDFs and PNGs"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Learning Resources"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Get Started"
                },
                {
                    "type": "list",
                    "items": [
                        "JS to TS",
                        "New to Programming",
                        "OOP to JS",
                        "Functional to JS",
                        "Installation"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Handbook"
                },
                {
                    "type": "list",
                    "items": [
                        "Everyday Types",
                        "Creating Types from Types",
                        "Object Types",
                        "Variable Declarations",
                        "More on Functions"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Tools"
                },
                {
                    "type": "list",
                    "items": [
                        "Playground",
                        "TSConfig Reference"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Release Notes"
                },
                {
                    "type": "list",
                    "items": [
                        "What's upcoming in5.7?",
                        "What's new in5.6"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Tutorials"
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET",
                        "Migrating from JS",
                        "Working with the DOM",
                        "React & Webpack"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/basic-types.html",
            "title": "TypeScript: Documentation - The Basics",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "The Basics"
                },
                {
                    "type": "p",
                    "text": "Welcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the 'Getting Started' guides"
                },
                {
                    "type": "p",
                    "text": "Each and every value in JavaScript has a set of behaviors you can observe from running different operations.\nThat sounds abstract, but as a quick example, consider some operations we might run on a variable namedmessage."
                },
                {
                    "type": "code",
                    "code": "js// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message();"
                },
                {
                    "type": "p",
                    "text": "If we break this down, the first runnable line of code accesses a property calledtoLowerCaseand then calls it.\nThe second one tries to callmessagedirectly."
                },
                {
                    "type": "p",
                    "text": "But assuming we don’t know the value ofmessage- and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code.\nThe behavior of each operation depends entirely on what value we had in the first place."
                },
                {
                    "type": "list",
                    "items": [
                        "Ismessagecallable?",
                        "Does it have a property calledtoLowerCaseon it?",
                        "If it does, istoLowerCaseeven callable?",
                        "If both of these values are callable, what do they return?"
                    ]
                },
                {
                    "type": "p",
                    "text": "The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right."
                },
                {
                    "type": "p",
                    "text": "Let’s saymessagewas defined in the following way."
                },
                {
                    "type": "code",
                    "code": "jsconstmessage=\"Hello World!\";"
                },
                {
                    "type": "p",
                    "text": "As you can probably guess, if we try to runmessage.toLowerCase(), we’ll get the same string only in lower-case."
                },
                {
                    "type": "p",
                    "text": "What about that second line of code?\nIf you’re familiar with JavaScript, you’ll know this fails with an exception:"
                },
                {
                    "type": "code",
                    "code": "txtTypeError: message is not a function"
                },
                {
                    "type": "p",
                    "text": "It’d be great if we could avoid mistakes like this."
                },
                {
                    "type": "p",
                    "text": "When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out thetypeof the value - what sorts of behaviors and capabilities it has.\nThat’s part of what thatTypeErroris alluding to - it’s saying that the string\"Hello World!\"cannot be called as a function."
                },
                {
                    "type": "p",
                    "text": "For some values, such as the primitivesstringandnumber, we can identify their type at runtime using thetypeofoperator.\nBut for other things like functions, there’s no corresponding runtime mechanism to identify their types.\nFor example, consider this function:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionfn(x) {returnx.flip();}"
                },
                {
                    "type": "p",
                    "text": "We canobserveby reading the code that this function will only work if given an object with a callableflipproperty, but JavaScript doesn’t surface this information in a way that we can check while the code is running.\nThe only way in pure JavaScript to tell whatfndoes with a particular value is to call it and see what happens.\nThis kind of behavior makes it hard to predict what the code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it."
                },
                {
                    "type": "p",
                    "text": "Seen in this way, atypeis the concept of describing which values can be passed tofnand which will crash.\nJavaScript only truly providesdynamictyping - running the code to see what happens."
                },
                {
                    "type": "p",
                    "text": "The alternative is to use astatictype system to make predictions about what the code is expected to dobeforeit runs."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Static type-checking"
                },
                {
                    "type": "p",
                    "text": "Think back to thatTypeErrorwe got earlier from trying to call astringas a function.Most peopledon’t like to get any sorts of errors when running their code - those are considered bugs!\nAnd when we write new code, we try our best to avoid introducing new bugs."
                },
                {
                    "type": "p",
                    "text": "If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case.\nWe might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown!\nOr if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through."
                },
                {
                    "type": "p",
                    "text": "Ideally, we could have a tool that helps us find these bugsbeforeour code runs.\nThat’s what a static type-checker like TypeScript does.Static types systemsdescribe the shapes and behaviors of what our values will be when we run our programs.\nA type-checker like TypeScript uses that information and tells us when things might be going off the rails."
                },
                {
                    "type": "code",
                    "code": "tsconstmessage=\"hello!\";message();This expression is not callable.\n  Type 'String' has no call signatures.2349This expression is not callable.\n  Type 'String' has no call signatures.Try"
                },
                {
                    "type": "p",
                    "text": "Running that last sample with TypeScript will give us an error message before we run the code in the first place."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Non-exception Failures"
                },
                {
                    "type": "p",
                    "text": "So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical.\nThose cases come up becausethe ECMAScript specificationhas explicit instructions on how the language should behave when it runs into something unexpected."
                },
                {
                    "type": "p",
                    "text": "For example, the specification says that trying to call something that isn’t callable should throw an error.\nMaybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too.\nInstead, JavaScript gives us different behavior and returns the valueundefined:"
                },
                {
                    "type": "code",
                    "code": "jsconstuser= {name:\"Daniel\",age:26,};user.location;// returns undefined"
                },
                {
                    "type": "p",
                    "text": "Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error.\nIn TypeScript, the following code produces an error aboutlocationnot being defined:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser= {name:\"Daniel\",age:26,};user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.Try"
                },
                {
                    "type": "p",
                    "text": "While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs.\nAnd TypeScript catchesa lotof legitimate bugs."
                },
                {
                    "type": "p",
                    "text": "For example: typos,"
                },
                {
                    "type": "code",
                    "code": "tsconstannouncement=\"Hello World!\";// How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase();// We probably meant to write this...announcement.toLocaleLowerCase();Try"
                },
                {
                    "type": "p",
                    "text": "uncalled functions,"
                },
                {
                    "type": "code",
                    "code": "tsfunctionflipCoin() {// Meant to be Math.random()returnMath.random<0.5;Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "or basic logic errors."
                },
                {
                    "type": "code",
                    "code": "tsconstvalue=Math.random() <0.5?\"a\":\"b\";if(value!==\"a\") {// ...}elseif(value===\"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.// Oops, unreachable}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Types for Tooling"
                },
                {
                    "type": "p",
                    "text": "TypeScript can catch bugs when we make mistakes in our code.\nThat’s great, but TypeScript canalsoprevent us from making those mistakes in the first place."
                },
                {
                    "type": "p",
                    "text": "The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties.\nOnce it has that information, it can also startsuggestingwhich properties you might want to use."
                },
                {
                    "type": "p",
                    "text": "That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor.\nThat’s part of what people often refer to when they talk about tooling in TypeScript."
                },
                {
                    "type": "code",
                    "code": "tsimportexpressfrom\"express\";constapp=express();app.get(\"/\",function(req,res) {res.sensendsendDatesendfilesendFilesendStatus});app.listen(3000);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "send",
                        "sendDate",
                        "sendfile",
                        "sendFile",
                        "sendStatus"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript takes tooling seriously, and that goes beyond completions and errors as you type.\nAn editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable.\nAll of this is built on top of the type-checker and is fully cross-platform, so it’s likely thatyour favorite editor has TypeScript support available."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "tsc, the TypeScript compiler"
                },
                {
                    "type": "p",
                    "text": "We’ve been talking about type-checking, but we haven’t yet used our type-checker.\nLet’s get acquainted with our new friendtsc, the TypeScript compiler.\nFirst we’ll need to grab it via npm."
                },
                {
                    "type": "code",
                    "code": "shnpm install -g typescript"
                },
                {
                    "type": "p",
                    "text": "This installs the TypeScript Compilertscglobally.\nYou can usenpxor similar tools if you’d prefer to runtscfrom a localnode_modulespackage instead."
                },
                {
                    "type": "p",
                    "text": "Now let’s move to an empty folder and try writing our first TypeScript program:hello.ts:"
                },
                {
                    "type": "code",
                    "code": "ts// Greets the world.console.log(\"Hello world!\");Try"
                },
                {
                    "type": "p",
                    "text": "Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript.\nAnd now let’s type-check it by running the commandtscwhich was installed for us by thetypescriptpackage."
                },
                {
                    "type": "code",
                    "code": "shtsc hello.ts"
                },
                {
                    "type": "p",
                    "text": "Tada!"
                },
                {
                    "type": "p",
                    "text": "Wait, “tada”whatexactly?\nWe rantscand nothing happened!\nWell, there were no type errors, so we didn’t get any output in our console since there was nothing to report."
                },
                {
                    "type": "p",
                    "text": "But check again - we got somefileoutput instead.\nIf we look in our current directory, we’ll see ahello.jsfile next tohello.ts.\nThat’s the output from ourhello.tsfile aftertsccompilesortransformsit into a plain JavaScript file.\nAnd if we check the contents, we’ll see what TypeScript spits out after it processes a.tsfile:"
                },
                {
                    "type": "code",
                    "code": "js// Greets the world.console.log(\"Hello world!\");"
                },
                {
                    "type": "p",
                    "text": "In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote.\nThe compiler tries to emit clean readable code that looks like something a person would write.\nWhile that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around."
                },
                {
                    "type": "p",
                    "text": "What about if wedidintroduce a type-checking error?\nLet’s rewritehello.ts:"
                },
                {
                    "type": "code",
                    "code": "ts// This is an industrial-grade general-purpose greeter function:functiongreet(person,date) {console.log(`Hello${person}, today is${date}!`);}greet(\"Brendan\");Try"
                },
                {
                    "type": "p",
                    "text": "If we runtsc hello.tsagain, notice that we get an error on the command line!"
                },
                {
                    "type": "code",
                    "code": "txtExpected 2 arguments, but got 1."
                },
                {
                    "type": "p",
                    "text": "TypeScript is telling us we forgot to pass an argument to thegreetfunction, and rightfully so.\nSo far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code.\nThanks TypeScript!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Emitting with Errors"
                },
                {
                    "type": "p",
                    "text": "One thing you might not have noticed from the last example was that ourhello.jsfile changed again.\nIf we open that file up then we’ll see that the contents still basically look the same as our input file.\nThat might be a bit surprising given the fact thattscreported an error about our code, but this is based on one of TypeScript’s core values: much of the time,youwill know better than TypeScript."
                },
                {
                    "type": "p",
                    "text": "To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable.\nMost of the time that’s okay, but there are scenarios where those checks get in the way.\nFor example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors.\nEventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working!\nWhy should converting it over to TypeScript stop you from running it?"
                },
                {
                    "type": "p",
                    "text": "So TypeScript doesn’t get in your way.\nOf course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly.\nIn that case, you can use thenoEmitOnErrorcompiler option.\nTry changing yourhello.tsfile and runningtscwith that flag:"
                },
                {
                    "type": "code",
                    "code": "shtsc --noEmitOnError hello.ts"
                },
                {
                    "type": "p",
                    "text": "You’ll notice thathello.jsnever gets updated."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Explicit Types"
                },
                {
                    "type": "p",
                    "text": "Up until now, we haven’t told TypeScript whatpersonordateare.\nLet’s edit the code to tell TypeScript thatpersonis astring, and thatdateshould be aDateobject.\nWe’ll also use thetoDateString()method ondate."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(person:string,date:Date) {console.log(`Hello${person}, today is${date.toDateString()}!`);}Try"
                },
                {
                    "type": "p",
                    "text": "What we did was addtype annotationsonpersonanddateto describe what types of valuesgreetcan be called with.\nYou can read that signature as ”greettakes apersonof typestring, and adateof typeDate“."
                },
                {
                    "type": "p",
                    "text": "With this, TypeScript can tell us about other cases wheregreetmight have been called incorrectly.\nFor example…"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(person:string,date:Date) {console.log(`Hello${person}, today is${date.toDateString()}!`);}greet(\"Maddison\",Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.Try"
                },
                {
                    "type": "p",
                    "text": "Huh?\nTypeScript reported an error on our second argument, but why?"
                },
                {
                    "type": "p",
                    "text": "Perhaps surprisingly, callingDate()in JavaScript returns astring.\nOn the other hand, constructing aDatewithnew Date()actually gives us what we were expecting."
                },
                {
                    "type": "p",
                    "text": "Anyway, we can quickly fix up the error:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(person:string,date:Date) {console.log(`Hello${person}, today is${date.toDateString()}!`);}greet(\"Maddison\",newDate());Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind, we don’t always have to write explicit type annotations.\nIn many cases, TypeScript can even justinfer(or “figure out”) the types for us even if we omit them."
                },
                {
                    "type": "code",
                    "code": "tsletmsg=\"hello there!\";let msg: stringTry"
                },
                {
                    "type": "p",
                    "text": "Even though we didn’t tell TypeScript thatmsghad the typestringit was able to figure that out.\nThat’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway."
                },
                {
                    "type": "p",
                    "text": "Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Erased Types"
                },
                {
                    "type": "p",
                    "text": "Let’s take a look at what happens when we compile the above functiongreetwithtscto output JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";functiongreet(person,date) {console.log(\"Hello \".concat(person,\", today is \").concat(date.toDateString(),\"!\"));}greet(\"Maddison\",newDate());Try"
                },
                {
                    "type": "p",
                    "text": "Notice two things here:"
                },
                {
                    "type": "list",
                    "items": [
                        "Ourpersonanddateparameters no longer have type annotations.",
                        "Our “template string” - that string that used backticks (the`character) - was converted to plain strings with concatenations."
                    ]
                },
                {
                    "type": "p",
                    "text": "More on that second point later, but let’s now focus on that first point.\nType annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified.\nThat’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it.\nMost TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased."
                },
                {
                    "type": "p",
                    "text": "Remember: Type annotations never change the runtime behavior of your program."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Downleveling"
                },
                {
                    "type": "p",
                    "text": "One other difference from the above was that our template string was rewritten from"
                },
                {
                    "type": "code",
                    "code": "js`Hello${person}, today is${date.toDateString()}!`;"
                },
                {
                    "type": "p",
                    "text": "to"
                },
                {
                    "type": "code",
                    "code": "js\"Hello \".concat(person,\", today is \").concat(date.toDateString(),\"!\");"
                },
                {
                    "type": "p",
                    "text": "Why did this happen?"
                },
                {
                    "type": "p",
                    "text": "Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. -don’t ask).\nTypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5).\nThis process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes calleddownleveling."
                },
                {
                    "type": "p",
                    "text": "By default TypeScript targets ES5, an extremely old version of ECMAScript.\nWe could have chosen something a little bit more recent by using thetargetoption.\nRunning with--target es2015changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported.\nSo runningtsc --target es2015 hello.tsgives us the following output:"
                },
                {
                    "type": "code",
                    "code": "jsfunctiongreet(person,date) {console.log(`Hello${person}, today is${date.toDateString()}!`);}greet(\"Maddison\",newDate());"
                },
                {
                    "type": "p",
                    "text": "While the default target is ES5, the great majority of current browsers support ES2015.\nMost developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Strictness"
                },
                {
                    "type": "p",
                    "text": "Different users come to TypeScript looking for different things in a type-checker.\nSome people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling.\nThis is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentiallynull/undefinedvalues.\nMuch like howtscemits in the face of errors, these defaults are put in place to stay out of your way.\nIf you’re migrating existing JavaScript, that might be a desirable first step."
                },
                {
                    "type": "p",
                    "text": "In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well.\nThese strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial.\nThe further you turn this dial up, the more TypeScript will check for you.\nThis can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling.\nWhen possible, a new codebase should always turn these strictness checks on."
                },
                {
                    "type": "p",
                    "text": "TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated.\nThestrictflag in the CLI, or\"strict\": truein atsconfig.jsontoggles them all on simultaneously, but we can opt out of them individually.\nThe two biggest ones you should know about arenoImplicitAnyandstrictNullChecks."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "noImplicitAny"
                },
                {
                    "type": "p",
                    "text": "Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type:any.\nThis isn’t the worst thing that can happen - after all, falling back toanyis just the plain JavaScript experience anyway."
                },
                {
                    "type": "p",
                    "text": "However, usinganyoften defeats the purpose of using TypeScript in the first place.\nThe more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code.\nTurning on thenoImplicitAnyflag will issue an error on any variables whose type is implicitly inferred asany."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "strictNullChecks"
                },
                {
                    "type": "p",
                    "text": "By default, values likenullandundefinedare assignable to any other type.\nThis can make writing some code easier, but forgetting to handlenullandundefinedis the cause of countless bugs in the world - some consider it abillion dollar mistake!\nThestrictNullChecksflag makes handlingnullandundefinedmore explicit, andsparesus from worrying about whether weforgotto handlenullandundefined."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The TypeScript Handbook"
                },
                {
                    "type": "p",
                    "text": "Your first step to learn TypeScript"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Everyday Types"
                },
                {
                    "type": "p",
                    "text": "The language primitives."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
            "title": "TypeScript: Documentation - Classes",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Classes (MDN)"
                },
                {
                    "type": "p",
                    "text": "TypeScript offers full support for theclasskeyword introduced in ES2015."
                },
                {
                    "type": "p",
                    "text": "As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Class Members"
                },
                {
                    "type": "p",
                    "text": "Here’s the most basic class - an empty one:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{}Try"
                },
                {
                    "type": "p",
                    "text": "This class isn’t very useful yet, so let’s start adding some members."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fields"
                },
                {
                    "type": "p",
                    "text": "A field declaration creates a public writeable property on a class:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x:number;y:number;}constpt=newPoint();pt.x=0;pt.y=0;Try"
                },
                {
                    "type": "p",
                    "text": "As with other locations, the type annotation is optional, but will be an implicitanyif not specified."
                },
                {
                    "type": "p",
                    "text": "Fields can also haveinitializers; these will run automatically when the class is instantiated:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x=0;y=0;}constpt=newPoint();// Prints 0, 0console.log(`${pt.x},${pt.y}`);Try"
                },
                {
                    "type": "p",
                    "text": "Just like withconst,let, andvar, the initializer of a class property will be used to infer its type:"
                },
                {
                    "type": "code",
                    "code": "tsconstpt=newPoint();pt.x=\"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "--strictPropertyInitialization"
                },
                {
                    "type": "p",
                    "text": "ThestrictPropertyInitializationsetting controls whether class fields need to be initialized in the constructor."
                },
                {
                    "type": "code",
                    "code": "tsclassBadGreeter{name:string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}Try"
                },
                {
                    "type": "code",
                    "code": "tsclassGoodGreeter{name:string;constructor() {this.name=\"hello\";}}Try"
                },
                {
                    "type": "p",
                    "text": "Note that the field needs to be initializedin the constructor itself.\r\nTypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members."
                },
                {
                    "type": "p",
                    "text": "If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use thedefinite assignment assertion operator,!:"
                },
                {
                    "type": "code",
                    "code": "tsclassOKGreeter{// Not initialized, but no errorname!:string;}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "readonly"
                },
                {
                    "type": "p",
                    "text": "Fields may be prefixed with thereadonlymodifier.\r\nThis prevents assignments to the field outside of the constructor."
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{readonlyname:string=\"world\";constructor(otherName?:string) {if(otherName!==undefined) {this.name=otherName;}}err() {this.name=\"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.}}constg=newGreeter();g.name=\"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Constructors"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Constructor (MDN)"
                },
                {
                    "type": "p",
                    "text": "Class constructors are very similar to functions.\r\nYou can add parameters with type annotations, default values, and overloads:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x:number;y:number;// Normal signature with defaultsconstructor(x=0,y=0) {this.x=x;this.y=y;}}Try"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x:number=0;y:number=0;// Constructor overloadsconstructor(x:number,y:number);constructor(xy:string);constructor(x:string|number,y:number=0) {// Code logic here}}Try"
                },
                {
                    "type": "p",
                    "text": "There are just a few differences between class constructor signatures and function signatures:"
                },
                {
                    "type": "list",
                    "items": [
                        "Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later",
                        "Constructors can’t have return type annotations - the class instance type is always what’s returned"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Super Calls"
                },
                {
                    "type": "p",
                    "text": "Just as in JavaScript, if you have a base class, you’ll need to callsuper();in your constructor body before using anythis.members:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{k=4;}classDerivedextendsBase{constructor() {// Prints a wrong value in ES5; throws exception in ES6console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.super();}}Try"
                },
                {
                    "type": "p",
                    "text": "Forgetting to callsuperis an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Methods"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Method definitions"
                },
                {
                    "type": "p",
                    "text": "A function property on a class is called amethod.\r\nMethods can use all the same type annotations as functions and constructors:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x=10;y=10;scale(n:number):void{this.x*=n;this.y*=n;}}Try"
                },
                {
                    "type": "p",
                    "text": "Other than the standard type annotations, TypeScript doesn’t add anything else new to methods."
                },
                {
                    "type": "p",
                    "text": "Note that inside a method body, it is still mandatory to access fields and other methods viathis..\r\nAn unqualified name in a method body will always refer to something in the enclosing scope:"
                },
                {
                    "type": "code",
                    "code": "tsletx:number=0;classC{x:string=\"hello\";m() {// This is trying to modify 'x' from line 1, not the class propertyx=\"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Getters / Setters"
                },
                {
                    "type": "p",
                    "text": "Classes can also haveaccessors:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{_length=0;getlength() {returnthis._length;}setlength(value) {this._length=value;}}Try"
                },
                {
                    "type": "p",
                    "text": "Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript.\r\nIt’s fine to expose public fields if you don’t need to add additional logic during the get/set operations."
                },
                {
                    "type": "p",
                    "text": "TypeScript has some special inference rules for accessors:"
                },
                {
                    "type": "list",
                    "items": [
                        "Ifgetexists but noset, the property is automaticallyreadonly",
                        "If the type of the setter parameter is not specified, it is inferred from the return type of the getter"
                    ]
                },
                {
                    "type": "p",
                    "text": "SinceTypeScript 4.3, it is possible to have accessors with different types for getting and setting."
                },
                {
                    "type": "code",
                    "code": "tsclassThing{_size=0;getsize():number{returnthis._size;}setsize(value:string|number|boolean) {letnum=Number(value);// Don't allow NaN, Infinity, etcif(!Number.isFinite(num)) {this._size=0;return;}this._size=num;}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Index Signatures"
                },
                {
                    "type": "p",
                    "text": "Classes can declare index signatures; these work the same asIndex Signatures for other object types:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{[s:string]:boolean| ((s:string)=>boolean);check(s:string) {returnthis[s]asboolean;}}Try"
                },
                {
                    "type": "p",
                    "text": "Because the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types.\r\nGenerally it’s better to store indexed data in another place instead of on the class instance itself."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Class Heritage"
                },
                {
                    "type": "p",
                    "text": "Like other languages with object-oriented features, classes in JavaScript can inherit from base classes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "implementsClauses"
                },
                {
                    "type": "p",
                    "text": "You can use animplementsclause to check that a class satisfies a particularinterface.\r\nAn error will be issued if a class fails to correctly implement it:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePingable{ping():void;}classSonarimplementsPingable{ping() {console.log(\"ping!\");}}classBallimplementsPingable{Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.pong() {console.log(\"pong!\");}}Try"
                },
                {
                    "type": "p",
                    "text": "Classes may also implement multiple interfaces, e.g.class C implements A, B {."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Cautions"
                },
                {
                    "type": "p",
                    "text": "It’s important to understand that animplementsclause is only a check that the class can be treated as the interface type.\r\nIt doesn’t change the type of the class or its methodsat all.\r\nA common source of error is to assume that animplementsclause will change the class type - it doesn’t!"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCheckable{check(name:string):boolean;}classNameCheckerimplementsCheckable{check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.// Notice no error herereturns.toLowerCase() ===\"ok\";any}}Try"
                },
                {
                    "type": "p",
                    "text": "In this example, we perhaps expected thats’s type would be influenced by thename: stringparameter ofcheck.\r\nIt is not -implementsclauses don’t change how the class body is checked or its type inferred."
                },
                {
                    "type": "p",
                    "text": "Similarly, implementing an interface with an optional property doesn’t create that property:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceA{x:number;y?:number;}classCimplementsA{x=0;}constc=newC();c.y=10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "extendsClauses"
                },
                {
                    "type": "p",
                    "text": "Background Reading:extends keyword (MDN)"
                },
                {
                    "type": "p",
                    "text": "Classes mayextendfrom a base class.\r\nA derived class has all the properties and methods of its base class, and can also define additional members."
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{move() {console.log(\"Moving along!\");}}classDogextendsAnimal{woof(times:number) {for(leti=0;i<times;i++) {console.log(\"woof!\");}}}constd=newDog();// Base class methodd.move();// Derived class methodd.woof(3);Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Overriding Methods"
                },
                {
                    "type": "p",
                    "text": "Background Reading:super keyword (MDN)"
                },
                {
                    "type": "p",
                    "text": "A derived class can also override a base class field or property.\r\nYou can use thesuper.syntax to access base class methods.\r\nNote that because JavaScript classes are a simple lookup object, there is no notion of a “super field”."
                },
                {
                    "type": "p",
                    "text": "TypeScript enforces that a derived class is always a subtype of its base class."
                },
                {
                    "type": "p",
                    "text": "For example, here’s a legal way to override a method:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{greet() {console.log(\"Hello, world!\");}}classDerivedextendsBase{greet(name?:string) {if(name===undefined) {super.greet();}else{console.log(`Hello,${name.toUpperCase()}`);}}}constd=newDerived();d.greet();d.greet(\"reader\");Try"
                },
                {
                    "type": "p",
                    "text": "It’s important that a derived class follow its base class contract.\r\nRemember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:"
                },
                {
                    "type": "code",
                    "code": "ts// Alias the derived instance through a base class referenceconstb:Base=d;// No problemb.greet();Try"
                },
                {
                    "type": "p",
                    "text": "What ifDeriveddidn’t followBase’s contract?"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{greet() {console.log(\"Hello, world!\");}}classDerivedextendsBase{// Make this parameter requiredgreet(name:string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.console.log(`Hello,${name.toUpperCase()}`);}}Try"
                },
                {
                    "type": "p",
                    "text": "If we compiled this code despite the error, this sample would then crash:"
                },
                {
                    "type": "code",
                    "code": "tsconstb:Base=newDerived();// Crashes because \"name\" will be undefinedb.greet();Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Type-only Field Declarations"
                },
                {
                    "type": "p",
                    "text": "Whentarget >= ES2022oruseDefineForClassFieldsistrue, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can writedeclareto indicate to TypeScript that there should be no runtime effect for this field declaration."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimal{dateOfBirth:any;}interfaceDogextendsAnimal{breed:any;}classAnimalHouse{resident:Animal;constructor(animal:Animal) {this.resident=animal;}}classDogHouseextendsAnimalHouse{// Does not emit JavaScript code,// only ensures the types are correctdeclareresident:Dog;constructor(dog:Dog) {super(dog);}}Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Initialization Order"
                },
                {
                    "type": "p",
                    "text": "The order that JavaScript classes initialize can be surprising in some cases.\r\nLet’s consider this code:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{name=\"base\";constructor() {console.log(\"My name is \"+this.name);}}classDerivedextendsBase{name=\"derived\";}// Prints \"base\", not \"derived\"constd=newDerived();Try"
                },
                {
                    "type": "p",
                    "text": "What happened here?"
                },
                {
                    "type": "p",
                    "text": "The order of class initialization, as defined by JavaScript, is:"
                },
                {
                    "type": "list",
                    "items": [
                        "The base class fields are initialized",
                        "The base class constructor runs",
                        "The derived class fields are initialized",
                        "The derived class constructor runs"
                    ]
                },
                {
                    "type": "p",
                    "text": "This means that the base class constructor saw its own value fornameduring its own constructor, because the derived class field initializations hadn’t run yet."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Inheriting Built-in Types"
                },
                {
                    "type": "p",
                    "text": "Note: If you don’t plan to inherit from built-in types likeArray,Error,Map, etc. or your compilation target is explicitly set toES6/ES2015or above, you may skip this section"
                },
                {
                    "type": "p",
                    "text": "In ES2015, constructors which return an object implicitly substitute the value ofthisfor any callers ofsuper(...).\r\nIt is necessary for generated constructor code to capture any potential return value ofsuper(...)and replace it withthis."
                },
                {
                    "type": "p",
                    "text": "As a result, subclassingError,Array, and others may no longer work as expected.\r\nThis is due to the fact that constructor functions forError,Array, and the like use ECMAScript 6’snew.targetto adjust the prototype chain;\r\nhowever, there is no way to ensure a value fornew.targetwhen invoking a constructor in ECMAScript 5.\r\nOther downlevel compilers generally have the same limitation by default."
                },
                {
                    "type": "p",
                    "text": "For a subclass like the following:"
                },
                {
                    "type": "code",
                    "code": "tsclassMsgErrorextendsError{constructor(m:string) {super(m);}sayHello() {return\"hello \"+this.message;}}Try"
                },
                {
                    "type": "p",
                    "text": "you may find that:"
                },
                {
                    "type": "list",
                    "items": [
                        "methods may beundefinedon objects returned by constructing these subclasses, so callingsayHellowill result in an error.",
                        "instanceofwill be broken between instances of the subclass and their instances, so(new MsgError()) instanceof MsgErrorwill returnfalse."
                    ]
                },
                {
                    "type": "p",
                    "text": "As a recommendation, you can manually adjust the prototype immediately after anysuper(...)calls."
                },
                {
                    "type": "code",
                    "code": "tsclassMsgErrorextendsError{constructor(m:string) {super(m);// Set the prototype explicitly.Object.setPrototypeOf(this,MsgError.prototype);}sayHello() {return\"hello \"+this.message;}}Try"
                },
                {
                    "type": "p",
                    "text": "However, any subclass ofMsgErrorwill have to manually set the prototype as well.\r\nFor runtimes that don’t supportObject.setPrototypeOf, you may instead be able to use__proto__."
                },
                {
                    "type": "p",
                    "text": "Unfortunately,these workarounds will not work on Internet Explorer 10 and prior.\r\nOne can manually copy methods from the prototype onto the instance itself (i.e.MsgError.prototypeontothis), but the prototype chain itself cannot be fixed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Member Visibility"
                },
                {
                    "type": "p",
                    "text": "You can use TypeScript to control whether certain methods or properties are visible to code outside the class."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "public"
                },
                {
                    "type": "p",
                    "text": "The default visibility of class members ispublic.\r\nApublicmember can be accessed anywhere:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{publicgreet() {console.log(\"hi!\");}}constg=newGreeter();g.greet();Try"
                },
                {
                    "type": "p",
                    "text": "Becausepublicis already the default visibility modifier, you don’t everneedto write it on a class member, but might choose to do so for style/readability reasons."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "protected"
                },
                {
                    "type": "p",
                    "text": "protectedmembers are only visible to subclasses of the class they’re declared in."
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{publicgreet() {console.log(\"Hello, \"+this.getName());}protectedgetName() {return\"hi\";}}classSpecialGreeterextendsGreeter{publichowdy() {// OK to access protected member hereconsole.log(\"Howdy, \"+this.getName());}}constg=newSpecialGreeter();g.greet();// OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Exposure ofprotectedmembers"
                },
                {
                    "type": "p",
                    "text": "Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities.\r\nThis includes makingprotectedmemberspublic:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{protectedm=10;}classDerivedextendsBase{// No modifier, so default is 'public'm=15;}constd=newDerived();console.log(d.m);// OKTry"
                },
                {
                    "type": "p",
                    "text": "Note thatDerivedwas already able to freely read and writem, so this doesn’t meaningfully alter the “security” of this situation.\r\nThe main thing to note here is that in the derived class, we need to be careful to repeat theprotectedmodifier if this exposure isn’t intentional."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Cross-hierarchyprotectedaccess"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t allow accessingprotectedmembers of a sibling class in a class hierarchy:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{protectedx:number=1;}classDerived1extendsBase{protectedx:number=5;}classDerived2extendsBase{f1(other:Derived2) {other.x=10;}f2(other:Derived1) {other.x=10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.}}Try"
                },
                {
                    "type": "p",
                    "text": "This is because accessingxinDerived2should only be legal fromDerived2’s subclasses, andDerived1isn’t one of them.\r\nMoreover, if accessingxthrough aDerived1reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation."
                },
                {
                    "type": "p",
                    "text": "See alsoWhy Can’t I Access A Protected Member From A Derived Class?which explains more of C#‘s reasoning on the same topic."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "private"
                },
                {
                    "type": "p",
                    "text": "privateis likeprotected, but doesn’t allow access to the member even from subclasses:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{privatex=0;}constb=newBase();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.Try"
                },
                {
                    "type": "code",
                    "code": "tsclassDerivedextendsBase{showX() {// Can't access in subclassesconsole.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.}}Try"
                },
                {
                    "type": "p",
                    "text": "Becauseprivatemembers aren’t visible to derived classes, a derived class can’t increase their visibility:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{privatex=0;}classDerivedextendsBase{Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.x=1;}Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Cross-instanceprivateaccess"
                },
                {
                    "type": "p",
                    "text": "Different OOP languages disagree about whether different instances of the same class may access each others’privatemembers.\r\nWhile languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not."
                },
                {
                    "type": "p",
                    "text": "TypeScript does allow cross-instanceprivateaccess:"
                },
                {
                    "type": "code",
                    "code": "tsclassA{privatex=10;publicsameAs(other:A) {// No errorreturnother.x===this.x;}}Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "p",
                    "text": "Like other aspects of TypeScript’s type system,privateandprotectedare only enforced during type checking."
                },
                {
                    "type": "p",
                    "text": "This means that JavaScript runtime constructs likeinor simple property lookup can still access aprivateorprotectedmember:"
                },
                {
                    "type": "code",
                    "code": "tsclassMySafe{privatesecretKey=12345;}Try"
                },
                {
                    "type": "code",
                    "code": "js// In a JavaScript file...consts=newMySafe();// Will print 12345console.log(s.secretKey);"
                },
                {
                    "type": "p",
                    "text": "privatealso allows access using bracket notation during type checking. This makesprivate-declared fields potentially easier to access for things like unit tests, with the drawback that these fields aresoft privateand don’t strictly enforce privacy."
                },
                {
                    "type": "code",
                    "code": "tsclassMySafe{privatesecretKey=12345;}consts=newMySafe();// Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'.// OKconsole.log(s[\"secretKey\"]);Try"
                },
                {
                    "type": "p",
                    "text": "Unlike TypeScripts’sprivate, JavaScript’sprivate fields(#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making themhard private."
                },
                {
                    "type": "code",
                    "code": "tsclassDog{#barkAmount=0;personality=\"happy\";constructor() {}}Try"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";classDog{#barkAmount=0;personality=\"happy\";constructor() { }}Try"
                },
                {
                    "type": "p",
                    "text": "When compiling to ES2021 or less, TypeScript will use WeakMaps in place of#."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var_Dog_barkAmount;classDog{constructor() {_Dog_barkAmount.set(this,0);this.personality=\"happy\";}}_Dog_barkAmount=newWeakMap();Try"
                },
                {
                    "type": "p",
                    "text": "If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Static Members"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Static Members (MDN)"
                },
                {
                    "type": "p",
                    "text": "Classes may havestaticmembers.\r\nThese members aren’t associated with a particular instance of the class.\r\nThey can be accessed through the class constructor object itself:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{staticx=0;staticprintX() {console.log(MyClass.x);}}console.log(MyClass.x);MyClass.printX();Try"
                },
                {
                    "type": "p",
                    "text": "Static members can also use the samepublic,protected, andprivatevisibility modifiers:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{privatestaticx=0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.Try"
                },
                {
                    "type": "p",
                    "text": "Static members are also inherited:"
                },
                {
                    "type": "code",
                    "code": "tsclassBase{staticgetGreeting() {return\"Hello world\";}}classDerivedextendsBase{myGreeting=Derived.getGreeting();}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Special Static Names"
                },
                {
                    "type": "p",
                    "text": "It’s generally not safe/possible to overwrite properties from theFunctionprototype.\r\nBecause classes are themselves functions that can be invoked withnew, certainstaticnames can’t be used.\r\nFunction properties likename,length, andcallaren’t valid to define asstaticmembers:"
                },
                {
                    "type": "code",
                    "code": "tsclassS{staticname=\"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Why No Static Classes?"
                },
                {
                    "type": "p",
                    "text": "TypeScript (and JavaScript) don’t have a construct calledstatic classthe same way as, for example, C# does."
                },
                {
                    "type": "p",
                    "text": "Those constructsonlyexist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them.\r\nA class with only a single instance is typically just represented as a normalobjectin JavaScript/TypeScript."
                },
                {
                    "type": "p",
                    "text": "For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:"
                },
                {
                    "type": "code",
                    "code": "ts// Unnecessary \"static\" classclassMyStaticClass{staticdoSomething() {}}// Preferred (alternative 1)functiondoSomething() {}// Preferred (alternative 2)constMyHelperObject= {dosomething() {},};Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "staticBlocks in Classes"
                },
                {
                    "type": "p",
                    "text": "Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals."
                },
                {
                    "type": "code",
                    "code": "tsclassFoo{static#count=0;getcount() {returnFoo.#count;}static{try{constlastInstances=loadLastInstances();Foo.#count+=lastInstances.length;}catch{}}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Classes"
                },
                {
                    "type": "p",
                    "text": "Classes, much like interfaces, can be generic.\r\nWhen a generic class is instantiated withnew, its type parameters are inferred the same way as in a function call:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox<Type> {contents:Type;constructor(value:Type) {this.contents=value;}}constb=newBox(\"hello!\");const b: Box<string>Try"
                },
                {
                    "type": "p",
                    "text": "Classes can use generic constraints and defaults the same way as interfaces."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type Parameters in Static Members"
                },
                {
                    "type": "p",
                    "text": "This code isn’t legal, and it may not be obvious why:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox<Type> {staticdefaultValue:Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}Try"
                },
                {
                    "type": "p",
                    "text": "Remember that types are always fully erased!\r\nAt runtime, there’s onlyoneBox.defaultValueproperty slot.\r\nThis means that settingBox<string>.defaultValue(if that were possible) wouldalsochangeBox<number>.defaultValue- not good.\r\nThestaticmembers of a generic class can never refer to the class’s type parameters."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "thisat Runtime in Classes"
                },
                {
                    "type": "p",
                    "text": "Background Reading:this keyword (MDN)"
                },
                {
                    "type": "p",
                    "text": "It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors."
                },
                {
                    "type": "p",
                    "text": "JavaScript’s handling ofthisis indeed unusual:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{name=\"MyClass\";getName() {returnthis.name;}}constc=newMyClass();constobj= {name:\"obj\",getName:c.getName,};// Prints \"obj\", not \"MyClass\"console.log(obj.getName());Try"
                },
                {
                    "type": "p",
                    "text": "Long story short, by default, the value ofthisinside a function depends onhow the function was called.\r\nIn this example, because the function was called through theobjreference, its value ofthiswasobjrather than the class instance."
                },
                {
                    "type": "p",
                    "text": "This is rarely what you want to happen!\r\nTypeScript provides some ways to mitigate or prevent this kind of error."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Arrow Functions"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Arrow functions (MDN)"
                },
                {
                    "type": "p",
                    "text": "If you have a function that will often be called in a way that loses itsthiscontext, it can make sense to use an arrow function property instead of a method definition:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{name=\"MyClass\";getName= ()=>{returnthis.name;};}constc=newMyClass();constg=c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());Try"
                },
                {
                    "type": "p",
                    "text": "This has some trade-offs:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thethisvalue is guaranteed to be correct at runtime, even for code not checked with TypeScript",
                        "This will use more memory, because each class instance will have its own copy of each function defined this way",
                        "You can’t usesuper.getNamein a derived class, because there’s no entry in the prototype chain to fetch the base class method from"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "thisparameters"
                },
                {
                    "type": "p",
                    "text": "In a method or function definition, an initial parameter namedthishas special meaning in TypeScript.\r\nThese parameters are erased during compilation:"
                },
                {
                    "type": "code",
                    "code": "ts// TypeScript input with 'this' parameterfunctionfn(this:SomeType,x:number) {/* ... */}Try"
                },
                {
                    "type": "code",
                    "code": "js// JavaScript outputfunctionfn(x) {/* ... */}"
                },
                {
                    "type": "p",
                    "text": "TypeScript checks that calling a function with athisparameter is done so with a correct context.\r\nInstead of using an arrow function, we can add athisparameter to method definitions to statically enforce that the method is called correctly:"
                },
                {
                    "type": "code",
                    "code": "tsclassMyClass{name=\"MyClass\";getName(this:MyClass) {returnthis.name;}}constc=newMyClass();// OKc.getName();// Error, would crashconstg=c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.Try"
                },
                {
                    "type": "p",
                    "text": "This method makes the opposite trade-offs of the arrow function approach:"
                },
                {
                    "type": "list",
                    "items": [
                        "JavaScript callers might still use the class method incorrectly without realizing it",
                        "Only one function per class definition gets allocated, rather than one per class instance",
                        "Base method definitions can still be called viasuper."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "thisTypes"
                },
                {
                    "type": "p",
                    "text": "In classes, a special type calledthisrefersdynamicallyto the type of the current class.\r\nLet’s see how this is useful:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox{contents:string=\"\";set(value:string) {(method) Box.set(value: string): thisthis.contents=value;returnthis;}}Try"
                },
                {
                    "type": "p",
                    "text": "Here, TypeScript inferred the return type ofsetto bethis, rather thanBox.\r\nNow let’s make a subclass ofBox:"
                },
                {
                    "type": "code",
                    "code": "tsclassClearableBoxextendsBox{clear() {this.contents=\"\";}}consta=newClearableBox();constb=a.set(\"hello\");const b: ClearableBoxTry"
                },
                {
                    "type": "p",
                    "text": "You can also usethisin a parameter type annotation:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox{content:string=\"\";sameAs(other:this) {returnother.content===this.content;}}Try"
                },
                {
                    "type": "p",
                    "text": "This is different from writingother: Box— if you have a derived class, itssameAsmethod will now only accept other instances of that same derived class:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox{content:string=\"\";sameAs(other:this) {returnother.content===this.content;}}classDerivedBoxextendsBox{otherContent:string=\"?\";}constbase=newBox();constderived=newDerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "this-based type guards"
                },
                {
                    "type": "p",
                    "text": "You can usethis is Typein the return position for methods in classes and interfaces.\r\nWhen mixed with a type narrowing (e.g.ifstatements) the type of the target object would be narrowed to the specifiedType."
                },
                {
                    "type": "code",
                    "code": "tsclassFileSystemObject{isFile():thisisFileRep{returnthisinstanceofFileRep;}isDirectory():thisisDirectory{returnthisinstanceofDirectory;}isNetworked():thisisNetworked&this{returnthis.networked;}constructor(publicpath:string,privatenetworked:boolean) {}}classFileRepextendsFileSystemObject{constructor(path:string,publiccontent:string) {super(path,false);}}classDirectoryextendsFileSystemObject{children:FileSystemObject[];}interfaceNetworked{host:string;}constfso:FileSystemObject=newFileRep(\"foo/bar.txt\",\"foo\");if(fso.isFile()) {fso.content;const fso: FileRep}elseif(fso.isDirectory()) {fso.children;const fso: Directory}elseif(fso.isNetworked()) {fso.host;const fso: Networked & FileSystemObject}Try"
                },
                {
                    "type": "p",
                    "text": "A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes anundefinedfrom the value held inside box whenhasValuehas been verified to be true:"
                },
                {
                    "type": "code",
                    "code": "tsclassBox<T> {value?:T;hasValue():thisis{value:T} {returnthis.value!==undefined;}}constbox=newBox<string>();box.value=\"Gameboy\";box.value;(property) Box<string>.value?: stringif(box.hasValue()) {box.value;(property) value: string}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Parameter Properties"
                },
                {
                    "type": "p",
                    "text": "TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value.\r\nThese are calledparameter propertiesand are created by prefixing a constructor argument with one of the visibility modifierspublic,private,protected, orreadonly.\r\nThe resulting field gets those modifier(s):"
                },
                {
                    "type": "code",
                    "code": "tsclassParams{constructor(publicreadonlyx:number,protectedy:number,privatez:number) {// No body necessary}}consta=newParams(1,2,3);console.log(a.x);(property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Class Expressions"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Class expressions (MDN)"
                },
                {
                    "type": "p",
                    "text": "Class expressions are very similar to class declarations.\r\nThe only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:"
                },
                {
                    "type": "code",
                    "code": "tsconstsomeClass=class<Type> {content:Type;constructor(value:Type) {this.content=value;}};constm=newsomeClass(\"Hello, world\");const m: someClass<string>Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Constructor Signatures"
                },
                {
                    "type": "p",
                    "text": "JavaScript classes are instantiated with thenewoperator. Given the type of a class itself, theInstanceTypeutility type models this operation."
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{createdAt:number;x:number;y:numberconstructor(x:number,y:number) {this.createdAt=Date.now()this.x=x;this.y=y;}}typePointInstance=InstanceType<typeofPoint>functionmoveRight(point:PointInstance) {point.x+=5;}constpoint=newPoint(3,4);moveRight(point);point.x;// => 8Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "abstractClasses and Members"
                },
                {
                    "type": "p",
                    "text": "Classes, methods, and fields in TypeScript may beabstract."
                },
                {
                    "type": "p",
                    "text": "Anabstract methodorabstract fieldis one that hasn’t had an implementation provided.\r\nThese members must exist inside anabstract class, which cannot be directly instantiated."
                },
                {
                    "type": "p",
                    "text": "The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members.\r\nWhen a class doesn’t have any abstract members, it is said to beconcrete."
                },
                {
                    "type": "p",
                    "text": "Let’s look at an example:"
                },
                {
                    "type": "code",
                    "code": "tsabstractclassBase{abstractgetName():string;printName() {console.log(\"Hello, \"+this.getName());}}constb=newBase();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.Try"
                },
                {
                    "type": "p",
                    "text": "We can’t instantiateBasewithnewbecause it’s abstract.\r\nInstead, we need to make a derived class and implement the abstract members:"
                },
                {
                    "type": "code",
                    "code": "tsclassDerivedextendsBase{getName() {return\"world\";}}constd=newDerived();d.printName();Try"
                },
                {
                    "type": "p",
                    "text": "Notice that if we forget to implement the base class’s abstract members, we’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "tsclassDerivedextendsBase{Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.// forgot to do anything}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Abstract Construct Signatures"
                },
                {
                    "type": "p",
                    "text": "Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class."
                },
                {
                    "type": "p",
                    "text": "For example, you might want to write this code:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(ctor:typeofBase) {constinstance=newctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.instance.printName();}Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript is correctly telling you that you’re trying to instantiate an abstract class.\r\nAfter all, given the definition ofgreet, it’s perfectly legal to write this code, which would end up constructing an abstract class:"
                },
                {
                    "type": "code",
                    "code": "ts// Bad!greet(Base);Try"
                },
                {
                    "type": "p",
                    "text": "Instead, you want to write a function that accepts something with a construct signature:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(ctor:new()=>Base) {constinstance=newctor();instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.Try"
                },
                {
                    "type": "p",
                    "text": "Now TypeScript correctly tells you about which class constructor functions can be invoked -Derivedcan because it’s concrete, butBasecannot."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Relationships Between Classes"
                },
                {
                    "type": "p",
                    "text": "In most cases, classes in TypeScript are compared structurally, the same as other types."
                },
                {
                    "type": "p",
                    "text": "For example, these two classes can be used in place of each other because they’re identical:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint1{x=0;y=0;}classPoint2{x=0;y=0;}// OKconstp:Point1=newPoint2();Try"
                },
                {
                    "type": "p",
                    "text": "Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:"
                },
                {
                    "type": "code",
                    "code": "tsclassPerson{name:string;age:number;}classEmployee{name:string;age:number;salary:number;}// OKconstp:Person=newEmployee();Try"
                },
                {
                    "type": "p",
                    "text": "This sounds straightforward, but there are a few cases that seem stranger than others."
                },
                {
                    "type": "p",
                    "text": "Empty classes have no members.\r\nIn a structural type system, a type with no members is generally a supertype of anything else.\r\nSo if you write an empty class (don’t!), anything can be used in place of it:"
                },
                {
                    "type": "code",
                    "code": "tsclassEmpty{}functionfn(x:Empty) {// can't do anything with 'x', so I won't}// All OK!fn(window);fn({});fn(fn);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Modules"
                },
                {
                    "type": "p",
                    "text": "How JavaScript handles communicating across file boundaries."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",
            "title": "TypeScript: Documentation - Conditional Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Conditional Types"
                },
                {
                    "type": "p",
                    "text": "At the heart of most useful programs, we have to make decisions based on input.\nJavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs.Conditional typeshelp describe the relation between the types of inputs and outputs."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimal{live():void;}interfaceDogextendsAnimal{woof():void;}typeExample1=DogextendsAnimal?number:string;type Example1 = numbertypeExample2=RegExpextendsAnimal?number:string;type Example2 = stringTry"
                },
                {
                    "type": "p",
                    "text": "Conditional types take a form that looks a little like conditional expressions (condition ? trueExpression : falseExpression) in JavaScript:"
                },
                {
                    "type": "code",
                    "code": "tsSomeTypeextendsOtherType?TrueType:FalseType;Try"
                },
                {
                    "type": "p",
                    "text": "When the type on the left of theextendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch)."
                },
                {
                    "type": "p",
                    "text": "From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or notDog extends Animaland picknumberorstring!\nBut the power of conditional types comes from using them with generics."
                },
                {
                    "type": "p",
                    "text": "For example, let’s take the followingcreateLabelfunction:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceIdLabel{id:number/* some fields */;}interfaceNameLabel{name:string/* other fields */;}functioncreateLabel(id:number):IdLabel;functioncreateLabel(name:string):NameLabel;functioncreateLabel(nameOrId:string|number):IdLabel|NameLabel;functioncreateLabel(nameOrId:string|number):IdLabel|NameLabel{throw\"unimplemented\";}Try"
                },
                {
                    "type": "p",
                    "text": "These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:"
                },
                {
                    "type": "list",
                    "items": [
                        "If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.",
                        "We have to create three overloads: one for each case when we’resureof the type (one forstringand one fornumber), and one for the most general case (taking astring | number). For every new typecreateLabelcan handle, the number of overloads grows exponentially."
                    ]
                },
                {
                    "type": "p",
                    "text": "Instead, we can encode that logic in a conditional type:"
                },
                {
                    "type": "code",
                    "code": "tstypeNameOrId<Textendsnumber|string> =Textendsnumber?IdLabel:NameLabel;Try"
                },
                {
                    "type": "p",
                    "text": "We can then use that conditional type to simplify our overloads down to a single function with no overloads."
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreateLabel<Textendsnumber|string>(idOrName:T):NameOrId<T> {throw\"unimplemented\";}leta=createLabel(\"typescript\");let a: NameLabelletb=createLabel(2.8);let b: IdLabelletc=createLabel(Math.random() ?\"hello\":42);let c: NameLabel | IdLabelTry"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditional Type Constraints"
                },
                {
                    "type": "p",
                    "text": "Often, the checks in a conditional type will provide us with some new information.\nJust like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against."
                },
                {
                    "type": "p",
                    "text": "For example, let’s take the following:"
                },
                {
                    "type": "code",
                    "code": "tstypeMessageOf<T> =T[\"message\"];Type '\"message\"' cannot be used to index type 'T'.2536Type '\"message\"' cannot be used to index type 'T'.Try"
                },
                {
                    "type": "p",
                    "text": "In this example, TypeScript errors becauseTisn’t known to have a property calledmessage.\nWe could constrainT, and TypeScript would no longer complain:"
                },
                {
                    "type": "code",
                    "code": "tstypeMessageOf<Textends{message:unknown}> =T[\"message\"];interfaceEmail{message:string;}typeEmailMessageContents=MessageOf<Email>;type EmailMessageContents = stringTry"
                },
                {
                    "type": "p",
                    "text": "However, what if we wantedMessageOfto take any type, and default to something likeneverif amessageproperty isn’t available?\nWe can do this by moving the constraint out and introducing a conditional type:"
                },
                {
                    "type": "code",
                    "code": "tstypeMessageOf<T> =Textends{message:unknown} ?T[\"message\"] :never;interfaceEmail{message:string;}interfaceDog{bark():void;}typeEmailMessageContents=MessageOf<Email>;type EmailMessageContents = stringtypeDogMessageContents=MessageOf<Dog>;type DogMessageContents = neverTry"
                },
                {
                    "type": "p",
                    "text": "Within the true branch, TypeScript knows thatTwillhave amessageproperty."
                },
                {
                    "type": "p",
                    "text": "As another example, we could also write a type calledFlattenthat flattens array types to their element types, but leaves them alone otherwise:"
                },
                {
                    "type": "code",
                    "code": "tstypeFlatten<T> =Textendsany[] ?T[number] :T;// Extracts out the element type.typeStr=Flatten<string[]>;type Str = string// Leaves the type alone.typeNum=Flatten<number>;type Num = numberTry"
                },
                {
                    "type": "p",
                    "text": "WhenFlattenis given an array type, it uses an indexed access withnumberto fetch outstring[]’s element type.\nOtherwise, it just returns the type it was given."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inferring Within Conditional Types"
                },
                {
                    "type": "p",
                    "text": "We just found ourselves using conditional types to apply constraints and then extract out types.\nThis ends up being such a common operation that conditional types make it easier."
                },
                {
                    "type": "p",
                    "text": "Conditional types provide us with a way to infer from types we compare against in the true branch using theinferkeyword.\nFor example, we could have inferred the element type inFlatteninstead of fetching it out “manually” with an indexed access type:"
                },
                {
                    "type": "code",
                    "code": "tstypeFlatten<Type> =TypeextendsArray<inferItem> ?Item:Type;Try"
                },
                {
                    "type": "p",
                    "text": "Here, we used theinferkeyword to declaratively introduce a new generic type variable namedIteminstead of specifying how to retrieve the element type ofTypewithin the true branch.\nThis frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in."
                },
                {
                    "type": "p",
                    "text": "We can write some useful helper type aliases using theinferkeyword.\nFor example, for simple cases, we can extract the return type out from function types:"
                },
                {
                    "type": "code",
                    "code": "tstypeGetReturnType<Type> =Typeextends(...args:never[])=>inferReturn?Return:never;typeNum=GetReturnType<()=>number>;type Num = numbertypeStr=GetReturnType<(x:string)=>string>;type Str = stringtypeBools=GetReturnType<(a:boolean,b:boolean)=>boolean[]>;type Bools = boolean[]Try"
                },
                {
                    "type": "p",
                    "text": "When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from thelastsignature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types."
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionstringOrNum(x:string):number;declarefunctionstringOrNum(x:number):string;declarefunctionstringOrNum(x:string|number):string|number;typeT1=ReturnType<typeofstringOrNum>;type T1 = string | numberTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Distributive Conditional Types"
                },
                {
                    "type": "p",
                    "text": "When conditional types act on a generic type, they becomedistributivewhen given a union type.\nFor example, take the following:"
                },
                {
                    "type": "code",
                    "code": "tstypeToArray<Type> =Typeextendsany?Type[] :never;Try"
                },
                {
                    "type": "p",
                    "text": "If we plug a union type intoToArray, then the conditional type will be applied to each member of that union."
                },
                {
                    "type": "code",
                    "code": "tstypeToArray<Type> =Typeextendsany?Type[] :never;typeStrArrOrNumArr=ToArray<string|number>;type StrArrOrNumArr = string[] | number[]Try"
                },
                {
                    "type": "p",
                    "text": "What happens here is thatToArraydistributes on:"
                },
                {
                    "type": "code",
                    "code": "tsstring|number;Try"
                },
                {
                    "type": "p",
                    "text": "and maps over each member type of the union, to what is effectively:"
                },
                {
                    "type": "code",
                    "code": "tsToArray<string> |ToArray<number>;Try"
                },
                {
                    "type": "p",
                    "text": "which leaves us with:"
                },
                {
                    "type": "code",
                    "code": "tsstring[] |number[];Try"
                },
                {
                    "type": "p",
                    "text": "Typically, distributivity is the desired behavior.\nTo avoid that behavior, you can surround each side of theextendskeyword with square brackets."
                },
                {
                    "type": "code",
                    "code": "tstypeToArrayNonDist<Type> = [Type]extends[any] ?Type[] :never;// 'ArrOfStrOrNum' is no longer a union.typeArrOfStrOrNum=ToArrayNonDist<string|number>;type ArrOfStrOrNum = (string | number)[]Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Indexed Access Types"
                },
                {
                    "type": "p",
                    "text": "Using Type['a'] syntax to access a subset of a type."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Mapped Types"
                },
                {
                    "type": "p",
                    "text": "Generating types by re-using an existing type."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html",
            "title": "TypeScript: Documentation - Everyday Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Everyday Types"
                },
                {
                    "type": "p",
                    "text": "In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript.\r\nThis isn’t an exhaustive list, and future chapters will describe more ways to name and use other types."
                },
                {
                    "type": "p",
                    "text": "Types can also appear in many moreplacesthan just type annotations.\r\nAs we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs."
                },
                {
                    "type": "p",
                    "text": "We’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code.\r\nThese will later form the core building blocks of more complex types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The primitives:string,number, andboolean"
                },
                {
                    "type": "p",
                    "text": "JavaScript has three very commonly usedprimitives:string,number, andboolean.\r\nEach has a corresponding type in TypeScript.\r\nAs you might expect, these are the same names you’d see if you used the JavaScripttypeofoperator on a value of those types:"
                },
                {
                    "type": "list",
                    "items": [
                        "stringrepresents string values like\"Hello, world\"",
                        "numberis for numbers like42. JavaScript does not have a special runtime value for integers, so there’s no equivalent tointorfloat- everything is simplynumber",
                        "booleanis for the two valuestrueandfalse"
                    ]
                },
                {
                    "type": "p",
                    "text": "The type namesString,Number, andBoolean(starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code.Alwaysusestring,number, orbooleanfor types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Arrays"
                },
                {
                    "type": "p",
                    "text": "To specify the type of an array like[1, 2, 3], you can use the syntaxnumber[]; this syntax works for any type (e.g.string[]is an array of strings, and so on).\r\nYou may also see this written asArray<number>, which means the same thing.\r\nWe’ll learn more about the syntaxT<U>when we covergenerics."
                },
                {
                    "type": "p",
                    "text": "Note that[number]is a different thing; refer to the section onTuples."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "any"
                },
                {
                    "type": "p",
                    "text": "TypeScript also has a special type,any, that you can use whenever you don’t want a particular value to cause typechecking errors."
                },
                {
                    "type": "p",
                    "text": "When a value is of typeany, you can access any properties of it (which will in turn be of typeany), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:"
                },
                {
                    "type": "code",
                    "code": "tsletobj:any= {x:0};// None of the following lines of code will throw compiler errors.// Using `any` disables all further type checking, and it is assumed// you know the environment better than TypeScript.obj.foo();obj();obj.bar=100;obj=\"hello\";constn:number=obj;Try"
                },
                {
                    "type": "p",
                    "text": "Theanytype is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "noImplicitAny"
                },
                {
                    "type": "p",
                    "text": "When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default toany."
                },
                {
                    "type": "p",
                    "text": "You usually want to avoid this, though, becauseanyisn’t type-checked.\r\nUse the compiler flagnoImplicitAnyto flag any implicitanyas an error."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type Annotations on Variables"
                },
                {
                    "type": "p",
                    "text": "When you declare a variable usingconst,var, orlet, you can optionally add a type annotation to explicitly specify the type of the variable:"
                },
                {
                    "type": "code",
                    "code": "tsletmyName:string=\"Alice\";Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t use “types on the left”-style declarations likeint x = 0;Type annotations will always goafterthe thing being typed."
                },
                {
                    "type": "p",
                    "text": "In most cases, though, this isn’t needed.\r\nWherever possible, TypeScript tries to automaticallyinferthe types in your code.\r\nFor example, the type of a variable is inferred based on the type of its initializer:"
                },
                {
                    "type": "code",
                    "code": "ts// No type annotation needed -- 'myName' inferred as type 'string'letmyName=\"Alice\";Try"
                },
                {
                    "type": "p",
                    "text": "For the most part you don’t need to explicitly learn the rules of inference.\r\nIf you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Functions"
                },
                {
                    "type": "p",
                    "text": "Functions are the primary means of passing data around in JavaScript.\r\nTypeScript allows you to specify the types of both the input and output values of functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Parameter Type Annotations"
                },
                {
                    "type": "p",
                    "text": "When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts.\r\nParameter type annotations go after the parameter name:"
                },
                {
                    "type": "code",
                    "code": "ts// Parameter type annotationfunctiongreet(name:string) {console.log(\"Hello, \"+name.toUpperCase() +\"!!\");}Try"
                },
                {
                    "type": "p",
                    "text": "When a parameter has a type annotation, arguments to that function will be checked:"
                },
                {
                    "type": "code",
                    "code": "ts// Would be a runtime error if executed!greet(42);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Return Type Annotations"
                },
                {
                    "type": "p",
                    "text": "You can also add return type annotations.\r\nReturn type annotations appear after the parameter list:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetFavoriteNumber():number{return26;}Try"
                },
                {
                    "type": "p",
                    "text": "Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on itsreturnstatements.\r\nThe type annotation in the above example doesn’t change anything.\r\nSome codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Functions Which Return Promises"
                },
                {
                    "type": "p",
                    "text": "If you want to annotate the return type of a function which returns a promise, you should use thePromisetype:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctiongetFavoriteNumber():Promise<number> {return26;}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Anonymous Functions"
                },
                {
                    "type": "p",
                    "text": "Anonymous functions are a little bit different from function declarations.\r\nWhen a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types."
                },
                {
                    "type": "p",
                    "text": "Here’s an example:"
                },
                {
                    "type": "code",
                    "code": "tsconstnames= [\"Alice\",\"Bob\",\"Eve\"];// Contextual typing for function - parameter s inferred to have type stringnames.forEach(function(s) {console.log(s.toUpperCase());});// Contextual typing also applies to arrow functionsnames.forEach((s)=>{console.log(s.toUpperCase());});Try"
                },
                {
                    "type": "p",
                    "text": "Even though the parametersdidn’t have a type annotation, TypeScript used the types of theforEachfunction, along with the inferred type of the array, to determine the typeswill have."
                },
                {
                    "type": "p",
                    "text": "This process is calledcontextual typingbecause thecontextthat the function occurred within informs what type it should have."
                },
                {
                    "type": "p",
                    "text": "Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that itdoeshappen can help you notice when type annotations aren’t needed.\r\nLater, we’ll see more examples of how the context that a value occurs in can affect its type."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Object Types"
                },
                {
                    "type": "p",
                    "text": "Apart from primitives, the most common sort of type you’ll encounter is anobject type.\r\nThis refers to any JavaScript value with properties, which is almost all of them!\r\nTo define an object type, we simply list its properties and their types."
                },
                {
                    "type": "p",
                    "text": "For example, here’s a function that takes a point-like object:"
                },
                {
                    "type": "code",
                    "code": "ts// The parameter's type annotation is an object typefunctionprintCoord(pt: {x:number;y:number}) {console.log(\"The coordinate's x value is \"+pt.x);console.log(\"The coordinate's y value is \"+pt.y);}printCoord({x:3,y:7});Try"
                },
                {
                    "type": "p",
                    "text": "Here, we annotated the parameter with a type with two properties -xandy- which are both of typenumber.\r\nYou can use,or;to separate the properties, and the last separator is optional either way."
                },
                {
                    "type": "p",
                    "text": "The type part of each property is also optional.\r\nIf you don’t specify a type, it will be assumed to beany."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Properties"
                },
                {
                    "type": "p",
                    "text": "Object types can also specify that some or all of their properties areoptional.\r\nTo do this, add a?after the property name:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintName(obj: {first:string;last?:string}) {// ...}// Both OKprintName({first:\"Bob\"});printName({first:\"Alice\",last:\"Alisson\"});Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, if you access a property that doesn’t exist, you’ll get the valueundefinedrather than a runtime error.\r\nBecause of this, when youreadfrom an optional property, you’ll have to check forundefinedbefore using it."
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintName(obj: {first:string;last?:string}) {// Error - might crash if 'obj.last' wasn't provided!console.log(obj.last.toUpperCase());'obj.last' is possibly 'undefined'.18048'obj.last' is possibly 'undefined'.if(obj.last!==undefined) {// OKconsole.log(obj.last.toUpperCase());}// A safe alternative using modern JavaScript syntax:console.log(obj.last?.toUpperCase());}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Union Types"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators.\r\nNow that we know how to write a few types, it’s time to startcombiningthem in interesting ways."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Defining a Union Type"
                },
                {
                    "type": "p",
                    "text": "The first way to combine types you might see is auniontype.\r\nA union type is a type formed from two or more other types, representing values that may beany oneof those types.\r\nWe refer to each of these types as the union’smembers."
                },
                {
                    "type": "p",
                    "text": "Let’s write a function that can operate on strings or numbers:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintId(id:number|string) {console.log(\"Your ID is: \"+id);}// OKprintId(101);// OKprintId(\"202\");// ErrorprintId({myID:22342});Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.2345Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.Try"
                },
                {
                    "type": "p",
                    "text": "The separator of the union members is allowed before the first element, so you could also write this:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintTextOrNumberOrBool(textOrNumberOrBool:|string|number|boolean) {console.log(textOrNumberOrBool);}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Working with Union Types"
                },
                {
                    "type": "p",
                    "text": "It’s easy toprovidea value matching a union type - simply provide a type matching any of the union’s members.\r\nIf youhavea value of a union type, how do you work with it?"
                },
                {
                    "type": "p",
                    "text": "TypeScript will only allow an operation if it is valid foreverymember of the union.\r\nFor example, if you have the unionstring | number, you can’t use methods that are only available onstring:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintId(id:number|string) {console.log(id.toUpperCase());Property 'toUpperCase' does not exist on type 'string | number'.\n  Property 'toUpperCase' does not exist on type 'number'.2339Property 'toUpperCase' does not exist on type 'string | number'.\n  Property 'toUpperCase' does not exist on type 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "The solution is tonarrowthe union with code, the same as you would in JavaScript without type annotations.Narrowingoccurs when TypeScript can deduce a more specific type for a value based on the structure of the code."
                },
                {
                    "type": "p",
                    "text": "For example, TypeScript knows that only astringvalue will have atypeofvalue\"string\":"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintId(id:number|string) {if(typeofid===\"string\") {// In this branch, id is of type 'string'console.log(id.toUpperCase());}else{// Here, id is of type 'number'console.log(id);}}Try"
                },
                {
                    "type": "p",
                    "text": "Another example is to use a function likeArray.isArray:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionwelcomePeople(x:string[] |string) {if(Array.isArray(x)) {// Here: 'x' is 'string[]'console.log(\"Hello, \"+x.join(\" and \"));}else{// Here: 'x' is 'string'console.log(\"Welcome lone traveler \"+x);}}Try"
                },
                {
                    "type": "p",
                    "text": "Notice that in theelsebranch, we don’t need to do anything special - ifxwasn’t astring[], then it must have been astring."
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll have a union where all the members have something in common.\r\nFor example, both arrays and strings have aslicemethod.\r\nIf every member in a union has a property in common, you can use that property without narrowing:"
                },
                {
                    "type": "code",
                    "code": "ts// Return type is inferred as number[] | stringfunctiongetFirstThree(x:number[] |string) {returnx.slice(0,3);}Try"
                },
                {
                    "type": "p",
                    "text": "It might be confusing that aunionof types appears to have theintersectionof those types’ properties.\r\nThis is not an accident - the nameunioncomes from type theory.\r\nTheunionnumber | stringis composed by taking the unionof the valuesfrom each type.\r\nNotice that given two sets with corresponding facts about each set, only theintersectionof those facts applies to theunionof the sets themselves.\r\nFor example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know abouteveryperson is that they must be wearing a hat."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type Aliases"
                },
                {
                    "type": "p",
                    "text": "We’ve been using object types and union types by writing them directly in type annotations.\r\nThis is convenient, but it’s common to want to use the same type more than once and refer to it by a single name."
                },
                {
                    "type": "p",
                    "text": "Atype aliasis exactly that - anamefor anytype.\r\nThe syntax for a type alias is:"
                },
                {
                    "type": "code",
                    "code": "tstypePoint= {x:number;y:number;};// Exactly the same as the earlier examplefunctionprintCoord(pt:Point) {console.log(\"The coordinate's x value is \"+pt.x);console.log(\"The coordinate's y value is \"+pt.y);}printCoord({x:100,y:100});Try"
                },
                {
                    "type": "p",
                    "text": "You can actually use a type alias to give a name to any type at all, not just an object type.\r\nFor example, a type alias can name a union type:"
                },
                {
                    "type": "code",
                    "code": "tstypeID=number|string;Try"
                },
                {
                    "type": "p",
                    "text": "Note that aliases areonlyaliases - you cannot use type aliases to create different/distinct “versions” of the same type.\r\nWhen you use the alias, it’s exactly as if you had written the aliased type.\r\nIn other words, this code mightlookillegal, but is OK according to TypeScript because both types are aliases for the same type:"
                },
                {
                    "type": "code",
                    "code": "tstypeUserInputSanitizedString=string;functionsanitizeInput(str:string):UserInputSanitizedString{returnsanitize(str);}// Create a sanitized inputletuserInput=sanitizeInput(getInput());// Can still be re-assigned with a string thoughuserInput=\"new input\";Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interfaces"
                },
                {
                    "type": "p",
                    "text": "Aninterface declarationis another way to name an object type:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePoint{x:number;y:number;}functionprintCoord(pt:Point) {console.log(\"The coordinate's x value is \"+pt.x);console.log(\"The coordinate's y value is \"+pt.y);}printCoord({x:100,y:100});Try"
                },
                {
                    "type": "p",
                    "text": "Just like when we used a type alias above, the example works just as if we had used an anonymous object type.\r\nTypeScript is only concerned with thestructureof the value we passed toprintCoord- it only cares that it has the expected properties.\r\nBeing concerned only with the structure and capabilities of types is why we call TypeScript astructurally typedtype system."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Differences Between Type Aliases and Interfaces"
                },
                {
                    "type": "p",
                    "text": "Type aliases and interfaces are very similar, and in many cases you can choose between them freely.\r\nAlmost all features of aninterfaceare available intype, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable."
                },
                {
                    "type": "p",
                    "text": "Extending an interface"
                },
                {
                    "type": "code",
                    "code": "interface Animal {\r\n  name: string;\r\n}interface Bear extends Animal {\r\n  honey: boolean;\r\n}const bear = getBear();\r\nbear.name;\r\nbear.honey;"
                },
                {
                    "type": "p",
                    "text": "Extending a type via intersections"
                },
                {
                    "type": "code",
                    "code": "type Animal = {\r\n  name: string;\r\n}type Bear = Animal & { \r\n  honey: boolean;\r\n}const bear = getBear();\r\nbear.name;\r\nbear.honey;"
                },
                {
                    "type": "p",
                    "text": "Adding new fields to an existing interface"
                },
                {
                    "type": "code",
                    "code": "interface Window {\r\n  title: string;\r\n}interface Window {\r\n  ts: TypeScriptAPI;\r\n}const src = 'const a = \"Hello World\"';\r\nwindow.ts.transpileModule(src, {});"
                },
                {
                    "type": "p",
                    "text": "A type cannot be changed after being created"
                },
                {
                    "type": "code",
                    "code": "type Window = {\r\n  title: string;\r\n}type Window = {\r\n  ts: TypeScriptAPI;\r\n}// Error: Duplicate identifier 'Window'."
                },
                {
                    "type": "p",
                    "text": "You’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away."
                },
                {
                    "type": "list",
                    "items": [
                        "Prior to TypeScript version 4.2, type alias namesmayappear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.",
                        "Type aliases may not participatein declaration merging, but interfaces can.",
                        "Interfaces may only be used todeclare the shapes of objects, not rename primitives.",
                        "Interface names willalwaysappear in their original formin error messages, butonlywhen they are used by name.",
                        "Using interfaces withextendscan often be more performant for the compilerthan type aliases with intersections"
                    ]
                },
                {
                    "type": "p",
                    "text": "For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, useinterfaceuntil you need to use features fromtype."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type Assertions"
                },
                {
                    "type": "p",
                    "text": "Sometimes you will have information about the type of a value that TypeScript can’t know about."
                },
                {
                    "type": "p",
                    "text": "For example, if you’re usingdocument.getElementById, TypeScript only knows that this will returnsomekind ofHTMLElement, but you might know that your page will always have anHTMLCanvasElementwith a given ID."
                },
                {
                    "type": "p",
                    "text": "In this situation, you can use atype assertionto specify a more specific type:"
                },
                {
                    "type": "code",
                    "code": "tsconstmyCanvas=document.getElementById(\"main_canvas\")asHTMLCanvasElement;Try"
                },
                {
                    "type": "p",
                    "text": "Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code."
                },
                {
                    "type": "p",
                    "text": "You can also use the angle-bracket syntax (except if the code is in a.tsxfile), which is equivalent:"
                },
                {
                    "type": "code",
                    "code": "tsconstmyCanvas= <HTMLCanvasElement>document.getElementById(\"main_canvas\");Try"
                },
                {
                    "type": "p",
                    "text": "Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion.\r\nThere won’t be an exception ornullgenerated if the type assertion is wrong."
                },
                {
                    "type": "p",
                    "text": "TypeScript only allows type assertions which convert to amore specificorless specificversion of a type.\r\nThis rule prevents “impossible” coercions like:"
                },
                {
                    "type": "code",
                    "code": "tsconstx=\"hello\"asnumber;Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.2352Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.Try"
                },
                {
                    "type": "p",
                    "text": "Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid.\r\nIf this happens, you can use two assertions, first toany(orunknown, which we’ll introduce later), then to the desired type:"
                },
                {
                    "type": "code",
                    "code": "tsconsta=exprasanyasT;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Literal Types"
                },
                {
                    "type": "p",
                    "text": "In addition to the general typesstringandnumber, we can refer tospecificstrings and numbers in type positions."
                },
                {
                    "type": "p",
                    "text": "One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Bothvarandletallow for changing what is held inside the variable, andconstdoes not. This is reflected in how TypeScript creates types for literals."
                },
                {
                    "type": "code",
                    "code": "tsletchangingString=\"Hello World\";changingString=\"Olá Mundo\";// Because `changingString` can represent any possible string, that// is how TypeScript describes it in the type systemchangingString;let changingString: stringconstconstantString=\"Hello World\";// Because `constantString` can only represent 1 possible string, it// has a literal type representationconstantString;const constantString: \"Hello World\"Try"
                },
                {
                    "type": "p",
                    "text": "By themselves, literal types aren’t very valuable:"
                },
                {
                    "type": "code",
                    "code": "tsletx:\"hello\"=\"hello\";// OKx=\"hello\";// ...x=\"howdy\";Type '\"howdy\"' is not assignable to type '\"hello\"'.2322Type '\"howdy\"' is not assignable to type '\"hello\"'.Try"
                },
                {
                    "type": "p",
                    "text": "It’s not much use to have a variable that can only have one value!"
                },
                {
                    "type": "p",
                    "text": "But bycombiningliterals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintText(s:string,alignment:\"left\"|\"right\"|\"center\") {// ...}printText(\"Hello, world\",\"left\");printText(\"G'day, mate\",\"centre\");Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.2345Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.Try"
                },
                {
                    "type": "p",
                    "text": "Numeric literal types work the same way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncompare(a:string,b:string): -1|0|1{returna===b?0:a>b?1: -1;}Try"
                },
                {
                    "type": "p",
                    "text": "Of course, you can combine these with non-literal types:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceOptions{width:number;}functionconfigure(x:Options|\"auto\") {// ...}configure({width:100});configure(\"auto\");configure(\"automatic\");Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.2345Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.Try"
                },
                {
                    "type": "p",
                    "text": "There’s one more kind of literal type: boolean literals.\r\nThere are only two boolean literal types, and as you might guess, they are the typestrueandfalse.\r\nThe typebooleanitself is actually just an alias for the uniontrue | false."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Literal Inference"
                },
                {
                    "type": "p",
                    "text": "When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later.\r\nFor example, if you wrote code like this:"
                },
                {
                    "type": "code",
                    "code": "tsconstobj= {counter:0};if(someCondition) {obj.counter=1;}Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t assume the assignment of1to a field which previously had0is an error.\r\nAnother way of saying this is thatobj.countermust have the typenumber, not0, because types are used to determine bothreadingandwritingbehavior."
                },
                {
                    "type": "p",
                    "text": "The same applies to strings:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionhandleRequest(url:string,method:\"GET\"|\"POST\"):void;constreq= {url:\"https://example.com\",method:\"GET\"};handleRequest(req.url,req.method);Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.2345Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.Try"
                },
                {
                    "type": "p",
                    "text": "In the above examplereq.methodis inferred to bestring, not\"GET\". Because code can be evaluated between the creation ofreqand the call ofhandleRequestwhich could assign a new string like\"GUESS\"toreq.method, TypeScript considers this code to have an error."
                },
                {
                    "type": "p",
                    "text": "There are two ways to work around this."
                },
                {
                    "type": "list",
                    "items": [
                        "You can change the inference by adding a type assertion in either location:ts// Change 1:constreq= {url:\"https://example.com\",method:\"GET\"as\"GET\"};// Change 2handleRequest(req.url,req.methodas\"GET\");TryChange 1 means “I intend forreq.methodto always have theliteral type\"GET\"”, preventing the possible assignment of\"GUESS\"to that field after.\r\nChange 2 means “I know for other reasons thatreq.methodhas the value\"GET\"“.",
                        "You can useas constto convert the entire object to be type literals:tsconstreq= {url:\"https://example.com\",method:\"GET\"}asconst;handleRequest(req.url,req.method);Try"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can change the inference by adding a type assertion in either location:"
                },
                {
                    "type": "code",
                    "code": "ts// Change 1:constreq= {url:\"https://example.com\",method:\"GET\"as\"GET\"};// Change 2handleRequest(req.url,req.methodas\"GET\");Try"
                },
                {
                    "type": "p",
                    "text": "Change 1 means “I intend forreq.methodto always have theliteral type\"GET\"”, preventing the possible assignment of\"GUESS\"to that field after.\r\nChange 2 means “I know for other reasons thatreq.methodhas the value\"GET\"“."
                },
                {
                    "type": "p",
                    "text": "You can useas constto convert the entire object to be type literals:"
                },
                {
                    "type": "code",
                    "code": "tsconstreq= {url:\"https://example.com\",method:\"GET\"}asconst;handleRequest(req.url,req.method);Try"
                },
                {
                    "type": "p",
                    "text": "Theas constsuffix acts likeconstbut for the type system, ensuring that all properties are assigned the literal type instead of a more general version likestringornumber."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "nullandundefined"
                },
                {
                    "type": "p",
                    "text": "JavaScript has two primitive values used to signal absent or uninitialized value:nullandundefined."
                },
                {
                    "type": "p",
                    "text": "TypeScript has two correspondingtypesby the same names. How these types behave depends on whether you have thestrictNullChecksoption on."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "strictNullChecksoff"
                },
                {
                    "type": "p",
                    "text": "WithstrictNullChecksoff, values that might benullorundefinedcan still be accessed normally, and the valuesnullandundefinedcan be assigned to a property of any type.\r\nThis is similar to how languages without null checks (e.g. C#, Java) behave.\r\nThe lack of checking for these values tends to be a major source of bugs; we always recommend people turnstrictNullCheckson if it’s practical to do so in their codebase."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "strictNullCheckson"
                },
                {
                    "type": "p",
                    "text": "WithstrictNullCheckson, when a value isnullorundefined, you will need to test for those values before using methods or properties on that value.\r\nJust like checking forundefinedbefore using an optional property, we can usenarrowingto check for values that might benull:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(x:string|null) {if(x===null) {// do nothing}else{console.log(\"Hello, \"+x.toUpperCase());}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Non-null Assertion Operator (Postfix!)"
                },
                {
                    "type": "p",
                    "text": "TypeScript also has a special syntax for removingnullandundefinedfrom a type without doing any explicit checking.\r\nWriting!after any expression is effectively a type assertion that the value isn’tnullorundefined:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionliveDangerously(x?:number|null) {// No errorconsole.log(x!.toFixed());}Try"
                },
                {
                    "type": "p",
                    "text": "Just like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use!when you know that the valuecan’tbenullorundefined."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Enums"
                },
                {
                    "type": "p",
                    "text": "Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this isnota type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in theEnum reference page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Less Common Primitives"
                },
                {
                    "type": "p",
                    "text": "It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system.\r\nThough we will not go into depth here."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "bigint"
                },
                {
                    "type": "p",
                    "text": "From ES2020 onwards, there is a primitive in JavaScript used for very large integers,BigInt:"
                },
                {
                    "type": "code",
                    "code": "ts// Creating a bigint via the BigInt functionconstoneHundred:bigint=BigInt(100);// Creating a BigInt via the literal syntaxconstanotherHundred:bigint=100n;Try"
                },
                {
                    "type": "p",
                    "text": "You can learn more about BigInt inthe TypeScript 3.2 release notes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "symbol"
                },
                {
                    "type": "p",
                    "text": "There is a primitive in JavaScript used to create a globally unique reference via the functionSymbol():"
                },
                {
                    "type": "code",
                    "code": "tsconstfirstName=Symbol(\"name\");constsecondName=Symbol(\"name\");if(firstName===secondName) {This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.2367This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.// Can't ever happen}Try"
                },
                {
                    "type": "p",
                    "text": "You can learn more about them inSymbols reference page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The Basics"
                },
                {
                    "type": "p",
                    "text": "Step one in learning TypeScript: The basic types."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Narrowing"
                },
                {
                    "type": "p",
                    "text": "Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
            "title": "TypeScript: Documentation - More on Functions",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "More on Functions"
                },
                {
                    "type": "p",
                    "text": "Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class.\r\nThey’re also values, and just like other values, TypeScript has many ways to describe how functions can be called.\r\nLet’s learn about how to write types that describe functions."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function Type Expressions"
                },
                {
                    "type": "p",
                    "text": "The simplest way to describe a function is with afunction type expression.\r\nThese types are syntactically similar to arrow functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(fn: (a:string)=>void) {fn(\"Hello, World\");}functionprintToConsole(s:string) {console.log(s);}greeter(printToConsole);Try"
                },
                {
                    "type": "p",
                    "text": "The syntax(a: string) => voidmeans “a function with one parameter, nameda, of typestring, that doesn’t have a return value”.\r\nJust like with function declarations, if a parameter type isn’t specified, it’s implicitlyany."
                },
                {
                    "type": "p",
                    "text": "Note that the parameter name isrequired. The function type(string) => voidmeans “a function with a parameter namedstringof typeany“!"
                },
                {
                    "type": "p",
                    "text": "Of course, we can use a type alias to name a function type:"
                },
                {
                    "type": "code",
                    "code": "tstypeGreetFunction= (a:string)=>void;functiongreeter(fn:GreetFunction) {// ...}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Call Signatures"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, functions can have properties in addition to being callable.\r\nHowever, the function type expression syntax doesn’t allow for declaring properties.\r\nIf we want to describe something callable with properties, we can write acall signaturein an object type:"
                },
                {
                    "type": "code",
                    "code": "tstypeDescribableFunction= {description:string;(someArg:number):boolean;};functiondoSomething(fn:DescribableFunction) {console.log(fn.description+\" returned \"+fn(6));}functionmyFunc(someArg:number) {returnsomeArg>3;}myFunc.description=\"default description\";doSomething(myFunc);Try"
                },
                {
                    "type": "p",
                    "text": "Note that the syntax is slightly different compared to a function type expression - use:between the parameter list and the return type rather than=>."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Construct Signatures"
                },
                {
                    "type": "p",
                    "text": "JavaScript functions can also be invoked with thenewoperator.\r\nTypeScript refers to these asconstructorsbecause they usually create a new object.\r\nYou can write aconstruct signatureby adding thenewkeyword in front of a call signature:"
                },
                {
                    "type": "code",
                    "code": "tstypeSomeConstructor= {new(s:string):SomeObject;};functionfn(ctor:SomeConstructor) {returnnewctor(\"hello\");}Try"
                },
                {
                    "type": "p",
                    "text": "Some objects, like JavaScript’sDateobject, can be called with or withoutnew.\r\nYou can combine call and construct signatures in the same type arbitrarily:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCallOrConstruct{(n?:number):string;new(s:string):Date;}functionfn(ctor:CallOrConstruct) {// Passing an argument of type `number` to `ctor` matches it against// the first definition in the `CallOrConstruct` interface.console.log(ctor(10));(parameter) ctor: CallOrConstruct\n(n?: number) => string// Similarly, passing an argument of type `string` to `ctor` matches it// against the second definition in the `CallOrConstruct` interface.console.log(newctor(\"10\"));(parameter) ctor: CallOrConstruct\nnew (s: string) => Date}fn(Date);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Functions"
                },
                {
                    "type": "p",
                    "text": "It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.\r\nLet’s consider for a moment a function that returns the first element of an array:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirstElement(arr:any[]) {returnarr[0];}Try"
                },
                {
                    "type": "p",
                    "text": "This function does its job, but unfortunately has the return typeany.\r\nIt’d be better if the function returned the type of the array element."
                },
                {
                    "type": "p",
                    "text": "In TypeScript,genericsare used when we want to describe a correspondence between two values.\r\nWe do this by declaring atype parameterin the function signature:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirstElement<Type>(arr:Type[]):Type|undefined{returnarr[0];}Try"
                },
                {
                    "type": "p",
                    "text": "By adding a type parameterTypeto this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value).\r\nNow when we call it, a more specific type comes out:"
                },
                {
                    "type": "code",
                    "code": "ts// s is of type 'string'consts=firstElement([\"a\",\"b\",\"c\"]);// n is of type 'number'constn=firstElement([1,2,3]);// u is of type undefinedconstu=firstElement([]);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inference"
                },
                {
                    "type": "p",
                    "text": "Note that we didn’t have to specifyTypein this sample.\r\nThe type wasinferred- chosen automatically - by TypeScript."
                },
                {
                    "type": "p",
                    "text": "We can use multiple type parameters as well.\r\nFor example, a standalone version ofmapwould look like this:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionmap<Input,Output>(arr:Input[],func: (arg:Input)=>Output):Output[] {returnarr.map(func);}// Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'constparsed=map([\"1\",\"2\",\"3\"], (n)=>parseInt(n));Try"
                },
                {
                    "type": "p",
                    "text": "Note that in this example, TypeScript could infer both the type of theInputtype parameter (from the givenstringarray), as well as theOutputtype parameter based on the return value of the function expression (number)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Constraints"
                },
                {
                    "type": "p",
                    "text": "We’ve written some generic functions that can work onanykind of value.\r\nSometimes we want to relate two values, but can only operate on a certain subset of values.\r\nIn this case, we can use aconstraintto limit the kinds of types that a type parameter can accept."
                },
                {
                    "type": "p",
                    "text": "Let’s write a function that returns the longer of two values.\r\nTo do this, we need alengthproperty that’s a number.\r\nWeconstrainthe type parameter to that type by writing anextendsclause:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlongest<Typeextends{length:number}>(a:Type,b:Type) {if(a.length>=b.length) {returna;}else{returnb;}}// longerArray is of type 'number[]'constlongerArray=longest([1,2], [1,2,3]);// longerString is of type 'alice' | 'bob'constlongerString=longest(\"alice\",\"bob\");// Error! Numbers don't have a 'length' propertyconstnotOK=longest(10,100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.Try"
                },
                {
                    "type": "p",
                    "text": "There are a few interesting things to note in this example.\r\nWe allowed TypeScript toinferthe return type oflongest.\r\nReturn type inference also works on generic functions."
                },
                {
                    "type": "p",
                    "text": "Because we constrainedTypeto{ length: number }, we were allowed to access the.lengthproperty of theaandbparameters.\r\nWithout the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property."
                },
                {
                    "type": "p",
                    "text": "The types oflongerArrayandlongerStringwere inferred based on the arguments.\r\nRemember, generics are all about relating two or more values with the same type!"
                },
                {
                    "type": "p",
                    "text": "Finally, just as we’d like, the call tolongest(10, 100)is rejected because thenumbertype doesn’t have a.lengthproperty."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Working with Constrained Values"
                },
                {
                    "type": "p",
                    "text": "Here’s a common error when working with generic constraints:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionminimumLength<Typeextends{length:number}>(obj:Type,minimum:number):Type{if(obj.length>=minimum) {returnobj;}else{return{length:minimum};Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.}}Try"
                },
                {
                    "type": "p",
                    "text": "It might look like this function is OK -Typeis constrained to{ length: number }, and the function either returnsTypeor a value matching that constraint.\r\nThe problem is that the function promises to return thesamekind of object as was passed in, not justsomeobject matching the constraint.\r\nIf this code were legal, you could write code that definitely wouldn’t work:"
                },
                {
                    "type": "code",
                    "code": "ts// 'arr' gets value { length: 6 }constarr=minimumLength([1,2,3],6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying Type Arguments"
                },
                {
                    "type": "p",
                    "text": "TypeScript can usually infer the intended type arguments in a generic call, but not always.\r\nFor example, let’s say you wrote a function to combine two arrays:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncombine<Type>(arr1:Type[],arr2:Type[]):Type[] {returnarr1.concat(arr2);}Try"
                },
                {
                    "type": "p",
                    "text": "Normally it would be an error to call this function with mismatched arrays:"
                },
                {
                    "type": "code",
                    "code": "tsconstarr=combine([1,2,3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "If you intended to do this, however, you could manually specifyType:"
                },
                {
                    "type": "code",
                    "code": "tsconstarr=combine<string|number>([1,2,3], [\"hello\"]);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Guidelines for Writing Good Generic Functions"
                },
                {
                    "type": "p",
                    "text": "Writing generic functions is fun, and it can be easy to get carried away with type parameters.\r\nHaving too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Push Type Parameters Down"
                },
                {
                    "type": "p",
                    "text": "Here are two ways of writing a function that appear similar:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirstElement1<Type>(arr:Type[]) {returnarr[0];}functionfirstElement2<Typeextendsany[]>(arr:Type) {returnarr[0];}// a: number (good)consta=firstElement1([1,2,3]);// b: any (bad)constb=firstElement2([1,2,3]);Try"
                },
                {
                    "type": "p",
                    "text": "These might seem identical at first glance, butfirstElement1is a much better way to write this function.\r\nIts inferred return type isType, butfirstElement2’s inferred return type isanybecause TypeScript has to resolve thearr[0]expression using the constraint type, rather than “waiting” to resolve the element during a call."
                },
                {
                    "type": "p",
                    "text": "Rule: When possible, use the type parameter itself rather than constraining it"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Use Fewer Type Parameters"
                },
                {
                    "type": "p",
                    "text": "Here’s another pair of similar functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfilter1<Type>(arr:Type[],func: (arg:Type)=>boolean):Type[] {returnarr.filter(func);}functionfilter2<Type,Funcextends(arg:Type)=>boolean>(arr:Type[],func:Func):Type[] {returnarr.filter(func);}Try"
                },
                {
                    "type": "p",
                    "text": "We’ve created a type parameterFuncthatdoesn’t relate two values.\r\nThat’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason.Funcdoesn’t do anything but make the function harder to read and reason about!"
                },
                {
                    "type": "p",
                    "text": "Rule: Always use as few type parameters as possible"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Type Parameters Should Appear Twice"
                },
                {
                    "type": "p",
                    "text": "Sometimes we forget that a function might not need to be generic:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet<Strextendsstring>(s:Str) {console.log(\"Hello, \"+s);}greet(\"world\");Try"
                },
                {
                    "type": "p",
                    "text": "We could just as easily have written a simpler version:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(s:string) {console.log(\"Hello, \"+s);}Try"
                },
                {
                    "type": "p",
                    "text": "Remember, type parameters are forrelating the types of multiple values.\r\nIf a type parameter is only used once in the function signature, it’s not relating anything.\r\nThis includes the inferred return type; for example, ifStrwas part of the inferred return type ofgreet, it would be relating the argument and return types, so would be usedtwicedespite appearing only once in the written code."
                },
                {
                    "type": "p",
                    "text": "Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Optional Parameters"
                },
                {
                    "type": "p",
                    "text": "Functions in JavaScript often take a variable number of arguments.\r\nFor example, thetoFixedmethod ofnumbertakes an optional digit count:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(n:number) {console.log(n.toFixed());// 0 argumentsconsole.log(n.toFixed(3));// 1 argument}Try"
                },
                {
                    "type": "p",
                    "text": "We can model this in TypeScript by marking the parameter asoptionalwith?:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x?:number) {// ...}f();// OKf(10);// OKTry"
                },
                {
                    "type": "p",
                    "text": "Although the parameter is specified as typenumber, thexparameter will actually have the typenumber | undefinedbecause unspecified parameters in JavaScript get the valueundefined."
                },
                {
                    "type": "p",
                    "text": "You can also provide a parameterdefault:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x=10) {// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Now in the body off,xwill have typenumberbecause anyundefinedargument will be replaced with10.\r\nNote that when a parameter is optional, callers can always passundefined, as this simply simulates a “missing” argument:"
                },
                {
                    "type": "code",
                    "code": "ts// All OKf();f(10);f(undefined);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Parameters in Callbacks"
                },
                {
                    "type": "p",
                    "text": "Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionmyForEach(arr:any[],callback: (arg:any,index?:number)=>void) {for(leti=0;i<arr.length;i++) {callback(arr[i],i);}}Try"
                },
                {
                    "type": "p",
                    "text": "What people usually intend when writingindex?as an optional parameter is that they want both of these calls to be legal:"
                },
                {
                    "type": "code",
                    "code": "tsmyForEach([1,2,3], (a)=>console.log(a));myForEach([1,2,3], (a,i)=>console.log(a,i));Try"
                },
                {
                    "type": "p",
                    "text": "What thisactuallymeans is thatcallbackmight get invoked with one argument.\r\nIn other words, the function definition says that the implementation might look like this:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionmyForEach(arr:any[],callback: (arg:any,index?:number)=>void) {for(leti=0;i<arr.length;i++) {// I don't feel like providing the index todaycallback(arr[i]);}}Try"
                },
                {
                    "type": "p",
                    "text": "In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:"
                },
                {
                    "type": "code",
                    "code": "tsmyForEach([1,2,3], (a,i)=>{console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored.\r\nTypeScript behaves the same way.\r\nFunctions with fewer parameters (of the same types) can always take the place of functions with more parameters."
                },
                {
                    "type": "p",
                    "text": "Rule: When writing a function type for a callback,neverwrite an optional parameter unless you intend tocallthe function without passing that argument"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function Overloads"
                },
                {
                    "type": "p",
                    "text": "Some JavaScript functions can be called in a variety of argument counts and types.\r\nFor example, you might write a function to produce aDatethat takes either a timestamp (one argument) or a month/day/year specification (three arguments)."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, we can specify a function that can be called in different ways by writingoverload signatures.\r\nTo do this, write some number of function signatures (usually two or more), followed by the body of the function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionmakeDate(timestamp:number):Date;functionmakeDate(m:number,d:number,y:number):Date;functionmakeDate(mOrTimestamp:number,d?:number,y?:number):Date{if(d!==undefined&&y!==undefined) {returnnewDate(y,mOrTimestamp,d);}else{returnnewDate(mOrTimestamp);}}constd1=makeDate(12345678);constd2=makeDate(5,5,5);constd3=makeDate(1,3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.Try"
                },
                {
                    "type": "p",
                    "text": "In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments.\r\nThese first two signatures are called theoverload signatures."
                },
                {
                    "type": "p",
                    "text": "Then, we wrote a function implementation with a compatible signature.\r\nFunctions have animplementationsignature, but this signature can’t be called directly.\r\nEven though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Overload Signatures and the Implementation Signature"
                },
                {
                    "type": "p",
                    "text": "This is a common source of confusion.\r\nOften people will write code like this and not understand why there is an error:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string):void;functionfn() {// ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.Try"
                },
                {
                    "type": "p",
                    "text": "Again, the signature used to write the function body can’t be “seen” from the outside."
                },
                {
                    "type": "p",
                    "text": "The signature of theimplementationis not visible from the outside.\r\nWhen writing an overloaded function, you should always havetwoor more signatures above the implementation of the function."
                },
                {
                    "type": "p",
                    "text": "The implementation signature must also becompatiblewith the overload signatures.\r\nFor example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:boolean):void;// Argument type isn't rightfunctionfn(x:string):void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.functionfn(x:boolean) {}Try"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string):string;// Return type isn't rightfunctionfn(x:number):boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.functionfn(x:string|number) {return\"oops\";}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Writing Good Overloads"
                },
                {
                    "type": "p",
                    "text": "Like generics, there are a few guidelines you should follow when using function overloads.\r\nFollowing these principles will make your function easier to call, easier to understand, and easier to implement."
                },
                {
                    "type": "p",
                    "text": "Let’s consider a function that returns the length of a string or an array:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlen(s:string):number;functionlen(arr:any[]):number;functionlen(x:any) {returnx.length;}Try"
                },
                {
                    "type": "p",
                    "text": "This function is fine; we can invoke it with strings or arrays.\r\nHowever, we can’t invoke it with a value that might be a stringoran array, because TypeScript can only resolve a function call to a single overload:"
                },
                {
                    "type": "code",
                    "code": "tslen(\"\");// OKlen([0]);// OKlen(Math.random() >0.5?\"hello\": [0]);No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.Try"
                },
                {
                    "type": "p",
                    "text": "Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlen(x:any[] |string) {returnx.length;}Try"
                },
                {
                    "type": "p",
                    "text": "This is much better!\r\nCallers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature."
                },
                {
                    "type": "p",
                    "text": "Always prefer parameters with union types instead of overloads when possible"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Declaringthisin a Function"
                },
                {
                    "type": "p",
                    "text": "TypeScript will infer what thethisshould be in a function via code flow analysis, for example in the following:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser= {id:123,admin:false,becomeAdmin:function() {this.admin=true;},};Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript understands that the functionuser.becomeAdminhas a correspondingthiswhich is the outer objectuser.this,heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what objectthisrepresents. The JavaScript specification states that you cannot have a parameter calledthis, and so TypeScript uses that syntax space to let you declare the type forthisin the function body."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDB{filterUsers(filter: (this:User)=>boolean):User[];}constdb=getDB();constadmins=db.filterUsers(function(this:User) {returnthis.admin;});Try"
                },
                {
                    "type": "p",
                    "text": "This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to usefunctionand not arrow functions to get this behavior:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDB{filterUsers(filter: (this:User)=>boolean):User[];}constdb=getDB();constadmins=db.filterUsers(()=>this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Other Types to Know About"
                },
                {
                    "type": "p",
                    "text": "There are some additional types you’ll want to recognize that appear often when working with function types.\r\nLike all types, you can use them everywhere, but these are especially relevant in the context of functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "void"
                },
                {
                    "type": "p",
                    "text": "voidrepresents the return value of functions which don’t return a value.\r\nIt’s the inferred type any time a function doesn’t have anyreturnstatements, or doesn’t return any explicit value from those return statements:"
                },
                {
                    "type": "code",
                    "code": "ts// The inferred return type is voidfunctionnoop() {return;}Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, a function that doesn’t return any value will implicitly return the valueundefined.\r\nHowever,voidandundefinedare not the same thing in TypeScript.\r\nThere are further details at the end of this chapter."
                },
                {
                    "type": "p",
                    "text": "voidis not the same asundefined."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "object"
                },
                {
                    "type": "p",
                    "text": "The special typeobjectrefers to any value that isn’t a primitive (string,number,bigint,boolean,symbol,null, orundefined).\r\nThis is different from theempty object type{ }, and also different from the global typeObject.\r\nIt’s very likely you will never useObject."
                },
                {
                    "type": "p",
                    "text": "objectis notObject.Alwaysuseobject!"
                },
                {
                    "type": "p",
                    "text": "Note that in JavaScript, function values are objects: They have properties, haveObject.prototypein their prototype chain, areinstanceof Object, you can callObject.keyson them, and so on.\r\nFor this reason, function types are considered to beobjects in TypeScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "unknown"
                },
                {
                    "type": "p",
                    "text": "Theunknowntype representsanyvalue.\r\nThis is similar to theanytype, but is safer because it’s not legal to do anything with anunknownvalue:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf1(a:any) {a.b();// OK}functionf2(a:unknown) {a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}Try"
                },
                {
                    "type": "p",
                    "text": "This is useful when describing function types because you can describe functions that accept any value without havinganyvalues in your function body."
                },
                {
                    "type": "p",
                    "text": "Conversely, you can describe a function that returns a value of unknown type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsafeParse(s:string):unknown{returnJSON.parse(s);}// Need to be careful with 'obj'!constobj=safeParse(someRandomString);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "never"
                },
                {
                    "type": "p",
                    "text": "Some functionsneverreturn a value:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfail(msg:string):never{thrownewError(msg);}Try"
                },
                {
                    "type": "p",
                    "text": "Thenevertype represents values which areneverobserved.\r\nIn a return type, this means that the function throws an exception or terminates execution of the program."
                },
                {
                    "type": "p",
                    "text": "neveralso appears when TypeScript determines there’s nothing left in a union."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string|number) {if(typeofx===\"string\") {// do something}elseif(typeofx===\"number\") {// do something else}else{x;// has type 'never'!}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Function"
                },
                {
                    "type": "p",
                    "text": "The global typeFunctiondescribes properties likebind,call,apply, and others present on all function values in JavaScript.\r\nIt also has the special property that values of typeFunctioncan always be called; these calls returnany:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(f:Function) {returnf(1,2,3);}Try"
                },
                {
                    "type": "p",
                    "text": "This is anuntyped function calland is generally best avoided because of the unsafeanyreturn type."
                },
                {
                    "type": "p",
                    "text": "If you need to accept an arbitrary function but don’t intend to call it, the type() => voidis generally safer."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rest Parameters and Arguments"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Rest ParametersSpread Syntax"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rest Parameters"
                },
                {
                    "type": "p",
                    "text": "In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take anunboundednumber of arguments usingrest parameters."
                },
                {
                    "type": "p",
                    "text": "A rest parameter appears after all other parameters, and uses the...syntax:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionmultiply(n:number, ...m:number[]) {returnm.map((x)=>n*x);}// 'a' gets value [10, 20, 30, 40]consta=multiply(10,1,2,3,4);Try"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, the type annotation on these parameters is implicitlyany[]instead ofany, and any type annotation given must be of the formArray<T>orT[], or a tuple type (which we’ll learn about later)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rest Arguments"
                },
                {
                    "type": "p",
                    "text": "Conversely, we canprovidea variable number of arguments from an iterable object (for example, an array) using the spread syntax.\r\nFor example, thepushmethod of arrays takes any number of arguments:"
                },
                {
                    "type": "code",
                    "code": "tsconstarr1= [1,2,3];constarr2= [4,5,6];arr1.push(...arr2);Try"
                },
                {
                    "type": "p",
                    "text": "Note that in general, TypeScript does not assume that arrays are immutable.\r\nThis can lead to some surprising behavior:"
                },
                {
                    "type": "code",
                    "code": "ts// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconstargs= [8,5];constangle=Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.Try"
                },
                {
                    "type": "p",
                    "text": "The best fix for this situation depends a bit on your code, but in general aconstcontext is the most straightforward solution:"
                },
                {
                    "type": "code",
                    "code": "ts// Inferred as 2-length tupleconstargs= [8,5]asconst;// OKconstangle=Math.atan2(...args);Try"
                },
                {
                    "type": "p",
                    "text": "Using rest arguments may require turning ondownlevelIterationwhen targeting older runtimes."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Parameter Destructuring"
                },
                {
                    "type": "p",
                    "text": "Background Reading:Destructuring Assignment"
                },
                {
                    "type": "p",
                    "text": "You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body.\r\nIn JavaScript, it looks like this:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionsum({a,b,c}) {console.log(a+b+c);}sum({a:10,b:3,c:9});"
                },
                {
                    "type": "p",
                    "text": "The type annotation for the object goes after the destructuring syntax:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsum({a,b,c}: {a:number;b:number;c:number}) {console.log(a+b+c);}Try"
                },
                {
                    "type": "p",
                    "text": "This can look a bit verbose, but you can use a named type here as well:"
                },
                {
                    "type": "code",
                    "code": "ts// Same as prior exampletypeABC= {a:number;b:number;c:number};functionsum({a,b,c}:ABC) {console.log(a+b+c);}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Assignability of Functions"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Return typevoid"
                },
                {
                    "type": "p",
                    "text": "Thevoidreturn type for functions can produce some unusual, but expected behavior."
                },
                {
                    "type": "p",
                    "text": "Contextual typing with a return type ofvoiddoesnotforce functions tonotreturn something. Another way to say this is a contextual function type with avoidreturn type (type voidFunc = () => void), when implemented, can returnanyother value, but it will be ignored."
                },
                {
                    "type": "p",
                    "text": "Thus, the following implementations of the type() => voidare valid:"
                },
                {
                    "type": "code",
                    "code": "tstypevoidFunc= ()=>void;constf1:voidFunc= ()=>{returntrue;};constf2:voidFunc= ()=>true;constf3:voidFunc=function() {returntrue;};Try"
                },
                {
                    "type": "p",
                    "text": "And when the return value of one of these functions is assigned to another variable, it will retain the type ofvoid:"
                },
                {
                    "type": "code",
                    "code": "tsconstv1=f1();constv2=f2();constv3=f3();Try"
                },
                {
                    "type": "p",
                    "text": "This behavior exists so that the following code is valid even thoughArray.prototype.pushreturns a number and theArray.prototype.forEachmethod expects a function with a return type ofvoid."
                },
                {
                    "type": "code",
                    "code": "tsconstsrc= [1,2,3];constdst= [0];src.forEach((el)=>dst.push(el));Try"
                },
                {
                    "type": "p",
                    "text": "There is one other special case to be aware of, when a literal function definition has avoidreturn type, that function mustnotreturn anything."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf2():void{// @ts-expect-errorreturntrue;}constf3=function():void{// @ts-expect-errorreturntrue;};Try"
                },
                {
                    "type": "p",
                    "text": "For more onvoidplease refer to these other documentation entries:"
                },
                {
                    "type": "list",
                    "items": [
                        "v2 handbook",
                        "FAQ - “Why are functions returning non-void assignable to function returning void?”"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Narrowing"
                },
                {
                    "type": "p",
                    "text": "Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Object Types"
                },
                {
                    "type": "p",
                    "text": "How TypeScript describes the shapes of JavaScript objects."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
            "title": "TypeScript: Documentation - Generics",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable.\nComponents that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems."
                },
                {
                    "type": "p",
                    "text": "In languages like C# and Java, one of the main tools in the toolbox for creating reusable components isgenerics, that is, being able to create a component that can work over a variety of types rather than a single one.\nThis allows users to consume these components and use their own types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Hello World of Generics"
                },
                {
                    "type": "p",
                    "text": "To start off, let’s do the “hello world” of generics: the identity function.\nThe identity function is a function that will return back whatever is passed in.\nYou can think of this in a similar way to theechocommand."
                },
                {
                    "type": "p",
                    "text": "Without generics, we would either have to give the identity function a specific type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity(arg:number):number{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Or, we could describe the identity function using theanytype:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity(arg:any):any{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "While usinganyis certainly generic in that it will cause the function to accept any and all types for the type ofarg, we actually are losing the information about what that type was when the function returns.\nIf we passed in a number, the only information we have is that any type could be returned."
                },
                {
                    "type": "p",
                    "text": "Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned.\nHere, we will use atype variable, a special kind of variable that works on types rather than values."
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<Type>(arg:Type):Type{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "We’ve now added a type variableTypeto the identity function.\nThisTypeallows us to capture the type the user provides (e.g.number), so that we can use that information later.\nHere, we useTypeagain as the return type. On inspection, we can now see the same type is used for the argument and the return type.\nThis allows us to traffic that type information in one side of the function and out the other."
                },
                {
                    "type": "p",
                    "text": "We say that this version of theidentityfunction is generic, as it works over a range of types.\nUnlike usingany, it’s also just as precise (i.e., it doesn’t lose any information) as the firstidentityfunction that used numbers for the argument and return type."
                },
                {
                    "type": "p",
                    "text": "Once we’ve written the generic identity function, we can call it in one of two ways.\nThe first way is to pass all of the arguments, including the type argument, to the function:"
                },
                {
                    "type": "code",
                    "code": "tsletoutput=identity<string>(\"myString\");let output: stringTry"
                },
                {
                    "type": "p",
                    "text": "Here we explicitly setTypeto bestringas one of the arguments to the function call, denoted using the<>around the arguments rather than()."
                },
                {
                    "type": "p",
                    "text": "The second way is also perhaps the most common. Here we usetype argument inference— that is, we want the compiler to set the value ofTypefor us automatically based on the type of the argument we pass in:"
                },
                {
                    "type": "code",
                    "code": "tsletoutput=identity(\"myString\");let output: stringTry"
                },
                {
                    "type": "p",
                    "text": "Notice that we didn’t have to explicitly pass the type in the angle brackets (<>); the compiler just looked at the value\"myString\", and setTypeto its type.\nWhile type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Working with Generic Type Variables"
                },
                {
                    "type": "p",
                    "text": "When you begin to use generics, you’ll notice that when you create generic functions likeidentity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly.\nThat is, that you actually treat these parameters as if they could be any and all types."
                },
                {
                    "type": "p",
                    "text": "Let’s take ouridentityfunction from earlier:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<Type>(arg:Type):Type{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "What if we want to also log the length of the argumentargto the console with each call?\nWe might be tempted to write this:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<Type>(arg:Type):Type{console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "When we do, the compiler will give us an error that we’re using the.lengthmember ofarg, but nowhere have we said thatarghas this member.\nRemember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in anumberinstead, which does not have a.lengthmember."
                },
                {
                    "type": "p",
                    "text": "Let’s say that we’ve actually intended this function to work on arrays ofTyperather thanTypedirectly. Since we’re working with arrays, the.lengthmember should be available.\nWe can describe this just like we would create arrays of other types:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<Type>(arg:Type[]):Type[] {console.log(arg.length);returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "You can read the type ofloggingIdentityas “the generic functionloggingIdentitytakes a type parameterType, and an argumentargwhich is an array ofTypes, and returns an array ofTypes.”\nIf we passed in an array of numbers, we’d get an array of numbers back out, asTypewould bind tonumber.\nThis allows us to use our generic type variableTypeas part of the types we’re working with, rather than the whole type, giving us greater flexibility."
                },
                {
                    "type": "p",
                    "text": "We can alternatively write the sample example this way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<Type>(arg:Array<Type>):Array<Type> {console.log(arg.length);// Array has a .length, so no more errorreturnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "You may already be familiar with this style of type from other languages.\nIn the next section, we’ll cover how you can create your own generic types likeArray<Type>."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Types"
                },
                {
                    "type": "p",
                    "text": "In previous sections, we created generic identity functions that worked over a range of types.\nIn this section, we’ll explore the type of the functions themselves and how to create generic interfaces."
                },
                {
                    "type": "p",
                    "text": "The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<Type>(arg:Type):Type{returnarg;}letmyIdentity: <Type>(arg:Type)=>Type=identity;Try"
                },
                {
                    "type": "p",
                    "text": "We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up."
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<Type>(arg:Type):Type{returnarg;}letmyIdentity: <Input>(arg:Input)=>Input=identity;Try"
                },
                {
                    "type": "p",
                    "text": "We can also write the generic type as a call signature of an object literal type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<Type>(arg:Type):Type{returnarg;}letmyIdentity: { <Type>(arg:Type):Type} =identity;Try"
                },
                {
                    "type": "p",
                    "text": "Which leads us to writing our first generic interface.\nLet’s take the object literal from the previous example and move it to an interface:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGenericIdentityFn{<Type>(arg:Type):Type;}functionidentity<Type>(arg:Type):Type{returnarg;}letmyIdentity:GenericIdentityFn=identity;Try"
                },
                {
                    "type": "p",
                    "text": "In a similar example, we may want to move the generic parameter to be a parameter of the whole interface.\nThis lets us see what type(s) we’re generic over (e.g.Dictionary<string>rather than justDictionary).\nThis makes the type parameter visible to all the other members of the interface."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGenericIdentityFn<Type> {(arg:Type):Type;}functionidentity<Type>(arg:Type):Type{returnarg;}letmyIdentity:GenericIdentityFn<number> =identity;Try"
                },
                {
                    "type": "p",
                    "text": "Notice that our example has changed to be something slightly different.\nInstead of describing a generic function, we now have a non-generic function signature that is a part of a generic type.\nWhen we useGenericIdentityFn, we now will also need to specify the corresponding type argument (here:number), effectively locking in what the underlying call signature will use.\nUnderstanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic."
                },
                {
                    "type": "p",
                    "text": "In addition to generic interfaces, we can also create generic classes.\nNote that it is not possible to create generic enums and namespaces."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Classes"
                },
                {
                    "type": "p",
                    "text": "A generic class has a similar shape to a generic interface.\nGeneric classes have a generic type parameter list in angle brackets (<>) following the name of the class."
                },
                {
                    "type": "code",
                    "code": "tsclassGenericNumber<NumType> {zeroValue:NumType;add: (x:NumType,y:NumType)=>NumType;}letmyGenericNumber=newGenericNumber<number>();myGenericNumber.zeroValue=0;myGenericNumber.add=function(x,y) {returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "This is a pretty literal use of theGenericNumberclass, but you may have noticed that nothing is restricting it to only use thenumbertype.\nWe could have instead usedstringor even more complex objects."
                },
                {
                    "type": "code",
                    "code": "tsletstringNumeric=newGenericNumber<string>();stringNumeric.zeroValue=\"\";stringNumeric.add=function(x,y) {returnx+y;};console.log(stringNumeric.add(stringNumeric.zeroValue,\"test\"));Try"
                },
                {
                    "type": "p",
                    "text": "Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type."
                },
                {
                    "type": "p",
                    "text": "As we cover inour section on classes, a class has two sides to its type: the static side and the instance side.\nGeneric classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Constraints"
                },
                {
                    "type": "p",
                    "text": "If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you havesomeknowledge about what capabilities that set of types will have.\nIn ourloggingIdentityexample, we wanted to be able to access the.lengthproperty ofarg, but the compiler could not prove that every type had a.lengthproperty, so it warns us that we can’t make this assumption."
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<Type>(arg:Type):Type{console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Instead of working with any and all types, we’d like to constrain this function to work with any and all types thatalsohave the.lengthproperty.\nAs long as the type has this member, we’ll allow it, but it’s required to have at least this member.\nTo do so, we must list our requirement as a constraint on whatTypecan be."
                },
                {
                    "type": "p",
                    "text": "To do so, we’ll create an interface that describes our constraint.\nHere, we’ll create an interface that has a single.lengthproperty and then we’ll use this interface and theextendskeyword to denote our constraint:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceLengthwise{length:number;}functionloggingIdentity<TypeextendsLengthwise>(arg:Type):Type{console.log(arg.length);// Now we know it has a .length property, so no more errorreturnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Because the generic function is now constrained, it will no longer work over any and all types:"
                },
                {
                    "type": "code",
                    "code": "tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try"
                },
                {
                    "type": "p",
                    "text": "Instead, we need to pass in values whose type has all the required properties:"
                },
                {
                    "type": "code",
                    "code": "tsloggingIdentity({length:10,value:3});Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Type Parameters in Generic Constraints"
                },
                {
                    "type": "p",
                    "text": "You can declare a type parameter that is constrained by another type parameter.\nFor example, here we’d like to get a property from an object given its name.\nWe’d like to ensure that we’re not accidentally grabbing a property that does not exist on theobj, so we’ll place a constraint between the two types:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetProperty<Type,KeyextendskeyofType>(obj:Type,key:Key) {returnobj[key];}letx= {a:1,b:2,c:3,d:4};getProperty(x,\"a\");getProperty(x,\"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Class Types in Generics"
                },
                {
                    "type": "p",
                    "text": "When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreate<Type>(c: {new():Type}):Type{returnnewc();}Try"
                },
                {
                    "type": "p",
                    "text": "A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types."
                },
                {
                    "type": "code",
                    "code": "tsclassBeeKeeper{hasMask:boolean=true;}classZooKeeper{nametag:string=\"Mikle\";}classAnimal{numLegs:number=4;}classBeeextendsAnimal{numLegs=6;keeper:BeeKeeper=newBeeKeeper();}classLionextendsAnimal{keeper:ZooKeeper=newZooKeeper();}functioncreateInstance<AextendsAnimal>(c:new()=>A):A{returnnewc();}createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try"
                },
                {
                    "type": "p",
                    "text": "This pattern is used to power themixinsdesign pattern."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Parameter Defaults"
                },
                {
                    "type": "p",
                    "text": "By declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a newHTMLElement. Calling the function with no arguments generates aHTMLDivElement; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctioncreate():Container<HTMLDivElement,HTMLDivElement[]>;declarefunctioncreate<TextendsHTMLElement>(element:T):Container<T,T[]>;declarefunctioncreate<TextendsHTMLElement,UextendsHTMLElement>(element:T,children:U[]):Container<T,U[]>;Try"
                },
                {
                    "type": "p",
                    "text": "With generic parameter defaults we can reduce it to:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctioncreate<TextendsHTMLElement=HTMLDivElement,UextendsHTMLElement[] =T[]>(element?:T,children?:U):Container<T,U>;constdiv=create();const div: Container<HTMLDivElement, HTMLDivElement[]>constp=create(newHTMLParagraphElement());const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>Try"
                },
                {
                    "type": "p",
                    "text": "A generic parameter default follows the following rules:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type parameter is deemed optional if it has a default.",
                        "Required type parameters must not follow optional type parameters.",
                        "Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.",
                        "When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.",
                        "If a default type is specified and inference cannot choose a candidate, the default type is inferred.",
                        "A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.",
                        "A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Variance Annotations"
                },
                {
                    "type": "p",
                    "text": "This is an advanced feature for solving a very specific problem, and should only be used in situations where you’ve identified a reason to use it"
                },
                {
                    "type": "p",
                    "text": "Covariance and contravarianceare type theory terms that describe what the relationship between two generic types is.\nHere’s a brief primer on the concept."
                },
                {
                    "type": "p",
                    "text": "For example, if you have an interface representing an object that canmakea certain type:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceProducer<T> {make():T;}"
                },
                {
                    "type": "p",
                    "text": "We can use aProducer<Cat>where aProducer<Animal>is expected, because aCatis anAnimal.\nThis relationship is calledcovariance: the relationship fromProducer<T>toProducer<U>is the same as the relationship fromTtoU."
                },
                {
                    "type": "p",
                    "text": "Conversely, if you have an interface that canconsumea certain type:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceConsumer<T> {consume: (arg:T)=>void;}"
                },
                {
                    "type": "p",
                    "text": "Then we can use aConsumer<Animal>where aConsumer<Cat>is expected, because any function that is capable of accepting aCatmust also be capable of accepting anAnimal.\nThis relationship is calledcontravariance: the relationship fromConsumer<T>toConsumer<U>is the same as the relationship fromUtoT.\nNote the reversal of direction as compared to covariance! This is why contravariance “cancels itself out” but covariance doesn’t."
                },
                {
                    "type": "p",
                    "text": "In a structural type system like TypeScript’s, covariance and contravariance are naturally emergent behaviors that follow from the definition of types.\nEven in the absence of generics, we would see covariant (and contravariant) relationships:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimalProducer{make():Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterfaceCatProducer{make():Cat;}"
                },
                {
                    "type": "p",
                    "text": "TypeScript has a structural type system, so when comparing two types, e.g. to see if aProducer<Cat>can be used where aProducer<Animal>is expected, the usual algorithm would be structurally expand both of those definitions, and compare their structures.\nHowever, variance allows for an extremely useful optimization: ifProducer<T>is covariant onT, then we can simply checkCatandAnimalinstead, as we know they’ll have the same relationship asProducer<Cat>andProducer<Animal>."
                },
                {
                    "type": "p",
                    "text": "Note that this logic can only be used when we’re examining two instantiations of the same type.\nIf we have aProducer<T>and aFastProducer<U>, there’s no guarantee thatTandUnecessarily refer to the same positions in these types, so this check will always be performed structurally."
                },
                {
                    "type": "p",
                    "text": "Because variance is a naturally emergent property of structural types, TypeScript automaticallyinfersthe variance of every generic type.In extremely rare casesinvolving certain kinds of circular types, this measurement can be inaccurate.\nIf this happens, you can add a variance annotation to a type parameter to force a particular variance:"
                },
                {
                    "type": "code",
                    "code": "ts// Contravariant annotationinterfaceConsumer<inT> {consume: (arg:T)=>void;}// Covariant annotationinterfaceProducer<outT> {make():T;}// Invariant annotationinterfaceProducerConsumer<inoutT> {consume: (arg:T)=>void;make():T;}"
                },
                {
                    "type": "p",
                    "text": "Only do this if you are writing the same variance thatshouldoccur structurally."
                },
                {
                    "type": "p",
                    "text": "Never write a variance annotation that doesn’t match the structural variance!"
                },
                {
                    "type": "p",
                    "text": "It’s critical to reinforce that variance annotations are only in effect during an instantiation-based comparison.\nThey have no effect during a structural comparison.\nFor example, you can’t use variance annotations to “force” a type to be actually invariant:"
                },
                {
                    "type": "code",
                    "code": "ts// DON'T DO THIS - variance annotation// does not match structural behaviorinterfaceProducer<inoutT> {make():T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconstp:Producer<string|number> = {make():number{return42;}}"
                },
                {
                    "type": "p",
                    "text": "Here, the object literal’smakefunction returnsnumber, which we might expect to cause an error becausenumberisn’tstring | number.\nHowever, this isn’t an instantiation-based comparison, because the object literal is an anonymous type, not aProducer<string | number>."
                },
                {
                    "type": "p",
                    "text": "Variance annotations don’t change structural behavior and are only consulted in specific situations"
                },
                {
                    "type": "p",
                    "text": "It’s very important to only write variance annotations if you absolutely know why you’re doing it, what their limitations are, and when they aren’t in effect.\nWhether TypeScript uses an instantiation-based comparison or structural comparison is not a specified behavior and may change from version to version for correctness or performance reasons, so you should only ever write variance annotations when they match the structural behavior of a type.\nDon’t use variance annotations to try to “force” a particular variance; this will cause unpredictable behavior in your code."
                },
                {
                    "type": "p",
                    "text": "Do NOT write variance annotations unless they match the structural behavior of a type"
                },
                {
                    "type": "p",
                    "text": "Remember, TypeScript can automatically infer variance from your generic types.\nIt’s almost never necessary to write a variance annotation, and you should only do so when you’ve identified a specific need.\nVariance annotationsdo notchange the structural behavior of a type, and depending on the situation, you might see a structural comparison made when you expected an instantiation-based comparison.\nVariance annotations can’t be used to modify how types behave in these structural contexts, and shouldn’t be written unless the annotation is the same as the structural definition.\nBecause this is difficult to get right, and TypeScript can correctly infer variance in the vast majority of cases, you should not find yourself writing variance annotations in normal code."
                },
                {
                    "type": "p",
                    "text": "Don’t try to use variance annotations to change typechecking behavior; this is not what they are for"
                },
                {
                    "type": "p",
                    "text": "Youmayfind temporary variance annotations useful in a “type debugging” situation, because variance annotations are checked.\nTypeScript will issue an error if the annotated variance is identifiably wrong:"
                },
                {
                    "type": "code",
                    "code": "ts// Error, this interface is definitely contravariant on TinterfaceFoo<outT> {consume: (arg:T)=>void;}"
                },
                {
                    "type": "p",
                    "text": "However, variance annotations are allowed to be stricter (e.g.in outis valid if the actual variance is covariant).\nBe sure to remove your variance annotations once you’re done debugging."
                },
                {
                    "type": "p",
                    "text": "Lastly, if you’re trying to maximize your typechecking performance,andhave run a profiler,andhave identified a specific type that’s slow,andhave identified variance inference specifically is slow,andhave carefully validated the variance annotation you want to write, youmaysee a small performance benefit in extraordinarily complex types by adding variance annotations."
                },
                {
                    "type": "p",
                    "text": "Don’t try to use variance annotations to change typechecking behavior; this is not what they are for"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating Types from Types"
                },
                {
                    "type": "p",
                    "text": "An overview of the ways in which you can create more types from existing types."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Keyof Type Operator"
                },
                {
                    "type": "p",
                    "text": "Using the keyof operator in type contexts."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html",
            "title": "TypeScript: Documentation - Indexed Access Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Indexed Access Types"
                },
                {
                    "type": "p",
                    "text": "We can use anindexed access typeto look up a specific property on another type:"
                },
                {
                    "type": "code",
                    "code": "tstypePerson= {age:number;name:string;alive:boolean};typeAge=Person[\"age\"];type Age = numberTry"
                },
                {
                    "type": "p",
                    "text": "The indexing type is itself a type, so we can use unions,keyof, or other types entirely:"
                },
                {
                    "type": "code",
                    "code": "tstypeI1=Person[\"age\"|\"name\"];type I1 = string | numbertypeI2=Person[keyofPerson];type I2 = string | number | booleantypeAliveOrName=\"alive\"|\"name\";typeI3=Person[AliveOrName];type I3 = string | booleanTry"
                },
                {
                    "type": "p",
                    "text": "You’ll even see an error if you try to index a property that doesn’t exist:"
                },
                {
                    "type": "code",
                    "code": "tstypeI1=Person[\"alve\"];Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.Try"
                },
                {
                    "type": "p",
                    "text": "Another example of indexing with an arbitrary type is usingnumberto get the type of an array’s elements.\nWe can combine this withtypeofto conveniently capture the element type of an array literal:"
                },
                {
                    "type": "code",
                    "code": "tsconstMyArray= [{name:\"Alice\",age:15},{name:\"Bob\",age:23},{name:\"Eve\",age:38},];typePerson=typeofMyArray[number];type Person = {\n    name: string;\n    age: number;\n}typeAge=typeofMyArray[number][\"age\"];type Age = number// OrtypeAge2=Person[\"age\"];type Age2 = numberTry"
                },
                {
                    "type": "p",
                    "text": "You can only use types when indexing, meaning you can’t use aconstto make a variable reference:"
                },
                {
                    "type": "code",
                    "code": "tsconstkey=\"age\";typeAge=Person[key];Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?25382749Type 'key' cannot be used as an index type.'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?Try"
                },
                {
                    "type": "p",
                    "text": "However, you can use a type alias for a similar style of refactor:"
                },
                {
                    "type": "code",
                    "code": "tstypekey=\"age\";typeAge=Person[key];Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Typeof Type Operator"
                },
                {
                    "type": "p",
                    "text": "Using the typeof operator in type contexts."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditional Types"
                },
                {
                    "type": "p",
                    "text": "Create types which act like if statements in the type system."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html",
            "title": "TypeScript: Documentation - Keyof Type Operator",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Keyof Type Operator"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Thekeyoftype operator"
                },
                {
                    "type": "p",
                    "text": "Thekeyofoperator takes an object type and produces a string or numeric literal union of its keys.\nThe following typePis the same type astype P = \"x\" | \"y\":"
                },
                {
                    "type": "code",
                    "code": "tstypePoint= {x:number;y:number};typeP=keyofPoint;type P = keyof PointTry"
                },
                {
                    "type": "p",
                    "text": "If the type has astringornumberindex signature,keyofwill return those types instead:"
                },
                {
                    "type": "code",
                    "code": "tstypeArrayish= { [n:number]:unknown};typeA=keyofArrayish;type A = numbertypeMapish= { [k:string]:boolean};typeM=keyofMapish;type M = string | numberTry"
                },
                {
                    "type": "p",
                    "text": "Note that in this example,Misstring | number— this is because JavaScript object keys are always coerced to a string, soobj[0]is always the same asobj[\"0\"]."
                },
                {
                    "type": "p",
                    "text": "keyoftypes become especially useful when combined with mapped types, which we’ll learn more about later."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "Types which take parameters"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Typeof Type Operator"
                },
                {
                    "type": "p",
                    "text": "Using the typeof operator in type contexts."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html",
            "title": "TypeScript: Documentation - Mapped Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Mapped Types"
                },
                {
                    "type": "p",
                    "text": "When you don’t want to repeat yourself, sometimes a type needs to be based on another type."
                },
                {
                    "type": "p",
                    "text": "Mapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:"
                },
                {
                    "type": "code",
                    "code": "tstypeOnlyBoolsAndHorses= {[key:string]:boolean|Horse;};constconforms:OnlyBoolsAndHorses= {del:true,rodney:false,};Try"
                },
                {
                    "type": "p",
                    "text": "A mapped type is a generic type which uses a union ofPropertyKeys (frequently createdvia akeyof) to iterate through keys to create a type:"
                },
                {
                    "type": "code",
                    "code": "tstypeOptionsFlags<Type> = {[PropertyinkeyofType]:boolean;};Try"
                },
                {
                    "type": "p",
                    "text": "In this example,OptionsFlagswill take all the properties from the typeTypeand change their values to be a boolean."
                },
                {
                    "type": "code",
                    "code": "tstypeFeatures= {darkMode: ()=>void;newUserProfile: ()=>void;};typeFeatureOptions=OptionsFlags<Features>;type FeatureOptions = {\n    darkMode: boolean;\n    newUserProfile: boolean;\n}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Mapping Modifiers"
                },
                {
                    "type": "p",
                    "text": "There are two additional modifiers which can be applied during mapping:readonlyand?which affect mutability and optionality respectively."
                },
                {
                    "type": "p",
                    "text": "You can remove or add these modifiers by prefixing with-or+. If you don’t add a prefix, then+is assumed."
                },
                {
                    "type": "code",
                    "code": "ts// Removes 'readonly' attributes from a type's propertiestypeCreateMutable<Type> = {-readonly[PropertyinkeyofType]:Type[Property];};typeLockedAccount= {readonlyid:string;readonlyname:string;};typeUnlockedAccount=CreateMutable<LockedAccount>;type UnlockedAccount = {\n    id: string;\n    name: string;\n}Try"
                },
                {
                    "type": "code",
                    "code": "ts// Removes 'optional' attributes from a type's propertiestypeConcrete<Type> = {[PropertyinkeyofType]-?:Type[Property];};typeMaybeUser= {id:string;name?:string;age?:number;};typeUser=Concrete<MaybeUser>;type User = {\n    id: string;\n    name: string;\n    age: number;\n}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Key Remapping viaas"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 4.1 and onwards, you can re-map keys in mapped types with anasclause in a mapped type:"
                },
                {
                    "type": "code",
                    "code": "tstypeMappedTypeWithNewProperties<Type> = {[PropertiesinkeyofTypeasNewKeyType]:Type[Properties]}"
                },
                {
                    "type": "p",
                    "text": "You can leverage features liketemplate literal typesto create new property names from prior ones:"
                },
                {
                    "type": "code",
                    "code": "tstypeGetters<Type> = {[PropertyinkeyofTypeas`get${Capitalize<string&Property>}`]: ()=>Type[Property]};interfacePerson{name:string;age:number;location:string;}typeLazyPerson=Getters<Person>;type LazyPerson = {\n    getName: () => string;\n    getAge: () => number;\n    getLocation: () => string;\n}Try"
                },
                {
                    "type": "p",
                    "text": "You can filter out keys by producingnevervia a conditional type:"
                },
                {
                    "type": "code",
                    "code": "ts// Remove the 'kind' propertytypeRemoveKindField<Type> = {[PropertyinkeyofTypeasExclude<Property,\"kind\">]:Type[Property]};interfaceCircle{kind:\"circle\";radius:number;}typeKindlessCircle=RemoveKindField<Circle>;type KindlessCircle = {\n    radius: number;\n}Try"
                },
                {
                    "type": "p",
                    "text": "You can map over arbitrary unions, not just unions ofstring | number | symbol, but unions of any type:"
                },
                {
                    "type": "code",
                    "code": "tstypeEventConfig<Eventsextends{kind:string}> = {[EinEventsasE[\"kind\"]]: (event:E)=>void;}typeSquareEvent= {kind:\"square\",x:number,y:number};typeCircleEvent= {kind:\"circle\",radius:number};typeConfig=EventConfig<SquareEvent|CircleEvent>type Config = {\n    square: (event: SquareEvent) => void;\n    circle: (event: CircleEvent) => void;\n}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Further Exploration"
                },
                {
                    "type": "p",
                    "text": "Mapped types work well with other features in this type manipulation section, for example here isa mapped type using a conditional typewhich returns either atrueorfalsedepending on whether an object has the propertypiiset to the literaltrue:"
                },
                {
                    "type": "code",
                    "code": "tstypeExtractPII<Type> = {[PropertyinkeyofType]:Type[Property]extends{pii:true} ?true:false;};typeDBFields= {id: {format:\"incrementing\"};name: {type:string;pii:true};};typeObjectsNeedingGDPRDeletion=ExtractPII<DBFields>;type ObjectsNeedingGDPRDeletion = {\n    id: false;\n    name: true;\n}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditional Types"
                },
                {
                    "type": "p",
                    "text": "Create types which act like if statements in the type system."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Template Literal Types"
                },
                {
                    "type": "p",
                    "text": "Generating mapping types which change properties via template literal strings."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/modules.html",
            "title": "TypeScript: Documentation - Modules",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules"
                },
                {
                    "type": "p",
                    "text": "JavaScript has a long history of different ways to handle modularizing code.\r\nHaving been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as theimport/exportsyntax."
                },
                {
                    "type": "p",
                    "text": "ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes."
                },
                {
                    "type": "p",
                    "text": "For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJSmodule.exports =syntax, and you can find information about the other module patterns in the reference section underModules."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How JavaScript Modules are Defined"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, just as in ECMAScript 2015, any file containing a top-levelimportorexportis considered a module."
                },
                {
                    "type": "p",
                    "text": "Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well)."
                },
                {
                    "type": "p",
                    "text": "Modules are executed within their own scope, not in the global scope.\r\nThis means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms.\r\nConversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Non-modules"
                },
                {
                    "type": "p",
                    "text": "Before we start, it’s important to understand what TypeScript considers a module.\r\nThe JavaScript specification declares that any JavaScript files without animportdeclaration,export, or top-levelawaitshould be considered a script and not a module."
                },
                {
                    "type": "p",
                    "text": "Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use theoutFilecompiler option to join multiple input files into one output file, or use multiple<script>tags in your HTML to load these files (in the correct order!)."
                },
                {
                    "type": "p",
                    "text": "If you have a file that doesn’t currently have anyimports orexports, but you want to be treated as a module, add the line:"
                },
                {
                    "type": "code",
                    "code": "tsexport{};Try"
                },
                {
                    "type": "p",
                    "text": "which will change the file to be a module exporting nothing. This syntax works regardless of your module target."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Modules in TypeScript"
                },
                {
                    "type": "p",
                    "text": "Additional Reading:Impatient JS (Modules)MDN: JavaScript Modules"
                },
                {
                    "type": "p",
                    "text": "There are three main things to consider when writing module-based code in TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "Syntax: What syntax do I want to use to import and export things?",
                        "Module Resolution: What is the relationship between module names (or paths) and files on disk?",
                        "Module Output Target: What should my emitted JavaScript module look like?"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ES Module Syntax"
                },
                {
                    "type": "p",
                    "text": "A file can declare a main export viaexport default:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: hello.tsexportdefaultfunctionhelloWorld() {console.log(\"Hello, world!\");}Try"
                },
                {
                    "type": "p",
                    "text": "This is then imported via:"
                },
                {
                    "type": "code",
                    "code": "tsimporthelloWorldfrom\"./hello.js\";helloWorld();Try"
                },
                {
                    "type": "p",
                    "text": "In addition to the default export, you can have more than one export of variables and functions via theexportby omittingdefault:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: maths.tsexportvarpi=3.14;exportletsquareTwo=1.41;exportconstphi=1.61;exportclassRandomNumberGenerator{}exportfunctionabsolute(num:number) {if(num<0)returnnum* -1;returnnum;}Try"
                },
                {
                    "type": "p",
                    "text": "These can be used in another file via theimportsyntax:"
                },
                {
                    "type": "code",
                    "code": "tsimport{pi,phi,absolute}from\"./maths.js\";console.log(pi);constabsPhi=absolute(phi);const absPhi: numberTry"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Additional Import Syntax"
                },
                {
                    "type": "p",
                    "text": "An import can be renamed using a format likeimport {old as new}:"
                },
                {
                    "type": "code",
                    "code": "tsimport{piasπ}from\"./maths.js\";console.log(π);(alias) var π: number\nimport πTry"
                },
                {
                    "type": "p",
                    "text": "You can mix and match the above syntax into a singleimport:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: maths.tsexportconstpi=3.14;exportdefaultclassRandomNumberGenerator{}// @filename: app.tsimportRandomNumberGenerator, {piasπ}from\"./maths.js\";RandomNumberGenerator;(alias) class RandomNumberGenerator\nimport RandomNumberGeneratorconsole.log(π);(alias) const π: 3.14\nimport πTry"
                },
                {
                    "type": "p",
                    "text": "You can take all of the exported objects and put them into a single namespace using* as name:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: app.tsimport*asmathfrom\"./maths.js\";console.log(math.pi);constpositivePhi=math.absolute(math.phi);const positivePhi: numberTry"
                },
                {
                    "type": "p",
                    "text": "You can import a file andnotinclude any variables into your current module viaimport \"./file\":"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: app.tsimport\"./maths.js\";console.log(\"3.14\");Try"
                },
                {
                    "type": "p",
                    "text": "In this case, theimportdoes nothing. However, all of the code inmaths.tswas evaluated, which could trigger side-effects which affect other objects."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "TypeScript Specific ES Module Syntax"
                },
                {
                    "type": "p",
                    "text": "Types can be exported and imported using the same syntax as JavaScript values:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: animal.tsexporttypeCat= {breed:string;yearOfBirth:number};exportinterfaceDog{breeds:string[];yearOfBirth:number;}// @filename: app.tsimport{Cat,Dog}from\"./animal.js\";typeAnimals=Cat|Dog;Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript has extended theimportsyntax with two concepts for declaring an import of a type:"
                },
                {
                    "type": "header",
                    "level": 6,
                    "text": "import type"
                },
                {
                    "type": "p",
                    "text": "Which is an import statement which canonlyimport types:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: animal.tsexporttypeCat= {breed:string;yearOfBirth:number};exporttypeDog= {breeds:string[];yearOfBirth:number};exportconstcreateCatName= ()=>\"fluffy\";// @filename: valid.tsimporttype{Cat,Dog}from\"./animal.js\";exporttypeAnimals=Cat|Dog;// @filename: app.tsimporttype{createCatName}from\"./animal.js\";constname=createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.Try"
                },
                {
                    "type": "header",
                    "level": 6,
                    "text": "Inlinetypeimports"
                },
                {
                    "type": "p",
                    "text": "TypeScript 4.5 also allows for individual imports to be prefixed withtypeto indicate that the imported reference is a type:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: app.tsimport{createCatName,typeCat,typeDog}from\"./animal.js\";exporttypeAnimals=Cat|Dog;constname=createCatName();Try"
                },
                {
                    "type": "p",
                    "text": "Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "ES Module Syntax with CommonJS Behavior"
                },
                {
                    "type": "p",
                    "text": "TypeScript has ES Module syntax whichdirectlycorrelates to a CommonJS and AMDrequire. Imports using ES Module arefor most casesthe same as therequirefrom those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:"
                },
                {
                    "type": "code",
                    "code": "tsimportfs=require(\"fs\");constcode=fs.readFileSync(\"hello.ts\",\"utf8\");Try"
                },
                {
                    "type": "p",
                    "text": "You can learn more about this syntax in themodules reference page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "CommonJS Syntax"
                },
                {
                    "type": "p",
                    "text": "CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Exporting"
                },
                {
                    "type": "p",
                    "text": "Identifiers are exported via setting theexportsproperty on a global calledmodule."
                },
                {
                    "type": "code",
                    "code": "tsfunctionabsolute(num:number) {if(num<0)returnnum* -1;returnnum;}module.exports= {pi:3.14,squareTwo:1.41,phi:1.61,absolute,};Try"
                },
                {
                    "type": "p",
                    "text": "Then these files can be imported via arequirestatement:"
                },
                {
                    "type": "code",
                    "code": "tsconstmaths=require(\"./maths\");maths.pi;anyTry"
                },
                {
                    "type": "p",
                    "text": "Or you can simplify a bit using the destructuring feature in JavaScript:"
                },
                {
                    "type": "code",
                    "code": "tsconst{squareTwo} =require(\"./maths\");squareTwo;const squareTwo: anyTry"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "CommonJS and ES Modules interop"
                },
                {
                    "type": "p",
                    "text": "There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints withesModuleInterop."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript’s Module Resolution Options"
                },
                {
                    "type": "p",
                    "text": "Module resolution is the process of taking a string from theimportorrequirestatement, and determining what file that string refers to."
                },
                {
                    "type": "p",
                    "text": "TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler optionmoduleis notcommonjs, is included for backwards compatibility.\r\nThe Node strategy replicates how Node.js works in CommonJS mode, with additional checks for.tsand.d.ts."
                },
                {
                    "type": "p",
                    "text": "There are many TSConfig flags which influence the module strategy within TypeScript:moduleResolution,baseUrl,paths,rootDirs."
                },
                {
                    "type": "p",
                    "text": "For the full details on how these strategies work, you can consult theModule Resolutionreference page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript’s Module Output Options"
                },
                {
                    "type": "p",
                    "text": "There are two options which affect the emitted JavaScript output:"
                },
                {
                    "type": "list",
                    "items": [
                        "targetwhich determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact",
                        "modulewhich determines what code is used for modules to interact with each other"
                    ]
                },
                {
                    "type": "p",
                    "text": "Whichtargetyou use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example."
                },
                {
                    "type": "p",
                    "text": "All communication between modules happens via a module loader, the compiler optionmoduledetermines which one is used.\r\nAt runtime the module loader is responsible for locating and executing all dependencies of a module before executing it."
                },
                {
                    "type": "p",
                    "text": "For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options formodule:"
                },
                {
                    "type": "code",
                    "code": "tsimport{valueOfPi}from\"./constants.js\";exportconsttwoPi=valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "ES2020"
                },
                {
                    "type": "code",
                    "code": "tsimport{valueOfPi}from\"./constants.js\";exportconsttwoPi=valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "CommonJS"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;constconstants_js_1=require(\"./constants.js\");exports.twoPi=constants_js_1.valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "UMD"
                },
                {
                    "type": "code",
                    "code": "ts(function(factory) {if(typeofmodule===\"object\"&&typeofmodule.exports===\"object\") {varv=factory(require,exports);if(v!==undefined)module.exports=v;}elseif(typeofdefine===\"function\"&&define.amd) {define([\"require\",\"exports\",\"./constants.js\"],factory);}})(function(require,exports) {\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;constconstants_js_1=require(\"./constants.js\");exports.twoPi=constants_js_1.valueOfPi*2;});Try"
                },
                {
                    "type": "p",
                    "text": "Note that ES2020 is effectively the same as the originalindex.ts."
                },
                {
                    "type": "p",
                    "text": "You can see all of the available options and what their emitted JavaScript code looks like in theTSConfig Reference formodule."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript namespaces"
                },
                {
                    "type": "p",
                    "text": "TypeScript has its own module format callednamespaceswhich pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active usein DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces inthe namespaces reference page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "How classes work in TypeScript"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html",
            "title": "TypeScript: Documentation - Narrowing",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Narrowing"
                },
                {
                    "type": "p",
                    "text": "Imagine we have a function calledpadLeft."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpadLeft(padding:number|string,input:string):string{thrownewError(\"Not implemented yet!\");}Try"
                },
                {
                    "type": "p",
                    "text": "Ifpaddingis anumber, it will treat that as the number of spaces we want to prepend toinput.\nIfpaddingis astring, it should just prependpaddingtoinput.\nLet’s try to implement the logic for whenpadLeftis passed anumberforpadding."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpadLeft(padding:number|string,input:string):string{return\" \".repeat(padding) +input;Argument of type 'string | number' is not assignable to parameter of type 'number'.\n  Type 'string' is not assignable to type 'number'.2345Argument of type 'string | number' is not assignable to parameter of type 'number'.\n  Type 'string' is not assignable to type 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "Uh-oh, we’re getting an error onpadding.\nTypeScript is warning us that we’re passing a value with typenumber | stringto therepeatfunction, which only accepts anumber, and it’s right.\nIn other words, we haven’t explicitly checked ifpaddingis anumberfirst, nor are we handling the case where it’s astring, so let’s do exactly that."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpadLeft(padding:number|string,input:string):string{if(typeofpadding===\"number\") {return\" \".repeat(padding) +input;}returnpadding+input;}Try"
                },
                {
                    "type": "p",
                    "text": "If this mostly looks like uninteresting JavaScript code, that’s sort of the point.\nApart from the annotations we put in place, this TypeScript code looks like JavaScript.\nThe idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety."
                },
                {
                    "type": "p",
                    "text": "While it might not look like much, there’s actually a lot going on under the covers here.\nMuch like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs likeif/else, conditional ternaries, loops, truthiness checks, etc., which can all affect those types."
                },
                {
                    "type": "p",
                    "text": "Within ourifcheck, TypeScript seestypeof padding === \"number\"and understands that as a special form of code called atype guard.\nTypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position.\nIt looks at these special checks (calledtype guards) and assignments, and the process of refining types to more specific types than declared is callednarrowing.\nIn many editors we can observe these types as they change, and we’ll even do so in our examples."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpadLeft(padding:number|string,input:string):string{if(typeofpadding===\"number\") {return\" \".repeat(padding) +input;(parameter) padding: number}returnpadding+input;(parameter) padding: string}Try"
                },
                {
                    "type": "p",
                    "text": "There are a couple of different constructs TypeScript understands for narrowing."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "typeoftype guards"
                },
                {
                    "type": "p",
                    "text": "As we’ve seen, JavaScript supports atypeofoperator which can give very basic information about the type of values we have at runtime.\nTypeScript expects this to return a certain set of strings:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"string\"",
                        "\"number\"",
                        "\"bigint\"",
                        "\"boolean\"",
                        "\"symbol\"",
                        "\"undefined\"",
                        "\"object\"",
                        "\"function\""
                    ]
                },
                {
                    "type": "p",
                    "text": "Like we saw withpadLeft, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, checking against the value returned bytypeofis a type guard.\nBecause TypeScript encodes howtypeofoperates on different values, it knows about some of its quirks in JavaScript.\nFor example, notice that in the list above,typeofdoesn’t return the stringnull.\nCheck out the following example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintAll(strs:string|string[] |null) {if(typeofstrs===\"object\") {for(constsofstrs) {'strs' is possibly 'null'.18047'strs' is possibly 'null'.console.log(s);}}elseif(typeofstrs===\"string\") {console.log(strs);}else{// do nothing}}Try"
                },
                {
                    "type": "p",
                    "text": "In theprintAllfunction, we try to check ifstrsis an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript).\nBut it turns out that in JavaScript,typeof nullis actually\"object\"!\nThis is one of those unfortunate accidents of history."
                },
                {
                    "type": "p",
                    "text": "Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know thatstrswas only narrowed down tostring[] | nullinstead of juststring[]."
                },
                {
                    "type": "p",
                    "text": "This might be a good segue into what we’ll call “truthiness” checking."
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Truthiness narrowing"
                },
                {
                    "type": "p",
                    "text": "Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript."
                },
                {
                    "type": "p",
                    "text": "In JavaScript, we can use any expression in conditionals,&&s,||s,ifstatements, Boolean negations (!), and more.\nAs an example,ifstatements don’t expect their condition to always have the typeboolean."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetUsersOnlineMessage(numUsersOnline:number) {if(numUsersOnline) {return`There are${numUsersOnline}online now!`;}return\"Nobody's here. :(\";}Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, constructs likeiffirst “coerce” their conditions tobooleans to make sense of them, and then choose their branches depending on whether the result istrueorfalse.\nValues like"
                },
                {
                    "type": "list",
                    "items": [
                        "0",
                        "NaN",
                        "\"\"(the empty string)",
                        "0n(thebigintversion of zero)",
                        "null",
                        "undefined"
                    ]
                },
                {
                    "type": "p",
                    "text": "all coerce tofalse, and other values get coerced totrue.\nYou can always coerce values tobooleans by running them through theBooleanfunction, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean typetrue, while inferring the first as typeboolean.)"
                },
                {
                    "type": "code",
                    "code": "ts// both of these result in 'true'Boolean(\"hello\");// type: boolean, value: true!!\"world\";// type: true,    value: trueThis kind of expression is always truthy.2872This kind of expression is always truthy.Try"
                },
                {
                    "type": "p",
                    "text": "It’s fairly popular to leverage this behavior, especially for guarding against values likenullorundefined.\nAs an example, let’s try using it for ourprintAllfunction."
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintAll(strs:string|string[] |null) {if(strs&&typeofstrs===\"object\") {for(constsofstrs) {console.log(s);}}elseif(typeofstrs===\"string\") {console.log(strs);}}Try"
                },
                {
                    "type": "p",
                    "text": "You’ll notice that we’ve gotten rid of the error above by checking ifstrsis truthy.\nThis at least prevents us from dreaded errors when we run our code like:"
                },
                {
                    "type": "code",
                    "code": "txtTypeError: null is not iterable"
                },
                {
                    "type": "p",
                    "text": "Keep in mind though that truthiness checking on primitives can often be error prone.\nAs an example, consider a different attempt at writingprintAll"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintAll(strs:string|string[] |null) {// !!!!!!!!!!!!!!!!//  DON'T DO THIS!//   KEEP READING// !!!!!!!!!!!!!!!!if(strs) {if(typeofstrs===\"object\") {for(constsofstrs) {console.log(s);}}elseif(typeofstrs===\"string\") {console.log(strs);}}}Try"
                },
                {
                    "type": "p",
                    "text": "We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly."
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript.\nTypeScript can often help you catch bugs early on, but if you choose to donothingwith a value, there’s only so much that it can do without being overly prescriptive.\nIf you want, you can make sure you handle situations like these with a linter."
                },
                {
                    "type": "p",
                    "text": "One last word on narrowing by truthiness is that Boolean negations with!filter out from negated branches."
                },
                {
                    "type": "code",
                    "code": "tsfunctionmultiplyAll(values:number[] |undefined,factor:number):number[] |undefined{if(!values) {returnvalues;}else{returnvalues.map((x)=>x*factor);}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Equality narrowing"
                },
                {
                    "type": "p",
                    "text": "TypeScript also usesswitchstatements and equality checks like===,!==,==, and!=to narrow types.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionexample(x:string|number,y:string|boolean) {if(x===y) {// We can now call any 'string' method on 'x' or 'y'.x.toUpperCase();(method) String.toUpperCase(): stringy.toLowerCase();(method) String.toLowerCase(): string}else{console.log(x);(parameter) x: string | numberconsole.log(y);(parameter) y: string | boolean}}Try"
                },
                {
                    "type": "p",
                    "text": "When we checked thatxandyare both equal in the above example, TypeScript knew their types also had to be equal.\nSincestringis the only common type that bothxandycould take on, TypeScript knows thatxandymust bestrings in the first branch."
                },
                {
                    "type": "p",
                    "text": "Checking against specific literal values (as opposed to variables) works also.\nIn our section about truthiness narrowing, we wrote aprintAllfunction which was error-prone because it accidentally didn’t handle empty strings properly.\nInstead we could have done a specific check to block outnulls, and TypeScript still correctly removesnullfrom the type ofstrs."
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintAll(strs:string|string[] |null) {if(strs!==null) {if(typeofstrs===\"object\") {for(constsofstrs) {(parameter) strs: string[]console.log(s);}}elseif(typeofstrs===\"string\") {console.log(strs);(parameter) strs: string}}}Try"
                },
                {
                    "type": "p",
                    "text": "JavaScript’s looser equality checks with==and!=also get narrowed correctly.\nIf you’re unfamiliar, checking whether something== nullactually not only checks whether it is specifically the valuenull- it also checks whether it’s potentiallyundefined.\nThe same applies to== undefined: it checks whether a value is eithernullorundefined."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceContainer{value:number|null|undefined;}functionmultiplyValue(container:Container,factor:number) {// Remove both 'null' and 'undefined' from the type.if(container.value!=null) {console.log(container.value);(property) Container.value: number// Now we can safely multiply 'container.value'.container.value*=factor;}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Theinoperator narrowing"
                },
                {
                    "type": "p",
                    "text": "JavaScript has an operator for determining if an object or its prototype chain has a property with a name: theinoperator.\nTypeScript takes this into account as a way to narrow down potential types."
                },
                {
                    "type": "p",
                    "text": "For example, with the code:\"value\" in x. where\"value\"is a string literal andxis a union type.\nThe “true” branch narrowsx’s types which have either an optional or required propertyvalue, and the “false” branch narrows to types which have an optional or missing propertyvalue."
                },
                {
                    "type": "code",
                    "code": "tstypeFish= {swim: ()=>void};typeBird= {fly: ()=>void};functionmove(animal:Fish|Bird) {if(\"swim\"inanimal) {returnanimal.swim();}returnanimal.fly();}Try"
                },
                {
                    "type": "p",
                    "text": "To reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of theincheck:"
                },
                {
                    "type": "code",
                    "code": "tstypeFish= {swim: ()=>void};typeBird= {fly: ()=>void};typeHuman= {swim?: ()=>void;fly?: ()=>void};functionmove(animal:Fish|Bird|Human) {if(\"swim\"inanimal) {animal;(parameter) animal: Fish | Human}else{animal;(parameter) animal: Bird | Human}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "instanceofnarrowing"
                },
                {
                    "type": "p",
                    "text": "JavaScript has an operator for checking whether or not a value is an “instance” of another value.\nMore specifically, in JavaScriptx instanceof Foochecks whether theprototype chainofxcontainsFoo.prototype.\nWhile we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed withnew.\nAs you might have guessed,instanceofis also a type guard, and TypeScript narrows in branches guarded byinstanceofs."
                },
                {
                    "type": "code",
                    "code": "tsfunctionlogValue(x:Date|string) {if(xinstanceofDate) {console.log(x.toUTCString());(parameter) x: Date}else{console.log(x.toUpperCase());(parameter) x: string}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Assignments"
                },
                {
                    "type": "p",
                    "text": "As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately."
                },
                {
                    "type": "code",
                    "code": "tsletx=Math.random() <0.5?10:\"hello world!\";let x: string | numberx=1;console.log(x);let x: numberx=\"goodbye!\";console.log(x);let x: stringTry"
                },
                {
                    "type": "p",
                    "text": "Notice that each of these assignments is valid.\nEven though the observed type ofxchanged tonumberafter our first assignment, we were still able to assign astringtox.\nThis is because thedeclared typeofx- the type thatxstarted with - isstring | number, and assignability is always checked against the declared type."
                },
                {
                    "type": "p",
                    "text": "If we’d assigned abooleantox, we’d have seen an error since that wasn’t part of the declared type."
                },
                {
                    "type": "code",
                    "code": "tsletx=Math.random() <0.5?10:\"hello world!\";let x: string | numberx=1;console.log(x);let x: numberx=true;Type 'boolean' is not assignable to type 'string | number'.2322Type 'boolean' is not assignable to type 'string | number'.console.log(x);let x: string | numberTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Control flow analysis"
                },
                {
                    "type": "p",
                    "text": "Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches.\nBut there’s a bit more going on than just walking up from every variable and looking for type guards inifs,whiles, conditionals, etc.\nFor example"
                },
                {
                    "type": "code",
                    "code": "tsfunctionpadLeft(padding:number|string,input:string) {if(typeofpadding===\"number\") {return\" \".repeat(padding) +input;}returnpadding+input;}Try"
                },
                {
                    "type": "p",
                    "text": "padLeftreturns from within its firstifblock.\nTypeScript was able to analyze this code and see that the rest of the body (return padding + input;) isunreachablein the case wherepaddingis anumber.\nAs a result, it was able to removenumberfrom the type ofpadding(narrowing fromstring | numbertostring) for the rest of the function."
                },
                {
                    "type": "p",
                    "text": "This analysis of code based on reachability is calledcontrol flow analysis, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments.\nWhen a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point."
                },
                {
                    "type": "code",
                    "code": "tsfunctionexample() {letx:string|number|boolean;x=Math.random() <0.5;console.log(x);let x: booleanif(Math.random() <0.5) {x=\"hello\";console.log(x);let x: string}else{x=100;console.log(x);let x: number}returnx;let x: string | number}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using type predicates"
                },
                {
                    "type": "p",
                    "text": "We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code."
                },
                {
                    "type": "p",
                    "text": "To define a user-defined type guard, we simply need to define a function whose return type is atype predicate:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionisFish(pet:Fish|Bird):petisFish{return(petasFish).swim!==undefined;}Try"
                },
                {
                    "type": "p",
                    "text": "pet is Fishis our type predicate in this example.\nA predicate takes the formparameterName is Type, whereparameterNamemust be the name of a parameter from the current function signature."
                },
                {
                    "type": "p",
                    "text": "Any timeisFishis called with some variable, TypeScript willnarrowthat variable to that specific type if the original type is compatible."
                },
                {
                    "type": "code",
                    "code": "ts// Both calls to 'swim' and 'fly' are now okay.letpet=getSmallPet();if(isFish(pet)) {pet.swim();}else{pet.fly();}Try"
                },
                {
                    "type": "p",
                    "text": "Notice that TypeScript not only knows thatpetis aFishin theifbranch;\nit also knows that in theelsebranch, youdon’thave aFish, so you must have aBird."
                },
                {
                    "type": "p",
                    "text": "You may use the type guardisFishto filter an array ofFish | Birdand obtain an array ofFish:"
                },
                {
                    "type": "code",
                    "code": "tsconstzoo: (Fish|Bird)[] = [getSmallPet(),getSmallPet(),getSmallPet()];constunderWater1:Fish[] =zoo.filter(isFish);// or, equivalentlyconstunderWater2:Fish[] =zoo.filter(isFish)asFish[];// The predicate may need repeating for more complex examplesconstunderWater3:Fish[] =zoo.filter((pet):petisFish=>{if(pet.name===\"sharkey\")returnfalse;returnisFish(pet);});Try"
                },
                {
                    "type": "p",
                    "text": "In addition, classes canusethis is Typeto narrow their type."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Assertion functions"
                },
                {
                    "type": "p",
                    "text": "Types can also be narrowed usingAssertion functions."
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Discriminated unions"
                },
                {
                    "type": "p",
                    "text": "Most of the examples we’ve looked at so far have focused around narrowing single variables with simple types likestring,boolean, andnumber.\nWhile this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures."
                },
                {
                    "type": "p",
                    "text": "For some motivation, let’s imagine we’re trying to encode shapes like circles and squares.\nCircles keep track of their radiuses and squares keep track of their side lengths.\nWe’ll use a field calledkindto tell which shape we’re dealing with.\nHere’s a first attempt at definingShape."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceShape{kind:\"circle\"|\"square\";radius?:number;sideLength?:number;}Try"
                },
                {
                    "type": "p",
                    "text": "Notice we’re using a union of string literal types:\"circle\"and\"square\"to tell us whether we should treat the shape as a circle or square respectively.\nBy using\"circle\" | \"square\"instead ofstring, we can avoid misspelling issues."
                },
                {
                    "type": "code",
                    "code": "tsfunctionhandleShape(shape:Shape) {// oops!if(shape.kind===\"rect\") {This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.2367This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.// ...}}Try"
                },
                {
                    "type": "p",
                    "text": "We can write agetAreafunction that applies the right logic based on if it’s dealing with a circle or square.\nWe’ll first try dealing with circles."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {returnMath.PI*shape.radius**2;'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.}Try"
                },
                {
                    "type": "p",
                    "text": "UnderstrictNullChecksthat gives us an error - which is appropriate sinceradiusmight not be defined.\nBut what if we perform the appropriate checks on thekindproperty?"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {if(shape.kind===\"circle\") {returnMath.PI*shape.radius**2;'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.}}Try"
                },
                {
                    "type": "p",
                    "text": "Hmm, TypeScript still doesn’t know what to do here.\nWe’ve hit a point where we know more about our values than the type checker does.\nWe could try to use a non-null assertion (a!aftershape.radius) to say thatradiusis definitely present."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {if(shape.kind===\"circle\") {returnMath.PI*shape.radius! **2;}}Try"
                },
                {
                    "type": "p",
                    "text": "But this doesn’t feel ideal.\nWe had to shout a bit at the type-checker with those non-null assertions (!) to convince it thatshape.radiuswas defined, but those assertions are error-prone if we start to move code around.\nAdditionally, outside ofstrictNullCheckswe’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them).\nWe can definitely do better."
                },
                {
                    "type": "p",
                    "text": "The problem with this encoding ofShapeis that the type-checker doesn’t have any way to know whether or notradiusorsideLengthare present based on thekindproperty.\nWe need to communicate whatweknow to the type checker.\nWith that in mind, let’s take another swing at definingShape."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCircle{kind:\"circle\";radius:number;}interfaceSquare{kind:\"square\";sideLength:number;}typeShape=Circle|Square;Try"
                },
                {
                    "type": "p",
                    "text": "Here, we’ve properly separatedShapeout into two types with different values for thekindproperty, butradiusandsideLengthare declared as required properties in their respective types."
                },
                {
                    "type": "p",
                    "text": "Let’s see what happens here when we try to access theradiusof aShape."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {returnMath.PI*shape.radius**2;Property 'radius' does not exist on type 'Shape'.\n  Property 'radius' does not exist on type 'Square'.2339Property 'radius' does not exist on type 'Shape'.\n  Property 'radius' does not exist on type 'Square'.}Try"
                },
                {
                    "type": "p",
                    "text": "Like with our first definition ofShape, this is still an error.\nWhenradiuswas optional, we got an error (withstrictNullChecksenabled) because TypeScript couldn’t tell whether the property was present.\nNow thatShapeis a union, TypeScript is telling us thatshapemight be aSquare, andSquares don’t haveradiusdefined on them!\nBoth interpretations are correct, but only the union encoding ofShapewill cause an error regardless of howstrictNullChecksis configured."
                },
                {
                    "type": "p",
                    "text": "But what if we tried checking thekindproperty again?"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {if(shape.kind===\"circle\") {returnMath.PI*shape.radius**2;(parameter) shape: Circle}}Try"
                },
                {
                    "type": "p",
                    "text": "That got rid of the error!\nWhen every type in a union contains a common property with literal types, TypeScript considers that to be adiscriminated union, and can narrow out the members of the union."
                },
                {
                    "type": "p",
                    "text": "In this case,kindwas that common property (which is what’s considered adiscriminantproperty ofShape).\nChecking whether thekindproperty was\"circle\"got rid of every type inShapethat didn’t have akindproperty with the type\"circle\".\nThat narrowedshapedown to the typeCircle."
                },
                {
                    "type": "p",
                    "text": "The same checking works withswitchstatements as well.\nNow we can try to write our completegetAreawithout any pesky!non-null assertions."
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetArea(shape:Shape) {switch(shape.kind) {case\"circle\":returnMath.PI*shape.radius**2;(parameter) shape: Circlecase\"square\":returnshape.sideLength**2;(parameter) shape: Square}}Try"
                },
                {
                    "type": "p",
                    "text": "The important thing here was the encoding ofShape.\nCommunicating the right information to TypeScript - thatCircleandSquarewere really two separate types with specifickindfields - was crucial.\nDoing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise.\nFrom there, the type system was able to do the “right” thing and figure out the types in each branch of ourswitchstatement."
                },
                {
                    "type": "p",
                    "text": "As an aside, try playing around with the above example and remove some of the return keywords.\nYou’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in aswitchstatement."
                },
                {
                    "type": "p",
                    "text": "Discriminated unions are useful for more than just talking about circles and squares.\nThey’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework."
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Thenevertype"
                },
                {
                    "type": "p",
                    "text": "When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left.\nIn those cases, TypeScript will use anevertype to represent a state which shouldn’t exist."
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Exhaustiveness checking"
                },
                {
                    "type": "p",
                    "text": "Thenevertype is assignable to every type; however, no type is assignable tonever(exceptneveritself). This means you can use narrowing and rely onneverturning up to do exhaustive checking in aswitchstatement."
                },
                {
                    "type": "p",
                    "text": "For example, adding adefaultto ourgetAreafunction which tries to assign the shape toneverwill not raise an error when every possible case has been handled."
                },
                {
                    "type": "code",
                    "code": "tstypeShape=Circle|Square;functiongetArea(shape:Shape) {switch(shape.kind) {case\"circle\":returnMath.PI*shape.radius**2;case\"square\":returnshape.sideLength**2;default:const_exhaustiveCheck:never=shape;return_exhaustiveCheck;}}Try"
                },
                {
                    "type": "p",
                    "text": "Adding a new member to theShapeunion, will cause a TypeScript error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTriangle{kind:\"triangle\";sideLength:number;}typeShape=Circle|Square|Triangle;functiongetArea(shape:Shape) {switch(shape.kind) {case\"circle\":returnMath.PI*shape.radius**2;case\"square\":returnshape.sideLength**2;default:const_exhaustiveCheck:never=shape;Type 'Triangle' is not assignable to type 'never'.2322Type 'Triangle' is not assignable to type 'never'.return_exhaustiveCheck;}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Everyday Types"
                },
                {
                    "type": "p",
                    "text": "The language primitives."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "More on Functions"
                },
                {
                    "type": "p",
                    "text": "Learn about how Functions work in TypeScript."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
            "title": "TypeScript: Documentation - Object Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Object Types"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, the fundamental way that we group and pass around data is through objects.\nIn TypeScript, we represent those throughobject types."
                },
                {
                    "type": "p",
                    "text": "As we’ve seen, they can be anonymous:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreet(person: {name:string;age:number}) {return\"Hello \"+person.name;}Try"
                },
                {
                    "type": "p",
                    "text": "or they can be named by using either an interface:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson{name:string;age:number;}functiongreet(person:Person) {return\"Hello \"+person.name;}Try"
                },
                {
                    "type": "p",
                    "text": "or a type alias:"
                },
                {
                    "type": "code",
                    "code": "tstypePerson= {name:string;age:number;};functiongreet(person:Person) {return\"Hello \"+person.name;}Try"
                },
                {
                    "type": "p",
                    "text": "In all three examples above, we’ve written functions that take objects that contain the propertyname(which must be astring) andage(which must be anumber)."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Quick Reference"
                },
                {
                    "type": "p",
                    "text": "We have cheat-sheets available for bothtypeandinterface, if you want a quick look at the important every-day syntax at a glance."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Property Modifiers"
                },
                {
                    "type": "p",
                    "text": "Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Properties"
                },
                {
                    "type": "p",
                    "text": "Much of the time, we’ll find ourselves dealing with objects thatmighthave a property set.\nIn those cases, we can mark those properties asoptionalby adding a question mark (?) to the end of their names."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePaintOptions{shape:Shape;xPos?:number;yPos?:number;}functionpaintShape(opts:PaintOptions) {// ...}constshape=getShape();paintShape({shape});paintShape({shape,xPos:100});paintShape({shape,yPos:100});paintShape({shape,xPos:100,yPos:100});Try"
                },
                {
                    "type": "p",
                    "text": "In this example, bothxPosandyPosare considered optional.\nWe can choose to provide either of them, so every call above topaintShapeis valid.\nAll optionality really says is that if the propertyisset, it better have a specific type."
                },
                {
                    "type": "p",
                    "text": "We can also read from those properties - but when we do understrictNullChecks, TypeScript will tell us they’re potentiallyundefined."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpaintShape(opts:PaintOptions) {letxPos=opts.xPos;(property) PaintOptions.xPos?: number | undefinedletyPos=opts.yPos;(property) PaintOptions.yPos?: number | undefined// ...}Try"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the valueundefined.\nWe can just handleundefinedspecially by checking for it."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpaintShape(opts:PaintOptions) {letxPos=opts.xPos===undefined?0:opts.xPos;let xPos: numberletyPos=opts.yPos===undefined?0:opts.yPos;let yPos: number// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it."
                },
                {
                    "type": "code",
                    "code": "tsfunctionpaintShape({shape,xPos=0,yPos=0}:PaintOptions) {console.log(\"x coordinate at\",xPos);(parameter) xPos: numberconsole.log(\"y coordinate at\",yPos);(parameter) yPos: number// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Here we useda destructuring patternforpaintShape’s parameter, and provideddefault valuesforxPosandyPos.\nNowxPosandyPosare both definitely present within the body ofpaintShape, but optional for any callers topaintShape."
                },
                {
                    "type": "p",
                    "text": "Note that there is currently no way to place type annotations within destructuring patterns.\nThis is because the following syntax already means something different in JavaScript."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondraw({shape:Shape,xPos:number=100/*...*/}) {render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try"
                },
                {
                    "type": "p",
                    "text": "In an object destructuring pattern,shape: Shapemeans “grab the propertyshapeand redefine it locally as a variable namedShape.”\nLikewisexPos: numbercreates a variable namednumberwhose value is based on the parameter’sxPos."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "readonlyProperties"
                },
                {
                    "type": "p",
                    "text": "Properties can also be marked asreadonlyfor TypeScript.\nWhile it won’t change any behavior at runtime, a property marked asreadonlycan’t be written to during type-checking."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSomeType{readonlyprop:string;}functiondoSomething(obj:SomeType) {// We can read from 'obj.prop'.console.log(`prop has the value '${obj.prop}'.`);// But we can't re-assign it.obj.prop=\"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try"
                },
                {
                    "type": "p",
                    "text": "Using thereadonlymodifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed.\nIt just means the property itself can’t be re-written to."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceHome{readonlyresident: {name:string;age:number};}functionvisitForBirthday(home:Home) {// We can read and update properties from 'home.resident'.console.log(`Happy birthday${home.resident.name}!`);home.resident.age++;}functionevict(home:Home) {// But we can't write to the 'resident' property itself on a 'Home'.home.resident= {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.name:\"Victor the Evictor\",age:42,};}Try"
                },
                {
                    "type": "p",
                    "text": "It’s important to manage expectations of whatreadonlyimplies.\nIt’s useful to signal intent during development time for TypeScript on how an object should be used.\nTypeScript doesn’t factor in whether properties on two types arereadonlywhen checking whether those types are compatible, soreadonlyproperties can also change via aliasing."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson{name:string;age:number;}interfaceReadonlyPerson{readonlyname:string;readonlyage:number;}letwritablePerson:Person= {name:\"Person McPersonface\",age:42,};// worksletreadonlyPerson:ReadonlyPerson=writablePerson;console.log(readonlyPerson.age);// prints '42'writablePerson.age++;console.log(readonlyPerson.age);// prints '43'Try"
                },
                {
                    "type": "p",
                    "text": "Usingmapping modifiers, you can removereadonlyattributes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Index Signatures"
                },
                {
                    "type": "p",
                    "text": "Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values."
                },
                {
                    "type": "p",
                    "text": "In those cases you can use an index signature to describe the types of possible values, for example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringArray{[index:number]:string;}constmyArray:StringArray=getStringArray();constsecondItem=myArray[1];const secondItem: stringTry"
                },
                {
                    "type": "p",
                    "text": "Above, we have aStringArrayinterface which has an index signature.\nThis index signature states that when aStringArrayis indexed with anumber, it will return astring."
                },
                {
                    "type": "p",
                    "text": "Only some types are allowed for index signature properties:string,number,symbol, template string patterns, and union types consisting only of these."
                },
                {
                    "type": "p",
                    "text": "It is possible to support multiple types of indexers. Note that when using both `number` and `string` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with anumber, JavaScript will actually convert that to astringbefore indexing into an object. That means that indexing with100(anumber) is the same thing as indexing with\"100\"(astring), so the two need to be consistent."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimal{name:string;}interfaceDogextendsAnimal{breed:string;}// Error: indexing with a numeric string might get you a completely separate type of Animal!interfaceNotOkay{[x:number]:Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.[x:string]:Dog;}Try"
                },
                {
                    "type": "p",
                    "text": "While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type.\nThis is because a string index declares thatobj.propertyis also available asobj[\"property\"].\nIn the following example,name’s type does not match the string index’s type, and the type checker gives an error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberDictionary{[index:string]:number;length:number;// okname:string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "However, properties of different types are acceptable if the index signature is a union of the property types:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberOrStringDictionary{[index:string]:number|string;length:number;// ok, length is a numbername:string;// ok, name is a string}Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can make index signaturesreadonlyin order to prevent assignment to their indices:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceReadonlyStringArray{readonly[index:number]:string;}letmyArray:ReadonlyStringArray=getReadOnlyStringArray();myArray[2] =\"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try"
                },
                {
                    "type": "p",
                    "text": "You can’t setmyArray[2]because the index signature isreadonly."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Excess Property Checks"
                },
                {
                    "type": "p",
                    "text": "Where and how an object is assigned a type can make a difference in the type system.\nOne of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {return{color:config.color||\"red\",area:config.width?config.width*config.width:20,};}letmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Notice the given argument tocreateSquareis spelledcolourinstead ofcolor.\nIn plain JavaScript, this sort of thing fails silently."
                },
                {
                    "type": "p",
                    "text": "You could argue that this program is correctly typed, since thewidthproperties are compatible, there’s nocolorproperty present, and the extracolourproperty is insignificant."
                },
                {
                    "type": "p",
                    "text": "However, TypeScript takes the stance that there’s probably a bug in this code.\nObject literals get special treatment and undergoexcess property checkingwhen assigning them to other variables, or passing them as arguments.\nIf an object literal has any properties that the “target type” doesn’t have, you’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Getting around these checks is actually really simple.\nThe easiest method is to just use a type assertion:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({width:100,opacity:0.5}asSquareConfig);Try"
                },
                {
                    "type": "p",
                    "text": "However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way.\nIfSquareConfigcan havecolorandwidthproperties with the above types, but couldalsohave any number of other properties, then we could define it like so:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;[propName:string]:unknown;}Try"
                },
                {
                    "type": "p",
                    "text": "Here we’re saying thatSquareConfigcan have any number of properties, and as long as they aren’tcolororwidth, their types don’t matter."
                },
                {
                    "type": "p",
                    "text": "One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable:\nSince assigningsquareOptionswon’t undergo excess property checks, the compiler won’t give you an error:"
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\",width:100};letmySquare=createSquare(squareOptions);Try"
                },
                {
                    "type": "p",
                    "text": "The above workaround will work as long as you have a common property betweensquareOptionsandSquareConfig.\nIn this example, it was the propertywidth. It will however, fail if the variable does not have any common object property. For example:"
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\"};letmySquare=createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks.\nFor more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs."
                },
                {
                    "type": "p",
                    "text": "That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations.\nIn this instance, if it’s okay to pass an object with both acolororcolourproperty tocreateSquare, you should fix up the definition ofSquareConfigto reflect that."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Extending Types"
                },
                {
                    "type": "p",
                    "text": "It’s pretty common to have types that might be more specific versions of other types.\nFor example, we might have aBasicAddresstype that describes the fields necessary for sending letters and packages in the U.S."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBasicAddress{name?:string;street:string;city:string;country:string;postalCode:string;}Try"
                },
                {
                    "type": "p",
                    "text": "In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units.\nWe can then describe anAddressWithUnit."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAddressWithUnit{name?:string;unit:string;street:string;city:string;country:string;postalCode:string;}Try"
                },
                {
                    "type": "p",
                    "text": "This does the job, but the downside here is that we had to repeat all the other fields fromBasicAddresswhen our changes were purely additive.\nInstead, we can extend the originalBasicAddresstype and just add the new fields that are unique toAddressWithUnit."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBasicAddress{name?:string;street:string;city:string;country:string;postalCode:string;}interfaceAddressWithUnitextendsBasicAddress{unit:string;}Try"
                },
                {
                    "type": "p",
                    "text": "Theextendskeyword on aninterfaceallows us to effectively copy members from other named types, and add whatever new members we want.\nThis can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related.\nFor example,AddressWithUnitdidn’t need to repeat thestreetproperty, and becausestreetoriginates fromBasicAddress, a reader will know that those two types are related in some way."
                },
                {
                    "type": "p",
                    "text": "interfaces can also extend from multiple types."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceColorful{color:string;}interfaceCircle{radius:number;}interfaceColorfulCircleextendsColorful,Circle{}constcc:ColorfulCircle= {color:\"red\",radius:42,};Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Intersection Types"
                },
                {
                    "type": "p",
                    "text": "interfaces allowed us to build up new types from other types by extending them.\nTypeScript provides another construct calledintersection typesthat is mainly used to combine existing object types."
                },
                {
                    "type": "p",
                    "text": "An intersection type is defined using the&operator."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceColorful{color:string;}interfaceCircle{radius:number;}typeColorfulCircle=Colorful&Circle;Try"
                },
                {
                    "type": "p",
                    "text": "Here, we’ve intersectedColorfulandCircleto produce a new type that has all the members ofColorfulandCircle."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondraw(circle:Colorful&Circle) {console.log(`Color was${circle.color}`);console.log(`Radius was${circle.radius}`);}// okaydraw({color:\"blue\",radius:42});// oopsdraw({color:\"red\",raidus:42});Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interface Extension vs. Intersection"
                },
                {
                    "type": "p",
                    "text": "We just looked at two ways to combine types which are similar, but are actually subtly different.\nWith interfaces, we could use anextendsclause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias.\nThe principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type."
                },
                {
                    "type": "p",
                    "text": "If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error."
                },
                {
                    "type": "p",
                    "text": "In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results."
                },
                {
                    "type": "p",
                    "text": "For example, the following code will throw an error because the properties are incompatible:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson{name:string;}interfacePerson{name:number;}"
                },
                {
                    "type": "p",
                    "text": "In contrast, the following code will compile, but it results in anevertype:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson1{name:string;}interfacePerson2{name:number;}typeStaff=Person1&Person2declareconststaffer:Staff;staffer.name;(property) name: neverTry"
                },
                {
                    "type": "p",
                    "text": "In this case, Staff would require the name property to be both a string and a number, which results in property being of typenever."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Object Types"
                },
                {
                    "type": "p",
                    "text": "Let’s imagine aBoxtype that can contain any value -strings,numbers,Giraffes, whatever."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox{contents:any;}Try"
                },
                {
                    "type": "p",
                    "text": "Right now, thecontentsproperty is typed asany, which works, but can lead to accidents down the line."
                },
                {
                    "type": "p",
                    "text": "We could instead useunknown, but that would mean that in cases where we already know the type ofcontents, we’d need to do precautionary checks, or use error-prone type assertions."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox{contents:unknown;}letx:Box= {contents:\"hello world\",};// we could check 'x.contents'if(typeofx.contents===\"string\") {console.log(x.contents.toLowerCase());}// or we could use a type assertionconsole.log((x.contentsasstring).toLowerCase());Try"
                },
                {
                    "type": "p",
                    "text": "One type safe approach would be to instead scaffold out differentBoxtypes for every type ofcontents."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberBox{contents:number;}interfaceStringBox{contents:string;}interfaceBooleanBox{contents:boolean;}Try"
                },
                {
                    "type": "p",
                    "text": "But that means we’ll have to create different functions, or overloads of functions, to operate on these types."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsetContents(box:StringBox,newContents:string):void;functionsetContents(box:NumberBox,newContents:number):void;functionsetContents(box:BooleanBox,newContents:boolean):void;functionsetContents(box: {contents:any},newContents:any) {box.contents=newContents;}Try"
                },
                {
                    "type": "p",
                    "text": "That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads.\nThis is frustrating, since our box types and overloads are all effectively the same."
                },
                {
                    "type": "p",
                    "text": "Instead, we can make agenericBoxtype which declares atype parameter."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox<Type> {contents:Type;}Try"
                },
                {
                    "type": "p",
                    "text": "You might read this as “ABoxofTypeis something whosecontentshave typeType”.\nLater on, when we refer toBox, we have to give atype argumentin place ofType."
                },
                {
                    "type": "code",
                    "code": "tsletbox:Box<string>;Try"
                },
                {
                    "type": "p",
                    "text": "Think ofBoxas a template for a real type, whereTypeis a placeholder that will get replaced with some other type.\nWhen TypeScript seesBox<string>, it will replace every instance ofTypeinBox<Type>withstring, and end up working with something like{ contents: string }.\nIn other words,Box<string>and our earlierStringBoxwork identically."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox<Type> {contents:Type;}interfaceStringBox{contents:string;}letboxA:Box<string> = {contents:\"hello\"};boxA.contents;(property) Box<string>.contents: stringletboxB:StringBox= {contents:\"world\"};boxB.contents;(property) StringBox.contents: stringTry"
                },
                {
                    "type": "p",
                    "text": "Boxis reusable in thatTypecan be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a newBoxtype at all (though we certainly could if we wanted to)."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox<Type> {contents:Type;}interfaceApple{// ....}// Same as '{ contents: Apple }'.typeAppleBox=Box<Apple>;Try"
                },
                {
                    "type": "p",
                    "text": "This also means that we can avoid overloads entirely by instead usinggeneric functions."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsetContents<Type>(box:Box<Type>,newContents:Type) {box.contents=newContents;}Try"
                },
                {
                    "type": "p",
                    "text": "It is worth noting that type aliases can also be generic. We could have defined our newBox<Type>interface, which was:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox<Type> {contents:Type;}Try"
                },
                {
                    "type": "p",
                    "text": "by using a type alias instead:"
                },
                {
                    "type": "code",
                    "code": "tstypeBox<Type> = {contents:Type;};Try"
                },
                {
                    "type": "p",
                    "text": "Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types."
                },
                {
                    "type": "code",
                    "code": "tstypeOrNull<Type> =Type|null;typeOneOrMany<Type> =Type|Type[];typeOneOrManyOrNull<Type> =OrNull<OneOrMany<Type>>;type OneOrManyOrNull<Type> = OneOrMany<Type> | nulltypeOneOrManyOrNullStrings=OneOrManyOrNull<string>;type OneOrManyOrNullStrings = OneOrMany<string> | nullTry"
                },
                {
                    "type": "p",
                    "text": "We’ll circle back to type aliases in just a little bit."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TheArrayType"
                },
                {
                    "type": "p",
                    "text": "Generic object types are often some sort of container type that work independently of the type of elements they contain.\nIt’s ideal for data structures to work this way so that they’re re-usable across different data types."
                },
                {
                    "type": "p",
                    "text": "It turns out we’ve been working with a type just like that throughout this handbook: theArraytype.\nWhenever we write out types likenumber[]orstring[], that’s really just a shorthand forArray<number>andArray<string>."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(value:Array<string>) {// ...}letmyArray:string[] = [\"hello\",\"world\"];// either of these work!doSomething(myArray);doSomething(newArray(\"hello\",\"world\"));Try"
                },
                {
                    "type": "p",
                    "text": "Much like theBoxtype above,Arrayitself is a generic type."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceArray<Type> {Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters.23172428Global type 'Array' must have 1 type parameter(s).All declarations of 'Array' must have identical type parameters./*** Gets or sets the length of the array.*/length:number;/*** Removes the last element from an array and returns it.*/pop():Type|undefined;/*** Appends new elements to an array, and returns the new length of the array.*/push(...items:Type[]):number;A rest parameter must be of an array type.2370A rest parameter must be of an array type.// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Modern JavaScript also provides other data structures which are generic, likeMap<K, V>,Set<T>, andPromise<T>.\nAll this really means is that because of howMap,Set, andPromisebehave, they can work with any sets of types."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TheReadonlyArrayType"
                },
                {
                    "type": "p",
                    "text": "TheReadonlyArrayis a special type that describes arrays that shouldn’t be changed."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoStuff(values:ReadonlyArray<string>) {// We can read from 'values'...constcopy=values.slice();console.log(`The first value is${values[0]}`);// ...but we can't mutate 'values'.values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
                },
                {
                    "type": "p",
                    "text": "Much like thereadonlymodifier for properties, it’s mainly a tool we can use for intent.\nWhen we see a function that returnsReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumesReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents."
                },
                {
                    "type": "p",
                    "text": "UnlikeArray, there isn’t aReadonlyArrayconstructor that we can use."
                },
                {
                    "type": "code",
                    "code": "tsnewReadonlyArray(\"red\",\"green\",\"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try"
                },
                {
                    "type": "p",
                    "text": "Instead, we can assign regularArrays toReadonlyArrays."
                },
                {
                    "type": "code",
                    "code": "tsconstroArray:ReadonlyArray<string> = [\"red\",\"green\",\"blue\"];Try"
                },
                {
                    "type": "p",
                    "text": "Just as TypeScript provides a shorthand syntax forArray<Type>withType[], it also provides a shorthand syntax forReadonlyArray<Type>withreadonly Type[]."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoStuff(values:readonlystring[]) {// We can read from 'values'...constcopy=values.slice();console.log(`The first value is${values[0]}`);// ...but we can't mutate 'values'.values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
                },
                {
                    "type": "p",
                    "text": "One last thing to note is that unlike thereadonlyproperty modifier, assignability isn’t bidirectional between regularArrays andReadonlyArrays."
                },
                {
                    "type": "code",
                    "code": "tsletx:readonlystring[] = [];lety:string[] = [];x=y;y=x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Tuple Types"
                },
                {
                    "type": "p",
                    "text": "Atuple typeis another sort ofArraytype that knows exactly how many elements it contains, and exactly which types it contains at specific positions."
                },
                {
                    "type": "code",
                    "code": "tstypeStringNumberPair= [string,number];Try"
                },
                {
                    "type": "p",
                    "text": "Here,StringNumberPairis a tuple type ofstringandnumber.\nLikeReadonlyArray, it has no representation at runtime, but is significant to TypeScript.\nTo the type system,StringNumberPairdescribes arrays whose0index contains astringand whose1index contains anumber."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(pair: [string,number]) {consta=pair[0];const a: stringconstb=pair[1];const b: number// ...}doSomething([\"hello\",42]);Try"
                },
                {
                    "type": "p",
                    "text": "If we try to index past the number of elements, we’ll get an error."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(pair: [string,number]) {// ...constc=pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try"
                },
                {
                    "type": "p",
                    "text": "We can alsodestructure tuplesusing JavaScript’s array destructuring."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(stringHash: [string,number]) {const[inputString,hash] =stringHash;console.log(inputString);const inputString: stringconsole.log(hash);const hash: number}Try"
                },
                {
                    "type": "p",
                    "text": "Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”.\nThis gives us flexibility in whatever we want to name our variables when we destructure them.\nIn the above example, we were able to name elements0and1to whatever we wanted."
                },
                {
                    "type": "p",
                    "text": "However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API."
                },
                {
                    "type": "p",
                    "text": "Other than those length checks, simple tuple types like these are equivalent to types which are versions ofArrays that declare properties for specific indexes, and that declarelengthwith a numeric literal type."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringNumberPair{// specialized propertieslength:2;0:string;1:number;// Other 'Array<string | number>' members...slice(start?:number,end?:number):Array<string|number>;}Try"
                },
                {
                    "type": "p",
                    "text": "Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (?after an element’s type).\nOptional tuple elements can only come at the end, and also affect the type oflength."
                },
                {
                    "type": "code",
                    "code": "tstypeEither2dOr3d= [number,number,number?];functionsetCoordinate(coord:Either2dOr3d) {const[x,y,z] =coord;const z: number | undefinedconsole.log(`Provided coordinates had${coord.length}dimensions`);(property) length: 2 | 3}Try"
                },
                {
                    "type": "p",
                    "text": "Tuples can also have rest elements, which have to be an array/tuple type."
                },
                {
                    "type": "code",
                    "code": "tstypeStringNumberBooleans= [string,number, ...boolean[]];typeStringBooleansNumber= [string, ...boolean[],number];typeBooleansStringNumber= [...boolean[],string,number];Try"
                },
                {
                    "type": "list",
                    "items": [
                        "StringNumberBooleansdescribes a tuple whose first two elements arestringandnumberrespectively, but which may have any number ofbooleans following.",
                        "StringBooleansNumberdescribes a tuple whose first element isstringand then any number ofbooleans and ending with anumber.",
                        "BooleansStringNumberdescribes a tuple whose starting elements are any number ofbooleans and ending with astringthen anumber."
                    ]
                },
                {
                    "type": "p",
                    "text": "A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions."
                },
                {
                    "type": "code",
                    "code": "tsconsta:StringNumberBooleans= [\"hello\",1];constb:StringNumberBooleans= [\"beautiful\",2,true];constc:StringNumberBooleans= [\"world\",3,true,false,true,false,true];Try"
                },
                {
                    "type": "p",
                    "text": "Why might optional and rest elements be useful?\nWell, it allows TypeScript to correspond tuples with parameter lists.\nTuples types can be used inrest parameters and arguments, so that the following:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionreadButtonInput(...args: [string,number, ...boolean[]]) {const[name,version, ...input] =args;// ...}Try"
                },
                {
                    "type": "p",
                    "text": "is basically equivalent to:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionreadButtonInput(name:string,version:number, ...input:boolean[]) {// ...}Try"
                },
                {
                    "type": "p",
                    "text": "This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "readonlyTuple Types"
                },
                {
                    "type": "p",
                    "text": "One final note about tuple types - tuple types havereadonlyvariants, and can be specified by sticking areadonlymodifier in front of them - just like with array shorthand syntax."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(pair:readonly[string,number]) {// ...}Try"
                },
                {
                    "type": "p",
                    "text": "As you might expect, writing to any property of areadonlytuple isn’t allowed in TypeScript."
                },
                {
                    "type": "code",
                    "code": "tsfunctiondoSomething(pair:readonly[string,number]) {pair[0] =\"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try"
                },
                {
                    "type": "p",
                    "text": "Tuples tend to be created and left un-modified in most code, so annotating types asreadonlytuples when possible is a good default.\nThis is also important given that array literals withconstassertions will be inferred withreadonlytuple types."
                },
                {
                    "type": "code",
                    "code": "tsletpoint= [3,4]asconst;functiondistanceFromOrigin([x,y]: [number,number]) {returnMath.sqrt(x**2+y**2);}distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try"
                },
                {
                    "type": "p",
                    "text": "Here,distanceFromOriginnever modifies its elements, but expects a mutable tuple.\nSincepoint’s type was inferred asreadonly [3, 4], it won’t be compatible with[number, number]since that type can’t guaranteepoint’s elements won’t be mutated."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "More on Functions"
                },
                {
                    "type": "p",
                    "text": "Learn about how Functions work in TypeScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating Types from Types"
                },
                {
                    "type": "p",
                    "text": "An overview of the ways in which you can create more types from existing types."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html",
            "title": "TypeScript: Documentation - Template Literal Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Template Literal Types"
                },
                {
                    "type": "p",
                    "text": "Template literal types build onstring literal types, and have the ability to expand into many strings via unions."
                },
                {
                    "type": "p",
                    "text": "They have the same syntax astemplate literal strings in JavaScript, but are used in type positions.\nWhen used with concrete literal types, a template literal produces a new string literal type by concatenating the contents."
                },
                {
                    "type": "code",
                    "code": "tstypeWorld=\"world\";typeGreeting=`hello${World}`;type Greeting = \"hello world\"Try"
                },
                {
                    "type": "p",
                    "text": "When a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:"
                },
                {
                    "type": "code",
                    "code": "tstypeEmailLocaleIDs=\"welcome_email\"|\"email_heading\";typeFooterLocaleIDs=\"footer_title\"|\"footer_sendoff\";typeAllLocaleIDs=`${EmailLocaleIDs|FooterLocaleIDs}_id`;type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"Try"
                },
                {
                    "type": "p",
                    "text": "For each interpolated position in the template literal, the unions are cross multiplied:"
                },
                {
                    "type": "code",
                    "code": "tstypeAllLocaleIDs=`${EmailLocaleIDs|FooterLocaleIDs}_id`;typeLang=\"en\"|\"ja\"|\"pt\";typeLocaleMessageIDs=`${Lang}_${AllLocaleIDs}`;type LocaleMessageIDs = \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"Try"
                },
                {
                    "type": "p",
                    "text": "We generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "String Unions in Types"
                },
                {
                    "type": "p",
                    "text": "The power in template literals comes when defining a new string based on information inside a type."
                },
                {
                    "type": "p",
                    "text": "Consider the case where a function (makeWatchedObject) adds a new function\ncalledon()to a passed object.  In JavaScript, its call might look like:makeWatchedObject(baseObject). We can imagine the base object as looking\nlike:"
                },
                {
                    "type": "code",
                    "code": "tsconstpassedObject= {firstName:\"Saoirse\",lastName:\"Ronan\",age:26,};Try"
                },
                {
                    "type": "p",
                    "text": "Theonfunction that will be added to the base object expects two arguments, aneventName(astring) and acallback(afunction)."
                },
                {
                    "type": "p",
                    "text": "TheeventNameshould be of the formattributeInThePassedObject + \"Changed\"; thus,firstNameChangedas derived from the attributefirstNamein the base object."
                },
                {
                    "type": "p",
                    "text": "Thecallbackfunction, when called:"
                },
                {
                    "type": "list",
                    "items": [
                        "Should be passed a value of the type associated with the nameattributeInThePassedObject; thus, sincefirstNameis typed asstring, the callback for thefirstNameChangedevent expects astringto be passed to it at call time. Similarly events associated withageshould expect to be called with anumberargument",
                        "Should havevoidreturn type (for simplicity of demonstration)"
                    ]
                },
                {
                    "type": "p",
                    "text": "The naive function signature ofon()might thus be:on(eventName: string, callback: (newValue: any) => void). However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code."
                },
                {
                    "type": "code",
                    "code": "tsconstperson=makeWatchedObject({firstName:\"Saoirse\",lastName:\"Ronan\",age:26,});// makeWatchedObject has added `on` to the anonymous Objectperson.on(\"firstNameChanged\", (newValue)=>{console.log(`firstName was changed to${newValue}!`);});Try"
                },
                {
                    "type": "p",
                    "text": "Notice thatonlistens on the event\"firstNameChanged\", not just\"firstName\". Our naive specification ofon()could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e.Object.keys(passedObject).map(x => `${x}Changed`), template literalsinside the type systemprovide a similar approach to string manipulation:"
                },
                {
                    "type": "code",
                    "code": "tstypePropEventSource<Type> = {on(eventName:`${string&keyofType}Changed`,callback: (newValue:any)=>void):void;};/// Create a \"watched object\" with an `on` method/// so that you can watch for changes to properties.declarefunctionmakeWatchedObject<Type>(obj:Type):Type&PropEventSource<Type>;Try"
                },
                {
                    "type": "p",
                    "text": "With this, we can build something that errors when given the wrong property:"
                },
                {
                    "type": "code",
                    "code": "tsconstperson=makeWatchedObject({firstName:\"Saoirse\",lastName:\"Ronan\",age:26});person.on(\"firstNameChanged\", ()=>{});// Prevent easy human error (using the key instead of the event name)person.on(\"firstName\", ()=>{});Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.// It's typo-resistantperson.on(\"frstNameChanged\", ()=>{});Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inference with Template Literals"
                },
                {
                    "type": "p",
                    "text": "Notice that we did not benefit from all the information provided in the original passed object. Given change of afirstName(i.e. afirstNameChangedevent),  we should expect that the callback will receive an argument of typestring. Similarly, the callback for a change toageshould receive anumberargument. We’re naively usinganyto type thecallback’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument."
                },
                {
                    "type": "p",
                    "text": "The key insight that makes this possible is this: we can use a function with a generic such that:"
                },
                {
                    "type": "list",
                    "items": [
                        "The literal used in the first argument is captured as a literal type",
                        "That literal type can be validated as being in the union of valid attributes in the generic",
                        "The type of the validated attribute can be looked up in the generic’s structure using Indexed Access",
                        "This typing information canthenbe applied to ensure the argument to the\ncallback function is of the same type"
                    ]
                },
                {
                    "type": "code",
                    "code": "tstypePropEventSource<Type> = {on<Keyextendsstring&keyofType>(eventName:`${Key}Changed`,callback: (newValue:Type[Key])=>void):void;};declarefunctionmakeWatchedObject<Type>(obj:Type):Type&PropEventSource<Type>;constperson=makeWatchedObject({firstName:\"Saoirse\",lastName:\"Ronan\",age:26});person.on(\"firstNameChanged\",newName=>{(parameter) newName: stringconsole.log(`new name is${newName.toUpperCase()}`);});person.on(\"ageChanged\",newAge=>{(parameter) newAge: numberif(newAge< 0) {console.warn(\"warning! negative age\");}})Try"
                },
                {
                    "type": "p",
                    "text": "Here we madeoninto a generic method."
                },
                {
                    "type": "p",
                    "text": "When a user calls with the string\"firstNameChanged\", TypeScript will try to infer the right type forKey.\nTo do that, it will matchKeyagainst the content before\"Changed\"and infer the string\"firstName\".\nOnce TypeScript figures that out, theonmethod can fetch the type offirstNameon the original object, which isstringin this case.\nSimilarly, when called with\"ageChanged\", TypeScript finds the type for the propertyagewhich isnumber."
                },
                {
                    "type": "p",
                    "text": "Inference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Intrinsic String Manipulation Types"
                },
                {
                    "type": "p",
                    "text": "To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the.d.tsfiles included with TypeScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Uppercase<StringType>"
                },
                {
                    "type": "p",
                    "text": "Converts each character in the string to the uppercase version."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeGreeting=\"Hello, world\"typeShoutyGreeting=Uppercase<Greeting>type ShoutyGreeting = \"HELLO, WORLD\"typeASCIICacheKey<Strextendsstring> =`ID-${Uppercase<Str>}`typeMainID=ASCIICacheKey<\"my_app\">type MainID = \"ID-MY_APP\"Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Lowercase<StringType>"
                },
                {
                    "type": "p",
                    "text": "Converts each character in the string to the lowercase equivalent."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeGreeting=\"Hello, world\"typeQuietGreeting=Lowercase<Greeting>type QuietGreeting = \"hello, world\"typeASCIICacheKey<Strextendsstring> =`id-${Lowercase<Str>}`typeMainID=ASCIICacheKey<\"MY_APP\">type MainID = \"id-my_app\"Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Capitalize<StringType>"
                },
                {
                    "type": "p",
                    "text": "Converts the first character in the string to an uppercase equivalent."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeLowercaseGreeting=\"hello, world\";typeGreeting=Capitalize<LowercaseGreeting>;type Greeting = \"Hello, world\"Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Uncapitalize<StringType>"
                },
                {
                    "type": "p",
                    "text": "Converts the first character in the string to a lowercase equivalent."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeUppercaseGreeting=\"HELLO WORLD\";typeUncomfortableGreeting=Uncapitalize<UppercaseGreeting>;type UncomfortableGreeting = \"hELLO WORLD\"Try"
                },
                {
                    "type": "p",
                    "text": "The code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware."
                },
                {
                    "type": "code",
                    "code": "function applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Mapped Types"
                },
                {
                    "type": "p",
                    "text": "Generating types by re-using an existing type."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/typeof-types.html",
            "title": "TypeScript: Documentation - Typeof Type Operator",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Typeof Type Operator"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Thetypeoftype operator"
                },
                {
                    "type": "p",
                    "text": "JavaScript already has atypeofoperator you can use in anexpressioncontext:"
                },
                {
                    "type": "code",
                    "code": "ts// Prints \"string\"console.log(typeof\"Hello world\");Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds atypeofoperator you can use in atypecontext to refer to thetypeof a variable or property:"
                },
                {
                    "type": "code",
                    "code": "tslets=\"hello\";letn:typeofs;let n: stringTry"
                },
                {
                    "type": "p",
                    "text": "This isn’t very useful for basic types, but combined with other type operators, you can usetypeofto conveniently express many patterns.\nFor an example, let’s start by looking at the predefined typeReturnType<T>.\nIt takes afunction typeand produces its return type:"
                },
                {
                    "type": "code",
                    "code": "tstypePredicate= (x:unknown)=>boolean;typeK=ReturnType<Predicate>;type K = booleanTry"
                },
                {
                    "type": "p",
                    "text": "If we try to useReturnTypeon a function name, we see an instructive error:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {return{x:10,y:3};}typeP=ReturnType<f>;'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?2749'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?Try"
                },
                {
                    "type": "p",
                    "text": "Remember thatvaluesandtypesaren’t the same thing.\nTo refer to thetypethat thevaluefhas, we usetypeof:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {return{x:10,y:3};}typeP=ReturnType<typeoff>;type P = {\n    x: number;\n    y: number;\n}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Limitations"
                },
                {
                    "type": "p",
                    "text": "TypeScript intentionally limits the sorts of expressions you can usetypeofon."
                },
                {
                    "type": "p",
                    "text": "Specifically, it’s only legal to usetypeofon identifiers (i.e. variable names) or their properties.\nThis helps avoid the confusing trap of writing code you think is executing, but isn’t:"
                },
                {
                    "type": "code",
                    "code": "ts// Meant to use = ReturnType<typeof msgbox>letshouldContinue:typeofmsgbox(\"Are you sure you want to continue?\");',' expected.1005',' expected.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Keyof Type Operator"
                },
                {
                    "type": "p",
                    "text": "Using the keyof operator in type contexts."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Indexed Access Types"
                },
                {
                    "type": "p",
                    "text": "Using Type['a'] syntax to access a subset of a type."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
            "title": "TypeScript: Documentation - Creating Types from Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Creating Types from Types"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system is very powerful because it allows expressing typesin terms of other types."
                },
                {
                    "type": "p",
                    "text": "The simplest form of this idea is generics. Additionally, we have a wide variety oftype operatorsavailable to use.\nIt’s also possible to express types in terms ofvaluesthat we already have."
                },
                {
                    "type": "p",
                    "text": "By combining various type operators, we can express complex operations and values in a succinct, maintainable way.\nIn this section we’ll cover ways to express a new type in terms of an existing type or value."
                },
                {
                    "type": "list",
                    "items": [
                        "Generics- Types which take parameters",
                        "Keyof Type Operator- Using thekeyofoperator to create new types",
                        "Typeof Type Operator- Using thetypeofoperator to create new types",
                        "Indexed Access Types- UsingType['a']syntax to access a subset of a type",
                        "Conditional Types- Types which act like if statements in the type system",
                        "Mapped Types- Creating types by mapping each property in an existing type",
                        "Template Literal Types- Mapped types which change properties via template literal strings"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "Types which take parameters"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/asp-net-core.html",
            "title": "TypeScript: Documentation - ASP.NET Core",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "ASP.NET Core"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Install ASP.NET Core and TypeScript"
                },
                {
                    "type": "p",
                    "text": "First, installASP.NET Coreif you need it. This quick-start guide requires Visual Studio 2015 or 2017."
                },
                {
                    "type": "p",
                    "text": "Next, if your version of Visual Studio does not already have the latest TypeScript, you caninstall it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Create a new project"
                },
                {
                    "type": "list",
                    "items": [
                        "ChooseFile",
                        "ChooseNew Project(Ctrl + Shift + N)",
                        "Search for.NET Corein the project search bar",
                        "SelectASP.NET Core Web Applicationand press theNextbutton"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "list",
                    "items": [
                        "Name your project and solution. After select theCreatebutton"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "list",
                    "items": [
                        "In the last window, select theEmptytemplate and press theCreatebutton"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Run the application and make sure that it works."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Set up the server"
                },
                {
                    "type": "p",
                    "text": "OpenDependencies > Manage NuGet Packages > Browse.Search and installMicrosoft.AspNetCore.StaticFilesandMicrosoft.TypeScript.MSBuild:"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Open up yourStartup.csfile and edit yourConfigurefunction to look like this:"
                },
                {
                    "type": "code",
                    "code": "public void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}"
                },
                {
                    "type": "p",
                    "text": "You may need to restart VS for the red squiggly lines belowUseDefaultFilesandUseStaticFilesto disappear."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Add TypeScript"
                },
                {
                    "type": "p",
                    "text": "Next we will add a new folder and call itscripts."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Add TypeScript code"
                },
                {
                    "type": "p",
                    "text": "Right click onscriptsand clickNew Item. Then chooseTypeScript Fileand name the fileapp.ts"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Add example code"
                },
                {
                    "type": "p",
                    "text": "Add the following code to theapp.tsfile."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsayHello() {constcompiler= (document.getElementById(\"compiler\")asHTMLInputElement).value;constframework= (document.getElementById(\"framework\")asHTMLInputElement).value;return`Hello from${compiler}and${framework}!`;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Set up the build"
                },
                {
                    "type": "p",
                    "text": "Configure the TypeScript compiler"
                },
                {
                    "type": "p",
                    "text": "First we need to tell TypeScript how to build. Right click onscriptsand clickNew Item. Then chooseTypeScript Configuration Fileand use the default name oftsconfig.json"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Replace the contents of thetsconfig.jsonfile with:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"noEmitOnError\":true,\"noImplicitAny\":true,\"sourceMap\":true,\"target\":\"es6\"},\"files\": [\"./app.ts\"],\"compileOnSave\":true}"
                },
                {
                    "type": "list",
                    "items": [
                        "noEmitOnError: Do not emit outputs if any errors were reported.",
                        "noImplicitAny: Raise error on expressions and declarations with an impliedanytype.",
                        "sourceMap: Generates corresponding.mapfile.",
                        "target: Specify ECMAScript target version."
                    ]
                },
                {
                    "type": "p",
                    "text": "Note:\"ESNext\"targets latest supported"
                },
                {
                    "type": "p",
                    "text": "noImplicitAnyis good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake.\"compileOnSave\"makes it easy to update your code in a running web app."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Set up NPM"
                },
                {
                    "type": "p",
                    "text": "We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and selectNew Item. Then chooseNPM Configuration Fileand use the default name ofpackage.json."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Inside the\"devDependencies\"section of thepackage.jsonfile, addgulpanddel"
                },
                {
                    "type": "code",
                    "code": "\"devDependencies\": {\"gulp\":\"4.0.2\",\"del\":\"5.1.0\"}"
                },
                {
                    "type": "p",
                    "text": "Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages."
                },
                {
                    "type": "p",
                    "text": "After you should see annpmfolder in your solution explorer"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Set up gulp"
                },
                {
                    "type": "p",
                    "text": "Right click on the project and clickNew Item. Then chooseJavaScript Fileand use the name ofgulpfile.js"
                },
                {
                    "type": "code",
                    "code": "js/// <binding AfterBuild='default' Clean='clean' />/*This file is the main entry point for defining Gulp tasks and using Gulp plugins.Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007*/vargulp=require(\"gulp\");vardel=require(\"del\");varpaths= {scripts:[\"scripts/**/*.js\",\"scripts/**/*.ts\",\"scripts/**/*.map\"],};gulp.task(\"clean\",function() {returndel([\"wwwroot/scripts/**/*\"]);});gulp.task(\"default\",function(done) {gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));done();});"
                },
                {
                    "type": "p",
                    "text": "The first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build."
                },
                {
                    "type": "p",
                    "text": "Now right-click ongulpfile.jsand click Task Runner Explorer."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "If ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Write a HTML page"
                },
                {
                    "type": "p",
                    "text": "Right click on thewwwrootfolder (if you don’t see the folder try building the project) and add a New Item namedindex.htmlinside. Use the following code forindex.html"
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html><html><head><meta charset=\"utf-8\" /><script src=\"scripts/app.js\"></script><title></title></head><body><div id=\"message\"></div><div>Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /></div></body></html>"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Test"
                },
                {
                    "type": "list",
                    "items": [
                        "Run the project",
                        "As you type on the boxes you should see the message appear/change!"
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Debug"
                },
                {
                    "type": "list",
                    "items": [
                        "In Edge, press F12 and click the Debugger tab.",
                        "Look in the first localhost folder, then scripts/app.ts",
                        "Put a breakpoint on the line with return.",
                        "Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly."
                    ]
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Congrats you’ve built your own .NET Core project with a TypeScript frontend."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html",
            "title": "TypeScript: Documentation - Using Babel with TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Using Babel with TypeScript"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Babel vstscfor TypeScript"
                },
                {
                    "type": "p",
                    "text": "When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?"
                },
                {
                    "type": "p",
                    "text": "A lot of the time the answer is“it depends”, or“someone may have decided for you”depending on the project. If you are building your project with an existing framework liketsdx,Angular,NestJSor any framework mentioned in theGetting Startedthen this decision is handled for you."
                },
                {
                    "type": "p",
                    "text": "However, a useful heuristic could be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Is your build output mostly the same as your source input files? Usetsc",
                        "Do you need a build pipeline with multiple potential outputs? Usebabelfor transpiling andtscfor type checking"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Babel for transpiling,tscfor types"
                },
                {
                    "type": "p",
                    "text": "This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript."
                },
                {
                    "type": "p",
                    "text": "This technique is a hybrid approach, using Babel’spreset-typescriptto generate your JS files, and then using TypeScript to do type checking and.d.tsfile generation."
                },
                {
                    "type": "p",
                    "text": "By using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Type Checking and d.ts file generation"
                },
                {
                    "type": "p",
                    "text": "The downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code."
                },
                {
                    "type": "p",
                    "text": "In addition to that, Babel cannot create.d.tsfiles for your TypeScript which can make it harder to work with your project if it is a library."
                },
                {
                    "type": "p",
                    "text": "To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a correspondingtsconfig.jsonand ensuring these flags are enabled:"
                },
                {
                    "type": "code",
                    "code": "\"compilerOptions\": {// Ensure that .d.ts files are created by tsc, but not .js files\"declaration\":true,\"emitDeclarationOnly\":true,// Ensure that Babel can safely transpile files in the TypeScript project\"isolatedModules\":true}"
                },
                {
                    "type": "p",
                    "text": "For more information on these flags:"
                },
                {
                    "type": "list",
                    "items": [
                        "isolatedModules",
                        "declaration,emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/basic-types.html#a-note-about-let",
            "title": "TypeScript: Handbook - Basic Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "This page has been deprecated"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Basic Types"
                },
                {
                    "type": "p",
                    "text": "For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like.\nIn TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Boolean"
                },
                {
                    "type": "p",
                    "text": "The most basic datatype is the simple true/false value, which JavaScript and TypeScript call abooleanvalue."
                },
                {
                    "type": "code",
                    "code": "tsletisDone:boolean=false;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Number"
                },
                {
                    "type": "p",
                    "text": "As in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers.\nThese floating point numbers get the typenumber, while BigIntegers get the typebigint.\nIn addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015."
                },
                {
                    "type": "code",
                    "code": "tsletdecimal:number=6;lethex:number=0xf00d;letbinary:number=0b1010;letoctal:number=0o744;letbig:bigint=100n;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "String"
                },
                {
                    "type": "p",
                    "text": "Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data.\nAs in other languages, we use the typestringto refer to these textual datatypes.\nJust like JavaScript, TypeScript also uses double quotes (\") or single quotes (') to surround string data."
                },
                {
                    "type": "code",
                    "code": "tsletcolor:string=\"blue\";color='red';Try"
                },
                {
                    "type": "p",
                    "text": "You can also usetemplate strings, which can span multiple lines and have embedded expressions.\nThese strings are surrounded by the backtick/backquote (`) character, and embedded expressions are of the form${ expr }."
                },
                {
                    "type": "code",
                    "code": "tsletfullName:string=`Bob Bobbington`;letage:number=37;letsentence:string=`Hello, my name is${fullName}.I'll be${age+1}years old next month.`;Try"
                },
                {
                    "type": "p",
                    "text": "This is equivalent to declaringsentencelike so:"
                },
                {
                    "type": "code",
                    "code": "tsletsentence:string=\"Hello, my name is \"+fullName+\".\\n\\n\"+\"I'll be \"+(age+1) +\" years old next month.\";Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Array"
                },
                {
                    "type": "p",
                    "text": "TypeScript, like JavaScript, allows you to work with arrays of values.\nArray types can be written in one of two ways.\nIn the first, you use the type of the elements followed by[]to denote an array of that element type:"
                },
                {
                    "type": "code",
                    "code": "tsletlist:number[] = [1,2,3];Try"
                },
                {
                    "type": "p",
                    "text": "The second way uses a generic array type,Array<elemType>:"
                },
                {
                    "type": "code",
                    "code": "tsletlist:Array<number> = [1,2,3];Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Tuple"
                },
                {
                    "type": "p",
                    "text": "Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of astringand anumber:"
                },
                {
                    "type": "code",
                    "code": "ts// Declare a tuple typeletx: [string,number];// Initialize itx= [\"hello\",10];// OK// Initialize it incorrectlyx= [10,\"hello\"];// ErrorType 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.23222322Type 'number' is not assignable to type 'string'.Type 'string' is not assignable to type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "When accessing an element with a known index, the correct type is retrieved:"
                },
                {
                    "type": "code",
                    "code": "ts// OKconsole.log(x[0].substring(1));console.log(x[1].substring(1));Property 'substring' does not exist on type 'number'.2339Property 'substring' does not exist on type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "Accessing an element outside the set of known indices fails with an error:"
                },
                {
                    "type": "code",
                    "code": "tsx[3] =\"world\";Tuple type '[string, number]' of length '2' has no element at index '3'.2493Tuple type '[string, number]' of length '2' has no element at index '3'.console.log(x[5].toString());Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.25322493Object is possibly 'undefined'.Tuple type '[string, number]' of length '2' has no element at index '5'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Enum"
                },
                {
                    "type": "p",
                    "text": "A helpful addition to the standard set of datatypes from JavaScript is theenum.\nAs in languages like C#, an enum is a way of giving more friendly names to sets of numeric values."
                },
                {
                    "type": "code",
                    "code": "tsenumColor{Red,Green,Blue,}letc:Color=Color.Green;Try"
                },
                {
                    "type": "p",
                    "text": "By default, enums begin numbering their members starting at0.\nYou can change this by manually setting the value of one of its members.\nFor example, we can start the previous example at1instead of0:"
                },
                {
                    "type": "code",
                    "code": "tsenumColor{Red=1,Green,Blue,}letc:Color=Color.Green;Try"
                },
                {
                    "type": "p",
                    "text": "Or, even manually set all the values in the enum:"
                },
                {
                    "type": "code",
                    "code": "tsenumColor{Red=1,Green=2,Blue=4,}letc:Color=Color.Green;Try"
                },
                {
                    "type": "p",
                    "text": "A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum.\nFor example, if we had the value2but weren’t sure what that mapped to in theColorenum above, we could look up the corresponding name:"
                },
                {
                    "type": "code",
                    "code": "tsenumColor{Red=1,Green,Blue,}letcolorName:string=Color[2];// Displays 'Green'console.log(colorName);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Unknown"
                },
                {
                    "type": "p",
                    "text": "We may need to describe the type of variables that we do not know when we are writing an application.\nThese values may come from dynamic content – e.g. from the user – or we may want to intentionally accept all values in our API.\nIn these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it theunknowntype."
                },
                {
                    "type": "code",
                    "code": "tsletnotSure:unknown=4;notSure=\"maybe a string instead\";// OK, definitely a booleannotSure=false;Try"
                },
                {
                    "type": "p",
                    "text": "If you have a variable with an unknown type, you can narrow it to something more specific by doingtypeofchecks, comparison checks, or more advanced type guards that will be discussed in a later chapter:"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstmaybe:unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconstaNumber:number=maybe;Type 'unknown' is not assignable to type 'number'.2322Type 'unknown' is not assignable to type 'number'.if(maybe===true) {// TypeScript knows that maybe is a boolean nowconstaBoolean:boolean=maybe;// So, it cannot be a stringconstaString:string=maybe;Type 'boolean' is not assignable to type 'string'.2322Type 'boolean' is not assignable to type 'string'.}if(typeofmaybe===\"string\") {// TypeScript knows that maybe is a stringconstaString:string=maybe;// So, it cannot be a booleanconstaBoolean:boolean=maybe;Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Any"
                },
                {
                    "type": "p",
                    "text": "In some situations, not all type information is available or its declaration would take an inappropriate amount of effort.\nThese may occur for values from code that has been written without TypeScript or a 3rd party library.\nIn these cases, we might want to opt-out of type checking.\nTo do so, we label these values with theanytype:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongetValue(key:string):any;// OK, return value of 'getValue' is not checkedconststr:string=getValue(\"myString\");Try"
                },
                {
                    "type": "p",
                    "text": "Theanytype is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation."
                },
                {
                    "type": "p",
                    "text": "Unlikeunknown, variables of typeanyallow you to access arbitrary properties, even ones that don’t exist.\nThese properties include functions and TypeScript will not check their existence or type:"
                },
                {
                    "type": "code",
                    "code": "tsletlooselyTyped:any=4;// OK, ifItExists might exist at runtimelooselyTyped.ifItExists();// OK, toFixed exists (but the compiler doesn't check)looselyTyped.toFixed();letstrictlyTyped:unknown=4;strictlyTyped.toFixed();'strictlyTyped' is of type 'unknown'.18046'strictlyTyped' is of type 'unknown'.Try"
                },
                {
                    "type": "p",
                    "text": "Theanywill continue to propagate through your objects:"
                },
                {
                    "type": "code",
                    "code": "tsletlooselyTyped:any= {};letd=looselyTyped.a.b.c.d;let d: anyTry"
                },
                {
                    "type": "p",
                    "text": "After all, remember that all the convenience ofanycomes at the cost of losing type safety.\nType safety is one of the main motivations for using TypeScript and you should try to avoid usinganywhen not necessary."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Void"
                },
                {
                    "type": "p",
                    "text": "voidis a little like the opposite ofany: the absence of having any type at all.\nYou may commonly see this as the return type of functions that do not return a value:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionwarnUser():void{console.log(\"This is my warning message\");}Try"
                },
                {
                    "type": "p",
                    "text": "Declaring variables of typevoidis not useful because you can only assignnull(only ifstrictNullChecksis not specified, see next section) orundefinedto them:"
                },
                {
                    "type": "code",
                    "code": "tsletunusable:void=undefined;// OK if `--strictNullChecks` is not givenunusable=null;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Null and Undefined"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, bothundefinedandnullactually have their types namedundefinedandnullrespectively.\nMuch likevoid, they’re not extremely useful on their own:"
                },
                {
                    "type": "code",
                    "code": "ts// Not much else we can assign to these variables!letu:undefined=undefined;letn:null=null;Try"
                },
                {
                    "type": "p",
                    "text": "By defaultnullandundefinedare subtypes of all other types.\nThat means you can assignnullandundefinedto something likenumber."
                },
                {
                    "type": "p",
                    "text": "However, when using thestrictNullChecksflag,nullandundefinedare only assignable tounknown,anyand their respective types (the one exception being thatundefinedis also assignable tovoid).\nThis helps avoidmanycommon errors.\nIn cases where you want to pass in either astringornullorundefined, you can use the union typestring | null | undefined."
                },
                {
                    "type": "p",
                    "text": "Union types are an advanced topic that we’ll cover in a later chapter."
                },
                {
                    "type": "p",
                    "text": "As a note: we encourage the use ofstrictNullCheckswhen possible, but for the purposes of this handbook, we will assume it is turned off."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Never"
                },
                {
                    "type": "p",
                    "text": "Thenevertype represents the type of values that never occur.\nFor instance,neveris the return type for a function expression or an arrow function expression that always throws an exception or one that never returns.\nVariables also acquire the typeneverwhen narrowed by any type guards that can never be true."
                },
                {
                    "type": "p",
                    "text": "Thenevertype is a subtype of, and assignable to, every type; however,notype is a subtype of, or assignable to,never(exceptneveritself).\nEvenanyisn’t assignable tonever."
                },
                {
                    "type": "p",
                    "text": "Some examples of functions returningnever:"
                },
                {
                    "type": "code",
                    "code": "ts// Function returning never must not have a reachable end pointfunctionerror(message:string):never{thrownewError(message);}// Inferred return type is neverfunctionfail() {returnerror(\"Something failed\");}// Function returning never must not have a reachable end pointfunctioninfiniteLoop():never{while(true) {}}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Object"
                },
                {
                    "type": "p",
                    "text": "objectis a type that represents the non-primitive type, i.e. anything that is notnumber,string,boolean,bigint,symbol,null, orundefined."
                },
                {
                    "type": "p",
                    "text": "Withobjecttype, APIs likeObject.createcan be better represented. For example:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctioncreate(o:object|null):void;// OKcreate({prop:0});create(null);create(undefined);// with `--strictNullChecks` flag enabled, undefined is not a subtype of nullArgument of type 'undefined' is not assignable to parameter of type 'object | null'.2345Argument of type 'undefined' is not assignable to parameter of type 'object | null'.create(42);Argument of type 'number' is not assignable to parameter of type 'object'.2345Argument of type 'number' is not assignable to parameter of type 'object'.create(\"string\");Argument of type 'string' is not assignable to parameter of type 'object'.2345Argument of type 'string' is not assignable to parameter of type 'object'.create(false);Argument of type 'boolean' is not assignable to parameter of type 'object'.2345Argument of type 'boolean' is not assignable to parameter of type 'object'.Try"
                },
                {
                    "type": "p",
                    "text": "Generally, you won’t need to use this."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type assertions"
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does.\nUsually, this will happen when you know the type of some entity could be more specific than its current type."
                },
                {
                    "type": "p",
                    "text": "Type assertionsare a way to tell the compiler “trust me, I know what I’m doing.”\nA type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data.\nIt has no runtime impact and is used purely by the compiler.\nTypeScript assumes that you, the programmer, have performed any special checks that you need."
                },
                {
                    "type": "p",
                    "text": "Type assertions have two forms."
                },
                {
                    "type": "p",
                    "text": "One is theas-syntax:"
                },
                {
                    "type": "code",
                    "code": "tsletsomeValue:unknown=\"this is a string\";letstrLength:number= (someValueasstring).length;Try"
                },
                {
                    "type": "p",
                    "text": "The other version is the “angle-bracket” syntax:"
                },
                {
                    "type": "code",
                    "code": "tsletsomeValue:unknown=\"this is a string\";letstrLength:number= (<string>someValue).length;Try"
                },
                {
                    "type": "p",
                    "text": "The two samples are equivalent.\nUsing one over the other is mostly a choice of preference; however, when using TypeScript with JSX, onlyas-style assertions are allowed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "A note aboutlet"
                },
                {
                    "type": "p",
                    "text": "You may have noticed that so far, we’ve been using theletkeyword instead of JavaScript’svarkeyword which you might be more familiar with.\nTheletkeyword is actually a newer JavaScript construct that TypeScript makes available.\nYou can read in the Handbook Reference onVariable Declarationsmore about howletandconstfix a lot of the problems withvar."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "AboutNumber,String,Boolean,SymbolandObject"
                },
                {
                    "type": "p",
                    "text": "It can be tempting to think that the typesNumber,String,Boolean,Symbol, orObjectare the same as the lowercase versions recommended above.\nThese types do not refer to the language primitives however, and almost never should be used as a type."
                },
                {
                    "type": "code",
                    "code": "tsfunctionreverse(s:String):String{returns.split(\"\").reverse().join(\"\");}reverse(\"hello world\");Try"
                },
                {
                    "type": "p",
                    "text": "Instead, use the typesnumber,string,boolean,objectandsymbol."
                },
                {
                    "type": "code",
                    "code": "tsfunctionreverse(s:string):string{returns.split(\"\").reverse().join(\"\");}reverse(\"hello world\");Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/classes.html",
            "title": "TypeScript: Handbook - Classes",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "This page has been deprecated"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes.\nStarting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach.\nIn TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Let’s take a look at a simple class-based example:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{greeting:string;constructor(message:string) {this.greeting=message;}greet() {return\"Hello, \"+this.greeting;}}letgreeter=newGreeter(\"world\");Try"
                },
                {
                    "type": "p",
                    "text": "The syntax should look familiar if you’ve used C# or Java before.\nWe declare a new classGreeter. This class has three members: a property calledgreeting, a constructor, and a methodgreet."
                },
                {
                    "type": "p",
                    "text": "You’ll notice that in the class when we refer to one of the members of the class we prependthis..\nThis denotes that it’s a member access."
                },
                {
                    "type": "p",
                    "text": "In the last line we construct an instance of theGreeterclass usingnew.\nThis calls into the constructor we defined earlier, creating a new object with theGreetershape, and running the constructor to initialize it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Inheritance"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, we can use common object-oriented patterns.\nOne of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance."
                },
                {
                    "type": "p",
                    "text": "Let’s take a look at an example:"
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{move(distanceInMeters:number=0) {console.log(`Animal moved${distanceInMeters}m.`);}}classDogextendsAnimal{bark() {console.log(\"Woof! Woof!\");}}constdog=newDog();dog.bark();dog.move(10);dog.bark();Try"
                },
                {
                    "type": "p",
                    "text": "This example shows the most basic inheritance feature: classes inherit properties and methods from base classes.\nHere,Dogis aderivedclass that derives from theAnimalbaseclass using theextendskeyword.\nDerived classes are often calledsubclasses, and base classes are often calledsuperclasses."
                },
                {
                    "type": "p",
                    "text": "BecauseDogextends the functionality fromAnimal, we were able to create an instance ofDogthat could bothbark()andmove()."
                },
                {
                    "type": "p",
                    "text": "Let’s now look at a more complex example."
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{name:string;constructor(theName:string) {this.name=theName;}move(distanceInMeters:number=0) {console.log(`${this.name}moved${distanceInMeters}m.`);}}classSnakeextendsAnimal{constructor(name:string) {super(name);}move(distanceInMeters=5) {console.log(\"Slithering...\");super.move(distanceInMeters);}}classHorseextendsAnimal{constructor(name:string) {super(name);}move(distanceInMeters=45) {console.log(\"Galloping...\");super.move(distanceInMeters);}}letsam=newSnake(\"Sammy the Python\");lettom:Animal=newHorse(\"Tommy the Palomino\");sam.move();tom.move(34);Try"
                },
                {
                    "type": "p",
                    "text": "This example covers a few other features we didn’t previously mention.\nAgain, we see theextendskeywords used to create two new subclasses ofAnimal:HorseandSnake."
                },
                {
                    "type": "p",
                    "text": "One difference from the prior example is that each derived class that contains a constructor functionmustcallsuper()which will execute the constructor of the base class.\nWhat’s more, before weeveraccess a property onthisin a constructor body, wehaveto callsuper().\nThis is an important rule that TypeScript will enforce."
                },
                {
                    "type": "p",
                    "text": "The example also shows how to override methods in the base class with methods that are specialized for the subclass.\nHere bothSnakeandHorsecreate amovemethod that overrides themovefromAnimal, giving it functionality specific to each class.\nNote that even thoughtomis declared as anAnimal, since its value is aHorse, callingtom.move(34)will call the overriding method inHorse:"
                },
                {
                    "type": "code",
                    "code": "Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Public, private, and protected modifiers"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Public by default"
                },
                {
                    "type": "p",
                    "text": "In our examples, we’ve been able to freely access the members that we declared throughout our programs.\nIf you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the wordpublicto accomplish this; for instance, C# requires that each member be explicitly labeledpublicto be visible.\nIn TypeScript, each member ispublicby default."
                },
                {
                    "type": "p",
                    "text": "You may still mark a memberpublicexplicitly.\nWe could have written theAnimalclass from the previous section in the following way:"
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{publicname:string;publicconstructor(theName:string) {this.name=theName;}publicmove(distanceInMeters:number) {console.log(`${this.name}moved${distanceInMeters}m.`);}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ECMAScript Private Fields"
                },
                {
                    "type": "p",
                    "text": "With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:"
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{#name:string;constructor(theName:string) {this.#name=theName;}}newAnimal(\"Cat\").#name;Property '#name' is not accessible outside class 'Animal' because it has a private identifier.18013Property '#name' is not accessible outside class 'Animal' because it has a private identifier.Try"
                },
                {
                    "type": "p",
                    "text": "This syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field.\nRight now, the best documentation for these private fields is in the TypeScript 3.8release notes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Understanding TypeScript’sprivate"
                },
                {
                    "type": "p",
                    "text": "TypeScript also has its own way to declare a member as being markedprivate, it cannot be accessed from outside of its containing class. For example:"
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{privatename:string;constructor(theName:string) {this.name=theName;}}newAnimal(\"Cat\").name;Property 'name' is private and only accessible within class 'Animal'.2341Property 'name' is private and only accessible within class 'Animal'.Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a structural type system.\nWhen we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible."
                },
                {
                    "type": "p",
                    "text": "However, when comparing types that haveprivateandprotectedmembers, we treat these types differently.\nFor two types to be considered compatible, if one of them has aprivatemember, then the other must have aprivatemember that originated in the same declaration.\nThe same applies toprotectedmembers."
                },
                {
                    "type": "p",
                    "text": "Let’s look at an example to better see how this plays out in practice:"
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{privatename:string;constructor(theName:string) {this.name=theName;}}classRhinoextendsAnimal{constructor() {super(\"Rhino\");}}classEmployee{privatename:string;constructor(theName:string) {this.name=theName;}}letanimal=newAnimal(\"Goat\");letrhino=newRhino();letemployee=newEmployee(\"Bob\");animal=rhino;animal=employee;Type 'Employee' is not assignable to type 'Animal'.\n  Types have separate declarations of a private property 'name'.2322Type 'Employee' is not assignable to type 'Animal'.\n  Types have separate declarations of a private property 'name'.Try"
                },
                {
                    "type": "p",
                    "text": "In this example, we have anAnimaland aRhino, withRhinobeing a subclass ofAnimal.\nWe also have a new classEmployeethat looks identical toAnimalin terms of shape.\nWe create some instances of these classes and then try to assign them to each other to see what will happen.\nBecauseAnimalandRhinoshare theprivateside of their shape from the same declaration ofprivate name: stringinAnimal, they are compatible. However, this is not the case forEmployee.\nWhen we try to assign from anEmployeetoAnimalwe get an error that these types are not compatible.\nEven thoughEmployeealso has aprivatemember calledname, it’s not the one we declared inAnimal."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Understandingprotected"
                },
                {
                    "type": "p",
                    "text": "Theprotectedmodifier acts much like theprivatemodifier with the exception that members declaredprotectedcan also be accessed within deriving classes. For example,"
                },
                {
                    "type": "code",
                    "code": "tsclassPerson{protectedname:string;constructor(name:string) {this.name=name;}}classEmployeeextendsPerson{privatedepartment:string;constructor(name:string,department:string) {super(name);this.department=department;}publicgetElevatorPitch() {return`Hello, my name is${this.name}and I work in${this.department}.`;}}lethoward=newEmployee(\"Howard\",\"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name);Property 'name' is protected and only accessible within class 'Person' and its subclasses.2445Property 'name' is protected and only accessible within class 'Person' and its subclasses.Try"
                },
                {
                    "type": "p",
                    "text": "Notice that while we can’t usenamefrom outside ofPerson, we can still use it from within an instance method ofEmployeebecauseEmployeederives fromPerson."
                },
                {
                    "type": "p",
                    "text": "A constructor may also be markedprotected.\nThis means that the class cannot be instantiated outside of its containing class, but can be extended. For example,"
                },
                {
                    "type": "code",
                    "code": "tsclassPerson{protectedname:string;protectedconstructor(theName:string) {this.name=theName;}}// Employee can extend PersonclassEmployeeextendsPerson{privatedepartment:string;constructor(name:string,department:string) {super(name);this.department=department;}publicgetElevatorPitch() {return`Hello, my name is${this.name}and I work in${this.department}.`;}}lethoward=newEmployee(\"Howard\",\"Sales\");letjohn=newPerson(\"John\");Constructor of class 'Person' is protected and only accessible within the class declaration.2674Constructor of class 'Person' is protected and only accessible within the class declaration.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Readonly modifier"
                },
                {
                    "type": "p",
                    "text": "You can make properties readonly by using thereadonlykeyword.\nReadonly properties must be initialized at their declaration or in the constructor."
                },
                {
                    "type": "code",
                    "code": "tsclassOctopus{readonlyname:string;readonlynumberOfLegs:number=8;constructor(theName:string) {this.name=theName;}}letdad=newOctopus(\"Man with the 8 strong legs\");dad.name=\"Man with the 3-piece suit\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Parameter properties"
                },
                {
                    "type": "p",
                    "text": "In our last example, we had to declare a readonly membernameand a constructor parametertheNamein theOctopusclass. This is needed in order to have the value oftheNameaccessible after theOctopusconstructor is executed.Parameter propertieslet you create and initialize a member in one place.\nHere’s a further revision of the previousOctopusclass using a parameter property:"
                },
                {
                    "type": "code",
                    "code": "tsclassOctopus{readonlynumberOfLegs:number=8;constructor(readonlyname:string) {}}letdad=newOctopus(\"Man with the 8 strong legs\");dad.name;Try"
                },
                {
                    "type": "p",
                    "text": "Notice how we droppedtheNamealtogether and just use the shortenedreadonly name: stringparameter on the constructor to create and initialize thenamemember.\nWe’ve consolidated the declarations and assignment into one location."
                },
                {
                    "type": "p",
                    "text": "Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier orreadonly, or both.\nUsingprivatefor a parameter property declares and initializes a private member; likewise, the same is done forpublic,protected, andreadonly."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Accessors"
                },
                {
                    "type": "p",
                    "text": "TypeScript supports getters/setters as a way of intercepting accesses to a member of an object.\nThis gives you a way of having finer-grained control over how a member is accessed on each object."
                },
                {
                    "type": "p",
                    "text": "Let’s convert a simple class to usegetandset.\nFirst, let’s start with an example without getters and setters."
                },
                {
                    "type": "code",
                    "code": "tsclassEmployee{fullName:string;}letemployee=newEmployee();employee.fullName=\"Bob Smith\";if(employee.fullName) {console.log(employee.fullName);}Try"
                },
                {
                    "type": "p",
                    "text": "While allowing people to randomly setfullNamedirectly is pretty handy, we may also want enforce some constraints whenfullNameis set."
                },
                {
                    "type": "p",
                    "text": "In this version, we add a setter that checks the length of thenewNameto make sure it’s compatible with the max-length of our backing database field. If it isn’t we throw an error notifying client code that something went wrong."
                },
                {
                    "type": "p",
                    "text": "To preserve existing functionality, we also add a simple getter that retrievesfullNameunmodified."
                },
                {
                    "type": "code",
                    "code": "tsconstfullNameMaxLength=10;classEmployee{private_fullName:string=\"\";getfullName():string{returnthis._fullName;}setfullName(newName:string) {if(newName&&newName.length>fullNameMaxLength) {thrownewError(\"fullName has a max length of \"+fullNameMaxLength);}this._fullName=newName;}}letemployee=newEmployee();employee.fullName=\"Bob Smith\";if(employee.fullName) {console.log(employee.fullName);}Try"
                },
                {
                    "type": "p",
                    "text": "To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error."
                },
                {
                    "type": "p",
                    "text": "A couple of things to note about accessors:"
                },
                {
                    "type": "p",
                    "text": "First, accessors require you to set the compiler to output ECMAScript 5 or higher.\nDownleveling to ECMAScript 3 is not supported.\nSecond, accessors with agetand nosetare automatically inferred to bereadonly.\nThis is helpful when generating a.d.tsfile from your code, because users of your property can see that they can’t change it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Static Properties"
                },
                {
                    "type": "p",
                    "text": "Up to this point, we’ve only talked about theinstancemembers of the class, those that show up on the object when it’s instantiated.\nWe can also createstaticmembers of a class, those that are visible on the class itself rather than on the instances.\nIn this example, we usestaticon the origin, as it’s a general value for all grids.\nEach instance accesses this value through prepending the name of the class.\nSimilarly to prependingthis.in front of instance accesses, here we prependGrid.in front of static accesses."
                },
                {
                    "type": "code",
                    "code": "tsclassGrid{staticorigin= {x:0,y:0};calculateDistanceFromOrigin(point: {x:number;y:number}) {letxDist=point.x-Grid.origin.x;letyDist=point.y-Grid.origin.y;returnMath.sqrt(xDist*xDist+yDist*yDist) /this.scale;}constructor(publicscale:number) {}}letgrid1=newGrid(1.0);// 1x scaleletgrid2=newGrid(5.0);// 5x scaleconsole.log(grid1.calculateDistanceFromOrigin({x:10,y:10}));console.log(grid2.calculateDistanceFromOrigin({x:10,y:10}));Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Abstract Classes"
                },
                {
                    "type": "p",
                    "text": "Abstract classes are base classes from which other classes may be derived.\nThey may not be instantiated directly.\nUnlike an interface, an abstract class may contain implementation details for its members.\nTheabstractkeyword is used to define abstract classes as well as abstract methods within an abstract class."
                },
                {
                    "type": "code",
                    "code": "tsabstractclassAnimal{abstractmakeSound():void;move():void{console.log(\"roaming the earth...\");}}Try"
                },
                {
                    "type": "p",
                    "text": "Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes.\nAbstract methods share a similar syntax to interface methods.\nBoth define the signature of a method without including a method body.\nHowever, abstract methods must include theabstractkeyword and may optionally include access modifiers."
                },
                {
                    "type": "code",
                    "code": "tsabstractclassDepartment{constructor(publicname:string) {}printName():void{console.log(\"Department name: \"+this.name);}abstractprintMeeting():void;// must be implemented in derived classes}classAccountingDepartmentextendsDepartment{constructor() {super(\"Accounting and Auditing\");// constructors in derived classes must call super()}printMeeting():void{console.log(\"The Accounting Department meets each Monday at 10am.\");}generateReports():void{console.log(\"Generating accounting reports...\");}}letdepartment:Department;// ok to create a reference to an abstract typedepartment=newDepartment();// error: cannot create an instance of an abstract classCannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.department=newAccountingDepartment();// ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();department.generateReports();// error: department is not of type AccountingDepartment, cannot access generateReportsProperty 'generateReports' does not exist on type 'Department'.2339Property 'generateReports' does not exist on type 'Department'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Advanced Techniques"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Constructor functions"
                },
                {
                    "type": "p",
                    "text": "When you declare a class in TypeScript, you are actually creating multiple declarations at the same time.\nThe first is the type of theinstanceof the class."
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{greeting:string;constructor(message:string) {this.greeting=message;}greet() {return\"Hello, \"+this.greeting;}}letgreeter:Greeter;greeter=newGreeter(\"world\");console.log(greeter.greet());// \"Hello, world\"Try"
                },
                {
                    "type": "p",
                    "text": "Here, when we saylet greeter: Greeter, we’re usingGreeteras the type of instances of the classGreeter.\nThis is almost second nature to programmers from other object-oriented languages."
                },
                {
                    "type": "p",
                    "text": "We’re also creating another value that we call theconstructor function.\nThis is the function that is called when wenewup instances of the class.\nTo see what this looks like in practice, let’s take a look at the JavaScript created by the above example:"
                },
                {
                    "type": "code",
                    "code": "tsletGreeter= (function() {functionGreeter(message) {this.greeting=message;}Greeter.prototype.greet=function() {return\"Hello, \"+this.greeting;};returnGreeter;})();letgreeter;greeter=newGreeter(\"world\");console.log(greeter.greet());// \"Hello, world\"Try"
                },
                {
                    "type": "p",
                    "text": "Here,let Greeteris going to be assigned the constructor function.\nWhen we callnewand run this function, we get an instance of the class.\nThe constructor function also contains all of the static members of the class.\nAnother way to think of each class is that there is aninstanceside and astaticside."
                },
                {
                    "type": "p",
                    "text": "Let’s modify the example a bit to show this difference:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{staticstandardGreeting=\"Hello, there\";greeting:string;greet() {if(this.greeting) {return\"Hello, \"+this.greeting;}else{returnGreeter.standardGreeting;}}}letgreeter1:Greeter;greeter1=newGreeter();console.log(greeter1.greet());// \"Hello, there\"letgreeterMaker:typeofGreeter=Greeter;greeterMaker.standardGreeting=\"Hey there!\";letgreeter2:Greeter=newgreeterMaker();console.log(greeter2.greet());// \"Hey there!\"letgreeter3:Greeter;greeter3=newGreeter();console.log(greeter3.greet());// \"Hey there!\"Try"
                },
                {
                    "type": "p",
                    "text": "In this example,greeter1works similarly to before.\nWe instantiate theGreeterclass, and use this object.\nThis we have seen before."
                },
                {
                    "type": "p",
                    "text": "Next, we then use the class directly.\nHere we create a new variable calledgreeterMaker.\nThis variable will hold the class itself, or said another way its constructor function.\nHere we usetypeof Greeter, that is “give me the type of theGreeterclass itself” rather than the instance type.\nOr, more precisely, “give me the type of the symbol calledGreeter,” which is the type of the constructor function.\nThis type will contain all of the static members of Greeter along with the constructor that creates instances of theGreeterclass.\nWe show this by usingnewongreeterMaker, creating new instances ofGreeterand invoking them as before.\nIt is also good to mention that changing static property is frowned upon, heregreeter3has\"Hey there!\"instead of\"Hello, there\"onstandardGreeting."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using a class as an interface"
                },
                {
                    "type": "p",
                    "text": "As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function.\nBecause classes create types, you can use them in the same places you would be able to use interfaces."
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{x:number;y:number;}interfacePoint3dextendsPoint{z:number;}letpoint3d:Point3d= {x:1,y:2,z:3};Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html",
            "title": "TypeScript: Documentation - Compiler Options in MSBuild",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Compiler Options in MSBuild"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Overview"
                },
                {
                    "type": "p",
                    "text": "When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via atsconfig.jsonor via the project settings."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using atsconfig.json"
                },
                {
                    "type": "p",
                    "text": "We recommend using atsconfig.jsonfor your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio."
                },
                {
                    "type": "p",
                    "text": "The newtsconfig.jsonwill then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learnabout how TSConfigs works hereand there is acomprehensive reference here."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Project Settings"
                },
                {
                    "type": "p",
                    "text": "You can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your.csprojto definePropertyGroupswhich describe how the build can work:"
                },
                {
                    "type": "code",
                    "code": "xml<PropertyGroup><TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError><TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns></PropertyGroup>"
                },
                {
                    "type": "p",
                    "text": "There is a series of mappings for common TypeScript settings, these are settings which map directly toTypeScript cli optionsand are used to help you write a more understandable project file. You can use theTSConfig referenceto get more information on what values and defaults are for each mapping."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "CLI Mappings"
                },
                {
                    "type": "p",
                    "text": "Allow JavaScript files to be a part of your program. Use thecheckJSoption to get errors from these files."
                },
                {
                    "type": "p",
                    "text": "Disable emitting comments."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for expressions and declarations with an impliedanytype.."
                },
                {
                    "type": "p",
                    "text": "Generate .d.ts files from TypeScript and JavaScript files in your project."
                },
                {
                    "type": "p",
                    "text": "Specify what module code is generated."
                },
                {
                    "type": "p",
                    "text": "Specify what JSX code is generated."
                },
                {
                    "type": "p",
                    "text": "Specify an output folder for all emitted files."
                },
                {
                    "type": "p",
                    "text": "Create source map files for emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."
                },
                {
                    "type": "p",
                    "text": "Disallowimports,requires or<reference>s from expanding the number of files TypeScript should add to a project."
                },
                {
                    "type": "p",
                    "text": "Specify the location where debugger should locate map files instead of generated locations."
                },
                {
                    "type": "p",
                    "text": "Specify the root path for debuggers to find the reference source code."
                },
                {
                    "type": "p",
                    "text": "No longer supported. In early versions, manually set the text encoding for reading files."
                },
                {
                    "type": "p",
                    "text": "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."
                },
                {
                    "type": "p",
                    "text": "Disable including any library files, including the default lib.d.ts."
                },
                {
                    "type": "p",
                    "text": "Disable erasingconst enumdeclarations in generated code."
                },
                {
                    "type": "p",
                    "text": "SuppressnoImplicitAnyerrors when indexing objects that lack index signatures."
                },
                {
                    "type": "p",
                    "text": "Disable generating custom helper functions like__extendsin compiled output."
                },
                {
                    "type": "p",
                    "text": "Include sourcemap files inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "Include source code in the sourcemaps inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "Set the newline character for emitting files."
                },
                {
                    "type": "p",
                    "text": "Ensure that each file can be safely transpiled without relying on other imports."
                },
                {
                    "type": "p",
                    "text": "Emit design-type metadata for decorated declarations in source files."
                },
                {
                    "type": "p",
                    "text": "Specify the root folder within your source files."
                },
                {
                    "type": "p",
                    "text": "Enable experimental support for TC39 stage 2 draft decorators."
                },
                {
                    "type": "p",
                    "text": "Specify how TypeScript looks up a file from a given module specifier."
                },
                {
                    "type": "p",
                    "text": "Disable reporting of excess property errors during the creation of object literals."
                },
                {
                    "type": "p",
                    "text": "Specify the object invoked forcreateElement. This only applies when targetingreactJSX emit."
                },
                {
                    "type": "p",
                    "text": "Skip type checking .d.ts files that are included with TypeScript."
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unused labels."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for codepaths that do not explicitly return in a function."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for fallthrough cases in switch statements."
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unreachable code."
                },
                {
                    "type": "p",
                    "text": "Ensure that casing is correct in imports."
                },
                {
                    "type": "p",
                    "text": "Allow 'import x from y' when a module doesn't have a default export."
                },
                {
                    "type": "p",
                    "text": "Disable adding 'use strict' directives in emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Specify a set of bundled library declaration files that describe the target runtime environment."
                },
                {
                    "type": "p",
                    "text": "Specify the base directory to resolve bare specifier module names."
                },
                {
                    "type": "p",
                    "text": "Specify the output directory for generated declaration files."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting whenthisis given the typeany."
                },
                {
                    "type": "p",
                    "text": "Skip type checking all .d.ts files."
                },
                {
                    "type": "p",
                    "text": "When type checking, take into accountnullandundefined."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting when a local variables aren't read."
                },
                {
                    "type": "p",
                    "text": "Raise an error when a function parameter isn't read"
                },
                {
                    "type": "p",
                    "text": "Ensure 'use strict' is always emitted."
                },
                {
                    "type": "p",
                    "text": "Allow importing helper functions from tslib once per project, instead of including them per-file."
                },
                {
                    "type": "p",
                    "text": "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'"
                },
                {
                    "type": "p",
                    "text": "Disable emitting declarations that have@internalin their JSDoc comments."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting in type-checked JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Emit more compliant, but verbose and less performant JavaScript for iteration."
                },
                {
                    "type": "p",
                    "text": "Enable all strict type checking options."
                },
                {
                    "type": "p",
                    "text": "Disable strict checking of generic signatures in function types."
                },
                {
                    "type": "p",
                    "text": "Disable resolving symlinks to their realpath. This correlates to the same flag in node."
                },
                {
                    "type": "p",
                    "text": "When assigning functions, check to ensure parameters and the return values are subtype-compatible."
                },
                {
                    "type": "p",
                    "text": "Check for class properties that are declared but not set in the constructor."
                },
                {
                    "type": "p",
                    "text": "Emit additional JavaScript to ease support for importing CommonJS modules. This enablesallowSyntheticDefaultImportsfor type compatibility."
                },
                {
                    "type": "p",
                    "text": "Only output d.ts files and not JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Make keyof only return strings instead of string, numbers or symbols. Legacy option."
                },
                {
                    "type": "p",
                    "text": "Emit ECMAScript-standard-compliant class fields."
                },
                {
                    "type": "p",
                    "text": "Create sourcemaps for d.ts files."
                },
                {
                    "type": "p",
                    "text": "Enable importing .json files"
                },
                {
                    "type": "p",
                    "text": "Check that the arguments forbind,call, andapplymethods match the original function."
                },
                {
                    "type": "p",
                    "text": "Disable emitting files if any type checking errors are reported."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Additional Flags"
                },
                {
                    "type": "p",
                    "text": "Because the MSBuild system passes arguments directly to the TypeScript CLI, you can use the optionTypeScriptAdditionalFlagsto provide specific flags which don’t have a mapping above."
                },
                {
                    "type": "p",
                    "text": "For example, this would turn onnoPropertyAccessFromIndexSignature:"
                },
                {
                    "type": "code",
                    "code": "xml<TypeScriptAdditionalFlags>$(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Debug and Release Builds"
                },
                {
                    "type": "p",
                    "text": "You can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:"
                },
                {
                    "type": "code",
                    "code": "xml<PropertyGroupCondition=\"'$(Configuration)' == 'Debug'\"><TypeScriptRemoveComments>false</TypeScriptRemoveComments><TypeScriptSourceMap>true</TypeScriptSourceMap></PropertyGroup><PropertyGroupCondition=\"'$(Configuration)' == 'Release'\"><TypeScriptRemoveComments>true</TypeScriptRemoveComments><TypeScriptSourceMap>false</TypeScriptSourceMap></PropertyGroup><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ToolsVersion"
                },
                {
                    "type": "p",
                    "text": "The value of<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>property in the project file identifies the compiler version to use to build (1.7 in this example).\nThis allows a project to build against the same versions of the compiler on different machines."
                },
                {
                    "type": "p",
                    "text": "IfTypeScriptToolsVersionis not specified, the latest compiler version installed on the machine will be used to build."
                },
                {
                    "type": "p",
                    "text": "Users using newer versions of TS, will see a prompt to upgrade their project on first load."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TypeScriptCompileBlocked"
                },
                {
                    "type": "p",
                    "text": "If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>in your project.\nThis should give you all the editing support, but not the build when you hit F5."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)"
                },
                {
                    "type": "p",
                    "text": "By default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation.\nHowever, if this behavior is causing issues, such as when TypeScript’sincrementaloption is enabled, set<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>to ensure the TypeScript compiler is invoked with every run of MSBuild."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html",
            "title": "TypeScript: Documentation - tsc CLI Options",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "tsc CLI Options"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using the CLI"
                },
                {
                    "type": "p",
                    "text": "Runningtsclocally will compile the closest project defined by atsconfig.json, or you can compile a set of TypeScript\nfiles by passing in a glob of files you want. When input files are specified on the command line,tsconfig.jsonfiles are\nignored."
                },
                {
                    "type": "code",
                    "code": "sh# Run a compile based on a backwards look through the fs for a tsconfig.jsontsc# Emit JS for just the index.ts with the compiler defaultstsc index.ts# Emit JS for any .ts files in the folder src, with the default settingstsc src/*.ts# Emit files referenced in with the compiler settings from tsconfig.production.jsontsc --project tsconfig.production.json# Emit d.ts files for a js file with showing compiler options which are booleanstsc index.js --declaration --emitDeclarationOnly# Emit a single .js file from two files via compiler options which take string argumentstsc app.ts util.ts --target esnext --outfile index.js"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Compiler Options"
                },
                {
                    "type": "p",
                    "text": "If you’re looking for more information about the compiler options in a tsconfig, check out theTSConfig Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "CLI Commands"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Show all compiler options."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Gives local information for help on the CLI."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Initializes a TypeScript project and creates a tsconfig.json file."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print names of files that are part of the compilation and then stop processing."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Set the language of the messaging from TypeScript. This does not affect emit."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print the final configuration instead of building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Print the compiler's version."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Build Options"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Build one or more projects and their dependencies, if out of date"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Delete the outputs of all projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Show what would be built (or deleted, if specified with '--clean')"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Build all projects, including those that appear to be up to date."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Enable verbose logging."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Watch Options"
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Remove a list of directories from the watch process."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Remove a list of files from the watch mode's processing."
                },
                {
                    "type": "p",
                    "text": "fixedinterval,priorityinterval,dynamicpriority, orfixedchunksize"
                },
                {
                    "type": "p",
                    "text": "Specify what approach the watcher should use if the system runs out of native file watchers."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Watch input files."
                },
                {
                    "type": "p",
                    "text": "usefsevents,fixedpollinginterval,dynamicprioritypolling, orfixedchunksizepolling"
                },
                {
                    "type": "p",
                    "text": "Specify how directories are watched on systems that lack recursive file-watching functionality."
                },
                {
                    "type": "p",
                    "text": "fixedpollinginterval,prioritypollinginterval,dynamicprioritypolling,fixedchunksizepolling,usefsevents, orusefseventsonparentdirectory"
                },
                {
                    "type": "p",
                    "text": "Specify how the TypeScript watch mode works."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Compiler Flags"
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable importing files with any extension, provided a declaration file is present."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow imports to include TypeScript file extensions."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow JavaScript files to be a part of your program. Use thecheckJSoption to get errors from these files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifesModuleInteropis enabled,moduleissystem, ormoduleResolutionisbundler;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Allow 'import x from y' when a module doesn't have a default export."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow accessing UMD globals from modules."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unreachable code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Disable error reporting for unused labels."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Ensure 'use strict' is always emitted."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Have recompiles in projects that useincrementalandwatchmode assume that changes within a file will only affect files directly depending on it."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the base directory to resolve bare specifier module names."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "utf8"
                },
                {
                    "type": "p",
                    "text": "No longer supported. In early versions, manually set the text encoding for reading files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting in type-checked JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable constraints that allow a TypeScript project to be used with project references."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Conditions to set in addition to the resolver-specific defaults when resolving imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Generate .d.ts files from TypeScript and JavaScript files in your project."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the output directory for generated declaration files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Create sourcemaps for d.ts files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Output compiler performance information after building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Reduce the number of projects loaded automatically by TypeScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Opt a project out of multi-project reference checking when editing."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable preferring source files instead of declaration files when referencing composite projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit more compliant, but verbose and less performant JavaScript for iteration."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Only output d.ts files and not JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Emit design-type metadata for decorated declarations in source files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifmoduleisnode16ornodenext;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Emit additional JavaScript to ease support for importing CommonJS modules. This enablesallowSyntheticDefaultImportsfor type compatibility."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Interpret optional property types as written, rather than addingundefined."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable experimental support for TC39 stage 2 draft decorators."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print files read during the compilation including why it was included."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Output more detailed compiler performance information after building."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "p",
                    "text": "Ensure that casing is correct in imports."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "profile.cpuprofile"
                },
                {
                    "type": "p",
                    "text": "Emit a v8 CPU profile of the compiler run for debugging."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Generates an event trace and a list of types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Allow importing helper functions from tslib once per project, instead of including them per-file."
                },
                {
                    "type": "p",
                    "text": "remove,preserve, orerror"
                },
                {
                    "type": "p",
                    "text": "remove"
                },
                {
                    "type": "p",
                    "text": "Specify emit/checking behavior for imports that are only used for types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Save .tsbuildinfo files to allow for incremental compilation of projects."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Include sourcemap files inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Include source code in the sourcemaps inside the emitted JavaScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Require sufficient annotation on exports so other tools can trivially generate declaration files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifverbatimModuleSyntax;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Ensure that each file can be safely transpiled without relying on other imports."
                },
                {
                    "type": "p",
                    "text": "preserve,react,react-native,react-jsx, orreact-jsxdev"
                },
                {
                    "type": "p",
                    "text": "Specify what JSX code is generated."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React.createElement"
                },
                {
                    "type": "p",
                    "text": "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React.Fragment"
                },
                {
                    "type": "p",
                    "text": "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "react"
                },
                {
                    "type": "p",
                    "text": "Specify module specifier used to import the JSX factory functions when usingjsx: react-jsx*."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Make keyof only return strings instead of string, numbers or symbols. Legacy option."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify a set of bundled library declaration files that describe the target runtime environment."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print the names of emitted files after a compilation."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Print all of the files read during the compilation."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the location where debugger should locate map files instead of generated locations."
                },
                {
                    "type": "p",
                    "text": "number"
                },
                {
                    "type": "p",
                    "text": "0"
                },
                {
                    "type": "p",
                    "text": "Specify the maximum folder depth used for checking JavaScript files fromnode_modules. Only applicable withallowJs."
                },
                {
                    "type": "p",
                    "text": "none,commonjs,amd,umd,system,es6/es2015,es2020,es2022,esnext,node16,nodenext, orpreserve"
                },
                {
                    "type": "p",
                    "text": "CommonJSiftargetisES5;ES6/ES2015otherwise."
                },
                {
                    "type": "p",
                    "text": "Specify what module code is generated."
                },
                {
                    "type": "p",
                    "text": "legacy,auto, orforce"
                },
                {
                    "type": "p",
                    "text": "\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."
                },
                {
                    "type": "p",
                    "text": "Specify what method is used to detect whether a file is a script or a module."
                },
                {
                    "type": "p",
                    "text": "classic,node10/node,node16,nodenext, orbundler"
                },
                {
                    "type": "p",
                    "text": "ClassicifmoduleisAMD,UMD,System, orES6/ES2015; Matches ifmoduleisnode16ornodenext;Nodeotherwise."
                },
                {
                    "type": "p",
                    "text": "Specify how TypeScript looks up a file from a given module specifier."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "List of file name suffixes to search when resolving a module."
                },
                {
                    "type": "p",
                    "text": "crlforlf"
                },
                {
                    "type": "p",
                    "text": "lf"
                },
                {
                    "type": "p",
                    "text": "Set the newline character for emitting files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable full type checking (only critical parse and emit errors will be reported)."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting files from a compilation."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable generating custom helper functions like__extendsin compiled output."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting files if any type checking errors are reported."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable truncating types in error messages."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for fallthrough cases in switch statements."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for expressions and declarations with an impliedanytype."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Ensure overriding members in derived classes are marked with an override modifier."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting for codepaths that do not explicitly return in a function."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Enable error reporting whenthisis given the typeany."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable adding 'use strict' directives in emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable including any library files, including the default lib.d.ts."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enforces using indexed accessors for keys declared using an indexed type."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disallowimports,requires or<reference>s from expanding the number of files TypeScript should add to a project."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable strict checking of generic signatures in function types."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Addundefinedto a type when accessed using an index."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Check side effect imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable error reporting when local variables aren't read."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Raise an error when a function parameter isn't read."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Deprecated setting. UseoutFileinstead."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify an output folder for all emitted files."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify a file that bundles all outputs into one JavaScript file. Ifdeclarationis true, also designates a file that bundles all .d.ts output."
                },
                {
                    "type": "p",
                    "text": "object"
                },
                {
                    "type": "p",
                    "text": "Specify a set of entries that re-map imports to additional lookup locations."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify a list of language service plugins to include."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifisolatedModules;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Disable erasingconst enumdeclarations in generated code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable resolving symlinks to their realpath. This correlates to the same flag in node."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Preserve unused imported values in the JavaScript output that would otherwise be removed."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable wiping the console in watch mode."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "p",
                    "text": "Enable color and formatting in TypeScript's output to make compiler errors easier to read."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "React"
                },
                {
                    "type": "p",
                    "text": "Specify the object invoked forcreateElement. This only applies when targetingreactJSX emit."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting comments."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable importing .json files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "p",
                    "text": "Use the package.json 'exports' field when resolving package imports."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "p",
                    "text": "Use the package.json 'imports' field when resolving imports."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "Specify the root folder within your source files."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "Allow multiple folders to be treated as one when resolving modules."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Skip type checking .d.ts files that are included with TypeScript."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Skip type checking all .d.ts files."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Create source map files for emitted JavaScript files."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": "Specify the root path for debuggers to find the reference source code."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "Skip building downstream projects on error in upstream project."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Enable all strict type-checking options."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Check that the arguments forbind,call, andapplymethods match the original function."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false, unlessstrictis set"
                },
                {
                    "type": "p",
                    "text": "Built-in iterators are instantiated with a TReturn type of undefined instead of any."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "When assigning functions, check to ensure parameters and the return values are subtype-compatible."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "When type checking, take into accountnullandundefined."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Check for class properties that are declared but not set in the constructor."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable emitting declarations that have@internalin their JSDoc comments."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Disable reporting of excess property errors during the creation of object literals."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "SuppressnoImplicitAnyerrors when indexing objects that lack index signatures."
                },
                {
                    "type": "p",
                    "text": "es3,es5,es6/es2015,es2016,es2017,es2018,es2019,es2020,es2021,es2022,es2023, oresnext"
                },
                {
                    "type": "p",
                    "text": "ES5"
                },
                {
                    "type": "p",
                    "text": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Log paths used during themoduleResolutionprocess."
                },
                {
                    "type": "p",
                    "text": "string"
                },
                {
                    "type": "p",
                    "text": ".tsbuildinfo"
                },
                {
                    "type": "p",
                    "text": "The file to store.tsbuildinfoincremental build information in."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify multiple folders that act like./node_modules/@types."
                },
                {
                    "type": "p",
                    "text": "list"
                },
                {
                    "type": "p",
                    "text": "Specify type package names to be included without being referenced in a source file."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueiftargetisES2022or higher, includingESNext;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Emit ECMAScript-standard-compliant class fields."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "Default catch clause variables asunknowninstead ofany."
                },
                {
                    "type": "p",
                    "text": "boolean"
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Related"
                },
                {
                    "type": "list",
                    "items": [
                        "Every option is fully explained in theTSConfig Reference.",
                        "Learn how to use atsconfig.jsonfile.",
                        "Learn how to work in anMSBuild project."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/configuring-watch.html",
            "title": "TypeScript: Documentation - Configuring Watch",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Configuring Watch"
                },
                {
                    "type": "p",
                    "text": "As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Background"
                },
                {
                    "type": "p",
                    "text": "The--watchimplementation of the compiler relies on Node’sfs.watchandfs.watchFile. Each of these methods has pros and cons."
                },
                {
                    "type": "p",
                    "text": "fs.watchrelies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors ofLinux). Heavy use offs.watchin large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically usesfs.watchto watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching."
                },
                {
                    "type": "p",
                    "text": "fs.watchFileuses polling and thus costs CPU cycles. However,fs.watchFileis by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically usesfs.watchFileto watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when usingfs.watchFiledepends directly on number of files watched in the codebase."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Configuring file watching using atsconfig.json"
                },
                {
                    "type": "p",
                    "text": "The suggested method of configuring watch behavior is through the newwatchOptionssection oftsconfig.json. We provide an example configuration below. See the following section for detailed descriptions of the settings available."
                },
                {
                    "type": "code",
                    "code": "{// Some typical compiler options\"compilerOptions\": {\"target\":\"es2020\",\"moduleResolution\":\"node\"// ...},// NEW: Options for file/directory watching\"watchOptions\": {// Use native file system events for files and directories\"watchFile\":\"useFsEvents\",\"watchDirectory\":\"useFsEvents\",// Poll files for updates more frequently// when they're updated a lot.\"fallbackPolling\":\"dynamicPriority\",// Don't coalesce watch notification\"synchronousWatchDirectory\":true,// Finally, two additional settings for reducing the amount of possible// files to track  work from these directories\"excludeDirectories\": [\"**/node_modules\",\"_build\"],\"excludeFiles\": [\"build/fileWhichChangesOften.ts\"]}}"
                },
                {
                    "type": "p",
                    "text": "For further details, seethe release notes for Typescript 3.8."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Configuring file watching using environment variableTSC_WATCHFILE"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Configuring directory watching using environment variableTSC_WATCHDIRECTORY"
                },
                {
                    "type": "p",
                    "text": "For directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected byTSC_WATCHDIRECTORY."
                },
                {
                    "type": "p",
                    "text": "NOTE:On platforms which support native recursive directory watching, the value ofTSC_WATCHDIRECTORYis ignored."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html",
            "title": "TypeScript: Documentation - Declaration Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Declaration Reference"
                },
                {
                    "type": "p",
                    "text": "The purpose of this guide is to teach you how to write a high-quality definition file.\nThis guide is structured by showing documentation for some API, along with sample usage of that API,\nand explaining how to write the corresponding declaration."
                },
                {
                    "type": "p",
                    "text": "These examples are ordered in approximately increasing order of complexity."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Objects with Properties"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "The global variablemyLibhas a functionmakeGreetingfor creating greetings,\nand a propertynumberOfGreetingsindicating the number of greetings made so far."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsletresult=myLib.makeGreeting(\"hello, world\");console.log(\"The computed greeting is:\"+result);letcount=myLib.numberOfGreetings;"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Usedeclare namespaceto describe types or values accessed by dotted notation."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacemyLib{functionmakeGreeting(s:string):string;letnumberOfGreetings:number;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Overloaded Functions"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "ThegetWidgetfunction accepts a number and returns a Widget, or accepts a string and returns a Widget array."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsletx:Widget=getWidget(43);letarr:Widget[] =getWidget(\"all of them\");"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongetWidget(n:number):Widget;declarefunctiongetWidget(s:string):Widget[];"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reusable Types (Interfaces)"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "When specifying a greeting, you must pass aGreetingSettingsobject.\nThis object has the following properties:"
                },
                {
                    "type": "p",
                    "text": "1 - greeting: Mandatory string"
                },
                {
                    "type": "p",
                    "text": "2 - duration: Optional length of time (in milliseconds)"
                },
                {
                    "type": "p",
                    "text": "3 - color: Optional string, e.g. ‘#ff00ff’"
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsgreet({greeting:\"hello world\",duration:4000});"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Use aninterfaceto define a type with properties."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGreetingSettings{greeting:string;duration?:number;color?:string;}declarefunctiongreet(setting:GreetingSettings):void;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reusable Types (Type Aliases)"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "Anywhere a greeting is expected, you can provide astring, a function returning astring, or aGreeterinstance."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetGreeting() {return\"howdy\";}classMyGreeterextendsGreeter{}greet(\"hello\");greet(getGreeting);greet(newMyGreeter());"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "You can use a type alias to make a shorthand for a type:"
                },
                {
                    "type": "code",
                    "code": "tstypeGreetingLike=string| (()=>string) |MyGreeter;declarefunctiongreet(g:GreetingLike):void;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Organizing Types"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "Thegreeterobject can log to a file or display an alert.\nYou can provide LogOptions to.log(...)and alert options to.alert(...)"
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconstg=newGreeter(\"Hello\");g.log({verbose:true});g.alert({modal:false,title:\"Current Greeting\"});"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Use namespaces to organize types."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceGreetingLib{interfaceLogOptions{verbose?:boolean;}interfaceAlertOptions{modal:boolean;title?:string;color?:string;}}"
                },
                {
                    "type": "p",
                    "text": "You can also create nested namespaces in one declaration:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceGreetingLib.Options{// Refer to via GreetingLib.Options.LoginterfaceLog{verbose?:boolean;}interfaceAlert{modal:boolean;title?:string;color?:string;}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "You can create a greeter by instantiating theGreeterobject, or create a customized greeter by extending from it."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconstmyGreeter=newGreeter(\"hello, world\");myGreeter.greeting=\"howdy\";myGreeter.showGreeting();classSpecialGreeterextendsGreeter{constructor() {super(\"Very special greetings\");}}"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Usedeclare classto describe a class or class-like object.\nClasses can have properties and methods as well as a constructor."
                },
                {
                    "type": "code",
                    "code": "tsdeclareclassGreeter{constructor(greeting:string);greeting:string;showGreeting():void;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global Variables"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "The global variablefoocontains the number of widgets present."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsconsole.log(\"Half the number of widgets is \"+foo/2);"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Usedeclare varto declare variables.\nIf the variable is read-only, you can usedeclare const.\nYou can also usedeclare letif the variable is block-scoped."
                },
                {
                    "type": "code",
                    "code": "ts/** The number of widgets present */declarevarfoo:number;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global Functions"
                },
                {
                    "type": "p",
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "You can call the functiongreetwith a string to show a greeting to the user."
                },
                {
                    "type": "p",
                    "text": "Code"
                },
                {
                    "type": "code",
                    "code": "tsgreet(\"hello, world\");"
                },
                {
                    "type": "p",
                    "text": "Declaration"
                },
                {
                    "type": "p",
                    "text": "Usedeclare functionto declare functions."
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongreet(greeting:string):void;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Introduction"
                },
                {
                    "type": "p",
                    "text": "How to write a high-quality TypeScript Declaration (d.ts) file"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Library Structures"
                },
                {
                    "type": "p",
                    "text": "How to structure your d.ts files"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html",
            "title": "TypeScript: Documentation - Consumption",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Consumption"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Downloading"
                },
                {
                    "type": "p",
                    "text": "Getting type declarations requires no tools apart from npm."
                },
                {
                    "type": "p",
                    "text": "As an example, getting the declarations for a library like lodash takes nothing more than the following command"
                },
                {
                    "type": "code",
                    "code": "cmdnpminstall--save-dev@types/lodash"
                },
                {
                    "type": "p",
                    "text": "It is worth noting that if the npm package already includes its declaration file as described inPublishing, downloading the corresponding@typespackage is not needed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Consuming"
                },
                {
                    "type": "p",
                    "text": "From there you’ll be able to use lodash in your TypeScript code with no fuss.\nThis works for both modules and global code."
                },
                {
                    "type": "p",
                    "text": "For example, once you’venpm install-ed your type declarations, you can use imports and write"
                },
                {
                    "type": "code",
                    "code": "tsimport*as_from\"lodash\";_.padStart(\"Hello TypeScript!\",20,\" \");"
                },
                {
                    "type": "p",
                    "text": "or if you’re not using modules, you can just use the global variable_."
                },
                {
                    "type": "code",
                    "code": "ts_.padStart(\"Hello TypeScript!\",20,\" \");"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Searching"
                },
                {
                    "type": "p",
                    "text": "For the most part, type declaration packages should always have the same name as the package name onnpm, but prefixed with@types/,\nbut if you need, you can use theYarn package searchto find the package for your favorite library."
                },
                {
                    "type": "p",
                    "text": "Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it.\nPlease see the DefinitelyTypedcontribution guidelines pagefor details."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Publishing"
                },
                {
                    "type": "p",
                    "text": "How to get your d.ts files to users"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html",
            "title": "TypeScript: Documentation - Deep Dive",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Declaration File Theory: A Deep Dive"
                },
                {
                    "type": "p",
                    "text": "Structuring modules to give the exact API shape you want can be tricky.\nFor example, we might want a module that can be invoked with or withoutnewto produce different types,\nhas a variety of named types exposed in a hierarchy,\nand has some properties on the module object as well."
                },
                {
                    "type": "p",
                    "text": "By reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface.\nThis guide focuses on module (or UMD) libraries because the options here are more varied."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Key Concepts"
                },
                {
                    "type": "p",
                    "text": "You can fully understand how to make any shape of declaration\nby understanding some key concepts of how TypeScript works."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Types"
                },
                {
                    "type": "p",
                    "text": "If you’re reading this guide, you probably already roughly know what a type in TypeScript is.\nTo be more explicit, though, atypeis introduced with:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type alias declaration (type sn = number | string;)",
                        "An interface declaration (interface I { x: number[]; })",
                        "A class declaration (class C { })",
                        "An enum declaration (enum E { A, B, C })",
                        "Animportdeclaration which refers to a type"
                    ]
                },
                {
                    "type": "p",
                    "text": "Each of these declaration forms creates a new type name."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Values"
                },
                {
                    "type": "p",
                    "text": "As with types, you probably already understand what a value is.\nValues are runtime names that we can reference in expressions.\nFor examplelet x = 5;creates a value calledx."
                },
                {
                    "type": "p",
                    "text": "Again, being explicit, the following things create values:"
                },
                {
                    "type": "list",
                    "items": [
                        "let,const, andvardeclarations",
                        "Anamespaceormoduledeclaration which contains a value",
                        "Anenumdeclaration",
                        "Aclassdeclaration",
                        "Animportdeclaration which refers to a value",
                        "Afunctiondeclaration"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Namespaces"
                },
                {
                    "type": "p",
                    "text": "Types can exist innamespaces.\nFor example, if we have the declarationlet x: A.B.C,\nwe say that the typeCcomes from theA.Bnamespace."
                },
                {
                    "type": "p",
                    "text": "This distinction is subtle and important — here,A.Bis not necessarily a type or a value."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Simple Combinations: One name, multiple meanings"
                },
                {
                    "type": "p",
                    "text": "Given a nameA, we might find up to three different meanings forA: a type, a value or a namespace.\nHow the name is interpreted depends on the context in which it is used.\nFor example, in the declarationlet m: A.A = A;,Ais used first as a namespace, then as a type name, then as a value.\nThese meanings might end up referring to entirely different declarations!"
                },
                {
                    "type": "p",
                    "text": "This may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things.\nLet’s look at some useful aspects of this combining behavior."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Built-in Combinations"
                },
                {
                    "type": "p",
                    "text": "Astute readers will notice that, for example,classappeared in both thetypeandvaluelists.\nThe declarationclass C { }creates two things:\natypeCwhich refers to the instance shape of the class,\nand avalueCwhich refers to the constructor function of the class.\nEnum declarations behave similarly."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "User Combinations"
                },
                {
                    "type": "p",
                    "text": "Let’s say we wrote a module filefoo.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportvarSomeVar: {a:SomeType};exportinterfaceSomeType{count:number;}"
                },
                {
                    "type": "p",
                    "text": "Then consumed it:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfoofrom\"./foo\";letx:foo.SomeType=foo.SomeVar.a;console.log(x.count);"
                },
                {
                    "type": "p",
                    "text": "This works well enough, but we might imagine thatSomeTypeandSomeVarwere very closely related\nsuch that you’d like them to have the same name.\nWe can use combining to present these two different objects (the value and the type) under the same nameBar:"
                },
                {
                    "type": "code",
                    "code": "tsexportvarBar: {a:Bar};exportinterfaceBar{count:number;}"
                },
                {
                    "type": "p",
                    "text": "This presents a very good opportunity for destructuring in the consuming code:"
                },
                {
                    "type": "code",
                    "code": "tsimport{Bar}from\"./foo\";letx:Bar=Bar.a;console.log(x.count);"
                },
                {
                    "type": "p",
                    "text": "Again, we’ve usedBaras both a type and a value here.\nNote that we didn’t have to declare theBarvalue as being of theBartype — they’re independent."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Advanced Combinations"
                },
                {
                    "type": "p",
                    "text": "Some kinds of declarations can be combined across multiple declarations.\nFor example,class C { }andinterface C { }can co-exist and both contribute properties to theCtypes."
                },
                {
                    "type": "p",
                    "text": "This is legal as long as it does not create a conflict.\nA general rule of thumb is that values always conflict with other values of the same name unless they are declared asnamespaces,\ntypes will conflict if they are declared with a type alias declaration (type s = string),\nand namespaces never conflict."
                },
                {
                    "type": "p",
                    "text": "Let’s see how this can be used."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding using aninterface"
                },
                {
                    "type": "p",
                    "text": "We can add additional members to aninterfacewith anotherinterfacedeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceFoo{x:number;}// ... elsewhere ...interfaceFoo{y:number;}leta:Foo= ...;console.log(a.x+a.y);// OK"
                },
                {
                    "type": "p",
                    "text": "This also works with classes:"
                },
                {
                    "type": "code",
                    "code": "tsclassFoo{x:number;}// ... elsewhere ...interfaceFoo{y:number;}leta:Foo= ...;console.log(a.x+a.y);// OK"
                },
                {
                    "type": "p",
                    "text": "Note that we cannot add to type aliases (type s = string;) using an interface."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding using anamespace"
                },
                {
                    "type": "p",
                    "text": "Anamespacedeclaration can be used to add new types, values, and namespaces in any way which does not create a conflict."
                },
                {
                    "type": "p",
                    "text": "For example, we can add a static member to a class:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{}// ... elsewhere ...namespaceC{exportletx:number;}lety=C.x;// OK"
                },
                {
                    "type": "p",
                    "text": "Note that in this example, we added a value to thestaticside ofC(its constructor function).\nThis is because we added avalue, and the container for all values is another value\n(types are contained by namespaces, and namespaces are contained by other namespaces)."
                },
                {
                    "type": "p",
                    "text": "We could also add a namespaced type to a class:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{}// ... elsewhere ...namespaceC{exportinterfaceD{}}lety:C.D;// OK"
                },
                {
                    "type": "p",
                    "text": "In this example, there wasn’t a namespaceCuntil we wrote thenamespacedeclaration for it.\nThe meaningCas a namespace doesn’t conflict with the value or type meanings ofCcreated by the class."
                },
                {
                    "type": "p",
                    "text": "Finally, we could perform many different merges usingnamespacedeclarations.\nThis isn’t a particularly realistic example, but shows all sorts of interesting behavior:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceX{exportinterfaceY{}exportclassZ{}}// ... elsewhere ...namespaceX{exportvarY:number;exportnamespaceZ{exportclassC{}}}typeX=string;"
                },
                {
                    "type": "p",
                    "text": "In this example, the first block creates the following name meanings:"
                },
                {
                    "type": "list",
                    "items": [
                        "A valueX(because thenamespacedeclaration contains a value,Z)",
                        "A namespaceX(because thenamespacedeclaration contains a type,Y)",
                        "A typeYin theXnamespace",
                        "A typeZin theXnamespace (the instance shape of the class)",
                        "A valueZthat is a property of theXvalue (the constructor function of the class)"
                    ]
                },
                {
                    "type": "p",
                    "text": "The second block creates the following name meanings:"
                },
                {
                    "type": "list",
                    "items": [
                        "A valueY(of typenumber) that is a property of theXvalue",
                        "A namespaceZ",
                        "A valueZthat is a property of theXvalue",
                        "A typeCin theX.Znamespace",
                        "A valueCthat is a property of theX.Zvalue",
                        "A typeX"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Do's and Don'ts"
                },
                {
                    "type": "p",
                    "text": "Recommendations for writing d.ts files"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Publishing"
                },
                {
                    "type": "p",
                    "text": "How to get your d.ts files to users"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
            "title": "TypeScript: Documentation - Do's and Don'ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Do's and Don'ts"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "General Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Number,String,Boolean,SymbolandObject"
                },
                {
                    "type": "p",
                    "text": "❌Don’tever use the typesNumber,String,Boolean,Symbol, orObjectThese types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code."
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */functionreverse(s:String):String;"
                },
                {
                    "type": "p",
                    "text": "✅Douse the typesnumber,string,boolean, andsymbol."
                },
                {
                    "type": "code",
                    "code": "ts/* OK */functionreverse(s:string):string;"
                },
                {
                    "type": "p",
                    "text": "Instead ofObject, use the non-primitiveobjecttype (added in TypeScript 2.2)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "❌Don’tever have a generic type which doesn’t use its type parameter.\nSee more details inTypeScript FAQ page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "any"
                },
                {
                    "type": "p",
                    "text": "❌Don’tuseanyas a type unless you are in the process of migrating a JavaScript project to TypeScript. The compilereffectivelytreatsanyas “please turn off type checking for this thing”. It is similar to putting an@ts-ignorecomment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet asany, but in a full TypeScript project you are disabling type checking for any parts of your program that use it."
                },
                {
                    "type": "p",
                    "text": "In cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can useunknown."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Callback Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Return Types of Callbacks"
                },
                {
                    "type": "p",
                    "text": "❌Don’tuse the return typeanyfor callbacks whose value will be ignored:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */functionfn(x: ()=>any) {x();}"
                },
                {
                    "type": "p",
                    "text": "✅Douse the return typevoidfor callbacks whose value will be ignored:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */functionfn(x: ()=>void) {x();}"
                },
                {
                    "type": "p",
                    "text": "❔Why:Usingvoidis safer because it prevents you from accidentally using the return value ofxin an unchecked way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x: ()=>void) {vark=x();// oops! meant to do something elsek.doSomething();// error, but would be OK if the return type had been 'any'}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Parameters in Callbacks"
                },
                {
                    "type": "p",
                    "text": "❌Don’tuse optional parameters in callbacks unless you really mean it:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceFetcher{getObject(done: (data:unknown,elapsedTime?:number)=>void):void;}"
                },
                {
                    "type": "p",
                    "text": "This has a very specific meaning: thedonecallback might be invoked with 1 argument or might be invoked with 2 arguments.\nThe author probably intended to say that the callback might not care about theelapsedTimeparameter,\nbut there’s no need to make the parameter optional to accomplish this —\nit’s always legal to provide a callback that accepts fewer arguments."
                },
                {
                    "type": "p",
                    "text": "✅Dowrite callback parameters as non-optional:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceFetcher{getObject(done: (data:unknown,elapsedTime:number)=>void):void;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Overloads and Callbacks"
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite separate overloads that differ only on callback arity:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */declarefunctionbeforeAll(action: ()=>void,timeout?:number):void;declarefunctionbeforeAll(action: (done:DoneFn)=>void,timeout?:number):void;"
                },
                {
                    "type": "p",
                    "text": "✅Dowrite a single overload using the maximum arity:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */declarefunctionbeforeAll(action: (done:DoneFn)=>void,timeout?:number):void;"
                },
                {
                    "type": "p",
                    "text": "❔Why:It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload.\nProviding a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function Overloads"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Ordering"
                },
                {
                    "type": "p",
                    "text": "❌Don’tput more general overloads before more specific overloads:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */declarefunctionfn(x:unknown):unknown;declarefunctionfn(x:HTMLElement):number;declarefunctionfn(x:HTMLDivElement):string;varmyElem:HTMLDivElement;varx=fn(myElem);// x: unknown, wat?"
                },
                {
                    "type": "p",
                    "text": "✅Dosort overloads by putting the more general signatures after more specific signatures:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */declarefunctionfn(x:HTMLDivElement):string;declarefunctionfn(x:HTMLElement):number;declarefunctionfn(x:unknown):unknown;varmyElem:HTMLDivElement;varx=fn(myElem);// x: string, :)"
                },
                {
                    "type": "p",
                    "text": "❔Why:TypeScript chooses thefirst matching overloadwhen resolving function calls.\nWhen an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Use Optional Parameters"
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite several overloads that differ only in trailing parameters:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceExample{diff(one:string):number;diff(one:string,two:string):number;diff(one:string,two:string,three:boolean):number;}"
                },
                {
                    "type": "p",
                    "text": "✅Douse optional parameters whenever possible:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceExample{diff(one:string,two?:string,three?:boolean):number;}"
                },
                {
                    "type": "p",
                    "text": "Note that this collapsing should only occur when all overloads have the same return type."
                },
                {
                    "type": "p",
                    "text": "❔Why:This is important for two reasons."
                },
                {
                    "type": "p",
                    "text": "TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source,and extraneous arguments are allowed.\nThis code, for example, exposes a bug only when the signature is correctly written using optional parameters:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x: (a:string,b:number,c:number)=>void) {}varx:Example;// When written with overloads, OK -- used first overload// When written with optionals, correctly an errorfn(x.diff);"
                },
                {
                    "type": "p",
                    "text": "The second reason is when a consumer uses the “strict null checking” feature of TypeScript.\nBecause unspecified parameters appear asundefinedin JavaScript, it’s usually fine to pass an explicitundefinedto a function with optional arguments.\nThis code, for example, should be OK under strict nulls:"
                },
                {
                    "type": "code",
                    "code": "tsvarx:Example;// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'// When written with optionals, correctly OKx.diff(\"something\",true?undefined:\"hour\");"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Use Union Types"
                },
                {
                    "type": "p",
                    "text": "❌Don’twrite overloads that differ by type in only one argument position:"
                },
                {
                    "type": "code",
                    "code": "ts/* WRONG */interfaceMoment{utcOffset():number;utcOffset(b:number):Moment;utcOffset(b:string):Moment;}"
                },
                {
                    "type": "p",
                    "text": "✅Douse union types whenever possible:"
                },
                {
                    "type": "code",
                    "code": "ts/* OK */interfaceMoment{utcOffset():number;utcOffset(b:number|string):Moment;}"
                },
                {
                    "type": "p",
                    "text": "Note that we didn’t makeboptional here because the return types of the signatures differ."
                },
                {
                    "type": "p",
                    "text": "❔Why:This is important for people who are “passing through” a value to your function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string):Moment;functionfn(x:number):Moment;functionfn(x:number|string) {// When written with separate overloads, incorrectly an error// When written with union types, correctly OKreturnmoment().utcOffset(x);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deep Dive"
                },
                {
                    "type": "p",
                    "text": "How do d.ts files work, a deep dive"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html",
            "title": "TypeScript: Documentation - Creating .d.ts Files from .js files",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Creating .d.ts Files from .js files"
                },
                {
                    "type": "p",
                    "text": "With TypeScript 3.7,\nTypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax."
                },
                {
                    "type": "p",
                    "text": "This set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase.\nTypeScript supports most JSDoc tags, you can findthe reference here."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Setting up your Project to emit .d.ts files"
                },
                {
                    "type": "p",
                    "text": "To add creation of .d.ts files in your project, you will need to do up-to four steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Add TypeScript to your dev dependencies",
                        "Add atsconfig.jsonto configure TypeScript",
                        "Run the TypeScript compiler to generate the corresponding d.ts files for JS files",
                        "(optional) Edit your package.json to reference the types"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding TypeScript"
                },
                {
                    "type": "p",
                    "text": "You can learn how to do this in ourinstallation page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TSConfig"
                },
                {
                    "type": "p",
                    "text": "The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files.\nIn this case, you will want a file like the following:"
                },
                {
                    "type": "code",
                    "code": "{// Change this to match your project\"include\": [\"src/**/*\"],\"compilerOptions\": {// Tells TypeScript to read JS files, as// normally they are ignored as source files\"allowJs\":true,// Generate d.ts files\"declaration\":true,// This compiler run should// only output d.ts files\"emitDeclarationOnly\":true,// Types should go into this directory.// Removing this would place the .d.ts files// next to the .js files\"outDir\":\"dist\",// go to js file when using IDE functions like// \"Go to Definition\" in VSCode\"declarationMap\":true}}"
                },
                {
                    "type": "p",
                    "text": "You can learn more about the options in thetsconfig reference.\nAn alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command."
                },
                {
                    "type": "code",
                    "code": "shnpx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Run the compiler"
                },
                {
                    "type": "p",
                    "text": "You can learn how to do this in ourinstallation page.\nYou want to make sure these files are included in your package if you have the files in your project’s.gitignore."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Editing the package.json"
                },
                {
                    "type": "p",
                    "text": "TypeScript replicates the node resolution for modules in apackage.json, with an additional step for finding .d.ts files.\nRoughly, the resolution will first check the optionaltypesfield, then the\"main\"field, and finally will tryindex.d.tsin the root."
                },
                {
                    "type": "p",
                    "text": "If absent, then “main” is used"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Tips"
                },
                {
                    "type": "p",
                    "text": "If you’d like to write tests for your .d.ts files, trytsd."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "JSDoc Reference"
                },
                {
                    "type": "p",
                    "text": "What JSDoc does TypeScript-powered JavaScript support?"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html",
            "title": "TypeScript: Documentation - Introduction",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Introduction"
                },
                {
                    "type": "p",
                    "text": "The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started."
                },
                {
                    "type": "p",
                    "text": "If you haven’t already, you should read theTypeScript Handbookto familiarize yourself with basic concepts, especially types and modules."
                },
                {
                    "type": "p",
                    "text": "The most common case for learning how .d.ts files work is that you’re typing an npm package with no types.\nIn that case, you can jump straight toModules .d.ts."
                },
                {
                    "type": "p",
                    "text": "The Declaration Files section is broken down into the following sections."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Declaration Reference"
                },
                {
                    "type": "p",
                    "text": "We are often faced with writing a declaration file when we only have examples of the underlying library to guide us.\nTheDeclaration Referencesection shows many common API patterns and how to write declarations for each of them.\nThis guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Library Structures"
                },
                {
                    "type": "p",
                    "text": "TheLibrary Structuresguide helps you understand common library formats and how to write a proper declaration file for each format.\nIf you’re editing an existing file, you probably don’t need to read this section.\nAuthors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file."
                },
                {
                    "type": "p",
                    "text": "In the Template section you’ll find a number of declaration files that serve as a useful starting point\nwhen writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Do’s and Don’ts"
                },
                {
                    "type": "p",
                    "text": "Many common mistakes in declaration files can be easily avoided.\nTheDo’s and Don’tssection identifies common errors,\ndescribes how to detect them,\nand how to fix them.\nEveryone should read this section to help themselves avoid common mistakes."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Deep Dive"
                },
                {
                    "type": "p",
                    "text": "For seasoned authors interested in the underlying mechanics of how declaration files work,\ntheDeep Divesection explains many advanced concepts in declaration writing,\nand shows how to leverage these concepts to create cleaner and more intuitive declaration files."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Publish to npm"
                },
                {
                    "type": "p",
                    "text": "ThePublishingsection explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Find and Install Declaration Files"
                },
                {
                    "type": "p",
                    "text": "For JavaScript library users, theConsumptionsection offers a few simple steps to locate and install corresponding declaration files."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Declaration Reference"
                },
                {
                    "type": "p",
                    "text": "How to create a d.ts file for a module"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html",
            "title": "TypeScript: Documentation - Library Structures",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Library Structures"
                },
                {
                    "type": "p",
                    "text": "Broadly speaking, the way youstructureyour declaration file depends on how the library is consumed.\nThere are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it.\nThis guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern."
                },
                {
                    "type": "p",
                    "text": "Each type of major library structuring pattern has a corresponding file in theTemplatessection.\nYou can start with these templates to help you get going faster."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Identifying Kinds of Libraries"
                },
                {
                    "type": "p",
                    "text": "First, we’ll review the kinds of libraries TypeScript declaration files can represent.\nWe’ll briefly show how each kind of library isused, how it iswritten, and list some example libraries from the real world."
                },
                {
                    "type": "p",
                    "text": "Identifying the structure of a library is the first step in writing its declaration file.\nWe’ll give hints on how to identify structure both based on itsusageand itscode.\nDepending on the library’s documentation and organization, one might be easier than the other.\nWe recommend using whichever is more comfortable to you."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What should you look for?"
                },
                {
                    "type": "p",
                    "text": "Question to ask yourself while looking at a library you are trying to type."
                },
                {
                    "type": "list",
                    "items": [
                        "How do you obtain the library?For example, can youonlyget it through npm or only from a CDN?",
                        "How would you import it?Does it add a global object? Does it userequireorimport/exportstatements?"
                    ]
                },
                {
                    "type": "p",
                    "text": "How do you obtain the library?"
                },
                {
                    "type": "p",
                    "text": "For example, can youonlyget it through npm or only from a CDN?"
                },
                {
                    "type": "p",
                    "text": "How would you import it?"
                },
                {
                    "type": "p",
                    "text": "Does it add a global object? Does it userequireorimport/exportstatements?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Smaller samples for different types of libraries"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Modular Libraries"
                },
                {
                    "type": "p",
                    "text": "Almost every modern Node.js library falls into the module family.\nThese type of libraries only work in a JS environment with a module loader.\nFor example,expressonly works in Node.js and must be loaded using the CommonJSrequirefunction."
                },
                {
                    "type": "p",
                    "text": "ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions ofimportingamodule.\nIn JavaScript CommonJS (Node.js), for example, you would write"
                },
                {
                    "type": "code",
                    "code": "jsvarfs=require(\"fs\");"
                },
                {
                    "type": "p",
                    "text": "In TypeScript or ES6, theimportkeyword serves the same purpose:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfsfrom\"fs\";"
                },
                {
                    "type": "p",
                    "text": "You’ll typically see modular libraries include one of these lines in their documentation:"
                },
                {
                    "type": "code",
                    "code": "jsvarsomeLib=require(\"someLib\");"
                },
                {
                    "type": "p",
                    "text": "or"
                },
                {
                    "type": "code",
                    "code": "jsdefine(..., ['someLib'],function(someLib) {});"
                },
                {
                    "type": "p",
                    "text": "As with global modules, you might see these examples in the documentation ofa UMDmodule, so be sure to check the code or documentation."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Identifying a Module Library from Code"
                },
                {
                    "type": "p",
                    "text": "Modular libraries will typically have at least some of the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Unconditional calls torequireordefine",
                        "Declarations likeimport * as a from 'b';orexport c;",
                        "Assignments toexportsormodule.exports"
                    ]
                },
                {
                    "type": "p",
                    "text": "They will rarely have:"
                },
                {
                    "type": "list",
                    "items": [
                        "Assignments to properties ofwindoworglobal"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Templates For Modules"
                },
                {
                    "type": "p",
                    "text": "There are four templates available for modules,module.d.ts,module-class.d.ts,module-function.d.tsandmodule-plugin.d.ts."
                },
                {
                    "type": "p",
                    "text": "You should first readmodule.d.tsfor an overview on the way they all work."
                },
                {
                    "type": "p",
                    "text": "Then use the templatemodule-function.d.tsif your module can becalledlike a function:"
                },
                {
                    "type": "code",
                    "code": "jsconstx=require(\"foo\");// Note: calling 'x' as a functionconsty=x(42);"
                },
                {
                    "type": "p",
                    "text": "Use the templatemodule-class.d.tsif your module can beconstructedusingnew:"
                },
                {
                    "type": "code",
                    "code": "jsconstx=require(\"bar\");// Note: using 'new' operator on the imported variableconsty=newx(\"hello\");"
                },
                {
                    "type": "p",
                    "text": "If you have a module which when imported, makes changes to other modules use templatemodule-plugin.d.ts:"
                },
                {
                    "type": "code",
                    "code": "jsconstjest=require(\"jest\");require(\"jest-matchers-files\");"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Global Libraries"
                },
                {
                    "type": "p",
                    "text": "Agloballibrary is one that can be accessed from the global scope (i.e. without using any form ofimport).\nMany libraries simply expose one or more global variables for use.\nFor example, if you were usingjQuery, the$variable can be used by simply referring to it:"
                },
                {
                    "type": "code",
                    "code": "ts$(()=>{console.log(\"hello!\");});"
                },
                {
                    "type": "p",
                    "text": "You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"http://a.great.cdn.for/someLib.js\"></script>"
                },
                {
                    "type": "p",
                    "text": "Today, most popular globally-accessible libraries are actually written as UMD libraries (see below).\nUMD library documentation is hard to distinguish from global library documentation.\nBefore writing a global declaration file, make sure the library isn’t actually UMD."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Identifying a Global Library from Code"
                },
                {
                    "type": "p",
                    "text": "Global library code is usually extremely simple.\nA global “Hello, world” library might look like this:"
                },
                {
                    "type": "code",
                    "code": "jsfunctioncreateGreeting(s) {return\"Hello, \"+s;}"
                },
                {
                    "type": "p",
                    "text": "or like this:"
                },
                {
                    "type": "code",
                    "code": "js// Webwindow.createGreeting=function(s) {return\"Hello, \"+s;};// Nodeglobal.createGreeting=function(s) {return\"Hello, \"+s;};// Potentially any runtimeglobalThis.createGreeting=function(s) {return\"Hello, \"+s;};"
                },
                {
                    "type": "p",
                    "text": "When looking at the code of a global library, you’ll usually see:"
                },
                {
                    "type": "list",
                    "items": [
                        "Top-levelvarstatements orfunctiondeclarations",
                        "One or more assignments towindow.someName",
                        "Assumptions that DOM primitives likedocumentorwindowexist"
                    ]
                },
                {
                    "type": "p",
                    "text": "Youwon’tsee:"
                },
                {
                    "type": "list",
                    "items": [
                        "Checks for, or usage of, module loaders likerequireordefine",
                        "CommonJS/Node.js-style imports of the formvar fs = require(\"fs\");",
                        "Calls todefine(...)",
                        "Documentation describing how torequireor import the library"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of Global Libraries"
                },
                {
                    "type": "p",
                    "text": "Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style.\nHowever, libraries that are small and require the DOM (or havenodependencies) may still be global."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Global Library Template"
                },
                {
                    "type": "p",
                    "text": "The template fileglobal.d.tsdefines an example librarymyLib.\nBe sure to read the“Preventing Name Conflicts” footnote."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UMD"
                },
                {
                    "type": "p",
                    "text": "AUMDmodule is one that caneitherbe used as module (through an import), or as a global (when run in an environment without a module loader).\nMany popular libraries, such asMoment.js, are written this way.\nFor example, in Node.js or using RequireJS, you would write:"
                },
                {
                    "type": "code",
                    "code": "tsimportmoment=require(\"moment\");console.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "whereas in a vanilla browser environment you would write:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(moment.format());"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Identifying a UMD library"
                },
                {
                    "type": "p",
                    "text": "UMD modulescheck for the existence of a module loader environment.\nThis is an easy-to-spot pattern that looks something like this:"
                },
                {
                    "type": "code",
                    "code": "js(function(root,factory) {if(typeofdefine===\"function\"&&define.amd) {define([\"libName\"],factory);}elseif(typeofmodule===\"object\"&&module.exports) {module.exports=factory(require(\"libName\"));}else{root.returnExports=factory(root.libName);}}(this,function(b) {"
                },
                {
                    "type": "p",
                    "text": "If you see tests fortypeof define,typeof window, ortypeof modulein the code of a library, especially at the top of the file, it’s almost always a UMD library."
                },
                {
                    "type": "p",
                    "text": "Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showingrequire,\nand a “Using in the browser” example showing using a<script>tag to load the script."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of UMD libraries"
                },
                {
                    "type": "p",
                    "text": "Most popular libraries are now available as UMD packages.\nExamples includejQuery,Moment.js,lodash, and many more."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Template"
                },
                {
                    "type": "p",
                    "text": "Use themodule-plugin.d.tstemplate."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Consuming Dependencies"
                },
                {
                    "type": "p",
                    "text": "There are several kinds of dependencies your library might have.\nThis section shows how to import them into the declaration file."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on Global Libraries"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a global library, use a/// <reference types=\"...\" />directive:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"someLib\"/>functiongetThing():someLib.thing;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on Modules"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a module, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmomentfrom\"moment\";functiongetThing():moment;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on UMD libraries"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "From a Global Library"
                },
                {
                    "type": "p",
                    "text": "If your global library depends on a UMD module, use a/// <reference typesdirective:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"moment\"/>functiongetThing():moment;"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "From a Module or UMD Library"
                },
                {
                    "type": "p",
                    "text": "If your module or UMD library depends on a UMD library, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*assomeLibfrom\"someLib\";"
                },
                {
                    "type": "p",
                    "text": "Donotuse a/// <referencedirective to declare a dependency to a UMD library!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Footnotes"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing Name Conflicts"
                },
                {
                    "type": "p",
                    "text": "Note that it’s possible to define many types in the global scope when writing a global declaration file.\nWe strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project."
                },
                {
                    "type": "p",
                    "text": "A simple rule to follow is to only declare typesnamespacedby whatever global variable the library defines.\nFor example, if the library defines the global value ‘cats’, you should write"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacecats{interfaceKittySettings{}}"
                },
                {
                    "type": "p",
                    "text": "Butnot"
                },
                {
                    "type": "code",
                    "code": "ts// at top-levelinterfaceCatsKittySettings{}"
                },
                {
                    "type": "p",
                    "text": "This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The Impact of ES6 on Module Call Signatures"
                },
                {
                    "type": "p",
                    "text": "Many popular libraries, such as Express, expose themselves as a callable function when imported.\nFor example, the typical Express usage looks like this:"
                },
                {
                    "type": "code",
                    "code": "tsimportexp=require(\"express\");varapp=exp();"
                },
                {
                    "type": "p",
                    "text": "In ES6-compliant module loaders, the top-level object (here imported asexp) can only have properties;\nthe top-level module object canneverbe callable."
                },
                {
                    "type": "p",
                    "text": "The most common solution here is to define adefaultexport for a callable/constructable object;\nmodule loaders commonly detect this situation automatically and replace the top-level object with thedefaultexport.\nTypeScript can handle this for you, if you have\"esModuleInterop\": truein your tsconfig.json."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Declaration Reference"
                },
                {
                    "type": "p",
                    "text": "How to create a d.ts file for a module"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Modules .d.ts"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html",
            "title": "TypeScript: Documentation - Publishing",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Publishing"
                },
                {
                    "type": "p",
                    "text": "Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm.\nThere are two main ways you can publish your declaration files to npm:"
                },
                {
                    "type": "list",
                    "items": [
                        "bundling with your npm package",
                        "publishing to the@types organizationon npm."
                    ]
                },
                {
                    "type": "p",
                    "text": "If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types viadeclaration."
                },
                {
                    "type": "p",
                    "text": "Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the@typesorganization on npm."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Including declarations in your npm package"
                },
                {
                    "type": "p",
                    "text": "If your package has a main.jsfile, you will need to indicate the main declaration file in yourpackage.jsonfile as well.\nSet thetypesproperty to point to your bundled declaration file.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"awesome\",\"author\":\"Vandelay Industries\",\"version\":\"1.0.0\",\"main\":\"./lib/main.js\",\"types\":\"./lib/main.d.ts\"}"
                },
                {
                    "type": "p",
                    "text": "Note that the\"typings\"field is synonymous withtypes, and could be used as well."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Dependencies"
                },
                {
                    "type": "p",
                    "text": "All dependencies are managed by npm.\nMake sure all the declaration packages you depend on are marked appropriately in the\"dependencies\"section in yourpackage.json.\nFor example, imagine we authored a package that used Browserify and TypeScript."
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"browserify-typescript-extension\",\"author\":\"Vandelay Industries\",\"version\":\"1.0.0\",\"main\":\"./lib/main.js\",\"types\":\"./lib/main.d.ts\",\"dependencies\": {\"browserify\":\"latest\",\"@types/browserify\":\"latest\",\"typescript\":\"next\"}}"
                },
                {
                    "type": "p",
                    "text": "Here, our package depends on thebrowserifyandtypescriptpackages.browserifydoes not bundle its declaration files with its npm packages, so we needed to depend on@types/browserifyfor its declarations.typescript, on the other hand, packages its declaration files, so there was no need for any additional dependencies."
                },
                {
                    "type": "p",
                    "text": "Our package exposes declarations from each of those, so any user of ourbrowserify-typescript-extensionpackage needs to have these dependencies as well.\nFor that reason, we used\"dependencies\"and not\"devDependencies\", because otherwise our consumers would have needed to manually install those packages.\nIf we had just written a command line application and not expected our package to be used as a library, we might have useddevDependencies."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Red flags"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "/// <reference path=\"...\" />"
                },
                {
                    "type": "p",
                    "text": "Don’tuse/// <reference path=\"...\" />in your declaration files."
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"../typescript/lib/typescriptServices.d.ts\"/>...."
                },
                {
                    "type": "p",
                    "text": "Douse/// <reference types=\"...\" />instead."
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"typescript\"/>...."
                },
                {
                    "type": "p",
                    "text": "Make sure to revisit theConsuming dependenciessection for more information."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Packaging dependent declarations"
                },
                {
                    "type": "p",
                    "text": "If your type definitions depend on another package:"
                },
                {
                    "type": "list",
                    "items": [
                        "Don’tcombine it with yours, keep each in their own file.",
                        "Don’tcopy the declarations in your package either.",
                        "Dodepend on the npm type declaration package if it doesn’t package its declaration files."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Version selection withtypesVersions"
                },
                {
                    "type": "p",
                    "text": "When TypeScript opens apackage.jsonfile to figure out which files it needs to read, it first looks at a field calledtypesVersions."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Folder redirects (using*)"
                },
                {
                    "type": "p",
                    "text": "Apackage.jsonwith atypesVersionsfield might look like this:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"package-name\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.1\": {\"*\": [\"ts3.1/*\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Thispackage.jsontells TypeScript to first check the current version of TypeScript.\nIf it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’sts3.1folder."
                },
                {
                    "type": "p",
                    "text": "That’s what that{ \"*\": [\"ts3.1/*\"] }means - if you’re familiar withpath mapping, it works exactly like that."
                },
                {
                    "type": "p",
                    "text": "In the above example, if we’re importing from\"package-name\", TypeScript will try to resolve from[...]/node_modules/package-name/ts3.1/index.d.ts(and other relevant paths) when running in TypeScript 3.1.\nIf we import frompackage-name/foo, we’ll try to look for[...]/node_modules/package-name/ts3.1/foo.d.tsand[...]/node_modules/package-name/ts3.1/foo/index.d.ts."
                },
                {
                    "type": "p",
                    "text": "What if we’re not running in TypeScript 3.1 in this example?\nWell, if none of the fields intypesVersionsget matched, TypeScript falls back to thetypesfield, so here TypeScript 3.0 and earlier will be redirected to[...]/node_modules/package-name/index.d.ts."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "File redirects"
                },
                {
                    "type": "p",
                    "text": "When you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"package-name\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\"<4.0\": {\"index.d.ts\": [\"index.v3.d.ts\"] }}}"
                },
                {
                    "type": "p",
                    "text": "On TypeScript 4.0 and above, an import for\"package-name\"would resolve to./index.d.tsand for 3.9 and below\"./index.v3.d.ts."
                },
                {
                    "type": "p",
                    "text": "Note that redirections only affect theexternalAPI of a package; import resolution within a project is not affected bytypesVersions. For example, ad.tsfile in the previous example containingimport * as foo from \"./index\"will still map toindex.d.ts, notindex.v3.d.ts, whereas another package importingimport * as foo from \"package-name\"willgetindex.v3.d.ts."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Matching behavior"
                },
                {
                    "type": "p",
                    "text": "The way that TypeScript decides on whether a version of the compiler & language matches is by using Node’ssemver ranges."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Multiple fields"
                },
                {
                    "type": "p",
                    "text": "typesVersionscan support multiple fields where each field name is specified by the range to match on."
                },
                {
                    "type": "code",
                    "code": "{\"name\":\"package-name\",\"version\":\"1.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.2\": {\"*\": [\"ts3.2/*\"] },\">=3.1\": {\"*\": [\"ts3.1/*\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Since ranges have the potential to overlap, determining which redirect applies is order-specific.\nThat means in the above example, even though both the>=3.2and the>=3.1matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following."
                },
                {
                    "type": "code",
                    "code": "{\"name\":\"package-name\",\"version\":\"1.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {// NOTE: this doesn't work!\">=3.1\": {\"*\": [\"ts3.1/*\"] },\">=3.2\": {\"*\": [\"ts3.2/*\"] }}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Publish to@types"
                },
                {
                    "type": "p",
                    "text": "Packages under the@typesorganization are published automatically fromDefinitelyTypedusing thetypes-publisher tool.\nTo get your declarations published as an @types package, please submit a pull request toDefinitelyTyped.\nYou can find more details in thecontribution guidelines page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deep Dive"
                },
                {
                    "type": "p",
                    "text": "How do d.ts files work, a deep dive"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Consumption"
                },
                {
                    "type": "p",
                    "text": "How to download d.ts files for your project"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html",
            "title": "TypeScript: Documentation - Templates",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Templates"
                },
                {
                    "type": "p",
                    "text": "global-modifying-module.d.ts"
                },
                {
                    "type": "list",
                    "items": [
                        "global-plugin.d.ts",
                        "global.d.ts",
                        "module-class.d.ts",
                        "module-function.d.ts",
                        "module-plugin.d.ts",
                        "module.d.ts"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html",
            "title": "TypeScript: Documentation - Global .d.ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Global .d.ts"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global Libraries"
                },
                {
                    "type": "p",
                    "text": "Agloballibrary is one that can be accessed from the global scope (i.e. without using any form ofimport).\nMany libraries simply expose one or more global variables for use.\nFor example, if you were usingjQuery, the$variable can be used by simply referring to it:"
                },
                {
                    "type": "code",
                    "code": "ts$(()=>{console.log(\"hello!\");});"
                },
                {
                    "type": "p",
                    "text": "You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"http://a.great.cdn.for/someLib.js\"></script>"
                },
                {
                    "type": "p",
                    "text": "Today, most popular globally-accessible libraries are actually written as UMD libraries (see below).\nUMD library documentation is hard to distinguish from global library documentation.\nBefore writing a global declaration file, make sure the library isn’t actually UMD."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Identifying a Global Library from Code"
                },
                {
                    "type": "p",
                    "text": "Global library code is usually extremely simple.\nA global “Hello, world” library might look like this:"
                },
                {
                    "type": "code",
                    "code": "jsfunctioncreateGreeting(s) {return\"Hello, \"+s;}"
                },
                {
                    "type": "p",
                    "text": "or like this:"
                },
                {
                    "type": "code",
                    "code": "jswindow.createGreeting=function(s) {return\"Hello, \"+s;};"
                },
                {
                    "type": "p",
                    "text": "When looking at the code of a global library, you’ll usually see:"
                },
                {
                    "type": "list",
                    "items": [
                        "Top-levelvarstatements orfunctiondeclarations",
                        "One or more assignments towindow.someName",
                        "Assumptions that DOM primitives likedocumentorwindowexist"
                    ]
                },
                {
                    "type": "p",
                    "text": "Youwon’tsee:"
                },
                {
                    "type": "list",
                    "items": [
                        "Checks for, or usage of, module loaders likerequireordefine",
                        "CommonJS/Node.js-style imports of the formvar fs = require(\"fs\");",
                        "Calls todefine(...)",
                        "Documentation describing how torequireor import the library"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Examples of Global Libraries"
                },
                {
                    "type": "p",
                    "text": "Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style.\nHowever, libraries that are small and require the DOM (or havenodependencies) may still be global."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global Library Template"
                },
                {
                    "type": "p",
                    "text": "You can see an example DTS below:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ If this library is callable (e.g. can be invoked as myLib(3)),*~ include those call signatures here.*~ Otherwise, delete this section.*/declarefunctionmyLib(a:string):string;declarefunctionmyLib(a:number):number;/*~ If you want the name of this library to be a valid type name,*~ you can do so here.*~*~ For example, this allows us to write 'var x: myLib';*~ Be sure this actually makes sense! If it doesn't, just*~ delete this declaration and add types inside the namespace below.*/interfacemyLib{name:string;length:number;extras?:string[];}/*~ If your library has properties exposed on a global variable,*~ place them here.*~ You should also place types (interfaces and type alias) here.*/declarenamespacemyLib{//~ We can write 'myLib.timeout = 50;'lettimeout:number;//~ We can access 'myLib.version', but not change itconstversion:string;//~ There's some class we can create via 'let c = new myLib.Cat(42)'//~ Or reference e.g. 'function f(c: myLib.Cat) { ... }classCat{constructor(n:number);//~ We can read 'c.age' from a 'Cat' instancereadonlyage:number;//~ We can invoke 'c.purr()' from a 'Cat' instancepurr():void;}//~ We can declare a variable as//~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'interfaceCatSettings{weight:number;name:string;tailLength?:number;}//~ We can write 'const v: myLib.VetID = 42;'//~  or 'const v: myLib.VetID = \"bob\";'typeVetID=string|number;//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'functioncheckCat(c:Cat,s?:VetID);}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html",
            "title": "TypeScript: Documentation - Global: Modifying Module",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Global: Modifying Module"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global-modifying Modules"
                },
                {
                    "type": "p",
                    "text": "Aglobal-modifying modulealters existing values in the global scope when they are imported.\nFor example, there might exist a library which adds new members toString.prototypewhen imported.\nThis pattern is somewhat dangerous due to the possibility of runtime conflicts,\nbut we can still write a declaration file for it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Identifying global-modifying modules"
                },
                {
                    "type": "p",
                    "text": "Global-modifying modules are generally easy to identify from their documentation.\nIn general, they’re similar to global plugins, but need arequirecall to activate their effects."
                },
                {
                    "type": "p",
                    "text": "You might see documentation like this:"
                },
                {
                    "type": "code",
                    "code": "js// 'require' call that doesn't use its return valuevarunused=require(\"magic-string-time\");/* or */require(\"magic-string-time\");varx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "p",
                    "text": "Here is an example"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the global-modifying module template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ Note: If your global-modifying module is callable or constructable, you'll*~ need to combine the patterns here with those in the module-class or module-function*~ template files*/declareglobal{/*~ Here, declare things that go in the global namespace, or augment*~ existing declarations in the global namespace*/interfaceString{fancyFormat(opts:StringFormatOptions):string;}}/*~ If your module exports types or values, write them as usual */exportinterfaceStringFormatOptions{fancinessLevel:number;}/*~ For example, declaring a method on the module (in addition to its global side effects) */exportfunctiondoSomething():void;/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */export{};"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html",
            "title": "TypeScript: Documentation - Global: Plugin",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Global: Plugin"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "UMD"
                },
                {
                    "type": "p",
                    "text": "AUMDmodule is one that caneitherbe used as module (through an import), or as a global (when run in an environment without a module loader).\nMany popular libraries, such asMoment.js, are written this way.\nFor example, in Node.js or using RequireJS, you would write:"
                },
                {
                    "type": "code",
                    "code": "tsimportmoment=require(\"moment\");console.log(moment.format());"
                },
                {
                    "type": "p",
                    "text": "whereas in a vanilla browser environment you would write:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(moment.format());"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Identifying a UMD library"
                },
                {
                    "type": "p",
                    "text": "UMD modulescheck for the existence of a module loader environment.\nThis is an easy-to-spot pattern that looks something like this:"
                },
                {
                    "type": "code",
                    "code": "js(function(root,factory) {if(typeofdefine===\"function\"&&define.amd) {define([\"libName\"],factory);}elseif(typeofmodule===\"object\"&&module.exports) {module.exports=factory(require(\"libName\"));}else{root.returnExports=factory(root.libName);}}(this,function(b) {"
                },
                {
                    "type": "p",
                    "text": "If you see tests fortypeof define,typeof window, ortypeof modulein the code of a library, especially at the top of the file, it’s almost always a UMD library."
                },
                {
                    "type": "p",
                    "text": "Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showingrequire,\nand a “Using in the browser” example showing using a<script>tag to load the script."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Examples of UMD libraries"
                },
                {
                    "type": "p",
                    "text": "Most popular libraries are now available as UMD packages.\nExamples includejQuery,Moment.js,lodash, and many more."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Template"
                },
                {
                    "type": "p",
                    "text": "There are three templates available for modules,module.d.ts,module-class.d.tsandmodule-function.d.ts."
                },
                {
                    "type": "p",
                    "text": "Usemodule-function.d.tsif your module can becalledlike a function:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=require(\"foo\");// Note: calling 'x' as a functionvary=x(42);"
                },
                {
                    "type": "p",
                    "text": "Be sure to read thefootnote “The Impact of ES6 on Module Call Signatures”"
                },
                {
                    "type": "p",
                    "text": "Usemodule-class.d.tsif your module can beconstructedusingnew:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=require(\"bar\");// Note: using 'new' operator on the imported variablevary=newx(\"hello\");"
                },
                {
                    "type": "p",
                    "text": "The samefootnoteapplies to these modules."
                },
                {
                    "type": "p",
                    "text": "If your module is not callable or constructable, use themodule.d.tsfile."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Module PluginorUMD Plugin"
                },
                {
                    "type": "p",
                    "text": "Amodule pluginchanges the shape of another module (either UMD or module).\nFor example, in Moment.js,moment-rangeadds a newrangemethod to themomentobject."
                },
                {
                    "type": "p",
                    "text": "For the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Template"
                },
                {
                    "type": "p",
                    "text": "Use themodule-plugin.d.tstemplate."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global Plugin"
                },
                {
                    "type": "p",
                    "text": "Aglobal pluginis global code that changes the shape of some global.\nAs withglobal-modifying modules, these raise the possibility of runtime conflict."
                },
                {
                    "type": "p",
                    "text": "For example, some libraries add new functions toArray.prototypeorString.prototype."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Identifying global plugins"
                },
                {
                    "type": "p",
                    "text": "Global plugins are generally easy to identify from their documentation."
                },
                {
                    "type": "p",
                    "text": "You’ll see examples that look like this:"
                },
                {
                    "type": "code",
                    "code": "jsvarx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Template"
                },
                {
                    "type": "p",
                    "text": "Use theglobal-plugin.d.tstemplate."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Global-modifying Modules"
                },
                {
                    "type": "p",
                    "text": "Aglobal-modifying modulealters existing values in the global scope when they are imported.\nFor example, there might exist a library which adds new members toString.prototypewhen imported.\nThis pattern is somewhat dangerous due to the possibility of runtime conflicts,\nbut we can still write a declaration file for it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Identifying global-modifying modules"
                },
                {
                    "type": "p",
                    "text": "Global-modifying modules are generally easy to identify from their documentation.\nIn general, they’re similar to global plugins, but need arequirecall to activate their effects."
                },
                {
                    "type": "p",
                    "text": "You might see documentation like this:"
                },
                {
                    "type": "code",
                    "code": "js// 'require' call that doesn't use its return valuevarunused=require(\"magic-string-time\");/* or */require(\"magic-string-time\");varx=\"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());vary= [1,2,3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort());"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Template"
                },
                {
                    "type": "p",
                    "text": "Use theglobal-modifying-module.d.tstemplate."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Consuming Dependencies"
                },
                {
                    "type": "p",
                    "text": "There are several kinds of dependencies your library might have.\nThis section shows how to import them into the declaration file."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on Global Libraries"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a global library, use a/// <reference types=\"...\" />directive:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"someLib\"/>functiongetThing():someLib.thing;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on Modules"
                },
                {
                    "type": "p",
                    "text": "If your library depends on a module, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmomentfrom\"moment\";functiongetThing():moment;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dependencies on UMD libraries"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "From a Global Library"
                },
                {
                    "type": "p",
                    "text": "If your global library depends on a UMD module, use a/// <reference typesdirective:"
                },
                {
                    "type": "code",
                    "code": "ts///<referencetypes=\"moment\"/>functiongetThing():moment;"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "From a Module or UMD Library"
                },
                {
                    "type": "p",
                    "text": "If your module or UMD library depends on a UMD library, use animportstatement:"
                },
                {
                    "type": "code",
                    "code": "tsimport*assomeLibfrom\"someLib\";"
                },
                {
                    "type": "p",
                    "text": "Donotuse a/// <referencedirective to declare a dependency to a UMD library!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Footnotes"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing Name Conflicts"
                },
                {
                    "type": "p",
                    "text": "Note that it’s possible to define many types in the global scope when writing a global declaration file.\nWe strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project."
                },
                {
                    "type": "p",
                    "text": "A simple rule to follow is to only declare typesnamespacedby whatever global variable the library defines.\nFor example, if the library defines the global value ‘cats’, you should write"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespacecats{interfaceKittySettings{}}"
                },
                {
                    "type": "p",
                    "text": "Butnot"
                },
                {
                    "type": "code",
                    "code": "ts// at top-levelinterfaceCatsKittySettings{}"
                },
                {
                    "type": "p",
                    "text": "This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The Impact of ES6 on Module Plugins"
                },
                {
                    "type": "p",
                    "text": "Some plugins add or modify top-level exports on existing modules.\nWhile this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible.\nBecause TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The Impact of ES6 on Module Call Signatures"
                },
                {
                    "type": "p",
                    "text": "Many popular libraries, such as Express, expose themselves as a callable function when imported.\nFor example, the typical Express usage looks like this:"
                },
                {
                    "type": "code",
                    "code": "tsimportexp=require(\"express\");varapp=exp();"
                },
                {
                    "type": "p",
                    "text": "In ES6 module loaders, the top-level object (here imported asexp) can only have properties;\nthe top-level module object isnevercallable.\nThe most common solution here is to define adefaultexport for a callable/constructable object;\nsome module loader shims will automatically detect this situation and replace the top-level object with thedefaultexport."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Library file layout"
                },
                {
                    "type": "p",
                    "text": "The layout of your declaration files should mirror the layout of the library."
                },
                {
                    "type": "p",
                    "text": "A library can consist of multiple modules, such as"
                },
                {
                    "type": "code",
                    "code": "myLib+---- index.js+---- foo.js+---- bar+---- index.js+---- baz.js"
                },
                {
                    "type": "p",
                    "text": "These could be imported as"
                },
                {
                    "type": "code",
                    "code": "jsvara=require(\"myLib\");varb=require(\"myLib/foo\");varc=require(\"myLib/bar\");vard=require(\"myLib/bar/baz\");"
                },
                {
                    "type": "p",
                    "text": "Your declaration files should thus be"
                },
                {
                    "type": "code",
                    "code": "@types/myLib+---- index.d.ts+---- foo.d.ts+---- bar+---- index.d.ts+---- baz.d.ts"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This template shows how to write a global plugin. *//*~ Write a declaration for the original type and add new members.*~ For example, this adds a 'toBinaryString' method with overloads to*~ the built-in number type.*/interfaceNumber{toBinaryString(opts?:MyLibrary.BinaryFormatOptions):string;toBinaryString(callback:MyLibrary.BinaryFormatCallback,opts?:MyLibrary.BinaryFormatOptions):string;}/*~ If you need to declare several types, place them inside a namespace*~ to avoid adding too many things to the global namespace.*/declarenamespaceMyLibrary{typeBinaryFormatCallback= (n:number)=>string;interfaceBinaryFormatOptions{prefix?:string;padding:number;}}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html",
            "title": "TypeScript: Documentation - Module: Class",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Module: Class"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which looks like:"
                },
                {
                    "type": "code",
                    "code": "tsconstGreeter=require(\"super-greeter\");constgreeter=newGreeter();greeter.greet();"
                },
                {
                    "type": "p",
                    "text": "To handle both importing via UMD and modules:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file for class modules.*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*/// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style://   import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import://   import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myClassLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespace\"super-greeter\";/*~ This declaration specifies that the class constructor function*~ is the exported object from the file*/export=Greeter;/*~ Write your module's methods and properties in this class */declareclassGreeter{constructor(customGreeting?:string);greet:void;myMethod(opts:MyClass.MyClassMethodOptions):number;}/*~ If you want to expose types from your module as well, you can*~ place them in this block.*~*~ Note that if you decide to include this namespace, the module can be*~ incorrectly imported as a namespace object, unless*~ --esModuleInterop is turned on:*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!*/declarenamespaceMyClass{exportinterfaceMyClassMethodOptions{width?:number;height?:number;}}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html",
            "title": "TypeScript: Documentation - Modules .d.ts",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules .d.ts"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Comparing JavaScript to an example DTS"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Common CommonJS Patterns"
                },
                {
                    "type": "p",
                    "text": "A module using CommonJS patterns usesmodule.exportsto describe the exported values. For example, here is a module which exports a function and a numerical constant:"
                },
                {
                    "type": "code",
                    "code": "jsconstmaxInterval=12;functiongetArrayLength(arr) {returnarr.length;}module.exports= {getArrayLength,maxInterval,};"
                },
                {
                    "type": "p",
                    "text": "This can be described by the following.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctiongetArrayLength(arr:any[]):number;exportconstmaxInterval:12;"
                },
                {
                    "type": "p",
                    "text": "The TypeScript playground can show you the.d.tsequivalent for JavaScript code. You cantry it yourself here."
                },
                {
                    "type": "p",
                    "text": "The.d.tssyntax intentionally looks likeES Modulessyntax.\nES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:"
                },
                {
                    "type": "code",
                    "code": "jsexportfunctiongetArrayLength(arr) {returnarr.length;}"
                },
                {
                    "type": "p",
                    "text": "This would have the following.d.tsequivalent:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctiongetArrayLength(arr:any[]):number;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Default Exports"
                },
                {
                    "type": "p",
                    "text": "In CommonJS you can export any value as the default export, for example here is a regular expression module:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=/hello(world)?/;"
                },
                {
                    "type": "p",
                    "text": "Which can be described by the following .d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconsthelloWorld:RegExp;exportdefaulthelloWorld;"
                },
                {
                    "type": "p",
                    "text": "Or a number:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=3.142;"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstpi:number;exportdefaultpi;"
                },
                {
                    "type": "p",
                    "text": "One style of exporting in CommonJS is to export a function.\nBecause a function is also an object, then extra fields can be added and are included in the export."
                },
                {
                    "type": "code",
                    "code": "jsfunctiongetArrayLength(arr) {returnarr.length;}getArrayLength.maxInterval=12;module.exports=getArrayLength;"
                },
                {
                    "type": "p",
                    "text": "Which can be described with:"
                },
                {
                    "type": "code",
                    "code": "tsexportdefaultfunctiongetArrayLength(arr:any[]):number;exportconstmaxInterval:12;"
                },
                {
                    "type": "p",
                    "text": "Note that usingexport defaultin your .d.ts files requiresesModuleInterop: trueto work.\nIf you can’t haveesModuleInterop: truein your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use theexport=syntax instead. This older syntax is harder to use but works everywhere.\nHere’s how the above example would have to be written usingexport=:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctiongetArrayLength(arr:any[]):number;declarenamespacegetArrayLength{declareconstmaxInterval:12;}export=getArrayLength;"
                },
                {
                    "type": "p",
                    "text": "SeeModule: Functionsfor details of how that works, and theModules referencepage."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Handling Many Consuming Import"
                },
                {
                    "type": "p",
                    "text": "There are many ways to import a module in modern consuming code:"
                },
                {
                    "type": "code",
                    "code": "tsconstfastify=require(\"fastify\");const{fastify} =require(\"fastify\");importfastify=require(\"fastify\");import*asFastifyfrom\"fastify\";import{fastify,FastifyInstance}from\"fastify\";importfastifyfrom\"fastify\";importfastify, {FastifyInstance}from\"fastify\";"
                },
                {
                    "type": "p",
                    "text": "Covering all of these cases requires the JavaScript code to actually support all of these patterns.\nTo support many of these patterns, a CommonJS module would need to look something like:"
                },
                {
                    "type": "code",
                    "code": "jsclassFastifyInstance{}functionfastify() {returnnewFastifyInstance();}fastify.FastifyInstance=FastifyInstance;// Allows for { fastify }fastify.fastify=fastify;// Allows for strict ES Module supportfastify.default=fastify;// Sets the default exportmodule.exports=fastify;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Types in Modules"
                },
                {
                    "type": "p",
                    "text": "You may want to provide a type for JavaScript code which does not exist"
                },
                {
                    "type": "code",
                    "code": "jsfunctiongetArrayMetadata(arr) {return{length:getArrayLength(arr),firstObject:arr[0],};}module.exports= {getArrayMetadata,};"
                },
                {
                    "type": "p",
                    "text": "This can be described with:"
                },
                {
                    "type": "code",
                    "code": "tsexporttypeArrayMetadata= {length:number;firstObject:any|undefined;};exportfunctiongetArrayMetadata(arr:any[]):ArrayMetadata;"
                },
                {
                    "type": "p",
                    "text": "This example is a good case forusing genericsto provide richer type information:"
                },
                {
                    "type": "code",
                    "code": "tsexporttypeArrayMetadata<ArrType> = {length:number;firstObject:ArrType|undefined;};exportfunctiongetArrayMetadata<ArrType>(arr:ArrType[]):ArrayMetadata<ArrType>;"
                },
                {
                    "type": "p",
                    "text": "Now the type of the array propagates into theArrayMetadatatype."
                },
                {
                    "type": "p",
                    "text": "The types which are exported can then be re-used by consumers of the modules using eitherimportorimport typein TypeScript code orJSDoc imports."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Namespaces in Module Code"
                },
                {
                    "type": "p",
                    "text": "Trying to describe the runtime relationship of JavaScript code can be tricky.\nWhen the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can usenamespaces."
                },
                {
                    "type": "p",
                    "text": "For example, you may have complex enough types to describe that you choose to namespace them inside your.d.ts:"
                },
                {
                    "type": "code",
                    "code": "ts// This represents the JavaScript class which would be available at runtimeexportclassAPI{constructor(baseURL:string);getInfo(opts:API.InfoRequest):API.InfoResponse;}// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declarenamespaceAPI{exportinterfaceInfoRequest{id:string;}exportinterfaceInfoResponse{width:number;height:number;}}"
                },
                {
                    "type": "p",
                    "text": "To understand how namespaces work in.d.tsfiles read the.d.tsdeep dive."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Global Usage"
                },
                {
                    "type": "p",
                    "text": "You can useexport as namespaceto declare that your module will be available in the global scope in UMD contexts:"
                },
                {
                    "type": "code",
                    "code": "tsexportasnamespacemoduleName;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference Example"
                },
                {
                    "type": "p",
                    "text": "To give you an idea of how all these pieces can come together, here is a reference.d.tsto start with when making a new module"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ If this module is a UMD module that exposes a global variable 'myLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespacemyLib;/*~ If this module exports functions, declare them like so.*/exportfunctionmyFunction(a:string):string;exportfunctionmyOtherFunction(a:number):number;/*~ You can declare types that are available via importing the module */exportinterfaceSomeType{name:string;length:number;extras?:string[];}/*~ You can declare properties of the module using const, let, or var */exportconstmyField:number;"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Library file layout"
                },
                {
                    "type": "p",
                    "text": "The layout of your declaration files should mirror the layout of the library."
                },
                {
                    "type": "p",
                    "text": "A library can consist of multiple modules, such as"
                },
                {
                    "type": "code",
                    "code": "myLib+---- index.js+---- foo.js+---- bar+---- index.js+---- baz.js"
                },
                {
                    "type": "p",
                    "text": "These could be imported as"
                },
                {
                    "type": "code",
                    "code": "jsvara=require(\"myLib\");varb=require(\"myLib/foo\");varc=require(\"myLib/bar\");vard=require(\"myLib/bar/baz\");"
                },
                {
                    "type": "p",
                    "text": "Your declaration files should thus be"
                },
                {
                    "type": "code",
                    "code": "@types/myLib+---- index.d.ts+---- foo.d.ts+---- bar+---- index.d.ts+---- baz.d.ts"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Testing your types"
                },
                {
                    "type": "p",
                    "text": "If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:"
                },
                {
                    "type": "list",
                    "items": [
                        "Create a new folder innode_modules/@types/[libname]",
                        "Create anindex.d.tsin that folder, and copy the example in",
                        "See where your usage of the module breaks, and start to fill out the index.d.ts",
                        "When you’re happy, cloneDefinitelyTyped/DefinitelyTypedand follow the instructions in the README."
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise"
                },
                {
                    "type": "list",
                    "items": [
                        "Create a new file in the root of your source tree:[libname].d.ts",
                        "Adddeclare module \"[libname]\" {  }",
                        "Add the template inside the braces of the declare module, and see where your usage breaks"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html",
            "title": "TypeScript: Documentation - Module: Function",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Module: Function"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which looks like:"
                },
                {
                    "type": "code",
                    "code": "tsimportgreeterfrom\"super-greeter\";greeter(2);greeter(\"Hello world\");"
                },
                {
                    "type": "p",
                    "text": "To handle both importing via UMD and modules:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file for function modules.*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*/// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style://   import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import://   import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when*~ loaded outside a module loader environment, declare that global here.*~ Otherwise, delete this declaration.*/exportasnamespacemyFuncLib;/*~ This declaration specifies that the function*~ is the exported object from the file*/export=Greeter;/*~ This example shows how to have multiple overloads for your function */declarefunctionGreeter(name:string):Greeter.NamedReturnType;declarefunctionGreeter(length:number):Greeter.LengthReturnType;/*~ If you want to expose types from your module as well, you can*~ place them in this block. Often you will want to describe the*~ shape of the return type of the function; that type should*~ be declared in here, as this example shows.*~*~ Note that if you decide to include this namespace, the module can be*~ incorrectly imported as a namespace object, unless*~ --esModuleInterop is turned on:*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!*/declarenamespaceGreeter{exportinterfaceLengthReturnType{width:number;height:number;}exportinterfaceNamedReturnType{firstName:string;lastName:string;}/*~ If the module also has properties, declare them here. For example,*~ this declaration says that this code is legal:*~   import f = require('super-greeter');*~   console.log(f.defaultName);*/exportconstdefaultName:string;exportletdefaultLength:number;}"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html",
            "title": "TypeScript: Documentation - Module: Plugin",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Module: Plugin"
                },
                {
                    "type": "p",
                    "text": "For example, when you want to work with JavaScript code which extends another library."
                },
                {
                    "type": "code",
                    "code": "tsimport{greeter}from\"super-greeter\";// Normal Greeter APIgreeter(2);greeter(\"Hello world\");// Now we extend the object with a new function at runtimeimport\"hyper-super-greeter\";greeter.hyperGreet();"
                },
                {
                    "type": "p",
                    "text": "The definition for “super-greeter”:"
                },
                {
                    "type": "code",
                    "code": "ts/*~ This example shows how to have multiple overloads for your function */exportinterfaceGreeterFunction{(name:string):void(time:number):void}/*~ This example shows how to export a function specified by an interface */exportconstgreeter:GreeterFunction;"
                },
                {
                    "type": "p",
                    "text": "We can extend the existing module like the following:"
                },
                {
                    "type": "code",
                    "code": "ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module plugin template file. You should rename it to index.d.ts*~ and place it in a folder with the same name as the module.*~ For example, if you were writing a file for \"super-greeter\", this*~ file should be 'super-greeter/index.d.ts'*//*~ On this line, import the module which this module adds to */import{greeter}from\"super-greeter\";/*~ Here, declare the same module as the one you imported above*~ then we expand the existing declaration of the greeter function*/exportmodule\"super-greeter\"{exportinterfaceGreeterFunction{/** Greets even better! */hyperGreet():void;}}"
                },
                {
                    "type": "p",
                    "text": "This usesdeclaration merging"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The Impact of ES6 on Module Plugins"
                },
                {
                    "type": "p",
                    "text": "Some plugins add or modify top-level exports on existing modules.\nWhile this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible.\nBecause TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html",
            "title": "TypeScript: Documentation - Declaration Merging",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Declaration Merging"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Introduction"
                },
                {
                    "type": "p",
                    "text": "Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level.\nOne example that is especially unique to TypeScript is the concept of ‘declaration merging’.\nUnderstanding this concept will give you an advantage when working with existing JavaScript.\nIt also opens the door to more advanced abstraction concepts."
                },
                {
                    "type": "p",
                    "text": "For the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition.\nThis merged definition has the features of both of the original declarations.\nAny number of declarations can be merged; it’s not limited to just two declarations."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Basic Concepts"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value.\nNamespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation.\nType-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name.\nLastly, value-creating declarations create values that are visible in the output JavaScript."
                },
                {
                    "type": "p",
                    "text": "Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Merging Interfaces"
                },
                {
                    "type": "p",
                    "text": "The simplest, and perhaps most common, type of declaration merging is interface merging.\nAt the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBox{height:number;width:number;}interfaceBox{scale:number;}letbox:Box= {height:5,width:6,scale:10};"
                },
                {
                    "type": "p",
                    "text": "Non-function members of the interfaces should be unique.\nIf they are not unique, they must be of the same type.\nThe compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types."
                },
                {
                    "type": "p",
                    "text": "For function members, each function member of the same name is treated as describing an overload of the same function.\nOf note, too, is that in the case of interfaceAmerging with later interfaceA, the second interface will have a higher precedence than the first."
                },
                {
                    "type": "p",
                    "text": "That is, in the example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCloner{clone(animal:Animal):Animal;}interfaceCloner{clone(animal:Sheep):Sheep;}interfaceCloner{clone(animal:Dog):Dog;clone(animal:Cat):Cat;}"
                },
                {
                    "type": "p",
                    "text": "The three interfaces will merge to create a single declaration as so:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCloner{clone(animal:Dog):Dog;clone(animal:Cat):Cat;clone(animal:Sheep):Sheep;clone(animal:Animal):Animal;}"
                },
                {
                    "type": "p",
                    "text": "Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first."
                },
                {
                    "type": "p",
                    "text": "One exception to this rule is specialized signatures.\nIf a signature has a parameter whose type is asinglestring literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list."
                },
                {
                    "type": "p",
                    "text": "For instance, the following interfaces will merge together:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDocument{createElement(tagName:any):Element;}interfaceDocument{createElement(tagName:\"div\"):HTMLDivElement;createElement(tagName:\"span\"):HTMLSpanElement;}interfaceDocument{createElement(tagName:string):HTMLElement;createElement(tagName:\"canvas\"):HTMLCanvasElement;}"
                },
                {
                    "type": "p",
                    "text": "The resulting merged declaration ofDocumentwill be the following:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceDocument{createElement(tagName:\"canvas\"):HTMLCanvasElement;createElement(tagName:\"div\"):HTMLDivElement;createElement(tagName:\"span\"):HTMLSpanElement;createElement(tagName:string):HTMLElement;createElement(tagName:any):Element;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Merging Namespaces"
                },
                {
                    "type": "p",
                    "text": "Similarly to interfaces, namespaces of the same name will also merge their members.\nSince namespaces create both a namespace and a value, we need to understand how both merge."
                },
                {
                    "type": "p",
                    "text": "To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside."
                },
                {
                    "type": "p",
                    "text": "To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first."
                },
                {
                    "type": "p",
                    "text": "The declaration merge ofAnimalsin this example:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimals{exportclassZebra{}}namespaceAnimals{exportinterfaceLegged{numberOfLegs:number;}exportclassDog{}}"
                },
                {
                    "type": "p",
                    "text": "is equivalent to:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimals{exportinterfaceLegged{numberOfLegs:number;}exportclassZebra{}exportclassDog{}}"
                },
                {
                    "type": "p",
                    "text": "This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members.\nNon-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members."
                },
                {
                    "type": "p",
                    "text": "We can see this more clearly in this example:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceAnimal{lethaveMuscles=true;exportfunctionanimalsHaveMuscles() {returnhaveMuscles;}}namespaceAnimal{exportfunctiondoAnimalsHaveMuscles() {returnhaveMuscles;// Error, because haveMuscles is not accessible here}}"
                },
                {
                    "type": "p",
                    "text": "BecausehaveMusclesis not exported, only theanimalsHaveMusclesfunction that shares the same un-merged namespace can see the symbol.\nThedoAnimalsHaveMusclesfunction, even though it’s part of the mergedAnimalnamespace can not see this un-exported member."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Merging Namespaces with Classes, Functions, and Enums"
                },
                {
                    "type": "p",
                    "text": "Namespaces are flexible enough to also merge with other types of declarations.\nTo do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types.\nTypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Merging Namespaces with Classes"
                },
                {
                    "type": "p",
                    "text": "This gives the user a way of describing inner classes."
                },
                {
                    "type": "code",
                    "code": "tsclassAlbum{label:Album.AlbumLabel;}namespaceAlbum{exportclassAlbumLabel{}}"
                },
                {
                    "type": "p",
                    "text": "The visibility rules for merged members is the same as described in theMerging Namespacessection, so we must export theAlbumLabelclass for the merged class to see it.\nThe end result is a class managed inside of another class.\nYou can also use namespaces to add more static members to an existing class."
                },
                {
                    "type": "p",
                    "text": "In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function.\nTypeScript uses declaration merging to build up definitions like this in a type-safe way."
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildLabel(name:string):string{returnbuildLabel.prefix+name+buildLabel.suffix;}namespacebuildLabel{exportletsuffix=\"\";exportletprefix=\"Hello, \";}console.log(buildLabel(\"Sam Smith\"));"
                },
                {
                    "type": "p",
                    "text": "Similarly, namespaces can be used to extend enums with static members:"
                },
                {
                    "type": "code",
                    "code": "tsenumColor{red=1,green=2,blue=4,}namespaceColor{exportfunctionmixColor(colorName:string) {if(colorName==\"yellow\") {returnColor.red+Color.green;}elseif(colorName==\"white\") {returnColor.red+Color.green+Color.blue;}elseif(colorName==\"magenta\") {returnColor.red+Color.blue;}elseif(colorName==\"cyan\") {returnColor.green+Color.blue;}}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Disallowed Merges"
                },
                {
                    "type": "p",
                    "text": "Not all merges are allowed in TypeScript.\nCurrently, classes can not merge with other classes or with variables.\nFor information on mimicking class merging, see theMixins in TypeScriptsection."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Module Augmentation"
                },
                {
                    "type": "p",
                    "text": "Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them.\nLet’s look at a toy Observable example:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... implementation left as an exercise for the reader ...}// map.tsimport{Observable}from\"./observable\";Observable.prototype.map=function(f) {// ... another exercise for the reader};"
                },
                {
                    "type": "p",
                    "text": "This works fine in TypeScript too, but the compiler doesn’t know aboutObservable.prototype.map.\nYou can use module augmentation to tell the compiler about it:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... implementation left as an exercise for the reader ...}// map.tsimport{Observable}from\"./observable\";declaremodule\"./observable\"{interfaceObservable<T> {map<U>(f: (x:T)=>U):Observable<U>;}}Observable.prototype.map=function(f) {// ... another exercise for the reader};// consumer.tsimport{Observable}from\"./observable\";import\"./map\";leto:Observable<number>;o.map((x)=>x.toFixed());"
                },
                {
                    "type": "p",
                    "text": "The module name is resolved the same way as module specifiers inimport/export.\nSeeModulesfor more information.\nThen the declarations in an augmentation are merged as if they were declared in the same file as the original."
                },
                {
                    "type": "p",
                    "text": "However, there are two limitations to keep in mind:"
                },
                {
                    "type": "list",
                    "items": [
                        "You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.",
                        "Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, anddefaultis a reserved word - see#14080for details)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Global augmentation"
                },
                {
                    "type": "p",
                    "text": "You can also add declarations to the global scope from inside a module:"
                },
                {
                    "type": "code",
                    "code": "ts// observable.tsexportclassObservable<T> {// ... still no implementation ...}declareglobal{interfaceArray<T> {toObservable():Observable<T>;}}Array.prototype.toObservable=function() {// ...};"
                },
                {
                    "type": "p",
                    "text": "Global augmentations have the same behavior and limits as module augmentations."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/decorators.html",
            "title": "TypeScript: Documentation - Decorators",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Decorators"
                },
                {
                    "type": "p",
                    "text": "NOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0.\nSee:Decorators in Typescript 5.0"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Introduction"
                },
                {
                    "type": "p",
                    "text": "With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members.\nDecorators provide a way to add both annotations and a meta-programming syntax for class declarations and members."
                },
                {
                    "type": "p",
                    "text": "Further Reading (stage 2):A Complete Guide to TypeScript Decorators"
                },
                {
                    "type": "p",
                    "text": "To enable experimental support for decorators, you must enable theexperimentalDecoratorscompiler option either on the command line or in yourtsconfig.json:"
                },
                {
                    "type": "p",
                    "text": "Command Line:"
                },
                {
                    "type": "code",
                    "code": "shelltsc --target ES5 --experimentalDecorators"
                },
                {
                    "type": "p",
                    "text": "tsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"ES5\",\"experimentalDecorators\":true}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Decorators"
                },
                {
                    "type": "p",
                    "text": "ADecoratoris a special kind of declaration that can be attached to aclass declaration,method,accessor,property, orparameter.\nDecorators use the form@expression, whereexpressionmust evaluate to a function that will be called at runtime with information about the decorated declaration."
                },
                {
                    "type": "p",
                    "text": "For example, given the decorator@sealedwe might write thesealedfunction as follows:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsealed(target) {// do something with 'target' ...}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Decorator Factories"
                },
                {
                    "type": "p",
                    "text": "If we want to customize how a decorator is applied to a declaration, we can write a decorator factory.\nADecorator Factoryis simply a function that returns the expression that will be called by the decorator at runtime."
                },
                {
                    "type": "p",
                    "text": "We can write a decorator factory in the following fashion:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncolor(value:string) {// this is the decorator factory, it sets up// the returned decorator functionreturnfunction(target) {// this is the decorator// do something with 'target' and 'value'...};}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Decorator Composition"
                },
                {
                    "type": "p",
                    "text": "Multiple decorators can be applied to a declaration, for example on a single line:"
                },
                {
                    "type": "code",
                    "code": "ts@f@gxTry"
                },
                {
                    "type": "p",
                    "text": "On multiple lines:"
                },
                {
                    "type": "code",
                    "code": "ts@f@gxTry"
                },
                {
                    "type": "p",
                    "text": "When multiple decorators apply to a single declaration, their evaluation is similar tofunction composition in mathematics. In this model, when composing functionsfandg, the resulting composite (f∘g)(x) is equivalent tof(g(x))."
                },
                {
                    "type": "p",
                    "text": "As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "The expressions for each decorator are evaluated top-to-bottom.",
                        "The results are then called as functions from bottom-to-top."
                    ]
                },
                {
                    "type": "p",
                    "text": "If we were to usedecorator factories, we can observe this evaluation order with the following example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirst() {console.log(\"first(): factory evaluated\");returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {console.log(\"first(): called\");};}functionsecond() {console.log(\"second(): factory evaluated\");returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {console.log(\"second(): called\");};}classExampleClass{@first()@second()method() {}}Try"
                },
                {
                    "type": "p",
                    "text": "Which would print this output to the console:"
                },
                {
                    "type": "code",
                    "code": "shellfirst(): factory evaluatedsecond(): factory evaluatedsecond(): calledfirst(): called"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Decorator Evaluation"
                },
                {
                    "type": "p",
                    "text": "There is a well defined order to how decorators applied to various declarations inside of a class are applied:"
                },
                {
                    "type": "list",
                    "items": [
                        "Parameter Decorators, followed byMethod,Accessor, orProperty Decoratorsare applied for each instance member.",
                        "Parameter Decorators, followed byMethod,Accessor, orProperty Decoratorsare applied for each static member.",
                        "Parameter Decoratorsare applied for the constructor.",
                        "Class Decoratorsare applied for the class."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Class Decorators"
                },
                {
                    "type": "p",
                    "text": "AClass Decoratoris declared just before a class declaration.\nThe class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition.\nA class decorator cannot be used in a declaration file, or in any other ambient context (such as on adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument."
                },
                {
                    "type": "p",
                    "text": "If the class decorator returns a value, it will replace the class declaration with the provided constructor function."
                },
                {
                    "type": "p",
                    "text": "NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype.\nThe logic that applies decorators at runtime willnotdo this for you."
                },
                {
                    "type": "p",
                    "text": "The following is an example of a class decorator (@sealed) applied to aBugReportclass:"
                },
                {
                    "type": "code",
                    "code": "ts@sealedclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@sealeddecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsealed(constructor:Function) {Object.seal(constructor);Object.seal(constructor.prototype);}"
                },
                {
                    "type": "p",
                    "text": "When@sealedis executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessingBugReport.prototypeor by defining properties onBugReportitself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator doesnotprevent classes from sub-classingBugReport."
                },
                {
                    "type": "p",
                    "text": "Next we have an example of how to override the constructor to set new defaults."
                },
                {
                    "type": "code",
                    "code": "tsfunctionreportableClassDecorator<Textends{new(...args:any[]): {} }>(constructor:T) {returnclassextendsconstructor{reportingURL=\"http://www...\";};}@reportableClassDecoratorclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}}constbug=newBugReport(\"Needs dark mode\");console.log(bug.title);// Prints \"Needs dark mode\"console.log(bug.type);// Prints \"report\"// Note that the decorator _does not_ change the TypeScript type// and so the new property `reportingURL` is not known// to the type system:bug.reportingURL;Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Method Decorators"
                },
                {
                    "type": "p",
                    "text": "AMethod Decoratoris declared just before a method declaration.\nThe decorator is applied to theProperty Descriptorfor the method, and can be used to observe, modify, or replace a method definition.\nA method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "The expression for the method decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "TheProperty Descriptorfor the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  TheProperty Descriptorwill beundefinedif your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "If the method decorator returns a value, it will be used as theProperty Descriptorfor the method."
                },
                {
                    "type": "p",
                    "text": "NOTE  The return value is ignored if your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "The following is an example of a method decorator (@enumerable) applied to a method on theGreeterclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{greeting:string;constructor(message:string) {this.greeting=message;}@enumerable(false)greet() {return\"Hello, \"+this.greeting;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@enumerabledecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionenumerable(value:boolean) {returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {descriptor.enumerable=value;};}Try"
                },
                {
                    "type": "p",
                    "text": "The@enumerable(false)decorator here is adecorator factory.\nWhen the@enumerable(false)decorator is called, it modifies theenumerableproperty of the property descriptor."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Accessor Decorators"
                },
                {
                    "type": "p",
                    "text": "AnAccessor Decoratoris declared just before an accessor declaration.\nThe accessor decorator is applied to theProperty Descriptorfor the accessor and can be used to observe, modify, or replace an accessor’s definitions.\nAn accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "NOTE  TypeScript disallows decorating both thegetandsetaccessor for a single member.\nInstead, all decorators for the member must be applied to the first accessor specified in document order.\nThis is because decorators apply to aProperty Descriptor, which combines both thegetandsetaccessor, not each declaration separately."
                },
                {
                    "type": "p",
                    "text": "The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "TheProperty Descriptorfor the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  TheProperty Descriptorwill beundefinedif your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "If the accessor decorator returns a value, it will be used as theProperty Descriptorfor the member."
                },
                {
                    "type": "p",
                    "text": "NOTE  The return value is ignored if your script target is less thanES5."
                },
                {
                    "type": "p",
                    "text": "The following is an example of an accessor decorator (@configurable) applied to a member of thePointclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{private_x:number;private_y:number;constructor(x:number,y:number) {this._x=x;this._y=y;}@configurable(false)getx() {returnthis._x;}@configurable(false)gety() {returnthis._y;}}Try"
                },
                {
                    "type": "p",
                    "text": "We can define the@configurabledecorator using the following function declaration:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionconfigurable(value:boolean) {returnfunction(target:any,propertyKey:string,descriptor:PropertyDescriptor) {descriptor.configurable=value;};}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Property Decorators"
                },
                {
                    "type": "p",
                    "text": "AProperty Decoratoris declared just before a property declaration.\nA property decorator cannot be used in a declaration file, or in any other ambient context (such as in adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "The expression for the property decorator will be called as a function at runtime, with the following two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  AProperty Descriptoris not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript.\nThis is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too.\nAs such, a property decorator can only be used to observe that a property of a specific name has been declared for a class."
                },
                {
                    "type": "p",
                    "text": "We can use this information to record metadata about the property, as in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsclassGreeter{@format(\"Hello, %s\")greeting:string;constructor(message:string) {this.greeting=message;}greet() {letformatString=getFormat(this,\"greeting\");returnformatString.replace(\"%s\",this.greeting);}}"
                },
                {
                    "type": "p",
                    "text": "We can then define the@formatdecorator andgetFormatfunctions using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";constformatMetadataKey=Symbol(\"format\");functionformat(formatString:string) {returnReflect.metadata(formatMetadataKey,formatString);}functiongetFormat(target:any,propertyKey:string) {returnReflect.getMetadata(formatMetadataKey,target,propertyKey);}"
                },
                {
                    "type": "p",
                    "text": "The@format(\"Hello, %s\")decorator here is adecorator factory.\nWhen@format(\"Hello, %s\")is called, it adds a metadata entry for the property using theReflect.metadatafunction from thereflect-metadatalibrary.\nWhengetFormatis called, it reads the metadata value for the format."
                },
                {
                    "type": "p",
                    "text": "NOTE  This example requires thereflect-metadatalibrary.\nSeeMetadatafor more information about thereflect-metadatalibrary."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Parameter Decorators"
                },
                {
                    "type": "p",
                    "text": "AParameter Decoratoris declared just before a parameter declaration.\nThe parameter decorator is applied to the function for a class constructor or method declaration.\nA parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in adeclareclass)."
                },
                {
                    "type": "p",
                    "text": "The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Either the constructor function of the class for a static member, or the prototype of the class for an instance member.",
                        "The name of the member.",
                        "The ordinal index of the parameter in the function’s parameter list."
                    ]
                },
                {
                    "type": "p",
                    "text": "NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method."
                },
                {
                    "type": "p",
                    "text": "The return value of the parameter decorator is ignored."
                },
                {
                    "type": "p",
                    "text": "The following is an example of a parameter decorator (@required) applied to parameter of a member of theBugReportclass:"
                },
                {
                    "type": "code",
                    "code": "tsclassBugReport{type=\"report\";title:string;constructor(t:string) {this.title=t;}@validateprint(@requiredverbose:boolean) {if(verbose) {return`type:${this.type}\\ntitle:${this.title}`;}else{returnthis.title;}}}Try"
                },
                {
                    "type": "p",
                    "text": "We can then define the@requiredand@validatedecorators using the following function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";constrequiredMetadataKey=Symbol(\"required\");functionrequired(target:Object,propertyKey:string|symbol,parameterIndex:number) {letexistingRequiredParameters:number[] =Reflect.getOwnMetadata(requiredMetadataKey,target,propertyKey) || [];existingRequiredParameters.push(parameterIndex);Reflect.defineMetadata(requiredMetadataKey,existingRequiredParameters,target,propertyKey);}functionvalidate(target:any,propertyName:string,descriptor:TypedPropertyDescriptor<Function>) {letmethod=descriptor.value!;descriptor.value=function() {letrequiredParameters:number[] =Reflect.getOwnMetadata(requiredMetadataKey,target,propertyName);if(requiredParameters) {for(letparameterIndexofrequiredParameters) {if(parameterIndex>=arguments.length||arguments[parameterIndex] ===undefined) {thrownewError(\"Missing required argument.\");}}}returnmethod.apply(this,arguments);};}Try"
                },
                {
                    "type": "p",
                    "text": "The@requireddecorator adds a metadata entry that marks the parameter as required.\nThe@validatedecorator then wraps the existingprintmethod in a function that validates the arguments before invoking the original method."
                },
                {
                    "type": "p",
                    "text": "NOTE  This example requires thereflect-metadatalibrary.\nSeeMetadatafor more information about thereflect-metadatalibrary."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Metadata"
                },
                {
                    "type": "p",
                    "text": "Some examples use thereflect-metadatalibrary which adds a polyfill for anexperimental metadata API.\nThis library is not yet part of the ECMAScript (JavaScript) standard.\nHowever, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption."
                },
                {
                    "type": "p",
                    "text": "You can install this library via npm:"
                },
                {
                    "type": "code",
                    "code": "shellnpm i reflect-metadata --save"
                },
                {
                    "type": "p",
                    "text": "TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators.\nTo enable this experimental support, you must set theemitDecoratorMetadatacompiler option either on the command line or in yourtsconfig.json:"
                },
                {
                    "type": "p",
                    "text": "Command Line:"
                },
                {
                    "type": "code",
                    "code": "shelltsc --target ES5 --experimentalDecorators --emitDecoratorMetadata"
                },
                {
                    "type": "p",
                    "text": "tsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"ES5\",\"experimentalDecorators\":true,\"emitDecoratorMetadata\":true}}"
                },
                {
                    "type": "p",
                    "text": "When enabled, as long as thereflect-metadatalibrary has been imported, additional design-time type information will be exposed at runtime."
                },
                {
                    "type": "p",
                    "text": "We can see this in action in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsimport\"reflect-metadata\";classPoint{constructor(publicx:number,publicy:number) {}}classLine{private_start:Point;private_end:Point;@validatesetstart(value:Point) {this._start=value;}getstart() {returnthis._start;}@validatesetend(value:Point) {this._end=value;}getend() {returnthis._end;}}functionvalidate<T>(target:any,propertyKey:string,descriptor:TypedPropertyDescriptor<T>) {letset=descriptor.set!;descriptor.set=function(value:T) {lettype=Reflect.getMetadata(\"design:type\",target,propertyKey);if(!(valueinstanceoftype)) {thrownewTypeError(`Invalid type, got${typeofvalue}not${type.name}.`);}set.call(this,value);};}constline=newLine()line.start=newPoint(0,0)// @ts-ignore// line.end = {}// Fails at runtime with:// > Invalid type, got object not PointTry"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler will inject design-time type information using the@Reflect.metadatadecorator.\nYou could consider it the equivalent of the following TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsclassLine{private_start:Point;private_end:Point;@validate@Reflect.metadata(\"design:type\",Point)setstart(value:Point) {this._start=value;}getstart() {returnthis._start;}@validate@Reflect.metadata(\"design:type\",Point)setend(value:Point) {this._end=value;}getend() {returnthis._end;}}"
                },
                {
                    "type": "p",
                    "text": "NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/dom-manipulation.html",
            "title": "TypeScript: Documentation - DOM Manipulation",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "DOM Manipulation"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "DOM Manipulation"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "An exploration into theHTMLElementtype"
                },
                {
                    "type": "p",
                    "text": "In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers."
                },
                {
                    "type": "p",
                    "text": "Websites are made up of HTML and/or XML documents. These documents are static, they do not change. TheDocument Object Model (DOM)is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop."
                },
                {
                    "type": "p",
                    "text": "TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions inlib.dom.d.ts, one stands out among the rest:HTMLElement. This type is the backbone for DOM manipulation with TypeScript."
                },
                {
                    "type": "p",
                    "text": "You can explore the source code for theDOM type definitions"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Basic Example"
                },
                {
                    "type": "p",
                    "text": "Given a simplifiedindex.htmlfile:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><htmllang=\"en\"><head><title>TypeScript Dom Manipulation</title></head><body><divid=\"app\"></div><!-- Assume index.js is the compiled output of index.ts --><scriptsrc=\"index.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Let’s explore a TypeScript script that adds a<p>Hello, World!</p>element to the#appelement."
                },
                {
                    "type": "code",
                    "code": "ts// 1. Select the div element using the id propertyconstapp=document.getElementById(\"app\");// 2. Create a new <p></p> element programmaticallyconstp=document.createElement(\"p\");// 3. Add the text contentp.textContent=\"Hello, World!\";// 4. Append the p element to the div elementapp?.appendChild(p);"
                },
                {
                    "type": "p",
                    "text": "After compiling and running theindex.htmlpage, the resulting HTML will be:"
                },
                {
                    "type": "code",
                    "code": "html<divid=\"app\"><p>Hello, World!</p></div>"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TheDocumentInterface"
                },
                {
                    "type": "p",
                    "text": "The first line of the TypeScript code uses a global variabledocument. Inspecting the variable shows it is defined by theDocumentinterface from thelib.dom.d.tsfile. The code snippet contains calls to two methods,getElementByIdandcreateElement."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Document.getElementById"
                },
                {
                    "type": "p",
                    "text": "The definition for this method is as follows:"
                },
                {
                    "type": "code",
                    "code": "tsgetElementById(elementId:string):HTMLElement|null;"
                },
                {
                    "type": "p",
                    "text": "Pass it an element id string and it will return eitherHTMLElementornull. This method introduces one of the most important types,HTMLElement. It serves as the base interface for every other element interface. For example, thepvariable in the code example is of typeHTMLParagraphElement. Also, take note that this method can returnnull. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the newoptional chainingoperator is used to callappendChild."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Document.createElement"
                },
                {
                    "type": "p",
                    "text": "The definition for this method is (I have omitted thedeprecateddefinition):"
                },
                {
                    "type": "code",
                    "code": "tscreateElement<KextendskeyofHTMLElementTagNameMap>(tagName:K,options?:ElementCreationOptions):HTMLElementTagNameMap[K];createElement(tagName:string,options?:ElementCreationOptions):HTMLElement;"
                },
                {
                    "type": "p",
                    "text": "This is an overloaded function definition. The second overload is simplest and works a lot like thegetElementByIdmethod does. Pass it anystringand it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags."
                },
                {
                    "type": "p",
                    "text": "For exampledocument.createElement('xyz')returns a<xyz></xyz>element, clearly not an element that is specified by the HTML specification."
                },
                {
                    "type": "p",
                    "text": "For those interested, you can interact with custom tag elements using thedocument.getElementsByTagName"
                },
                {
                    "type": "p",
                    "text": "For the first definition ofcreateElement, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression:<K extends keyof HTMLElementTagNameMap>. This expression defines a generic parameterKthat isconstrainedto the keys of the interfaceHTMLElementTagNameMap. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceHTMLElementTagNameMap{\"a\":HTMLAnchorElement;\"abbr\":HTMLElement;\"address\":HTMLElement;\"applet\":HTMLAppletElement;\"area\":HTMLAreaElement;...}"
                },
                {
                    "type": "p",
                    "text": "Some elements do not exhibit unique properties and so they just returnHTMLElement, but other types do have unique properties and methods so they return their specific interface (which will extend from or implementHTMLElement)."
                },
                {
                    "type": "p",
                    "text": "Now, for the remainder of thecreateElementdefinition:(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]. The first argumenttagNameis defined as the generic parameterK. The TypeScript interpreter is smart enough toinferthe generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to thetagNameargument will be inferred asKand thus can be used throughout the remainder of the definition. This is exactly what happens; the return valueHTMLElementTagNameMap[K]takes thetagNameargument and uses it to return the corresponding type. This definition is how thepvariable from the code snippet gets a type ofHTMLParagraphElement. And if the code wasdocument.createElement('a'), then it would be an element of typeHTMLAnchorElement."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TheNodeinterface"
                },
                {
                    "type": "p",
                    "text": "Thedocument.getElementByIdfunction returns anHTMLElement.HTMLElementinterface extends theElementinterface which extends theNodeinterface. This prototypal extension allows for allHTMLElementsto utilize a subset of standard methods. In the code snippet, we use a property defined on theNodeinterface to append the newpelement to the website."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Node.appendChild"
                },
                {
                    "type": "p",
                    "text": "The last line of the code snippet isapp?.appendChild(p). The previous,document.getElementById, section detailed that theoptional chainingoperator is used here becauseappcan potentially be null at runtime. TheappendChildmethod is defined by:"
                },
                {
                    "type": "code",
                    "code": "tsappendChild<TextendsNode>(newChild:T):T;"
                },
                {
                    "type": "p",
                    "text": "This method works similarly to thecreateElementmethod as the generic parameterTis inferred from thenewChildargument.Tisconstrainedto another base interfaceNode."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Difference betweenchildrenandchildNodes"
                },
                {
                    "type": "p",
                    "text": "Previously, this document details theHTMLElementinterface extends fromElementwhich extends fromNode. In the DOM API there is a concept ofchildrenelements. For example in the following HTML, theptags are children of thedivelement"
                },
                {
                    "type": "code",
                    "code": "tsx<div><p>Hello, World</p><p>TypeScript!</p></div>;constdiv=document.getElementsByTagName(\"div\")[0];div.children;// HTMLCollection(2) [p, p]div.childNodes;// NodeList(2) [p, p]"
                },
                {
                    "type": "p",
                    "text": "After capturing thedivelement, thechildrenprop will return anHTMLCollectionlist containing theHTMLParagraphElements. ThechildNodesproperty will return a similarNodeListlist of nodes. Eachptag will still be of typeHTMLParagraphElements, but theNodeListcan contain additionalHTML nodesthat theHTMLCollectionlist cannot."
                },
                {
                    "type": "p",
                    "text": "Modify the HTML by removing one of theptags, but keep the text."
                },
                {
                    "type": "code",
                    "code": "tsx<div><p>Hello, World</p>TypeScript!</div>;constdiv=document.getElementsByTagName(\"div\")[0];div.children;// HTMLCollection(1) [p]div.childNodes;// NodeList(2) [p, text]"
                },
                {
                    "type": "p",
                    "text": "See how both lists change.childrennow only contains the<p>Hello, World</p>element, and thechildNodescontains atextnode rather than twopnodes. Thetextpart of theNodeListis the literalNodecontaining the textTypeScript!. Thechildrenlist does not contain thisNodebecause it is not considered anHTMLElement."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ThequerySelectorandquerySelectorAllmethods"
                },
                {
                    "type": "p",
                    "text": "Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined inlib.dom.d.tsas:"
                },
                {
                    "type": "code",
                    "code": "ts/*** Returns the first element that is a descendant of node that matches selectors.*/querySelector<KextendskeyofHTMLElementTagNameMap>(selectors:K):HTMLElementTagNameMap[K] |null;querySelector<KextendskeyofSVGElementTagNameMap>(selectors:K):SVGElementTagNameMap[K] |null;querySelector<EextendsElement=Element>(selectors:string):E|null;/*** Returns all element descendants of node that match selectors.*/querySelectorAll<KextendskeyofHTMLElementTagNameMap>(selectors:K):NodeListOf<HTMLElementTagNameMap[K]>;querySelectorAll<KextendskeyofSVGElementTagNameMap>(selectors:K):NodeListOf<SVGElementTagNameMap[K]>;querySelectorAll<EextendsElement=Element>(selectors:string):NodeListOf<E>;"
                },
                {
                    "type": "p",
                    "text": "ThequerySelectorAlldefinition is similar togetElementsByTagName, except it returns a new type:NodeListOf. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacingNodeListOf<E>withE[]would result in a very similar user experience.NodeListOfonly implements the following properties and methods:length,item(index),forEach((value, key, parent) => void), and numeric indexing. Additionally, this method returns a list ofelements, notnodes, which is whatNodeListwas returning from the.childNodesmethod. While this may appear as a discrepancy, take note that interfaceElementextends fromNode."
                },
                {
                    "type": "p",
                    "text": "To see these methods in action modify the existing code to:"
                },
                {
                    "type": "code",
                    "code": "tsx<ul><li>First :)</li><li>Second!</li><li>Third times a charm.</li></ul>;constfirst=document.querySelector(\"li\");// returns the first li elementconstall=document.querySelectorAll(\"li\");// returns the list of all li elements"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interested in learning more?"
                },
                {
                    "type": "p",
                    "text": "The best part about thelib.dom.d.tstype definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, theHTMLElementinterface is documented by thisHTMLElement pageon MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to theW3C Recommendation for HTMLElement."
                },
                {
                    "type": "p",
                    "text": "Sources:"
                },
                {
                    "type": "list",
                    "items": [
                        "ECMA-262 Standard",
                        "Introduction to the DOM"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/enums.html",
            "title": "TypeScript: Handbook - Enums",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Enums"
                },
                {
                    "type": "p",
                    "text": "Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript."
                },
                {
                    "type": "p",
                    "text": "Enums allow a developer to define a set of named constants.\nUsing enums can make it easier to document intent, or create a set of distinct cases.\nTypeScript provides both numeric and string-based enums."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Numeric enums"
                },
                {
                    "type": "p",
                    "text": "We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages.\nAn enum can be defined using theenumkeyword."
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up=1,Down,Left,Right,}Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have a numeric enum whereUpis initialized with1.\nAll of the following members are auto-incremented from that point on.\nIn other words,Direction.Uphas the value1,Downhas2,Lefthas3, andRighthas4."
                },
                {
                    "type": "p",
                    "text": "If we wanted, we could leave off the initializers entirely:"
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up,Down,Left,Right,}Try"
                },
                {
                    "type": "p",
                    "text": "Here,Upwould have the value0,Downwould have1, etc.\nThis auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum."
                },
                {
                    "type": "p",
                    "text": "Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:"
                },
                {
                    "type": "code",
                    "code": "tsenumUserResponse{No=0,Yes=1,}functionrespond(recipient:string,message:UserResponse):void{// ...}respond(\"Princess Caroline\",UserResponse.Yes);Try"
                },
                {
                    "type": "p",
                    "text": "Numeric enums can be mixed incomputed and constant members (see below).\nThe short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members.\nIn other words, the following isn’t allowed:"
                },
                {
                    "type": "code",
                    "code": "tsenumE{A=getSomeValue(),B,Enum member must have initializer.1061Enum member must have initializer.}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "String enums"
                },
                {
                    "type": "p",
                    "text": "String enums are a similar concept, but have some subtleruntime differencesas documented below.\nIn a string enum, each member has to be constant-initialized with a string literal, or with another string enum member."
                },
                {
                    "type": "code",
                    "code": "tsenumDirection{Up=\"UP\",Down=\"DOWN\",Left=\"LEFT\",Right=\"RIGHT\",}Try"
                },
                {
                    "type": "p",
                    "text": "While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well.\nIn other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (thoughreverse mappingcan often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Heterogeneous enums"
                },
                {
                    "type": "p",
                    "text": "Technically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:"
                },
                {
                    "type": "code",
                    "code": "tsenumBooleanLikeHeterogeneousEnum{No=0,Yes=\"YES\",}Try"
                },
                {
                    "type": "p",
                    "text": "Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Computed and constant members"
                },
                {
                    "type": "p",
                    "text": "Each enum member has a value associated with it which can be eitherconstantorcomputed.\nAn enum member is considered constant if:"
                },
                {
                    "type": "list",
                    "items": [
                        "It is the first member in the enum and it has no initializer, in which case it’s assigned the value0:ts// E.X is constant:enumE{X,}Try",
                        "It does not have an initializer and the preceding enum member was anumericconstant.\nIn this case the value of the current enum member will be the value of the preceding enum member plus one.ts// All enum members in 'E1' and 'E2' are constant.enumE1{X,Y,Z,}enumE2{A=1,B,C,}Try",
                        "The enum member is initialized with a constant enum expression.\nA constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time.\nAn expression is a constant enum expression if it is:a literal enum expression (basically a string literal or a numeric literal)a reference to previously defined constant enum member (which can originate from a different enum)a parenthesized constant enum expressionone of the+,-,~unary operators applied to constant enum expression+,-,*,/,%,<<,>>,>>>,&,|,^binary operators with constant enum expressions as operandsIt is a compile time error for constant enum expressions to be evaluated toNaNorInfinity.",
                        "a literal enum expression (basically a string literal or a numeric literal)",
                        "a reference to previously defined constant enum member (which can originate from a different enum)",
                        "a parenthesized constant enum expression",
                        "one of the+,-,~unary operators applied to constant enum expression",
                        "+,-,*,/,%,<<,>>,>>>,&,|,^binary operators with constant enum expressions as operands"
                    ]
                },
                {
                    "type": "p",
                    "text": "It is the first member in the enum and it has no initializer, in which case it’s assigned the value0:"
                },
                {
                    "type": "code",
                    "code": "ts// E.X is constant:enumE{X,}Try"
                },
                {
                    "type": "p",
                    "text": "It does not have an initializer and the preceding enum member was anumericconstant.\nIn this case the value of the current enum member will be the value of the preceding enum member plus one."
                },
                {
                    "type": "code",
                    "code": "ts// All enum members in 'E1' and 'E2' are constant.enumE1{X,Y,Z,}enumE2{A=1,B,C,}Try"
                },
                {
                    "type": "p",
                    "text": "The enum member is initialized with a constant enum expression.\nA constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time.\nAn expression is a constant enum expression if it is:"
                },
                {
                    "type": "list",
                    "items": [
                        "a literal enum expression (basically a string literal or a numeric literal)",
                        "a reference to previously defined constant enum member (which can originate from a different enum)",
                        "a parenthesized constant enum expression",
                        "one of the+,-,~unary operators applied to constant enum expression",
                        "+,-,*,/,%,<<,>>,>>>,&,|,^binary operators with constant enum expressions as operands"
                    ]
                },
                {
                    "type": "p",
                    "text": "It is a compile time error for constant enum expressions to be evaluated toNaNorInfinity."
                },
                {
                    "type": "p",
                    "text": "In all other cases enum member is considered computed."
                },
                {
                    "type": "code",
                    "code": "tsenumFileAccess{// constant membersNone,Read=1<<1,Write=1<<2,ReadWrite=Read|Write,// computed memberG=\"123\".length,}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Union enums and enum member types"
                },
                {
                    "type": "p",
                    "text": "There is a special subset of constant enum members that aren’t calculated: literal enum members.\nA literal enum member is a constant enum member with no initialized value, or with values that are initialized to"
                },
                {
                    "type": "list",
                    "items": [
                        "any string literal (e.g.\"foo\",\"bar\",\"baz\")",
                        "any numeric literal (e.g.1,100)",
                        "a unary minus applied to any numeric literal (e.g.-1,-100)"
                    ]
                },
                {
                    "type": "p",
                    "text": "When all members in an enum have literal enum values, some special semantics come into play."
                },
                {
                    "type": "p",
                    "text": "The first is that enum members also become types as well!\nFor example, we can say that certain members canonlyhave the value of an enum member:"
                },
                {
                    "type": "code",
                    "code": "tsenumShapeKind{Circle,Square,}interfaceCircle{kind:ShapeKind.Circle;radius:number;}interfaceSquare{kind:ShapeKind.Square;sideLength:number;}letc:Circle= {kind:ShapeKind.Square,Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.radius:100,};Try"
                },
                {
                    "type": "p",
                    "text": "The other change is that enum types themselves effectively become aunionof each enum member.\nWith union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself.\nBecause of that, TypeScript can catch bugs where we might be comparing values incorrectly.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsenumE{Foo,Bar,}functionf(x:E) {if(x!==E.Foo||x!==E.Bar) {This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.//}}Try"
                },
                {
                    "type": "p",
                    "text": "In that example, we first checked whetherxwasnotE.Foo.\nIf that check succeeds, then our||will short-circuit, and the body of the ‘if’ will run.\nHowever, if the check didn’t succeed, thenxcanonlybeE.Foo, so it doesn’t make sense to see whether it’snotequal toE.Bar."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Enums at runtime"
                },
                {
                    "type": "p",
                    "text": "Enums are real objects that exist at runtime.\nFor example, the following enum"
                },
                {
                    "type": "code",
                    "code": "tsenumE{X,Y,Z,}Try"
                },
                {
                    "type": "p",
                    "text": "can actually be passed around to functions"
                },
                {
                    "type": "code",
                    "code": "tsenumE{X,Y,Z,}functionf(obj: {X:number}) {returnobj.X;}// Works, since 'E' has a property named 'X' which is a number.f(E);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Enums at compile time"
                },
                {
                    "type": "p",
                    "text": "Even though Enums are real objects that exist at runtime, thekeyofkeyword works differently than you might expect for typical objects. Instead, usekeyof typeofto get a Type that represents all Enum keys as strings."
                },
                {
                    "type": "code",
                    "code": "tsenumLogLevel{ERROR,WARN,INFO,DEBUG,}/*** This is equivalent to:* type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';*/typeLogLevelStrings=keyoftypeofLogLevel;functionprintImportant(key:LogLevelStrings,message:string) {constnum=LogLevel[key];if(num<=LogLevel.WARN) {console.log(\"Log level key is:\",key);console.log(\"Log level value is:\",num);console.log(\"Log level message is:\",message);}}printImportant(\"ERROR\",\"This is a message\");Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reverse mappings"
                },
                {
                    "type": "p",
                    "text": "In addition to creating an object with property names for members, numeric enums members also get areverse mappingfrom enum values to enum names.\nFor example, in this example:"
                },
                {
                    "type": "code",
                    "code": "tsenumEnum{A,}leta=Enum.A;letnameOfA=Enum[a];// \"A\"Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript compiles this down to the following JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";varEnum;(function(Enum) {Enum[Enum[\"A\"] =0] =\"A\";})(Enum|| (Enum= {}));leta=Enum.A;letnameOfA=Enum[a];// \"A\"Try"
                },
                {
                    "type": "p",
                    "text": "In this generated code, an enum is compiled into an object that stores both forward (name->value) and reverse (value->name) mappings.\nReferences to other enum members are always emitted as property accesses and never inlined."
                },
                {
                    "type": "p",
                    "text": "Keep in mind that string enum membersdo notget a reverse mapping generated at all."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "constenums"
                },
                {
                    "type": "p",
                    "text": "In most cases, enums are a perfectly valid solution.\nHowever sometimes requirements are tighter.\nTo avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to useconstenums.\nConst enums are defined using theconstmodifier on our enums:"
                },
                {
                    "type": "code",
                    "code": "tsconstenumEnum{A=1,B=A*2,}Try"
                },
                {
                    "type": "p",
                    "text": "Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation.\nConst enum members are inlined at use sites.\nThis is possible since const enums cannot have computed members."
                },
                {
                    "type": "code",
                    "code": "tsconstenumDirection{Up,Down,Left,Right,}letdirections= [Direction.Up,Direction.Down,Direction.Left,Direction.Right,];Try"
                },
                {
                    "type": "p",
                    "text": "in generated code will become"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";letdirections= [0/* Direction.Up */,1/* Direction.Down */,2/* Direction.Left */,3/* Direction.Right */,];Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Const enum pitfalls"
                },
                {
                    "type": "p",
                    "text": "Inlining enum values is straightforward at first, but comes with subtle implications.\nThese pitfalls pertain toambientconst enums only (basically const enums in.d.tsfiles) and sharing them between projects, but if you are publishing or consuming.d.tsfiles, these pitfalls likely apply to you, becausetsc --declarationtransforms.tsfiles into.d.tsfiles."
                },
                {
                    "type": "list",
                    "items": [
                        "For the reasons laid out in theisolatedModulesdocumentation, that mode is fundamentally incompatible with ambient const enums.\nThis means if you publish ambient const enums, downstream consumers will not be able to useisolatedModulesand those enum values at the same time.",
                        "You can easily inline values from version A of a dependency at compile time, and import version B at runtime.\nVersion A and B’s enums can have different values, if you are not very careful, resulting insurprising bugs, like taking the wrong branches ofifstatements.\nThese bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.",
                        "importsNotUsedAsValues: \"preserve\"will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime.jsfiles exist.\nThe unresolvable imports cause errors at runtime.\nThe usual way to unambiguously elide imports,type-only imports,does not allow const enum values, currently."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here are two approaches to avoiding these pitfalls:"
                },
                {
                    "type": "list",
                    "items": [
                        "Do not use const enums at all.\nYou can easilyban const enumswith the help of a linter.\nObviously this avoids any issues with const enums, but prevents your project from inlining its own enums.\nUnlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.",
                        "Do not publish ambient const enums, by deconstifying them with the help ofpreserveConstEnums.\nThis is the approach taken internally by theTypeScript project itself.preserveConstEnumsemits the same JavaScript for const enums as plain enums.\nYou can then safely strip theconstmodifier from.d.tsfilesin a build step.This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely."
                    ]
                },
                {
                    "type": "p",
                    "text": "Do not use const enums at all.\nYou can easilyban const enumswith the help of a linter.\nObviously this avoids any issues with const enums, but prevents your project from inlining its own enums.\nUnlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications."
                },
                {
                    "type": "p",
                    "text": "Do not publish ambient const enums, by deconstifying them with the help ofpreserveConstEnums.\nThis is the approach taken internally by theTypeScript project itself.preserveConstEnumsemits the same JavaScript for const enums as plain enums.\nYou can then safely strip theconstmodifier from.d.tsfilesin a build step."
                },
                {
                    "type": "p",
                    "text": "This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ambient enums"
                },
                {
                    "type": "p",
                    "text": "Ambient enums are used to describe the shape of already existing enum types."
                },
                {
                    "type": "code",
                    "code": "tsdeclareenumEnum{A=1,B,C=2,}Try"
                },
                {
                    "type": "p",
                    "text": "One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant.\nBy contrast, an ambient (and non-const) enum member that does not have an initializer isalwaysconsidered computed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Objects vs Enums"
                },
                {
                    "type": "p",
                    "text": "In modern TypeScript, you may not need an enum when an object withas constcould suffice:"
                },
                {
                    "type": "code",
                    "code": "tsconstenumEDirection{Up,Down,Left,Right,}constODirection= {Up:0,Down:1,Left:2,Right:3,}asconst;EDirection.Up;(enum member) EDirection.Up = 0ODirection.Up;(property) Up: 0// Using the enum as a parameterfunctionwalk(dir:EDirection) {}// It requires an extra line to pull out the valuestypeDirection=typeofODirection[keyoftypeofODirection];functionrun(dir:Direction) {}walk(EDirection.Left);run(ODirection.Right);Try"
                },
                {
                    "type": "p",
                    "text": "The biggest argument in favour of this format over TypeScript’senumis that it keeps your codebase aligned with the state of JavaScript, andwhen/ifenums are added to JavaScript then you can move to the additional syntax."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters",
            "title": "TypeScript: Handbook - Functions",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "This page has been deprecated"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Functions"
                },
                {
                    "type": "p",
                    "text": "Functions are the fundamental building block of any application in JavaScript.\nThey’re how you build up layers of abstraction, mimicking classes, information hiding, and modules.\nIn TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how todothings.\nTypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Functions"
                },
                {
                    "type": "p",
                    "text": "To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function.\nThis allows you to choose the most appropriate approach for your application, whether you’re building a list of functions in an API or a one-off function to hand off to another function."
                },
                {
                    "type": "p",
                    "text": "To quickly recap what these two approaches look like in JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts// Named functionfunctionadd(x,y) {returnx+y;}// Anonymous functionletmyAdd=function(x,y) {returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "Just as in JavaScript, functions can refer to variables outside of the function body.\nWhen they do so, they’re said tocapturethese variables.\nWhile understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript."
                },
                {
                    "type": "code",
                    "code": "tsletz=100;functionaddToZ(x,y) {returnx+y+z;}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Typing the function"
                },
                {
                    "type": "p",
                    "text": "Let’s add types to our simple examples from earlier:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionadd(x:number,y:number):number{returnx+y;}letmyAdd=function(x:number,y:number):number{returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "We can add types to each of the parameters and then to the function itself to add a return type.\nTypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Writing the function type"
                },
                {
                    "type": "p",
                    "text": "Now that we’ve typed the function, let’s write the full type of the function out by looking at each piece of the function type."
                },
                {
                    "type": "code",
                    "code": "tsletmyAdd: (x:number,y:number)=>number=function(x:number,y:number):number{returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "A function’s type has the same two parts: the type of the arguments and the return type.\nWhen writing out the whole function type, both parts are required.\nWe write out the parameter types just like a parameter list, giving each parameter a name and a type.\nThis name is just to help with readability.\nWe could have instead written:"
                },
                {
                    "type": "code",
                    "code": "tsletmyAdd: (baseValue:number,increment:number)=>number=function(x:number,y:number):number{returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "As long as the parameter types line up, it’s considered a valid type for the function, regardless of the names you give the parameters in the function type."
                },
                {
                    "type": "p",
                    "text": "The second part is the return type.\nWe make it clear which is the return type by using an arrow (=>) between the parameters and the return type.\nAs mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would usevoidinstead of leaving it off."
                },
                {
                    "type": "p",
                    "text": "Of note, only the parameters and the return type make up the function type.\nCaptured variables are not reflected in the type.\nIn effect, captured variables are part of the “hidden state” of any function and do not make up its API."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inferring the types"
                },
                {
                    "type": "p",
                    "text": "In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:"
                },
                {
                    "type": "code",
                    "code": "ts// The parameters 'x' and 'y' have the type numberletmyAdd=function(x:number,y:number):number{returnx+y;};// myAdd has the full function typeletmyAdd2: (baseValue:number,increment:number)=>number=function(x,y) {returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "This is called “contextual typing”, a form of type inference.\nThis helps cut down on the amount of effort to keep your program typed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Optional and Default Parameters"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, every parameter is assumed to be required by the function.\nThis doesn’t mean that it can’t be givennullorundefined, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter.\nThe compiler also assumes that these parameters are the only parameters that will be passed to the function.\nIn short, the number of arguments given to a function has to match the number of parameters the function expects."
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string,lastName:string) {returnfirstName+\" \"+lastName;}letresult1=buildName(\"Bob\");// error, too few parametersExpected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.letresult2=buildName(\"Bob\",\"Adams\",\"Sr.\");// error, too many parametersExpected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.letresult3=buildName(\"Bob\",\"Adams\");// ah, just rightTry"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, every parameter is optional, and users may leave them off as they see fit.\nWhen they do, their value isundefined.\nWe can get this functionality in TypeScript by adding a?to the end of parameters we want to be optional.\nFor example, let’s say we want the last name parameter from above to be optional:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string,lastName?:string) {if(lastName)returnfirstName+\" \"+lastName;elsereturnfirstName;}letresult1=buildName(\"Bob\");// works correctly nowletresult2=buildName(\"Bob\",\"Adams\",\"Sr.\");// error, too many parametersExpected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.letresult3=buildName(\"Bob\",\"Adams\");// ah, just rightTry"
                },
                {
                    "type": "p",
                    "text": "Any optional parameters must follow required parameters.\nHad we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passesundefinedin its place.\nThese are called default-initialized parameters.\nLet’s take the previous example and default the last name to\"Smith\"."
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string,lastName=\"Smith\") {returnfirstName+\" \"+lastName;}letresult1=buildName(\"Bob\");// works correctly now, returns \"Bob Smith\"letresult2=buildName(\"Bob\",undefined);// still works, also returns \"Bob Smith\"letresult3=buildName(\"Bob\",\"Adams\",\"Sr.\");// error, too many parametersExpected 1-2 arguments, but got 3.2554Expected 1-2 arguments, but got 3.letresult4=buildName(\"Bob\",\"Adams\");// ah, just rightTry"
                },
                {
                    "type": "p",
                    "text": "Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function.\nThis means optional parameters and trailing default parameters will share commonality in their types, so both"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string,lastName?:string) {// ...}"
                },
                {
                    "type": "p",
                    "text": "and"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string,lastName=\"Smith\") {// ...}"
                },
                {
                    "type": "p",
                    "text": "share the same type(firstName: string, lastName?: string) => string.\nThe default value oflastNamedisappears in the type, only leaving behind the fact that the parameter is optional."
                },
                {
                    "type": "p",
                    "text": "Unlike plain optional parameters, default-initialized parameters don’tneedto occur after required parameters.\nIf a default-initialized parameter comes before a required parameter, users need to explicitly passundefinedto get the default initialized value.\nFor example, we could write our last example with only a default initializer onfirstName:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName=\"Will\",lastName:string) {returnfirstName+\" \"+lastName;}letresult1=buildName(\"Bob\");// error, too few parametersExpected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.letresult2=buildName(\"Bob\",\"Adams\",\"Sr.\");// error, too many parametersExpected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.letresult3=buildName(\"Bob\",\"Adams\");// okay and returns \"Bob Adams\"letresult4=buildName(undefined,\"Adams\");// okay and returns \"Will Adams\"Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rest Parameters"
                },
                {
                    "type": "p",
                    "text": "Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time.\nSometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take.\nIn JavaScript, you can work with the arguments directly using theargumentsvariable that is visible inside every function body."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, you can gather these arguments together into a variable:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string, ...restOfName:string[]) {returnfirstName+\" \"+restOfName.join(\" \");}// employeeName will be \"Joseph Samuel Lucas MacKinzie\"letemployeeName=buildName(\"Joseph\",\"Samuel\",\"Lucas\",\"MacKinzie\");Try"
                },
                {
                    "type": "p",
                    "text": "Rest parametersare treated as a boundless number of optional parameters.\nWhen passing arguments for a rest parameter, you can use as many as you want; you can even pass none.\nThe compiler will build an array of the arguments passed in with the name given after the ellipsis (...), allowing you to use it in your function."
                },
                {
                    "type": "p",
                    "text": "The ellipsis is also used in the type of the function with rest parameters:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbuildName(firstName:string, ...restOfName:string[]) {returnfirstName+\" \"+restOfName.join(\" \");}letbuildNameFun: (fname:string, ...rest:string[])=>string=buildName;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "this"
                },
                {
                    "type": "p",
                    "text": "Learning how to usethisin JavaScript is something of a rite of passage.\nSince TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to usethisand how to spot when it’s not being used correctly.\nFortunately, TypeScript lets you catch incorrect uses ofthiswith a couple of techniques.\nIf you need to learn howthisworks in JavaScript, though, first read Yehuda Katz’sUnderstanding JavaScript Function Invocation and “this”.\nYehuda’s article explains the inner workings ofthisvery well, so we’ll just cover the basics here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "thisand arrow functions"
                },
                {
                    "type": "p",
                    "text": "In JavaScript,thisis a variable that’s set when a function is called.\nThis makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in.\nThis is notoriously confusing, especially when returning a function or passing a function as an argument."
                },
                {
                    "type": "p",
                    "text": "Let’s look at an example:"
                },
                {
                    "type": "code",
                    "code": "tsletdeck= {suits:[\"hearts\",\"spades\",\"clubs\",\"diamonds\"],cards:Array(52),createCardPicker:function() {returnfunction() {letpickedCard=Math.floor(Math.random() *52);letpickedSuit=Math.floor(pickedCard/13);return{suit:this.suits[pickedSuit],card:pickedCard%13};};},};letcardPicker=deck.createCardPicker();letpickedCard=cardPicker();alert(\"card: \"+pickedCard.card+\" of \"+pickedCard.suit);Try"
                },
                {
                    "type": "p",
                    "text": "Notice thatcreateCardPickeris a function that itself returns a function.\nIf we tried to run the example, we would get an error instead of the expected alert box.\nThis is because thethisbeing used in the function created bycreateCardPickerwill be set towindowinstead of ourdeckobject.\nThat’s because we callcardPicker()on its own.\nA top-level non-method syntax call like this will usewindowforthis.\n(Note: under strict mode,thiswill beundefinedrather thanwindow)."
                },
                {
                    "type": "p",
                    "text": "We can fix this by making sure the function is bound to the correctthisbefore we return the function to be used later.\nThis way, regardless of how it’s later used, it will still be able to see the originaldeckobject.\nTo do this, we change the function expression to use the ECMAScript 6 arrow syntax.\nArrow functions capture thethiswhere the function is created rather than where it is invoked:"
                },
                {
                    "type": "code",
                    "code": "tsletdeck= {suits:[\"hearts\",\"spades\",\"clubs\",\"diamonds\"],cards:Array(52),createCardPicker:function() {// NOTE: the line below is now an arrow function, allowing us to capture 'this' right herereturn()=>{letpickedCard=Math.floor(Math.random() *52);letpickedSuit=Math.floor(pickedCard/13);return{suit:this.suits[pickedSuit],card:pickedCard%13};};},};letcardPicker=deck.createCardPicker();letpickedCard=cardPicker();alert(\"card: \"+pickedCard.card+\" of \"+pickedCard.suit);Try"
                },
                {
                    "type": "p",
                    "text": "Even better, TypeScript will warn you when you make this mistake if you pass thenoImplicitThisflag to the compiler.\nIt will point out thatthisinthis.suits[pickedSuit]is of typeany."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "thisparameters"
                },
                {
                    "type": "p",
                    "text": "Unfortunately, the type ofthis.suits[pickedSuit]is stillany.\nThat’s becausethiscomes from the function expression inside the object literal.\nTo fix this, you can provide an explicitthisparameter.thisparameters are fake parameters that come first in the parameter list of a function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(this:void) {// make sure `this` is unusable in this standalone function}"
                },
                {
                    "type": "p",
                    "text": "Let’s add a couple of interfaces to our example above,CardandDeck, to make the types clearer and easier to reuse:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCard{suit:string;card:number;}interfaceDeck{suits:string[];cards:number[];createCardPicker(this:Deck): ()=>Card;}letdeck:Deck= {suits:[\"hearts\",\"spades\",\"clubs\",\"diamonds\"],cards:Array(52),// NOTE: The function now explicitly specifies that its callee must be of type DeckcreateCardPicker:function(this:Deck) {return()=>{letpickedCard=Math.floor(Math.random() *52);letpickedSuit=Math.floor(pickedCard/13);return{suit:this.suits[pickedSuit],card:pickedCard%13};};},};letcardPicker=deck.createCardPicker();letpickedCard=cardPicker();alert(\"card: \"+pickedCard.card+\" of \"+pickedCard.suit);Try"
                },
                {
                    "type": "p",
                    "text": "Now TypeScript knows thatcreateCardPickerexpects to be called on aDeckobject.\nThat means thatthisis of typeDecknow, notany, sonoImplicitThiswill not cause any errors."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "thisparameters in callbacks"
                },
                {
                    "type": "p",
                    "text": "You can also run into errors withthisin callbacks, when you pass functions to a library that will later call them.\nBecause the library that calls your callback will call it like a normal function,thiswill beundefined.\nWith some work you can usethisparameters to prevent errors with callbacks too.\nFirst, the library author needs to annotate the callback type withthis:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUIElement{addClickListener(onclick: (this:void,e:Event)=>void):void;}Try"
                },
                {
                    "type": "p",
                    "text": "this: voidmeans thataddClickListenerexpectsonclickto be a function that does not require athistype.\nSecond, annotate your calling code withthis:"
                },
                {
                    "type": "code",
                    "code": "tsclassHandler{info:string;onClickBad(this:Handler,e:Event) {// oops, used `this` here. using this callback would crash at runtimethis.info=e.message;}}leth=newHandler();uiElement.addClickListener(h.onClickBad);// error!Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.\n  The 'this' types of each signature are incompatible.\n    Type 'void' is not assignable to type 'Handler'.2345Argument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.\n  The 'this' types of each signature are incompatible.\n    Type 'void' is not assignable to type 'Handler'.Try"
                },
                {
                    "type": "p",
                    "text": "Withthisannotated, you make it explicit thatonClickBadmust be called on an instance ofHandler.\nThen TypeScript will detect thataddClickListenerrequires a function that hasthis: void.\nTo fix the error, change the type ofthis:"
                },
                {
                    "type": "code",
                    "code": "tsclassHandler{info:string;onClickGood(this:void,e:Event) {// can't use `this` here because it's of type void!console.log(\"clicked!\");}}leth=newHandler();uiElement.addClickListener(h.onClickGood);Try"
                },
                {
                    "type": "p",
                    "text": "BecauseonClickGoodspecifies itsthistype asvoid, it is legal to pass toaddClickListener.\nOf course, this also means that it can’t usethis.info.\nIf you want both then you’ll have to use an arrow function:"
                },
                {
                    "type": "code",
                    "code": "tsclassHandler{info:string;onClickGood= (e:Event)=>{this.info=e.message;};}Try"
                },
                {
                    "type": "p",
                    "text": "This works because arrow functions use the outerthis, so you can always pass them to something that expectsthis: void.\nThe downside is that one arrow function is created per object of type Handler.\nMethods, on the other hand, are only created once and attached to Handler’s prototype.\nThey are shared between all objects of type Handler."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Overloads"
                },
                {
                    "type": "p",
                    "text": "JavaScript is inherently a very dynamic language.\nIt’s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in."
                },
                {
                    "type": "code",
                    "code": "tsletsuits= [\"hearts\",\"spades\",\"clubs\",\"diamonds\"];functionpickCard(x:any):any{// Check to see if we're working with an object/array// if so, they gave us the deck and we'll pick the cardif(typeofx==\"object\") {letpickedCard=Math.floor(Math.random() *x.length);returnpickedCard;}// Otherwise just let them pick the cardelseif(typeofx==\"number\") {letpickedSuit=Math.floor(x/13);return{suit:suits[pickedSuit],card:x%13};}}letmyDeck= [{suit:\"diamonds\",card:2},{suit:\"spades\",card:10},{suit:\"hearts\",card:4},];letpickedCard1=myDeck[pickCard(myDeck)];alert(\"card: \"+pickedCard1.card+\" of \"+pickedCard1.suit);letpickedCard2=pickCard(15);alert(\"card: \"+pickedCard2.card+\" of \"+pickedCard2.suit);Try"
                },
                {
                    "type": "p",
                    "text": "Here, thepickCardfunction will return two different things based on what the user has passed in.\nIf the users passes in an object that represents the deck, the function will pick the card.\nIf the user picks the card, we tell them which card they’ve picked.\nBut how do we describe this to the type system?"
                },
                {
                    "type": "p",
                    "text": "The answer is to supply multiple function types for the same function as a list of overloads.\nThis list is what the compiler will use to resolve function calls.\nLet’s create a list of overloads that describe what ourpickCardaccepts and what it returns."
                },
                {
                    "type": "code",
                    "code": "tsletsuits= [\"hearts\",\"spades\",\"clubs\",\"diamonds\"];functionpickCard(x: {suit:string;card:number}[]):number;functionpickCard(x:number): {suit:string;card:number};functionpickCard(x:any):any{// Check to see if we're working with an object/array// if so, they gave us the deck and we'll pick the cardif(typeofx==\"object\") {letpickedCard=Math.floor(Math.random() *x.length);returnpickedCard;}// Otherwise just let them pick the cardelseif(typeofx==\"number\") {letpickedSuit=Math.floor(x/13);return{suit:suits[pickedSuit],card:x%13};}}letmyDeck= [{suit:\"diamonds\",card:2},{suit:\"spades\",card:10},{suit:\"hearts\",card:4},];letpickedCard1=myDeck[pickCard(myDeck)];alert(\"card: \"+pickedCard1.card+\" of \"+pickedCard1.suit);letpickedCard2=pickCard(15);alert(\"card: \"+pickedCard2.card+\" of \"+pickedCard2.suit);Try"
                },
                {
                    "type": "p",
                    "text": "With this change, the overloads now give us type checked calls to thepickCardfunction."
                },
                {
                    "type": "p",
                    "text": "In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript.\nIt looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters.\nIf it finds a match, it picks this overload as the correct overload.\nFor this reason, it’s customary to order overloads from most specific to least specific."
                },
                {
                    "type": "p",
                    "text": "Note that thefunction pickCard(x): anypiece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number.\nCallingpickCardwith any other parameter types would cause an error."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/generics.html#generic-types",
            "title": "TypeScript: Handbook - Generics",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "This page has been deprecated"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable.\nComponents that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems."
                },
                {
                    "type": "p",
                    "text": "In languages like C# and Java, one of the main tools in the toolbox for creating reusable components isgenerics, that is, being able to create a component that can work over a variety of types rather than a single one.\nThis allows users to consume these components and use their own types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Hello World of Generics"
                },
                {
                    "type": "p",
                    "text": "To start off, let’s do the “hello world” of generics: the identity function.\nThe identity function is a function that will return back whatever is passed in.\nYou can think of this in a similar way to theechocommand."
                },
                {
                    "type": "p",
                    "text": "Without generics, we would either have to give the identity function a specific type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity(arg:number):number{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Or, we could describe the identity function using theanytype:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity(arg:any):any{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "While usinganyis certainly generic in that it will cause the function to accept any and all types for the type ofarg, we actually are losing the information about what that type was when the function returns.\nIf we passed in a number, the only information we have is that any type could be returned."
                },
                {
                    "type": "p",
                    "text": "Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned.\nHere, we will use atype variable, a special kind of variable that works on types rather than values."
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<T>(arg:T):T{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "We’ve now added a type variableTto the identity function.\nThisTallows us to capture the type the user provides (e.g.number), so that we can use that information later.\nHere, we useTagain as the return type. On inspection, we can now see the same type is used for the argument and the return type.\nThis allows us to traffic that type information in one side of the function and out the other."
                },
                {
                    "type": "p",
                    "text": "We say that this version of theidentityfunction is generic, as it works over a range of types.\nUnlike usingany, it’s also just as precise (ie, it doesn’t lose any information) as the firstidentityfunction that used numbers for the argument and return type."
                },
                {
                    "type": "p",
                    "text": "Once we’ve written the generic identity function, we can call it in one of two ways.\nThe first way is to pass all of the arguments, including the type argument, to the function:"
                },
                {
                    "type": "code",
                    "code": "tsletoutput=identity<string>(\"myString\");let output: stringTry"
                },
                {
                    "type": "p",
                    "text": "Here we explicitly setTto bestringas one of the arguments to the function call, denoted using the<>around the arguments rather than()."
                },
                {
                    "type": "p",
                    "text": "The second way is also perhaps the most common. Here we usetype argument inference— that is, we want the compiler to set the value ofTfor us automatically based on the type of the argument we pass in:"
                },
                {
                    "type": "code",
                    "code": "tsletoutput=identity(\"myString\");let output: stringTry"
                },
                {
                    "type": "p",
                    "text": "Notice that we didn’t have to explicitly pass the type in the angle brackets (<>); the compiler just looked at the value\"myString\", and setTto its type.\nWhile type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Working with Generic Type Variables"
                },
                {
                    "type": "p",
                    "text": "When you begin to use generics, you’ll notice that when you create generic functions likeidentity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly.\nThat is, that you actually treat these parameters as if they could be any and all types."
                },
                {
                    "type": "p",
                    "text": "Let’s take ouridentityfunction from earlier:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<T>(arg:T):T{returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "What if we want to also log the length of the argumentargto the console with each call?\nWe might be tempted to write this:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<T>(arg:T):T{console.log(arg.length);Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "When we do, the compiler will give us an error that we’re using the.lengthmember ofarg, but nowhere have we said thatarghas this member.\nRemember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in anumberinstead, which does not have a.lengthmember."
                },
                {
                    "type": "p",
                    "text": "Let’s say that we’ve actually intended this function to work on arrays ofTrather thanTdirectly. Since we’re working with arrays, the.lengthmember should be available.\nWe can describe this just like we would create arrays of other types:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<T>(arg:T[]):T[] {console.log(arg.length);returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "You can read the type ofloggingIdentityas “the generic functionloggingIdentitytakes a type parameterT, and an argumentargwhich is an array ofTs, and returns an array ofTs.”\nIf we passed in an array of numbers, we’d get an array of numbers back out, asTwould bind tonumber.\nThis allows us to use our generic type variableTas part of the types we’re working with, rather than the whole type, giving us greater flexibility."
                },
                {
                    "type": "p",
                    "text": "We can alternatively write the sample example this way:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<T>(arg:Array<T>):Array<T> {console.log(arg.length);// Array has a .length, so no more errorreturnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "You may already be familiar with this style of type from other languages.\nIn the next section, we’ll cover how you can create your own generic types likeArray<T>."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Types"
                },
                {
                    "type": "p",
                    "text": "In previous sections, we created generic identity functions that worked over a range of types.\nIn this section, we’ll explore the type of the functions themselves and how to create generic interfaces."
                },
                {
                    "type": "p",
                    "text": "The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<T>(arg:T):T{returnarg;}letmyIdentity: <T>(arg:T)=>T=identity;Try"
                },
                {
                    "type": "p",
                    "text": "We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up."
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<T>(arg:T):T{returnarg;}letmyIdentity: <U>(arg:U)=>U=identity;Try"
                },
                {
                    "type": "p",
                    "text": "We can also write the generic type as a call signature of an object literal type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionidentity<T>(arg:T):T{returnarg;}letmyIdentity: { <T>(arg:T):T} =identity;Try"
                },
                {
                    "type": "p",
                    "text": "Which leads us to writing our first generic interface.\nLet’s take the object literal from the previous example and move it to an interface:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGenericIdentityFn{<T>(arg:T):T;}functionidentity<T>(arg:T):T{returnarg;}letmyIdentity:GenericIdentityFn=identity;Try"
                },
                {
                    "type": "p",
                    "text": "In a similar example, we may want to move the generic parameter to be a parameter of the whole interface.\nThis lets us see what type(s) we’re generic over (e.g.Dictionary<string>rather than justDictionary).\nThis makes the type parameter visible to all the other members of the interface."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGenericIdentityFn<T> {(arg:T):T;}functionidentity<T>(arg:T):T{returnarg;}letmyIdentity:GenericIdentityFn<number> =identity;Try"
                },
                {
                    "type": "p",
                    "text": "Notice that our example has changed to be something slightly different.\nInstead of describing a generic function, we now have a non-generic function signature that is a part of a generic type.\nWhen we useGenericIdentityFn, we now will also need to specify the corresponding type argument (here:number), effectively locking in what the underlying call signature will use.\nUnderstanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic."
                },
                {
                    "type": "p",
                    "text": "In addition to generic interfaces, we can also create generic classes.\nNote that it is not possible to create generic enums and namespaces."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Classes"
                },
                {
                    "type": "p",
                    "text": "A generic class has a similar shape to a generic interface.\nGeneric classes have a generic type parameter list in angle brackets (<>) following the name of the class."
                },
                {
                    "type": "code",
                    "code": "tsclassGenericNumber<T> {zeroValue:T;add: (x:T,y:T)=>T;}letmyGenericNumber=newGenericNumber<number>();myGenericNumber.zeroValue=0;myGenericNumber.add=function(x,y) {returnx+y;};Try"
                },
                {
                    "type": "p",
                    "text": "This is a pretty literal use of theGenericNumberclass, but you may have noticed that nothing is restricting it to only use thenumbertype.\nWe could have instead usedstringor even more complex objects."
                },
                {
                    "type": "code",
                    "code": "tsletstringNumeric=newGenericNumber<string>();stringNumeric.zeroValue=\"\";stringNumeric.add=function(x,y) {returnx+y;};console.log(stringNumeric.add(stringNumeric.zeroValue,\"test\"));Try"
                },
                {
                    "type": "p",
                    "text": "Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type."
                },
                {
                    "type": "p",
                    "text": "As we covered inour section on classes, a class has two sides to its type: the static side and the instance side.\nGeneric classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generic Constraints"
                },
                {
                    "type": "p",
                    "text": "If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have.\nIn ourloggingIdentityexample, we wanted to be able to access the.lengthproperty ofarg, but the compiler could not prove that every type had a.lengthproperty, so it warns us that we can’t make this assumption."
                },
                {
                    "type": "code",
                    "code": "tsfunctionloggingIdentity<T>(arg:T):T{console.log(arg.length);Property 'length' does not exist on type 'T'.2339Property 'length' does not exist on type 'T'.returnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Instead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the.lengthproperty.\nAs long as the type has this member, we’ll allow it, but it’s required to have at least this member.\nTo do so, we must list our requirement as a constraint on what T can be."
                },
                {
                    "type": "p",
                    "text": "To do so, we’ll create an interface that describes our constraint.\nHere, we’ll create an interface that has a single.lengthproperty and then we’ll use this interface and theextendskeyword to denote our constraint:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceLengthwise{length:number;}functionloggingIdentity<TextendsLengthwise>(arg:T):T{console.log(arg.length);// Now we know it has a .length property, so no more errorreturnarg;}Try"
                },
                {
                    "type": "p",
                    "text": "Because the generic function is now constrained, it will no longer work over any and all types:"
                },
                {
                    "type": "code",
                    "code": "tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try"
                },
                {
                    "type": "p",
                    "text": "Instead, we need to pass in values whose type has all the required properties:"
                },
                {
                    "type": "code",
                    "code": "tsloggingIdentity({length:10,value:3});Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using Type Parameters in Generic Constraints"
                },
                {
                    "type": "p",
                    "text": "You can declare a type parameter that is constrained by another type parameter.\nFor example, here we’d like to get a property from an object given its name.\nWe’d like to ensure that we’re not accidentally grabbing a property that does not exist on theobj, so we’ll place a constraint between the two types:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetProperty<T,KextendskeyofT>(obj:T,key:K) {returnobj[key];}letx= {a:1,b:2,c:3,d:4};getProperty(x,\"a\");getProperty(x,\"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using Class Types in Generics"
                },
                {
                    "type": "p",
                    "text": "When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreate<T>(c: {new():T}):T{returnnewc();}Try"
                },
                {
                    "type": "p",
                    "text": "A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types."
                },
                {
                    "type": "code",
                    "code": "tsclassBeeKeeper{hasMask:boolean;}classZooKeeper{nametag:string;}classAnimal{numLegs:number;}classBeeextendsAnimal{keeper:BeeKeeper;}classLionextendsAnimal{keeper:ZooKeeper;}functioncreateInstance<AextendsAnimal>(c:new()=>A):A{returnnewc();}createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/gulp.html",
            "title": "TypeScript: Documentation - Gulp",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Gulp"
                },
                {
                    "type": "p",
                    "text": "This quick start guide will teach you how to build TypeScript withgulpand then addBrowserify,terser, orWatchifyto the gulp pipeline.\nThis guide also shows how to addBabelfunctionality usingBabelify."
                },
                {
                    "type": "p",
                    "text": "We assume that you’re already usingNode.jswithnpm."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Minimal project"
                },
                {
                    "type": "p",
                    "text": "Let’s start out with a new directory.\nWe’ll name itprojfor now, but you can change it to whatever you want."
                },
                {
                    "type": "code",
                    "code": "shellmkdir projcdproj"
                },
                {
                    "type": "p",
                    "text": "To start, we’re going to structure our project in the following way:"
                },
                {
                    "type": "code",
                    "code": "proj/├─ src/└─ dist/"
                },
                {
                    "type": "p",
                    "text": "TypeScript files will start out in yoursrcfolder, run through the TypeScript compiler and end up indist."
                },
                {
                    "type": "p",
                    "text": "Let’s scaffold this out:"
                },
                {
                    "type": "code",
                    "code": "shellmkdir srcmkdir dist"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Initialize the project"
                },
                {
                    "type": "p",
                    "text": "Now we’ll turn this folder into an npm package."
                },
                {
                    "type": "code",
                    "code": "shellnpm init"
                },
                {
                    "type": "p",
                    "text": "You’ll be given a series of prompts.\nYou can use the defaults except for your entry point.\nFor your entry point, use./dist/main.js.\nYou can always go back and change these in thepackage.jsonfile that’s been generated for you."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install our dependencies"
                },
                {
                    "type": "p",
                    "text": "Now we can usenpm installto install packages.\nFirst installgulp-cliglobally (if you use a Unix system, you may need to prefix thenpm installcommands in this guide withsudo)."
                },
                {
                    "type": "code",
                    "code": "shellnpm install -g gulp-cli"
                },
                {
                    "type": "p",
                    "text": "Then installtypescript,gulpandgulp-typescriptin your project’s dev dependencies.Gulp-typescriptis a gulp plugin for TypeScript."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev typescript gulp@4.0.0 gulp-typescript"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Write a simple example"
                },
                {
                    "type": "p",
                    "text": "Let’s write a Hello World program.\nInsrc, create the filemain.ts:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionhello(compiler:string) {console.log(`Hello from${compiler}`);}hello(\"TypeScript\");"
                },
                {
                    "type": "p",
                    "text": "In the project root,proj, create the filetsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es5\"}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Create agulpfile.js"
                },
                {
                    "type": "p",
                    "text": "In the project root, create the filegulpfile.js:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varts=require(\"gulp-typescript\");vartsProject=ts.createProject(\"tsconfig.json\");gulp.task(\"default\",function() {returntsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Test the resulting app"
                },
                {
                    "type": "code",
                    "code": "shellgulpnode dist/main.js"
                },
                {
                    "type": "p",
                    "text": "The program should print “Hello from TypeScript!“."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Add modules to the code"
                },
                {
                    "type": "p",
                    "text": "Before we get to Browserify, let’s build our code out and add modules to the mix.\nThis is the structure you’re more likely to use for a real app."
                },
                {
                    "type": "p",
                    "text": "Create a file calledsrc/greet.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionsayHello(name:string) {return`Hello from${name}`;}"
                },
                {
                    "type": "p",
                    "text": "Now change the code insrc/main.tsto importsayHellofromgreet.ts:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"./greet\";console.log(sayHello(\"TypeScript\"));"
                },
                {
                    "type": "p",
                    "text": "Finally, addsrc/greet.tstotsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\",\"src/greet.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es5\"}}"
                },
                {
                    "type": "p",
                    "text": "Make sure that the modules work by runninggulpand then testing in Node:"
                },
                {
                    "type": "code",
                    "code": "shellgulpnode dist/main.js"
                },
                {
                    "type": "p",
                    "text": "Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses.\nWe’ll stick with CommonJS for this tutorial, but you could setmodulein the options object to change this."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Browserify"
                },
                {
                    "type": "p",
                    "text": "Now let’s move this project from Node to the browser.\nTo do this, we’d like to bundle all our modules into one JavaScript file.\nFortunately, that’s exactly what Browserify does.\nEven better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit.\nThat means our TypeScript and Node setup will transfer to the browser basically unchanged."
                },
                {
                    "type": "p",
                    "text": "First, install browserify,tsify, and vinyl-source-stream.\ntsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler.\nvinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands calledvinyl."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev browserify tsify vinyl-source-stream"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Create a page"
                },
                {
                    "type": "p",
                    "text": "Create a file insrcnamedindex.html:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><html><head><metacharset=\"UTF-8\"/><title>Hello World!</title></head><body><pid=\"greeting\">Loading ...</p><scriptsrc=\"bundle.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Now changemain.tsto update the page:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"./greet\";functionshowHello(divName:string,name:string) {constelt=document.getElementById(divName);elt.innerText=sayHello(name);}showHello(\"greeting\",\"TypeScript\");"
                },
                {
                    "type": "p",
                    "text": "CallingshowHellocallssayHelloto change the paragraph’s text.\nNow change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");vartsify=require(\"tsify\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).bundle().pipe(source(\"bundle.js\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "This adds thecopy-htmltask and adds it as a dependency ofdefault.\nThat means any timedefaultis run,copy-htmlhas to run first.\nWe’ve also changeddefaultto call Browserify with the tsify plugin instead of gulp-typescript.\nConveniently, they both allow us to pass the same options object to the TypeScript compiler."
                },
                {
                    "type": "p",
                    "text": "After callingbundlewe usesource(our alias for vinyl-source-stream) to name our output bundlebundle.js."
                },
                {
                    "type": "p",
                    "text": "Test the page by running gulp and then openingdist/index.htmlin a browser.\nYou should see “Hello from TypeScript” on the page."
                },
                {
                    "type": "p",
                    "text": "Notice that we specifieddebug: trueto Browserify.\nThis causes tsify to emit source maps inside the bundled JavaScript file.\nSource maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript.\nYou can test that source maps are working by opening the debugger for your browser and putting a breakpoint insidemain.ts.\nWhen you refresh the page the breakpoint should pause the page and let you debuggreet.ts."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Watchify, Babel, and Terser"
                },
                {
                    "type": "p",
                    "text": "Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins."
                },
                {
                    "type": "list",
                    "items": [
                        "Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file.\nThis lets you keep an edit-save-refresh cycle going in the browser.",
                        "Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3.\nThis lets you add extensive and customized transformations that TypeScript doesn’t support.",
                        "Terser compacts your code so that it takes less time to download."
                    ]
                },
                {
                    "type": "p",
                    "text": "Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file.\nThis lets you keep an edit-save-refresh cycle going in the browser."
                },
                {
                    "type": "p",
                    "text": "Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3.\nThis lets you add extensive and customized transformations that TypeScript doesn’t support."
                },
                {
                    "type": "p",
                    "text": "Terser compacts your code so that it takes less time to download."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Watchify"
                },
                {
                    "type": "p",
                    "text": "We’ll start with Watchify to provide background compilation:"
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev watchify fancy-log"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");varwatchify=require(\"watchify\");vartsify=require(\"tsify\");varfancy_log=require(\"fancy-log\");varpaths= {pages:[\"src/*.html\"],};varwatchedBrowserify=watchify(browserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify));gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});functionbundle() {returnwatchedBrowserify.bundle().on(\"error\",fancy_log).pipe(source(\"bundle.js\")).pipe(gulp.dest(\"dist\"));}gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),bundle));watchedBrowserify.on(\"update\",bundle);watchedBrowserify.on(\"log\",fancy_log);"
                },
                {
                    "type": "p",
                    "text": "There are basically three changes here, but they require you to refactor your code a bit."
                },
                {
                    "type": "list",
                    "items": [
                        "We wrapped ourbrowserifyinstance in a call towatchify, and then held on to the result.",
                        "We calledwatchedBrowserify.on('update', bundle);so that Browserify will run thebundlefunction every time one of your TypeScript files changes.",
                        "We calledwatchedBrowserify.on('log', fancy_log);to log to the console."
                    ]
                },
                {
                    "type": "p",
                    "text": "Together (1) and (2) mean that we have to move our call tobrowserifyout of thedefaulttask.\nAnd we have to give the function fordefaulta name since both Watchify and Gulp need to call it.\nAdding logging with (3) is optional but very useful for debugging your setup."
                },
                {
                    "type": "p",
                    "text": "Now when you run Gulp, it should start and stay running.\nTry changing the code forshowHelloinmain.tsand saving it.\nYou should see output that looks like this:"
                },
                {
                    "type": "code",
                    "code": "shellproj$ gulp[10:34:20] Using gulpfile ~/src/proj/gulpfile.js[10:34:20] Starting'copy-html'...[10:34:20] Finished'copy-html'after 26 ms[10:34:20] Starting'default'...[10:34:21] 2824 bytes written (0.13 seconds)[10:34:21] Finished'default'after 1.36 s[10:35:22] 2261 bytes written (0.02 seconds)[10:35:24] 2808 bytes written (0.05 seconds)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Terser"
                },
                {
                    "type": "p",
                    "text": "First install Terser.\nSince the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");varterser=require(\"gulp-terser\");vartsify=require(\"tsify\");varsourcemaps=require(\"gulp-sourcemaps\");varbuffer=require(\"vinyl-buffer\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).bundle().pipe(source(\"bundle.js\")).pipe(buffer()).pipe(sourcemaps.init({loadMaps:true})).pipe(terser()).pipe(sourcemaps.write(\"./\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "Notice thatterseritself has just one call — the calls tobufferandsourcemapsexist to make sure sourcemaps keep working.\nThese calls give us a separate sourcemap file instead of using inline sourcemaps like before.\nNow you can run Gulp and check thatbundle.jsdoes get minified into an unreadable mess:"
                },
                {
                    "type": "code",
                    "code": "shellgulpcat dist/bundle.js"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Babel"
                },
                {
                    "type": "p",
                    "text": "First install Babelify and the Babel preset for ES2015.\nLike Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps.\nBy default Babelify will only process files with extensions of.js,.es,.es6and.jsxso we need to add the.tsextension as an option to Babelify."
                },
                {
                    "type": "code",
                    "code": "shellnpm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps"
                },
                {
                    "type": "p",
                    "text": "Now change your gulpfile to the following:"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varbrowserify=require(\"browserify\");varsource=require(\"vinyl-source-stream\");vartsify=require(\"tsify\");varsourcemaps=require(\"gulp-sourcemaps\");varbuffer=require(\"vinyl-buffer\");varpaths= {pages:[\"src/*.html\"],};gulp.task(\"copy-html\",function() {returngulp.src(paths.pages).pipe(gulp.dest(\"dist\"));});gulp.task(\"default\",gulp.series(gulp.parallel(\"copy-html\"),function() {returnbrowserify({basedir:\".\",debug:true,entries:[\"src/main.ts\"],cache:{},packageCache:{},}).plugin(tsify).transform(\"babelify\", {presets:[\"es2015\"],extensions:[\".ts\"],}).bundle().pipe(source(\"bundle.js\")).pipe(buffer()).pipe(sourcemaps.init({loadMaps:true})).pipe(sourcemaps.write(\"./\")).pipe(gulp.dest(\"dist\"));}));"
                },
                {
                    "type": "p",
                    "text": "We also need to have TypeScript target ES2015.\nBabel will then produce ES5 from the ES2015 code that TypeScript emits.\nLet’s modifytsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"files\": [\"src/main.ts\"],\"compilerOptions\": {\"noImplicitAny\":true,\"target\":\"es2015\"}}"
                },
                {
                    "type": "p",
                    "text": "Babel’s ES5 output should be very similar to TypeScript’s output for such a simple script."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html",
            "title": "TypeScript: Documentation - Integrating with Build Tools",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Integrating with Build Tools"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Babel"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install @babel/cli @babel/core @babel/preset-typescript --save-dev"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": ".babelrc"
                },
                {
                    "type": "code",
                    "code": "js{\"presets\": [\"@babel/preset-typescript\"]}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using Command Line Interface"
                },
                {
                    "type": "code",
                    "code": "sh./node_modules/.bin/babel --out-file bundle.js src/index.ts"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "package.json"
                },
                {
                    "type": "code",
                    "code": "js{\"scripts\": {\"build\":\"babel --out-file bundle.js main.ts\"},}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Execute Babel from the command line"
                },
                {
                    "type": "code",
                    "code": "shnpm run build"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Browserify"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install tsify"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using Command Line Interface"
                },
                {
                    "type": "code",
                    "code": "shbrowserify main.ts -p [ tsify --noImplicitAny ] > bundle.js"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using API"
                },
                {
                    "type": "code",
                    "code": "jsvarbrowserify=require(\"browserify\");vartsify=require(\"tsify\");browserify().add(\"main.ts\").plugin(\"tsify\", {noImplicitAny:true}).bundle().pipe(process.stdout);"
                },
                {
                    "type": "p",
                    "text": "More details:smrq/tsify"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Grunt"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Usinggrunt-ts(no longer maintained)"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install grunt-ts --save-dev"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Basic Gruntfile.js"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=function(grunt) {grunt.initConfig({ts:{default:{src:[\"**/*.ts\",\"!node_modules/**/*.ts\"],},},});grunt.loadNpmTasks(\"grunt-ts\");grunt.registerTask(\"default\", [\"ts\"]);};"
                },
                {
                    "type": "p",
                    "text": "More details:TypeStrong/grunt-ts"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Usinggrunt-browserifycombined withtsify"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install grunt-browserify tsify --save-dev"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Basic Gruntfile.js"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports=function(grunt) {grunt.initConfig({browserify:{all:{src:\"src/main.ts\",dest:\"dist/main.js\",options:{plugin:[\"tsify\"],},},},});grunt.loadNpmTasks(\"grunt-browserify\");grunt.registerTask(\"default\", [\"browserify\"]);};"
                },
                {
                    "type": "p",
                    "text": "More details:jmreidy/grunt-browserify,TypeStrong/tsify"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Gulp"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install gulp-typescript"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Basic gulpfile.js"
                },
                {
                    "type": "code",
                    "code": "jsvargulp=require(\"gulp\");varts=require(\"gulp-typescript\");gulp.task(\"default\",function() {vartsResult=gulp.src(\"src/*.ts\").pipe(ts({noImplicitAny:true,out:\"output.js\",}));returntsResult.js.pipe(gulp.dest(\"built/local\"));});"
                },
                {
                    "type": "p",
                    "text": "More details:ivogabe/gulp-typescript"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Jspm"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install -g jspm@beta"
                },
                {
                    "type": "p",
                    "text": "Note: Currently TypeScript support in jspm is in 0.16beta"
                },
                {
                    "type": "p",
                    "text": "More details:TypeScriptSamples/jspm"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "MSBuild"
                },
                {
                    "type": "p",
                    "text": "Update project file to include locally installedMicrosoft.TypeScript.Default.props(at the top) andMicrosoft.TypeScript.targets(at the bottom) files:"
                },
                {
                    "type": "code",
                    "code": "xml<?xmlversion=\"1.0\"encoding=\"utf-8\"?><ProjectToolsVersion=\"4.0\"DefaultTargets=\"Build\"xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"><!-- Include default props at the top --><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\"/><!-- TypeScript configurations go here --><PropertyGroupCondition=\"'$(Configuration)' == 'Debug'\"><TypeScriptRemoveComments>false</TypeScriptRemoveComments><TypeScriptSourceMap>true</TypeScriptSourceMap></PropertyGroup><PropertyGroupCondition=\"'$(Configuration)' == 'Release'\"><TypeScriptRemoveComments>true</TypeScriptRemoveComments><TypeScriptSourceMap>false</TypeScriptSourceMap></PropertyGroup><!-- Include default targets at the bottom --><ImportProject=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"/></Project>"
                },
                {
                    "type": "p",
                    "text": "More details about defining MSBuild compiler options:Setting Compiler Options in MSBuild projects"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "NuGet"
                },
                {
                    "type": "list",
                    "items": [
                        "Right-Click -> Manage NuGet Packages",
                        "Search forMicrosoft.TypeScript.MSBuild",
                        "HitInstall",
                        "When install is complete, rebuild!"
                    ]
                },
                {
                    "type": "p",
                    "text": "More details can be found atPackage Manager Dialogandusing nightly builds with NuGet"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rollup"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "npm install @rollup/plugin-typescript --save-dev"
                },
                {
                    "type": "p",
                    "text": "Note that bothtypescriptandtslibare peer dependencies of this plugin that need to be installed separately."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "Create arollup.config.jsconfiguration fileand import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js// rollup.config.jsimporttypescriptfrom'@rollup/plugin-typescript';exportdefault{input:'src/index.ts',output:{dir:'output',format:'cjs'},plugins:[typescript()]};"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Svelte Compiler"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "npm install --save-dev svelte-preprocess"
                },
                {
                    "type": "p",
                    "text": "Note thattypescriptis an optional peer dependencies of this plugin and needs to be installed separately.tslibis not provided either."
                },
                {
                    "type": "p",
                    "text": "You may also considersvelte-checkfor CLI type checking."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "Create asvelte.config.jsconfiguration file and import the plugin:"
                },
                {
                    "type": "code",
                    "code": "js// svelte.config.jsimportpreprocessfrom'svelte-preprocess';constconfig= {// Consult https://github.com/sveltejs/svelte-preprocess// for more information about preprocessorspreprocess:preprocess()};exportdefaultconfig;"
                },
                {
                    "type": "p",
                    "text": "You can now specify that script blocks are written in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "<script lang=\"ts\">"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Vite"
                },
                {
                    "type": "p",
                    "text": "Vite supports importing.tsfiles out-of-the-box. It only performs transpilation and not type checking. It also requires that somecompilerOptionshave certain values. See theVite docsfor more details."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Webpack"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Install"
                },
                {
                    "type": "code",
                    "code": "shnpm install ts-loader --save-dev"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Basic webpack.config.js when using Webpack 5 or 4"
                },
                {
                    "type": "code",
                    "code": "jsconstpath=require('path');module.exports= {entry:'./src/index.ts',module:{rules:[{test:/\\.tsx?$/,use:'ts-loader',exclude:/node_modules/,},],},resolve:{extensions:['.tsx','.ts','.js'],},output:{filename:'bundle.js',path:path.resolve(__dirname,'dist'),},};"
                },
                {
                    "type": "p",
                    "text": "Seemore details on ts-loader here."
                },
                {
                    "type": "p",
                    "text": "Alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "awesome-typescript-loader"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/interfaces.html",
            "title": "TypeScript: Handbook - Interfaces",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "This page has been deprecated"
                },
                {
                    "type": "p",
                    "text": "This handbook page has been replaced,go to the new page"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Interfaces"
                },
                {
                    "type": "p",
                    "text": "One of TypeScript’s core principles is that type checking focuses on theshapethat values have.\nThis is sometimes called “duck typing” or “structural subtyping”.\nIn TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Our First Interface"
                },
                {
                    "type": "p",
                    "text": "The easiest way to see how interfaces work is to start with a simple example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionprintLabel(labeledObj: {label:string}) {console.log(labeledObj.label);}letmyObj= {size:10,label:\"Size 10 Object\"};printLabel(myObj);Try"
                },
                {
                    "type": "p",
                    "text": "The type checker checks the call toprintLabel.\nTheprintLabelfunction has a single parameter that requires that the object passed in has a property calledlabelof typestring.\nNotice that our object actually has more properties than this, but the compiler only checks thatat leastthe ones required are present and match the types required.\nThere are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit."
                },
                {
                    "type": "p",
                    "text": "We can write the same example again, this time using an interface to describe the requirement of having thelabelproperty that is a string:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceLabeledValue{label:string;}functionprintLabel(labeledObj:LabeledValue) {console.log(labeledObj.label);}letmyObj= {size:10,label:\"Size 10 Object\"};printLabel(myObj);Try"
                },
                {
                    "type": "p",
                    "text": "The interfaceLabeledValueis a name we can now use to describe the requirement in the previous example.\nIt still represents having a single property calledlabelthat is of typestring.\nNotice we didn’t have to explicitly say that the object we pass toprintLabelimplements this interface like we might have to in other languages.\nHere, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed."
                },
                {
                    "type": "p",
                    "text": "It’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Optional Properties"
                },
                {
                    "type": "p",
                    "text": "Not all properties of an interface may be required.\nSome exist under certain conditions or may not be there at all.\nThese optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in."
                },
                {
                    "type": "p",
                    "text": "Here’s an example of this pattern:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {letnewSquare= {color:\"white\",area:100};if(config.color) {newSquare.color=config.color;}if(config.width) {newSquare.area=config.width*config.width;}returnnewSquare;}letmySquare=createSquare({color:\"black\"});Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a?at the end of the property name in the declaration."
                },
                {
                    "type": "p",
                    "text": "The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface.\nFor example, had we mistyped the name of thecolorproperty increateSquare, we would get an error message letting us know:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {letnewSquare= {color:\"white\",area:100};if(config.clor) {Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?// Error: Property 'clor' does not exist on type 'SquareConfig'newSquare.color=config.clor;Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?2551Property 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?}if(config.width) {newSquare.area=config.width*config.width;}returnnewSquare;}letmySquare=createSquare({color:\"black\"});Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Readonly properties"
                },
                {
                    "type": "p",
                    "text": "Some properties should only be modifiable when an object is first created.\nYou can specify this by puttingreadonlybefore the name of the property:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePoint{readonlyx:number;readonlyy:number;}Try"
                },
                {
                    "type": "p",
                    "text": "You can construct aPointby assigning an object literal.\nAfter the assignment,xandycan’t be changed."
                },
                {
                    "type": "code",
                    "code": "tsletp1:Point= {x:10,y:20};p1.x=5;// error!Cannot assign to 'x' because it is a read-only property.2540Cannot assign to 'x' because it is a read-only property.Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript comes with aReadonlyArray<T>type that is the same asArray<T>with all mutating methods removed, so you can make sure you don’t change your arrays after creation:"
                },
                {
                    "type": "code",
                    "code": "tsleta:number[] = [1,2,3,4];letro:ReadonlyArray<number> =a;ro[0] =12;// error!Index signature in type 'readonly number[]' only permits reading.2542Index signature in type 'readonly number[]' only permits reading.ro.push(5);// error!Property 'push' does not exist on type 'readonly number[]'.2339Property 'push' does not exist on type 'readonly number[]'.ro.length=100;// error!Cannot assign to 'length' because it is a read-only property.2540Cannot assign to 'length' because it is a read-only property.a=ro;// error!The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.4104The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.Try"
                },
                {
                    "type": "p",
                    "text": "On the last line of the snippet you can see that even assigning the entireReadonlyArrayback to a normal array is illegal.\nYou can still override it with a type assertion, though:"
                },
                {
                    "type": "code",
                    "code": "tsleta:number[] = [1,2,3,4];letro:ReadonlyArray<number> =a;a=roasnumber[];Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "readonlyvsconst"
                },
                {
                    "type": "p",
                    "text": "The easiest way to remember whether to usereadonlyorconstis to ask whether you’re using it on a variable or a property.\nVariables useconstwhereas properties usereadonly."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Excess Property Checks"
                },
                {
                    "type": "p",
                    "text": "In our first example using interfaces, TypeScript lets us pass{ size: number; label: string; }to something that only expected a{ label: string; }.\nWe also just learned about optional properties, and how they’re useful when describing so-called “option bags”."
                },
                {
                    "type": "p",
                    "text": "However, combining the two naively would allow an error to sneak in. For example, taking our last example usingcreateSquare:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;}functioncreateSquare(config:SquareConfig): {color:string;area:number} {return{color:config.color||\"red\",area:config.width?config.width*config.width:20,};}letmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Notice the given argument tocreateSquareis spelledcolourinstead ofcolor.\nIn plain JavaScript, this sort of thing fails silently."
                },
                {
                    "type": "p",
                    "text": "You could argue that this program is correctly typed, since thewidthproperties are compatible, there’s nocolorproperty present, and the extracolourproperty is insignificant."
                },
                {
                    "type": "p",
                    "text": "However, TypeScript takes the stance that there’s probably a bug in this code.\nObject literals get special treatment and undergoexcess property checkingwhen assigning them to other variables, or passing them as arguments.\nIf an object literal has any properties that the “target type” doesn’t have, you’ll get an error:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({colour:\"red\",width:100});Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
                },
                {
                    "type": "p",
                    "text": "Getting around these checks is actually really simple.\nThe easiest method is to just use a type assertion:"
                },
                {
                    "type": "code",
                    "code": "tsletmySquare=createSquare({width:100,opacity:0.5}asSquareConfig);Try"
                },
                {
                    "type": "p",
                    "text": "However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way.\nIfSquareConfigcan havecolorandwidthproperties with the above types, but couldalsohave any number of other properties, then we could define it like so:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSquareConfig{color?:string;width?:number;[propName:string]:any;}Try"
                },
                {
                    "type": "p",
                    "text": "We’ll discuss index signatures in a bit, but here we’re saying aSquareConfigcan have any number of properties, and as long as they aren’tcolororwidth, their types don’t matter."
                },
                {
                    "type": "p",
                    "text": "One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable:\nSincesquareOptionswon’t undergo excess property checks, the compiler won’t give you an error."
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\",width:100};letmySquare=createSquare(squareOptions);Try"
                },
                {
                    "type": "p",
                    "text": "The above workaround will work as long as you have a common property betweensquareOptionsandSquareConfig.\nIn this example, it was the propertywidth. It will however, fail if the variable does not have any common object property. For example:"
                },
                {
                    "type": "code",
                    "code": "tsletsquareOptions= {colour:\"red\"};letmySquare=createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks.\nFor more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations.\nIn this instance, if it’s okay to pass an object with both acolororcolourproperty tocreateSquare, you should fix up the definition ofSquareConfigto reflect that."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function Types"
                },
                {
                    "type": "p",
                    "text": "Interfaces are capable of describing the wide range of shapes that JavaScript objects can take.\nIn addition to describing an object with properties, interfaces are also capable of describing function types."
                },
                {
                    "type": "p",
                    "text": "To describe a function type with an interface, we give the interface a call signature.\nThis is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceSearchFunc{(source:string,subString:string):boolean;}Try"
                },
                {
                    "type": "p",
                    "text": "Once defined, we can use this function type interface like we would other interfaces.\nHere, we show how you can create a variable of a function type and assign it a function value of the same type."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(source:string,subString:string):boolean{letresult=source.search(subString);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "For function types to correctly type check, the names of the parameters do not need to match.\nWe could have, for example, written the above example like this:"
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src:string,sub:string):boolean{letresult=src.search(sub);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other.\nIf you do not want to specify types at all, TypeScript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of typeSearchFunc.\nHere, also, the return type of our function expression is implied by the values it returns (herefalseandtrue)."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src,sub) {letresult=src.search(sub);returnresult> -1;};Try"
                },
                {
                    "type": "p",
                    "text": "Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn’t match the return type described in theSearchFuncinterface."
                },
                {
                    "type": "code",
                    "code": "tsletmySearch:SearchFunc;mySearch=function(src,sub) {Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.2322Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.letresult=src.search(sub);return\"string\";};Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Indexable Types"
                },
                {
                    "type": "p",
                    "text": "Similarly to how we can use interfaces to describe function types, we can also describe types that we can “index into” likea[10], orageMap[\"daniel\"].\nIndexable types have anindex signaturethat describes the types we can use to index into the object, along with the corresponding return types when indexing."
                },
                {
                    "type": "p",
                    "text": "Let’s take an example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringArray{[index:number]:string;}letmyArray:StringArray;myArray= [\"Bob\",\"Fred\"];letmyStr:string=myArray[0];Try"
                },
                {
                    "type": "p",
                    "text": "Above, we have aStringArrayinterface that has an index signature.\nThis index signature states that when aStringArrayis indexed with anumber, it will return astring."
                },
                {
                    "type": "p",
                    "text": "There are four types of supported index signatures: string, number, symbol and template strings.\nIt is possible to support many types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer."
                },
                {
                    "type": "p",
                    "text": "This is because when indexing with anumber, JavaScript will actually convert that to astringbefore indexing into an object.\nThat means that indexing with100(anumber) is the same thing as indexing with\"100\"(astring), so the two need to be consistent."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAnimal{name:string;}interfaceDogextendsAnimal{breed:string;}// Error: indexing with a numeric string might get you a completely separate type of Animal!interfaceNotOkay{[x:number]:Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.[x:string]:Dog;}Try"
                },
                {
                    "type": "p",
                    "text": "While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type.\nThis is because a string index declares thatobj.propertyis also available asobj[\"property\"].\nIn the following example,name’s type does not match the string index’s type, and the type checker gives an error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberDictionary{[index:string]:number;length:number;// ok, length is a numbername:string;// error, the type of 'name' is not a subtype of the indexerProperty 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try"
                },
                {
                    "type": "p",
                    "text": "However, properties of different types are acceptable if the index signature is a union of the property types:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNumberOrStringDictionary{[index:string]:number|string;length:number;// ok, length is a numbername:string;// ok, name is a string}Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can make index signaturesreadonlyin order to prevent assignment to their indices:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceReadonlyStringArray{readonly[index:number]:string;}letmyArray:ReadonlyStringArray= [\"Alice\",\"Bob\"];myArray[2] =\"Mallory\";// error!Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try"
                },
                {
                    "type": "p",
                    "text": "You can’t setmyArray[2]because the index signature isreadonly."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Indexable Types with Template Strings"
                },
                {
                    "type": "p",
                    "text": "A template string can be used to indicate that a particular pattern is allowed, but not all. For example, a HTTP headers object may have a set list of known headers and support anycustom defined propertieswhich are prefixed withx-."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceHeadersResponse{\"content-type\":string,date:string,\"content-length\":string// Permit any property starting with 'x-'.[headerName:`x-${string}`]:string;}functionhandleResponse(r:HeadersResponse) {// Handle known, and x- prefixedconsttype=r[\"content-type\"]constpoweredBy=r[\"x-powered-by\"]// Unknown keys without the prefix raise errorsconstorigin=r.originProperty 'origin' does not exist on type 'HeadersResponse'.2339Property 'origin' does not exist on type 'HeadersResponse'.}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Class Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Implementing an interface"
                },
                {
                    "type": "p",
                    "text": "One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockInterface{currentTime:Date;}classClockimplementsClockInterface{currentTime:Date=newDate();constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "You can also describe methods in an interface that are implemented in the class, as we do withsetTimein the below example:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockInterface{currentTime:Date;setTime(d:Date):void;}classClockimplementsClockInterface{currentTime:Date=newDate();setTime(d:Date) {this.currentTime=d;}constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "Interfaces describe the public side of the class, rather than both the public and private side.\nThis prohibits you from using them to check that a class also has particular types for the private side of the class instance."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Difference between the static and instance sides of classes"
                },
                {
                    "type": "p",
                    "text": "When working with classes and interfaces, it helps to keep in mind that a class hastwotypes: the type of the static side and the type of the instance side.\nYou may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number);}classClockimplementsClockConstructor{Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.2420Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.currentTime:Date;constructor(h:number,m:number) {}}Try"
                },
                {
                    "type": "p",
                    "text": "This is because when a class implements an interface, only the instance side of the class is checked.\nSince the constructor sits in the static side, it is not included in this check."
                },
                {
                    "type": "p",
                    "text": "Instead, you would need to work with the static side of the class directly.\nIn this example, we define two interfaces,ClockConstructorfor the constructor andClockInterfacefor the instance methods.\nThen, for convenience, we define a constructor functioncreateClockthat creates instances of the type that is passed to it:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number):ClockInterface;}interfaceClockInterface{tick():void;}functioncreateClock(ctor:ClockConstructor,hour:number,minute:number):ClockInterface{returnnewctor(hour,minute);}classDigitalClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"beep beep\");}}classAnalogClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"tick tock\");}}letdigital=createClock(DigitalClock,12,17);letanalog=createClock(AnalogClock,7,32);Try"
                },
                {
                    "type": "p",
                    "text": "BecausecreateClock’s first parameter is of typeClockConstructor, increateClock(AnalogClock, 7, 32), it checks thatAnalogClockhas the correct constructor signature."
                },
                {
                    "type": "p",
                    "text": "Another simple way is to use class expressions:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClockConstructor{new(hour:number,minute:number):ClockInterface;}interfaceClockInterface{tick():void;}constClock:ClockConstructor=classClockimplementsClockInterface{constructor(h:number,m:number) {}tick() {console.log(\"beep beep\");}};letclock=newClock(12,17);clock.tick();Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Extending Interfaces"
                },
                {
                    "type": "p",
                    "text": "Like classes, interfaces can extend each other.\nThis allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceShape{color:string;}interfaceSquareextendsShape{sideLength:number;}letsquare= {}asSquare;square.color=\"blue\";square.sideLength=10;Try"
                },
                {
                    "type": "p",
                    "text": "An interface can extend multiple interfaces, creating a combination of all of the interfaces."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceShape{color:string;}interfacePenStroke{penWidth:number;}interfaceSquareextendsShape,PenStroke{sideLength:number;}letsquare= {}asSquare;square.color=\"blue\";square.sideLength=10;square.penWidth=5.0;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Hybrid Types"
                },
                {
                    "type": "p",
                    "text": "As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript.\nBecause of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above."
                },
                {
                    "type": "p",
                    "text": "One such example is an object that acts as both a function and an object, with additional properties:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceCounter{(start:number):string;interval:number;reset():void;}functiongetCounter():Counter{letcounter=function(start:number) {}asCounter;counter.interval=123;counter.reset=function() {};returncounter;}letc=getCounter();c(10);c.reset();c.interval=5.0;Try"
                },
                {
                    "type": "p",
                    "text": "When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interfaces Extending Classes"
                },
                {
                    "type": "p",
                    "text": "When an interface type extends a class type it inherits the members of the class but not their implementations.\nIt is as if the interface had declared all of the members of the class without providing an implementation.\nInterfaces inherit even the private and protected members of a base class.\nThis means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it."
                },
                {
                    "type": "p",
                    "text": "This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties.\nThe subclasses don’t have to be related besides inheriting from the base class.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsclassControl{privatestate:any;}interfaceSelectableControlextendsControl{select():void;}classButtonextendsControlimplementsSelectableControl{select() {}}classTextBoxextendsControl{select() {}}classImageControlimplementsSelectableControl{Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.2420Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.privatestate:any;select() {}}Try"
                },
                {
                    "type": "p",
                    "text": "In the above example,SelectableControlcontains all of the members ofControl, including the privatestateproperty.\nSincestateis a private member it is only possible for descendants ofControlto implementSelectableControl.\nThis is because only descendants ofControlwill have astateprivate member that originates in the same declaration, which is a requirement for private members to be compatible."
                },
                {
                    "type": "p",
                    "text": "Within theControlclass it is possible to access thestateprivate member through an instance ofSelectableControl.\nEffectively, aSelectableControlacts like aControlthat is known to have aselectmethod.\nTheButtonandTextBoxclasses are subtypes ofSelectableControl(because they both inherit fromControland have aselectmethod). TheImageControlclass has its ownstateprivate member rather than extendingControl, so it cannot implementSelectableControl."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html",
            "title": "TypeScript: Documentation - JS Projects Utilizing TypeScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "JS Projects Utilizing TypeScript"
                },
                {
                    "type": "p",
                    "text": "The type system in TypeScript has different levels of strictness when working with a codebase:"
                },
                {
                    "type": "list",
                    "items": [
                        "A type-system based only on inference with JavaScript code",
                        "Incremental typing in JavaScriptvia JSDoc",
                        "Using// @ts-checkin a JavaScript file",
                        "TypeScript code",
                        "TypeScript withstrictenabled"
                    ]
                },
                {
                    "type": "p",
                    "text": "Each step represents a move towards a safer type-system, but not every project needs that level of verification."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript with JavaScript"
                },
                {
                    "type": "p",
                    "text": "This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename.\nThehomepagehas a list of editors which have TypeScript plugins."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Providing Type Hints in JS via JSDoc"
                },
                {
                    "type": "p",
                    "text": "In a.jsfile, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax."
                },
                {
                    "type": "p",
                    "text": "JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{number}*/varx;x=0;// OKx=false;// OK?!Try"
                },
                {
                    "type": "p",
                    "text": "You can find the full list of supported JSDoc patternsin JSDoc Supported Types."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "@ts-check"
                },
                {
                    "type": "p",
                    "text": "The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project.\nTo enable errors in your JavaScript files add:// @ts-checkto the first line in your.jsfiles to have TypeScript raise it as an error."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@type{number}*/varx;x=0;// OKx=false;// Not OKType 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.Try"
                },
                {
                    "type": "p",
                    "text": "If you have a lot of JavaScript files you want to add errors to then you can switch to using ajsconfig.json.\nYou can skip checking some files by adding a// @ts-nocheckcomment to files."
                },
                {
                    "type": "p",
                    "text": "TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding// @ts-ignoreor// @ts-expect-erroron the preceding line."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@type{number}*/varx;x=0;// OK// @ts-expect-errorx=false;// Not OKTry"
                },
                {
                    "type": "p",
                    "text": "To learn more about how JavaScript is interpreted by TypeScript readHow TS Type Checks JS"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type Checking JavaScript Files"
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/intro.html",
            "title": "TypeScript: Handbook - The TypeScript Handbook",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "The TypeScript Handbook"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "About this Handbook"
                },
                {
                    "type": "p",
                    "text": "Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale."
                },
                {
                    "type": "p",
                    "text": "The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked)."
                },
                {
                    "type": "p",
                    "text": "If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either theMicrosoft Learn JavaScript tutorialor readJavaScript at the Mozilla Web Docs.\nIf you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How is this Handbook Structured"
                },
                {
                    "type": "p",
                    "text": "The handbook is split into two sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "The HandbookThe TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.A reader who completes the walkthrough should be able to:Read and understand commonly-used TypeScript syntax and patternsExplain the effects of important compiler optionsCorrectly predict type system behavior in most casesIn the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.",
                        "Read and understand commonly-used TypeScript syntax and patterns",
                        "Explain the effects of important compiler options",
                        "Correctly predict type system behavior in most cases",
                        "Reference FilesThe reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity."
                    ]
                },
                {
                    "type": "p",
                    "text": "The Handbook"
                },
                {
                    "type": "p",
                    "text": "The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation."
                },
                {
                    "type": "p",
                    "text": "You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors."
                },
                {
                    "type": "p",
                    "text": "A reader who completes the walkthrough should be able to:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read and understand commonly-used TypeScript syntax and patterns",
                        "Explain the effects of important compiler options",
                        "Correctly predict type system behavior in most cases"
                    ]
                },
                {
                    "type": "p",
                    "text": "In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles."
                },
                {
                    "type": "p",
                    "text": "Reference Files"
                },
                {
                    "type": "p",
                    "text": "The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Non-Goals"
                },
                {
                    "type": "p",
                    "text": "The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short."
                },
                {
                    "type": "p",
                    "text": "Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts."
                },
                {
                    "type": "p",
                    "text": "The Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet."
                },
                {
                    "type": "p",
                    "text": "Finally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Get Started"
                },
                {
                    "type": "p",
                    "text": "Before getting started withThe Basics, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages."
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript for the New Programmer",
                        "TypeScript for JavaScript Programmers",
                        "TypeScript for Java/C# Programmers",
                        "TypeScript for Functional Programmers"
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise, jump toThe Basics."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The Basics"
                },
                {
                    "type": "p",
                    "text": "Step one in learning TypeScript: The basic types."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html",
            "title": "TypeScript: Documentation - Iterators and Generators",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Iterators and Generators"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Iterables"
                },
                {
                    "type": "p",
                    "text": "An object is deemed iterable if it has an implementation for theSymbol.iteratorproperty.\nSome built-in types likeArray,Map,Set,String,Int32Array,Uint32Array, etc. have theirSymbol.iteratorproperty already implemented.Symbol.iteratorfunction on an object is responsible for returning the list of values to iterate on."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Iterableinterface"
                },
                {
                    "type": "p",
                    "text": "Iterableis a type we can use if we want to take in types listed above which are iterable. Here is an example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoArray<X>(xs:Iterable<X>):X[] {return[...xs]}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "for..ofstatements"
                },
                {
                    "type": "p",
                    "text": "for..ofloops over an iterable object, invoking theSymbol.iteratorproperty on the object.\nHere is a simplefor..ofloop on an array:"
                },
                {
                    "type": "code",
                    "code": "tsletsomeArray= [1,\"string\",false];for(letentryofsomeArray) {console.log(entry);// 1, \"string\", false}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "for..ofvs.for..instatements"
                },
                {
                    "type": "p",
                    "text": "Bothfor..ofandfor..instatements iterate over lists; the values iterated on are different though,for..inreturns a list ofkeyson the object being iterated, whereasfor..ofreturns a list ofvaluesof the numeric properties of the object being iterated."
                },
                {
                    "type": "p",
                    "text": "Here is an example that demonstrates this distinction:"
                },
                {
                    "type": "code",
                    "code": "tsletlist= [4,5,6];for(letiinlist) {console.log(i);// \"0\", \"1\", \"2\",}for(letioflist) {console.log(i);// 4, 5, 6}"
                },
                {
                    "type": "p",
                    "text": "Another distinction is thatfor..inoperates on any object; it serves as a way to inspect properties on this object.for..ofon the other hand, is mainly interested in values of iterable objects. Built-in objects likeMapandSetimplementSymbol.iteratorproperty allowing access to stored values."
                },
                {
                    "type": "code",
                    "code": "tsletpets=newSet([\"Cat\",\"Dog\",\"Hamster\"]);pets[\"species\"] =\"mammals\";for(letpetinpets) {console.log(pet);// \"species\"}for(letpetofpets) {console.log(pet);// \"Cat\", \"Dog\", \"Hamster\"}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Code generation"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Targeting ES5"
                },
                {
                    "type": "p",
                    "text": "When targeting an ES5-compliant engine, iterators are only allowed on values ofArraytype.\nIt is an error to usefor..ofloops on non-Array values, even if these non-Array values implement theSymbol.iteratorproperty."
                },
                {
                    "type": "p",
                    "text": "The compiler will generate a simpleforloop for afor..ofloop, for instance:"
                },
                {
                    "type": "code",
                    "code": "tsletnumbers= [1,2,3];for(letnumofnumbers) {console.log(num);}"
                },
                {
                    "type": "p",
                    "text": "will be generated as:"
                },
                {
                    "type": "code",
                    "code": "jsvarnumbers= [1,2,3];for(var_i=0;_i<numbers.length;_i++) {varnum=numbers[_i];console.log(num);}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Targeting ECMAScript 2015 and higher"
                },
                {
                    "type": "p",
                    "text": "When targeting an ECMAScript 2015-compliant engine, the compiler will generatefor..ofloops to target the built-in iterator implementation in the engine."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
            "title": "TypeScript: Documentation - JSDoc Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "JSDoc Reference"
                },
                {
                    "type": "p",
                    "text": "The list below outlines which constructs are currently supported\nwhen using JSDoc annotations to provide type information in JavaScript files."
                },
                {
                    "type": "p",
                    "text": "Note:"
                },
                {
                    "type": "list",
                    "items": [
                        "Any tags which are not explicitly listed below (such as@async) are not yet supported.",
                        "Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Types"
                },
                {
                    "type": "list",
                    "items": [
                        "@type",
                        "@param(or@argor@argument)",
                        "@returns(or@return)",
                        "@typedef",
                        "@callback",
                        "@template",
                        "@satisfies"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Classes"
                },
                {
                    "type": "list",
                    "items": [
                        "Property Modifiers@public,@private,@protected,@readonly",
                        "@override",
                        "@extends(or@augments)",
                        "@implements",
                        "@class(or@constructor)",
                        "@this"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Documentation"
                },
                {
                    "type": "p",
                    "text": "Documentation tags work in both TypeScript and JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "@deprecated",
                        "@see",
                        "@link"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Other"
                },
                {
                    "type": "list",
                    "items": [
                        "@enum",
                        "@author",
                        "Other supported patterns",
                        "Unsupported patterns",
                        "Unsupported tags"
                    ]
                },
                {
                    "type": "p",
                    "text": "The meaning is usually the same, or a superset, of the meaning of the tag given atjsdoc.app.\nThe code below describes the differences and gives some example usage of each tag."
                },
                {
                    "type": "p",
                    "text": "Note:You can usethe playground to explore JSDoc support."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@type"
                },
                {
                    "type": "p",
                    "text": "You can reference types with the “@type” tag. The type can be:"
                },
                {
                    "type": "list",
                    "items": [
                        "Primitive, likestringornumber.",
                        "Declared in a TypeScript declaration, either global or imported.",
                        "Declared in a JSDoc@typedeftag."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use most JSDoc type syntax and any TypeScript syntax, fromthe most basic likestringtothe most advanced, like conditional types."
                },
                {
                    "type": "code",
                    "code": "js/***@type{string}*/vars;/**@type{Window}*/varwin;/**@type{PromiseLike<string>}*/varpromisedString;// You can specify an HTML Element with DOM properties/**@type{HTMLElement}*/varmyElement=document.querySelector(selector);element.dataset.myData=\"\";Try"
                },
                {
                    "type": "p",
                    "text": "@typecan specify a union type — for example, something can be either a string or a boolean."
                },
                {
                    "type": "code",
                    "code": "js/***@type{string | boolean}*/varsb;Try"
                },
                {
                    "type": "p",
                    "text": "You can specify array types using a variety of syntaxes:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{number[]}*/varns;/**@type{Array.<number>}*/varjsdoc;/**@type{Array<number>}*/varnas;Try"
                },
                {
                    "type": "p",
                    "text": "You can also specify object literal types.\nFor example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{{ a: string, b: number }}*/varvar9;Try"
                },
                {
                    "type": "p",
                    "text": "You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax."
                },
                {
                    "type": "code",
                    "code": "js/*** A map-like object that maps arbitrary `string` properties to `number`s.**@type{Object.<string, number>}*/varstringToNumber;/**@type{Object.<number, object>}*/vararrayLike;Try"
                },
                {
                    "type": "p",
                    "text": "The preceding two types are equivalent to the TypeScript types{ [x: string]: number }and{ [x: number]: any }. The compiler understands both syntaxes."
                },
                {
                    "type": "p",
                    "text": "You can specify function types using either TypeScript or Google Closure syntax:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{function(string, boolean): number}Closure syntax */varsbn;/**@type{(s: string, b: boolean) => number}TypeScript syntax */varsbn2;Try"
                },
                {
                    "type": "p",
                    "text": "Or you can just use the unspecifiedFunctiontype:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{Function}*/varfn7;/**@type{function}*/varfn6;Try"
                },
                {
                    "type": "p",
                    "text": "Other types from Closure also work:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{*}- can be 'any' type*/varstar;/***@type{?}- unknown type (same as 'any')*/varquestion;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Casts"
                },
                {
                    "type": "p",
                    "text": "TypeScript borrows cast syntax from Google Closure.\nThis lets you cast types to other types by adding a@typetag before any parenthesized expression."
                },
                {
                    "type": "code",
                    "code": "js/***@type{number | string}*/varnumberOrString=Math.random() <0.5?\"hello\":100;vartypeAssertedNumber=/**@type{number}*/(numberOrString);Try"
                },
                {
                    "type": "p",
                    "text": "You can even cast toconstjust like TypeScript:"
                },
                {
                    "type": "code",
                    "code": "jsletone=/**@type{const}*/(1);Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Import types"
                },
                {
                    "type": "p",
                    "text": "You can import declarations from other files using import types.\nThis syntax is TypeScript-specific and differs from the JSDoc standard:"
                },
                {
                    "type": "code",
                    "code": "js// @filename: types.d.tsexporttypePet= {name:string,};// @filename: main.js/***@param{import(\"./types\").Pet}p*/functionwalk(p) {console.log(`Walking${p.name}...`);}Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used in type alias declarations:"
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{import(\"./types\").Pet}Pet*//***@type{Pet}*/varmyPet;myPet.name;Try"
                },
                {
                    "type": "p",
                    "text": "import types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{typeof import(\"./accounts\").userAccount}*/varx=require(\"./accounts\").userAccount;Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@paramand@returns"
                },
                {
                    "type": "p",
                    "text": "@paramuses the same type syntax as@type, but adds a parameter name.\nThe parameter may also be declared optional by surrounding the name with square brackets:"
                },
                {
                    "type": "code",
                    "code": "js// Parameters may be declared in a variety of syntactic forms/***@param{string}p1- A string param.*@param{string=}p2- An optional param (Google Closure syntax)*@param{string}[p3]- Another optional param (JSDoc syntax).*@param{string}[p4=\"test\"]- An optional param with a default value*@returns{string}This is the result*/functionstringsStringStrings(p1,p2,p3,p4) {// TODO}Try"
                },
                {
                    "type": "p",
                    "text": "Likewise, for the return type of a function:"
                },
                {
                    "type": "code",
                    "code": "js/***@return{PromiseLike<string>}*/functionps() {}/***@returns{{ a: string, b: number }}- May use '@returns' as well as '@return'*/functionab() {}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@typedef,@callback, and@param"
                },
                {
                    "type": "p",
                    "text": "You can define complex types with@typedef.\nSimilar syntax works with@param."
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{Object}SpecialType- creates a new type named 'SpecialType'*@property{string}prop1- a string property of SpecialType*@property{number}prop2- a number property of SpecialType*@property{number=}prop3- an optional number property of SpecialType*@prop{number}[prop4]- an optional number property of SpecialType*@prop{number}[prop5=42]- an optional number property of SpecialType with default*//**@type{SpecialType}*/varspecialTypeObject;specialTypeObject.prop3;Try"
                },
                {
                    "type": "p",
                    "text": "You can use eitherobjectorObjecton the first line."
                },
                {
                    "type": "code",
                    "code": "js/***@typedef{object}SpecialType1- creates a new type named 'SpecialType1'*@property{string}prop1- a string property of SpecialType1*@property{number}prop2- a number property of SpecialType1*@property{number=}prop3- an optional number property of SpecialType1*//**@type{SpecialType1}*/varspecialTypeObject1;Try"
                },
                {
                    "type": "p",
                    "text": "@paramallows a similar syntax for one-off type specifications.\nNote that the nested property names must be prefixed with the name of the parameter:"
                },
                {
                    "type": "code",
                    "code": "js/***@param{Object}options- The shape is the same as SpecialType above*@param{string}options.prop1*@param{number}options.prop2*@param{number=}options.prop3*@param{number}[options.prop4]*@param{number}[options.prop5=42]*/functionspecial(options) {return(options.prop4||1001) +options.prop5;}Try"
                },
                {
                    "type": "p",
                    "text": "@callbackis similar to@typedef, but it specifies a function type instead of an object type:"
                },
                {
                    "type": "code",
                    "code": "js/***@callbackPredicate*@param{string}data*@param{number}[index]*@returns{boolean}*//**@type{Predicate}*/constok= (s)=>!(s.length%2);Try"
                },
                {
                    "type": "p",
                    "text": "Of course, any of these types can be declared using TypeScript syntax in a single-line@typedef:"
                },
                {
                    "type": "code",
                    "code": "js/**@typedef{{ prop1: string, prop2: string, prop3?: number }}SpecialType*//**@typedef{(data: string, index?: number) => boolean}Predicate*/"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@template"
                },
                {
                    "type": "p",
                    "text": "You can declare type parameters with the@templatetag.\nThis lets you make functions, classes, or types that are generic:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT*@param{T}x- A generic parameter that flows through to the return type*@returns{T}*/functionid(x) {returnx;}consta=id(\"string\");constb=id(123);constc=id({});Try"
                },
                {
                    "type": "p",
                    "text": "Use comma or multiple tags to declare multiple type parameters:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT,U,V*@templateW,X*/"
                },
                {
                    "type": "p",
                    "text": "You can also specify a type constraint before the type parameter name.\nOnly the first type parameter in a list is constrained:"
                },
                {
                    "type": "code",
                    "code": "js/***@template{string}K- K must be a string or string literal*@template{{ serious(): string }}Seriousalizable- must have a serious method*@param{K}key*@param{Seriousalizable}object*/functionseriousalize(key,object) {// ????}Try"
                },
                {
                    "type": "p",
                    "text": "Finally, you can specify a default for a type parameter:"
                },
                {
                    "type": "code",
                    "code": "js/**@template[T=object] */classCache{/**@param{T}initial*/constructor(initial) {}}letc=newCache()Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@satisfies"
                },
                {
                    "type": "p",
                    "text": "@satisfiesprovides access to the postfixoperatorsatisfiesin TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value."
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/***@typedef{\"hello world\" | \"Hello, world\"}WelcomeMessage*//**@satisfies{WelcomeMessage} */constmessage=\"hello world\"const message: \"hello world\"/**@satisfies{WelcomeMessage} */Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.1360Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.constfailingMessage=\"Hello world!\"/**@type{WelcomeMessage}*/constmessageUsingType=\"hello world\"const messageUsingType: WelcomeMessageTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Classes can be declared as ES6 classes."
                },
                {
                    "type": "code",
                    "code": "jsclassC{/***@param{number}data*/constructor(data) {// property types can be inferredthis.name=\"foo\";// or set explicitly/**@type{string | null}*/this.title=null;// or simply annotated, if they're set elsewhere/**@type{number}*/this.size;this.initialize(data);// Should error, initializer expects a string}/***@param{string}s*/initialize=function(s) {this.size=s.length;};}varc=newC(0);// C should only be called with new, but// because it is JavaScript, this is allowed and// considered an 'any'.varresult=C(1);Try"
                },
                {
                    "type": "p",
                    "text": "They can also be declared as constructor functions; use@constructoralong with@thisfor this."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Property Modifiers"
                },
                {
                    "type": "p",
                    "text": "@public,@private, and@protectedwork exactly likepublic,private, andprotectedin TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkclassCar{constructor() {/**@private*/this.identifier=100;}printIdentifier() {console.log(this.identifier);}}constc=newCar();console.log(c.identifier);Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.Try"
                },
                {
                    "type": "list",
                    "items": [
                        "@publicis always implied and can be left off, but means that a property can be reached from anywhere.",
                        "@privatemeans that a property can only be used within the containing class.",
                        "@protectedmeans that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class."
                    ]
                },
                {
                    "type": "p",
                    "text": "@public,@private, and@protecteddo not work in constructor functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@readonly"
                },
                {
                    "type": "p",
                    "text": "The@readonlymodifier ensures that a property is only ever written to during initialization."
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkclassCar{constructor() {/**@readonly*/this.identifier=100;}printIdentifier() {console.log(this.identifier);}}constc=newCar();console.log(c.identifier);Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@override"
                },
                {
                    "type": "p",
                    "text": "@overrideworks the same way as in TypeScript; use it on methods that override a method from a base class:"
                },
                {
                    "type": "code",
                    "code": "jsexportclassC{m() { }}classDextendsC{/**@override*/m() { }}Try"
                },
                {
                    "type": "p",
                    "text": "SetnoImplicitOverride: truein tsconfig to check overrides."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@extends"
                },
                {
                    "type": "p",
                    "text": "When JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The@extendstag allows this:"
                },
                {
                    "type": "code",
                    "code": "js/***@templateT*@extends{Set<T>}*/classSortableSetextendsSet{// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Note that@extendsonly works with classes. Currently, there is no way for a constructor function to extend a class."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@implements"
                },
                {
                    "type": "p",
                    "text": "In the same way, there is no JavaScript syntax for implementing a TypeScript interface. The@implementstag works just like in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js/**@implements{Print}*/classTextBook{print() {// TODO}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@constructor"
                },
                {
                    "type": "p",
                    "text": "The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a@constructortag:"
                },
                {
                    "type": "code",
                    "code": "js/***@constructor*@param{number}data*/functionC(data) {// property types can be inferredthis.name=\"foo\";// or set explicitly/**@type{string | null}*/this.title=null;// or simply annotated, if they're set elsewhere/**@type{number}*/this.size;this.initialize(data);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.}/***@param{string}s*/C.prototype.initialize=function(s) {this.size=s.length;};varc=newC(0);c.size;varresult=C(1);Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?Try"
                },
                {
                    "type": "p",
                    "text": "Note: Error messages only show up in JS codebases witha JSConfigandcheckJsenabled."
                },
                {
                    "type": "p",
                    "text": "With@constructor,thisis checked inside the constructor functionC, so you will get suggestions for theinitializemethod and an error if you pass it a number. Your editor may also show warnings if you callCinstead of constructing it."
                },
                {
                    "type": "p",
                    "text": "Unfortunately, this means that constructor functions that are also callable cannot use@constructor."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@this"
                },
                {
                    "type": "p",
                    "text": "The compiler can usually figure out the type ofthiswhen it has some context to work with. When it doesn’t, you can explicitly specify the type ofthiswith@this:"
                },
                {
                    "type": "code",
                    "code": "js/***@this{HTMLElement}*@param{*}e*/functioncallbackForLater(e) {this.clientHeight=parseInt(e);// should be fine!}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Documentation"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@deprecated"
                },
                {
                    "type": "p",
                    "text": "When a function, method, or property is deprecated you can let users know by marking it with a/** @deprecated */JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through stylelike this."
                },
                {
                    "type": "code",
                    "code": "js/**@deprecated*/constapiV1= {};constapiV2= {};apiV;apiV1apiV2Try"
                },
                {
                    "type": "list",
                    "items": [
                        "apiV1",
                        "apiV2"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@see"
                },
                {
                    "type": "p",
                    "text": "@seelets you link to other names in your program:"
                },
                {
                    "type": "code",
                    "code": "tstypeBox<T> = {t:T}/**@seeBoxfor implementation details */typeBoxify<T> = { [KinkeyofT]:Box<T> };Try"
                },
                {
                    "type": "p",
                    "text": "Some editors will turnBoxinto a link to make it easy to jump there and back."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@link"
                },
                {
                    "type": "p",
                    "text": "@linkis like@see, except that it can be used inside other tags:"
                },
                {
                    "type": "code",
                    "code": "tstypeBox<T> = {t:T}/**@returnsA{@linkBox}containing the parameter. */functionbox<U>(u:U):Box<U> {return{t:u};}Try"
                },
                {
                    "type": "p",
                    "text": "You can also link a property:"
                },
                {
                    "type": "code",
                    "code": "tstypePet= {name:stringhello: ()=>string}/*** Note: you should implement the{@linkPet.hello}method of Pet.*/functionhello(p:Pet) {p.hello()}Try"
                },
                {
                    "type": "p",
                    "text": "Or with an optional name:"
                },
                {
                    "type": "code",
                    "code": "tstypePet= {name:stringhello: ()=>string}/*** Note: you should implement the{@linkPet.hello| hello}method of Pet.*/functionhello(p:Pet) {p.hello()}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Other"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@enum"
                },
                {
                    "type": "p",
                    "text": "The@enumtag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members.@enumis intended for compatibility with Google Closure’s@enumtag."
                },
                {
                    "type": "code",
                    "code": "js/**@enum{number}*/constJSDocState= {BeginningOfLine:0,SawAsterisk:1,SavingComments:2,};JSDocState.SawAsterisk;Try"
                },
                {
                    "type": "p",
                    "text": "Note that@enumis quite different from, and much simpler than, TypeScript’senum. However, unlike TypeScript’s enums,@enumcan have any type:"
                },
                {
                    "type": "code",
                    "code": "js/**@enum{function(number): number}*/constMathFuncs= {add1:(n)=>n+1,id:(n)=>-n,sub1:(n)=>n-1,};MathFuncs.add1;Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "@author"
                },
                {
                    "type": "p",
                    "text": "You can specify the author of an item with@author:"
                },
                {
                    "type": "code",
                    "code": "ts/*** Welcome to awesome.ts*@authorIan Awesome<i.am.awesome@example.com>*/Try"
                },
                {
                    "type": "p",
                    "text": "Remember to surround the email address with angle brackets.\nOtherwise,@examplewill be parsed as a new tag."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Other supported patterns"
                },
                {
                    "type": "code",
                    "code": "jsvarsomeObj= {/***@param{string}param1- JSDocs on property assignments work*/x:function(param1) {},};/*** As do jsdocs on variable assignments*@return{Window}*/letsomeFunc=function() {};/*** And class methods*@param{string}greetingThe greeting to use*/Foo.prototype.sayHi= (greeting)=>console.log(\"Hi!\");/*** And arrow function expressions*@param{number}x- A multiplier*/letmyArrow= (x)=>x*x;/*** Which means it works for function components in JSX too*@param{{a: string, b: number}}props- Some param*/varfc= (props)=><div>{props.a.charAt(0)}</div>;/*** A parameter can be a class constructor, using Google Closure syntax.**@param{{new(...args: any[]): object}}C- The class to register*/functionregisterClass(C) {}/***@param{...string}p1- A 'rest' arg (array) of strings. (treated as 'any')*/functionfn10(p1) {}/***@param{...string}p1- A 'rest' arg (array) of strings. (treated as 'any')*/functionfn9(p1) {returnp1.join();}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unsupported patterns"
                },
                {
                    "type": "p",
                    "text": "Postfix equals on a property type in an object literal type doesn’t specify an optional property:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{{ a: string, b: number= }}*/varwrong;/*** Use postfix question on the property name instead:*@type{{ a: string, b?: number }}*/varright;Try"
                },
                {
                    "type": "p",
                    "text": "Nullable types only have meaning ifstrictNullChecksis on:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{?number}* With strictNullChecks: true  -- number | null* With strictNullChecks: false -- number*/varnullable;Try"
                },
                {
                    "type": "p",
                    "text": "The TypeScript-native syntax is a union type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{number | null}* With strictNullChecks: true  -- number | null* With strictNullChecks: false -- number*/varunionNullable;Try"
                },
                {
                    "type": "p",
                    "text": "Non-nullable types have no meaning and are treated just as their original type:"
                },
                {
                    "type": "code",
                    "code": "js/***@type{!number}* Just has type number*/varnormal;Try"
                },
                {
                    "type": "p",
                    "text": "Unlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not.\nThere is no explicit non-nullability — if strictNullChecks is on, thennumberis not nullable.\nIf it is off, thennumberis nullable."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unsupported tags"
                },
                {
                    "type": "p",
                    "text": "TypeScript ignores any unsupported JSDoc tags."
                },
                {
                    "type": "p",
                    "text": "The following tags have open issues to support them:"
                },
                {
                    "type": "list",
                    "items": [
                        "@memberof(issue #7237)",
                        "@yields(issue #23857)",
                        "@member(issue #56674)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Legacy type synonyms"
                },
                {
                    "type": "p",
                    "text": "A number of common types are given aliases for compatibility with old JavaScript code.\nSome of the aliases are the same as existing types, although most of those are rarely used.\nFor example,Stringis treated as an alias forstring.\nEven thoughStringis a type in TypeScript, old JSDoc often uses it to meanstring.\nBesides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use.\nSo the compiler treats these types as synonyms based on usage in old JSDoc:"
                },
                {
                    "type": "list",
                    "items": [
                        "String -> string",
                        "Number -> number",
                        "Boolean -> boolean",
                        "Void -> void",
                        "Undefined -> undefined",
                        "Null -> null",
                        "function -> Function",
                        "array -> Array<any>",
                        "promise -> Promise<any>",
                        "Object -> any",
                        "object -> any"
                    ]
                },
                {
                    "type": "p",
                    "text": "The last four aliases are turned off whennoImplicitAny: true:"
                },
                {
                    "type": "list",
                    "items": [
                        "objectandObjectare built-in types, althoughObjectis rarely used.",
                        "arrayandpromiseare not built-in, but might be declared somewhere in your program."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type Checking JavaScript Files"
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating .d.ts Files from .js files"
                },
                {
                    "type": "p",
                    "text": "How to add d.ts generation to JavaScript projects"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/jsx.html",
            "title": "TypeScript: Documentation - JSX",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "JSX"
                },
                {
                    "type": "p",
                    "text": "JSXis an embeddable XML-like syntax.\nIt is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific.\nJSX rose to popularity with theReactframework, but has since seen other implementations as well.\nTypeScript supports embedding, type checking, and compiling JSX directly to JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Basic usage"
                },
                {
                    "type": "p",
                    "text": "In order to use JSX you must do two things."
                },
                {
                    "type": "list",
                    "items": [
                        "Name your files with a.tsxextension",
                        "Enable thejsxoption"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript ships with several JSX modes:preserve,react(classic runtime),react-jsx(automatic runtime),react-jsxdev(automatic development runtime), andreact-native.\nThepreservemode will keep the JSX as part of the output to be further consumed by another transform step (e.g.Babel).\nAdditionally the output will have a.jsxfile extension.\nThereactmode will emitReact.createElement, does not need to go through a JSX transformation before use, and the output will have a.jsfile extension.\nThereact-nativemode is the equivalent ofpreservein that it keeps all JSX, but the output will instead have a.jsfile extension."
                },
                {
                    "type": "p",
                    "text": "You can specify this mode using either thejsxcommand line flag or the corresponding optionjsxin your tsconfig.jsonfile."
                },
                {
                    "type": "p",
                    "text": "*Note: You can specify the JSX factory function to use when targeting react JSX emit withjsxFactoryoption (defaults toReact.createElement)"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Theasoperator"
                },
                {
                    "type": "p",
                    "text": "Recall how to write a type assertion:"
                },
                {
                    "type": "code",
                    "code": "tsconstfoo= <Foo>bar;"
                },
                {
                    "type": "p",
                    "text": "This asserts the variablebarto have the typeFoo.\nSince TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in.tsxfiles."
                },
                {
                    "type": "p",
                    "text": "Since the above syntax cannot be used in.tsxfiles, an alternate type assertion operator should be used:as.\nThe example can easily be rewritten with theasoperator."
                },
                {
                    "type": "code",
                    "code": "tsconstfoo=barasFoo;"
                },
                {
                    "type": "p",
                    "text": "Theasoperator is available in both.tsand.tsxfiles, and is identical in behavior to the angle-bracket type assertion style."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type Checking"
                },
                {
                    "type": "p",
                    "text": "In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements.\nGiven a JSX expression<expr />,exprmay either refer to something intrinsic to the environment (e.g. adivorspanin a DOM environment) or to a custom component that you’ve created.\nThis is important for two reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "For React, intrinsic elements are emitted as strings (React.createElement(\"div\")), whereas a component you’ve created is not (React.createElement(MyComponent)).",
                        "The types of the attributes being passed in the JSX element should be looked up differently.\nIntrinsic element attributes should be knownintrinsicallywhereas components will likely want to specify their own set of attributes."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript uses thesame convention that React doesfor distinguishing between these.\nAn intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TheJSXnamespace"
                },
                {
                    "type": "p",
                    "text": "JSX in TypeScript is typed by theJSXnamespace. TheJSXnamespace may be defined in various places, depending on thejsxcompiler option."
                },
                {
                    "type": "p",
                    "text": "Thejsxoptionspreserve,react, andreact-nativeuse the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by thejsxFactorycompiler option. TheJSXnamespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factoryReact.createElement. This means itsJSXnamespace should be defined asReact.JSX."
                },
                {
                    "type": "code",
                    "code": "tsexportfunctioncreateElement():any;exportnamespaceJSX{// …}"
                },
                {
                    "type": "p",
                    "text": "And the user should always import React asReact."
                },
                {
                    "type": "code",
                    "code": "tsimport*asReactfrom'react';"
                },
                {
                    "type": "p",
                    "text": "Preact uses the JSX factoryh. That means its types should be defined as theh.JSX."
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionh(props:any):any;exportnamespaceh.JSX{// …}"
                },
                {
                    "type": "p",
                    "text": "The user should use a named import to importh."
                },
                {
                    "type": "code",
                    "code": "tsimport{h}from'preact';"
                },
                {
                    "type": "p",
                    "text": "For thejsxoptionsreact-jsxandreact-jsxdev, theJSXnamespace should be exported from the matching entry points. Forreact-jsxthis is${jsxImportSource}/jsx-runtime. Forreact-jsxdev, this is${jsxImportSource}/jsx-dev-runtime. Since these don’t use a file extension, you must use theexportsfield inpackage.jsonmap in order to support ESM users."
                },
                {
                    "type": "code",
                    "code": "json{\"exports\": {\"./jsx-runtime\":\"./jsx-runtime.js\",\"./jsx-dev-runtime\":\"./jsx-dev-runtime.js\",}}"
                },
                {
                    "type": "p",
                    "text": "Then injsx-runtime.d.tsandjsx-dev-runtime.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportnamespaceJSX{// …}"
                },
                {
                    "type": "p",
                    "text": "Note that while exporting theJSXnamespace is sufficient for type checking, the production runtime needs thejsx,jsxs, andFragmentexports at runtime, and the development runtime needsjsxDEVandFragment. Ideally you add types for those too."
                },
                {
                    "type": "p",
                    "text": "If theJSXnamespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the globalJSXnamespace."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Intrinsic elements"
                },
                {
                    "type": "p",
                    "text": "Intrinsic elements are looked up on the special interfaceJSX.IntrinsicElements.\nBy default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked.\nHowever, if this interfaceispresent, then the name of the intrinsic element is looked up as a property on theJSX.IntrinsicElementsinterface.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo:any;}}<foo/>;// ok<bar/>;// error"
                },
                {
                    "type": "p",
                    "text": "In the above example,<foo />will work fine but<bar />will result in an error since it has not been specified onJSX.IntrinsicElements."
                },
                {
                    "type": "p",
                    "text": "Note: You can also specify a catch-all string indexer onJSX.IntrinsicElementsas follows:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceJSX{interfaceIntrinsicElements{[elemName:string]:any;}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Value-based elements"
                },
                {
                    "type": "p",
                    "text": "Value-based elements are simply looked up by identifiers that are in scope."
                },
                {
                    "type": "code",
                    "code": "tsximportMyComponentfrom\"./myComponent\";<MyComponent/>;// ok<SomeOtherComponent/>;// error"
                },
                {
                    "type": "p",
                    "text": "There are two ways to define a value-based element:"
                },
                {
                    "type": "list",
                    "items": [
                        "Function Component (FC)",
                        "Class Component"
                    ]
                },
                {
                    "type": "p",
                    "text": "Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Function Component"
                },
                {
                    "type": "p",
                    "text": "As the name suggests, the component is defined as a JavaScript function where its first argument is apropsobject.\nTS enforces that its return type must be assignable toJSX.Element."
                },
                {
                    "type": "code",
                    "code": "tsxinterfaceFooProp{name:string;X:number;Y:number;}declarefunctionAnotherComponent(prop: {name:string});functionComponentFoo(prop:FooProp) {return<AnotherComponentname={prop.name}/>;}constButton= (prop: {value:string},context: {color:string})=>(<button/>);"
                },
                {
                    "type": "p",
                    "text": "Because a Function Component is simply a JavaScript function, function overloads may be used here as well:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceClickableProps{children:JSX.Element[] |JSX.Element;}interfaceHomePropsextendsClickableProps{home:JSX.Element;}interfaceSidePropsextendsClickableProps{side:JSX.Element|string;}functionMainButton(prop:HomeProps):JSX.Element;functionMainButton(prop:SideProps):JSX.Element;functionMainButton(prop:ClickableProps):JSX.Element{// ...}Try"
                },
                {
                    "type": "p",
                    "text": "Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the typeSFCand its aliasStatelessComponentwere deprecated."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Class Component"
                },
                {
                    "type": "p",
                    "text": "It is possible to define the type of a class component.\nHowever, to do so it is best to understand two new terms: theelement class typeand theelement instance type."
                },
                {
                    "type": "p",
                    "text": "Given<Expr />, theelement class typeis the type ofExpr.\nSo in the example above, ifMyComponentwas an ES6 class the class type would be that class’s constructor and statics.\nIfMyComponentwas a factory function, the class type would be that function."
                },
                {
                    "type": "p",
                    "text": "Once the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present).\nSo again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function."
                },
                {
                    "type": "code",
                    "code": "tsclassMyComponent{render() {}}// use a construct signatureconstmyComponent=newMyComponent();// element class type => MyComponent// element instance type => { render: () => void }functionMyFactoryFunction() {return{render:()=>{},};}// use a call signatureconstmyComponent=MyFactoryFunction();// element class type => MyFactoryFunction// element instance type => { render: () => void }"
                },
                {
                    "type": "p",
                    "text": "The element instance type is interesting because it must be assignable toJSX.ElementClassor it will result in an error.\nBy defaultJSX.ElementClassis{}, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceElementClass{render:any;}}classMyComponent{render() {}}functionMyFactoryFunction() {return{render:()=>{} };}<MyComponent/>;// ok<MyFactoryFunction/>;// okclassNotAValidComponent{}functionNotAValidFactoryFunction() {return{};}<NotAValidComponent/>;// error<NotAValidFactoryFunction/>;// error"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Attribute type checking"
                },
                {
                    "type": "p",
                    "text": "The first step to type checking attributes is to determine theelement attributes type.\nThis is slightly different between intrinsic and value-based elements."
                },
                {
                    "type": "p",
                    "text": "For intrinsic elements, it is the type of the property onJSX.IntrinsicElements"
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo: {bar?:boolean};}}// element attributes type for 'foo' is '{bar?: boolean}'<foobar/>;"
                },
                {
                    "type": "p",
                    "text": "For value-based elements, it is a bit more complex.\nIt is determined by the type of a property on theelement instance typethat was previously determined.\nWhich property to use is determined byJSX.ElementAttributesProperty.\nIt should be declared with a single property.\nThe name of that property is then used.\nAs of TypeScript 2.8, ifJSX.ElementAttributesPropertyis not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceElementAttributesProperty{props;// specify the property name to use}}classMyComponent{// specify the property on the element instance typeprops: {foo?:string;};}// element attributes type for 'MyComponent' is '{foo?: string}'<MyComponentfoo=\"bar\"/>;"
                },
                {
                    "type": "p",
                    "text": "The element attribute type is used to type check the attributes in the JSX.\nOptional and required properties are supported."
                },
                {
                    "type": "code",
                    "code": "tsxdeclarenamespaceJSX{interfaceIntrinsicElements{foo: {requiredProp:string;optionalProp?:number};}}<foorequiredProp=\"bar\"/>;// ok<foorequiredProp=\"bar\"optionalProp={0}/>;// ok<foo/>;// error, requiredProp is missing<foorequiredProp={0}/>;// error, requiredProp should be a string<foorequiredProp=\"bar\"unknownProp/>;// error, unknownProp does not exist<foorequiredProp=\"bar\"some-unknown-prop/>;// ok, because 'some-unknown-prop' is not a valid identifier"
                },
                {
                    "type": "p",
                    "text": "Note: If an attribute name is not a valid JS identifier (like adata-*attribute), it is not considered to be an error if it is not found in the element attributes type."
                },
                {
                    "type": "p",
                    "text": "Additionally, theJSX.IntrinsicAttributesinterface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instancekeyin React. Specializing further, the genericJSX.IntrinsicClassAttributes<T>type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow therefattribute of typeRef<T>. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag."
                },
                {
                    "type": "p",
                    "text": "The spread operator also works:"
                },
                {
                    "type": "code",
                    "code": "tsxconstprops= {requiredProp:\"bar\"};<foo{...props}/>;// okconstbadProps= {};<foo{...badProps}/>;// error"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children Type Checking"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 2.3, TS introduced type checking ofchildren.childrenis a special property in anelement attributes typewhere childJSXExpressions are taken to be inserted into the attributes.\nSimilar to how TS usesJSX.ElementAttributesPropertyto determine the name ofprops, TS usesJSX.ElementChildrenAttributeto determine the name ofchildrenwithin those props.JSX.ElementChildrenAttributeshould be declared with a single property."
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceJSX{interfaceElementChildrenAttribute{children: {};// specify children name to use}}"
                },
                {
                    "type": "code",
                    "code": "tsx<div><h1>Hello</h1></div>;<div><h1>Hello</h1>World</div>;constCustomComp= (props)=><div>{props.children}</div><CustomComp><div>Hello World</div>{\"This is just a JS expression...\"+1000}</CustomComp>"
                },
                {
                    "type": "p",
                    "text": "You can specify the type ofchildrenlike any other attribute. This will override the default type from, e.g. theReact typingsif you use them."
                },
                {
                    "type": "code",
                    "code": "tsxinterfacePropsType{children:JSX.Elementname:string}classComponentextendsReact.Component<PropsType, {}> {render() {return(<h2>{this.props.children}</h2>)}}// OK<Componentname=\"foo\"><h1>Hello World</h1></Component>// Error: children is of type JSX.Element not array of JSX.Element<Componentname=\"bar\"><h1>Hello World</h1><h2>Hello World</h2></Component>// Error: children is of type JSX.Element not array of JSX.Element or string.<Componentname=\"baz\"><h1>Hello</h1>World</Component>"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The JSX result type"
                },
                {
                    "type": "p",
                    "text": "By default the result of a JSX expression is typed asany.\nYou can customize the type by specifying theJSX.Elementinterface.\nHowever, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface.\nIt is a black box."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The JSX function return type"
                },
                {
                    "type": "p",
                    "text": "By default, function components must returnJSX.Element | null. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specifyJSX.ElementTypeto override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceJSX{exporttypeElementType=// All the valid lowercase tags|keyofIntrinsicElements// Function components| (props:any)=>Element// Class components|new(props:any)=>ElementClass;exportinterfaceIntrinsicAttributesextends/*...*/{}exporttypeElement=/*...*/;exporttypeElementClass=/*...*/;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Embedding Expressions"
                },
                {
                    "type": "p",
                    "text": "JSX allows you to embed expressions between tags by surrounding the expressions with curly braces ({ })."
                },
                {
                    "type": "code",
                    "code": "tsxconsta= (<div>{[\"foo\",\"bar\"].map((i)=>(<span>{i/2}</span>))}</div>);"
                },
                {
                    "type": "p",
                    "text": "The above code will result in an error since you cannot divide a string by a number.\nThe output, when using thepreserveoption, looks like:"
                },
                {
                    "type": "code",
                    "code": "tsxconsta= (<div>{[\"foo\",\"bar\"].map(function(i) {return<span>{i/2}</span>;})}</div>);"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React integration"
                },
                {
                    "type": "p",
                    "text": "To use JSX with React you should use theReact typings.\nThese typings define theJSXnamespace appropriately for use with React."
                },
                {
                    "type": "code",
                    "code": "tsx///<referencepath=\"react.d.ts\"/>interfaceProps{foo:string;}classMyComponentextendsReact.Component<Props, {}> {render() {return<span>{this.props.foo}</span>;}}<MyComponentfoo=\"bar\"/>;// ok<MyComponentfoo={0}/>;// error"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Configuring JSX"
                },
                {
                    "type": "p",
                    "text": "There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:"
                },
                {
                    "type": "list",
                    "items": [
                        "jsxFactory",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
            "title": "TypeScript: Documentation - Migrating from JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Migrating from JavaScript"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t exist in a vacuum.\nIt was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today.\nConverting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging.\nIn this tutorial, we’re going to look at how you might start out.\nWe assume you’ve read enough of the handbook to write new TypeScript code."
                },
                {
                    "type": "p",
                    "text": "If you’re looking to convert a React project, we recommend looking at theReact Conversion Guidefirst."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Setting up your Directories"
                },
                {
                    "type": "p",
                    "text": "If you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly,\nwhere your.jsfiles are in asrc,lib, ordistdirectory, and then run as desired."
                },
                {
                    "type": "p",
                    "text": "If that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces.\nDuring our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them.\nIf your output files need to reside in a specific directory, then that will be your output directory."
                },
                {
                    "type": "p",
                    "text": "You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel.\nIn this case, you might already have a folder structure like this set up."
                },
                {
                    "type": "p",
                    "text": "From this point on, we’re going to assume that your directory is set up something like this:"
                },
                {
                    "type": "code",
                    "code": "projectRoot├── src│   ├── file1.js│   └── file2.js├── built└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "If you have atestsfolder outside of yoursrcdirectory, you might have onetsconfig.jsoninsrc, and one intestsas well."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Writing a Configuration File"
                },
                {
                    "type": "p",
                    "text": "TypeScript uses a file calledtsconfig.jsonfor managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform.\nLet’s create a bare-bones one for our project:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"outDir\":\"./built\",\"allowJs\":true,\"target\":\"es5\"},\"include\": [\"./src/**/*\"]}"
                },
                {
                    "type": "p",
                    "text": "Here we’re specifying a few things to TypeScript:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read in any files it understands in thesrcdirectory (withinclude).",
                        "Accept JavaScript files as inputs (withallowJs).",
                        "Emit all of the output files inbuilt(withoutDir).",
                        "Translate newer JavaScript constructs down to an older version like ECMAScript 5 (usingtarget)."
                    ]
                },
                {
                    "type": "p",
                    "text": "At this point, if you try runningtscat the root of your project, you should see output files in thebuiltdirectory.\nThe layout of files inbuiltshould look identical to the layout ofsrc.\nYou should now have TypeScript working with your project."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Early Benefits"
                },
                {
                    "type": "p",
                    "text": "Even at this point you can get some great benefits from TypeScript understanding your project.\nIf you open up an editor likeVS CodeorVisual Studio, you’ll see that you can often get some tooling support like completion.\nYou can also catch certain bugs with options like:"
                },
                {
                    "type": "list",
                    "items": [
                        "noImplicitReturnswhich prevents you from forgetting to return at the end of a function.",
                        "noFallthroughCasesInSwitchwhich is helpful if you never want to forget abreakstatement betweencases in aswitchblock."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript will also warn about unreachable code and labels, which you can disable withallowUnreachableCodeandallowUnusedLabelsrespectively."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Integrating with Build Tools"
                },
                {
                    "type": "p",
                    "text": "You might have some more build steps in your pipeline.\nPerhaps you concatenate something to each of your files.\nEach build tool is different, but we’ll do our best to cover the gist of things."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Gulp"
                },
                {
                    "type": "p",
                    "text": "If you’re using Gulp in some fashion, we have a tutorial onusing Gulpwith TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify.\nYou can read more there."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Webpack"
                },
                {
                    "type": "p",
                    "text": "Webpack integration is pretty simple.\nYou can usets-loader, a TypeScript loader, combined withsource-map-loaderfor easier debugging.\nSimply run"
                },
                {
                    "type": "code",
                    "code": "shellnpm install ts-loader source-map-loader"
                },
                {
                    "type": "p",
                    "text": "and merge in options from the following into yourwebpack.config.jsfile:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports= {entry:\"./src/index.ts\",output:{filename:\"./dist/bundle.js\",},// Enable sourcemaps for debugging webpack's output.devtool:\"source-map\",resolve:{// Add '.ts' and '.tsx' as resolvable extensions.extensions:[\"\",\".webpack.js\",\".web.js\",\".ts\",\".tsx\",\".js\"],},module:{rules:[// All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.{test:/\\.tsx?$/,loader:\"ts-loader\"},// All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.{test:/\\.js$/,loader:\"source-map-loader\"},],},// Other options...};"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that ts-loader will need to run before any other loader that deals with.jsfiles."
                },
                {
                    "type": "p",
                    "text": "You can see an example of using Webpack in ourtutorial on React and Webpack."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Moving to TypeScript Files"
                },
                {
                    "type": "p",
                    "text": "At this point, you’re probably ready to start using TypeScript files.\nThe first step is to rename one of your.jsfiles to.ts.\nIf your file uses JSX, you’ll need to rename it to.tsx."
                },
                {
                    "type": "p",
                    "text": "Finished with that step?\nGreat!\nYou’ve successfully migrated a file from JavaScript to TypeScript!"
                },
                {
                    "type": "p",
                    "text": "Of course, that might not feel right.\nIf you open that file in an editor with TypeScript support (or if you runtsc --pretty), you might see red squiggles on certain lines.\nYou should think of these the same way you’d think of red squiggles in an editor like Microsoft Word.\nTypeScript will still translate your code, just like Word will still let you print your documents."
                },
                {
                    "type": "p",
                    "text": "If that sounds too lax for you, you can tighten that behavior up.\nIf, for instance, youdon’twant TypeScript to compile to JavaScript in the face of errors, you can use thenoEmitOnErroroption.\nIn that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want."
                },
                {
                    "type": "p",
                    "text": "If you plan on using the stricter settings that are available, it’s best to turn them on now (seeGetting Stricter Checksbelow).\nFor instance, if you never want TypeScript to silently inferanyfor a type without you explicitly saying so, you can usenoImplicitAnybefore you start modifying your files.\nWhile it might feel somewhat overwhelming, the long-term gains become apparent much more quickly."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Weeding out Errors"
                },
                {
                    "type": "p",
                    "text": "Like we mentioned, it’s not unexpected to get error messages after conversion.\nThe important thing is to actually go one by one through these and decide how to deal with the errors.\nOften these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Importing from Modules"
                },
                {
                    "type": "p",
                    "text": "You might start out getting a bunch of errors likeCannot find name 'require'., andCannot find name 'define'..\nIn these cases, it’s likely that you’re using modules.\nWhile you can just convince TypeScript that these exist by writing out"
                },
                {
                    "type": "code",
                    "code": "ts// For Node/CommonJSdeclarefunctionrequire(path:string):any;"
                },
                {
                    "type": "p",
                    "text": "or"
                },
                {
                    "type": "code",
                    "code": "ts// For RequireJS/AMDdeclarefunctiondefine(...args:any[]):any;"
                },
                {
                    "type": "p",
                    "text": "it’s better to get rid of those calls and use TypeScript syntax for imports."
                },
                {
                    "type": "p",
                    "text": "First, you’ll need to enable some module system by setting TypeScript’smoduleoption.\nValid options arecommonjs,amd,system, andumd."
                },
                {
                    "type": "p",
                    "text": "If you had the following Node/CommonJS code:"
                },
                {
                    "type": "code",
                    "code": "jsvarfoo=require(\"foo\");foo.doStuff();"
                },
                {
                    "type": "p",
                    "text": "or the following RequireJS/AMD code:"
                },
                {
                    "type": "code",
                    "code": "jsdefine([\"foo\"],function(foo) {foo.doStuff();});"
                },
                {
                    "type": "p",
                    "text": "then you would write the following TypeScript code:"
                },
                {
                    "type": "code",
                    "code": "tsimportfoo=require(\"foo\");foo.doStuff();"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Getting Declaration Files"
                },
                {
                    "type": "p",
                    "text": "If you started converting over to TypeScript imports, you’ll probably run into errors likeCannot find module 'foo'..\nThe issue here is that you likely don’t havedeclaration filesto describe your library.\nLuckily this is pretty easy.\nIf TypeScript complains about a package likelodash, you can just write"
                },
                {
                    "type": "code",
                    "code": "shellnpm install -S @types/lodash"
                },
                {
                    "type": "p",
                    "text": "If you’re using a module option other thancommonjs, you’ll need to set yourmoduleResolutionoption tonode."
                },
                {
                    "type": "p",
                    "text": "After that, you’ll be able to import lodash with no issues, and get accurate completions."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Exporting from Modules"
                },
                {
                    "type": "p",
                    "text": "Typically, exporting from a module involves adding properties to a value likeexportsormodule.exports.\nTypeScript allows you to use top-level export statements.\nFor instance, if you exported a function like so:"
                },
                {
                    "type": "code",
                    "code": "jsmodule.exports.feedPets=function(pets) {// ...};"
                },
                {
                    "type": "p",
                    "text": "you could write that out as the following:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionfeedPets(pets) {// ...}"
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll entirely overwrite the exports object.\nThis is a common pattern people use to make their modules immediately callable like in this snippet:"
                },
                {
                    "type": "code",
                    "code": "jsvarexpress=require(\"express\");varapp=express();"
                },
                {
                    "type": "p",
                    "text": "You might have previously written that like so:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionfoo() {// ...}module.exports=foo;"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, you can model this with theexport =construct."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfoo() {// ...}export=foo;"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Too many/too few arguments"
                },
                {
                    "type": "p",
                    "text": "You’ll sometimes find yourself calling a function with too many/few arguments.\nTypically, this is a bug, but in some cases, you might have declared a function that uses theargumentsobject instead of writing out any parameters:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionmyCoolFunction() {if(arguments.length==2&& !Array.isArray(arguments[1])) {varf=arguments[0];vararr=arguments[1];// ...}// ...}myCoolFunction(function(x) {console.log(x);},[1,2,3,4]);myCoolFunction(function(x) {console.log(x);},1,2,3,4);"
                },
                {
                    "type": "p",
                    "text": "In this case, we need to use TypeScript to tell any of our callers about the waysmyCoolFunctioncan be called using function overloads."
                },
                {
                    "type": "code",
                    "code": "tsfunctionmyCoolFunction(f: (x:number)=>void,nums:number[]):void;functionmyCoolFunction(f: (x:number)=>void, ...nums:number[]):void;functionmyCoolFunction() {if(arguments.length==2&& !Array.isArray(arguments[1])) {varf=arguments[0];vararr=arguments[1];// ...}// ...}"
                },
                {
                    "type": "p",
                    "text": "We added two overload signatures tomyCoolFunction.\nThe first checks states thatmyCoolFunctiontakes a function (which takes anumber), and then a list ofnumbers.\nThe second one says that it will take a function as well, and then uses a rest parameter (...nums) to state that any number of arguments after that need to benumbers."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Sequentially Added Properties"
                },
                {
                    "type": "p",
                    "text": "Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:"
                },
                {
                    "type": "code",
                    "code": "jsvaroptions= {};options.color=\"red\";options.volume=11;"
                },
                {
                    "type": "p",
                    "text": "TypeScript will say that you can’t assign tocolorandvolumebecause it first figured out the type ofoptionsas{}which doesn’t have any properties.\nIf you instead moved the declarations into the object literal themselves, you’d get no errors:"
                },
                {
                    "type": "code",
                    "code": "tsletoptions= {color:\"red\",volume:11,};"
                },
                {
                    "type": "p",
                    "text": "You could also define the type ofoptionsand add a type assertion on the object literal."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceOptions{color:string;volume:number;}letoptions= {}asOptions;options.color=\"red\";options.volume=11;"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can just sayoptionshas the typeanywhich is the easiest thing to do, but which will benefit you the least."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "any,Object, and{}"
                },
                {
                    "type": "p",
                    "text": "You might be tempted to useObjector{}to say that a value can have any property on it becauseObjectis, for most purposes, the most general type.\nHoweveranyis actually the type you want to usein those situations, since it’s the mostflexibletype."
                },
                {
                    "type": "p",
                    "text": "For instance, if you have something that’s typed asObjectyou won’t be able to call methods liketoLowerCase()on it.\nBeing more general usually means you can do less with a type, butanyis special in that it is the most general type while still allowing you to do anything with it.\nThat means you can call it, construct it, access properties on it, etc.\nKeep in mind though, whenever you useany, you lose out on most of the error checking and editor support that TypeScript gives you."
                },
                {
                    "type": "p",
                    "text": "If a decision ever comes down toObjectand{}, you should prefer{}.\nWhile they are mostly the same, technically{}is a more general type thanObjectin certain esoteric cases."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Getting Stricter Checks"
                },
                {
                    "type": "p",
                    "text": "TypeScript comes with certain checks to give you more safety and analysis of your program.\nOnce you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "No Implicitany"
                },
                {
                    "type": "p",
                    "text": "There are certain cases where TypeScript can’t figure out what certain types should be.\nTo be as lenient as possible, it will decide to use the typeanyin its place.\nWhile this is great for migration, usinganymeans that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere.\nYou can tell TypeScript to flag these locations down and give an error with thenoImplicitAnyoption."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Strictnull&undefinedChecks"
                },
                {
                    "type": "p",
                    "text": "By default, TypeScript assumes thatnullandundefinedare in the domain of every type.\nThat means anything declared with the typenumbercould benullorundefined.\nSincenullandundefinedare such a frequent source of bugs in JavaScript and TypeScript, TypeScript has thestrictNullChecksoption to spare you the stress of worrying about these issues."
                },
                {
                    "type": "p",
                    "text": "WhenstrictNullChecksis enabled,nullandundefinedget their own types callednullandundefinedrespectively.\nWhenever anything ispossiblynull, you can use a union type with the original type.\nSo for instance, if something could be anumberornull, you’d write the type out asnumber | null."
                },
                {
                    "type": "p",
                    "text": "If you ever have a value that TypeScript thinks is possiblynull/undefined, but you know better, you can use the postfix!operator to tell it otherwise."
                },
                {
                    "type": "code",
                    "code": "tsdeclarevarfoo:string[] |null;foo.length;// error - 'foo' is possibly 'null'foo!.length;// okay - 'foo!' just has type 'string[]'"
                },
                {
                    "type": "p",
                    "text": "As a heads up, when usingstrictNullChecks, your dependencies may need to be updated to usestrictNullChecksas well."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "No Implicitanyforthis"
                },
                {
                    "type": "p",
                    "text": "When you use thethiskeyword outside of classes, it has the typeanyby default.\nFor instance, imagine aPointclass, and imagine a function that we wish to add as a method:"
                },
                {
                    "type": "code",
                    "code": "tsclassPoint{constructor(publicx,publicy) {}getDistance(p:Point) {letdx=p.x-this.x;letdy=p.y-this.y;returnMath.sqrt(dx**2+dy**2);}}// ...// Reopen the interface.interfacePoint{distanceFromOrigin():number;}Point.prototype.distanceFromOrigin=function() {returnthis.getDistance({x:0,y:0});};"
                },
                {
                    "type": "p",
                    "text": "This has the same problems we mentioned above - we could easily have misspelledgetDistanceand not gotten an error.\nFor this reason, TypeScript has thenoImplicitThisoption.\nWhen that option is set, TypeScript will issue an error whenthisis used without an explicit (or inferred) type.\nThe fix is to use athis-parameter to give an explicit type in the interface or in the function itself:"
                },
                {
                    "type": "code",
                    "code": "tsPoint.prototype.distanceFromOrigin=function(this:Point) {returnthis.getDistance({x:0,y:0});};"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/mixins.html",
            "title": "TypeScript: Documentation - Mixins",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Mixins"
                },
                {
                    "type": "p",
                    "text": "Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes.\nYou may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How Does A Mixin Work?"
                },
                {
                    "type": "p",
                    "text": "The pattern relies on using generics with class inheritance to extend a base class.\nTypeScript’s best mixin support is done via the class expression pattern.\nYou can read more about how this pattern works in JavaScripthere."
                },
                {
                    "type": "p",
                    "text": "To get started, we’ll need a class which will have the mixins applied on top of:"
                },
                {
                    "type": "code",
                    "code": "tsclassSprite{name=\"\";x=0;y=0;constructor(name:string) {this.name=name;}}Try"
                },
                {
                    "type": "p",
                    "text": "Then you need a type and a factory function which returns a class expression extending the base class."
                },
                {
                    "type": "code",
                    "code": "ts// To get started, we need a type which we'll use to extend// other classes from. The main responsibility is to declare// that the type being passed in is a class.typeConstructor=new(...args:any[])=>{};// This mixin adds a scale property, with getters and setters// for changing it with an encapsulated private property:functionScale<TBaseextendsConstructor>(Base:TBase) {returnclassScalingextendsBase{// Mixins may not declare private/protected properties// however, you can use ES2020 private fields_scale=1;setScale(scale:number) {this._scale=scale;}getscale():number{returnthis._scale;}};}Try"
                },
                {
                    "type": "p",
                    "text": "With these all set up, then you can create a class which represents the base class with mixins applied:"
                },
                {
                    "type": "code",
                    "code": "ts// Compose a new class from the Sprite class,// with the Mixin Scale applier:constEightBitSprite=Scale(Sprite);constflappySprite=newEightBitSprite(\"Bird\");flappySprite.setScale(0.8);console.log(flappySprite.scale);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Constrained Mixins"
                },
                {
                    "type": "p",
                    "text": "In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want."
                },
                {
                    "type": "p",
                    "text": "To model this, we modify the original constructor type to accept a generic argument."
                },
                {
                    "type": "code",
                    "code": "ts// This was our previous constructor:typeConstructor=new(...args:any[])=>{};// Now we use a generic version which can apply a constraint on// the class which this mixin is applied totypeGConstructor<T= {}> =new(...args:any[])=>T;Try"
                },
                {
                    "type": "p",
                    "text": "This allows for creating classes which only work with constrained base classes:"
                },
                {
                    "type": "code",
                    "code": "tstypePositionable=GConstructor<{setPos: (x:number,y:number)=>void}>;typeSpritable=GConstructor<Sprite>;typeLoggable=GConstructor<{print: ()=>void}>;Try"
                },
                {
                    "type": "p",
                    "text": "Then you can create mixins which only work when you have a particular base to build on:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionJumpable<TBaseextendsPositionable>(Base:TBase) {returnclassJumpableextendsBase{jump() {// This mixin will only work if it is passed a base// class which has setPos defined because of the// Positionable constraint.this.setPos(0,20);}};}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternative Pattern"
                },
                {
                    "type": "p",
                    "text": "Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:"
                },
                {
                    "type": "code",
                    "code": "ts// Each mixin is a traditional ES classclassJumpable{jump() {}}classDuckable{duck() {}}// Including the baseclassSprite{x=0;y=0;}// Then you create an interface which merges// the expected mixins with the same name as your baseinterfaceSpriteextendsJumpable,Duckable{}// Apply the mixins into the base class via// the JS at runtimeapplyMixins(Sprite, [Jumpable,Duckable]);letplayer=newSprite();player.jump();console.log(player.x,player.y);// This can live anywhere in your codebase:functionapplyMixins(derivedCtor:any,constructors:any[]) {constructors.forEach((baseCtor)=>{Object.getOwnPropertyNames(baseCtor.prototype).forEach((name)=>{Object.defineProperty(derivedCtor.prototype,name,Object.getOwnPropertyDescriptor(baseCtor.prototype,name) ||Object.create(null));});});}Try"
                },
                {
                    "type": "p",
                    "text": "This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Constraints"
                },
                {
                    "type": "p",
                    "text": "The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis.\nThere are a few cases where you can hit the edges of the native support."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Decorators and Mixins#4881"
                },
                {
                    "type": "p",
                    "text": "You cannot use decorators to provide mixins via code flow analysis:"
                },
                {
                    "type": "code",
                    "code": "ts// A decorator function which replicates the mixin pattern:constPausable= (target:typeofPlayer)=>{returnclassPausableextendstarget{shouldFreeze=false;};};@PausableclassPlayer{x=0;y=0;}// The Player class does not have the decorator's type merged:constplayer=newPlayer();player.shouldFreeze;Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.// The runtime aspect could be manually replicated via// type composition or interface merging.typeFreezablePlayer=Player& {shouldFreeze:boolean};constplayerTwo= (newPlayer()asunknown)asFreezablePlayer;playerTwo.shouldFreeze;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Static Property Mixins#17829"
                },
                {
                    "type": "p",
                    "text": "More of a gotcha than a constraint.\nThe class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types."
                },
                {
                    "type": "p",
                    "text": "You can work around this by using functions to return your classes which differ based on a generic:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionbase<T>() {classBase{staticprop:T;}returnBase;}functionderived<T>() {classDerivedextendsbase<T>() {staticanotherProp:T;}returnDerived;}classSpecextendsderived<string>() {}Spec.prop;// stringSpec.anotherProp;// stringTry"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html",
            "title": "TypeScript: Documentation - Modules - ESM/CJS Interoperability",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules - ESM/CJS Interoperability"
                },
                {
                    "type": "p",
                    "text": "It’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:"
                },
                {
                    "type": "code",
                    "code": "tsexportconstA= {};exportconstB= {};exportdefault\"Hello, world!\";"
                },
                {
                    "type": "p",
                    "text": "How would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:"
                },
                {
                    "type": "code",
                    "code": "tsexports.A= {};exports.B= {};exports.default=\"Hello, world!\";"
                },
                {
                    "type": "p",
                    "text": "This is a nice analog, and it lets you implement a similar on the importing side:"
                },
                {
                    "type": "code",
                    "code": "tsimporthello, {A,B}from\"./module\";console.log(hello,A,B);// transpiles to:constmodule_1=require(\"./module\");console.log(module_1.default,module_1.A,module_1.B);"
                },
                {
                    "type": "p",
                    "text": "So far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmodfrom\"./module\";console.log(mod.default,mod.A,mod.B);// transpiles to:constmod=require(\"./module\");console.log(mod.default,mod.A,mod.B);"
                },
                {
                    "type": "p",
                    "text": "You might notice that in this scheme, there’s no way to write an ESM export that produces an output whereexportsis assigned a function, class, or primitive:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: exports-function.jsmodule.exports=functionhello() {console.log(\"Hello, world!\");};"
                },
                {
                    "type": "p",
                    "text": "But existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (import *) transpiles to a plainrequirecall, so we can support an input like:"
                },
                {
                    "type": "code",
                    "code": "tsimport*ashellofrom\"./exports-function\";hello();// transpiles to:consthello=require(\"./exports-function\");hello();"
                },
                {
                    "type": "p",
                    "text": "Our output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to aModule Namespace Object, that is, an object whose members are the exports of the module. In this case,requirewould return the functionhello, butimport *can never return a function. The correspondence we assumed appears invalid."
                },
                {
                    "type": "p",
                    "text": "It’s worth taking a step back here and clarifying what thegoalis. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior."
                },
                {
                    "type": "p",
                    "text": "By following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "However, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Even if transpiler authors did nothing, a behavior would emerge from the existing semantics between therequirecalls they emitted in transpiled code and theexportsdefined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement."
                },
                {
                    "type": "p",
                    "text": "Guessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able torequireES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJSrequirecalls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "allowSyntheticDefaultImportsandesModuleInterop"
                },
                {
                    "type": "p",
                    "text": "Let’s return to our specification compliance problem, whereimport *transpiles torequire:"
                },
                {
                    "type": "code",
                    "code": "ts// Invalid according to the spec:import*ashellofrom\"./exports-function\";hello();// but the transpilation works:consthello=require(\"./exports-function\");hello();"
                },
                {
                    "type": "p",
                    "text": "When TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whoseexportswas not a namespace-like object:"
                },
                {
                    "type": "code",
                    "code": "tsimport*ashellofrom\"./exports-function\";// TS2497              ^^^^^^^^^^^^^^^^^^^^// External module '\"./exports-function\"' resolves to a non-module entity// and cannot be imported using this construct."
                },
                {
                    "type": "p",
                    "text": "The only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJSrequire:"
                },
                {
                    "type": "code",
                    "code": "tsimporthello=require(\"./exports-function\");"
                },
                {
                    "type": "p",
                    "text": "Forcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like\"./exports-function\"will be accessible with ESM imports in the future, but we know itcan’tbe withimport *, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing theimport *to link to a function. This is still the behavior in TypeScript today whenallowSyntheticDefaultImportsandesModuleInteropare disabled."
                },
                {
                    "type": "p",
                    "text": "Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunction$(selector:string):any;export=$;// Cannot `import *` this 👍"
                },
                {
                    "type": "p",
                    "text": "A should-be-meaningless change allowed the invalid import to type check without errors:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespace${}declarefunction$(selector:string):any;export=$;// Allowed to `import *` this and call it 😱"
                },
                {
                    "type": "p",
                    "text": "Meanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.",
                        "Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modulesalwayslink directly to the wholeexports, rather than only doing so if theexportsis a function or primitive.",
                        "So, a default import of a true CJS module should work just like arequirecall. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpileexport default \"hello\"toexports.default = \"hello\"and have a default import ofthatmodule link toexports.default. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).",
                        "When we transpile an ES module to CJS, let’s add a special extra field to the output:tsexports.A= {};exports.B= {};exports.default=\"Hello, world!\";// Extra special flag!exports.__esModule=true;that we can check for when we transpile a default import:ts// import hello from \"./module\";const_mod=require(\"./module\");consthello=_mod.__esModule?_mod.default:_mod;"
                    ]
                },
                {
                    "type": "code",
                    "code": "tsexports.A= {};exports.B= {};exports.default=\"Hello, world!\";// Extra special flag!exports.__esModule=true;"
                },
                {
                    "type": "code",
                    "code": "ts// import hello from \"./module\";const_mod=require(\"./module\");consthello=_mod.__esModule?_mod.default:_mod;"
                },
                {
                    "type": "p",
                    "text": "The__esModuleflag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added theallowSyntheticDefaultImportsin 1.8 to allow the type checker to link default imports directly to theexports, rather than theexports.default, of any module types that lacked anexport defaultdeclaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” whereimport *was an error:"
                },
                {
                    "type": "code",
                    "code": "ts// Error:import*ashellofrom\"./exports-function\";// Old workaround:importhello=require(\"./exports-function\");// New way, with `allowSyntheticDefaultImports`:importhellofrom\"./exports-function\";"
                },
                {
                    "type": "p",
                    "text": "This was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:"
                },
                {
                    "type": "list",
                    "items": [
                        "Babel and others varied their default import behavior on whether an__esModuleproperty was found on the target module, butallowSyntheticDefaultImportsonly enabled afallbackbehavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an__esModuleflag butnodefault export. Transpilers and bundlers would still link a default import of such a module to itsexports.default, which would beundefined, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But withallowSyntheticDefaultImports, TypeScript would think a default import of such an import links to the wholeexportsobject, allowing named exports to be accessed as its properties.",
                        "allowSyntheticDefaultImportsdidn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:ts// @Filename: exportEqualsObject.d.tsdeclareconstobj:object;export=obj;// @Filename: main.tsimportobjDefaultfrom\"./exportEqualsObject\";import*asobjNamespacefrom\"./exportEqualsObject\";// This should be true at runtime, but TypeScript gives an error:objNamespace.default===objDefault;//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.",
                        "Most importantly,allowSyntheticDefaultImportsdid not change the JavaScript emitted bytsc. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting--module commonjswithtscand running in Node.js. If they encountered an error withimport *, it may have appeared as if enablingallowSyntheticDefaultImportswould fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node."
                    ]
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: exportEqualsObject.d.tsdeclareconstobj:object;export=obj;// @Filename: main.tsimportobjDefaultfrom\"./exportEqualsObject\";import*asobjNamespacefrom\"./exportEqualsObject\";// This should be true at runtime, but TypeScript gives an error:objNamespace.default===objDefault;//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'."
                },
                {
                    "type": "p",
                    "text": "TypeScript introduced theesModuleInteropflag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same__esModule-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper forimport *ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interop in Node.js"
                },
                {
                    "type": "p",
                    "text": "Node.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of theirexportsobject, allowing the entire module contents to be accessed with a default import from ESM:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: export.cjsmodule.exports= {hello:\"world\"};// @Filename: import.mjsimportgreetingfrom\"./export.cjs\";greeting.hello;// \"world\""
                },
                {
                    "type": "p",
                    "text": "That’s one win for seamless migration! Unfortunately, the similarities mostly end there."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "No__esModuledetection (the “double default” problem)"
                },
                {
                    "type": "p",
                    "text": "Node.js wasn’t able to respect the__esModulemarker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/dependency/index.jsexports.__esModule=true;exports.default=functiondoSomething() {/*...*/}// @Filename: transpile-vs-run-directly.{js/mjs}importdoSomethingfrom\"dependency\";// Works after transpilation, but not a function in Node.js ESM:doSomething();// Doesn't exist after trasnpilation, but works in Node.js ESM:doSomething.default();"
                },
                {
                    "type": "p",
                    "text": "While the transpiled default import only makes the synthetic default export if the target module lacks an__esModuleflag, Node.jsalwayssynthesizes a default export, creating a “double default” on the transpiled module."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unreliable named exports"
                },
                {
                    "type": "p",
                    "text": "In addition to making a CommonJS module’sexportsobject available as a default import, Node.js attempts to find properties ofexportsto make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js usessyntactic analysisto synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: named-exports.cjsexports.hello=\"world\";exports[\"worl\"+\"d\"] =\"hello\";// @Filename: transpile-vs-run-directly.{js/mjs}import{hello,world}from\"./named-exports.cjs\";// `hello` works, but `world` is missing in Node.js 💥importmodfrom\"./named-exports.cjs\";mod.world;// Accessing properties from the default always works ✅"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Cannotrequirea true ES module"
                },
                {
                    "type": "p",
                    "text": "True CommonJS modules canrequirean ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js,requirecrashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/dependency/index.jsexportfunctiondoSomething() {/* ... */}// @Filename: dependent.jsimport{doSomething}from\"dependency\";// ✅ Works if dependent and dependency are both transpiled// ✅ Works if dependent and dependency are both true ESM// ✅ Works if dependent is true ESM and dependency is transpiled// 💥 Crashes if dependent is transpiled and dependency is true ESM"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Different module resolution algorithms"
                },
                {
                    "type": "p",
                    "text": "Node.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolvingrequirecalls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: add.jsexportfunctionadd(a,b) {returna+b;}// @Filename: math.jsexport*from\"./add\";//            ^^^^^^^// Works when transpiled to CJS,// but would have to be \"./add.js\"// in Node.js ESM."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conclusions"
                },
                {
                    "type": "p",
                    "text": "Clearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Setting the rightmodulecompiler option is critical"
                },
                {
                    "type": "p",
                    "text": "Since interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of themodulecompiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unlessmoduleis set tonode16ornodenext.)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Applications with CommonJS code should always enableesModuleInterop"
                },
                {
                    "type": "p",
                    "text": "In a TypeScriptapplication(as opposed to a library that others may consume) wheretscis used to emit JavaScript files, whetheresModuleInteropis enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leavingesModuleInteropdisabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future."
                },
                {
                    "type": "p",
                    "text": "In an application that gets processed by a third-party transpiler or bundler, on the other hand, enablingesModuleInteropis more important. All major bundlers and transpilers use anesModuleInterop-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files thattscwould emit, so even if another tool is being used in place oftsc, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)"
                },
                {
                    "type": "p",
                    "text": "allowSyntheticDefaultImportswithoutesModuleInteropshould be avoided. It changes the compiler’s checking behavior without changing the code emitted bytsc, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced byesModuleInterop. Even iftscisn’t being used for emit, it’s better to enableesModuleInteropthanallowSyntheticDefaultImports."
                },
                {
                    "type": "p",
                    "text": "Some people object to the inclusion of the__importDefaultand__importStarhelper functions included intsc’s JavaScript output whenesModuleInteropis enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for__esModule, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited withesModuleInteropdisabled. First, theimportHelperscompiler option can be used to import the helper functions fromtslibrather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: node_modules/transpiled-dependency/index.jsexports.__esModule=true;exports.default=functiondoSomething() {/* ... */};exports.something=\"something\";// @Filename: node_modules/true-cjs-dependency/index.jsmodule.exports=functiondoSomethingElse() {/* ... */};// @Filename: src/sayHello.tsexportdefaultfunctionsayHello() {/* ... */}exportconsthello=\"hello\";// @Filename: src/main.tsimportdoSomethingfrom\"transpiled-dependency\";importdoSomethingElsefrom\"true-cjs-dependency\";importsayHellofrom\"./sayHello.js\";"
                },
                {
                    "type": "p",
                    "text": "Assume we’re compilingsrcto CommonJS for use in Node.js. WithoutallowSyntheticDefaultImportsoresModuleInterop, the import ofdoSomethingElsefrom\"true-cjs-dependency\"is an error, and the others are not. To fix the error without changing any compiler options, you could change the import toimport doSomethingElse = require(\"true-cjs-dependency\"). However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. WithesModuleInterop, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught."
                },
                {
                    "type": "p",
                    "text": "What would change if we decided to migratesrcto true ESM in Node.js (say, add\"type\": \"module\"to our root package.json)? The first import,doSomethingfrom\"transpiled-dependency\", would no longer be callable—it exhibits the “double default” problem, where we’d have to calldoSomething.default()rather thandoSomething(). (TypeScript understands and catches this under--module node16andnodenext.) But notably, thesecondimport ofdoSomethingElse, which neededesModuleInteropto work when compiling to CommonJS, works fine in true ESM."
                },
                {
                    "type": "p",
                    "text": "If there’s something to complain about here, it’s not whatesModuleInteropdoes with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is thatesModuleInteropseems to fail at giving us a seamless migration path for thefirstimport. But this problem was not introduced by enablingesModuleInterop; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract betweenmain.tsandsayHello.ts, because the CommonJS output ofsayHello.tslooks structurally identical totranspiled-dependency/index.js. IfesModuleInteropchanged the way the transpiled import ofdoSomethingworks to be identical to the way it would work in Node.js ESM, it would change the behavior of thesayHelloimport in the same way, making the input code violate ESM semantics (thus still preventing thesrcdirectory from being migrated to ESM without changes)."
                },
                {
                    "type": "p",
                    "text": "As we’ve seen, there is no seamless migration path from transpiled modules to true ESM. ButesModuleInteropis one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enablingverbatimModuleSyntaxis a better choice than disablingesModuleInterop.verbatimModuleSyntaxenforces that theimport mod = require(\"mod\")andexport = nssyntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Library code needs special considerations"
                },
                {
                    "type": "p",
                    "text": "Libraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS bytsc, is accessible in Node.js as the default property of a default import:"
                },
                {
                    "type": "code",
                    "code": "jsimportpkgfrom\"pkg\";pkg.default();"
                },
                {
                    "type": "p",
                    "text": "in most bundlers or transpiled ESM as the default import itself:"
                },
                {
                    "type": "code",
                    "code": "jsimportpkgfrom\"pkg\";pkg();"
                },
                {
                    "type": "p",
                    "text": "and in vanilla CommonJS as the default property of arequirecall:"
                },
                {
                    "type": "code",
                    "code": "jsconstpkg=require(\"pkg\");pkg.default();"
                },
                {
                    "type": "p",
                    "text": "Users will detect a misconfigured module smell if they have to access the.defaultproperty of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (.d.ts) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should useexport =for modules that have a single main export, or named exports for modules that have multiple exports:"
                },
                {
                    "type": "code",
                    "code": "diff- export default function doSomething() { /* ... */ }+ export = function doSomething() { /* ... */ }"
                },
                {
                    "type": "p",
                    "text": "Libraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully whenstrictNullChecksis disabled. If a library were to publish types like that, it would force all their users to disablestrictNullCheckstoo.esModuleInteropcan allow type declarations to contain similarly “infectious” default imports:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: /node_modules/dependency/index.d.tsimportexpressfrom\"express\";declarefunctiondoSomething(req:express.Request):any;export=doSomething;"
                },
                {
                    "type": "p",
                    "text": "Suppose this default importonlyworks withesModuleInteropenabled, and causes an error when a user without that option references this file. The user shouldprobablyenableesModuleInteropanyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:"
                },
                {
                    "type": "code",
                    "code": "tsimportexpress=require(\"express\");// ..."
                },
                {
                    "type": "p",
                    "text": "Examples like this have led to conventional wisdom that says libraries shouldnotenableesModuleInterop. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentiallyintroducingan error, when enablingesModuleInterop. So whether libraries compile with or withoutesModuleInterop, they run the risk of writing syntax that makes their choice infectious."
                },
                {
                    "type": "p",
                    "text": "Library authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But usingverbatimModuleSyntaxcompletely sidesteps the issue withesModuleInteropby forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, sinceesModuleInteroponly affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html",
            "title": "TypeScript: Documentation - Modules - Choosing Compiler Options",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules - Choosing Compiler Options"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "I’m writing an app"
                },
                {
                    "type": "p",
                    "text": "A single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected withproject references. Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “I’m writing a library” section."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m using a bundler"
                },
                {
                    "type": "p",
                    "text": "In addition to adopting the following settings, it’s also recommendednotto set{ \"type\": \"module\" }or use.mtsfiles in bundler projects for now.Some bundlersadopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with\"moduleResolution\": \"bundler\". Seeissue #54102for more information."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Required\"module\":\"esnext\",\"moduleResolution\":\"bundler\",\"esModuleInterop\":true,// Consult your bundler’s documentation\"customConditions\": [\"module\"],// Recommended\"noEmit\":true,// or `emitDeclarationOnly`\"allowImportingTsExtensions\":true,\"allowArbitraryExtensions\":true,\"verbatimModuleSyntax\":true,// or `isolatedModules`}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m compiling and running the outputs in Node.js"
                },
                {
                    "type": "p",
                    "text": "Remember to set\"type\": \"module\"or use.mtsfiles if you intend to emit ES modules."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Required\"module\":\"nodenext\",// Implied by `\"module\": \"nodenext\"`:// \"moduleResolution\": \"nodenext\",// \"esModuleInterop\": true,// \"target\": \"esnext\",// Recommended\"verbatimModuleSyntax\":true,}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m using ts-node"
                },
                {
                    "type": "p",
                    "text": "ts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used tocompile and run the JS outputs in Node.js. Refer tots-node documentationfor more details."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m using tsx"
                },
                {
                    "type": "p",
                    "text": "Whereas ts-node makes minimal modifications to Node.js’s module system by default,tsxbehaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as youwould for a bundler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m writing ES modules for the browser, with no bundler or module compiler"
                },
                {
                    "type": "p",
                    "text": "TypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of thenodenextESM module resolution algorithm andpathsas a substitute for URL and import map support."
                },
                {
                    "type": "code",
                    "code": "json// tsconfig.json{\"compilerOptions\": {// This is not a complete template; it only// shows relevant module-related settings.// Be sure to set other important options// like `target`, `lib`, and `strict`.// Combined with `\"type\": \"module\"` in a local package.json,// this enforces including file extensions on relative path imports.\"module\":\"nodenext\",\"paths\": {// Point TS to local types for remote URLs:\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],// Optional: point bare specifier imports to an empty file// to prohibit importing from node_modules specifiers not listed here:\"*\": [\"./empty-file.ts\"]}}}"
                },
                {
                    "type": "p",
                    "text": "This setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node_modules:"
                },
                {
                    "type": "code",
                    "code": "tsimport{}from\"lodash\";//             ^^^^^^^^// File '/project/empty-file.ts' is not a module. ts(2306)"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can useimport mapsto explicitly map a list of bare specifiers to URLs in the browser, while relying onnodenext’s default node_modules lookups, or onpaths, to direct TypeScript to type declaration files for those bare specifier imports:"
                },
                {
                    "type": "code",
                    "code": "html<scripttype=\"importmap\">{\"imports\": {\"lodash\": \"https://esm.sh/lodash@4.17.21\"}}</script>"
                },
                {
                    "type": "code",
                    "code": "tsimport{}from\"lodash\";// Browser: https://esm.sh/lodash@4.17.21// TypeScript: ./node_modules/@types/lodash/index.d.ts"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "I’m writing a library"
                },
                {
                    "type": "p",
                    "text": "Choosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code underall possiblelibrary consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"node16\",\"target\":\"es2020\",// set to the *lowest* target you support\"strict\":true,\"verbatimModuleSyntax\":true,\"declaration\":true,\"sourceMap\":true,\"declarationMap\":true}}"
                },
                {
                    "type": "p",
                    "text": "Let’s examine why we picked each of these settings:"
                },
                {
                    "type": "list",
                    "items": [
                        "module: \"node16\". When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set\"type\": \"module\"in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with\"moduleResolution\": \"bundler\":tsexport*from\"./utils\";Assuming./utils.ts(or./utils/index.ts) exists, a bundler would be fine with this code, so\"moduleResolution\": \"bundler\"doesn’t complain. Compiled with\"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.jsDid you mean to import ./utils.js?On the other hand, if we had written:tsexport*from\"./utils.js\";This would produce output that works both in Node.jsandin bundlers.In short,\"moduleResolution\": \"bundler\"is infectious, allowing code that only works in bundlers to be produced. Likewise,\"moduleResolution\": \"nodenext\"is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.",
                        "target: \"es2020\". Setting this value to thelowestECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Sincetargetalso implies a corresponding value forlib, this also ensures you don’t access globals that may not be available in older environments.",
                        "strict: true. Without this, you may write type-level code that ends up in your output.d.tsfiles and errors when a consumer compiles withstrictenabled. For example, thisextendsclause:tsexportinterfaceSuper{foo:string;}exportinterfaceSubextendsSuper{foo:string|undefined;}is only an error understrictNullChecks. On the other hand, it’s very difficult to write code that errors only whenstrictisdisabled, so it’s highly recommended for libraries to compile withstrict.",
                        "verbatimModuleSyntax: true. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value ofesModuleInteroporallowSyntheticDefaultImports. Previously, it was often suggested that libraries compile withoutesModuleInterop, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only workwithoutesModuleInterop, so neither value for the setting guarantees portability for libraries.verbatimModuleSyntaxdoes provide such a guarantee.1Second, it prevents the use ofexport defaultin modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix onESM/CJS Interopfor more details.",
                        "declaration: trueemits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.",
                        "sourceMap: trueanddeclarationMap: trueemit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (.ts) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them."
                    ]
                },
                {
                    "type": "p",
                    "text": "module: \"node16\". When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set\"type\": \"module\"in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with\"moduleResolution\": \"bundler\":"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils\";"
                },
                {
                    "type": "p",
                    "text": "Assuming./utils.ts(or./utils/index.ts) exists, a bundler would be fine with this code, so\"moduleResolution\": \"bundler\"doesn’t complain. Compiled with\"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:"
                },
                {
                    "type": "code",
                    "code": "Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.jsDid you mean to import ./utils.js?"
                },
                {
                    "type": "p",
                    "text": "On the other hand, if we had written:"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils.js\";"
                },
                {
                    "type": "p",
                    "text": "This would produce output that works both in Node.jsandin bundlers."
                },
                {
                    "type": "p",
                    "text": "In short,\"moduleResolution\": \"bundler\"is infectious, allowing code that only works in bundlers to be produced. Likewise,\"moduleResolution\": \"nodenext\"is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers."
                },
                {
                    "type": "p",
                    "text": "target: \"es2020\". Setting this value to thelowestECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Sincetargetalso implies a corresponding value forlib, this also ensures you don’t access globals that may not be available in older environments."
                },
                {
                    "type": "p",
                    "text": "strict: true. Without this, you may write type-level code that ends up in your output.d.tsfiles and errors when a consumer compiles withstrictenabled. For example, thisextendsclause:"
                },
                {
                    "type": "code",
                    "code": "tsexportinterfaceSuper{foo:string;}exportinterfaceSubextendsSuper{foo:string|undefined;}"
                },
                {
                    "type": "p",
                    "text": "is only an error understrictNullChecks. On the other hand, it’s very difficult to write code that errors only whenstrictisdisabled, so it’s highly recommended for libraries to compile withstrict."
                },
                {
                    "type": "p",
                    "text": "verbatimModuleSyntax: true. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value ofesModuleInteroporallowSyntheticDefaultImports. Previously, it was often suggested that libraries compile withoutesModuleInterop, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only workwithoutesModuleInterop, so neither value for the setting guarantees portability for libraries.verbatimModuleSyntaxdoes provide such a guarantee.1Second, it prevents the use ofexport defaultin modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix onESM/CJS Interopfor more details."
                },
                {
                    "type": "p",
                    "text": "declaration: trueemits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information."
                },
                {
                    "type": "p",
                    "text": "sourceMap: trueanddeclarationMap: trueemit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (.ts) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Considerations for bundling libraries"
                },
                {
                    "type": "p",
                    "text": "If you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use\"module\": \"esnext\"and\"moduleResolution\": \"bundler\", but only with two caveats:"
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with\"moduleResolution\": \"bundler\"and externalized imports with\"moduleResolution\": \"nodenext\"(or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using\"moduleResolution\": \"bundler\"may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using\"moduleResolution\": \"nodenext\"may impose overly strict requirements on bundled imports.",
                        "You must ensure that your declaration files get bundled as well. Recall thefirst rule of declaration files: every declaration file represents exactly one JavaScript file. If you use\"moduleResolution\": \"bundler\"and use a bundler to emit an ESM bundle while usingtscto emit many individual declaration files, your declaration files may cause errors when consumed under\"module\": \"nodenext\". For example, an input file like:tsimport{Component}from\"./extensionless-relative-import\";will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencingComponentwithany, assuming the dependency will crash at runtime.If your TypeScript bundler does not produce bundled declaration files, use\"moduleResolution\": \"nodenext\"to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library."
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with\"moduleResolution\": \"bundler\"and externalized imports with\"moduleResolution\": \"nodenext\"(or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using\"moduleResolution\": \"bundler\"may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using\"moduleResolution\": \"nodenext\"may impose overly strict requirements on bundled imports."
                },
                {
                    "type": "p",
                    "text": "You must ensure that your declaration files get bundled as well. Recall thefirst rule of declaration files: every declaration file represents exactly one JavaScript file. If you use\"moduleResolution\": \"bundler\"and use a bundler to emit an ESM bundle while usingtscto emit many individual declaration files, your declaration files may cause errors when consumed under\"module\": \"nodenext\". For example, an input file like:"
                },
                {
                    "type": "code",
                    "code": "tsimport{Component}from\"./extensionless-relative-import\";"
                },
                {
                    "type": "p",
                    "text": "will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencingComponentwithany, assuming the dependency will crash at runtime."
                },
                {
                    "type": "p",
                    "text": "If your TypeScript bundler does not produce bundled declaration files, use\"moduleResolution\": \"nodenext\"to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Notes on dual-emit solutions"
                },
                {
                    "type": "p",
                    "text": "A single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even iftscisn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination withtsctype checking as long astsccan be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests andstatic analysisagainst all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed."
                },
                {
                    "type": "list",
                    "items": [
                        "verbatimModuleSyntaxcan only work when the JS emitter emits the same module kind astscwould given the tsconfig.json, source file extension, and package.json\"type\". The option works by enforcing that theimport/requirewritten is identical to theimport/requireemitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible withverbatimModuleSyntax, since its whole purpose is to prevent you from writingimportanywhere that arequirewould be emitted.verbatimModuleSyntaxcan also be defeated by configuring a third-party emitter to emit a different module kind thantscwould—for example, by setting\"module\": \"esnext\"in tsconfig.json while configuring Babel to emit CommonJS.↩"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/introduction.html",
            "title": "TypeScript: Documentation - Modules - Introduction",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules - Introduction"
                },
                {
                    "type": "p",
                    "text": "This document is divided into four sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "The first section develops thetheorybehind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.",
                        "Theguidesshow how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.",
                        "Thereferencesection provides a more detailed look at the syntaxes and configurations presented in previous sections.",
                        "Theappendicescover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/reference.html",
            "title": "TypeScript: Documentation - Modules - Reference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules - Reference"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Module syntax"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler recognizes standardECMAScript module syntaxin TypeScript and JavaScript files and many forms ofCommonJS syntaxin JavaScript files."
                },
                {
                    "type": "p",
                    "text": "There are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Importing and exporting TypeScript-specific declarations"
                },
                {
                    "type": "p",
                    "text": "Type aliases, interfaces, enums, and namespaces can be exported from a module with anexportmodifier, like any standard JavaScript declaration:"
                },
                {
                    "type": "code",
                    "code": "ts// Standard JavaScript syntax...exportfunctionf() {}// ...extended to type declarationsexporttypeSomeType=/* ... */;exportinterfaceSomeInterface{/* ... */}"
                },
                {
                    "type": "p",
                    "text": "They can also be referenced in named exports, even alongside references to standard JavaScript declarations:"
                },
                {
                    "type": "code",
                    "code": "tsexport{f,SomeType,SomeInterface};"
                },
                {
                    "type": "p",
                    "text": "Exported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:"
                },
                {
                    "type": "code",
                    "code": "tsimport{f,SomeType,SomeInterface}from\"./module.js\";"
                },
                {
                    "type": "p",
                    "text": "When using namespace imports or exports, exported types are available on the namespace when referenced in a type position:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmodfrom\"./module.js\";mod.f();mod.SomeType;// Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'letx:mod.SomeType;// Ok"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type-only imports and exports"
                },
                {
                    "type": "p",
                    "text": "When emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written withimport type, export declarations written withexport type { ... }, and import or export specifiers prefixed with thetypekeyword are all guaranteed to be elided from the output JavaScript."
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimport{f,typeSomeInterface}from\"./module.js\";importtype{SomeType}from\"./module.js\";classCimplementsSomeInterface{constructor(p:SomeType) {f();}}exporttype{C};// @Filename: main.jsimport{f}from\"./module.js\";classC{constructor(p) {f();}}"
                },
                {
                    "type": "p",
                    "text": "Even values can be imported withimport type, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:"
                },
                {
                    "type": "code",
                    "code": "tsimporttype{f}from\"./module.js\";f();// 'f' cannot be used as a value because it was imported using 'import type'letotherFunction:typeoff= ()=>{};// Ok"
                },
                {
                    "type": "p",
                    "text": "A type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whethertypeapplies to the default import or to the entire import declaration. Instead, split the import declaration into two, or usedefaultas a named binding:"
                },
                {
                    "type": "code",
                    "code": "tsimporttypefs, {BigIntOptions}from\"fs\";//          ^^^^^^^^^^^^^^^^^^^^^// Error: A type-only import can specify a default import or named bindings, but not both.importtype{defaultasfs,BigIntOptions}from\"fs\";// Ok"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "import()types"
                },
                {
                    "type": "p",
                    "text": "TypeScript provides a type syntax similar to JavaScript’s dynamicimportfor referencing the type of a module without writing an import declaration:"
                },
                {
                    "type": "code",
                    "code": "ts// Access an exported type:typeWriteFileOptions=import(\"fs\").WriteFileOptions;// Access the type of an exported value:typeWriteFileFunction=typeofimport(\"fs\").writeFile;"
                },
                {
                    "type": "p",
                    "text": "This is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:"
                },
                {
                    "type": "code",
                    "code": "ts/**@type{import(\"webpack\").Configuration}*/module.exports= {// ...}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "export =andimport = require()"
                },
                {
                    "type": "p",
                    "text": "When emitting CommonJS modules, TypeScript files can use a direct analog ofmodule.exports = ...andconst mod = require(\"...\")JavaScript syntax:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportfs=require(\"fs\");export=fs.readFileSync(\"...\");// @Filename: main.js\"use strict\";constfs=require(\"fs\");module.exports=fs.readFileSync(\"...\");"
                },
                {
                    "type": "p",
                    "text": "This syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsinterfaceOptions{/* ... */}module.exports=Options;// Error: 'Options' only refers to a type, but is being used as a value here.export=Options;// Ok// @Filename: b.tsconstOptions=require(\"./a\");constoptions:Options= {/* ... */};// Error: 'Options' refers to a value, but is being used as a type here.// @Filename: c.tsimportOptions=require(\"./a\");constoptions:Options= {/* ... */};// Ok"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Ambient modules"
                },
                {
                    "type": "p",
                    "text": "TypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. Theseambient modulesusually represent runtime-provided modules, like\"fs\"or\"path\"in Node.js:"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"path\"{exportfunctionnormalize(p:string):string;exportfunctionjoin(...paths:any[]):string;exportvarsep:string;}"
                },
                {
                    "type": "p",
                    "text": "Once an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:"
                },
                {
                    "type": "code",
                    "code": "ts// 👇 Ensure the ambient module is loaded -//    may be unnecessary if path.d.ts is included//    by the project tsconfig.json somehow.///<referencepath=\"path.d.ts\"/>import{normalize,join}from\"path\";"
                },
                {
                    "type": "p",
                    "text": "Ambient module declarations are easy to confuse withmodule augmentationssince they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-levelimportorexportstatement (or is affected by--moduleDetection forceorauto):"
                },
                {
                    "type": "code",
                    "code": "ts// Not an ambient module declaration anymore!export{};declaremodule\"path\"{exportfunctionnormalize(p:string):string;exportfunctionjoin(...paths:any[]):string;exportvarsep:string;}"
                },
                {
                    "type": "p",
                    "text": "Ambient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"m\"{// Moving this outside \"m\" would totally change the meaning of the file!import{SomeType}from\"other\";exportfunctionf():SomeType;}"
                },
                {
                    "type": "p",
                    "text": "Apatternambient module contains a single*wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:"
                },
                {
                    "type": "code",
                    "code": "tsdeclaremodule\"*.html\"{constcontent:string;exportdefaultcontent;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Themodulecompiler option"
                },
                {
                    "type": "p",
                    "text": "This section discusses the details of eachmodulecompiler option value. See theModule output formattheory section for more background on what the option is and how it fits into the overall compilation process. In brief, themodulecompiler option was historically only used to control the output module format of emitted JavaScript files. The more recentnode16andnodenextvalues, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "node16,nodenext"
                },
                {
                    "type": "p",
                    "text": "Node.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate.node16andnodenextdescribe the full range of behavior for Node.js’s dual-format module system, andemit files in either CommonJS or ESM format. This is different from every othermoduleoption, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime."
                },
                {
                    "type": "p",
                    "text": "A common misconception is thatnode16andnodenextonly emit ES modules. In reality,node16andnodenextdescribe versions of Node.js thatsupportES modules, not just projects thatuseES modules. Both ESM and CommonJS emit are supported, based on thedetected module formatof each file. Becausenode16andnodenextare the onlymoduleoptions that reflect the complexities of Node.js’s dual module system, they are theonly correctmoduleoptionsfor all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not."
                },
                {
                    "type": "p",
                    "text": "node16andnodenextare currently identical, with the exception that theyimply differenttargetoption values. If Node.js makes significant changes to its module system in the future,node16will be frozen whilenodenextwill be updated to reflect the new behavior."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Module format detection"
                },
                {
                    "type": "list",
                    "items": [
                        ".mts/.mjs/.d.mtsfiles are always ES modules.",
                        ".cts/.cjs/.d.ctsfiles are always CommonJS modules.",
                        ".ts/.tsx/.js/.jsx/.d.tsfiles are ES modules if the nearest ancestor package.json file contains\"type\": \"module\", otherwise CommonJS modules."
                    ]
                },
                {
                    "type": "p",
                    "text": "The detected module format of input.ts/.tsx/.mts/.ctsfiles determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of.tsfiles will emit all CommonJS modules by default under--module nodenext, and can be made to emit all ES modules by adding\"type\": \"module\"to the project package.json."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Interoperability rules"
                },
                {
                    "type": "list",
                    "items": [
                        "When an ES module references a CommonJS module:Themodule.exportsof the CommonJS module is available as a default import to the ES module.Properties (other thandefault) of the CommonJS module’smodule.exportsmay or may not be available as named imports to the ES module. Node.js attempts to make them available viastatic analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See#54018for more details.",
                        "Themodule.exportsof the CommonJS module is available as a default import to the ES module.",
                        "Properties (other thandefault) of the CommonJS module’smodule.exportsmay or may not be available as named imports to the ES module. Node.js attempts to make them available viastatic analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See#54018for more details.",
                        "When a CommonJS module references an ES module:requirecannot reference an ES module. For TypeScript, this includesimportstatements in files that aredetectedto be CommonJS modules, since thoseimportstatements will be transformed torequirecalls in the emitted JavaScript.A dynamicimport()call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get fromimport * as ns from \"./module.js\"from another ES module).",
                        "requirecannot reference an ES module. For TypeScript, this includesimportstatements in files that aredetectedto be CommonJS modules, since thoseimportstatements will be transformed torequirecalls in the emitted JavaScript.",
                        "A dynamicimport()call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get fromimport * as ns from \"./module.js\"from another ES module)."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Themodule.exportsof the CommonJS module is available as a default import to the ES module.",
                        "Properties (other thandefault) of the CommonJS module’smodule.exportsmay or may not be available as named imports to the ES module. Node.js attempts to make them available viastatic analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See#54018for more details."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "requirecannot reference an ES module. For TypeScript, this includesimportstatements in files that aredetectedto be CommonJS modules, since thoseimportstatements will be transformed torequirecalls in the emitted JavaScript.",
                        "A dynamicimport()call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get fromimport * as ns from \"./module.js\"from another ES module)."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Emit"
                },
                {
                    "type": "p",
                    "text": "The emit format of each file is determined by thedetected module formatof each file. ESM emit is similar to--module esnext, but has a special transformation forimport x = require(\"...\"), which is not allowed in--module esnext:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx=require(\"mod\");"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsimport{createRequireas_createRequire}from\"module\";const__require=_createRequire(import.meta.url);constx=__require(\"mod\");"
                },
                {
                    "type": "p",
                    "text": "CommonJS emit is similar to--module commonjs, but dynamicimport()calls are not transformed. Emit here is shown withesModuleInteropenabled:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportfsfrom\"fs\";// transformedconstdynamic=import(\"mod\");// not transformed"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";var__importDefault= (this&&this.__importDefault) ||function(mod) {return(mod&&mod.__esModule) ?mod: {\"default\":mod};};Object.defineProperty(exports,\"__esModule\", {value:true});constfs_1=__importDefault(require(\"fs\"));// transformedconstdynamic=import(\"mod\");// not transformed"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Implied and enforced options"
                },
                {
                    "type": "list",
                    "items": [
                        "--module nodenextornode16implies and enforces themoduleResolutionwith the same name.",
                        "--module nodenextimplies--target esnext.",
                        "--module node16implies--target es2022.",
                        "--module nodenextornode16implies--esModuleInterop."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "node16andnodenextare the only correctmoduleoptions for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.",
                        "node16andnodenextemit files in either CommonJS or ESM format, based on thedetected module formatof each file.",
                        "Node.js’s interoperability rules between ESM and CJS are reflected in type checking.",
                        "ESM emit transformsimport x = require(\"...\")to arequirecall constructed from acreateRequireimport.",
                        "CommonJS emit leaves dynamicimport()calls untransformed, so CommonJS modules can asynchronously import ES modules."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preserve"
                },
                {
                    "type": "p",
                    "text": "In--module preserve(addedin TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-styleimport x = require(\"...\")andexport = ...statements are emitted as CommonJSrequireandmodule.exports. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file)."
                },
                {
                    "type": "p",
                    "text": "While it’s rare to need to mix imports and require calls in the same file, thismodulemode best reflects the capabilities of most modern bundlers, as well as the Bun runtime."
                },
                {
                    "type": "p",
                    "text": "Why care about TypeScript’smoduleemit with a bundler or with Bun, where you’re likely also settingnoEmit? TypeScript’s type checking and module resolution behavior are affected by the module format that itwouldemit. Settingmodulegives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See--moduleResolution bundlerfor more discussion."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "code",
                    "code": "tsimportx, {y,z}from\"mod\";importmod=require(\"mod\");constdynamic=import(\"mod\");exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "jsimportx, {y,z}from\"mod\";constmod=require(\"mod\");constdynamic=import(\"mod\");exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Implied and enforced options"
                },
                {
                    "type": "list",
                    "items": [
                        "--module preserveimplies--moduleResolution bundler.",
                        "--module preserveimplies--esModuleInterop."
                    ]
                },
                {
                    "type": "p",
                    "text": "The option--esModuleInteropis enabled by default in--module preserveonly for itstype checkingbehavior. Since imports never transform into require calls in--module preserve,--esModuleInteropdoes not affect the emitted JavaScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "es2015,es2020,es2022,esnext"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "Useesnextwith--moduleResolution bundlerfor bundlers, Bun, and tsx.",
                        "Do not use for Node.js. Usenode16ornodenextwith\"type\": \"module\"in package.json to emit ES modules for Node.js.",
                        "import mod = require(\"mod\")is not allowed in non-declaration files.",
                        "es2020adds support forimport.metaproperties.",
                        "es2022adds support for top-levelawait.",
                        "esnextis a moving target that may include support for Stage 3 proposals to ECMAScript modules.",
                        "Emitted files are ES modules, but dependencies may be any format."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "commonjs"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "You probably shouldn’t use this. Usenode16ornodenextto emit CommonJS modules for Node.js.",
                        "Emitted files are CommonJS modules, but dependencies may be any format.",
                        "Dynamicimport()is transformed to a Promise of arequire()call.",
                        "esModuleInteropaffects the output code for default and namespace imports."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "p",
                    "text": "Output is shown withesModuleInterop: false."
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constmod_1=require(\"mod\");constmod=require(\"mod\");constdynamic=Promise.resolve().then(()=>require(\"mod\"));console.log(mod_1.default,mod_1.y,mod_1.z,mod);exports.e1=0;exports.default=\"default export\";"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportmod=require(\"mod\");console.log(mod);export= {p1:true,p2:false};"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js\"use strict\";constmod=require(\"mod\");console.log(mod);module.exports= {p1:true,p2:false};"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "system"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for use with theSystemJS module loader."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsSystem.register([\"mod\"],function(exports_1,context_1) {\"use strict\";varmod_1,mod,dynamic,e1;var__moduleName=context_1&&context_1.id;return{setters:[function(mod_1_1) {mod_1=mod_1_1;mod=mod_1_1;}],execute:function() {dynamic=context_1.import(\"mod\");console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports_1(\"e1\",e1=0);exports_1(\"default\",\"default export\");}};});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "amd"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for AMD loaders like RequireJS.",
                        "You probably shouldn’t use this. Use a bundler instead.",
                        "Emitted files are AMD modules, but dependencies may be any format.",
                        "SupportsoutFile."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.jsdefine([\"require\",\"exports\",\"mod\",\"mod\"],function(require,exports,mod_1,mod) {\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constdynamic=newPromise((resolve_1,reject_1)=>{require([\"mod\"],resolve_1,reject_1); });console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports.e1=0;exports.default=\"default export\";});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "umd"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Summary"
                },
                {
                    "type": "list",
                    "items": [
                        "Designed for AMD or CommonJS loaders.",
                        "Does not expose a global variable like most other UMD wrappers.",
                        "You probably shouldn’t use this. Use a bundler instead.",
                        "Emitted files are UMD modules, but dependencies may be any format."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: main.tsimportx, {y,z}from\"mod\";import*asmodfrom\"mod\";constdynamic=import(\"mod\");console.log(x,y,z,mod,dynamic);exportconste1=0;exportdefault\"default export\";"
                },
                {
                    "type": "code",
                    "code": "js// @Filename: main.js(function(factory) {if(typeofmodule===\"object\"&&typeofmodule.exports===\"object\") {varv=factory(require,exports);if(v!==undefined)module.exports=v;}elseif(typeofdefine===\"function\"&&define.amd) {define([\"require\",\"exports\",\"mod\",\"mod\"],factory);}})(function(require,exports) {\"use strict\";var__syncRequire=typeofmodule===\"object\"&&typeofmodule.exports===\"object\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.e1=void0;constmod_1=require(\"mod\");constmod=require(\"mod\");constdynamic=__syncRequire?Promise.resolve().then(()=>require(\"mod\")) :newPromise((resolve_1,reject_1)=>{require([\"mod\"],resolve_1,reject_1); });console.log(mod_1.default,mod_1.y,mod_1.z,mod,dynamic);exports.e1=0;exports.default=\"default export\";});"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ThemoduleResolutioncompiler option"
                },
                {
                    "type": "p",
                    "text": "This section describes module resolution features and processes shared by multiplemoduleResolutionmodes, then specifies the details of each mode. See theModule resolutiontheory section for more background on what the option is and how it fits into the overall compilation process. In brief,moduleResolutioncontrols how TypeScript resolvesmodule specifiers(string literals inimport/export/requirestatements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Common features and processes"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "File extension substitution"
                },
                {
                    "type": "p",
                    "text": "TypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to themoduleResolutionalgorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension."
                },
                {
                    "type": "p",
                    "text": "Note that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a.tsor.d.tsfile even if the module specifier explicitly uses a.jsfile extension:"
                },
                {
                    "type": "code",
                    "code": "tsimportxfrom\"./mod.js\";// Runtime lookup: \"./mod.js\"// TypeScript lookup #1: \"./mod.ts\"// TypeScript lookup #2: \"./mod.d.ts\"// TypeScript lookup #3: \"./mod.js\""
                },
                {
                    "type": "p",
                    "text": "SeeTypeScript imitates the host’s module resolution, but with typesfor an explanation of why TypeScript’s module resolution works this way."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Relative file path resolution"
                },
                {
                    "type": "p",
                    "text": "All of TypeScript’smoduleResolutionalgorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to therules above):"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsexport{};// @Filename: b.tsimport{}from\"./a.js\";// ✅ Works in every `moduleResolution`"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Extensionless relative paths"
                },
                {
                    "type": "p",
                    "text": "In some cases, the runtime or bundler allows omitting a.jsfile extension from a relative path. TypeScript supports this behavior where themoduleResolutionsetting and the context indicate that the runtime or bundler supports it:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: a.tsexport{};// @Filename: b.tsimport{}from\"./a\";"
                },
                {
                    "type": "p",
                    "text": "If TypeScript determines that the runtime will perform a lookup for./a.jsgiven the module specifier\"./a\", then./a.jswill undergoextension substitution, and resolve to the filea.tsin this example."
                },
                {
                    "type": "p",
                    "text": "Extensionless relative paths are not supported inimportpaths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a.mjs/.mtsor.cjs/.ctsfile extension, even though some runtimes and bundlers do."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Directory modules (index file resolution)"
                },
                {
                    "type": "p",
                    "text": "In some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for anindex.jsfile in a directory. TypeScript supports this behavior where themoduleResolutionsetting and the context indicate that the runtime or bundler supports it:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: dir/index.tsexport{};// @Filename: b.tsimport{}from\"./dir\";"
                },
                {
                    "type": "p",
                    "text": "If TypeScript determines that the runtime will perform a lookup for./dir/index.jsgiven the module specifier\"./dir\", then./dir/index.jswill undergoextension substitution, and resolve to the filedir/index.tsin this example."
                },
                {
                    "type": "p",
                    "text": "Directory modules may also contain a package.json file, where resolution of the\"main\"and\"types\"fields are supported, and take precedence overindex.jslookups. The\"typesVersions\"field is also supported in directory modules."
                },
                {
                    "type": "p",
                    "text": "Note that directory modules are not the same asnode_modulespackagesand only support a subset of the features available to packages, and are not supported at all in some contexts.  Node.js considers them alegacy feature."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "paths"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Overview"
                },
                {
                    "type": "p",
                    "text": "TypeScript offers a way to override the compiler’s module resolution for bare specifiers with thepathscompiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with--experimental-network-imports, you can manually specify a local type definition file for a specifichttps://import:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"nodenext\",\"paths\": {\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]}}}"
                },
                {
                    "type": "code",
                    "code": "ts// Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entryimport{add}from\"https://esm.sh/lodash@4.17.21\";"
                },
                {
                    "type": "p",
                    "text": "It’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases withpaths:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"esnext\",\"moduleResolution\":\"bundler\",\"paths\": {\"@app/*\": [\"./src/*\"]}}}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "pathsdoes not affect emit"
                },
                {
                    "type": "p",
                    "text": "Thepathsoption doesnotchange the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"module\":\"nodenext\",\"paths\": {\"node-has-no-idea-what-this-is\": [\"./oops.ts\"]}}}"
                },
                {
                    "type": "code",
                    "code": "ts// TypeScript: ✅// Node.js: 💥import{}from\"node-has-no-idea-what-this-is\";"
                },
                {
                    "type": "p",
                    "text": "While it’s ok for bundled apps to set uppaths, it’s very important that published libraries donot, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can considerpackage.json\"imports\"as a standard replacement for conveniencepathsaliases."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "pathsshould not point to monorepo packages or node_modules packages"
                },
                {
                    "type": "p",
                    "text": "While module specifiers that matchpathsaliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen fornode_modulespackage lookups, including package.json\"exports\"field support, do not take effect when apathsalias is matched. This can lead to surprising behavior ifpathsis used to point to anode_modulespackage:"
                },
                {
                    "type": "code",
                    "code": "ts{\"compilerOptions\": {\"paths\":{\"pkg\":[\"./node_modules/pkg/dist/index.d.ts\"],\"pkg/*\":[\"./node_modules/pkg/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "While this configuration may simulate some of the behavior of package resolution, it overrides anymain,types,exports, andtypesVersionsthe package’spackage.jsonfile defines, and imports from the package may fail at runtime."
                },
                {
                    "type": "p",
                    "text": "The same caveat applies to packages referencing each other in a monorepo. Instead of usingpathsto make TypeScript artificially resolve\"@my-scope/lib\"to a sibling package, it’s best to use workspaces vianpm,yarn, orpnpmto symlink your packages intonode_modules, so both TypeScript and the runtime or bundler perform realnode_modulespackage lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other vianode_modulespackage lookups once installed by users, and using workspaces allows you to test that behavior during local development."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Relationship tobaseUrl"
                },
                {
                    "type": "p",
                    "text": "WhenbaseUrlis provided, the values in eachpathsarray are resolved relative to thebaseUrl. Otherwise, they are resolved relative to thetsconfig.jsonfile that defines them."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Wildcard substitutions"
                },
                {
                    "type": "p",
                    "text": "pathspatterns can contain a single*wildcard, which matches any string. The*token can then be used in the file path values to substitute the matched string:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"@app/*\": [\"./src/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "When resolving an import of\"@app/components/Button\", TypeScript will match on@app/*, binding*tocomponents/Button, and then attempt to resolve the path./src/components/Buttonrelative to thetsconfig.jsonpath. The remainder of this lookup will follow the same rules as any otherrelative path lookupaccording to themoduleResolutionsetting."
                },
                {
                    "type": "p",
                    "text": "When multiple patterns match a module specifier, the pattern with the longest matching prefix before any*token is used:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"*\": [\"./src/foo/one.ts\"],\"foo/*\": [\"./src/foo/two.ts\"],\"foo/bar\": [\"./src/foo/three.ts\"]}}}"
                },
                {
                    "type": "p",
                    "text": "When resolving an import of\"foo/bar\", all threepathspatterns match, but the last is used because\"foo/bar\"is longer than\"foo/\"and\"\"."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Fallbacks"
                },
                {
                    "type": "p",
                    "text": "Multiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached."
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"paths\": {\"*\": [\"./vendor/*\",\"./types/*\"]}}}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "baseUrl"
                },
                {
                    "type": "p",
                    "text": "baseUrlwas designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t usebaseUrl. Since TypeScript 4.1,baseUrlis no longer required to usepathsand should not be used just to set the directorypathsvalues are resolved from."
                },
                {
                    "type": "p",
                    "text": "ThebaseUrlcompiler option can be combined with anymoduleResolutionmode and specifies a directory that bare specifiers (module specifiers that don’t begin with./,../, or/) are resolved from.baseUrlhas a higher precedence thannode_modulespackage lookupsinmoduleResolutionmodes that support them."
                },
                {
                    "type": "p",
                    "text": "When performing abaseUrllookup, resolution proceeds with the same rules as other relative path resolutions. For example, in amoduleResolutionmode that supportsextensionless relative pathsa module specifier\"some-file\"may resolve to/src/some-file.tsifbaseUrlis set to/src."
                },
                {
                    "type": "p",
                    "text": "Resolution of relative module specifiers are never affected by thebaseUrloption."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "node_modulespackage lookups"
                },
                {
                    "type": "p",
                    "text": "Node.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up innode_modulessubdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’smoduleResolutionoptions exceptclassicsupportnode_moduleslookups. (classicsupports lookups innode_modules/@typeswhen other means of resolution fail, but never looks for packages innode_modulesdirectly.) Everynode_modulespackage lookup has the following structure (beginning after higher precedence bare specifier rules, likepaths,baseUrl, self-name imports, and package.json\"imports\"lookups have been exhausted):"
                },
                {
                    "type": "list",
                    "items": [
                        "For each ancestor directory of the importing file, if anode_modulesdirectory exists within it:If a directory with the same name as the package exists withinnode_modules:Attempt to resolve types from the package directory.If a result is found, return it and stop the search.If a directory with the same name as the package exists withinnode_modules/@types:Attempt to resolve types from the@typespackage directory.If a result is found, return it and stop the search.",
                        "If a directory with the same name as the package exists withinnode_modules:Attempt to resolve types from the package directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the package directory.",
                        "If a result is found, return it and stop the search.",
                        "If a directory with the same name as the package exists withinnode_modules/@types:Attempt to resolve types from the@typespackage directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the@typespackage directory.",
                        "If a result is found, return it and stop the search.",
                        "Repeat the previous search through allnode_modulesdirectories, but this time, allow JavaScript files as a result, and do not search in@typesdirectories."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "If a directory with the same name as the package exists withinnode_modules:Attempt to resolve types from the package directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the package directory.",
                        "If a result is found, return it and stop the search.",
                        "If a directory with the same name as the package exists withinnode_modules/@types:Attempt to resolve types from the@typespackage directory.If a result is found, return it and stop the search.",
                        "Attempt to resolve types from the@typespackage directory.",
                        "If a result is found, return it and stop the search."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Attempt to resolve types from the package directory.",
                        "If a result is found, return it and stop the search."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Attempt to resolve types from the@typespackage directory.",
                        "If a result is found, return it and stop the search."
                    ]
                },
                {
                    "type": "p",
                    "text": "AllmoduleResolutionmodes (exceptclassic) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "package.json\"exports\""
                },
                {
                    "type": "p",
                    "text": "WhenmoduleResolutionis set tonode16,nodenext, orbundler, andresolvePackageJsonExportsis not disabled, TypeScript follows Node.js’spackage.json\"exports\"specwhen resolving from a package directory triggered by abare specifiernode_modulespackage lookup."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s implementation for resolving a module specifier through\"exports\"to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will stilltry multiple file extensionsin order to prioritize finding types."
                },
                {
                    "type": "p",
                    "text": "When resolving throughconditional\"exports\", TypeScript always matches the\"types\"and\"default\"conditions if present. Additionally, TypeScript will match a versioned types condition in the form\"types@{selector}\"(where{selector}is a\"typesVersions\"-compatible version selector) according to the same version-matching rules implemented in\"typesVersions\". Other non-configurable conditions are dependent on themoduleResolutionmode and specified in the following sections. Additional conditions can be configured to match with thecustomConditionscompiler option."
                },
                {
                    "type": "p",
                    "text": "Note that the presence of\"exports\"prevents any subpaths not explicitly listed or matched by a pattern in\"exports\"from being resolved."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: subpaths, conditions, and extension substitution"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"require\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\".\": {\"import\":\"./index.mjs\",\"require\":\"./index.cjs\"},\"./subpath\": {\"import\":\"./subpath/index.mjs\",\"require\":\"./subpath/index.cjs\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?No.",
                        "Does the second condition\"require\"match this request?Yes.",
                        "Does the path\"./subpath/index.cjs\"have a recognized TypeScript file extension?No, so use extension substitution.",
                        "Viaextension substitution, try the following paths, returning the first one that exists, orundefinedotherwise:./subpath/index.cts./subpath/index.d.cts./subpath/index.cjs",
                        "./subpath/index.cts",
                        "./subpath/index.d.cts",
                        "./subpath/index.cjs"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "./subpath/index.cts",
                        "./subpath/index.d.cts",
                        "./subpath/index.cjs"
                    ]
                },
                {
                    "type": "p",
                    "text": "If./subpath/index.ctsor./subpath.d.ctsexists, resolution is complete. Otherwise, resolution searchesnode_modules/@types/pkgand othernode_modulesdirectories in an attempt to resolve types, according to thenode_modulespackage lookupsrules. If no types are found, a second pass through allnode_modulesresolves to./subpath/index.cjs(assuming it exists), which counts as a successful resolution, but one that does not provide types, leading toany-typed imports and anoImplicitAnyerror if enabled."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: explicit\"types\"condition"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\"./subpath\": {\"import\": {\"types\":\"./types/subpath/index.d.mts\",\"default\":\"./es/subpath/index.mjs\"},\"require\": {\"types\":\"./types/subpath/index.d.cts\",\"default\":\"./cjs/subpath/index.cjs\"}}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "The value atexports[\"./subpath\"].importis an object—it must be specifying conditions.",
                        "Does the first condition\"types\"match this request?Yes.",
                        "Does the path\"./types/subpath/index.d.mts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./types/subpath/index.d.mts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: versioned\"types\"condition"
                },
                {
                    "type": "p",
                    "text": "Scenario: using TypeScript 4.7.5,\"pkg/subpath\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"exports\": {\"./subpath\": {\"types@>=5.2\":\"./ts5.2/subpath/index.d.ts\",\"types@>=4.6\":\"./ts4.6/subpath/index.d.ts\",\"types\":\"./tsold/subpath/index.d.ts\",\"default\":\"./dist/subpath/index.js\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./subpath\"entry?Yes.",
                        "The value atexports[\"./subpath\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"types@>=5.2\"match this request?No, 4.7.5 is not greater than or equal to 5.2.",
                        "Does the second condition\"types@>=4.6\"match this request?Yes, 4.7.5 is greater than or equal to 4.6.",
                        "Does the path\"./ts4.6/subpath/index.d.ts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./ts4.6/subpath/index.d.ts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: subpath patterns"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/wildcard.js\"is requested with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"type\":\"module\",\"exports\": {\"./*.js\": {\"types\":\"./types/*.d.ts\",\"default\":\"./dist/*.js\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "Does\"exports\"have a\"./wildcard.js\"entry?No.",
                        "Does any key with a*in it match\"./wildcard.js\"?Yes,\"./*.js\"matches and setswildcardto be the substitution.",
                        "The value atexports[\"./*.js\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"types\"match this request?Yes.",
                        "In./types/*.d.ts, replace*with the substitutionwildcard../types/wildcard.d.ts",
                        "Does the path\"./types/wildcard.d.ts\"have a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path\"./types/wildcard.d.ts\"if the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example:\"exports\"block other subpaths"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"pkg/dist/index.js\"is requested in a package directory with the following package.json:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"main\":\"./dist/index.js\",\"exports\":\"./dist/index.js\"}"
                },
                {
                    "type": "p",
                    "text": "Resolution process within the package directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does\"exports\"exist?Yes.",
                        "The value atexportsis a string—it must be a file path for the package root (\".\").",
                        "Is the request\"pkg/dist/index.js\"for the package root?No, it has a subpathdist/index.js.",
                        "Resolution fails; returnundefined."
                    ]
                },
                {
                    "type": "p",
                    "text": "Without\"exports\", the request could have succeeded, but the presence of\"exports\"prevents resolving any subpaths that cannot be matched through\"exports\"."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "package.json\"typesVersions\""
                },
                {
                    "type": "p",
                    "text": "Anode_modulespackageordirectory modulemay specify a\"typesVersions\"field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and fornode_modulespackages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool likedownlevel-dts).\"typesVersions\"is supported in allmoduleResolutionmodes; however, the field is not read in situations whenpackage.json\"exports\"are read."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: redirect all requests to a subdirectory"
                },
                {
                    "type": "p",
                    "text": "Scenario: a module imports\"pkg\"using TypeScript 5.2, wherenode_modules/pkg/package.jsonis:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\">=3.1\": {\"*\": [\"ts3.1/*\"]}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "(Depending on compiler options) Does\"exports\"exist?No.",
                        "Does\"typesVersions\"exist?Yes.",
                        "Is the TypeScript version>=3.1?Yes. Remember the mapping\"*\": [\"ts3.1/*\"].",
                        "Are we resolving a subpath after the package name?No, just the root\"pkg\".",
                        "Does\"types\"exist?Yes.",
                        "Does any key in\"typesVersions\"match./index.d.ts?Yes,\"*\"matches and setsindex.d.tsto be the substitution.",
                        "Ints3.1/*, replace*with the substitution./index.d.ts:ts3.1/index.d.ts.",
                        "Does the path./ts3.1/index.d.tshave a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path./ts3.1/index.d.tsif the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: redirect requests for a specific file"
                },
                {
                    "type": "p",
                    "text": "Scenario: a module imports\"pkg\"using TypeScript 3.9, wherenode_modules/pkg/package.jsonis:"
                },
                {
                    "type": "code",
                    "code": "json{\"name\":\"pkg\",\"version\":\"1.0.0\",\"types\":\"./index.d.ts\",\"typesVersions\": {\"<4.0\": {\"index.d.ts\": [\"index.v3.d.ts\"] }}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "(Depending on compiler options) Does\"exports\"exist?No.",
                        "Does\"typesVersions\"exist?Yes.",
                        "Is the TypeScript version<4.0?Yes. Remember the mapping\"index.d.ts\": [\"index.v3.d.ts\"].",
                        "Are we resolving a subpath after the package name?No, just the root\"pkg\".",
                        "Does\"types\"exist?Yes.",
                        "Does any key in\"typesVersions\"match./index.d.ts?Yes,\"index.d.ts\"matches.",
                        "Does the path./index.v3.d.tshave a recognized TypeScript file extension?Yes, so don’t use extension substitution.",
                        "Return the path./index.v3.d.tsif the file exists,undefinedotherwise."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "package.json\"main\"and\"types\""
                },
                {
                    "type": "p",
                    "text": "If a directory’spackage.json\"exports\"field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as adirectory moduleinstead of anode_modulespackage) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"types\"",
                        "\"typings\"(legacy)",
                        "\"main\""
                    ]
                },
                {
                    "type": "p",
                    "text": "The declaration file found at\"types\"is assumed to be an accurate representation of the implementation file found at\"main\". If\"types\"and\"typings\"are not present or cannot be resolved, TypeScript will read the\"main\"field and performextension substitutionto find a declaration file."
                },
                {
                    "type": "p",
                    "text": "When publishing a typed package to npm, it’s recommended to include a\"types\"field even ifextension substitutionorpackage.json\"exports\"make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a\"types\"field."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Package-relative file paths"
                },
                {
                    "type": "p",
                    "text": "If neitherpackage.json\"exports\"norpackage.json\"typesVersions\"apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicablerelative pathresolution rules. In modes that respect [package.json\"exports\"], this behavior is blocked by the mere presence of the\"exports\"field in the package’s package.json, even if the import fails to resolve through\"exports\", as demonstrated inan example above. On the other hand, if the import fails to resolve through\"typesVersions\", a package-relative file path resolution is attempted as a fallback."
                },
                {
                    "type": "p",
                    "text": "When package-relative paths are supported, they resolve under the same rules as any other relative path considering themoduleResolutionmode and context. For example, in--moduleResolution nodenext,directory modulesandextensionless pathsare only supported inrequirecalls, not inimports:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: module.mtsimport\"pkg/dist/foo\";// ❌ import, needs `.js` extensionimport\"pkg/dist/foo.js\";// ✅importfoo=require(\"pkg/dist/foo\");// ✅ require, no extension needed"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "package.json\"imports\"and self-name imports"
                },
                {
                    "type": "p",
                    "text": "WhenmoduleResolutionis set tonode16,nodenext, orbundler, andresolvePackageJsonImportsis not disabled, TypeScript will attempt to resolve import paths beginning with#through the\"imports\"field of the nearest ancestor package.json of the importing file. Similarly, whenpackage.json\"exports\"lookupsare enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the\"name\"field of the nearest ancestor package.json of the importing file—through the\"exports\"field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path."
                },
                {
                    "type": "p",
                    "text": "TypeScript follows Node.js’s resolution algorithm for\"imports\"andself referencesexactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the\"imports\"or\"exports\"being resolved belongs to anode_modulesdependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):"
                },
                {
                    "type": "list",
                    "items": [
                        "If the package.json is innode_modules, TypeScript will applyextension substitutionto the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.",
                        "If the package.json is part of the local project, an additional remapping step is performed in order to find theinputTypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from\"imports\". Without this step, any compilation that resolves an\"imports\"path would be referencing output files from theprevious compilationinstead of other input files that are intended to be included in the current compilation. This remapping uses theoutDir/declarationDirandrootDirfrom the tsconfig.json, so using\"imports\"usually requires an explicitrootDirto be set."
                    ]
                },
                {
                    "type": "p",
                    "text": "This variation allows package authors to write\"imports\"and\"exports\"fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example: local project with conditions"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"/src/main.mts\"imports\"#utils\"with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:"
                },
                {
                    "type": "code",
                    "code": "json// tsconfig.json{\"compilerOptions\": {\"moduleResolution\":\"node16\",\"resolvePackageJsonImports\":true,\"rootDir\":\"./src\",\"outDir\":\"./dist\"}}"
                },
                {
                    "type": "code",
                    "code": "json// package.json{\"name\":\"pkg\",\"imports\": {\"#utils\": {\"import\":\"./dist/utils.d.mts\",\"require\":\"./dist/utils.d.cts\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "Import path starts with#, try to resolve through\"imports\".",
                        "Does\"imports\"exist in the nearest ancestor package.json?Yes.",
                        "Does\"#utils\"exist in the\"imports\"object?Yes.",
                        "The value atimports[\"#utils\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "Should we attempt to map the output path to an input path?Yes, because:Is the package.json innode_modules?No, it’s in the local project.Is the tsconfig.json within the package.json directory?Yes.",
                        "Is the package.json innode_modules?No, it’s in the local project.",
                        "Is the tsconfig.json within the package.json directory?Yes.",
                        "In./dist/utils.d.mts, replace theoutDirprefix withrootDir../src/utils.d.mts",
                        "Replace the output extension.d.mtswith the corresponding input extension.mts../src/utils.mts",
                        "Return the path\"./src/utils.mts\"if the file exists.",
                        "Otherwise, return the path\"./dist/utils.d.mts\"if the file exists."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Is the package.json innode_modules?No, it’s in the local project.",
                        "Is the tsconfig.json within the package.json directory?Yes."
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example:node_modulesdependency with subpath pattern"
                },
                {
                    "type": "p",
                    "text": "Scenario:\"/node_modules/pkg/main.mts\"imports\"#internal/utils\"with conditions[\"types\", \"node\", \"import\"](determined bymoduleResolutionsetting and the context that triggered the module resolution request) with the package.json:"
                },
                {
                    "type": "code",
                    "code": "json// /node_modules/pkg/package.json{\"name\":\"pkg\",\"imports\": {\"#internal/*\": {\"import\":\"./dist/internal/*.mjs\",\"require\":\"./dist/internal/*.cjs\"}}}"
                },
                {
                    "type": "p",
                    "text": "Resolution process:"
                },
                {
                    "type": "list",
                    "items": [
                        "Import path starts with#, try to resolve through\"imports\".",
                        "Does\"imports\"exist in the nearest ancestor package.json?Yes.",
                        "Does\"#internal/utils\"exist in the\"imports\"object?No, check for pattern matches.",
                        "Does any key with a*match\"#internal/utils\"?Yes,\"#internal/*\"matches and setsutilsto be the substitution.",
                        "The value atimports[\"#internal/*\"]is an object—it must be specifying conditions.",
                        "Does the first condition\"import\"match this request?Yes.",
                        "Should we attempt to map the output path to an input path?No, because the package.json is innode_modules.",
                        "In./dist/internal/*.mjs, replace*with the substitutionutils../dist/internal/utils.mjs",
                        "Does the path./dist/internal/utils.mjshave a recognized TypeScript file extension?No, try extension substitution.",
                        "Viaextension substitution, try the following paths, returning the first one that exists, orundefinedotherwise:./dist/internal/utils.mts./dist/internal/utils.d.mts./dist/internal/utils.mjs",
                        "./dist/internal/utils.mts",
                        "./dist/internal/utils.d.mts",
                        "./dist/internal/utils.mjs"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "./dist/internal/utils.mts",
                        "./dist/internal/utils.d.mts",
                        "./dist/internal/utils.mjs"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "node16,nodenext"
                },
                {
                    "type": "p",
                    "text": "These modes reflect the module resolution behavior of Node.js v12 and later. (node16andnodenextare currently identical, but if Node.js makes significant changes to its module system in the future,node16will be frozen whilenodenextwill be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJSrequirecalls. For each module specifier being resolved, the syntax and themodule format of the importing fileare first used to determine whether the module specifier will be in animportorrequirein the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the\"import\"or\"require\"condition for package.json\"exports\"or\"imports\")."
                },
                {
                    "type": "p",
                    "text": "TypeScript files that aredetermined to be in CommonJS formatmay still useimportandexportsyntax by default, but the emitted JavaScript will userequireandmodule.exportsinstead. This means that it’s common to seeimportstatements that are resolved using therequirealgorithm. If this causes confusion, theverbatimModuleSyntaxcompiler option can be enabled, which prohibits the use ofimportstatements that would be emitted asrequirecalls."
                },
                {
                    "type": "p",
                    "text": "Note that dynamicimport()calls are always resolved using theimportalgorithm, according to Node.js’s behavior. However,import()types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: module.mtsimportxfrom\"./mod.js\";// `import` algorithm due to file format (emitted as-written)import(\"./mod.js\");// `import` algorithm due to syntax (emitted as-written)typeMod=typeofimport(\"./mod.js\");// `import` algorithm due to file formatimportmod=require(\"./mod\");// `require` algorithm due to syntax (emitted as `require`)// @Filename: commonjs.ctsimportxfrom\"./mod\";// `require` algorithm due to file format (emitted as `require`)import(\"./mod.js\");// `import` algorithm due to syntax (emitted as-written)typeMod=typeofimport(\"./mod\");// `require` algorithm due to file formatimportmod=require(\"./mod\");// `require` algorithm due to syntax (emitted as `require`)"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Implied and enforced options"
                },
                {
                    "type": "list",
                    "items": [
                        "--moduleResolution node16andnodenextmust be paired with theircorrespondingmodulevalue."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Supported features"
                },
                {
                    "type": "p",
                    "text": "Features are listed in order of precedence."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "bundler"
                },
                {
                    "type": "p",
                    "text": "--moduleResolution bundlerattempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJSrequireresolution algorithm likenode_moduleslookups,directory modules, andextensionless paths, while also supporting newer Node.js resolution features likepackage.json\"exports\"andpackage.json\"imports\"."
                },
                {
                    "type": "p",
                    "text": "It’s instructive to think about the similarities and differences between--moduleResolution bundlerand--moduleResolution nodenext, particularly in how they decide what conditions to use when resolving package.json\"exports\"or\"imports\". Consider an import statement in a.tsfile:"
                },
                {
                    "type": "code",
                    "code": "ts// index.tsimport{foo}from\"pkg\";"
                },
                {
                    "type": "p",
                    "text": "Recall that in--module nodenext --moduleResolution nodenext, the--modulesetting firstdetermineswhether the import will be emitted to the.jsfile as animportorrequirecall, then passes that information to TypeScript’s module resolver, which decides whether to match\"import\"or\"require\"conditions in\"pkg\"’s package.json\"exports\"accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is.ts, so the output file extension will be.js, which Node.js will interpret as CommonJS, so TypeScript will emit thisimportas arequirecall. So, the module resolver will use therequirecondition as it resolves\"exports\"from\"pkg\"."
                },
                {
                    "type": "p",
                    "text": "The same process happens in--moduleResolution bundler, but the rules for deciding whether to emit animportorrequirecall for this import statement will be different, since--moduleResolution bundlernecessitates using--module esnextor--module preserve. In both of those modes, ESMimportdeclarations always emit as ESMimportdeclarations, so TypeScript’s module resolver will receive that information and use the\"import\"condition as it resolves\"exports\"from\"pkg\"."
                },
                {
                    "type": "p",
                    "text": "This explanation may be somewhat unintuitive, since--moduleResolution bundleris usually used in combination with--noEmit—bundlers typically process raw.tsfiles and perform module resolution on untransformedimports orrequires. However, for consistency, TypeScript still uses the hypothetical emit decided bymoduleto inform module resolution and type checking. This makes--module preservethe best choice whenever a runtime or bundler is operating on raw.tsfiles, since it implies no transformation. Under--module preserve --moduleResolution bundler, you can write imports and requires in the same file that will resolve with theimportandrequireconditions, respectively:"
                },
                {
                    "type": "code",
                    "code": "ts// index.tsimportpkg1from\"pkg\";// Resolved with \"import\" conditionimportpkg2=require(\"pkg\");// Resolved with \"require\" condition"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Implied and enforced options"
                },
                {
                    "type": "list",
                    "items": [
                        "--moduleResolution bundlermust be paired with--module esnextor--module preserve.",
                        "--moduleResolution bundlerimplies--allowSyntheticDefaultImports."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Supported features"
                },
                {
                    "type": "list",
                    "items": [
                        "paths✅",
                        "baseUrl✅",
                        "node_modulespackage lookups✅",
                        "package.json\"exports\"✅ matchestypes,import/requiredepending on syntax",
                        "package.json\"imports\"and self-name imports✅ matchestypes,import/requiredepending on syntax",
                        "package.json\"typesVersions\"✅",
                        "Package-relative paths✅ whenexportsnot present",
                        "Full relative paths✅",
                        "Extensionless relative paths✅",
                        "Directory modules✅"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "node10(formerly known asnode)"
                },
                {
                    "type": "p",
                    "text": "--moduleResolution nodewas renamed tonode10(keepingnodeas an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Supported features"
                },
                {
                    "type": "list",
                    "items": [
                        "paths✅",
                        "baseUrl✅",
                        "node_modulespackage lookups✅",
                        "package.json\"exports\"❌",
                        "package.json\"imports\"and self-name imports❌",
                        "package.json\"typesVersions\"✅",
                        "Package-relative paths✅",
                        "Full relative paths✅",
                        "Extensionless relative paths✅",
                        "Directory modules✅"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "classic"
                },
                {
                    "type": "p",
                    "text": "Do not useclassic."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/modules/theory.html",
            "title": "TypeScript: Documentation - Modules - Theory",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Modules - Theory"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Scripts and modules in JavaScript"
                },
                {
                    "type": "p",
                    "text": "In the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiplescripttags in HTML:"
                },
                {
                    "type": "code",
                    "code": "html<html><head><scriptsrc=\"a.js\"></script><scriptsrc=\"b.js\"></script></head><body></body></html>"
                },
                {
                    "type": "p",
                    "text": "This approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions."
                },
                {
                    "type": "p",
                    "text": "Any system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast withscriptfiles, which run outside a module system, in a global scope.)"
                },
                {
                    "type": "p",
                    "text": "There aremany module systems, and TypeScriptsupports emitting several, but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS)."
                },
                {
                    "type": "p",
                    "text": "ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicatedimportandexportsyntax:"
                },
                {
                    "type": "code",
                    "code": "js// a.jsexportdefault\"Hello from a.js\";"
                },
                {
                    "type": "code",
                    "code": "js// b.jsimportafrom\"./a.js\";console.log(a);// 'Hello from a.js'"
                },
                {
                    "type": "p",
                    "text": "CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions namedexportsandrequire:"
                },
                {
                    "type": "code",
                    "code": "js// a.jsexports.message=\"Hello from a.js\";"
                },
                {
                    "type": "code",
                    "code": "js// b.jsconsta=require(\"./a\");console.log(a.message);// 'Hello from a.js'"
                },
                {
                    "type": "p",
                    "text": "Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript’s job concerning modules"
                },
                {
                    "type": "p",
                    "text": "The TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:"
                },
                {
                    "type": "code",
                    "code": "tsimportsayHellofrom\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "To check this file, the compiler needs to know the type ofsayHello(is it a function that can accept one string argument?), which opens quite a few additional questions:"
                },
                {
                    "type": "list",
                    "items": [
                        "Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?",
                        "Whatkindof module does the module system expect to find, given the file name it will load and its location on disk?",
                        "If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?",
                        "Where will the module system look to find the module specified by\"greetings\"? Will the lookup succeed?",
                        "What kind of module is the file resolved by that lookup?",
                        "Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?",
                        "Once the\"greetings\"module has been analyzed, what piece of that module is bound tosayHello?"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notice that all of these questions depend on characteristics of thehost—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack)."
                },
                {
                    "type": "p",
                    "text": "The ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known asmodule resolution, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options."
                },
                {
                    "type": "p",
                    "text": "The other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of itsoutputJavaScript files, not itsinputTypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and otherTypeScript-first runtimes and bundlers. So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:"
                },
                {
                    "type": "p",
                    "text": "Understand therules of the hostenough"
                },
                {
                    "type": "list",
                    "items": [
                        "to compile files into a validoutput module format,",
                        "to ensure that imports in thoseoutputswillresolve successfully, and",
                        "to know whattypeto assign toimported names."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Who is the host?"
                },
                {
                    "type": "p",
                    "text": "Before we move on, it’s worth making sure we’re on the same page about the termhost, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:"
                },
                {
                    "type": "list",
                    "items": [
                        "When the output code (whether produced bytscor a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.",
                        "When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.",
                        "When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)",
                        "If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’snota host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.",
                        "When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.",
                        "The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The module output format"
                },
                {
                    "type": "p",
                    "text": "In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host onlysupportsone kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions andpackage.jsonfiles to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format."
                },
                {
                    "type": "p",
                    "text": "Themodulecompiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features likeimport.metaand top-levelawaitare available. So, even if a TypeScript project is usingnoEmit, choosing the right setting formodulestill matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. SeeChoosing compiler optionsfor guidance on choosing the rightmodulesetting for your project."
                },
                {
                    "type": "p",
                    "text": "The availablemodulesettings are"
                },
                {
                    "type": "list",
                    "items": [
                        "node16: Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.",
                        "nodenext: Currently identical tonode16, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.",
                        "es2015: Reflects the ES2015 language specification for JavaScript modules (the version that first introducedimportandexportto the language).",
                        "es2020: Adds support forimport.metaandexport * as ns from \"mod\"toes2015.",
                        "es2022: Adds support for top-levelawaittoes2020.",
                        "esnext: Currently identical toes2022, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.",
                        "commonjs,system,amd, andumd: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation."
                    ]
                },
                {
                    "type": "p",
                    "text": "Node.js’s rules for module format detection and interoperability make it incorrect to specifymoduleasesnextorcommonjsfor projects that run in Node.js, even if all files emitted bytscare ESM or CJS, respectively. The only correctmodulesettings for projects that intend to run in Node.js arenode16andnodenext. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations usingesnextandnodenext, the type checking can differ. See thereference section onnodenextfor more details."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module format detection"
                },
                {
                    "type": "p",
                    "text": "Node.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and thetypefield of the firstpackage.jsonfile found in a search of the file’s directory and all ancestor directories:"
                },
                {
                    "type": "list",
                    "items": [
                        ".mjsand.cjsfiles are always interpreted as ES modules and CJS modules, respectively.",
                        ".jsfiles are interpreted as ES modules if the nearestpackage.jsonfile contains atypefield with the value\"module\". If there is nopackage.jsonfile, or if thetypefield is missing or has any other value,.jsfiles are interpreted as CJS modules."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a file is determined to be an ES module by these rules, Node.js will not inject the CommonJSmoduleandrequireobjects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module,importandexportdeclarations in the file will cause a syntax error crash."
                },
                {
                    "type": "p",
                    "text": "When themodulecompiler option is set tonode16ornodenext, TypeScript applies this same algorithm to the project’sinputfiles to determine the module kind of each correspondingoutputfile. Let’s look at how module formats are detected in an example project that uses--module nodenext:"
                },
                {
                    "type": "p",
                    "text": "When the input file extension is.mtsor.cts, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output.mjsfile as an ES module or the output.cjsfile as a CJS module. When the input file extension is.ts, TypeScript has to consult the nearestpackage.jsonfile to determine the module format, because this is what Node.js will do when it encounters the output.jsfile. (Notice that the same rules apply to the.d.ctsand.d.tsdeclaration files in thepkgdependency: though they will not produce an output file as part of this compilation, the presence of a.d.tsfileimpliesthe existence of a corresponding.jsfile—perhaps created when the author of thepkglibrary rantscon an input.tsfile of their own—which Node.js must interpret as an ES module, due to its.jsextension and the presence of the\"type\": \"module\"field in/node_modules/pkg/package.json. Declaration files are covered in more detail in alater section.)"
                },
                {
                    "type": "p",
                    "text": "The detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit/example.jswithimportandexportstatements in it, Node.js would crash when parsing the file. If TypeScript were to emit/main.mjswithrequirecalls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections."
                },
                {
                    "type": "p",
                    "text": "It’s worth mentioning again that TypeScript’s behavior in--module node16and--module nodenextis entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection isnecessaryfor checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Input module syntax"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that theinputmodule syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:"
                },
                {
                    "type": "code",
                    "code": "tsimport{sayHello}from\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:"
                },
                {
                    "type": "code",
                    "code": "tsObject.defineProperty(exports,\"__esModule\", {value:true});constgreetings_1=require(\"greetings\");(0,greetings_1.sayHello)(\"world\");"
                },
                {
                    "type": "p",
                    "text": "depending on themodulecompiler option (and any applicablemodule format detectionrules, if themoduleoption supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module."
                },
                {
                    "type": "p",
                    "text": "Today, most TypeScript files are authored using ESM syntax (importandexportstatements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspiredimport fs = require(\"fs\")syntax inthe 1.5 release."
                },
                {
                    "type": "p",
                    "text": "The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:"
                },
                {
                    "type": "list",
                    "items": [
                        "Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.",
                        "When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.",
                        "When input files are written in ESM, the syntax in type declaration outputs (.d.tsfiles) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScripthasto know what kind of module everything is in order to provide correct types and prevent imports that will crash."
                    ]
                },
                {
                    "type": "p",
                    "text": "In TypeScript 5.0, a new compiler option calledverbatimModuleSyntaxwas introduced to help TypeScript authors know exactly how theirimportandexportstatements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (import fs = require(\"fs\")andexport = {}). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ESM and CJS interoperability"
                },
                {
                    "type": "p",
                    "text": "Can an ES moduleimporta CommonJS module? If so, does a default import link toexportsorexports.default? Can a CommonJS modulerequirean ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:"
                },
                {
                    "type": "list",
                    "items": [
                        "ESM-only.Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.",
                        "Bundler-like.Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.",
                        "Node.js.In Node.js, CommonJS modules cannot load ES modules synchronously (withrequire); they can only load them asynchronously with dynamicimport()calls. ES modules can default-import CJS modules, which always binds toexports. (This means that a default import of a Babel-like CJS output with__esModulebehaves differently between Node.js and some bundlers.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "TypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularlydefault) imports and to error on imports that will crash at runtime. When themodulecompiler option is set tonode16ornodenext, Node.js’s rules are enforced. All othermodulesettings, combined with theesModuleInteropoption, result in bundler-like interop in TypeScript. (While using--module esnextdoes prevent you fromwritingCommonJS modules, it does not prevent you fromimportingthem as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module specifiers are not transformed"
                },
                {
                    "type": "p",
                    "text": "While themodulecompiler option can transform imports and exports in input files to different module formats in output files, the modulespecifier(the stringfromwhich youimport, or pass torequire) is always emitted as-written. For example, an input like:"
                },
                {
                    "type": "code",
                    "code": "tsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "might be emitted as either:"
                },
                {
                    "type": "code",
                    "code": "tsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "or:"
                },
                {
                    "type": "code",
                    "code": "tsconstmath_1=require(\"./math.mjs\");math_1.add(1,2);"
                },
                {
                    "type": "p",
                    "text": "depending on themodulecompiler option, but the module specifier will always be\"./math.mjs\". There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand thoseoutput-relative specifiers. The process of finding the file referenced by a module specifier is calledmodule resolution."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Module resolution"
                },
                {
                    "type": "p",
                    "text": "Let’s return to ourfirst exampleand review what we’ve learned about it so far:"
                },
                {
                    "type": "code",
                    "code": "tsimportsayHellofrom\"greetings\";sayHello(\"world\");"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve discussed how the host’s module system and TypeScript’smodulecompiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on themodulecompiler option, potentially the file extension, andpackage.json\"type\"field. We also know that whatsayHellogets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how tofindthe target file."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module resolution is host-defined"
                },
                {
                    "type": "p",
                    "text": "While the ECMAScript specification defines how to parse and interpretimportandexportstatements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:"
                },
                {
                    "type": "code",
                    "code": "tsimportmonkeyfrom\"🐒\";// Looks for './eats/bananas.js'importcowfrom\"🐄\";// Looks for './eats/grass.js'importlionfrom\"🦁\";// Looks for './eats/you.js'"
                },
                {
                    "type": "p",
                    "text": "and still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign tomonkey,cow, andlionwithout built-in knowledge of this runtime’s module resolution algorithm. Just asmoduleinforms the compiler about the host’s expected module format,moduleResolution, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host."
                },
                {
                    "type": "p",
                    "text": "The availablemoduleResolutionoptions are:"
                },
                {
                    "type": "list",
                    "items": [
                        "classic: TypeScript’s oldest module resolution mode, this is unfortunately the default whenmoduleis set to anything other thancommonjs,node16, ornodenext. It was probably made to provide best-effort resolution for a wide range ofRequireJSconfigurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.",
                        "node10: Formerly known asnode, this is the unfortunate default whenmoduleis set tocommonjs. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages fromnode_modules, loading directoryindex.jsfiles, and omitting.jsextensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.",
                        "node16: This is the counterpart of--module node16and is set by default with thatmodulesetting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamicimport()calls are not allowed to omit file extensions or/index.jssuffixes, while module specifiers inrequirecalls are. This module resolution mode understands and enforces this restriction where necessary, as determined by themodule format detection rulesinstated by--module node16. (Fornode16andnodenext,moduleandmoduleResolutiongo hand-in-hand: setting one tonode16ornodenextwhile setting the other to something else has unsupported behavior and may be an error in the future.)",
                        "nodenext: Currently identical tonode16, this is the counterpart of--module nodenextand is set by default with thatmodulesetting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.",
                        "bundler: Node.js v12 introduced some new module resolution features for importing npm packages—the\"exports\"and\"imports\"fields ofpackage.json—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supportspackage.json\"exports\"and\"imports\"by default, but can be configured to ignore them. It requires settingmoduletoesnext."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TypeScript imitates the host’s module resolution, but with types"
                },
                {
                    "type": "p",
                    "text": "Remember the three components of TypeScript’sjobconcerning modules?"
                },
                {
                    "type": "list",
                    "items": [
                        "Compile files into a validoutput module format",
                        "Ensure that imports in thoseoutputswillresolve successfully",
                        "Know whattypeto assign toimported names."
                    ]
                },
                {
                    "type": "p",
                    "text": "Module resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports orrequirecalls in the output files, containing thesame module specifiers as the input files, will actually work at runtime. Let’s look at a new example with multiple files:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: math.tsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: main.tsimport{add}from\"./math\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "When we see the import from\"./math\", it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type toadd.”"
                },
                {
                    "type": "p",
                    "text": "This isn’t entirely wrong, but the reality is deeper. The resolution of\"./math\"(and subsequently, the type ofadd) need to reflect the reality of what happens at runtime to theoutputfiles. A more robust way to think about this process would look like this:"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "This model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:"
                },
                {
                    "type": "code",
                    "code": "ts// @moduleResolution: node16// @rootDir: src// @outDir: dist// @Filename: src/math.mtsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: src/main.mtsimport{add}from\"./math.mjs\";add(1,2);"
                },
                {
                    "type": "p",
                    "text": "Node.js ESMimportdeclarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that\"./math.mjs\"seems to resolve tomath.mts. Since we’re using anoutDirto put compiled outputs in a different directory,math.mjsdoesn’t even exist next tomain.mts! Why should this resolve? With our new mental model, it’s no problem:"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Understanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts:\"./math.mjs\"refers to the input filemath.mts. I have to write the output extension, but the compiler knows to look for.mtswhen I write.mjs.This shortcut is even how the compiler works internally, but the more robust mental model explainswhymodule resolution in TypeScript works this way: given the constraint that the module specifier in the output file will bethe sameas the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The role of declaration files"
                },
                {
                    "type": "p",
                    "text": "In the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?"
                },
                {
                    "type": "p",
                    "text": "This is where declaration files (.d.ts,.d.mts, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you runtsc --declarationon an input file, you get one output JavaScript file and one output declaration file:"
                },
                {
                    "type": "p",
                    "text": "Because of this relationship, the compilerassumesthat wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript filewillexist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file."
                },
                {
                    "type": "p",
                    "text": "The declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:"
                },
                {
                    "type": "p",
                    "text": "The last row expresses that non-JS files can be typed with theallowArbitraryExtensionscompiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file namedstyles.csscan be represented by a declaration file namedstyles.d.css.ts."
                },
                {
                    "type": "p",
                    "text": "“But wait! Plenty of declaration files are written by hand,notgenerated bytsc. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not usingtscto generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package@arethetypeswrong/clican help catch and explain these errors before they’re published."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module resolution for bundlers, TypeScript runtimes, and Node.js loaders"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve really emphasized the distinction betweeninput filesandoutput files. Recall that when specifying a file extension on a relative module specifier, TypeScript typicallymakes you use theoutputfile extension:"
                },
                {
                    "type": "code",
                    "code": "ts// @Filename: src/math.tsexportfunctionadd(a:number,b:number) {returna+b;}// @Filename: src/main.tsimport{add}from\"./math.ts\";//                  ^^^^^^^^^^^// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled."
                },
                {
                    "type": "p",
                    "text": "This restriction applies since TypeScriptwon’t rewrite the extensionto.js, and if\"./math.ts\"appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if thereisno output JS file? What if you’re in one of these situations:"
                },
                {
                    "type": "list",
                    "items": [
                        "You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.",
                        "You’re running this code directly in a TypeScript runtime like Deno or Bun.",
                        "You’re usingts-node,tsx, or another transpiling loader for Node."
                    ]
                },
                {
                    "type": "p",
                    "text": "In these cases, you can turn onnoEmit(oremitDeclarationOnly) andallowImportingTsExtensionsto disable emitting unsafe JavaScript files and silence the error on.ts-extensioned imports."
                },
                {
                    "type": "p",
                    "text": "With or withoutallowImportingTsExtensions, it’s still important to pick the most appropriatemoduleResolutionsetting for the module resolution host. For bundlers and the Bun runtime, it’sbundler. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm thatdisables extension searchingthat Node.js applies to imports. Thebundlermodule resolution setting reflects this, enablingpackage.json\"exports\"support likenode16andnodenext, while always allowing extensionless imports. SeeChoosing compiler optionsfor more guidance."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module resolution for libraries"
                },
                {
                    "type": "p",
                    "text": "When compiling an app, you choose themoduleResolutionoption for a TypeScript project based on who the module resolutionhostis. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using\"module\": \"nodenext\"(along with the implied\"moduleResolution\": \"nodenext\") is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules forimportmodule resolution. Let’s look at what would happen if a library were to compile with\"moduleResolution\": \"bundler\"(or worse,\"node10\"):"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils\";"
                },
                {
                    "type": "p",
                    "text": "Assuming./utils.ts(or./utils/index.ts) exists, a bundler would be fine with this code, so\"moduleResolution\": \"bundler\"doesn’t complain. Compiled with\"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:"
                },
                {
                    "type": "code",
                    "code": "Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.jsDid you mean to import ./utils.js?"
                },
                {
                    "type": "p",
                    "text": "On the other hand, if we had written:"
                },
                {
                    "type": "code",
                    "code": "tsexport*from\"./utils.js\";"
                },
                {
                    "type": "p",
                    "text": "This would produce output that works both in Node.jsandin bundlers."
                },
                {
                    "type": "p",
                    "text": "In short,\"moduleResolution\": \"bundler\"is infectious, allowing code that only works in bundlers to be produced. Likewise,\"moduleResolution\": \"nodenext\"is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers."
                },
                {
                    "type": "p",
                    "text": "Of course, this guidance can only apply in cases where the library ships outputs fromtsc. If the library is being bundledbeforeshipping,\"moduleResolution\": \"bundler\"may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, andtsccan no longer contribute to that task, since it can’t know what module code will exist at runtime."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html",
            "title": "TypeScript: Documentation - Namespaces and Modules",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Namespaces and Modules"
                },
                {
                    "type": "p",
                    "text": "This post outlines the various ways to organize your code using modules and namespaces in TypeScript.\nWe’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript."
                },
                {
                    "type": "p",
                    "text": "See theModulesdocumentation for more information about ES Modules.\nSee theNamespacesdocumentation for more information about TypeScript namespaces."
                },
                {
                    "type": "p",
                    "text": "Note: Inveryold versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Modules"
                },
                {
                    "type": "p",
                    "text": "Modules can contain both code and declarations."
                },
                {
                    "type": "p",
                    "text": "Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules.\nModules provide for better code reuse, stronger isolation and better tooling support for bundling."
                },
                {
                    "type": "p",
                    "text": "It is also worth noting that, for Node.js applications, modules are the default andwe recommended modules over namespaces in modern code."
                },
                {
                    "type": "p",
                    "text": "Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations.\nThus, for new projects modules would be the recommended code organization mechanism."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Namespaces"
                },
                {
                    "type": "p",
                    "text": "Namespaces are a TypeScript-specific way to organize code.Namespaces are simply named JavaScript objects in the global namespace.\nThis makes namespaces a very simple construct to use.\nUnlike modules, they can span multiple files, and can be concatenated usingoutFile.\nNamespaces can be a good way to structure your code in a Web Application, with all dependencies included as<script>tags in your HTML page."
                },
                {
                    "type": "p",
                    "text": "Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Pitfalls of Namespaces and Modules"
                },
                {
                    "type": "p",
                    "text": "In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "/// <reference>-ing a module"
                },
                {
                    "type": "p",
                    "text": "A common mistake is to try to use the/// <reference ... />syntax to refer to a module file, rather than using animportstatement.\nTo understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of animport(e.g. the...inimport x from \"...\";,import x = require(\"...\");, etc.) path."
                },
                {
                    "type": "p",
                    "text": "The compiler will try to find a.ts,.tsx, and then a.d.tswith the appropriate path.\nIf a specific file could not be found, then the compiler will look for anambient module declaration.\nRecall that these need to be declared in a.d.tsfile."
                },
                {
                    "type": "list",
                    "items": [
                        "myModules.d.tsts// In a .d.ts file or .ts file that is not a module:declaremodule\"SomeModule\"{exportfunctionfn():string;}",
                        "myOtherModule.tsts///<referencepath=\"myModules.d.ts\"/>import*asmfrom\"SomeModule\";"
                    ]
                },
                {
                    "type": "p",
                    "text": "myModules.d.ts"
                },
                {
                    "type": "code",
                    "code": "ts// In a .d.ts file or .ts file that is not a module:declaremodule\"SomeModule\"{exportfunctionfn():string;}"
                },
                {
                    "type": "p",
                    "text": "myOtherModule.ts"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"myModules.d.ts\"/>import*asmfrom\"SomeModule\";"
                },
                {
                    "type": "p",
                    "text": "The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module.\nThis is how thenode.d.tsfile that several of the TypeScript samples use is consumed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Needless Namespacing"
                },
                {
                    "type": "p",
                    "text": "If you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapes.tstsexportnamespaceShapes{exportclassTriangle{/* ... */}exportclassSquare{/* ... */}}"
                    ]
                },
                {
                    "type": "p",
                    "text": "shapes.ts"
                },
                {
                    "type": "code",
                    "code": "tsexportnamespaceShapes{exportclassTriangle{/* ... */}exportclassSquare{/* ... */}}"
                },
                {
                    "type": "p",
                    "text": "The top-level namespace hereShapeswraps upTriangleandSquarefor no reason.\nThis is confusing and annoying for consumers of your module:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapeConsumer.tstsimport*asshapesfrom\"./shapes\";lett=newshapes.Shapes.Triangle();// shapes.Shapes?"
                    ]
                },
                {
                    "type": "p",
                    "text": "shapeConsumer.ts"
                },
                {
                    "type": "code",
                    "code": "tsimport*asshapesfrom\"./shapes\";lett=newshapes.Shapes.Triangle();// shapes.Shapes?"
                },
                {
                    "type": "p",
                    "text": "A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope.\nBecause the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace."
                },
                {
                    "type": "p",
                    "text": "To reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions.\nBecause the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects."
                },
                {
                    "type": "p",
                    "text": "Here’s a revised example:"
                },
                {
                    "type": "list",
                    "items": [
                        "shapes.tstsexportclassTriangle{/* ... */}exportclassSquare{/* ... */}",
                        "shapeConsumer.tstsimport*asshapesfrom\"./shapes\";lett=newshapes.Triangle();"
                    ]
                },
                {
                    "type": "p",
                    "text": "shapes.ts"
                },
                {
                    "type": "code",
                    "code": "tsexportclassTriangle{/* ... */}exportclassSquare{/* ... */}"
                },
                {
                    "type": "p",
                    "text": "shapeConsumer.ts"
                },
                {
                    "type": "code",
                    "code": "tsimport*asshapesfrom\"./shapes\";lett=newshapes.Triangle();"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Trade-offs of Modules"
                },
                {
                    "type": "p",
                    "text": "Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files.\nOne effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target.\nFor instance, you can’t use theoutFileoption while targetingcommonjsorumd, but with TypeScript 1.8 and later,it’s possibleto useoutFilewhen targetingamdorsystem."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
            "title": "TypeScript: Documentation - Namespaces",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Namespaces"
                },
                {
                    "type": "p",
                    "text": "A note about terminology:It’s important to note that in TypeScript 1.5, the nomenclature has changed.\n“Internal modules” are now “namespaces”.\n“External modules” are now simply “modules”, as to align withECMAScript 2015’s terminology, (namely thatmodule X {is equivalent to the now-preferrednamespace X {)."
                },
                {
                    "type": "p",
                    "text": "This post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript.\nAs we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”.\nAdditionally, anywhere themodulekeyword was used when declaring an internal module, thenamespacekeyword can and should be used instead.\nThis avoids confusing new users by overloading them with similarly named terms."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "First steps"
                },
                {
                    "type": "p",
                    "text": "Let’s start with the program we’ll be using as our example throughout this page.\nWe’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Validators in a single file"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceStringValidator{isAcceptable(s:string):boolean;}letlettersRegexp=/^[A-Za-z]+$/;letnumberRegexp=/^[0-9]+$/;classLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}classZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:StringValidator} = {};validators[\"ZIP code\"] =newZipCodeValidator();validators[\"Letters only\"] =newLettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {letisMatch=validators[name].isAcceptable(s);console.log(`'${s}'${isMatch?\"matches\":\"does not match\"}'${name}'.`);}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Namespacing"
                },
                {
                    "type": "p",
                    "text": "As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects.\nInstead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace."
                },
                {
                    "type": "p",
                    "text": "In this example, we’ll move all validator-related entities into a namespace calledValidation.\nBecause we want the interfaces and classes here to be visible outside the namespace, we preface them withexport.\nConversely, the variableslettersRegexpandnumberRegexpare implementation details, so they are left unexported and will not be visible to code outside the namespace.\nIn the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g.Validation.LettersOnlyValidator."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Namespaced Validators"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceValidation{exportinterfaceStringValidator{isAcceptable(s:string):boolean;}constlettersRegexp=/^[A-Za-z]+$/;constnumberRegexp=/^[0-9]+$/;exportclassLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}exportclassZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}}// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:Validation.StringValidator} = {};validators[\"ZIP code\"] =newValidation.ZipCodeValidator();validators[\"Letters only\"] =newValidation.LettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {console.log(`\"${s}\" -${validators[name].isAcceptable(s)?\"matches\":\"does not match\"}${name}`);}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Splitting Across Files"
                },
                {
                    "type": "p",
                    "text": "As our application grows, we’ll want to split the code across multiple files to make it easier to maintain."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Multi-file namespaces"
                },
                {
                    "type": "p",
                    "text": "Here, we’ll split ourValidationnamespace across many files.\nEven though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place.\nBecause there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files.\nOur test code is otherwise unchanged."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Validation.ts"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceValidation{exportinterfaceStringValidator{isAcceptable(s:string):boolean;}}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "LettersOnlyValidator.ts"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>namespaceValidation{constlettersRegexp=/^[A-Za-z]+$/;exportclassLettersOnlyValidatorimplementsStringValidator{isAcceptable(s:string) {returnlettersRegexp.test(s);}}}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "ZipCodeValidator.ts"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>namespaceValidation{constnumberRegexp=/^[0-9]+$/;exportclassZipCodeValidatorimplementsStringValidator{isAcceptable(s:string) {returns.length===5&&numberRegexp.test(s);}}}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Test.ts"
                },
                {
                    "type": "code",
                    "code": "ts///<referencepath=\"Validation.ts\"/>///<referencepath=\"LettersOnlyValidator.ts\"/>///<referencepath=\"ZipCodeValidator.ts\"/>// Some samples to tryletstrings= [\"Hello\",\"98052\",\"101\"];// Validators to useletvalidators: { [s:string]:Validation.StringValidator} = {};validators[\"ZIP code\"] =newValidation.ZipCodeValidator();validators[\"Letters only\"] =newValidation.LettersOnlyValidator();// Show whether each string passed each validatorfor(letsofstrings) {for(letnameinvalidators) {console.log(`\"${s}\" -${validators[name].isAcceptable(s)?\"matches\":\"does not match\"}${name}`);}}"
                },
                {
                    "type": "p",
                    "text": "Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded.\nThere are two ways of doing this."
                },
                {
                    "type": "p",
                    "text": "First, we can use concatenated output using theoutFileoption to compile all of the input files into a single JavaScript output file:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Test.ts"
                },
                {
                    "type": "p",
                    "text": "The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:"
                },
                {
                    "type": "code",
                    "code": "tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts"
                },
                {
                    "type": "p",
                    "text": "Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file.\nIf multiple JS files get produced, we’ll need to use<script>tags on our webpage to load each emitted file in the appropriate order, for example:"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "MyTestPage.html (excerpt)"
                },
                {
                    "type": "code",
                    "code": "html<scriptsrc=\"Validation.js\"type=\"text/javascript\"/><scriptsrc=\"LettersOnlyValidator.js\"type=\"text/javascript\"/><scriptsrc=\"ZipCodeValidator.js\"type=\"text/javascript\"/><scriptsrc=\"Test.js\"type=\"text/javascript\"/>"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Aliases"
                },
                {
                    "type": "p",
                    "text": "Another way that you can simplify working with namespaces is to useimport q = x.y.zto create shorter names for commonly-used objects.\nNot to be confused with theimport x = require(\"name\")syntax used to load modules, this syntax simply creates an alias for the specified symbol.\nYou can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports."
                },
                {
                    "type": "code",
                    "code": "tsnamespaceShapes{exportnamespacePolygons{exportclassTriangle{}exportclassSquare{}}}importpolygons=Shapes.Polygons;letsq=newpolygons.Square();// Same as 'new Shapes.Polygons.Square()'"
                },
                {
                    "type": "p",
                    "text": "Notice that we don’t use therequirekeyword; instead we assign directly from the qualified name of the symbol we’re importing.\nThis is similar to usingvar, but also works on the type and namespace meanings of the imported symbol.\nImportantly, for values,importis a distinct reference from the original symbol, so changes to an aliasedvarwill not be reflected in the original variable."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Working with Other JavaScript Libraries"
                },
                {
                    "type": "p",
                    "text": "To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.\nBecause most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them."
                },
                {
                    "type": "p",
                    "text": "We call declarations that don’t define an implementation “ambient”.\nTypically these are defined in.d.tsfiles.\nIf you’re familiar with C/C++, you can think of these as.hfiles.\nLet’s look at a few examples."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ambient Namespaces"
                },
                {
                    "type": "p",
                    "text": "The popular library D3 defines its functionality in a global object calledd3.\nBecause this library is loaded through a<script>tag (instead of a module loader), its declaration uses namespaces to define its shape.\nFor the TypeScript compiler to see this shape, we use an ambient namespace declaration.\nFor example, we could begin writing it as follows:"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "D3.d.ts (simplified excerpt)"
                },
                {
                    "type": "code",
                    "code": "tsdeclarenamespaceD3{exportinterfaceSelectors{select: {(selector:string):Selection;(element:EventTarget):Selection;};}exportinterfaceEvent{x:number;y:number;}exportinterfaceBaseextendsSelectors{event:Event;}}declarevard3:D3.Base;"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/nightly-builds.html",
            "title": "TypeScript: Documentation - Nightly Builds",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Nightly Builds"
                },
                {
                    "type": "p",
                    "text": "A nightly build from theTypeScript’smainbranch is published by midnight PST to npm.\nHere is how you can get it and use it with your tools."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using npm"
                },
                {
                    "type": "code",
                    "code": "shellnpm install -D typescript@next"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating your IDE to use the nightly builds"
                },
                {
                    "type": "p",
                    "text": "You can also update your editor/IDE to use the nightly drop.\nYou will typically need to install the package through npm.\nThe rest of this section mostly assumestypescript@nextis already installed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Visual Studio Code"
                },
                {
                    "type": "p",
                    "text": "The VS Code websitehas documentation on selecting a workspace version of TypeScript.\nAfter installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view.\nA direct way to do this is to open or create your workspace’s.vscode/settings.jsonand add the following property:"
                },
                {
                    "type": "code",
                    "code": "json\"typescript.tsdk\":\"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "Alternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run theJavaScript and TypeScript Nightly Extension"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Sublime Text"
                },
                {
                    "type": "p",
                    "text": "Update theSettings - Userfile with the following:"
                },
                {
                    "type": "code",
                    "code": "json\"typescript_tsdk\":\"<path to your folder>/node_modules/typescript/lib\""
                },
                {
                    "type": "p",
                    "text": "More information is available at theTypeScript Plugin for Sublime Text installation documentation."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Visual Studio 2013 and 2015"
                },
                {
                    "type": "p",
                    "text": "Note: Most changes do not require you to install a new version of the VS TypeScript plugin."
                },
                {
                    "type": "p",
                    "text": "The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well."
                },
                {
                    "type": "list",
                    "items": [
                        "Download theVSDevMode.ps1script.Also see our wiki page onusing a custom language service file.",
                        "From a PowerShell command window, run:"
                    ]
                },
                {
                    "type": "p",
                    "text": "Download theVSDevMode.ps1script."
                },
                {
                    "type": "p",
                    "text": "Also see our wiki page onusing a custom language service file."
                },
                {
                    "type": "p",
                    "text": "From a PowerShell command window, run:"
                },
                {
                    "type": "p",
                    "text": "For VS 2015:"
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "p",
                    "text": "For VS 2013:"
                },
                {
                    "type": "code",
                    "code": "VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "IntelliJ IDEA (Mac)"
                },
                {
                    "type": "p",
                    "text": "Go toPreferences>Languages & Frameworks>TypeScript:"
                },
                {
                    "type": "p",
                    "text": "TypeScript Version: If you installed with npm:/usr/local/lib/node_modules/typescript/lib"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "IntelliJ IDEA (Windows)"
                },
                {
                    "type": "p",
                    "text": "Go toFile>Settings>Languages & Frameworks>TypeScript:"
                },
                {
                    "type": "p",
                    "text": "TypeScript Version: If you installed with npm:C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
            "title": "TypeScript: Documentation - Project References",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Project References"
                },
                {
                    "type": "p",
                    "text": "Project references allows you to structure your TypeScript programs into smaller pieces, available in TypeScript 3.0 and newer."
                },
                {
                    "type": "p",
                    "text": "By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways."
                },
                {
                    "type": "p",
                    "text": "We’re also introducing a new mode fortsc, the--buildflag, that works hand in hand with project references to enable faster TypeScript builds."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "An Example Project"
                },
                {
                    "type": "p",
                    "text": "Let’s look at a fairly normal program and see how project references can help us better organize it.\nImagine you have a project with two modules,converterandunits, and a corresponding test file for each:"
                },
                {
                    "type": "code",
                    "code": "/├── src/│   ├── converter.ts│   └── units.ts├── test/│   ├── converter-tests.ts│   └── units-tests.ts└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "The test files import the implementation files and do some testing:"
                },
                {
                    "type": "code",
                    "code": "ts// converter-tests.tsimport*asconverterfrom\"../src/converter\";assert.areEqual(converter.celsiusToFahrenheit(0),32);"
                },
                {
                    "type": "p",
                    "text": "Previously, this structure was rather awkward to work with if you used a single tsconfig file:"
                },
                {
                    "type": "list",
                    "items": [
                        "It was possible for the implementation files to import the test files",
                        "It wasn’t possible to buildtestandsrcat the same time without havingsrcappear in the output folder name, which you probably don’t want",
                        "Changing just theinternalsin the implementation files requiredtypecheckingthe tests again, even though this wouldn’t ever cause new errors",
                        "Changing just the tests required typechecking the implementation again, even if nothing changed"
                    ]
                },
                {
                    "type": "p",
                    "text": "You could use multiple tsconfig files to solvesomeof those problems, but new ones would appear:"
                },
                {
                    "type": "list",
                    "items": [
                        "There’s no built-in up-to-date checking, so you end up always runningtsctwice",
                        "Invokingtsctwice incurs more startup time overhead",
                        "tsc -wcan’t run on multiple config files at once"
                    ]
                },
                {
                    "type": "p",
                    "text": "Project references can solve all of these problems and more."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What is a Project Reference?"
                },
                {
                    "type": "p",
                    "text": "tsconfig.jsonfiles have a new top-level property,references. It’s an array of objects that specifies projects to reference:"
                },
                {
                    "type": "code",
                    "code": "js{\"compilerOptions\": {// The usual},\"references\": [{\"path\":\"../src\"}]}"
                },
                {
                    "type": "p",
                    "text": "Thepathproperty of each reference can point to a directory containing atsconfig.jsonfile, or to the config file itself (which may have any name)."
                },
                {
                    "type": "p",
                    "text": "When you reference a project, new things happen:"
                },
                {
                    "type": "list",
                    "items": [
                        "Importing modules from a referenced project will instead load itsoutputdeclaration file (.d.ts)",
                        "If the referenced project produces anoutFile, the output file.d.tsfile’s declarations will be visible in this project",
                        "Build mode (see below) will automatically build the referenced project if needed"
                    ]
                },
                {
                    "type": "p",
                    "text": "By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "composite"
                },
                {
                    "type": "p",
                    "text": "Referenced projects must have the newcompositesetting enabled.\nThis setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project.\nEnabling thecompositeflag changes a few things:"
                },
                {
                    "type": "list",
                    "items": [
                        "TherootDirsetting, if not explicitly set, defaults to the directory containing thetsconfigfile",
                        "All implementation files must be matched by anincludepattern or listed in thefilesarray. If this constraint is violated,tscwill inform you which files weren’t specified",
                        "declarationmust be turned on"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "declarationMap"
                },
                {
                    "type": "p",
                    "text": "We’ve also added support fordeclaration source maps.\nIf you enabledeclarationMap, you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Caveats for Project References"
                },
                {
                    "type": "p",
                    "text": "Project references have a few trade-offs you should be aware of."
                },
                {
                    "type": "p",
                    "text": "Because dependent projects make use of.d.tsfiles that are built from their dependencies, you’ll either have to check in certain build outputsorbuild a project after cloning it before you can navigate the project in an editor without seeing spurious errors."
                },
                {
                    "type": "p",
                    "text": "When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory.d.tsgeneration process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this usingdisableSourceOfProjectReferenceRedirect option."
                },
                {
                    "type": "p",
                    "text": "Additionally, to preserve compatibility with existing build workflows,tscwillnotautomatically build dependencies unless invoked with the--buildswitch.\nLet’s learn more about--build."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Build Mode for TypeScript"
                },
                {
                    "type": "p",
                    "text": "A long-awaited feature is smart incremental builds for TypeScript projects.\nIn 3.0 you can use the--buildflag withtsc.\nThis is effectively a new entry point fortscthat behaves more like a build orchestrator than a simple compiler."
                },
                {
                    "type": "p",
                    "text": "Runningtsc --build(tsc -bfor short) will do the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Find all referenced projects",
                        "Detect if they are up-to-date",
                        "Build out-of-date projects in the correct order"
                    ]
                },
                {
                    "type": "p",
                    "text": "You can providetsc -bwith multiple config file paths (e.g.tsc -b src test).\nJust liketsc -p, specifying the config file name itself is unnecessary if it’s namedtsconfig.json."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "tsc -bCommandline"
                },
                {
                    "type": "p",
                    "text": "You can specify any number of config files:"
                },
                {
                    "type": "code",
                    "code": "shell> tsc -b# Use the tsconfig.json in the current directory> tsc -b src# Use src/tsconfig.json> tsc -b foo/prd.tsconfig.json bar# Use foo/prd.tsconfig.json and bar/tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "Don’t worry about ordering the files you pass on the commandline -tscwill re-order them if needed so that dependencies are always built first."
                },
                {
                    "type": "p",
                    "text": "There are also some flags specific totsc -b:"
                },
                {
                    "type": "list",
                    "items": [
                        "--verbose: Prints out verbose logging to explain what’s going on (may be combined with any other flag)",
                        "--dry: Shows what would be done but doesn’t actually build anything",
                        "--clean: Deletes the outputs of the specified projects (may be combined with--dry)",
                        "--force: Act as if all projects are out of date",
                        "--watch: Watch mode (may not be combined with any flag except--verbose)"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Caveats"
                },
                {
                    "type": "p",
                    "text": "Normally,tscwill produce outputs (.jsand.d.ts) in the presence of syntax or type errors, unlessnoEmitOnErroris on.\nDoing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see itoncebecause a subsequent build would skip building the now up-to-date project.\nFor this reason,tsc -beffectively acts as ifnoEmitOnErroris enabled for all projects."
                },
                {
                    "type": "p",
                    "text": "If you check in any build outputs (.js,.d.ts,.d.ts.map, etc.), you may need to run a--forcebuild after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "MSBuild"
                },
                {
                    "type": "p",
                    "text": "If you have an msbuild project, you can enable build mode by adding"
                },
                {
                    "type": "code",
                    "code": "xml<TypeScriptBuildMode>true</TypeScriptBuildMode>"
                },
                {
                    "type": "p",
                    "text": "to your proj file. This will enable automatic incremental build as well as cleaning."
                },
                {
                    "type": "p",
                    "text": "Note that as withtsconfig.json/-p, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file."
                },
                {
                    "type": "p",
                    "text": "Some teams have set up msbuild-based workflows wherein tsconfig files have the sameimplicitgraph ordering as the managed projects they are paired with.\nIf your solution is like this, you can continue to usemsbuildwithtsc -palong with project references; these are fully interoperable."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Guidance"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Overall Structure"
                },
                {
                    "type": "p",
                    "text": "With moretsconfig.jsonfiles, you’ll usually want to useConfiguration file inheritanceto centralize your common compiler options.\nThis way you can change a setting in one file rather than having to edit multiple files."
                },
                {
                    "type": "p",
                    "text": "Another good practice is to have a “solution”tsconfig.jsonfile that simply hasreferencesto all of your leaf-node projects and setsfilesto an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an emptyfilesarray if you have at least onereferencein atsconfig.jsonfile."
                },
                {
                    "type": "p",
                    "text": "This presents a simple entry point; e.g. in the TypeScript repo we simply runtsc -b srcto build all endpoints because we list all the subprojects insrc/tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "You can see these patterns in the TypeScript repo - seesrc/tsconfig_base.json,src/tsconfig.json, andsrc/tsc/tsconfig.jsonas key examples."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Structuring for relative modules"
                },
                {
                    "type": "p",
                    "text": "In general, not much is needed to transition a repo using relative modules.\nSimply place atsconfig.jsonfile in each subdirectory of a given parent folder, and addreferences to these config files to match the intended layering of the program.\nYou will need to either set theoutDirto an explicit subfolder of the output folder, or set therootDirto the common root of all project folders."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Structuring for outFiles"
                },
                {
                    "type": "p",
                    "text": "Layout for compilations usingoutFileis more flexible because relative paths don’t matter as much.\nThe TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/symbols.html",
            "title": "TypeScript: Documentation - Symbols",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Symbols"
                },
                {
                    "type": "p",
                    "text": "Starting with ECMAScript 2015,symbolis a primitive data type, just likenumberandstring."
                },
                {
                    "type": "p",
                    "text": "symbolvalues are created by calling theSymbolconstructor."
                },
                {
                    "type": "code",
                    "code": "tsletsym1=Symbol();letsym2=Symbol(\"key\");// optional string key"
                },
                {
                    "type": "p",
                    "text": "Symbols are immutable, and unique."
                },
                {
                    "type": "code",
                    "code": "tsletsym2=Symbol(\"key\");letsym3=Symbol(\"key\");sym2===sym3;// false, symbols are unique"
                },
                {
                    "type": "p",
                    "text": "Just like strings, symbols can be used as keys for object properties."
                },
                {
                    "type": "code",
                    "code": "tsconstsym=Symbol();letobj= {[sym]:\"value\",};console.log(obj[sym]);// \"value\""
                },
                {
                    "type": "p",
                    "text": "Symbols can also be combined with computed property declarations to declare object properties and class members."
                },
                {
                    "type": "code",
                    "code": "tsconstgetClassNameSymbol=Symbol();classC{[getClassNameSymbol]() {return\"C\";}}letc=newC();letclassName=c[getClassNameSymbol]();// \"C\""
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "unique symbol"
                },
                {
                    "type": "p",
                    "text": "To enable treating symbols as unique literals a special typeunique symbolis available.unique symbolis a subtype ofsymbol, and are produced only from callingSymbol()orSymbol.for(), or from explicit type annotations. This type is only allowed onconstdeclarations andreadonly staticproperties, and in order to reference a specific unique symbol, you’ll have to use thetypeofoperator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration."
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstsym1:uniquesymbol;// sym2 can only be a constant reference.letsym2:uniquesymbol=Symbol();A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.// Works - refers to a unique symbol, but its identity is tied to 'sym1'.letsym3:typeofsym1=sym1;// Also works.classC{staticreadonlyStaticSymbol:uniquesymbol=Symbol();}Try"
                },
                {
                    "type": "p",
                    "text": "Because eachunique symbolhas a completely separate identity, no twounique symboltypes are assignable or comparable to each other."
                },
                {
                    "type": "code",
                    "code": "tsconstsym2=Symbol();constsym3=Symbol();if(sym2===sym3) {This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.// ...}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Well-known Symbols"
                },
                {
                    "type": "p",
                    "text": "In addition to user-defined symbols, there are well-known built-in symbols.\nBuilt-in symbols are used to represent internal language behaviors."
                },
                {
                    "type": "p",
                    "text": "Here is a list of well-known symbols:"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.asyncIterator"
                },
                {
                    "type": "p",
                    "text": "A method that returns async iterator for an object, compatible to be used with for await..of loop."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.hasInstance"
                },
                {
                    "type": "p",
                    "text": "A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.isConcatSpreadable"
                },
                {
                    "type": "p",
                    "text": "A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.iterator"
                },
                {
                    "type": "p",
                    "text": "A method that returns the default iterator for an object. Called by the semantics of the for-of statement."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.match"
                },
                {
                    "type": "p",
                    "text": "A regular expression method that matches the regular expression against a string. Called by theString.prototype.matchmethod."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.replace"
                },
                {
                    "type": "p",
                    "text": "A regular expression method that replaces matched substrings of a string. Called by theString.prototype.replacemethod."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.search"
                },
                {
                    "type": "p",
                    "text": "A regular expression method that returns the index within a string that matches the regular expression. Called by theString.prototype.searchmethod."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.species"
                },
                {
                    "type": "p",
                    "text": "A function valued property that is the constructor function that is used to create derived objects."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.split"
                },
                {
                    "type": "p",
                    "text": "A regular expression method that splits a string at the indices that match the regular expression.\nCalled by theString.prototype.splitmethod."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.toPrimitive"
                },
                {
                    "type": "p",
                    "text": "A method that converts an object to a corresponding primitive value.\nCalled by theToPrimitiveabstract operation."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.toStringTag"
                },
                {
                    "type": "p",
                    "text": "A String value that is used in the creation of the default string description of an object.\nCalled by the built-in methodObject.prototype.toString."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Symbol.unscopables"
                },
                {
                    "type": "p",
                    "text": "An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",
            "title": "TypeScript: Documentation - Triple-Slash Directives",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Triple-Slash Directives"
                },
                {
                    "type": "p",
                    "text": "Triple-slash directives are single-line comments containing a single XML tag.\nThe contents of the comment are used as compiler directives."
                },
                {
                    "type": "p",
                    "text": "Triple-slash directives areonlyvalid at the top of their containing file.\nA triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives.\nIf they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <reference path=\"...\" />"
                },
                {
                    "type": "p",
                    "text": "The/// <reference path=\"...\" />directive is the most common of this group.\nIt serves as a declaration ofdependencybetween files."
                },
                {
                    "type": "p",
                    "text": "Triple-slash references instruct the compiler to include additional files in the compilation process."
                },
                {
                    "type": "p",
                    "text": "They also serve as a method to order the output when usingoutoroutFile.\nFiles are emitted to the output file location in the same order as the input after preprocessing pass."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preprocessing input files"
                },
                {
                    "type": "p",
                    "text": "The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives.\nDuring this process, additional files are added to the compilation."
                },
                {
                    "type": "p",
                    "text": "The process starts with a set ofroot files;\nthese are the file names specified on the command-line or in thefileslist in thetsconfig.jsonfile.\nThese root files are preprocessed in the same order they are specified.\nBefore a file is added to the list, all triple-slash references in it are processed, and their targets included.\nTriple-slash references are resolved in a depth-first manner, in the order they have been seen in the file."
                },
                {
                    "type": "p",
                    "text": "A triple-slash reference path is resolved relative to the containing file, if a relative path is used."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Errors"
                },
                {
                    "type": "p",
                    "text": "It is an error to reference a file that does not exist.\nIt is an error for a file to have a triple-slash reference to itself."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using--noResolve"
                },
                {
                    "type": "p",
                    "text": "If the compiler flagnoResolveis specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <reference types=\"...\" />"
                },
                {
                    "type": "p",
                    "text": "Similar to a/// <reference path=\"...\" />directive, which serves as a declaration ofdependency, a/// <reference types=\"...\" />directive declares a dependency on a package."
                },
                {
                    "type": "p",
                    "text": "The process of resolving these package names is similar to the process of resolving module names in animportstatement.\nAn easy way to think of triple-slash-reference-types directives are as animportfor declaration packages."
                },
                {
                    "type": "p",
                    "text": "For example, including/// <reference types=\"node\" />in a declaration file declares that this file uses names declared in@types/node/index.d.ts;\nand thus, this package needs to be included in the compilation along with the declaration file."
                },
                {
                    "type": "p",
                    "text": "Use these directives only when you’re authoring ad.tsfile by hand."
                },
                {
                    "type": "p",
                    "text": "For declaration files generated during compilation, the compiler will automatically add/// <reference types=\"...\" />for you;\nA/// <reference types=\"...\" />in a generated declaration file is addedif and only ifthe resulting file uses any declarations from the referenced package."
                },
                {
                    "type": "p",
                    "text": "For declaring a dependency on an@typespackage in a.tsfile, usetypeson the command line or in yourtsconfig.jsoninstead.\nSeeusing@types,typeRootsandtypesintsconfig.jsonfilesfor more details."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <reference lib=\"...\" />"
                },
                {
                    "type": "p",
                    "text": "This directive allows a file to explicitly include an existing built-inlibfile."
                },
                {
                    "type": "p",
                    "text": "Built-inlibfiles are referenced in the same fashion as thelibcompiler option intsconfig.json(e.g. uselib=\"es2015\"and notlib=\"lib.es2015.d.ts\", etc.)."
                },
                {
                    "type": "p",
                    "text": "For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors likeSymbolorIterable, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types."
                },
                {
                    "type": "p",
                    "text": "For example, adding/// <reference lib=\"es2017.string\" />to one of the files in a compilation is equivalent to compiling with--lib es2017.string."
                },
                {
                    "type": "code",
                    "code": "ts///<referencelib=\"es2017.string\"/>\"foo\".padStart(4);"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <reference no-default-lib=\"true\"/>"
                },
                {
                    "type": "p",
                    "text": "This directive marks a file as adefault library.\nYou will see this comment at the top oflib.d.tsand its different variants."
                },
                {
                    "type": "p",
                    "text": "This directive instructs the compiler tonotinclude the default library (i.e.lib.d.ts) in the compilation.\nThe impact here is similar to passingnoLibon the command line."
                },
                {
                    "type": "p",
                    "text": "Also note that when passingskipDefaultLibCheck, the compiler will only skip checking files with/// <reference no-default-lib=\"true\"/>."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <amd-module />"
                },
                {
                    "type": "p",
                    "text": "By default AMD modules are generated anonymous.\nThis can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g.r.js)."
                },
                {
                    "type": "p",
                    "text": "Theamd-moduledirective allows passing an optional module name to the compiler:"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "amdModule.ts"
                },
                {
                    "type": "code",
                    "code": "ts///<amd-modulename=\"NamedModule\"/>exportclassC{}"
                },
                {
                    "type": "p",
                    "text": "Will result in assigning the nameNamedModuleto the module as part of calling the AMDdefine:"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "amdModule.js"
                },
                {
                    "type": "code",
                    "code": "jsdefine(\"NamedModule\", [\"require\",\"exports\"],function(require,exports) {varC= (function() {functionC() {}returnC;})();exports.C=C;});"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "/// <amd-dependency />"
                },
                {
                    "type": "p",
                    "text": "Note: this directive has been deprecated. Useimport \"moduleName\";statements instead."
                },
                {
                    "type": "p",
                    "text": "/// <amd-dependency path=\"x\" />informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call."
                },
                {
                    "type": "p",
                    "text": "Theamd-dependencydirective can also have an optionalnameproperty; this allows passing an optional name for an amd-dependency:"
                },
                {
                    "type": "code",
                    "code": "ts///<amd-dependencypath=\"legacy/moduleA\"name=\"moduleA\"/>declarevarmoduleA:MyType;moduleA.callStuff();"
                },
                {
                    "type": "p",
                    "text": "Generated JS code:"
                },
                {
                    "type": "code",
                    "code": "jsdefine([\"require\",\"exports\",\"legacy/moduleA\"],function(require,exports,moduleA) {moduleA.callStuff();});"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
            "title": "TypeScript: Documentation - What is a tsconfig.json",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "What is a tsconfig.json"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Overview"
                },
                {
                    "type": "p",
                    "text": "The presence of atsconfig.jsonfile in a directory indicates that the directory is the root of a TypeScript project.\nThetsconfig.jsonfile specifies the root files and the compiler options required to compile the project."
                },
                {
                    "type": "p",
                    "text": "JavaScript projects can use ajsconfig.jsonfile instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default."
                },
                {
                    "type": "p",
                    "text": "A project is compiled in one of the following ways:"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usingtsconfig.jsonorjsconfig.json"
                },
                {
                    "type": "list",
                    "items": [
                        "By invoking tsc with no input files, in which case the compiler searches for thetsconfig.jsonfile starting in the current directory and continuing up the parent directory chain.",
                        "By invoking tsc with no input files and a--project(or just-p) command line option that specifies the path of a directory containing atsconfig.jsonfile, or a path to a valid.jsonfile containing the configurations."
                    ]
                },
                {
                    "type": "p",
                    "text": "When input files are specified on the command line,tsconfig.jsonfiles are ignored."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Examples"
                },
                {
                    "type": "p",
                    "text": "Exampletsconfig.jsonfiles:"
                },
                {
                    "type": "list",
                    "items": [
                        "Using thefilesproperty{\"compilerOptions\": {\"module\":\"commonjs\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"sourceMap\":true},\"files\": [\"core.ts\",\"sys.ts\",\"types.ts\",\"scanner.ts\",\"parser.ts\",\"utilities.ts\",\"binder.ts\",\"checker.ts\",\"emitter.ts\",\"program.ts\",\"commandLineParser.ts\",\"tsc.ts\",\"diagnosticInformationMap.generated.ts\"]}",
                        "Using theincludeandexcludeproperties{\"compilerOptions\": {\"module\":\"system\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"outFile\":\"../../built/local/tsc.js\",\"sourceMap\":true},\"include\": [\"src/**/*\"],\"exclude\": [\"**/*.spec.ts\"]}"
                    ]
                },
                {
                    "type": "p",
                    "text": "Using thefilesproperty"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"module\":\"commonjs\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"sourceMap\":true},\"files\": [\"core.ts\",\"sys.ts\",\"types.ts\",\"scanner.ts\",\"parser.ts\",\"utilities.ts\",\"binder.ts\",\"checker.ts\",\"emitter.ts\",\"program.ts\",\"commandLineParser.ts\",\"tsc.ts\",\"diagnosticInformationMap.generated.ts\"]}"
                },
                {
                    "type": "p",
                    "text": "Using theincludeandexcludeproperties"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"module\":\"system\",\"noImplicitAny\":true,\"removeComments\":true,\"preserveConstEnums\":true,\"outFile\":\"../../built/local/tsc.js\",\"sourceMap\":true},\"include\": [\"src/**/*\"],\"exclude\": [\"**/*.spec.ts\"]}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TSConfig Bases"
                },
                {
                    "type": "p",
                    "text": "Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use atgithub.com/tsconfig/bases.\nThese aretsconfig.jsonfiles which your project extends from which simplifies yourtsconfig.jsonby handling the runtime support."
                },
                {
                    "type": "p",
                    "text": "For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module@tsconfig/node12:"
                },
                {
                    "type": "code",
                    "code": "{\"extends\":\"@tsconfig/node12/tsconfig.json\",\"compilerOptions\": {\"preserveConstEnums\":true},\"include\": [\"src/**/*\"],\"exclude\": [\"**/*.spec.ts\"]}"
                },
                {
                    "type": "p",
                    "text": "This lets yourtsconfig.jsonfocus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Details"
                },
                {
                    "type": "p",
                    "text": "The\"compilerOptions\"property can be omitted, in which case the compiler’s defaults are used. See our full list of supportedCompiler Options."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TSConfig Reference"
                },
                {
                    "type": "p",
                    "text": "To learn more about the hundreds of configuration options in theTSConfig Reference."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Schema"
                },
                {
                    "type": "p",
                    "text": "Thetsconfig.jsonSchema can be found atthe JSON Schema Store."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html",
            "title": "TypeScript: Documentation - Type Checking JavaScript Files",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Type Checking JavaScript Files"
                },
                {
                    "type": "p",
                    "text": "Here are some notable differences on how checking works in.jsfiles compared to.tsfiles."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Properties are inferred from assignments in class bodies"
                },
                {
                    "type": "p",
                    "text": "ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals."
                },
                {
                    "type": "p",
                    "text": "In a.jsfile, the compiler infers properties from property assignments inside the class body.\nThe type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null.\nIn that case, the type is the union of the types of all the right-hand values in these assignments.\nProperties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional."
                },
                {
                    "type": "code",
                    "code": "jsclassC{constructor() {this.constructorOnly=0;this.constructorUnknown=undefined;}method() {this.constructorOnly=false;Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.this.constructorUnknown=\"plunkbat\";// ok, constructorUnknown is string | undefinedthis.methodOnly=\"ok\";// ok, but methodOnly could also be undefined}method2() {this.methodOnly=true;// also, ok, methodOnly's type is string | boolean | undefined}}Try"
                },
                {
                    "type": "p",
                    "text": "If properties are never set in the class body, they are considered unknown.\nIf your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type.\nYou don’t even have to give a value if it will be initialized later:"
                },
                {
                    "type": "code",
                    "code": "jsclassC{constructor() {/**@type{number | undefined}*/this.prop=undefined;/**@type{number | undefined}*/this.count;}}letc=newC();c.prop=0;// OKc.count=\"string\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Constructor functions are equivalent to classes"
                },
                {
                    "type": "p",
                    "text": "Before ES2015, JavaScript used constructor functions instead of classes.\nThe compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes.\nThe property inference rules described above work exactly the same way."
                },
                {
                    "type": "code",
                    "code": "jsfunctionC() {this.constructorOnly=0;this.constructorUnknown=undefined;}C.prototype.method=function() {this.constructorOnly=false;Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.this.constructorUnknown=\"plunkbat\";// OK, the type is string | undefined};Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "CommonJS modules are supported"
                },
                {
                    "type": "p",
                    "text": "In a.jsfile, TypeScript understands the CommonJS module format.\nAssignments toexportsandmodule.exportsare recognized as export declarations.\nSimilarly,requirefunction calls are recognized as module imports. For example:"
                },
                {
                    "type": "code",
                    "code": "js// same as `import module \"fs\"`constfs=require(\"fs\");// same as `export function readFile`module.exports.readFile=function(f) {returnfs.readFileSync(f);};"
                },
                {
                    "type": "p",
                    "text": "The module support in JavaScript is much more syntactically forgiving than TypeScript’s module support.\nMost combinations of assignments and declarations are supported."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes, functions, and object literals are namespaces"
                },
                {
                    "type": "p",
                    "text": "Classes are namespaces in.jsfiles.\nThis can be used to nest classes, for example:"
                },
                {
                    "type": "code",
                    "code": "jsclassC{}C.D=class{};Try"
                },
                {
                    "type": "p",
                    "text": "And, for pre-ES2015 code, it can be used to simulate static methods:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionOuter() {this.y=2;}Outer.Inner=function() {this.yy=2;};Outer.Inner();Try"
                },
                {
                    "type": "p",
                    "text": "It can also be used to create simple namespaces:"
                },
                {
                    "type": "code",
                    "code": "jsvarns= {};ns.C=class{};ns.func=function() {};ns;Try"
                },
                {
                    "type": "p",
                    "text": "Other variants are allowed as well:"
                },
                {
                    "type": "code",
                    "code": "js// IIFEvarns= (function(n) {returnn|| {};})();ns.CONST=1;// defaulting to globalvarassign=assign||function() {// code goes here};assign.extra=1;Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Object literals are open-ended"
                },
                {
                    "type": "p",
                    "text": "In a.tsfile, an object literal that initializes a variable declaration gives its type to the declaration.\nNo new members can be added that were not specified in the original literal.\nThis rule is relaxed in a.jsfile; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally.\nFor instance:"
                },
                {
                    "type": "code",
                    "code": "jsvarobj= {a:1};obj.b=2;// AllowedTry"
                },
                {
                    "type": "p",
                    "text": "Object literals behave as if they have an index signature[x:string]: anythat allows them to be treated as open maps instead of closed objects."
                },
                {
                    "type": "p",
                    "text": "Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{{a: number}}*/varobj= {a:1};obj.b=2;Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "null, undefined, and empty array initializers are of type any or any[]"
                },
                {
                    "type": "p",
                    "text": "Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on.\nAny variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on.\nThe only exception is for properties that have multiple initializers as described above."
                },
                {
                    "type": "code",
                    "code": "jsfunctionFoo(i=null) {if(!i)i=1;varj=undefined;j=2;this.l= [];}varfoo=newFoo();foo.l.push(foo.i);foo.l.push(\"end\");Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function parameters are optional by default"
                },
                {
                    "type": "p",
                    "text": "Since there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in.jsfile are considered optional.\nCalls with fewer arguments than the declared number of parameters are allowed."
                },
                {
                    "type": "p",
                    "text": "It is important to note that it is an error to call a function with too many arguments."
                },
                {
                    "type": "p",
                    "text": "For instance:"
                },
                {
                    "type": "code",
                    "code": "jsfunctionbar(a,b) {console.log(a+\" \"+b);}bar(1);// OK, second argument considered optionalbar(1,2);bar(1,2,3);// Error, too many argumentsExpected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.Try"
                },
                {
                    "type": "p",
                    "text": "JSDoc annotated functions are excluded from this rule.\nUse JSDoc optional parameter syntax ([]) to express optionality. e.g.:"
                },
                {
                    "type": "code",
                    "code": "js/***@param{string}[somebody]- Somebody's name.*/functionsayHello(somebody) {if(!somebody) {somebody=\"John Doe\";}console.log(\"Hello \"+somebody);}sayHello();Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Var-args parameter declaration inferred from use ofarguments"
                },
                {
                    "type": "p",
                    "text": "A function whose body has a reference to theargumentsreference is implicitly considered to have a var-arg parameter (i.e.(...arg: any[]) => any). Use JSDoc var-arg syntax to specify the type of the arguments."
                },
                {
                    "type": "code",
                    "code": "js/**@param{...number}args*/functionsum(/* numbers */) {vartotal=0;for(vari=0;i<arguments.length;i++) {total+=arguments[i];}returntotal;}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Unspecified type parameters default toany"
                },
                {
                    "type": "p",
                    "text": "Since there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults toany."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In extends clause"
                },
                {
                    "type": "p",
                    "text": "For instance,React.Componentis defined to have two type parameters,PropsandState.\nIn a.jsfile, there is no legal way to specify these in the extends clause. By default the type arguments will beany:"
                },
                {
                    "type": "code",
                    "code": "jsimport{Component}from\"react\";classMyComponentextendsComponent{render() {this.props.b;// Allowed, since this.props is of type any}}"
                },
                {
                    "type": "p",
                    "text": "Use JSDoc@augmentsto specify the types explicitly. for instance:"
                },
                {
                    "type": "code",
                    "code": "jsimport{Component}from\"react\";/***@augments{Component<{a: number}, State>}*/classMyComponentextendsComponent{render() {this.props.b;// Error: b does not exist on {a:number}}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In JSDoc references"
                },
                {
                    "type": "p",
                    "text": "An unspecified type argument in JSDoc defaults to any:"
                },
                {
                    "type": "code",
                    "code": "js/**@type{Array} */varx= [];x.push(1);// OKx.push(\"string\");// OK, x is of type Array<any>/**@type{Array.<number>} */vary= [];y.push(1);// OKy.push(\"string\");// Error, string is not assignable to numberTry"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In function calls"
                },
                {
                    "type": "p",
                    "text": "A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default toany. For example:"
                },
                {
                    "type": "code",
                    "code": "jsvarp=newPromise((resolve,reject)=>{reject();});p;// Promise<any>;"
                },
                {
                    "type": "p",
                    "text": "To learn all of the features available in JSDoc, seethe reference."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "JS Projects Utilizing TypeScript"
                },
                {
                    "type": "p",
                    "text": "How to add type checking to JavaScript files using TypeScript"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "JSDoc Reference"
                },
                {
                    "type": "p",
                    "text": "What JSDoc does TypeScript-powered JavaScript support?"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html",
            "title": "TypeScript: Documentation - Type Compatibility",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Type Compatibility"
                },
                {
                    "type": "p",
                    "text": "Type compatibility in TypeScript is based on structural subtyping.\nStructural typing is a way of relating types based solely on their members.\nThis is in contrast with nominal typing.\nConsider the following code:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}classDog{name:string;}letpet:Pet;// OK, because of structural typingpet=newDog();"
                },
                {
                    "type": "p",
                    "text": "In nominally-typed languages like C# or Java, the equivalent code would be an error because theDogclass does not explicitly describe itself as being an implementer of thePetinterface."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s structural type system was designed based on how JavaScript code is typically written.\nBecause JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "A Note on Soundness"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Starting out"
                },
                {
                    "type": "p",
                    "text": "The basic rule for TypeScript’s structural type system is thatxis compatible withyifyhas at least the same members asx. For example consider the following code involving an interface namedPetwhich has anameproperty:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}letpet:Pet;// dog's inferred type is { name: string; owner: string; }letdog= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};pet=dog;"
                },
                {
                    "type": "p",
                    "text": "To check whetherdogcan be assigned topet, the compiler checks each property ofpetto find a corresponding compatible property indog.\nIn this case,dogmust have a member callednamethat is a string. It does, so the assignment is allowed."
                },
                {
                    "type": "p",
                    "text": "The same rule for assignment is used when checking function call arguments:"
                },
                {
                    "type": "code",
                    "code": "tsinterfacePet{name:string;}letdog= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};functiongreet(pet:Pet) {console.log(\"Hello, \"+pet.name);}greet(dog);// OK"
                },
                {
                    "type": "p",
                    "text": "Note thatdoghas an extraownerproperty, but this does not create an error.\nOnly members of the target type (Petin this case) are considered when\nchecking for compatibility. This comparison process proceeds recursively,\nexploring the type of each member and sub-member."
                },
                {
                    "type": "p",
                    "text": "Be aware, however, that object literalsmay only specify known properties.\nFor example, because we have explicitly specified thatdogis\nof typePet, the following code is invalid:"
                },
                {
                    "type": "code",
                    "code": "tsletdog:Pet= {name:\"Lassie\",owner:\"Rudd Weatherwax\"};// Error"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Comparing two functions"
                },
                {
                    "type": "p",
                    "text": "While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved.\nLet’s start with a basic example of two functions that differ only in their parameter lists:"
                },
                {
                    "type": "code",
                    "code": "tsletx= (a:number)=>0;lety= (b:number,s:string)=>0;y=x;// OKx=y;// Error"
                },
                {
                    "type": "p",
                    "text": "To check ifxis assignable toy, we first look at the parameter list.\nEach parameter inxmust have a corresponding parameter inywith a compatible type.\nNote that the names of the parameters are not considered, only their types.\nIn this case, every parameter ofxhas a corresponding compatible parameter iny, so the assignment is allowed."
                },
                {
                    "type": "p",
                    "text": "The second assignment is an error, becauseyhas a required second parameter thatxdoes not have, so the assignment is disallowed."
                },
                {
                    "type": "p",
                    "text": "You may be wondering why we allow ‘discarding’ parameters like in the exampley = x.\nThe reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript.\nFor example,Array#forEachprovides three parameters to the callback function: the array element, its index, and the containing array.\nNevertheless, it’s very useful to provide a callback that only uses the first parameter:"
                },
                {
                    "type": "code",
                    "code": "tsletitems= [1,2,3];// Don't force these extra parametersitems.forEach((item,index,array)=>console.log(item));// Should be OK!items.forEach((item)=>console.log(item));"
                },
                {
                    "type": "p",
                    "text": "Now let’s look at how return types are treated, using two functions that differ only by their return type:"
                },
                {
                    "type": "code",
                    "code": "tsletx= ()=>({name:\"Alice\"});lety= ()=>({name:\"Alice\",location:\"Seattle\"});x=y;// OKy=x;// Error, because x() lacks a location property"
                },
                {
                    "type": "p",
                    "text": "The type system enforces that the source function’s return type be a subtype of the target type’s return type."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Function Parameter Bivariance"
                },
                {
                    "type": "p",
                    "text": "When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa.\nThis is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type.\nIn practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:"
                },
                {
                    "type": "code",
                    "code": "tsenumEventType{Mouse,Keyboard,}interfaceEvent{timestamp:number;}interfaceMyMouseEventextendsEvent{x:number;y:number;}interfaceMyKeyEventextendsEvent{keyCode:number;}functionlistenEvent(eventType:EventType,handler: (n:Event)=>void) {/* ... */}// Unsound, but useful and commonlistenEvent(EventType.Mouse, (e:MyMouseEvent)=>console.log(e.x+\",\"+e.y));// Undesirable alternatives in presence of soundnesslistenEvent(EventType.Mouse, (e:Event)=>console.log((easMyMouseEvent).x+\",\"+ (easMyMouseEvent).y));listenEvent(EventType.Mouse, ((e:MyMouseEvent)=>console.log(e.x+\",\"+e.y))as(e:Event)=>void);// Still disallowed (clear error). Type safety enforced for wholly incompatible typeslistenEvent(EventType.Mouse, (e:number)=>console.log(e));"
                },
                {
                    "type": "p",
                    "text": "You can have TypeScript raise errors when this happens via the compiler flagstrictFunctionTypes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optional Parameters and Rest Parameters"
                },
                {
                    "type": "p",
                    "text": "When comparing functions for compatibility, optional and required parameters are interchangeable.\nExtra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error."
                },
                {
                    "type": "p",
                    "text": "When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters."
                },
                {
                    "type": "p",
                    "text": "This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passingundefinedin that position is equivalent for most functions."
                },
                {
                    "type": "p",
                    "text": "The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioninvokeLater(args:any[],callback: (...args:any[])=>void) {/* ... Invoke callback with 'args' ... */}// Unsound - invokeLater \"might\" provide any number of argumentsinvokeLater([1,2], (x,y)=>console.log(x+\", \"+y));// Confusing (x and y are actually required) and undiscoverableinvokeLater([1,2], (x?,y?)=>console.log(x+\", \"+y));"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Functions with overloads"
                },
                {
                    "type": "p",
                    "text": "When a function has overloads, each overload in the target type must be matched by a compatible signature on the source type.\nThis ensures that the source function can be called in all the same cases as the target function."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Enums"
                },
                {
                    "type": "p",
                    "text": "Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,"
                },
                {
                    "type": "code",
                    "code": "tsenumStatus{Ready,Waiting,}enumColor{Red,Blue,Green,}letstatus=Status.Ready;status=Color.Green;// Error"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type.\nWhen comparing two objects of a class type, only members of the instance are compared.\nStatic members and constructors do not affect compatibility."
                },
                {
                    "type": "code",
                    "code": "tsclassAnimal{feet:number;constructor(name:string,numFeet:number) {}}classSize{feet:number;constructor(numFeet:number) {}}leta:Animal;lets:Size;a=s;// OKs=a;// OK"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Private and protected members in classes"
                },
                {
                    "type": "p",
                    "text": "Private and protected members in a class affect their compatibility.\nWhen an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class.\nLikewise, the same applies for an instance with a protected member.\nThis allows a class to be assignment compatible with its super class, butnotwith classes from a different inheritance hierarchy which otherwise have the same shape."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceEmpty<T> {}letx:Empty<number>;lety:Empty<string>;x=y;// OK, because y matches structure of x"
                },
                {
                    "type": "p",
                    "text": "In the above,xandyare compatible because their structures do not use the type argument in a differentiating way.\nChanging this example by adding a member toEmpty<T>shows how this works:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceNotEmpty<T> {data:T;}letx:NotEmpty<number>;lety:NotEmpty<string>;x=y;// Error, because x and y are not compatible"
                },
                {
                    "type": "p",
                    "text": "In this way, a generic type that has its type arguments specified acts just like a non-generic type."
                },
                {
                    "type": "p",
                    "text": "For generic types that do not have their type arguments specified, compatibility is checked by specifyinganyin place of all unspecified type arguments.\nThe resulting types are then checked for compatibility, just as in the non-generic case."
                },
                {
                    "type": "p",
                    "text": "For example,"
                },
                {
                    "type": "code",
                    "code": "tsletidentity=function<T>(x:T):T{// ...};letreverse=function<U>(y:U):U{// ...};identity=reverse;// OK, because (x: any) => any matches (y: any) => any"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Advanced Topics"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Subtype vs Assignment"
                },
                {
                    "type": "p",
                    "text": "So far, we’ve used “compatible”, which is not a term defined in the language spec.\nIn TypeScript, there are two kinds of compatibility: subtype and assignment.\nThese differ only in that assignment extends subtype compatibility with rules to allow assignment to and fromany, and to and fromenumwith corresponding numeric values."
                },
                {
                    "type": "p",
                    "text": "Different places in the language use one of the two compatibility mechanisms, depending on the situation.\nFor practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of theimplementsandextendsclauses."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "any,unknown,object,void,undefined,null, andneverassignability"
                },
                {
                    "type": "p",
                    "text": "The following table summarizes assignability between some abstract types.\nRows indicate what each is assignable to, columns indicate what is assignable to them.\nA ”✓” indicates a combination that is compatible only whenstrictNullChecksis off."
                },
                {
                    "type": "p",
                    "text": "ReiteratingThe Basics:"
                },
                {
                    "type": "list",
                    "items": [
                        "Everything is assignable to itself.",
                        "anyandunknownare the same in terms of what is assignable to them, different in thatunknownis not assignable to anything exceptany.",
                        "unknownandneverare like inverses of each other.\nEverything is assignable tounknown,neveris assignable to everything.\nNothing is assignable tonever,unknownis not assignable to anything (exceptany).",
                        "voidis not assignable to or from anything, with the following exceptions:any,unknown,never,undefined, andnull(ifstrictNullChecksis off, see table for details).",
                        "WhenstrictNullChecksis off,nullandundefinedare similar tonever: assignable to most types, most types are not assignable to them.\nThey are assignable to each other.",
                        "WhenstrictNullChecksis on,nullandundefinedbehave more likevoid: not assignable to or from anything, except forany,unknown, andvoid(undefinedis always assignable tovoid)."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
            "title": "TypeScript: Documentation - Type Inference",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Type Inference"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code"
                },
                {
                    "type": "code",
                    "code": "tsletx=3;let x: numberTry"
                },
                {
                    "type": "p",
                    "text": "The type of thexvariable is inferred to benumber.\nThis kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types."
                },
                {
                    "type": "p",
                    "text": "In most cases, type inference is straightforward.\nIn the following sections, we’ll explore some of the nuances in how types are inferred."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Best common type"
                },
                {
                    "type": "p",
                    "text": "When a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,"
                },
                {
                    "type": "code",
                    "code": "tsletx= [0,1,null];let x: (number | null)[]Try"
                },
                {
                    "type": "p",
                    "text": "To infer the type ofxin the example above, we must consider the type of each array element.\nHere we are given two choices for the type of the array:numberandnull.\nThe best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates."
                },
                {
                    "type": "p",
                    "text": "Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:"
                },
                {
                    "type": "code",
                    "code": "tsletzoo= [newRhino(),newElephant(),newSnake()];let zoo: (Rhino | Elephant | Snake)[]Try"
                },
                {
                    "type": "p",
                    "text": "Ideally, we may wantzooto be inferred as anAnimal[], but because there is no object that is strictly of typeAnimalin the array, we make no inference about the array element type.\nTo correct this, explicitly provide the type when no one type is a super type of all other candidates:"
                },
                {
                    "type": "code",
                    "code": "tsletzoo:Animal[] = [newRhino(),newElephant(),newSnake()];let zoo: Animal[]Try"
                },
                {
                    "type": "p",
                    "text": "When no best common type is found, the resulting inference is the union array type,(Rhino | Elephant | Snake)[]."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Contextual Typing"
                },
                {
                    "type": "p",
                    "text": "Type inference also works in “the other direction” in some cases in TypeScript.\nThis is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onmousedown=function(mouseEvent) {console.log(mouseEvent.button);console.log(mouseEvent.kangaroo);Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.};Try"
                },
                {
                    "type": "p",
                    "text": "Here, the TypeScript type checker used the type of theWindow.onmousedownfunction to infer the type of the function expression on the right hand side of the assignment.\nWhen it did so, it was able to infer thetypeof themouseEventparameter, which does contain abuttonproperty, but not akangarooproperty."
                },
                {
                    "type": "p",
                    "text": "This works because window already hasonmousedowndeclared in its type:"
                },
                {
                    "type": "code",
                    "code": "ts// Declares there is a global variable called 'window'declarevarwindow:Window&typeofglobalThis;// Which is declared as (simplified):interfaceWindowextendsGlobalEventHandlers{// ...}// Which defines a lot of known handler eventsinterfaceGlobalEventHandlers{onmousedown: ((this:GlobalEventHandlers,ev:MouseEvent)=>any) |null;// ...}"
                },
                {
                    "type": "p",
                    "text": "TypeScript is smart enough to infer types in other contexts as well:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onscroll=function(uiEvent) {console.log(uiEvent.button);Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.};Try"
                },
                {
                    "type": "p",
                    "text": "Based on the fact that the above function is being assigned toWindow.onscroll, TypeScript knows thatuiEventis aUIEvent, and not aMouseEventlike the previous example.UIEventobjects contain nobuttonproperty, and so TypeScript will throw an error."
                },
                {
                    "type": "p",
                    "text": "If this function were not in a contextually typed position, the function’s argument would implicitly have typeany, and no error would be issued (unless you are using thenoImplicitAnyoption):"
                },
                {
                    "type": "code",
                    "code": "tsconsthandler=function(uiEvent) {console.log(uiEvent.button);// <- OK};Try"
                },
                {
                    "type": "p",
                    "text": "We can also explicitly give type information to the function’s argument to override any contextual type:"
                },
                {
                    "type": "code",
                    "code": "tswindow.onscroll=function(uiEvent:any) {console.log(uiEvent.button);// <- Now, no error is given};Try"
                },
                {
                    "type": "p",
                    "text": "However, this code will logundefined, sinceuiEventhas no property calledbutton."
                },
                {
                    "type": "p",
                    "text": "Contextual typing applies in many cases.\nCommon cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements.\nThe contextual type also acts as a candidate type in best common type. For example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreateZoo():Animal[] {return[newRhino(),newElephant(),newSnake()];}Try"
                },
                {
                    "type": "p",
                    "text": "In this example, best common type has a set of four candidates:Animal,Rhino,Elephant, andSnake.\nOf these,Animalcan be chosen by the best common type algorithm."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html",
            "title": "TypeScript: Documentation - TypeScript for the New Programmer",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript for the New Programmer"
                },
                {
                    "type": "p",
                    "text": "Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!"
                },
                {
                    "type": "p",
                    "text": "You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript.\nThe relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What is JavaScript? A Brief History"
                },
                {
                    "type": "p",
                    "text": "JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers.\nAt the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual.\nDue to this, early web browsers executed such code pretty slowly.\nOver time, though, JS became more and more popular, and web developers started using it to create interactive experiences."
                },
                {
                    "type": "p",
                    "text": "Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more.\nOn modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code.\nThis is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for richapplicationsof all kinds."
                },
                {
                    "type": "p",
                    "text": "More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js.\nThe “run anywhere” nature of JS makes it an attractive choice for cross-platform development.\nThere are many developers these days that useonlyJavaScript to program their entire stack!"
                },
                {
                    "type": "p",
                    "text": "To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines.\nEvery language has its ownquirks— oddities and surprises, and JavaScript’s humble beginning makes it havemanyof these. Some examples:"
                },
                {
                    "type": "list",
                    "items": [
                        "JavaScript’s equality operator (==)coercesits operands, leading to unexpected behavior:jsif(\"\"==0) {// It is! But why??}if(1<x<3) {// True for *any* value of x!}",
                        "JavaScript also allows accessing properties which aren’t present:jsconstobj= {width:10,height:15};// Why is this NaN? Spelling is hard!constarea=obj.width*obj.heigth;"
                    ]
                },
                {
                    "type": "p",
                    "text": "JavaScript’s equality operator (==)coercesits operands, leading to unexpected behavior:"
                },
                {
                    "type": "code",
                    "code": "jsif(\"\"==0) {// It is! But why??}if(1<x<3) {// True for *any* value of x!}"
                },
                {
                    "type": "p",
                    "text": "JavaScript also allows accessing properties which aren’t present:"
                },
                {
                    "type": "code",
                    "code": "jsconstobj= {width:10,height:15};// Why is this NaN? Spelling is hard!constarea=obj.width*obj.heigth;"
                },
                {
                    "type": "p",
                    "text": "Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running.\nWhen writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript: A Static Type Checker"
                },
                {
                    "type": "p",
                    "text": "We said earlier that some languages wouldn’t allow those buggy programs to run at all.\nDetecting errors in code without running it is referred to asstatic checking.\nDetermining what’s an error and what’s not based on the kinds of values being operated on is known as statictypechecking."
                },
                {
                    "type": "p",
                    "text": "TypeScript checks a program for errors before execution, and does so based on thekinds of values, making it astatic type checker.\nFor example, the last example above has an error because of thetypeofobj.\nHere’s the error TypeScript found:"
                },
                {
                    "type": "code",
                    "code": "tsconstobj= {width:10,height:15};constarea=obj.width*obj.heigth;Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "A Typed Superset of JavaScript"
                },
                {
                    "type": "p",
                    "text": "How does TypeScript relate to JavaScript, though?"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Syntax"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a language that is asupersetof JavaScript: JS syntax is therefore legal TS.\nSyntax refers to the way we write text to form a program.\nFor example, this code has asyntaxerror because it’s missing a):"
                },
                {
                    "type": "code",
                    "code": "tsleta= (4')' expected.1005')' expected.Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript doesn’t consider any JavaScript code to be an error because of its syntax.\nThis means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Types"
                },
                {
                    "type": "p",
                    "text": "However, TypeScript is atypedsuperset, meaning that it adds rules about how different kinds of values can be used.\nThe earlier error aboutobj.heigthwas not asyntaxerror: it is an error of using some kind of value (atype) in an incorrect way."
                },
                {
                    "type": "p",
                    "text": "As another example, this is JavaScript code that you can run in your browser, and itwilllog a value:"
                },
                {
                    "type": "code",
                    "code": "jsconsole.log(4/ []);"
                },
                {
                    "type": "p",
                    "text": "This syntactically-legal program logsInfinity.\nTypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:"
                },
                {
                    "type": "code",
                    "code": "tsconsole.log(4/[]);The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.Try"
                },
                {
                    "type": "p",
                    "text": "It’s possible you reallydidintend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake.\nTypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible.\n(Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)"
                },
                {
                    "type": "p",
                    "text": "If you move some code from a JavaScript file to a TypeScript file, you might seetype errorsdepending on how the code is written.\nThese may be legitimate problems with the code, or TypeScript being overly conservative.\nThroughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Runtime Behavior"
                },
                {
                    "type": "p",
                    "text": "TypeScript is also a programming language that preserves theruntime behaviorof JavaScript.\nFor example, dividing by zero in JavaScript producesInfinityinstead of throwing a runtime exception.\nAs a principle, TypeScriptneverchanges the runtime behavior of JavaScript code."
                },
                {
                    "type": "p",
                    "text": "This means that if you move code from JavaScript to TypeScript, it isguaranteedto run the same way, even if TypeScript thinks that the code has type errors."
                },
                {
                    "type": "p",
                    "text": "Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Erased Types"
                },
                {
                    "type": "p",
                    "text": "Roughly speaking, once TypeScript’s compiler is done with checking your code, iterasesthe types to produce the resulting “compiled” code.\nThis means that once your code is compiled, the resulting plain JS code has no type information."
                },
                {
                    "type": "p",
                    "text": "This also means that TypeScript never changes thebehaviorof your program based on the types it inferred.\nThe bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs."
                },
                {
                    "type": "p",
                    "text": "Finally, TypeScript doesn’t provide any additional runtime libraries.\nYour programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Learning JavaScript and TypeScript"
                },
                {
                    "type": "p",
                    "text": "We frequently see the question “Should I learn JavaScript or TypeScript?“."
                },
                {
                    "type": "p",
                    "text": "The answer is that you can’t learn TypeScript without learning JavaScript!\nTypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time."
                },
                {
                    "type": "p",
                    "text": "There are many, many resources available for programmers to learn JavaScript; you shouldnotignore these resources if you’re writing TypeScript.\nFor example, there are about 20 times more StackOverflow questions taggedjavascriptthantypescript, butallof thejavascriptquestions also apply to TypeScript."
                },
                {
                    "type": "p",
                    "text": "If you find yourself searching for something like “how to sort a list in TypeScript”, remember:TypeScript is JavaScript’s runtime with a compile-time type checker.\nThe way you sort a list in TypeScript is the same way you do so in JavaScript.\nIf you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next Steps"
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Learn some of the JavaScript fundamentals, we recommend either:Microsoft’s JavaScript ResourcesorJavaScript guide at the Mozilla Web Docs",
                        "Microsoft’s JavaScript Resourcesor",
                        "JavaScript guide at the Mozilla Web Docs",
                        "Continue toTypeScript for JavaScript Programmers",
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "Learn some of the JavaScript fundamentals, we recommend either:"
                },
                {
                    "type": "list",
                    "items": [
                        "Microsoft’s JavaScript Resourcesor",
                        "JavaScript guide at the Mozilla Web Docs"
                    ]
                },
                {
                    "type": "p",
                    "text": "Continue toTypeScript for JavaScript Programmers"
                },
                {
                    "type": "p",
                    "text": "Read the full Handbookfrom start to finish"
                },
                {
                    "type": "p",
                    "text": "Explore thePlayground examples"
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html",
            "title": "TypeScript: Documentation - TypeScript for Functional Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript for Functional Programmers"
                },
                {
                    "type": "p",
                    "text": "TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional object-oriented programs to the web. As it has developed, TypeScript’s type\nsystem has evolved to model code written by native JavaScripters. The\nresulting system is powerful, interesting and messy."
                },
                {
                    "type": "p",
                    "text": "This introduction is designed for working Haskell or ML programmers\nwho want to learn TypeScript. It describes how the type system of\nTypeScript differs from Haskell’s type system. It also describes\nunique features of TypeScript’s type system that arise from its\nmodelling of JavaScript code."
                },
                {
                    "type": "p",
                    "text": "This introduction does not cover object-oriented programming. In\npractice, object-oriented programs in TypeScript are similar to those\nin other popular languages with OO features."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Prerequisites"
                },
                {
                    "type": "p",
                    "text": "In this introduction, I assume you know the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "How to program in JavaScript, the good parts.",
                        "Type syntax of a C-descended language."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you need to learn the good parts of JavaScript, readJavaScript: The Good Parts.\nYou may be able to skip the book if you know how to write programs in\na call-by-value lexically scoped language with lots of mutability and\nnot much else.R4RS Schemeis a good example."
                },
                {
                    "type": "p",
                    "text": "The C++ Programming Languageis\na good place to learn about C-style type syntax. Unlike C++,\nTypeScript uses postfix types, like so:x: stringinstead ofstring x."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Concepts not in Haskell"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Built-in types"
                },
                {
                    "type": "p",
                    "text": "JavaScript defines 8 built-in types:"
                },
                {
                    "type": "p",
                    "text": "See the MDN page for more detail."
                },
                {
                    "type": "p",
                    "text": "TypeScript has corresponding primitive types for the built-in types:"
                },
                {
                    "type": "list",
                    "items": [
                        "number",
                        "string",
                        "bigint",
                        "boolean",
                        "symbol",
                        "null",
                        "undefined",
                        "object"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Other important TypeScript types"
                },
                {
                    "type": "p",
                    "text": "Notes:"
                },
                {
                    "type": "list",
                    "items": [
                        "Function syntax includes parameter names. This is pretty hard to get used to!tsletfst: (a:any,b:any)=>any= (a,b)=>a;// or more precisely:letfst: <T,U>(a:T,b:U)=>T= (a,b)=>a;",
                        "Object literal type syntax closely mirrors object literal value syntax:tsleto: {n:number;xs:object[] } = {n:1,xs:[] };",
                        "[T, T]is a subtype ofT[]. This is different than Haskell, where tuples are not related to lists."
                    ]
                },
                {
                    "type": "p",
                    "text": "Function syntax includes parameter names. This is pretty hard to get used to!"
                },
                {
                    "type": "code",
                    "code": "tsletfst: (a:any,b:any)=>any= (a,b)=>a;// or more precisely:letfst: <T,U>(a:T,b:U)=>T= (a,b)=>a;"
                },
                {
                    "type": "p",
                    "text": "Object literal type syntax closely mirrors object literal value syntax:"
                },
                {
                    "type": "code",
                    "code": "tsleto: {n:number;xs:object[] } = {n:1,xs:[] };"
                },
                {
                    "type": "p",
                    "text": "[T, T]is a subtype ofT[]. This is different than Haskell, where tuples are not related to lists."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Boxed types"
                },
                {
                    "type": "p",
                    "text": "JavaScript has boxed equivalents of primitive types that contain the\nmethods that programmers associate with those types. TypeScript\nreflects this with, for example, the difference between the primitive\ntypenumberand the boxed typeNumber. The boxed types are rarely\nneeded, since their methods return primitives."
                },
                {
                    "type": "code",
                    "code": "ts(1).toExponential();// equivalent toNumber.prototype.toExponential.call(1);"
                },
                {
                    "type": "p",
                    "text": "Note that calling a method on a numeric literal requires it to be in\nparentheses to aid the parser."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Gradual typing"
                },
                {
                    "type": "p",
                    "text": "TypeScript uses the typeanywhenever it can’t tell what the type of\nan expression should be. Compared toDynamic, callinganya type\nis an overstatement. It just turns off the type checker\nwherever it appears. For example, you can push any value into anany[]without marking the value in any way:"
                },
                {
                    "type": "code",
                    "code": "ts// with \"noImplicitAny\": false in tsconfig.json, anys: any[]constanys= [];anys.push(1);anys.push(\"oh no\");anys.push({anything:\"goes\"});Try"
                },
                {
                    "type": "p",
                    "text": "And you can use an expression of typeanyanywhere:"
                },
                {
                    "type": "code",
                    "code": "tsanys.map(anys[1]);// oh no, \"oh no\" is not a function"
                },
                {
                    "type": "p",
                    "text": "anyis contagious, too — if you initialize a variable with an\nexpression of typeany, the variable has typeanytoo."
                },
                {
                    "type": "code",
                    "code": "tsletsepsis=anys[0] +anys[1];// this could mean anything"
                },
                {
                    "type": "p",
                    "text": "To get an error when TypeScript produces anany, use\"noImplicitAny\": true, or\"strict\": trueintsconfig.json."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Structural typing"
                },
                {
                    "type": "p",
                    "text": "Structural typing is a familiar concept to most functional\nprogrammers, although Haskell and most MLs are not\nstructurally typed. Its basic form is pretty simple:"
                },
                {
                    "type": "code",
                    "code": "ts// @strict: falseleto= {x:\"hi\",extra:1};// okleto2: {x:string} =o;// ok"
                },
                {
                    "type": "p",
                    "text": "Here, the object literal{ x: \"hi\", extra: 1 }has a matching\nliteral type{ x: string, extra: number }. That\ntype is assignable to{ x: string }since\nit has all the required properties and those properties have\nassignable types. The extra property doesn’t prevent assignment, it\njust makes it a subtype of{ x: string }."
                },
                {
                    "type": "p",
                    "text": "Named types just give a name to a type; for assignability purposes\nthere’s no difference between the type aliasOneand the interface\ntypeTwobelow. They both have a propertyp: string. (Type aliases\nbehave differently from interfaces with respect to recursive\ndefinitions and type parameters, however.)"
                },
                {
                    "type": "code",
                    "code": "tstypeOne= {p:string};interfaceTwo{p:string;}classThree{p=\"Hello\";}letx:One= {p:\"hi\"};lettwo:Two=x;two=newThree();Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unions"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, union types are untagged. In other words, they are not\ndiscriminated unions likedatain Haskell. However, you can often\ndiscriminate types in a union using built-in tags or other properties."
                },
                {
                    "type": "code",
                    "code": "tsfunctionstart(arg:string|string[] | (()=>string) | {s:string}):string{// this is super common in JavaScriptif(typeofarg===\"string\") {returncommonCase(arg);}elseif(Array.isArray(arg)) {returnarg.map(commonCase).join(\",\");}elseif(typeofarg===\"function\") {returncommonCase(arg());}else{returncommonCase(arg.s);}functioncommonCase(s:string):string{// finally, just convert a string to another stringreturns;}}Try"
                },
                {
                    "type": "p",
                    "text": "string,ArrayandFunctionhave built-in type predicates,\nconveniently leaving the object type for theelsebranch. It is\npossible, however, to generate unions that are difficult to\ndifferentiate at runtime. For new code, it’s best to build only\ndiscriminated unions."
                },
                {
                    "type": "p",
                    "text": "The following types have built-in predicates:"
                },
                {
                    "type": "p",
                    "text": "Note that functions and arrays are objects at runtime, but have their\nown predicates."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Intersections"
                },
                {
                    "type": "p",
                    "text": "In addition to unions, TypeScript also has intersections:"
                },
                {
                    "type": "code",
                    "code": "tstypeCombined= {a:number} & {b:string};typeConflicting= {a:number} & {a:string};Try"
                },
                {
                    "type": "p",
                    "text": "Combinedhas two properties,aandb, just as if they had been\nwritten as one object literal type. Intersection and union are\nrecursive in case of conflicts, soConflicting.a: number & string."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unit types"
                },
                {
                    "type": "p",
                    "text": "Unit types are subtypes of primitive types that contain exactly one\nprimitive value. For example, the string\"foo\"has the type\"foo\". Since JavaScript has no built-in enums, it is common to use a set of\nwell-known strings instead. Unions of string literal types allow\nTypeScript to type this pattern:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionpad(s:string,n:number,direction:\"left\"|\"right\"):string;pad(\"hi\",10,\"left\");Try"
                },
                {
                    "type": "p",
                    "text": "When needed, the compilerwidens— converts to a\nsupertype — the unit type to the primitive type, such as\"foo\"tostring. This happens when using mutability, which can hamper some\nuses of mutable variables:"
                },
                {
                    "type": "code",
                    "code": "tslets=\"right\";pad(\"hi\",10,s);// error: 'string' is not assignable to '\"left\" | \"right\"'Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.2345Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.Try"
                },
                {
                    "type": "p",
                    "text": "Here’s how the error happens:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"right\": \"right\"",
                        "s: stringbecause\"right\"widens tostringon assignment to a mutable variable.",
                        "stringis not assignable to\"left\" | \"right\""
                    ]
                },
                {
                    "type": "p",
                    "text": "You can work around this with a type annotation fors, but that\nin turn prevents assignments tosof variables that are not of type\"left\" | \"right\"."
                },
                {
                    "type": "code",
                    "code": "tslets:\"left\"|\"right\"=\"right\";pad(\"hi\",10,s);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Concepts similar to Haskell"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Contextual typing"
                },
                {
                    "type": "p",
                    "text": "TypeScript has some obvious places where it can infer types, like\nvariable declarations:"
                },
                {
                    "type": "code",
                    "code": "tslets=\"I'm a string!\";Try"
                },
                {
                    "type": "p",
                    "text": "But it also infers types in a few other places that you may not expect\nif you’ve worked with other C-syntax languages:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionmap<T,U>(f: (t:T)=>U,ts:T[]):U[];letsns=map((n)=>n.toString(), [1,2,3]);Try"
                },
                {
                    "type": "p",
                    "text": "Here,n: numberin this example also, despite the fact thatTandUhave not been inferred before the call. In fact, after[1,2,3]has\nbeen used to inferT=number, the return type ofn => n.toString()is used to inferU=string, causingsnsto have the typestring[]."
                },
                {
                    "type": "p",
                    "text": "Note that inference will work in any order, but intellisense will only\nwork left-to-right, so TypeScript prefers to declaremapwith the\narray first:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionmap<T,U>(ts:T[],f: (t:T)=>U):U[];Try"
                },
                {
                    "type": "p",
                    "text": "Contextual typing also works recursively through object literals, and\non unit types that would otherwise be inferred asstringornumber. And it can infer return types from context:"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionrun<T>(thunk: (t:T)=>void):T;leti: {inference:string} =run((o)=>{o.inference=\"INSERT STATE HERE\";});Try"
                },
                {
                    "type": "p",
                    "text": "The type ofois determined to be{ inference: string }because"
                },
                {
                    "type": "list",
                    "items": [
                        "Declaration initializers are contextually typed by the\ndeclaration’s type:{ inference: string }.",
                        "The return type of a call uses the contextual type for inferences,\nso the compiler infers thatT={ inference: string }.",
                        "Arrow functions use the contextual type to type their parameters,\nso the compiler giveso: { inference: string }."
                    ]
                },
                {
                    "type": "p",
                    "text": "And it does so while you are typing, so that after typingo., you\nget completions for the propertyinference, along with any other\nproperties you’d have in a real program.\nAltogether, this feature can make TypeScript’s inference look a bit\nlike a unifying type inference engine, but it is not."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type aliases"
                },
                {
                    "type": "p",
                    "text": "Type aliases are mere aliases, just liketypein Haskell. The\ncompiler will attempt to use the alias name wherever it was used in\nthe source code, but does not always succeed."
                },
                {
                    "type": "code",
                    "code": "tstypeSize= [number,number];letx:Size= [101.1,999.9];Try"
                },
                {
                    "type": "p",
                    "text": "The closest equivalent tonewtypeis atagged intersection:"
                },
                {
                    "type": "code",
                    "code": "tstypeFString=string& {__compileTimeOnly:any};"
                },
                {
                    "type": "p",
                    "text": "AnFStringis just like a normal string, except that the compiler\nthinks it has a property named__compileTimeOnlythat doesn’t\nactually exist. This means thatFStringcan still be assigned tostring, but not the other way round."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Discriminated Unions"
                },
                {
                    "type": "p",
                    "text": "The closest equivalent todatais a union of types with discriminant\nproperties, normally called discriminated unions in TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tstypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};"
                },
                {
                    "type": "p",
                    "text": "Unlike Haskell, the tag, or discriminant, is just a property in each\nobject type. Each variant has an identical property with a different\nunit type. This is still a normal union type; the leading|is\nan optional part of the union type syntax. You can discriminate the\nmembers of the union using normal JavaScript code:"
                },
                {
                    "type": "code",
                    "code": "tstypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};functionarea(s:Shape) {if(s.kind===\"circle\") {returnMath.PI*s.radius*s.radius;}elseif(s.kind===\"square\") {returns.x*s.x;}else{return(s.x*s.y) /2;}}Try"
                },
                {
                    "type": "p",
                    "text": "Note that the return type ofareais inferred to benumberbecause\nTypeScript knows the function is total. If some variant is not\ncovered, the return type ofareawill benumber | undefinedinstead."
                },
                {
                    "type": "p",
                    "text": "Also, unlike Haskell, common properties show up in any union, so you\ncan usefully discriminate multiple members of the union:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionheight(s:Shape) {if(s.kind===\"circle\") {return2*s.radius;}else{// s.kind: \"square\" | \"triangle\"returns.x;}}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Type Parameters"
                },
                {
                    "type": "p",
                    "text": "Like most C-descended languages, TypeScript requires declaration of\ntype parameters:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionliftArray<T>(t:T):Array<T> {return[t];}"
                },
                {
                    "type": "p",
                    "text": "There is no case requirement, but type parameters are conventionally\nsingle uppercase letters. Type parameters can also be constrained to a\ntype, which behaves a bit like type class constraints:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfirstish<Textends{length:number}>(t1:T,t2:T):T{returnt1.length>t2.length?t1:t2;}"
                },
                {
                    "type": "p",
                    "text": "TypeScript can usually infer type arguments from a call based on the\ntype of the arguments, so type arguments are usually not needed."
                },
                {
                    "type": "p",
                    "text": "Because TypeScript is structural, it doesn’t need type parameters as\nmuch as nominal systems. Specifically, they are not needed to make a\nfunction polymorphic. Type parameters should only be used topropagatetype information, such as constraining parameters to be\nthe same type:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlength<TextendsArrayLike<unknown>>(t:T):number{}functionlength(t:ArrayLike<unknown>):number{}"
                },
                {
                    "type": "p",
                    "text": "In the firstlength, T is not necessary; notice that it’s only\nreferenced once, so it’s not being used to constrain the type of the\nreturn value or other parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Higher-kinded types"
                },
                {
                    "type": "p",
                    "text": "TypeScript does not have higher kinded types, so the following is not legal:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionlength<TextendsArrayLike<unknown>,U>(m:T<U>) {}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Point-free programming"
                },
                {
                    "type": "p",
                    "text": "Point-free programming — heavy use of currying and function\ncomposition — is possible in JavaScript, but can be verbose.\nIn TypeScript, type inference often fails for point-free programs, so\nyou’ll end up specifying type parameters instead of value parameters. The\nresult is so verbose that it’s usually better to avoid point-free\nprogramming."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Module system"
                },
                {
                    "type": "p",
                    "text": "JavaScript’s modern module syntax is a bit like Haskell’s, except that\nany file withimportorexportis implicitly a module:"
                },
                {
                    "type": "code",
                    "code": "tsimport{value,Type}from\"npm-package\";import{other,Types}from\"./local-package\";import*asprefixfrom\"../lib/third-package\";"
                },
                {
                    "type": "p",
                    "text": "You can also import commonjs modules — modules written using node.js’\nmodule system:"
                },
                {
                    "type": "code",
                    "code": "tsimportf=require(\"single-function-package\");"
                },
                {
                    "type": "p",
                    "text": "You can export with an export list:"
                },
                {
                    "type": "code",
                    "code": "tsexport{f};functionf() {returng();}functiong() {}// g is not exported"
                },
                {
                    "type": "p",
                    "text": "Or by marking each export individually:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionf() {returng() }functiong() { }"
                },
                {
                    "type": "p",
                    "text": "The latter style is more common but both are allowed, even in the same\nfile."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "readonlyandconst"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, mutability is the default, although it allows variable\ndeclarations withconstto declare that thereferenceis\nimmutable. The referent is still mutable:"
                },
                {
                    "type": "code",
                    "code": "jsconsta= [1,2,3];a.push(102);// ):a[0] =101;// D:"
                },
                {
                    "type": "p",
                    "text": "TypeScript additionally has areadonlymodifier for properties."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceRx{readonlyx:number;}letrx:Rx= {x:1};rx.x=12;// error"
                },
                {
                    "type": "p",
                    "text": "It also ships with a mapped typeReadonly<T>that makes\nall propertiesreadonly:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceX{x:number;}letrx:Readonly<X> = {x:1};rx.x=12;// error"
                },
                {
                    "type": "p",
                    "text": "And it has a specificReadonlyArray<T>type that removes\nside-affecting methods and prevents writing to indices of the array,\nas well as special syntax for this type:"
                },
                {
                    "type": "code",
                    "code": "tsleta:ReadonlyArray<number> = [1,2,3];letb:readonlynumber[] = [1,2,3];a.push(102);// errorb[0] =101;// error"
                },
                {
                    "type": "p",
                    "text": "You can also use a const-assertion, which operates on arrays and\nobject literals:"
                },
                {
                    "type": "code",
                    "code": "tsleta= [1,2,3]asconst;a.push(102);// errora[0] =101;// error"
                },
                {
                    "type": "p",
                    "text": "However, none of these options are the default, so they are not\nconsistently used in TypeScript code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Next Steps"
                },
                {
                    "type": "p",
                    "text": "This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html",
            "title": "TypeScript: Documentation - TypeScript for Java/C# Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript for Java/C# Programmers"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program.\nWhile TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages.\nUnderstanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Co-learning JavaScript"
                },
                {
                    "type": "p",
                    "text": "If you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to.\nSome of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript."
                },
                {
                    "type": "p",
                    "text": "If you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScriptwithouttypes first to understand JavaScript’s runtime behaviors.\nBecause TypeScript doesn’t change how your coderuns, you’ll still have to learn how JavaScript works in order to write code that actually does something!"
                },
                {
                    "type": "p",
                    "text": "It’s important to remember that TypeScript uses the sameruntimeas JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs.\nDon’t limit yourself to TypeScript-specific resources!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rethinking the Class"
                },
                {
                    "type": "p",
                    "text": "C# and Java are what we might callmandatory OOPlanguages.\nIn these languages, theclassis the basic unit of code organization, and also the basic container of all dataandbehavior at runtime.\nForcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domainneedsto be represented this way."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Free Functions and Data"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-definedclassorstruct.\nThis flexibility is extremely powerful.\n“Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Static Classes"
                },
                {
                    "type": "p",
                    "text": "Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "OOP in TypeScript"
                },
                {
                    "type": "p",
                    "text": "That said, you can still use classes if you like!\nSome problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful.\nTypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods."
                },
                {
                    "type": "p",
                    "text": "We’ll cover classes later in this guide."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rethinking Types"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s understanding of atypeis actually quite different from C# or Java’s.\nLet’s explore some differences."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Nominal Reified Type Systems"
                },
                {
                    "type": "p",
                    "text": "In C# or Java, any given value or object has one exact type - eithernull, a primitive, or a known class type.\nWe can call methods likevalue.GetType()orvalue.getClass()to query the exact type at runtime.\nThe definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface."
                },
                {
                    "type": "p",
                    "text": "These aspects describe areified, nominaltype system.\nThe types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Types as Sets"
                },
                {
                    "type": "p",
                    "text": "In C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, it’s better to think of a type as aset of valuesthat share something in common.\nBecause types are just sets, a particular value can belong tomanysets at the same time."
                },
                {
                    "type": "p",
                    "text": "Once you start thinking of types as sets, certain operations become very natural.\nFor example, in C#, it’s awkward to pass around a value that iseitherastringorint, because there isn’t a single type that represents this sort of value."
                },
                {
                    "type": "p",
                    "text": "In TypeScript, this becomes very natural once you realize that every type is just a set.\nHow do you describe a value that either belongs in thestringset or thenumberset?\nIt simply belongs to theunionof those sets:string | number."
                },
                {
                    "type": "p",
                    "text": "TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Erased Structural Types"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, objects arenotof a single exact type.\nFor example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePointlike{x:number;y:number;}interfaceNamed{name:string;}functionlogPoint(point:Pointlike) {console.log(\"x = \"+point.x+\", y = \"+point.y);}functionlogName(x:Named) {console.log(\"Hello, \"+x.name);}constobj= {x:0,y:0,name:\"Origin\",};logPoint(obj);logName(obj);Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system isstructural, not nominal: We can useobjas aPointlikebecause it hasxandyproperties that are both numbers.\nThe relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type system is alsonot reified: There’s nothing at runtime that will tell us thatobjisPointlike.\nIn fact, thePointliketype is not presentin any format runtime."
                },
                {
                    "type": "p",
                    "text": "Going back to the idea oftypes as sets, we can think ofobjas being a member of both thePointlikeset of values and theNamedset of values."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Consequences of Structural Typing"
                },
                {
                    "type": "p",
                    "text": "OOP programmers are often surprised by two particular aspects of structural typing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Empty Types"
                },
                {
                    "type": "p",
                    "text": "The first is that theempty typeseems to defy expectation:"
                },
                {
                    "type": "code",
                    "code": "tsclassEmpty{}functionfn(arg:Empty) {// do something?}// No error, but this isn't an 'Empty' ?fn({k:10});Try"
                },
                {
                    "type": "p",
                    "text": "TypeScript determines if the call tofnhere is valid by seeing if the provided argument is a validEmpty.\nIt does so by examining thestructureof{ k: 10 }andclass Empty { }.\nWe can see that{ k: 10 }hasallof the properties thatEmptydoes, becauseEmptyhas no properties.\nTherefore, this is a valid call!"
                },
                {
                    "type": "p",
                    "text": "This may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages.\nA subclass cannotremovea property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base.\nStructural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Identical Types"
                },
                {
                    "type": "p",
                    "text": "Another frequent source of surprise comes with identical types:"
                },
                {
                    "type": "code",
                    "code": "tsclassCar{drive() {// hit the gas}}classGolfer{drive() {// hit the ball far}}// No error?letw:Car=newGolfer();"
                },
                {
                    "type": "p",
                    "text": "Again, this isn’t an error because thestructuresof these classes are the same.\nWhile this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common."
                },
                {
                    "type": "p",
                    "text": "We’ll learn more about how classes relate to each other in the Classes chapter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reflection"
                },
                {
                    "type": "p",
                    "text": "OOP programmers are accustomed to being able to query the type of any value, even a generic one:"
                },
                {
                    "type": "code",
                    "code": "csharp// C#staticvoidLogType<T>() {Console.WriteLine(typeof(T).Name);}"
                },
                {
                    "type": "p",
                    "text": "Because TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime."
                },
                {
                    "type": "p",
                    "text": "JavaScript does have some limited primitives liketypeofandinstanceof, but remember that these operators are still working on the values as they exist in the type-erased output code.\nFor example,typeof (new Car())will be\"object\", notCaror\"Car\"."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next Steps"
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript for JavaScript Programmers",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript for JavaScript Programmers"
                },
                {
                    "type": "p",
                    "text": "TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system."
                },
                {
                    "type": "p",
                    "text": "For example, JavaScript provides language primitives likestringandnumber, but it doesn’t check that you’ve consistently assigned these. TypeScript does."
                },
                {
                    "type": "p",
                    "text": "This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs."
                },
                {
                    "type": "p",
                    "text": "This tutorial provides a brief overview of TypeScript, focusing on its type system."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Types by Inference"
                },
                {
                    "type": "p",
                    "text": "TypeScript knows the JavaScript language and will generate types for you in many cases.\nFor example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type."
                },
                {
                    "type": "code",
                    "code": "tslethelloWorld=\"Hello World\";let helloWorld: stringTry"
                },
                {
                    "type": "p",
                    "text": "By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows thathelloWorldis astringin the above example."
                },
                {
                    "type": "p",
                    "text": "You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Defining Types"
                },
                {
                    "type": "p",
                    "text": "You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be."
                },
                {
                    "type": "p",
                    "text": "For example, to create an object with an inferred type which includesname: stringandid: number, you can write:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser= {name:\"Hayes\",id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "You can explicitly describe this object’s shape using aninterfacedeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}Try"
                },
                {
                    "type": "p",
                    "text": "You can then declare that a JavaScript object conforms to the shape of your newinterfaceby using syntax like: TypeNameafter a variable declaration:"
                },
                {
                    "type": "code",
                    "code": "tsconstuser:User= {name:\"Hayes\",id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}constuser:User= {username:\"Hayes\",Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.id:0,};Try"
                },
                {
                    "type": "p",
                    "text": "Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUser{name:string;id:number;}classUserAccount{name:string;id:number;constructor(name:string,id:number) {this.name=name;this.id=id;}}constuser:User=newUserAccount(\"Murphy\",1);Try"
                },
                {
                    "type": "p",
                    "text": "You can use interfaces to annotate parameters and return values to functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiondeleteUser(user:User) {// ...}functiongetAdminUser():User{//...}Try"
                },
                {
                    "type": "p",
                    "text": "There is already a small set of primitive types available in JavaScript:boolean,bigint,null,number,string,symbol, andundefined, which you can use in an interface. TypeScript extends this list with a few more, such asany(allow anything),unknown(ensure someone using this type declares what the type is),never(it’s not possible that this type could happen), andvoid(a function which returnsundefinedor has no return value)."
                },
                {
                    "type": "p",
                    "text": "You’ll see that there are two syntaxes for building types:Interfaces and Types. You should preferinterface. Usetypewhen you need specific features."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Composing Types"
                },
                {
                    "type": "p",
                    "text": "With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Unions"
                },
                {
                    "type": "p",
                    "text": "With a union, you can declare that a type could be one of many types. For example, you can describe abooleantype as being eithertrueorfalse:"
                },
                {
                    "type": "code",
                    "code": "tstypeMyBool=true|false;Try"
                },
                {
                    "type": "p",
                    "text": "Note:If you hover overMyBoolabove, you’ll see that it is classed asboolean. That’s a property of the Structural Type System. More on this below."
                },
                {
                    "type": "p",
                    "text": "A popular use-case for union types is to describe the set ofstringornumberliteralsthat a value is allowed to be:"
                },
                {
                    "type": "code",
                    "code": "tstypeWindowStates=\"open\"|\"closed\"|\"minimized\";typeLockStates=\"locked\"|\"unlocked\";typePositiveOddNumbersUnderTen=1|3|5|7|9;Try"
                },
                {
                    "type": "p",
                    "text": "Unions provide a way to handle different types too. For example, you may have a function that takes anarrayor astring:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongetLength(obj:string|string[]) {returnobj.length;}Try"
                },
                {
                    "type": "p",
                    "text": "To learn the type of a variable, usetypeof:"
                },
                {
                    "type": "p",
                    "text": "For example, you can make a function return different values depending on whether it is passed a string or an array:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionwrapInArray(obj:string|string[]) {if(typeofobj===\"string\") {return[obj];(parameter) obj: string}returnobj;}Try"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generics"
                },
                {
                    "type": "p",
                    "text": "Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains."
                },
                {
                    "type": "code",
                    "code": "tstypeStringArray=Array<string>;typeNumberArray=Array<number>;typeObjectWithNameArray=Array<{name:string}>;"
                },
                {
                    "type": "p",
                    "text": "You can declare your own types that use generics:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceBackpack<Type> {add: (obj:Type)=>void;get: ()=>Type;}// This line is a shortcut to tell TypeScript there is a// constant called `backpack`, and to not worry about where it came from.declareconstbackpack:Backpack<string>;// object is a string, because we declared it above as the variable part of Backpack.constobject=backpack.get();// Since the backpack variable is a string, you can't pass a number to the add function.backpack.add(23);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Structural Type System"
                },
                {
                    "type": "p",
                    "text": "One of TypeScript’s core principles is that type checking focuses on theshapethat values have. This is sometimes called “duck typing” or “structural typing”."
                },
                {
                    "type": "p",
                    "text": "In a structural type system, if two objects have the same shape, they are considered to be of the same type."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePoint{x:number;y:number;}functionlogPoint(p:Point) {console.log(`${p.x},${p.y}`);}// logs \"12, 26\"constpoint= {x:12,y:26};logPoint(point);Try"
                },
                {
                    "type": "p",
                    "text": "Thepointvariable is never declared to be aPointtype. However, TypeScript compares the shape ofpointto the shape ofPointin the type-check. They have the same shape, so the code passes."
                },
                {
                    "type": "p",
                    "text": "The shape-matching only requires a subset of the object’s fields to match."
                },
                {
                    "type": "code",
                    "code": "tsconstpoint3= {x:12,y:26,z:89};logPoint(point3);// logs \"12, 26\"constrect= {x:33,y:3,width:30,height:80};logPoint(rect);// logs \"33, 3\"constcolor= {hex:\"#187ABF\"};logPoint(color);Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.\n  Type '{ hex: string; }' is missing the following properties from type 'Point': x, yTry"
                },
                {
                    "type": "p",
                    "text": "There is no difference between how classes and objects conform to shapes:"
                },
                {
                    "type": "code",
                    "code": "tsclassVirtualPoint{x:number;y:number;constructor(x:number,y:number) {this.x=x;this.y=y;}}constnewVPoint=newVirtualPoint(13,56);logPoint(newVPoint);// logs \"13, 56\"Try"
                },
                {
                    "type": "p",
                    "text": "If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next Steps"
                },
                {
                    "type": "p",
                    "text": "This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:"
                },
                {
                    "type": "list",
                    "items": [
                        "Read the full Handbookfrom start to finish",
                        "Explore thePlayground examples"
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html",
            "title": "TypeScript: Documentation - TypeScript Tooling in 5 minutes",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript Tooling in 5 minutes"
                },
                {
                    "type": "p",
                    "text": "Let’s get started by building a simple web application with TypeScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Installing TypeScript"
                },
                {
                    "type": "p",
                    "text": "There are two main ways to add TypeScript to your project:"
                },
                {
                    "type": "list",
                    "items": [
                        "Via npm (the Node.js package manager)",
                        "By installing TypeScript’s Visual Studio plugins"
                    ]
                },
                {
                    "type": "p",
                    "text": "Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler,tsc.\nIf you didn’t install TypeScript with Visual Studio, you can stilldownload it."
                },
                {
                    "type": "p",
                    "text": "For npm users:"
                },
                {
                    "type": "code",
                    "code": "shell> npm install -g typescript"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Building your first TypeScript file"
                },
                {
                    "type": "p",
                    "text": "In your editor, type the following JavaScript code ingreeter.ts:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person) {return\"Hello, \"+person;}letuser=\"Jane User\";document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Compiling your code"
                },
                {
                    "type": "p",
                    "text": "We used a.tsextension, but this code is just JavaScript.\nYou could have copy/pasted this straight out of an existing JavaScript app."
                },
                {
                    "type": "p",
                    "text": "At the command line, run the TypeScript compiler:"
                },
                {
                    "type": "code",
                    "code": "shelltsc greeter.ts"
                },
                {
                    "type": "p",
                    "text": "The result will be a filegreeter.jswhich contains the same JavaScript that you fed in.\nWe’re up and running using TypeScript in our JavaScript app!"
                },
                {
                    "type": "p",
                    "text": "Now we can start taking advantage of some of the new tools TypeScript offers.\nAdd a: stringtype annotation to the ‘person’ function parameter as shown here:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person:string) {return\"Hello, \"+person;}letuser=\"Jane User\";document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type annotations"
                },
                {
                    "type": "p",
                    "text": "Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable.\nIn this case, we intend the greeter function to be called with a single string parameter.\nWe can try changing the call greeter to pass an array instead:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiongreeter(person:string) {return\"Hello, \"+person;}letuser= [0,1,2];document.body.textContent=greeter(user);Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "Re-compiling, you’ll now see an error:"
                },
                {
                    "type": "code",
                    "code": "shellerror TS2345: Argument oftype'number[]'is not assignable to parameter oftype'string'."
                },
                {
                    "type": "p",
                    "text": "Similarly, try removing all the arguments to the greeter call.\nTypeScript will let you know that you have called this function with an unexpected number of arguments.\nIn both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide."
                },
                {
                    "type": "p",
                    "text": "Notice that although there were errors, thegreeter.jsfile is still created.\nYou can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Interfaces"
                },
                {
                    "type": "p",
                    "text": "Let’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field.\nIn TypeScript, two types are compatible if their internal structure is compatible.\nThis allows us to implement an interface just by having the shape the interface requires, without an explicitimplementsclause."
                },
                {
                    "type": "code",
                    "code": "tsinterfacePerson{firstName:string;lastName:string;}functiongreeter(person:Person) {return\"Hello, \"+person.firstName+\" \"+person.lastName;}letuser= {firstName:\"Jane\",lastName:\"User\"};document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Classes"
                },
                {
                    "type": "p",
                    "text": "Finally, let’s extend the example one last time with classes.\nTypeScript supports new features in JavaScript, like support for class-based object-oriented programming."
                },
                {
                    "type": "p",
                    "text": "Here we’re going to create aStudentclass with a constructor and a few public fields.\nNotice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction."
                },
                {
                    "type": "p",
                    "text": "Also of note, the use ofpublicon parameters to the constructor is a shorthand that allows us to automatically create properties with that name."
                },
                {
                    "type": "code",
                    "code": "tsclassStudent{fullName:string;constructor(publicfirstName:string,publicmiddleInitial:string,publiclastName:string) {this.fullName=firstName+\" \"+middleInitial+\" \"+lastName;}}interfacePerson{firstName:string;lastName:string;}functiongreeter(person:Person) {return\"Hello, \"+person.firstName+\" \"+person.lastName;}letuser=newStudent(\"Jane\",\"M.\",\"User\");document.body.textContent=greeter(user);Try"
                },
                {
                    "type": "p",
                    "text": "Re-runtsc greeter.tsand you’ll see the generated JavaScript is the same as the earlier code.\nClasses in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Running your TypeScript web app"
                },
                {
                    "type": "p",
                    "text": "Now type the following ingreeter.html:"
                },
                {
                    "type": "code",
                    "code": "html<!DOCTYPEhtml><html><head><title>TypeScript Greeter</title></head><body><scriptsrc=\"greeter.js\"></script></body></html>"
                },
                {
                    "type": "p",
                    "text": "Opengreeter.htmlin the browser to run your first simple TypeScript web application!"
                },
                {
                    "type": "p",
                    "text": "Optional: Opengreeter.tsin Visual Studio, or copy the code into the TypeScript playground.\nYou can hover over identifiers to see their types.\nNotice that in some cases these types are inferred automatically for you.\nRe-type the last line, and see completion lists and parameter help based on the types of the DOM elements.\nPut your cursor on the reference to the greeter function, and hit F12 to go to its definition.\nNotice, too, that you can right-click on a symbol and use refactoring to rename it."
                },
                {
                    "type": "p",
                    "text": "The type information provided works together with the tools to work with JavaScript at application scale.\nFor more examples of what’s possible in TypeScript, see the Samples section of the website."
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
            "title": "TypeScript: Documentation - Utility Types",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Utility Types"
                },
                {
                    "type": "p",
                    "text": "TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Awaited<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:4.5"
                },
                {
                    "type": "p",
                    "text": "This type is meant to model operations likeawaitinasyncfunctions, or the.then()method onPromises - specifically, the way that they recursively\nunwrapPromises."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeA=Awaited<Promise<string>>;type A = stringtypeB=Awaited<Promise<Promise<number>>>;type B = numbertypeC=Awaited<boolean|Promise<number>>;type C = number | booleanTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Partial<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties ofTypeset to optional. This utility will return a type that represents all subsets of a given type."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;}functionupdateTodo(todo:Todo,fieldsToUpdate:Partial<Todo>) {return{ ...todo, ...fieldsToUpdate};}consttodo1= {title:\"organize desk\",description:\"clear clutter\",};consttodo2=updateTodo(todo1, {description:\"throw out trash\",});Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Required<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of all properties ofTypeset to required. The opposite ofPartial."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceProps{a?:number;b?:string;}constobj:Props= {a:5};constobj2:Required<Props> = {a:5};Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Readonly<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type with all properties ofTypeset toreadonly, meaning the properties of the constructed type cannot be reassigned."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;}consttodo:Readonly<Todo> = {title:\"Delete inactive users\",};todo.title=\"Hello\";Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.Try"
                },
                {
                    "type": "p",
                    "text": "This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of afrozen object)."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Object.freeze"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfreeze<Type>(obj:Type):Readonly<Type>;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Record<Keys, Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs an object type whose property keys areKeysand whose property values areType. This utility can be used to map the properties of a type to another type."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeCatName=\"miffy\"|\"boris\"|\"mordred\";interfaceCatInfo{age:number;breed:string;}constcats:Record<CatName,CatInfo> = {miffy:{age:10,breed:\"Persian\"},boris:{age:5,breed:\"Maine Coon\"},mordred:{age:16,breed:\"British Shorthair\"},};cats.boris;const cats: Record<CatName, CatInfo>Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Pick<Type, Keys>"
                },
                {
                    "type": "p",
                    "text": "Released:2.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking the set of propertiesKeys(string literal or union of string literals) fromType."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;completed:boolean;}typeTodoPreview=Pick<Todo,\"title\"|\"completed\">;consttodo:TodoPreview= {title:\"Clean room\",completed:false,};todo;const todo: TodoPreviewTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Omit<Type, Keys>"
                },
                {
                    "type": "p",
                    "text": "Released:3.5"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by picking all properties fromTypeand then removingKeys(string literal or union of string literals). The opposite ofPick."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceTodo{title:string;description:string;completed:boolean;createdAt:number;}typeTodoPreview=Omit<Todo,\"description\">;consttodo:TodoPreview= {title:\"Clean room\",completed:false,createdAt:1615544252770,};todo;const todo: TodoPreviewtypeTodoInfo=Omit<Todo,\"completed\"|\"createdAt\">;consttodoInfo:TodoInfo= {title:\"Pick up kids\",description:\"Kindergarten closes at 5pm\",};todoInfo;const todoInfo: TodoInfoTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Exclude<UnionType, ExcludedMembers>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excluding fromUnionTypeall union members that are assignable toExcludedMembers."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeT0=Exclude<\"a\"|\"b\"|\"c\",\"a\">;type T0 = \"b\" | \"c\"typeT1=Exclude<\"a\"|\"b\"|\"c\",\"a\"|\"b\">;type T1 = \"c\"typeT2=Exclude<string|number| (()=>void),Function>;type T2 = string | numbertypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};typeT3=Exclude<Shape, {kind:\"circle\"}>type T3 = {\n    kind: \"square\";\n    x: number;\n} | {\n    kind: \"triangle\";\n    x: number;\n    y: number;\n}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Extract<Type, Union>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by extracting fromTypeall union members that are assignable toUnion."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeT0=Extract<\"a\"|\"b\"|\"c\",\"a\"|\"f\">;type T0 = \"a\"typeT1=Extract<string|number| (()=>void),Function>;type T1 = () => voidtypeShape=| {kind:\"circle\";radius:number}| {kind:\"square\";x:number}| {kind:\"triangle\";x:number;y:number};typeT2=Extract<Shape, {kind:\"circle\"}>type T2 = {\n    kind: \"circle\";\n    radius: number;\n}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "NonNullable<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type by excludingnullandundefinedfromType."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeT0=NonNullable<string|number|undefined>;type T0 = string | numbertypeT1=NonNullable<string[] |null|undefined>;type T1 = string[]Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Parameters<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:3.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple type from the types used in the parameters of a function typeType."
                },
                {
                    "type": "p",
                    "text": "For overloaded functions, this will be the parameters of thelastsignature; seeInferring Within Conditional Types."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionf1(arg: {a:number;b:string}):void;typeT0=Parameters<()=>string>;type T0 = []typeT1=Parameters<(s:string)=>void>;type T1 = [s: string]typeT2=Parameters<<T>(arg:T)=>T>;type T2 = [arg: unknown]typeT3=Parameters<typeoff1>;type T3 = [arg: {\n    a: number;\n    b: string;\n}]typeT4=Parameters<any>;type T4 = unknown[]typeT5=Parameters<never>;type T5 = nevertypeT6=Parameters<string>;Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.type T6 = nevertypeT7=Parameters<Function>;Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.type T7 = neverTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ConstructorParameters<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:3.1"
                },
                {
                    "type": "p",
                    "text": "Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the typeneverifTypeis not a function)."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeT0=ConstructorParameters<ErrorConstructor>;type T0 = [message?: string]typeT1=ConstructorParameters<FunctionConstructor>;type T1 = string[]typeT2=ConstructorParameters<RegExpConstructor>;type T2 = [pattern: string | RegExp, flags?: string]classC{constructor(a:number,b:string) {}}typeT3=ConstructorParameters<typeofC>;type T3 = [a: number, b: string]typeT4=ConstructorParameters<any>;type T4 = unknown[]typeT5=ConstructorParameters<Function>;Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.type T5 = neverTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ReturnType<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the return type of functionType."
                },
                {
                    "type": "p",
                    "text": "For overloaded functions, this will be the return type of thelastsignature; seeInferring Within Conditional Types."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsdeclarefunctionf1(): {a:number;b:string};typeT0=ReturnType<()=>string>;type T0 = stringtypeT1=ReturnType<(s:string)=>void>;type T1 = voidtypeT2=ReturnType<<T>()=>T>;type T2 = unknowntypeT3=ReturnType<<TextendsU,Uextendsnumber[]>()=>T>;type T3 = number[]typeT4=ReturnType<typeoff1>;type T4 = {\n    a: number;\n    b: string;\n}typeT5=ReturnType<any>;type T5 = anytypeT6=ReturnType<never>;type T6 = nevertypeT7=ReturnType<string>;Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.type T7 = anytypeT8=ReturnType<Function>;Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n  Type 'Function' provides no match for the signature '(...args: any): any'.type T8 = anyTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "InstanceType<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.8"
                },
                {
                    "type": "p",
                    "text": "Constructs a type consisting of the instance type of a constructor function inType."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsclassC{x=0;y=0;}typeT0=InstanceType<typeofC>;type T0 = CtypeT1=InstanceType<any>;type T1 = anytypeT2=InstanceType<never>;type T2 = nevertypeT3=InstanceType<string>;Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.type T3 = anytypeT4=InstanceType<Function>;Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n  Type 'Function' provides no match for the signature 'new (...args: any): any'.type T4 = anyTry"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "NoInfer<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:5.4"
                },
                {
                    "type": "p",
                    "text": "Blocks inferences to the contained type. Other than blocking inferences,NoInfer<Type>is\nidentical toType."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncreateStreetLight<Cextendsstring>(colors:C[],defaultColor?:NoInfer<C>,) {// ...}createStreetLight([\"red\",\"yellow\",\"green\"],\"red\");// OKcreateStreetLight([\"red\",\"yellow\",\"green\"],\"blue\");// Error"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ThisParameterType<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:3.3"
                },
                {
                    "type": "p",
                    "text": "Extracts the type of thethisparameter for a function type, orunknownif the function type has nothisparameter."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoHex(this:Number) {returnthis.toString(16);}functionnumberToString(n:ThisParameterType<typeoftoHex>) {returntoHex.apply(n);}Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "OmitThisParameter<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:3.3"
                },
                {
                    "type": "p",
                    "text": "Removes thethisparameter fromType. IfTypehas no explicitly declaredthisparameter, the result is simplyType. Otherwise, a new function type with nothisparameter is created fromType. Generics are erased and only the last overload signature is propagated into the new function type."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tsfunctiontoHex(this:Number) {returnthis.toString(16);}constfiveToHex:OmitThisParameter<typeoftoHex> =toHex.bind(5);console.log(fiveToHex());Try"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ThisType<Type>"
                },
                {
                    "type": "p",
                    "text": "Released:2.3"
                },
                {
                    "type": "p",
                    "text": "This utility does not return a transformed type. Instead, it serves as a marker for a contextualthistype. Note that thenoImplicitThisflag must be enabled to use this utility."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "code",
                    "code": "tstypeObjectDescriptor<D,M> = {data?:D;methods?:M&ThisType<D&M>;// Type of 'this' in methods is D & M};functionmakeObject<D,M>(desc:ObjectDescriptor<D,M>):D&M{letdata:object=desc.data|| {};letmethods:object=desc.methods|| {};return{ ...data, ...methods}asD&M;}letobj=makeObject({data:{x:0,y:0},methods:{moveBy(dx:number,dy:number) {this.x+=dx;// Strongly typed thisthis.y+=dy;// Strongly typed this},},});obj.x=10;obj.y=20;obj.moveBy(5,5);Try"
                },
                {
                    "type": "p",
                    "text": "In the example above, themethodsobject in the argument tomakeObjecthas a contextual type that includesThisType<D & M>and therefore the type ofthisin methods within themethodsobject is{ x: number, y: number } & { moveBy(dx: number, dy: number): void }. Notice how the type of themethodsproperty simultaneously is an inference target and a source for thethistype in methods."
                },
                {
                    "type": "p",
                    "text": "TheThisType<T>marker interface is simply an empty interface declared inlib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Intrinsic String Manipulation Types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Uppercase<StringType>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Lowercase<StringType>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Capitalize<StringType>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Uncapitalize<StringType>"
                },
                {
                    "type": "p",
                    "text": "To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in theTemplate Literal Typesdocumentation."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/docs/handbook/variable-declarations.html",
            "title": "TypeScript: Documentation - Variable Declaration",
            "content": [
                {
                    "type": "p",
                    "text": "Was this page helpful?"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "Variable Declaration"
                },
                {
                    "type": "p",
                    "text": "letandconstare two relatively new concepts for variable declarations in JavaScript.As we mentioned earlier,letis similar tovarin some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript."
                },
                {
                    "type": "p",
                    "text": "constis an augmentation ofletin that it prevents re-assignment to a variable."
                },
                {
                    "type": "p",
                    "text": "With TypeScript being an extension of JavaScript, the language naturally supportsletandconst.\nHere we’ll elaborate more on these new declarations and why they’re preferable tovar."
                },
                {
                    "type": "p",
                    "text": "If you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory.\nIf you’re intimately familiar with all the quirks ofvardeclarations in JavaScript, you might find it easier to skip ahead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "vardeclarations"
                },
                {
                    "type": "p",
                    "text": "Declaring a variable in JavaScript has always traditionally been done with thevarkeyword."
                },
                {
                    "type": "code",
                    "code": "tsvara=10;"
                },
                {
                    "type": "p",
                    "text": "As you might’ve figured out, we just declared a variable namedawith the value10."
                },
                {
                    "type": "p",
                    "text": "We can also declare a variable inside of a function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {varmessage=\"Hello, world!\";returnmessage;}"
                },
                {
                    "type": "p",
                    "text": "and we can also access those same variables within other functions:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {vara=10;returnfunctiong() {varb=a+1;returnb;};}varg=f();g();// returns '11'"
                },
                {
                    "type": "p",
                    "text": "In this above example,gcaptured the variableadeclared inf.\nAt any point thatggets called, the value ofawill be tied to the value ofainf.\nEven ifgis called oncefis done running, it will be able to access and modifya."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {vara=1;a=2;varb=g();a=3;returnb;functiong() {returna;}}f();// returns '2'"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Scoping rules"
                },
                {
                    "type": "p",
                    "text": "vardeclarations have some odd scoping rules for those used to other languages.\nTake the following example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(shouldInitialize:boolean) {if(shouldInitialize) {varx=10;}returnx;}f(true);// returns '10'f(false);// returns 'undefined'"
                },
                {
                    "type": "p",
                    "text": "Some readers might do a double-take at this example.\nThe variablexwas declaredwithin theifblock, and yet we were able to access it from outside that block.\nThat’s becausevardeclarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block.\nSome people call thisvar-scopingorfunction-scoping.\nParameters are also function scoped."
                },
                {
                    "type": "p",
                    "text": "These scoping rules can cause several types of mistakes.\nOne problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionsumMatrix(matrix:number[][]) {varsum=0;for(vari=0;i<matrix.length;i++) {varcurrentRow=matrix[i];for(vari=0;i<currentRow.length;i++) {sum+=currentRow[i];}}returnsum;}"
                },
                {
                    "type": "p",
                    "text": "Maybe it was easy to spot out for some experienced JavaScript developers, but the innerfor-loop will accidentally overwrite the variableibecauseirefers to the same function-scoped variable.\nAs experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Variable capturing quirks"
                },
                {
                    "type": "p",
                    "text": "Take a quick second to guess what the output of the following snippet is:"
                },
                {
                    "type": "code",
                    "code": "tsfor(vari=0;i<10;i++) {setTimeout(function() {console.log(i);},100*i);}"
                },
                {
                    "type": "p",
                    "text": "For those unfamiliar,setTimeoutwill try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running)."
                },
                {
                    "type": "p",
                    "text": "Ready? Take a look:"
                },
                {
                    "type": "code",
                    "code": "10101010101010101010"
                },
                {
                    "type": "p",
                    "text": "Many JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone.\nMost people expect the output to be"
                },
                {
                    "type": "code",
                    "code": "0123456789"
                },
                {
                    "type": "p",
                    "text": "Remember what we mentioned earlier about variable capturing?\nEvery function expression we pass tosetTimeoutactually refers to the sameifrom the same scope."
                },
                {
                    "type": "p",
                    "text": "Let’s take a minute to consider what that means.setTimeoutwill run a function after some number of milliseconds,but onlyafter theforloop has stopped executing;\nBy the time theforloop has stopped executing, the value ofiis10.\nSo each time the given function gets called, it will print out10!"
                },
                {
                    "type": "p",
                    "text": "A common work around is to use an IIFE - an Immediately Invoked Function Expression - to captureiat each iteration:"
                },
                {
                    "type": "code",
                    "code": "tsfor(vari=0;i<10;i++) {// capture the current state of 'i'// by invoking a function with its current value(function(i) {setTimeout(function() {console.log(i);},100*i);})(i);}"
                },
                {
                    "type": "p",
                    "text": "This odd-looking pattern is actually pretty common.\nTheiin the parameter list actually shadows theideclared in theforloop, but since we named them the same, we didn’t have to modify the loop body too much."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "letdeclarations"
                },
                {
                    "type": "p",
                    "text": "By now you’ve figured out thatvarhas some problems, which is precisely whyletstatements were introduced.\nApart from the keyword used,letstatements are written the same wayvarstatements are."
                },
                {
                    "type": "code",
                    "code": "tslethello=\"Hello!\";"
                },
                {
                    "type": "p",
                    "text": "The key difference is not in the syntax, but in the semantics, which we’ll now dive into."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Block-scoping"
                },
                {
                    "type": "p",
                    "text": "When a variable is declared usinglet, it uses what some calllexical-scopingorblock-scoping.\nUnlike variables declared withvarwhose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block orfor-loop."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(input:boolean) {leta=100;if(input) {// Still okay to reference 'a'letb=a+1;returnb;}// Error: 'b' doesn't exist herereturnb;}"
                },
                {
                    "type": "p",
                    "text": "Here, we have two local variablesaandb.a’s scope is limited to the body offwhileb’s scope is limited to the containingifstatement’s block."
                },
                {
                    "type": "p",
                    "text": "Variables declared in acatchclause also have similar scoping rules."
                },
                {
                    "type": "code",
                    "code": "tstry{throw\"oh no!\";}catch(e) {console.log(\"Oh well.\");}// Error: 'e' doesn't exist hereconsole.log(e);"
                },
                {
                    "type": "p",
                    "text": "Another property of block-scoped variables is that they can’t be read or written to before they’re actually declared.\nWhile these variables are “present” throughout their scope, all points up until their declaration are part of theirtemporal dead zone.\nThis is just a sophisticated way of saying you can’t access them before theletstatement, and luckily TypeScript will let you know that."
                },
                {
                    "type": "code",
                    "code": "tsa++;// illegal to use 'a' before it's declared;leta;"
                },
                {
                    "type": "p",
                    "text": "Something to note is that you can stillcapturea block-scoped variable before it’s declared.\nThe only catch is that it’s illegal to call that function before the declaration.\nIf targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error."
                },
                {
                    "type": "code",
                    "code": "tsfunctionfoo() {// okay to capture 'a'returna;}// illegal call 'foo' before 'a' is declared// runtimes should throw an error herefoo();leta;"
                },
                {
                    "type": "p",
                    "text": "For more information on temporal dead zones, see relevant content on theMozilla Developer Network."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Re-declarations and Shadowing"
                },
                {
                    "type": "p",
                    "text": "Withvardeclarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x) {varx;varx;if(true) {varx;}}"
                },
                {
                    "type": "p",
                    "text": "In the above example, all declarations ofxactually refer to thesamex, and this is perfectly valid.\nThis often ends up being a source of bugs.\nThankfully,letdeclarations are not as forgiving."
                },
                {
                    "type": "code",
                    "code": "tsletx=10;letx=20;// error: can't re-declare 'x' in the same scope"
                },
                {
                    "type": "p",
                    "text": "The variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(x) {letx=100;// error: interferes with parameter declaration}functiong() {letx=100;varx=100;// error: can't have both declarations of 'x'}"
                },
                {
                    "type": "p",
                    "text": "That’s not to say that a block-scoped variable can never be declared with a function-scoped variable.\nThe block-scoped variable just needs to be declared within a distinctly different block."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf(condition,x) {if(condition) {letx=100;returnx;}returnx;}f(false,0);// returns '0'f(true,0);// returns '100'"
                },
                {
                    "type": "p",
                    "text": "The act of introducing a new name in a more nested scope is calledshadowing.\nIt is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs.\nFor instance, imagine we had written our earliersumMatrixfunction usingletvariables."
                },
                {
                    "type": "code",
                    "code": "tsfunctionsumMatrix(matrix:number[][]) {letsum=0;for(leti=0;i<matrix.length;i++) {varcurrentRow=matrix[i];for(leti=0;i<currentRow.length;i++) {sum+=currentRow[i];}}returnsum;}"
                },
                {
                    "type": "p",
                    "text": "This version of the loop will actually perform the summation correctly because the inner loop’sishadowsifrom the outer loop."
                },
                {
                    "type": "p",
                    "text": "Shadowing shouldusuallybe avoided in the interest of writing clearer code.\nWhile there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Block-scoped variable capturing"
                },
                {
                    "type": "p",
                    "text": "When we first touched on the idea of variable capturing withvardeclaration, we briefly went into how variables act once captured.\nTo give a better intuition of this, each time a scope is run, it creates an “environment” of variables.\nThat environment and its captured variables can exist even after everything within its scope has finished executing."
                },
                {
                    "type": "code",
                    "code": "tsfunctiontheCityThatAlwaysSleeps() {letgetCity;if(true) {letcity=\"Seattle\";getCity=function() {returncity;};}returngetCity();}"
                },
                {
                    "type": "p",
                    "text": "Because we’ve capturedcityfrom within its environment, we’re still able to access it despite the fact that theifblock finished executing."
                },
                {
                    "type": "p",
                    "text": "Recall that with our earliersetTimeoutexample, we ended up needing to use an IIFE to capture the state of a variable for every iteration of theforloop.\nIn effect, what we were doing was creating a new variable environment for our captured variables.\nThat was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript."
                },
                {
                    "type": "p",
                    "text": "letdeclarations have drastically different behavior when declared as part of a loop.\nRather than just introducing a new environment to the loop itself, these declarations sort of create a new scopeper iteration.\nSince this is what we were doing anyway with our IIFE, we can change our oldsetTimeoutexample to just use aletdeclaration."
                },
                {
                    "type": "code",
                    "code": "tsfor(leti=0;i<10;i++) {setTimeout(function() {console.log(i);},100*i);}"
                },
                {
                    "type": "p",
                    "text": "and as expected, this will print out"
                },
                {
                    "type": "code",
                    "code": "0123456789"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "constdeclarations"
                },
                {
                    "type": "p",
                    "text": "constdeclarations are another way of declaring variables."
                },
                {
                    "type": "code",
                    "code": "tsconstnumLivesForCat=9;"
                },
                {
                    "type": "p",
                    "text": "They are likeletdeclarations but, as their name implies, their value cannot be changed once they are bound.\nIn other words, they have the same scoping rules aslet, but you can’t re-assign to them."
                },
                {
                    "type": "p",
                    "text": "This should not be confused with the idea that the values they refer to areimmutable."
                },
                {
                    "type": "code",
                    "code": "tsconstnumLivesForCat=9;constkitty= {name:\"Aurora\",numLives:numLivesForCat,};// Errorkitty= {name:\"Danielle\",numLives:numLivesForCat,};// all \"okay\"kitty.name=\"Rory\";kitty.name=\"Kitty\";kitty.name=\"Cat\";kitty.numLives--;"
                },
                {
                    "type": "p",
                    "text": "Unless you take specific measures to avoid it, the internal state of aconstvariable is still modifiable.\nFortunately, TypeScript allows you to specify that members of an object arereadonly.\nThechapter on Interfaceshas the details."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "letvs.const"
                },
                {
                    "type": "p",
                    "text": "Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use.\nLike most broad questions, the answer is: it depends."
                },
                {
                    "type": "p",
                    "text": "Applying theprinciple of least privilege, all declarations other than those you plan to modify should useconst.\nThe rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable.\nUsingconstalso makes code more predictable when reasoning about flow of data."
                },
                {
                    "type": "p",
                    "text": "Use your best judgement, and if applicable, consult the matter with the rest of your team."
                },
                {
                    "type": "p",
                    "text": "The majority of this handbook usesletdeclarations."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Destructuring"
                },
                {
                    "type": "p",
                    "text": "Another ECMAScript 2015 feature that TypeScript has is destructuring.\nFor a complete reference, seethe article on the Mozilla Developer Network.\nIn this section, we’ll give a short overview."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Array destructuring"
                },
                {
                    "type": "p",
                    "text": "The simplest form of destructuring is array destructuring assignment:"
                },
                {
                    "type": "code",
                    "code": "tsletinput= [1,2];let[first,second] =input;console.log(first);// outputs 1console.log(second);// outputs 2"
                },
                {
                    "type": "p",
                    "text": "This creates two new variables namedfirstandsecond.\nThis is equivalent to using indexing, but is much more convenient:"
                },
                {
                    "type": "code",
                    "code": "tsfirst=input[0];second=input[1];"
                },
                {
                    "type": "p",
                    "text": "Destructuring works with already-declared variables as well:"
                },
                {
                    "type": "code",
                    "code": "ts// swap variables[first,second] = [second,first];"
                },
                {
                    "type": "p",
                    "text": "And with parameters to a function:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf([first,second]: [number,number]) {console.log(first);console.log(second);}f([1,2]);"
                },
                {
                    "type": "p",
                    "text": "You can create a variable for the remaining items in a list using the syntax...:"
                },
                {
                    "type": "code",
                    "code": "tslet[first, ...rest] = [1,2,3,4];console.log(first);// outputs 1console.log(rest);// outputs [ 2, 3, 4 ]"
                },
                {
                    "type": "p",
                    "text": "Of course, since this is JavaScript, you can just ignore trailing elements you don’t care about:"
                },
                {
                    "type": "code",
                    "code": "tslet[first] = [1,2,3,4];console.log(first);// outputs 1"
                },
                {
                    "type": "p",
                    "text": "Or other elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[,second, ,fourth] = [1,2,3,4];console.log(second);// outputs 2console.log(fourth);// outputs 4"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Tuple destructuring"
                },
                {
                    "type": "p",
                    "text": "Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:"
                },
                {
                    "type": "code",
                    "code": "tslettuple: [number,string,boolean] = [7,\"hello\",true];let[a,b,c] =tuple;// a: number, b: string, c: boolean"
                },
                {
                    "type": "p",
                    "text": "It’s an error to destructure a tuple beyond the range of its elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[a,b,c,d] =tuple;// Error, no element at index 3"
                },
                {
                    "type": "p",
                    "text": "As with arrays, you can destructure the rest of the tuple with..., to get a shorter tuple:"
                },
                {
                    "type": "code",
                    "code": "tslet[a, ...bc] =tuple;// bc: [string, boolean]let[a,b,c, ...d] =tuple;// d: [], the empty tuple"
                },
                {
                    "type": "p",
                    "text": "Or ignore trailing elements, or other elements:"
                },
                {
                    "type": "code",
                    "code": "tslet[a] =tuple;// a: numberlet[,b] =tuple;// b: string"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Object destructuring"
                },
                {
                    "type": "p",
                    "text": "You can also destructure objects:"
                },
                {
                    "type": "code",
                    "code": "tsleto= {a:\"foo\",b:12,c:\"bar\",};let{a,b} =o;"
                },
                {
                    "type": "p",
                    "text": "This creates new variablesaandbfromo.aando.b.\nNotice that you can skipcif you don’t need it."
                },
                {
                    "type": "p",
                    "text": "Like array destructuring, you can have assignment without declaration:"
                },
                {
                    "type": "code",
                    "code": "ts({a,b} = {a:\"baz\",b:101});"
                },
                {
                    "type": "p",
                    "text": "Notice that we had to surround this statement with parentheses.\nJavaScript normally parses a{as the start of block."
                },
                {
                    "type": "p",
                    "text": "You can create a variable for the remaining items in an object using the syntax...:"
                },
                {
                    "type": "code",
                    "code": "tslet{a, ...passthrough} =o;lettotal=passthrough.b+passthrough.c.length;"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Property renaming"
                },
                {
                    "type": "p",
                    "text": "You can also give different names to properties:"
                },
                {
                    "type": "code",
                    "code": "tslet{a:newName1,b:newName2} =o;"
                },
                {
                    "type": "p",
                    "text": "Here the syntax starts to get confusing.\nYou can reada: newName1as ”aasnewName1”.\nThe direction is left-to-right, as if you had written:"
                },
                {
                    "type": "code",
                    "code": "tsletnewName1=o.a;letnewName2=o.b;"
                },
                {
                    "type": "p",
                    "text": "Confusingly, the colon here doesnotindicate the type.\nThe type, if you specify it, still needs to be written after the entire destructuring:"
                },
                {
                    "type": "code",
                    "code": "tslet{a:newName1,b:newName2}: {a:string;b:number} =o;"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Default values"
                },
                {
                    "type": "p",
                    "text": "Default values let you specify a default value in case a property is undefined:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionkeepWholeObject(wholeObject: {a:string;b?:number}) {let{a,b=1001} =wholeObject;}"
                },
                {
                    "type": "p",
                    "text": "In this example theb?indicates thatbis optional, so it may beundefined.keepWholeObjectnow has a variable forwholeObjectas well as the propertiesaandb, even ifbis undefined."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Function declarations"
                },
                {
                    "type": "p",
                    "text": "Destructuring also works in function declarations.\nFor simple cases this is straightforward:"
                },
                {
                    "type": "code",
                    "code": "tstypeC= {a:string;b?:number};functionf({a,b}:C):void{// ...}"
                },
                {
                    "type": "p",
                    "text": "But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky.\nFirst of all, you need to remember to put the pattern before the default value."
                },
                {
                    "type": "code",
                    "code": "tsfunctionf({a=\"\",b=0} = {}):void{// ...}f();"
                },
                {
                    "type": "p",
                    "text": "The snippet above is an example of type inference, explained earlier in the handbook."
                },
                {
                    "type": "p",
                    "text": "Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer.\nRemember thatCwas defined withboptional:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf({a,b=0} = {a:\"\"}):void{// ...}f({a:\"yes\"});// ok, default b = 0f();// ok, default to { a: \"\" }, which then defaults b = 0f({});// error, 'a' is required if you supply an argument"
                },
                {
                    "type": "p",
                    "text": "Use destructuring with care.\nAs the previous example demonstrates, anything but the simplest destructuring expression is confusing.\nThis is especially true with deeply nested destructuring, which getsreallyhard to understand even without piling on renaming, default values, and type annotations.\nTry to keep destructuring expressions small and simple.\nYou can always write the assignments that destructuring would generate yourself."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Spread"
                },
                {
                    "type": "p",
                    "text": "The spread operator is the opposite of destructuring.\nIt allows you to spread an array into another array, or an object into another object.\nFor example:"
                },
                {
                    "type": "code",
                    "code": "tsletfirst= [1,2];letsecond= [3,4];letbothPlus= [0, ...first, ...second,5];"
                },
                {
                    "type": "p",
                    "text": "This gives bothPlus the value[0, 1, 2, 3, 4, 5].\nSpreading creates a shallow copy offirstandsecond.\nThey are not changed by the spread."
                },
                {
                    "type": "p",
                    "text": "You can also spread objects:"
                },
                {
                    "type": "code",
                    "code": "tsletdefaults= {food:\"spicy\",price:\"$$\",ambiance:\"noisy\"};letsearch= { ...defaults,food:\"rich\"};"
                },
                {
                    "type": "p",
                    "text": "Nowsearchis{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }.\nObject spreading is more complex than array spreading.\nLike array spreading, it proceeds from left-to-right, but the result is still an object.\nThis means that properties that come later in the spread object overwrite properties that come earlier.\nSo if we modify the previous example to spread at the end:"
                },
                {
                    "type": "code",
                    "code": "tsletdefaults= {food:\"spicy\",price:\"$$\",ambiance:\"noisy\"};letsearch= {food:\"rich\", ...defaults};"
                },
                {
                    "type": "p",
                    "text": "Then thefoodproperty indefaultsoverwritesfood: \"rich\", which is not what we want in this case."
                },
                {
                    "type": "p",
                    "text": "Object spread also has a couple of other surprising limits.\nFirst, it only includes an objects’own, enumerable properties.\nBasically, that means you lose methods when you spread instances of an object:"
                },
                {
                    "type": "code",
                    "code": "tsclassC{p=12;m() {}}letc=newC();letclone= { ...c};clone.p;// okclone.m();// error!"
                },
                {
                    "type": "p",
                    "text": "Second, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions.\nThat feature is expected in future versions of the language."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "usingdeclarations"
                },
                {
                    "type": "p",
                    "text": "usingdeclarations are an upcoming feature for JavaScript that are part of theStage 3 Explicit Resource Managementproposal. Ausingdeclaration is much like aconstdeclaration, except that it couples thelifetimeof the value bound to the\ndeclaration with thescopeof the variable."
                },
                {
                    "type": "p",
                    "text": "When control exits the block containing ausingdeclaration, the[Symbol.dispose]()method of the\ndeclared value is executed, which allows that value to perform cleanup:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {usingx=newC();doSomethingWith(x);}// `x[Symbol.dispose]()` is called"
                },
                {
                    "type": "p",
                    "text": "At runtime, this has an effectroughlyequivalent to the following:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {constx=newC();try{doSomethingWith(x);}finally{x[Symbol.dispose]();}}"
                },
                {
                    "type": "p",
                    "text": "usingdeclarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to\nnative references like file handles"
                },
                {
                    "type": "code",
                    "code": "ts{usingfile=awaitopenFile();file.write(text);doSomethingThatMayThrow();}// `file` is disposed, even if an error is thrown"
                },
                {
                    "type": "p",
                    "text": "or scoped operations like tracing"
                },
                {
                    "type": "code",
                    "code": "tsfunctionf() {usingactivity=newTraceActivity(\"f\");// traces entry into function// ...}// traces exit of function"
                },
                {
                    "type": "p",
                    "text": "Unlikevar,let, andconst,usingdeclarations do not support destructuring."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "nullandundefined"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that the value can benullorundefined, in which case nothing is disposed at the end of the\nblock:"
                },
                {
                    "type": "code",
                    "code": "ts{usingx=b?newC() :null;// ...}"
                },
                {
                    "type": "p",
                    "text": "which isroughlyequivalent to:"
                },
                {
                    "type": "code",
                    "code": "ts{constx=b?newC() :null;try{// ...}finally{x?.[Symbol.dispose]();}}"
                },
                {
                    "type": "p",
                    "text": "This allows you to conditionally acquire resources when declaring ausingdeclaration without the need for complex\nbranching or repetition."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Defining a disposable resource"
                },
                {
                    "type": "p",
                    "text": "You can indicate the classes or objects you produce are disposable by implementing theDisposableinterface:"
                },
                {
                    "type": "code",
                    "code": "ts// from the default lib:interfaceDisposable{[Symbol.dispose]():void;}// usage:classTraceActivityimplementsDisposable{readonlyname:string;constructor(name:string) {this.name=name;console.log(`Entering:${name}`);}[Symbol.dispose]():void{console.log(`Exiting:${name}`);}}functionf() {using_activity=newTraceActivity(\"f\");console.log(\"Hello world!\");}f();// prints://   Entering: f//   Hello world!//   Exiting: f"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "await usingdeclarations"
                },
                {
                    "type": "p",
                    "text": "Some resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, theExplicit Resource Managementproposal also introduces\ntheawait usingdeclaration:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {awaitusingx=newC();}// `await x[Symbol.asyncDispose]()` is invoked"
                },
                {
                    "type": "p",
                    "text": "Anawait usingdeclaration invokes, andawaits, its value’s[Symbol.asyncDispose]()method as control leaves the\ncontaining block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit,\nor a file stream flushing any pending writes to storage before it is closed."
                },
                {
                    "type": "p",
                    "text": "As withawait,await usingcan only be used in anasyncfunction or method, or at the top level of a module."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Defining an asynchronously disposable resource"
                },
                {
                    "type": "p",
                    "text": "Just asusingrelies on objects that areDisposable, anawait usingrelies on objects that areAsyncDisposable:"
                },
                {
                    "type": "code",
                    "code": "ts// from the default lib:interfaceAsyncDisposable{[Symbol.asyncDispose]:PromiseLike<void>;}// usage:classDatabaseTransactionimplementsAsyncDisposable{publicsuccess=false;privatedb:Database|undefined;privateconstructor(db:Database) {this.db=db;}staticasynccreate(db:Database) {awaitdb.execAsync(\"BEGIN TRANSACTION\");returnnewDatabaseTransaction(db);}async[Symbol.asyncDispose]() {if(this.db) {constdb=this.db:this.db=undefined;if(this.success) {awaitdb.execAsync(\"COMMIT TRANSACTION\");}else{awaitdb.execAsync(\"ROLLBACK TRANSACTION\");}}}}asyncfunctiontransfer(db:Database,account1:Account,account2:Account,amount:number) {usingtx=awaitDatabaseTransaction.create(db);if(awaitdebitAccount(db,account1,amount)) {awaitcreditAccount(db,account2,amount);}// if an exception is thrown before this line, the transaction will roll backtx.success=true;// now the transaction will commit}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "await usingvsawait"
                },
                {
                    "type": "p",
                    "text": "Theawaitkeyword that is part of theawait usingdeclaration only indicates that thedisposalof the resource isawait-ed. It doesnotawaitthe value itself:"
                },
                {
                    "type": "code",
                    "code": "ts{awaitusingx=getResourceSynchronously();}// performs `await x[Symbol.asyncDispose]()`{awaitusingy=awaitgetResourceAsynchronously();}// performs `await y[Symbol.asyncDispose]()`"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "await usingandreturn"
                },
                {
                    "type": "p",
                    "text": "It’s important to note that there is a small caveat with this behavior if you are using anawait usingdeclaration in\nanasyncfunction that returns aPromisewithout firstawait-ing it:"
                },
                {
                    "type": "code",
                    "code": "tsfunctiong() {returnPromise.reject(\"error!\");}asyncfunctionf() {awaitusingx=newC();returng();// missing an `await`}"
                },
                {
                    "type": "p",
                    "text": "Because the returned promise isn’tawait-ed, it’s possible that the JavaScript runtime may report an unhandled\nrejection since execution pauses whileawait-ing the asynchronous disposal ofx, without having subscribed to the\nreturned promise. This is not a problem that is unique toawait using, however, as this can also occur in anasyncfunction that usestry..finally:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {try{returng();// also reports an unhandled rejection}finally{awaitsomethingElse();}}"
                },
                {
                    "type": "p",
                    "text": "To avoid this situation, it is recommended that youawaityour return value if it may be aPromise:"
                },
                {
                    "type": "code",
                    "code": "tsasyncfunctionf() {awaitusingx=newC();returnawaitg();}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "usingandawait usinginforandfor..ofstatements"
                },
                {
                    "type": "p",
                    "text": "Bothusingandawait usingcan be used in aforstatement:"
                },
                {
                    "type": "code",
                    "code": "tsfor(usingx=getReader(); !x.eof;x.next()) {// ...}"
                },
                {
                    "type": "p",
                    "text": "In this case, the lifetime ofxis scoped to the entireforstatement and is only disposed when control leaves the\nloop due tobreak,return,throw, or when the loop condition is false."
                },
                {
                    "type": "p",
                    "text": "In addition toforstatements, both declarations can also be used infor..ofstatements:"
                },
                {
                    "type": "code",
                    "code": "tsfunction*g() {yieldcreateResource1();yieldcreateResource2();}for(usingxofg()) {// ...}"
                },
                {
                    "type": "p",
                    "text": "Here,xis disposed at the end ofeach iteration of the loop, and is then reinitialized with the next value. This is\nespecially useful when consuming resources produced one at a time by a generator."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "usingandawait usingin older runtimes"
                },
                {
                    "type": "p",
                    "text": "usingandawait usingdeclarations can be used when targeting older ECMAScript editions as long as you are using\na compatible polyfill forSymbol.dispose/Symbol.asyncDispose, such as the one provided by default in recent\neditions of NodeJS."
                },
                {
                    "type": "p",
                    "text": "The TypeScript docs are an open source project. Help us improve these pagesby sending a Pull Request❤"
                },
                {
                    "type": "p",
                    "text": "Last updated: Oct 17, 2024"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/download",
            "title": "TypeScript: How to set up TypeScript",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Download TypeScript"
                },
                {
                    "type": "p",
                    "text": "TypeScript can be installed through three installation routes depending on how you intend to use it: an npm module, a NuGet package or a Visual Studio Extension."
                },
                {
                    "type": "p",
                    "text": "If you are using Node.js, you want the npm version. If you are using MSBuild in your project, you want the NuGet package or Visual Studio extension."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript in Your Project"
                },
                {
                    "type": "p",
                    "text": "Having TypeScript set up on a per-project basis lets you have many projects with many different versions of TypeScript, this keeps each project working consistently."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "via npm"
                },
                {
                    "type": "p",
                    "text": "TypeScript is available as apackage on the npm registryavailable as\"typescript\"."
                },
                {
                    "type": "p",
                    "text": "You will need a copy ofNode.jsas an environment to run the package. Then you use a dependency manager likenpm,yarnorpnpmto download TypeScript into your project."
                },
                {
                    "type": "p",
                    "text": "All of these dependency managers support lockfiles, ensuring that everyone on your team is using the same version of the language. You can then run the TypeScript compiler using one of the following commands:"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "with Visual Studio"
                },
                {
                    "type": "p",
                    "text": "For most project types, you can get TypeScript as a package in Nuget for your MSBuild projects, for example an ASP.NET Core app."
                },
                {
                    "type": "p",
                    "text": "When using Nuget, you caninstall TypeScript through Visual Studiousing:"
                },
                {
                    "type": "list",
                    "items": [
                        "The Manage NuGet Packages window (which you can get to by right-clicking on a project node)",
                        "The Nuget Package Manager Console (found in Tools > NuGet Package Manager > Package Manager Console) and then running:Install-Package Microsoft.TypeScript.MSBuild"
                    ]
                },
                {
                    "type": "p",
                    "text": "For project types which don't support Nuget, you can use theTypeScript Visual Studio extension. You caninstall the extensionusingExtensions > Manage Extensionsin Visual Studio."
                },
                {
                    "type": "p",
                    "text": "The examples below are for more advanced use cases."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Globally Installing TypeScript"
                },
                {
                    "type": "p",
                    "text": "It can be handy to have TypeScript available across all projects, often to test one-off ideas. Long-term, codebases should prefer a project-wide installation over a global install so that they can benefit from reproducible builds across different machines."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "via npm"
                },
                {
                    "type": "p",
                    "text": "You can use npm to install TypeScript globally, this means that you can use thetsccommand anywhere in your terminal."
                },
                {
                    "type": "p",
                    "text": "To do this, runnpm install -g typescript. This will install the latest version (currently5.6)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "via Visual Studio Marketplace"
                },
                {
                    "type": "p",
                    "text": "You can install TypeScript as a Visual Studio extension, which will allow you to use TypeScript across many MSBuild projects in Visual Studio."
                },
                {
                    "type": "p",
                    "text": "The latest version is availablein the Visual Studio Marketplace."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Working with TypeScript-compatible transpilers"
                },
                {
                    "type": "p",
                    "text": "There are other tools which convert TypeScript files to JavaScript files. You might use these tools for speed or consistency with your existing build tooling."
                },
                {
                    "type": "p",
                    "text": "Each of these projects handle the file conversion, but do not handle the type-checking aspects of the TypeScript compiler. So it's likely that you will still need to keep the above TypeScript dependency around, and you will want to enableisolatedModules."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Babel"
                },
                {
                    "type": "p",
                    "text": "Babelis a very popular JavaScript transpiler which supports TypeScript files via the plugin@babel/plugin-transform-typescript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "swc"
                },
                {
                    "type": "p",
                    "text": "swcis a fast transpiler created in Rust which supports many of Babel's features including TypeScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Sucrase"
                },
                {
                    "type": "p",
                    "text": "Sucraseis a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next Steps"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Get Started"
                },
                {
                    "type": "list",
                    "items": [
                        "JS to TS",
                        "New to Programming",
                        "OOP to JS",
                        "Functional to JS",
                        "Installation"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Handbook"
                },
                {
                    "type": "list",
                    "items": [
                        "Everyday Types",
                        "Creating Types from Types",
                        "Object Types",
                        "Variable Declarations",
                        "More on Functions"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Tools"
                },
                {
                    "type": "list",
                    "items": [
                        "Playground",
                        "TSConfig Reference"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Release Notes"
                },
                {
                    "type": "list",
                    "items": [
                        "What's upcoming in5.7?",
                        "What's new in5.6"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Tutorials"
                },
                {
                    "type": "list",
                    "items": [
                        "ASP.NET",
                        "Migrating from JS",
                        "Working with the DOM",
                        "React & Webpack"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/index.html#download-links",
            "title": "TypeScript: JavaScript With Syntax For Types.",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "TypeScript isJavaScript with syntax for types."
                },
                {
                    "type": "p",
                    "text": "TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale."
                },
                {
                    "type": "list",
                    "items": [
                        "Editor Checks",
                        "Auto-complete",
                        "Interfaces",
                        "JSX"
                    ]
                },
                {
                    "type": "code",
                    "code": "tsconstuser={firstName:\"Angela\",lastName:\"Davis\",role:\"Professor\",}console.log(user.name)Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'."
                },
                {
                    "type": "code",
                    "code": "tsconstuser={firstName:\"Angela\",lastName:\"Davis\",role:\"Professor\",}console.log(user.name)Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'.2339Property 'name' does not exist on type '{ firstName: string; lastName: string; role: string; }'."
                },
                {
                    "type": "p",
                    "text": "TypeScript5.6is now available,5.7is currently in beta."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What is TypeScript?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "JavaScript and More"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds additional syntax to JavaScript to support atighter integration with your editor. Catch errors early in your editor."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "A Result You Can Trust"
                },
                {
                    "type": "p",
                    "text": "TypeScript code converts to JavaScript, whichruns anywhere JavaScript runs: In a browser, on Node.js or Deno and in your apps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Safety at Scale"
                },
                {
                    "type": "p",
                    "text": "TypeScript understands JavaScript and usestype inference to give you great toolingwithout additional code."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Get Started"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adopt TypeScript Gradually"
                },
                {
                    "type": "p",
                    "text": ""
                },
                {
                    "type": "p",
                    "text": "Apply types to your JavaScript project incrementally,each step improves editor supportand improves your codebase."
                },
                {
                    "type": "p",
                    "text": "Let's take this incorrect JavaScript code, and see howTypeScript can catch mistakes in your editor."
                },
                {
                    "type": "code",
                    "code": "jsfunctioncompact(arr) {if(orr.length>10)returnarr.trim(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "No editor warnings in JavaScript filesThis code crashes at runtime!"
                },
                {
                    "type": "p",
                    "text": "JavaScript file"
                },
                {
                    "type": "code",
                    "code": "js// @ts-checkfunctioncompact(arr) {if(orr.length>10)Cannot find name 'orr'.2304Cannot find name 'orr'.returnarr.trim(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "Adding this to a JS file shows errors in your editor"
                },
                {
                    "type": "p",
                    "text": "the param is arr, not orr!"
                },
                {
                    "type": "p",
                    "text": "JavaScript with TS Check"
                },
                {
                    "type": "code",
                    "code": "js// @ts-check/**@param{any[]}arr*/functioncompact(arr) {if(arr.length>10)returnarr.trim(0,10)Property 'trim' does not exist on type 'any[]'.2339Property 'trim' does not exist on type 'any[]'.returnarr}"
                },
                {
                    "type": "p",
                    "text": "Using JSDoc to give type information"
                },
                {
                    "type": "p",
                    "text": "Now TS has found a bad call. Arrays have slice, not trim."
                },
                {
                    "type": "p",
                    "text": "JavaScript with JSDoc"
                },
                {
                    "type": "code",
                    "code": "tsfunctioncompact(arr:string[]) {if(arr.length>10)returnarr.slice(0,10)returnarr}"
                },
                {
                    "type": "p",
                    "text": "TypeScript adds natural syntax for providing types"
                },
                {
                    "type": "p",
                    "text": "TypeScript file"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Describe Your Data"
                },
                {
                    "type": "p",
                    "text": "Describe the shape of objects and functionsin your code."
                },
                {
                    "type": "p",
                    "text": "Making it possible to seedocumentation and issues in your editor."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceAccount{id:numberdisplayName:stringversion:1}functionwelcome(user:Account) {console.log(user.id)}"
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript becomes JavaScript via the delete key."
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "TypeScript file."
                },
                {
                    "type": "code",
                    "code": "tstypeResult=\"pass\"|\"fail\"functionverify(result:Result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "Types are removed."
                },
                {
                    "type": "code",
                    "code": "jsfunctionverify(result) {if(result===\"pass\") {console.log(\"Passed\")}else{console.log(\"Failed\")}}"
                },
                {
                    "type": "p",
                    "text": "JavaScript file."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript Testimonials"
                },
                {
                    "type": "p",
                    "text": "First, we were surprised by the number of small bugs we found when converting our code."
                },
                {
                    "type": "p",
                    "text": "Second, we underestimated how powerful the editor integration is."
                },
                {
                    "type": "p",
                    "text": "TypeScript was such a boon to our stability and sanity that we started using it for all new code within days of starting the conversion."
                },
                {
                    "type": "p",
                    "text": "Felix Rieseberg at Slack covered the transition of their desktop app from JavaScript to TypeScript in their blog"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Open Source with TypeScript"
                },
                {
                    "type": "p",
                    "text": "Angular"
                },
                {
                    "type": "p",
                    "text": "Vue"
                },
                {
                    "type": "p",
                    "text": "Jest"
                },
                {
                    "type": "p",
                    "text": "Redux"
                },
                {
                    "type": "p",
                    "text": "Ionic"
                },
                {
                    "type": "p",
                    "text": "Probot"
                },
                {
                    "type": "p",
                    "text": "Deno"
                },
                {
                    "type": "p",
                    "text": "Vercel"
                },
                {
                    "type": "p",
                    "text": "Yarn"
                },
                {
                    "type": "p",
                    "text": "GitHubDesktop"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Loved by Developers"
                },
                {
                    "type": "p",
                    "text": "Voted2nd most loved programming languagein theStack Overflow 2020 Developer survey"
                },
                {
                    "type": "p",
                    "text": "TypeScript wasused by 78%of the2020 State of JSrespondents, with93% saying they would use it again."
                },
                {
                    "type": "p",
                    "text": "TypeScript was given the award for“Most Adopted Technology”based on year-on-year growth."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Get Started"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?e=83#example/types-vs-interfaces",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?esModuleInterop=true&q=496#example/function-chaining",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?jsx=2&esModuleInterop=true&q=324#example/typescript-with-react",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?noImplicitAny=false&q=488#example/functions",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=126#example/async-await",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=129#example/this",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=130#example/indexed-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=151#example/conditional-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=156#example/immutability",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=166#example/nominal-typing",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=201#example/generic-functions",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=244#example/unknown-and-never",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=25#example/any",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=292#example/mapped-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=30#example/mixins",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=310#example/import-export",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=330#example/typing-functions",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=332#example/classes-101",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=346#example/types-vs-interfaces",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=357#example/typescript-with-deno",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=365#example/structural-typing",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=369#example/type-widening-and-narrowing",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=372#example/generic-classes",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=382#example/quick-fixes",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=390#example/enums",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=398#example/literals",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=435#example/type-guards",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=6#example/tuples",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=76#example/errors",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?q=86#example/union-and-intersection-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?strict=false&q=247#example/objects-and-arrays",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?strictFunctionTypes=false&q=147#example/soundness",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?strictNullChecks=false&q=327#example/nullable-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?strictNullChecks=true&q=126#example/built-in-utility-types",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?strictNullChecks=true&q=338#example/code-flow",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?target=1&q=162#example/hello-world",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=trueq=1#example/jsdoc-support",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=trueq=188#example/typescript-with-webgl",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=trueq=302#example/typescript-with-node",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/play?useJavaScript=trueq=463#example/typescript-with-web",
            "title": "TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript",
            "content": [
                {
                    "type": "p",
                    "text": "Downloading TypeScript..."
                },
                {
                    "type": "list",
                    "items": [
                        "Version......",
                        "Run",
                        "ExportTweet link to PlaygroundCopy as Markdown IssueCopy as Markdown LinkCopy as Markdown Link with PreviewOpen in TypeScript AST ViewerOpen in Bug WorkbenchOpen in VSCode TS Playground (alpha)Open in CodeSandboxOpen in StackBlitz",
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz",
                        "Share"
                    ]
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "list",
                    "items": [
                        "Tweet link to Playground",
                        "",
                        "Copy as Markdown Issue",
                        "Copy as Markdown Link",
                        "Copy as Markdown Link with Preview",
                        "",
                        "Open in TypeScript AST Viewer",
                        "Open in Bug Workbench",
                        "Open in VSCode TS Playground (alpha)",
                        "",
                        "Open in CodeSandbox",
                        "Open in StackBlitz"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "⇥"
                    ]
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/tools",
            "title": "TypeScript: Reference Tools",
            "content": [
                {
                    "type": "p",
                    "text": "Playground"
                },
                {
                    "type": "p",
                    "text": "A live environment for exploring, learning and sharing TypeScript code. Try different compiler flags, run through extensive code samples to learn specifics about how TypeScript works."
                },
                {
                    "type": "p",
                    "text": "TSConfig Reference"
                },
                {
                    "type": "p",
                    "text": "An annotated reference to more than a hundred compiler options available in atsconfig.jsonorjsconfig.json."
                },
                {
                    "type": "p",
                    "text": "Cheat Sheets"
                },
                {
                    "type": "p",
                    "text": "Quickly look up the syntax for common TypeScript code."
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/tsconfig",
            "title": "TypeScript: TSConfig Reference - Docs on every TSConfig option",
            "content": [
                {
                    "type": "header",
                    "level": 2,
                    "text": "Intro to the TSConfig Reference"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Compiler Options"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Top Level"
                },
                {
                    "type": "list",
                    "items": [
                        "files,",
                        "extends,",
                        "include,",
                        "excludeand",
                        "references"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "\"compilerOptions\""
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Type Checking"
                },
                {
                    "type": "list",
                    "items": [
                        "allowUnreachableCode,",
                        "allowUnusedLabels,",
                        "alwaysStrict,",
                        "exactOptionalPropertyTypes,",
                        "noFallthroughCasesInSwitch,",
                        "noImplicitAny,",
                        "noImplicitOverride,",
                        "noImplicitReturns,",
                        "noImplicitThis,",
                        "noPropertyAccessFromIndexSignature,",
                        "noUncheckedIndexedAccess,",
                        "noUnusedLocals,",
                        "noUnusedParameters,",
                        "strict,",
                        "strictBindCallApply,",
                        "strictBuiltinIteratorReturn,",
                        "strictFunctionTypes,",
                        "strictNullChecks,",
                        "strictPropertyInitializationand",
                        "useUnknownInCatchVariables"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Modules"
                },
                {
                    "type": "list",
                    "items": [
                        "allowArbitraryExtensions,",
                        "allowImportingTsExtensions,",
                        "allowUmdGlobalAccess,",
                        "baseUrl,",
                        "customConditions,",
                        "module,",
                        "moduleResolution,",
                        "moduleSuffixes,",
                        "noResolve,",
                        "noUncheckedSideEffectImports,",
                        "paths,",
                        "resolveJsonModule,",
                        "resolvePackageJsonExports,",
                        "resolvePackageJsonImports,",
                        "rootDir,",
                        "rootDirs,",
                        "typeRootsand",
                        "types"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Emit"
                },
                {
                    "type": "list",
                    "items": [
                        "declaration,",
                        "declarationDir,",
                        "declarationMap,",
                        "downlevelIteration,",
                        "emitBOM,",
                        "emitDeclarationOnly,",
                        "importHelpers,",
                        "inlineSourceMap,",
                        "inlineSources,",
                        "mapRoot,",
                        "newLine,",
                        "noEmit,",
                        "noEmitHelpers,",
                        "noEmitOnError,",
                        "outDir,",
                        "outFile,",
                        "preserveConstEnums,",
                        "removeComments,",
                        "sourceMap,",
                        "sourceRootand",
                        "stripInternal"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "JavaScript Support"
                },
                {
                    "type": "list",
                    "items": [
                        "allowJs,",
                        "checkJsand",
                        "maxNodeModuleJsDepth"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Editor Support"
                },
                {
                    "type": "list",
                    "items": [
                        "disableSizeLimitand",
                        "plugins"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Interop Constraints"
                },
                {
                    "type": "list",
                    "items": [
                        "allowSyntheticDefaultImports,",
                        "esModuleInterop,",
                        "forceConsistentCasingInFileNames,",
                        "isolatedDeclarations,",
                        "isolatedModules,",
                        "preserveSymlinksand",
                        "verbatimModuleSyntax"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Backwards Compatibility"
                },
                {
                    "type": "list",
                    "items": [
                        "charset,",
                        "importsNotUsedAsValues,",
                        "keyofStringsOnly,",
                        "noImplicitUseStrict,",
                        "noStrictGenericChecks,",
                        "out,",
                        "preserveValueImports,",
                        "suppressExcessPropertyErrorsand",
                        "suppressImplicitAnyIndexErrors"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Language and Environment"
                },
                {
                    "type": "list",
                    "items": [
                        "emitDecoratorMetadata,",
                        "experimentalDecorators,",
                        "jsx,",
                        "jsxFactory,",
                        "jsxFragmentFactory,",
                        "jsxImportSource,",
                        "lib,",
                        "moduleDetection,",
                        "noLib,",
                        "reactNamespace,",
                        "targetand",
                        "useDefineForClassFields"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Compiler Diagnostics"
                },
                {
                    "type": "list",
                    "items": [
                        "diagnostics,",
                        "explainFiles,",
                        "extendedDiagnostics,",
                        "generateCpuProfile,",
                        "generateTrace,",
                        "listEmittedFiles,",
                        "listFiles,",
                        "noCheckand",
                        "traceResolution"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Projects"
                },
                {
                    "type": "list",
                    "items": [
                        "composite,",
                        "disableReferencedProjectLoad,",
                        "disableSolutionSearching,",
                        "disableSourceOfProjectReferenceRedirect,",
                        "incrementaland",
                        "tsBuildInfoFile"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Output Formatting"
                },
                {
                    "type": "list",
                    "items": [
                        "noErrorTruncation,",
                        "preserveWatchOutputand",
                        "pretty"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Completeness"
                },
                {
                    "type": "list",
                    "items": [
                        "skipDefaultLibCheckand",
                        "skipLibCheck"
                    ]
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Command Line"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Watch Options"
                },
                {
                    "type": "list",
                    "items": [
                        "assumeChangesOnlyAffectDirectDependencies"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "\"watchOptions\""
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "watchOptions"
                },
                {
                    "type": "list",
                    "items": [
                        "watchFile,",
                        "watchDirectory,",
                        "fallbackPolling,",
                        "synchronousWatchDirectory,",
                        "excludeDirectoriesand",
                        "excludeFiles"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "\"typeAcquisition\""
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "typeAcquisition"
                },
                {
                    "type": "list",
                    "items": [
                        "enable,",
                        "include,",
                        "excludeand",
                        "disableFilenameBasedTypeAcquisition"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Root Fields"
                },
                {
                    "type": "p",
                    "text": "Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Files -files"
                },
                {
                    "type": "p",
                    "text": "Specifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found."
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {},\"files\": [\"core.ts\",\"sys.ts\",\"types.ts\",\"scanner.ts\",\"parser.ts\",\"utilities.ts\",\"binder.ts\",\"checker.ts\",\"tsc.ts\"]}"
                },
                {
                    "type": "p",
                    "text": "This is useful when you only have a small number of files and don’t need to use a glob to reference many files.\nIf you need that then useinclude."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:false",
                        "Related:includeexclude",
                        "include",
                        "exclude"
                    ]
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "list",
                    "items": [
                        "include",
                        "exclude"
                    ]
                },
                {
                    "type": "p",
                    "text": "include"
                },
                {
                    "type": "p",
                    "text": "exclude"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Extends -extends"
                },
                {
                    "type": "p",
                    "text": "The value ofextendsis a string which contains a path to another configuration file to inherit from.\nThe path may use Node.js style resolution."
                },
                {
                    "type": "p",
                    "text": "The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in."
                },
                {
                    "type": "p",
                    "text": "It’s worth noting thatfiles,include, andexcludefrom the inheriting config fileoverwritethose from the\nbase config file, and that circularity between configuration files is not allowed."
                },
                {
                    "type": "p",
                    "text": "Currently, the only top-level property that is excluded from inheritance isreferences."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Example"
                },
                {
                    "type": "p",
                    "text": "configs/base.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"noImplicitAny\":true,\"strictNullChecks\":true}}"
                },
                {
                    "type": "p",
                    "text": "tsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"extends\":\"./configs/base\",\"files\": [\"main.ts\",\"supplemental.ts\"]}"
                },
                {
                    "type": "p",
                    "text": "tsconfig.nostrictnull.json:"
                },
                {
                    "type": "code",
                    "code": "{\"extends\":\"./tsconfig\",\"compilerOptions\": {\"strictNullChecks\":false}}"
                },
                {
                    "type": "p",
                    "text": "Properties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:false",
                        "Released:2.1"
                    ]
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "p",
                    "text": "2.1"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Include -include"
                },
                {
                    "type": "p",
                    "text": "Specifies an array of filenames or patterns to include in the program.\nThese filenames are resolved relative to the directory containing thetsconfig.jsonfile."
                },
                {
                    "type": "code",
                    "code": "json{\"include\": [\"src/**/*\",\"tests/**/*\"]}"
                },
                {
                    "type": "p",
                    "text": "Which would include:"
                },
                {
                    "type": "code",
                    "code": ".├── scripts                ⨯│   ├── lint.ts            ⨯│   ├── update_deps.ts     ⨯│   └── utils.ts           ⨯├── src                    ✓│   ├── client             ✓│   │    ├── index.ts      ✓│   │    └── utils.ts      ✓│   ├── server             ✓│   │    └── index.ts      ✓├── tests                  ✓│   ├── app.test.ts        ✓│   ├── utils.ts           ✓│   └── tests.d.ts         ✓├── package.json├── tsconfig.json└── yarn.lock"
                },
                {
                    "type": "p",
                    "text": "includeandexcludesupport wildcard characters to make glob patterns:"
                },
                {
                    "type": "list",
                    "items": [
                        "*matches zero or more characters (excluding directory separators)",
                        "?matches any one character (excluding directory separators)",
                        "**/matches any directory nested to any level"
                    ]
                },
                {
                    "type": "p",
                    "text": "If the last path segment in a pattern does not contain a file extension or wildcard character, then it is treated as a directory, and files with supported extensions inside that directory are included (e.g..ts,.tsx, and.d.tsby default, with.jsand.jsxifallowJsis set to true)."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:[]iffilesis specified;**/*otherwise.",
                        "Related:filesexclude",
                        "files",
                        "exclude",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "[]iffilesis specified;**/*otherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "files",
                        "exclude"
                    ]
                },
                {
                    "type": "p",
                    "text": "files"
                },
                {
                    "type": "p",
                    "text": "exclude"
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Exclude -exclude"
                },
                {
                    "type": "p",
                    "text": "Specifies an array of filenames or patterns that should be skipped when resolvinginclude."
                },
                {
                    "type": "p",
                    "text": "Important:excludeonlychanges which files are included as a result of theincludesetting.\nA file specified byexcludecan still become part of your codebase due to animportstatement in your code, atypesinclusion, a/// <referencedirective, or being specified in thefileslist."
                },
                {
                    "type": "p",
                    "text": "It is not a mechanism thatpreventsa file from being included in the codebase - it simply changes what theincludesetting finds."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:node_modules bower_components jspm_packagesoutDir",
                        "Related:includefiles",
                        "include",
                        "files"
                    ]
                },
                {
                    "type": "p",
                    "text": "node_modules bower_components jspm_packagesoutDir"
                },
                {
                    "type": "list",
                    "items": [
                        "include",
                        "files"
                    ]
                },
                {
                    "type": "p",
                    "text": "include"
                },
                {
                    "type": "p",
                    "text": "files"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#References -references"
                },
                {
                    "type": "p",
                    "text": "Project references are a way to structure your TypeScript programs into smaller pieces.\nUsing Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways."
                },
                {
                    "type": "p",
                    "text": "You can read more about how references works in theProject Referencessection of the handbook"
                },
                {
                    "type": "list",
                    "items": [
                        "Default:false"
                    ]
                },
                {
                    "type": "p",
                    "text": "false"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Compiler Options"
                },
                {
                    "type": "p",
                    "text": "These options make up the bulk of TypeScript’s configuration and it covers how the language should work."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Type Checking"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Unreachable Code -allowUnreachableCode"
                },
                {
                    "type": "p",
                    "text": "When:"
                },
                {
                    "type": "list",
                    "items": [
                        "undefined(default) provide suggestions as warnings to editors",
                        "trueunreachable code is ignored",
                        "falseraises compiler errors about unreachable code"
                    ]
                },
                {
                    "type": "p",
                    "text": "These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(n:number) {if(n>5) {returntrue;}else{returnfalse;}returntrue;}"
                },
                {
                    "type": "p",
                    "text": "With\"allowUnreachableCode\": false:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(n:number) {if(n>5) {returntrue;}else{returnfalse;}returntrue;Unreachable code detected.7027Unreachable code detected.}Try"
                },
                {
                    "type": "p",
                    "text": "This does not affect errors on the basis of code whichappearsto be unreachable due to type analysis."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Unused Labels -allowUnusedLabels"
                },
                {
                    "type": "p",
                    "text": "When:"
                },
                {
                    "type": "list",
                    "items": [
                        "undefined(default) provide suggestions as warnings to editors",
                        "trueunused labels are ignored",
                        "falseraises compiler errors about unused labels"
                    ]
                },
                {
                    "type": "p",
                    "text": "Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionverifyAge(age:number) {// Forgot 'return' statementif(age>18) {verified:true;Unused label.7028Unused label.}}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Always Strict -alwaysStrict"
                },
                {
                    "type": "p",
                    "text": "Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file."
                },
                {
                    "type": "p",
                    "text": "ECMAScript strictmode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:2.1"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "2.1"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Exact Optional Property Types -exactOptionalPropertyTypes"
                },
                {
                    "type": "p",
                    "text": "With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties ontypeorinterfaceswhich have a?prefix."
                },
                {
                    "type": "p",
                    "text": "For example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceUserDefaults{// The absence of a value represents 'system'colorThemeOverride?:\"dark\"|\"light\";}"
                },
                {
                    "type": "p",
                    "text": "Without this flag enabled, there are three values which you can setcolorThemeOverrideto be: “dark”, “light” andundefined."
                },
                {
                    "type": "p",
                    "text": "Setting the value toundefinedwill allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate;colorThemeOverride: undefinedis not the same ascolorThemeOverridenot being defined. For example,\"colorThemeOverride\" in settingswould have different behavior withundefinedas the key compared to not being defined."
                },
                {
                    "type": "p",
                    "text": "exactOptionalPropertyTypesmakes TypeScript truly enforce the definition provided as an optional property:"
                },
                {
                    "type": "code",
                    "code": "tsconstsettings=getUserSettings();settings.colorThemeOverride=\"dark\";settings.colorThemeOverride=\"light\";// But not:settings.colorThemeOverride=undefined;Type 'undefined' is not assignable to type '\"dark\" | \"light\"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.2412Type 'undefined' is not assignable to type '\"dark\" | \"light\"' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Released:4.4"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.4"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Fallthrough Cases In Switch -noFallthroughCasesInSwitch"
                },
                {
                    "type": "p",
                    "text": "Report errors for fallthrough cases in switch statements.\nEnsures that any non-empty case inside a switch statement includes eitherbreak,return, orthrow.\nThis means you won’t accidentally ship a case fallthrough bug."
                },
                {
                    "type": "code",
                    "code": "tsconsta:number=6;switch(a) {case0:Fallthrough case in switch.7029Fallthrough case in switch.console.log(\"even\");case1:console.log(\"odd\");break;}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Implicit Any -noImplicitAny"
                },
                {
                    "type": "p",
                    "text": "In some cases where no type annotations are present, TypeScript will fall back to a type ofanyfor a variable when it cannot infer the type."
                },
                {
                    "type": "p",
                    "text": "This can cause some errors to be missed, for example:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(s) {// No error?console.log(s.subtr(3));}fn(42);Try"
                },
                {
                    "type": "p",
                    "text": "Turning onnoImplicitAnyhowever TypeScript will issue an error whenever it would have inferredany:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.console.log(s.subtr(3));}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Implicit Override -noImplicitOverride"
                },
                {
                    "type": "p",
                    "text": "When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class."
                },
                {
                    "type": "p",
                    "text": "For example, imagine you are modeling a music album syncing system:"
                },
                {
                    "type": "code",
                    "code": "tsclassAlbum{download() {// Default behavior}}classSharedAlbumextendsAlbum{download() {// Override to get info from many sources}}Try"
                },
                {
                    "type": "p",
                    "text": "Then when you add support for machine-learning generated playlists, you refactor theAlbumclass to have a ‘setup’ function instead:"
                },
                {
                    "type": "code",
                    "code": "tsclassAlbum{setup() {// Default behavior}}classMLAlbumextendsAlbum{setup() {// Override to get info from algorithm}}classSharedAlbumextendsAlbum{download() {// Override to get info from many sources}}Try"
                },
                {
                    "type": "p",
                    "text": "In this case, TypeScript has provided no warning thatdownloadonSharedAlbumexpectedto override a function in the base class."
                },
                {
                    "type": "p",
                    "text": "UsingnoImplicitOverrideyou can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keywordoverride."
                },
                {
                    "type": "p",
                    "text": "The following example hasnoImplicitOverrideenabled, and you can see the error received whenoverrideis missing:"
                },
                {
                    "type": "code",
                    "code": "tsclassAlbum{setup() {}}classMLAlbumextendsAlbum{overridesetup() {}}classSharedAlbumextendsAlbum{setup() {}This member must have an 'override' modifier because it overrides a member in the base class 'Album'.4114This member must have an 'override' modifier because it overrides a member in the base class 'Album'.}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.3"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.3"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Implicit Returns -noImplicitReturns"
                },
                {
                    "type": "p",
                    "text": "When enabled, TypeScript will check all code paths in a function to ensure they return a value."
                },
                {
                    "type": "code",
                    "code": "tsfunctionlookupHeadphonesManufacturer(color:\"blue\"|\"black\"):string{Function lacks ending return statement and return type does not include 'undefined'.2366Function lacks ending return statement and return type does not include 'undefined'.if(color===\"blue\") {return\"beats\";}else{(\"bose\");}}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Implicit This -noImplicitThis"
                },
                {
                    "type": "p",
                    "text": "Raise error on ‘this’ expressions with an implied ‘any’ type."
                },
                {
                    "type": "p",
                    "text": "For example, the class below returns a function which tries to accessthis.widthandthis.height– but the context\nforthisinside the function insidegetAreaFunctionis not the instance of the Rectangle."
                },
                {
                    "type": "code",
                    "code": "tsclassRectangle{width:number;height:number;constructor(width:number,height:number) {this.width=width;this.height=height;}getAreaFunction() {returnfunction() {returnthis.width*this.height;'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.26832683'this' implicitly has type 'any' because it does not have a type annotation.'this' implicitly has type 'any' because it does not have a type annotation.};}}Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Property Access From Index Signature -noPropertyAccessFromIndexSignature"
                },
                {
                    "type": "p",
                    "text": "This setting ensures consistency between accessing a field via the “dot” (obj.key) syntax, and “indexed” (obj[\"key\"]) and the way which the property is declared in the type."
                },
                {
                    "type": "p",
                    "text": "Without this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:"
                },
                {
                    "type": "code",
                    "code": "tsinterfaceGameSettings{// Known up-front propertiesspeed:\"fast\"|\"medium\"|\"slow\";quality:\"high\"|\"low\";// Assume anything unknown to the interface// is a string.[key:string]:string;}constsettings=getSettings();settings.speed;(property) GameSettings.speed: \"fast\" | \"medium\" | \"slow\"settings.quality;(property) GameSettings.quality: \"high\" | \"low\"// Unknown key accessors are allowed on// this object, and are `string`settings.username;(index) GameSettings[string]: stringTry"
                },
                {
                    "type": "p",
                    "text": "Turning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax."
                },
                {
                    "type": "code",
                    "code": "tsconstsettings=getSettings();settings.speed;settings.quality;// This would need to be settings[\"username\"];settings.username;Property 'username' comes from an index signature, so it must be accessed with ['username'].4111Property 'username' comes from an index signature, so it must be accessed with ['username'].(index) GameSettings[string]: stringTry"
                },
                {
                    "type": "p",
                    "text": "The goal of this flag is to signal intent in your calling syntax about how certain you are this property exists."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.2"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.2"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Unchecked Indexed Access -noUncheckedIndexedAccess"
                },
                {
                    "type": "p",
                    "text": "TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures."
                },
                {
                    "type": "code",
                    "code": "tsinterfaceEnvironmentVars{NAME:string;OS:string;// Unknown properties are covered by this index signature.[propName:string]:string;}declareconstenv:EnvironmentVars;// Declared as existingconstsysName=env.NAME;constos=env.OS;const os: string// Not declared, but because of the index// signature, then it is considered a stringconstnodeEnv=env.NODE_ENV;const nodeEnv: stringTry"
                },
                {
                    "type": "p",
                    "text": "Turning onnoUncheckedIndexedAccesswill addundefinedto any un-declared field in the type."
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstenv:EnvironmentVars;// Declared as existingconstsysName=env.NAME;constos=env.OS;const os: string// Not declared, but because of the index// signature, then it is considered a stringconstnodeEnv=env.NODE_ENV;const nodeEnv: string | undefinedTry"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.1"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.1"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Unused Locals -noUnusedLocals"
                },
                {
                    "type": "p",
                    "text": "Report errors on unused local variables."
                },
                {
                    "type": "code",
                    "code": "tsconstcreateKeyboard= (modelID:number)=>{constdefaultModelID=23;'defaultModelID' is declared but its value is never read.6133'defaultModelID' is declared but its value is never read.return{type:\"keyboard\",modelID};};Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Unused Parameters -noUnusedParameters"
                },
                {
                    "type": "p",
                    "text": "Report errors on unused parameters in functions."
                },
                {
                    "type": "code",
                    "code": "tsconstcreateDefaultKeyboard= (modelID:number)=>{'modelID' is declared but its value is never read.6133'modelID' is declared but its value is never read.constdefaultModelID=23;return{type:\"keyboard\",modelID:defaultModelID};};Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strict -strict"
                },
                {
                    "type": "p",
                    "text": "Thestrictflag enables a wide range of type checking behavior that results in stronger guarantees of program correctness.\nTurning this on is equivalent to enabling all of thestrict mode familyoptions, which are outlined below.\nYou can then turn off individual strict mode family checks as needed."
                },
                {
                    "type": "p",
                    "text": "Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program.\nWhen appropriate and possible, a corresponding flag will be added to disable that behavior."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Related:alwaysStrictstrictNullChecksstrictBindCallApplystrictFunctionTypesstrictPropertyInitializationnoImplicitAnynoImplicitThisuseUnknownInCatchVariables",
                        "alwaysStrict",
                        "strictNullChecks",
                        "strictBindCallApply",
                        "strictFunctionTypes",
                        "strictPropertyInitialization",
                        "noImplicitAny",
                        "noImplicitThis",
                        "useUnknownInCatchVariables",
                        "Released:2.3"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "alwaysStrict",
                        "strictNullChecks",
                        "strictBindCallApply",
                        "strictFunctionTypes",
                        "strictPropertyInitialization",
                        "noImplicitAny",
                        "noImplicitThis",
                        "useUnknownInCatchVariables"
                    ]
                },
                {
                    "type": "p",
                    "text": "alwaysStrict"
                },
                {
                    "type": "p",
                    "text": "strictNullChecks"
                },
                {
                    "type": "p",
                    "text": "strictBindCallApply"
                },
                {
                    "type": "p",
                    "text": "strictFunctionTypes"
                },
                {
                    "type": "p",
                    "text": "strictPropertyInitialization"
                },
                {
                    "type": "p",
                    "text": "noImplicitAny"
                },
                {
                    "type": "p",
                    "text": "noImplicitThis"
                },
                {
                    "type": "p",
                    "text": "useUnknownInCatchVariables"
                },
                {
                    "type": "p",
                    "text": "2.3"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strict Bind Call Apply -strictBindCallApply"
                },
                {
                    "type": "p",
                    "text": "When set, TypeScript will check that the built-in methods of functionscall,bind, andapplyare invoked with correct argument for the underlying function:"
                },
                {
                    "type": "code",
                    "code": "ts// With strictBindCallApply onfunctionfn(x:string) {returnparseInt(x);}constn1=fn.call(undefined,\"10\");constn2=fn.call(undefined,false);Argument of type 'boolean' is not assignable to parameter of type 'string'.2345Argument of type 'boolean' is not assignable to parameter of type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "Otherwise, these functions accept any arguments and will returnany:"
                },
                {
                    "type": "code",
                    "code": "ts// With strictBindCallApply offfunctionfn(x:string) {returnparseInt(x);}// Note: No error; return type is 'any'constn=fn.call(undefined,false);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:3.2"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "3.2"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#strictBuiltinIteratorReturn -strictBuiltinIteratorReturn"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:false, unlessstrictis set"
                    ]
                },
                {
                    "type": "p",
                    "text": "false, unlessstrictis set"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strict Function Types -strictFunctionTypes"
                },
                {
                    "type": "p",
                    "text": "When enabled, this flag causes functions parameters to be checked more correctly."
                },
                {
                    "type": "p",
                    "text": "Here’s a basic example withstrictFunctionTypesoff:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string) {console.log(\"Hello, \"+x.toLowerCase());}typeStringOrNumberFunc= (ns:string|number)=>void;// Unsafe assignmentletfunc:StringOrNumberFunc=fn;// Unsafe call - will crashfunc(10);Try"
                },
                {
                    "type": "p",
                    "text": "WithstrictFunctionTypeson, the error is correctly detected:"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfn(x:string) {console.log(\"Hello, \"+x.toLowerCase());}typeStringOrNumberFunc= (ns:string|number)=>void;// Unsafe assignment is preventedletfunc:StringOrNumberFunc=fn;Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.\n  Types of parameters 'x' and 'ns' are incompatible.\n    Type 'string | number' is not assignable to type 'string'.\n      Type 'number' is not assignable to type 'string'.2322Type '(x: string) => void' is not assignable to type 'StringOrNumberFunc'.\n  Types of parameters 'x' and 'ns' are incompatible.\n    Type 'string | number' is not assignable to type 'string'.\n      Type 'number' is not assignable to type 'string'.Try"
                },
                {
                    "type": "p",
                    "text": "During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM.\nBecause of this, the setting only applies to functions written infunctionsyntax, not to those inmethodsyntax:"
                },
                {
                    "type": "code",
                    "code": "tstypeMethodish= {func(x:string|number):void;};functionfn(x:string) {console.log(\"Hello, \"+x.toLowerCase());}// Ultimately an unsafe assignment, but not detectedconstm:Methodish= {func:fn,};m.func(10);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:2.6"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "2.6"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strict Null Checks -strictNullChecks"
                },
                {
                    "type": "p",
                    "text": "WhenstrictNullChecksisfalse,nullandundefinedare effectively ignored by the language.\nThis can lead to unexpected errors at runtime."
                },
                {
                    "type": "p",
                    "text": "WhenstrictNullChecksistrue,nullandundefinedhave their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected."
                },
                {
                    "type": "p",
                    "text": "For example with this TypeScript code,users.findhas no guarantee that it will actually find a user, but you can\nwrite code as though it will:"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstloggedInUsername:string;constusers= [{name:\"Oby\",age:12},{name:\"Heera\",age:32},];constloggedInUser=users.find((u)=>u.name===loggedInUsername);console.log(loggedInUser.age);Try"
                },
                {
                    "type": "p",
                    "text": "SettingstrictNullCheckstotruewill raise an error that you have not made a guarantee that theloggedInUserexists before trying to use it."
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstloggedInUsername:string;constusers= [{name:\"Oby\",age:12},{name:\"Heera\",age:32},];constloggedInUser=users.find((u)=>u.name===loggedInUsername);console.log(loggedInUser.age);'loggedInUser' is possibly 'undefined'.18048'loggedInUser' is possibly 'undefined'.Try"
                },
                {
                    "type": "p",
                    "text": "The second example failed because the array’sfindfunction looks a bit like this simplification:"
                },
                {
                    "type": "code",
                    "code": "ts// When strictNullChecks: truetypeArray= {find(predicate: (value:any,index:number)=>boolean):S|undefined;};// When strictNullChecks: false the undefined is removed from the type system,// allowing you to write code which assumes it always found a resulttypeArray= {find(predicate: (value:any,index:number)=>boolean):S;};"
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strict Property Initialization -strictPropertyInitialization"
                },
                {
                    "type": "p",
                    "text": "When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor."
                },
                {
                    "type": "code",
                    "code": "tsclassUserAccount{name:string;accountType=\"user\";email:string;Property 'email' has no initializer and is not definitely assigned in the constructor.2564Property 'email' has no initializer and is not definitely assigned in the constructor.address:string|undefined;constructor(name:string) {this.name=name;// Note that this.email is not set}}Try"
                },
                {
                    "type": "p",
                    "text": "In the above case:"
                },
                {
                    "type": "list",
                    "items": [
                        "this.nameis set specifically.",
                        "this.accountTypeis set by default.",
                        "this.emailis not set and raises an error.",
                        "this.addressis declared as potentiallyundefinedwhich means it does not have to be set."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:2.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "2.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Use Unknown In Catch Variables -useUnknownInCatchVariables"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause fromanytounknown. Allowing for code like:"
                },
                {
                    "type": "code",
                    "code": "tstry{// ...}catch(err:unknown) {// We have to verify err is an// error before using it as one.if(errinstanceofError) {console.log(err.message);}}Try"
                },
                {
                    "type": "p",
                    "text": "This pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrownisa Error subclass ahead of time. With the flaguseUnknownInCatchVariablesenabled, then you do not need the additional syntax (: unknown) nor a linter rule to try enforce this behavior."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifstrict;falseotherwise.",
                        "Related:strict",
                        "strict",
                        "Released:4.4"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifstrict;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "strict"
                    ]
                },
                {
                    "type": "p",
                    "text": "strict"
                },
                {
                    "type": "p",
                    "text": "4.4"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Modules"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Arbitrary Extensions -allowArbitraryExtensions"
                },
                {
                    "type": "p",
                    "text": "In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of{file basename}.d.{extension}.ts.\nFor example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:"
                },
                {
                    "type": "code",
                    "code": "css/* app.css */.cookie-banner{display:none;}"
                },
                {
                    "type": "code",
                    "code": "ts// app.d.css.tsdeclareconstcss: {cookieBanner:string;};exportdefaultcss;"
                },
                {
                    "type": "code",
                    "code": "ts// App.tsximportstylesfrom\"./app.css\";styles.cookieBanner;// string"
                },
                {
                    "type": "p",
                    "text": "By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it.\nBut if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new--allowArbitraryExtensionscompiler option."
                },
                {
                    "type": "p",
                    "text": "Note that historically, a similar effect has often been achievable by adding a declaration file namedapp.css.d.tsinstead ofapp.d.css.ts- however, this just worked through Node’srequireresolution rules for CommonJS.\nStrictly speaking, the former is interpreted as a declaration file for a JavaScript file namedapp.css.js.\nBecause relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under--moduleResolution node16ornodenext."
                },
                {
                    "type": "p",
                    "text": "For more information, read upthe proposal for this featureandits corresponding pull request."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Importing TS Extensions -allowImportingTsExtensions"
                },
                {
                    "type": "p",
                    "text": "--allowImportingTsExtensionsallows TypeScript files to import each other with a TypeScript-specific extension like.ts,.mts, or.tsx."
                },
                {
                    "type": "p",
                    "text": "This flag is only allowed when--noEmitor--emitDeclarationOnlyis enabled, since these import paths would not be resolvable at runtime in JavaScript output files.\nThe expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between.tsfiles work."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Umd Global Access -allowUmdGlobalAccess"
                },
                {
                    "type": "p",
                    "text": "When set to true,allowUmdGlobalAccesslets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration."
                },
                {
                    "type": "p",
                    "text": "An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:3.5"
                    ]
                },
                {
                    "type": "p",
                    "text": "3.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Base URL -baseUrl"
                },
                {
                    "type": "p",
                    "text": "Sets a base directory from which to resolve bare specifier module names. For example, in the directory structure:"
                },
                {
                    "type": "code",
                    "code": "project├── ex.ts├── hello│   └── world.ts└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "With\"baseUrl\": \"./\", TypeScript will look for files starting at the same folder as thetsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "tsimport{helloWorld}from\"hello/world\";console.log(helloWorld);"
                },
                {
                    "type": "p",
                    "text": "This resolution has higher priority than lookups fromnode_modules."
                },
                {
                    "type": "p",
                    "text": "This feature was designed for use in conjunction with AMD module loaders in the browser, and is not recommended in any other context. As of TypeScript 4.1,baseUrlis no longer required to be set when usingpaths."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Custom Conditions -customConditions"
                },
                {
                    "type": "p",
                    "text": "--customConditionstakes a list of additionalconditionsthat should succeed when TypeScript resolves from anexportsorimportsfield of apackage.json.\nThese conditions are added to whatever existing conditions a resolver will use by default."
                },
                {
                    "type": "p",
                    "text": "For example, when this field is set in atsconfig.jsonas so:"
                },
                {
                    "type": "code",
                    "code": "jsonc{\"compilerOptions\": {\"target\":\"es2022\",\"moduleResolution\":\"bundler\",\"customConditions\": [\"my-condition\"]}}"
                },
                {
                    "type": "p",
                    "text": "Any time anexportsorimportsfield is referenced inpackage.json, TypeScript will consider conditions calledmy-condition."
                },
                {
                    "type": "p",
                    "text": "So when importing from a package with the followingpackage.json"
                },
                {
                    "type": "code",
                    "code": "jsonc{// ...\"exports\": {\".\": {\"my-condition\":\"./foo.mjs\",\"node\":\"./bar.mjs\",\"import\":\"./baz.mjs\",\"require\":\"./biz.mjs\"}}}"
                },
                {
                    "type": "p",
                    "text": "TypeScript will try to look for files corresponding tofoo.mjs."
                },
                {
                    "type": "p",
                    "text": "This field is only valid under thenode16,nodenext, andbundleroptions for--moduleResolution."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:moduleResolutionresolvePackageJsonExportsresolvePackageJsonImports",
                        "moduleResolution",
                        "resolvePackageJsonExports",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "moduleResolution",
                        "resolvePackageJsonExports",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "moduleResolution"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonExports"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonImports"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Module -module"
                },
                {
                    "type": "p",
                    "text": "Sets the module system for the program. See thetheory behind TypeScript’smoduleoptionandits reference pagefor more information. You very likely want\"nodenext\"for modern Node.js projects andpreserveoresnextfor code that will be bundled."
                },
                {
                    "type": "p",
                    "text": "ChangingmoduleaffectsmoduleResolutionwhichalso has a reference page."
                },
                {
                    "type": "p",
                    "text": "Here’s some example output for this file:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: index.tsimport{valueOfPi}from\"./constants\";exportconsttwoPi=valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "CommonJS"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;constconstants_1=require(\"./constants\");exports.twoPi=constants_1.valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "UMD"
                },
                {
                    "type": "code",
                    "code": "ts(function(factory) {if(typeofmodule===\"object\"&&typeofmodule.exports===\"object\") {varv=factory(require,exports);if(v!==undefined)module.exports=v;}elseif(typeofdefine===\"function\"&&define.amd) {define([\"require\",\"exports\",\"./constants\"],factory);}})(function(require,exports) {\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;constconstants_1=require(\"./constants\");exports.twoPi=constants_1.valueOfPi*2;});Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "AMD"
                },
                {
                    "type": "code",
                    "code": "tsdefine([\"require\",\"exports\",\"./constants\"],function(require,exports,constants_1) {\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;exports.twoPi=constants_1.valueOfPi*2;});Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "System"
                },
                {
                    "type": "code",
                    "code": "tsSystem.register([\"./constants\"],function(exports_1,context_1) {\"use strict\";varconstants_1,twoPi;var__moduleName=context_1&&context_1.id;return{setters:[function(constants_1_1) {constants_1=constants_1_1;}],execute:function() {exports_1(\"twoPi\",twoPi=constants_1.valueOfPi*2);}};});Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "ESNext"
                },
                {
                    "type": "code",
                    "code": "tsimport{valueOfPi}from\"./constants\";exportconsttwoPi=valueOfPi*2;Try"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "ES2015/ES6/ES2020/ES2022"
                },
                {
                    "type": "code",
                    "code": "tsimport{valueOfPi}from\"./constants\";exportconsttwoPi=valueOfPi*2;Try"
                },
                {
                    "type": "p",
                    "text": "In addition to the base functionality ofES2015/ES6,ES2020adds support fordynamicimports, andimport.metawhileES2022further adds support fortop levelawait."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "node16/nodenext"
                },
                {
                    "type": "p",
                    "text": "Available from 4.7+, thenode16andnodenextmodes integrate with Node’snative ECMAScript Module support. The emitted JavaScript uses eitherCommonJSorES2020output depending on the file extension and the value of thetypesetting in the nearestpackage.json. Module resolution also works differently. You can learn more in thehandbookandModules Reference."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "preserve"
                },
                {
                    "type": "p",
                    "text": "In--module preserve(addedin TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-styleimport x = require(\"...\")andexport = ...statements are emitted as CommonJSrequireandmodule.exports. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file)."
                },
                {
                    "type": "code",
                    "code": "tsimport{valueOfPi}from\"./constants\";constconstants=require(\"./constants\");exportconstpiSquared=valueOfPi*constants.valueOfPi;Try"
                },
                {
                    "type": "p",
                    "text": "While it’s rare to need to mix imports and require calls in the same file, thismodulemode best reflects the capabilities of most modern bundlers, as well as the Bun runtime."
                },
                {
                    "type": "p",
                    "text": "Why care about TypeScript’smoduleemit with a bundler or with Bun, where you’re likely also settingnoEmit? TypeScript’s type checking and module resolution behavior are affected by the module format that itwouldemit. Settingmodulegives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "None"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.twoPi=void0;constconstants_1=require(\"./constants\");exports.twoPi=constants_1.valueOfPi*2;Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Default:CommonJSiftargetisES5;ES6/ES2015otherwise.",
                        "Allowed:nonecommonjsamdumdsystemes6/es2015es2020es2022esnextnode16nodenextpreserve",
                        "none",
                        "commonjs",
                        "amd",
                        "umd",
                        "system",
                        "es6/es2015",
                        "es2020",
                        "es2022",
                        "esnext",
                        "node16",
                        "nodenext",
                        "preserve",
                        "Related:moduleResolutionesModuleInteropallowImportingTsExtensionsallowArbitraryExtensionsresolveJsonModule",
                        "moduleResolution",
                        "esModuleInterop",
                        "allowImportingTsExtensions",
                        "allowArbitraryExtensions",
                        "resolveJsonModule",
                        "Released:1.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "CommonJSiftargetisES5;ES6/ES2015otherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "none",
                        "commonjs",
                        "amd",
                        "umd",
                        "system",
                        "es6/es2015",
                        "es2020",
                        "es2022",
                        "esnext",
                        "node16",
                        "nodenext",
                        "preserve"
                    ]
                },
                {
                    "type": "p",
                    "text": "none"
                },
                {
                    "type": "p",
                    "text": "commonjs"
                },
                {
                    "type": "p",
                    "text": "amd"
                },
                {
                    "type": "p",
                    "text": "umd"
                },
                {
                    "type": "p",
                    "text": "system"
                },
                {
                    "type": "p",
                    "text": "es6/es2015"
                },
                {
                    "type": "p",
                    "text": "es2020"
                },
                {
                    "type": "p",
                    "text": "es2022"
                },
                {
                    "type": "p",
                    "text": "esnext"
                },
                {
                    "type": "p",
                    "text": "node16"
                },
                {
                    "type": "p",
                    "text": "nodenext"
                },
                {
                    "type": "p",
                    "text": "preserve"
                },
                {
                    "type": "list",
                    "items": [
                        "moduleResolution",
                        "esModuleInterop",
                        "allowImportingTsExtensions",
                        "allowArbitraryExtensions",
                        "resolveJsonModule"
                    ]
                },
                {
                    "type": "p",
                    "text": "moduleResolution"
                },
                {
                    "type": "p",
                    "text": "esModuleInterop"
                },
                {
                    "type": "p",
                    "text": "allowImportingTsExtensions"
                },
                {
                    "type": "p",
                    "text": "allowArbitraryExtensions"
                },
                {
                    "type": "p",
                    "text": "resolveJsonModule"
                },
                {
                    "type": "p",
                    "text": "1.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Module Resolution -moduleResolution"
                },
                {
                    "type": "p",
                    "text": "Specify the module resolution strategy:"
                },
                {
                    "type": "list",
                    "items": [
                        "'node16'or'nodenext'for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJSrequire, which resolve using different algorithms. ThesemoduleResolutionvalues, when combined with the correspondingmodulevalues, picks the right algorithm for each resolution based on whether Node.js will see animportorrequirein the output JavaScript code.",
                        "'node10'(previously called'node') for Node.js versions older than v10, which only support CommonJSrequire. You probably won’t need to usenode10in modern code.",
                        "'bundler'for use with bundlers. Likenode16andnodenext, this mode supports package.json\"imports\"and\"exports\", but unlike the Node.js resolution modes,bundlernever requires file extensions on relative paths in imports.",
                        "'classic'was used in TypeScript before the release of 1.6.classicshould not be used."
                    ]
                },
                {
                    "type": "p",
                    "text": "There are reference pages explaining thetheory behind TypeScript’s module resolutionand thedetails of each option."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:ClassicifmoduleisAMD,UMD,System, orES6/ES2015; Matches ifmoduleisnode16ornodenext;Nodeotherwise.",
                        "Allowed:classicnode10/nodenode16nodenextbundler",
                        "classic",
                        "node10/node",
                        "node16",
                        "nodenext",
                        "bundler",
                        "Related:modulepathsbaseUrlrootDirsmoduleSuffixescustomConditionsresolvePackageJsonExportsresolvePackageJsonImports",
                        "module",
                        "paths",
                        "baseUrl",
                        "rootDirs",
                        "moduleSuffixes",
                        "customConditions",
                        "resolvePackageJsonExports",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "ClassicifmoduleisAMD,UMD,System, orES6/ES2015; Matches ifmoduleisnode16ornodenext;Nodeotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "classic",
                        "node10/node",
                        "node16",
                        "nodenext",
                        "bundler"
                    ]
                },
                {
                    "type": "p",
                    "text": "classic"
                },
                {
                    "type": "p",
                    "text": "node10/node"
                },
                {
                    "type": "p",
                    "text": "node16"
                },
                {
                    "type": "p",
                    "text": "nodenext"
                },
                {
                    "type": "p",
                    "text": "bundler"
                },
                {
                    "type": "list",
                    "items": [
                        "module",
                        "paths",
                        "baseUrl",
                        "rootDirs",
                        "moduleSuffixes",
                        "customConditions",
                        "resolvePackageJsonExports",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "module"
                },
                {
                    "type": "p",
                    "text": "paths"
                },
                {
                    "type": "p",
                    "text": "baseUrl"
                },
                {
                    "type": "p",
                    "text": "rootDirs"
                },
                {
                    "type": "p",
                    "text": "moduleSuffixes"
                },
                {
                    "type": "p",
                    "text": "customConditions"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonExports"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonImports"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Module Suffixes -moduleSuffixes"
                },
                {
                    "type": "p",
                    "text": "Provides a way to override the default list of file name suffixes to search when resolving a module."
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"moduleSuffixes\": [\".ios\",\".native\",\"\"]}}"
                },
                {
                    "type": "p",
                    "text": "Given the above configuration, an import like the following:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfoofrom\"./foo\";"
                },
                {
                    "type": "p",
                    "text": "TypeScript will look for the relative files./foo.ios.ts,./foo.native.ts, and finally./foo.ts."
                },
                {
                    "type": "p",
                    "text": "Note the empty string\"\"inmoduleSuffixeswhich is necessary for TypeScript to also look-up./foo.ts."
                },
                {
                    "type": "p",
                    "text": "This feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differingmoduleSuffixes."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Resolve -noResolve"
                },
                {
                    "type": "p",
                    "text": "By default, TypeScript will examine the initial set of files forimportand<referencedirectives and add these resolved files to your program."
                },
                {
                    "type": "p",
                    "text": "IfnoResolveis set, this process doesn’t happen.\nHowever,importstatements are still checked to see if they resolve to a valid module, so you’ll need to make sure this is satisfied by some other means."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#noUncheckedSideEffectImports -noUncheckedSideEffectImports"
                },
                {
                    "type": "p",
                    "text": "In JavaScript it’s possible toimporta module without actually importing any values from it."
                },
                {
                    "type": "code",
                    "code": "tsimport\"some-module\";"
                },
                {
                    "type": "p",
                    "text": "These imports are often calledside effect importsbecause the only useful behavior they can provide is by executing some side effect (like registering a global variable, or adding a polyfill to a prototype)."
                },
                {
                    "type": "p",
                    "text": "By default, TypeScript will not check these imports for validity. If the import resolves to a valid source file, TypeScript will load and check the file.\nIf no source file is found, TypeScript will silently ignore the import."
                },
                {
                    "type": "p",
                    "text": "This is surprising behavior, but it partially stems from modeling patterns in the JavaScript ecosystem.\nFor example, this syntax has also been used with special loaders in bundlers to load CSS or other assets.\nYour bundler might be configured in such a way where you can include specific.cssfiles by writing something like the following:"
                },
                {
                    "type": "code",
                    "code": "tsximport\"./button-component.css\";exportfunctionButton() {// ...}"
                },
                {
                    "type": "p",
                    "text": "Still, this masks potential typos on side effect imports."
                },
                {
                    "type": "p",
                    "text": "When--noUncheckedSideEffectImportsis enabled, TypeScript will error if it can’t find a source file for a side effect import."
                },
                {
                    "type": "code",
                    "code": "tsimport\"oops-this-module-does-not-exist\";//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding//        type declarations."
                },
                {
                    "type": "p",
                    "text": "When enabling this option, some working code may now receive an error, like in the CSS example above.\nTo work around this, users who want to just write side effectimports for assets might be better served by writing what’s called anambient module declarationwith a wildcard specifier.\nIt would go in a global file and look something like the following:"
                },
                {
                    "type": "code",
                    "code": "ts// ./src/globals.d.ts// Recognize all CSS files as module imports.declaremodule\"*.css\"{}"
                },
                {
                    "type": "p",
                    "text": "In fact, you might already have a file like this in your project!\nFor example, running something likevite initmight create a similarvite-env.d.ts."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Paths -paths"
                },
                {
                    "type": "p",
                    "text": "A series of entries which re-map imports to lookup locations relative to thebaseUrlif set, or to the tsconfig file itself otherwise. There is a larger coverage ofpathsinthemoduleResolutionreference page."
                },
                {
                    "type": "p",
                    "text": "pathslets you declare how TypeScript should resolve an import in yourrequire/imports."
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"paths\": {\"jquery\": [\"./vendor/jquery/dist/jquery\"]}}}"
                },
                {
                    "type": "p",
                    "text": "This would allow you to be able to writeimport \"jquery\", and get all of the correct typing locally."
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"paths\": {\"app/*\": [\"./src/app/*\"],\"config/*\": [\"./src/app/_config/*\"],\"environment/*\": [\"./src/environments/*\"],\"shared/*\": [\"./src/app/_shared/*\"],\"helpers/*\": [\"./src/helpers/*\"],\"tests/*\": [\"./src/tests/*\"]},}"
                },
                {
                    "type": "p",
                    "text": "In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code."
                },
                {
                    "type": "p",
                    "text": "Note that this feature does not change how import paths are emitted bytsc, sopathsshould only be used to inform TypeScript that another tool has this mapping and will use it at runtime or when bundling."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Resolve JSON Module -resolveJsonModule"
                },
                {
                    "type": "p",
                    "text": "Allows importing modules with a.jsonextension, which is a common practice in node projects. This includes\ngenerating a type for theimportbased on the static JSON shape."
                },
                {
                    "type": "p",
                    "text": "TypeScript does not support resolving JSON files by default:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: settings.json{\"repo\":\"TypeScript\",\"dry\":false,\"debug\":false}// @filename: index.tsimportsettingsfrom\"./settings.json\";Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.2732Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.settings.debug===true;settings.dry===2;Try"
                },
                {
                    "type": "p",
                    "text": "Enabling the option allows importing JSON, and validating the types in that JSON file."
                },
                {
                    "type": "code",
                    "code": "ts// @filename: settings.json{\"repo\":\"TypeScript\",\"dry\":false,\"debug\":false}// @filename: index.tsimportsettingsfrom\"./settings.json\";settings.debug===true;settings.dry===2;This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.2367This comparison appears to be unintentional because the types 'boolean' and 'number' have no overlap.Try"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Resolve package.json Exports -resolvePackageJsonExports"
                },
                {
                    "type": "p",
                    "text": "--resolvePackageJsonExportsforces TypeScript to consulttheexportsfield ofpackage.jsonfilesif it ever reads from a package innode_modules."
                },
                {
                    "type": "p",
                    "text": "This option defaults totrueunder thenode16,nodenext, andbundleroptions for--moduleResolution."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse",
                        "Related:moduleResolutioncustomConditionsresolvePackageJsonImports",
                        "moduleResolution",
                        "customConditions",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "list",
                    "items": [
                        "moduleResolution",
                        "customConditions",
                        "resolvePackageJsonImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "moduleResolution"
                },
                {
                    "type": "p",
                    "text": "customConditions"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonImports"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Resolve package.json Imports -resolvePackageJsonImports"
                },
                {
                    "type": "p",
                    "text": "--resolvePackageJsonImportsforces TypeScript to consulttheimportsfield ofpackage.jsonfileswhen performing a lookup that starts with#from a file whose ancestor directory contains apackage.json."
                },
                {
                    "type": "p",
                    "text": "This option defaults totrueunder thenode16,nodenext, andbundleroptions for--moduleResolution."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse",
                        "Related:moduleResolutioncustomConditionsresolvePackageJsonExports",
                        "moduleResolution",
                        "customConditions",
                        "resolvePackageJsonExports"
                    ]
                },
                {
                    "type": "p",
                    "text": "truewhenmoduleResolutionisnode16,nodenext, orbundler; otherwisefalse"
                },
                {
                    "type": "list",
                    "items": [
                        "moduleResolution",
                        "customConditions",
                        "resolvePackageJsonExports"
                    ]
                },
                {
                    "type": "p",
                    "text": "moduleResolution"
                },
                {
                    "type": "p",
                    "text": "customConditions"
                },
                {
                    "type": "p",
                    "text": "resolvePackageJsonExports"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Root Dir -rootDir"
                },
                {
                    "type": "p",
                    "text": "Default: The longest common path of all non-declaration input files. Ifcompositeis set, the default is instead the directory containing thetsconfig.jsonfile."
                },
                {
                    "type": "p",
                    "text": "When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory."
                },
                {
                    "type": "p",
                    "text": "For example, let’s say you have some input files:"
                },
                {
                    "type": "code",
                    "code": "MyProj├── tsconfig.json├── core│   ├── a.ts│   ├── b.ts│   ├── sub│   │   ├── c.ts├── types.d.ts"
                },
                {
                    "type": "p",
                    "text": "The inferred value forrootDiris the longest common path of all non-declaration input files, which in this case iscore/."
                },
                {
                    "type": "p",
                    "text": "If youroutDirwasdist, TypeScript would write this tree:"
                },
                {
                    "type": "code",
                    "code": "MyProj├── dist│   ├── a.js│   ├── b.js│   ├── sub│   │   ├── c.js"
                },
                {
                    "type": "p",
                    "text": "However, you may have intended forcoreto be part of the output directory structure.\nBy settingrootDir: \".\"intsconfig.json, TypeScript would write this tree:"
                },
                {
                    "type": "code",
                    "code": "MyProj├── dist│   ├── core│   │   ├── a.js│   │   ├── b.js│   │   ├── sub│   │   │   ├── c.js"
                },
                {
                    "type": "p",
                    "text": "Importantly,rootDirdoes not affect which files become part of the compilation.\nIt has no interaction with theinclude,exclude, orfilestsconfig.jsonsettings."
                },
                {
                    "type": "p",
                    "text": "Note that TypeScript will never write an output file to a directory outside ofoutDir, and will never skip emitting a file.\nFor this reason,rootDiralso enforces that all files which need to be emitted are underneath therootDirpath."
                },
                {
                    "type": "p",
                    "text": "For example, let’s say you had this tree:"
                },
                {
                    "type": "code",
                    "code": "MyProj├── tsconfig.json├── core│   ├── a.ts│   ├── b.ts├── helpers.ts"
                },
                {
                    "type": "p",
                    "text": "It would be an error to specifyrootDirascoreandincludeas*because it creates a file (helpers.ts) that would need to be emittedoutsidetheoutDir(i.e.../helpers.js)."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:Computed from the list of input files.",
                        "Released:1.5"
                    ]
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "1.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Root Dirs -rootDirs"
                },
                {
                    "type": "p",
                    "text": "UsingrootDirs, you can inform the compiler that there are many “virtual” directories acting as a single root.\nThis allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory."
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "code",
                    "code": "src└── views└── view1.ts (can import \"./template1\", \"./view2`)└── view2.ts (can import \"./template1\", \"./view1`)generated└── templates└── views└── template1.ts (can import \"./view1\", \"./view2\")"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"rootDirs\": [\"src/views\",\"generated/templates/views\"]}}"
                },
                {
                    "type": "p",
                    "text": "This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to\nwork via those relative paths at runtime."
                },
                {
                    "type": "p",
                    "text": "rootDirscan be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated.d.tsfiles in another folder. This technique is useful for bundled applications where you useimportof files that aren’t necessarily code:"
                },
                {
                    "type": "code",
                    "code": "shsrc└── index.ts└── css└── main.css└── navigation.cssgenerated└── css└── main.css.d.ts└── navigation.css.d.ts"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"rootDirs\": [\"src\",\"generated\"]}}"
                },
                {
                    "type": "p",
                    "text": "This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location.\nFor example./src/index.tscan import the file./src/css/main.cssand TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file."
                },
                {
                    "type": "code",
                    "code": "ts// @filename: index.tsimport{appClass}from\"./main.css\";Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Default:Computed from the list of input files.",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "Computed from the list of input files."
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Type Roots -typeRoots"
                },
                {
                    "type": "p",
                    "text": "By default allvisible”@types” packages are included in your compilation.\nPackages innode_modules/@typesof any enclosing folder are consideredvisible.\nFor example, that means packages within./node_modules/@types/,../node_modules/@types/,../../node_modules/@types/, and so on."
                },
                {
                    "type": "p",
                    "text": "IftypeRootsis specified,onlypackages undertypeRootswill be included. For example:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"typeRoots\": [\"./typings\",\"./vendor/types\"]}}"
                },
                {
                    "type": "p",
                    "text": "This config file will includeallpackages under./typingsand./vendor/types, and no packages from./node_modules/@types.\nAll paths are relative to thetsconfig.json."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:types",
                        "types"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "types"
                    ]
                },
                {
                    "type": "p",
                    "text": "types"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Types -types"
                },
                {
                    "type": "p",
                    "text": "By default allvisible”@types” packages are included in your compilation.\nPackages innode_modules/@typesof any enclosing folder are consideredvisible.\nFor example, that means packages within./node_modules/@types/,../node_modules/@types/,../../node_modules/@types/, and so on."
                },
                {
                    "type": "p",
                    "text": "Iftypesis specified, only packages listed will be included in the global scope. For instance:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"types\": [\"node\",\"jest\",\"express\"]}}"
                },
                {
                    "type": "p",
                    "text": "Thistsconfig.jsonfile willonlyinclude./node_modules/@types/node,./node_modules/@types/jestand./node_modules/@types/express.\nOther packages undernode_modules/@types/*will not be included."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What does this affect?"
                },
                {
                    "type": "p",
                    "text": "This option does not affect how@types/*are included in your application code, for example if you had the abovecompilerOptionsexample with code like:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asmomentfrom\"moment\";moment().format(\"MMMM Do YYYY, h:mm:ss a\");"
                },
                {
                    "type": "p",
                    "text": "Themomentimport would be fully typed."
                },
                {
                    "type": "p",
                    "text": "When you have this option set, by not including a module in thetypesarray it:"
                },
                {
                    "type": "list",
                    "items": [
                        "Will not add globals to your project (e.gprocessin node, orexpectin Jest)",
                        "Will not have exports appear as auto-import recommendations"
                    ]
                },
                {
                    "type": "p",
                    "text": "This feature differs fromtypeRootsin that it is about specifying only the exact types you want included, whereastypeRootssupports saying you want particular folders."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:typeRoots",
                        "typeRoots"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "typeRoots"
                    ]
                },
                {
                    "type": "p",
                    "text": "typeRoots"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Emit"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Declaration -declaration"
                },
                {
                    "type": "p",
                    "text": "Generate.d.tsfiles for every TypeScript or JavaScript file inside your project.\nThese.d.tsfiles are type definition files which describe the external API of your module.\nWith.d.tsfiles, tools like TypeScript can provide intellisense and accurate types for un-typed code."
                },
                {
                    "type": "p",
                    "text": "Whendeclarationis set totrue, running the compiler with this TypeScript code:"
                },
                {
                    "type": "code",
                    "code": "tsexportlethelloWorld=\"hi\";Try"
                },
                {
                    "type": "p",
                    "text": "Will generate anindex.jsfile like this:"
                },
                {
                    "type": "code",
                    "code": "tsexportlethelloWorld=\"hi\";Try"
                },
                {
                    "type": "p",
                    "text": "With a correspondinghelloWorld.d.ts:"
                },
                {
                    "type": "code",
                    "code": "tsexportdeclarelethelloWorld:string;Try"
                },
                {
                    "type": "p",
                    "text": "When working with.d.tsfiles for JavaScript files you may want to useemitDeclarationOnlyor useoutDirto ensure that the JavaScript files are not overwritten."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueifcomposite;falseotherwise.",
                        "Related:declarationDiremitDeclarationOnly",
                        "declarationDir",
                        "emitDeclarationOnly",
                        "Released:1.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "declarationDir",
                        "emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "declarationDir"
                },
                {
                    "type": "p",
                    "text": "emitDeclarationOnly"
                },
                {
                    "type": "p",
                    "text": "1.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Declaration Dir -declarationDir"
                },
                {
                    "type": "p",
                    "text": "Offers a way to configure the root directory for where declaration files are emitted."
                },
                {
                    "type": "code",
                    "code": "example├── index.ts├── package.json└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "with thistsconfig.json:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"declaration\":true,\"declarationDir\":\"./types\"}}"
                },
                {
                    "type": "p",
                    "text": "Would place the d.ts for theindex.tsin atypesfolder:"
                },
                {
                    "type": "code",
                    "code": "example├── index.js├── index.ts├── package.json├── tsconfig.json└── types└── index.d.ts"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:declaration",
                        "declaration",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "declaration"
                    ]
                },
                {
                    "type": "p",
                    "text": "declaration"
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Declaration Map -declarationMap"
                },
                {
                    "type": "p",
                    "text": "Generates a source map for.d.tsfiles which map back to the original.tssource file.\nThis will allow editors such as VS Code to go to the original.tsfile when using features likeGo to Definition."
                },
                {
                    "type": "p",
                    "text": "You should strongly consider turning this on if you’re using project references."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:2.9"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.9"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Downlevel Iteration -downlevelIteration"
                },
                {
                    "type": "p",
                    "text": "Downleveling is TypeScript’s term for transpiling to an older version of JavaScript.\nThis flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes."
                },
                {
                    "type": "p",
                    "text": "ECMAScript 6 added several new iteration primitives: thefor / ofloop (for (el of arr)), Array spread ([a, ...b]), argument spread (fn(...args)), andSymbol.iterator.downlevelIterationallows for these iteration primitives to be used more accurately in ES5 environments if aSymbol.iteratorimplementation is present."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example: Effects onfor / of"
                },
                {
                    "type": "p",
                    "text": "With this TypeScript code:"
                },
                {
                    "type": "code",
                    "code": "tsconststr=\"Hello!\";for(constsofstr) {console.log(s);}Try"
                },
                {
                    "type": "p",
                    "text": "WithoutdownlevelIterationenabled, afor / ofloop on any object is downleveled to a traditionalforloop:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";varstr=\"Hello!\";for(var_i=0,str_1=str;_i<str_1.length;_i++) {vars=str_1[_i];console.log(s);}Try"
                },
                {
                    "type": "p",
                    "text": "This is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol.\nCertain strings, such as emoji (😜), have a.lengthof 2 (or even more!), but should iterate as 1 unit in afor-ofloop.\nSeethis blog post by Jonathan Newfor a longer explanation."
                },
                {
                    "type": "p",
                    "text": "WhendownlevelIterationis enabled, TypeScript will use a helper function that checks for aSymbol.iteratorimplementation (either native or polyfill).\nIf this implementation is missing, you’ll fall back to index-based iteration."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__values= (this&&this.__values) ||function(o) {vars=typeofSymbol===\"function\"&&Symbol.iterator,m=s&&o[s],i=0;if(m)returnm.call(o);if(o&&typeofo.length===\"number\")return{next:function() {if(o&&i>=o.length)o=void0;return{value:o&&o[i++],done:!o};}};thrownewTypeError(s?\"Object is not iterable.\":\"Symbol.iterator is not defined.\");};vare_1,_a;varstr=\"Hello!\";try{for(varstr_1=__values(str),str_1_1=str_1.next(); !str_1_1.done;str_1_1=str_1.next()) {vars=str_1_1.value;console.log(s);}}catch(e_1_1) {e_1= {error:e_1_1}; }finally{try{if(str_1_1&& !str_1_1.done&& (_a=str_1.return))_a.call(str_1);}finally{if(e_1)throwe_1.error; }}Try"
                },
                {
                    "type": "p",
                    "text": "You can usetslibviaimportHelpersto reduce the amount of inline JavaScript too:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__values= (this&&this.__values) ||function(o) {vars=typeofSymbol===\"function\"&&Symbol.iterator,m=s&&o[s],i=0;if(m)returnm.call(o);if(o&&typeofo.length===\"number\")return{next:function() {if(o&&i>=o.length)o=void0;return{value:o&&o[i++],done:!o};}};thrownewTypeError(s?\"Object is not iterable.\":\"Symbol.iterator is not defined.\");};vare_1,_a;varstr=\"Hello!\";try{for(varstr_1=__values(str),str_1_1=str_1.next(); !str_1_1.done;str_1_1=str_1.next()) {vars=str_1_1.value;console.log(s);}}catch(e_1_1) {e_1= {error:e_1_1}; }finally{try{if(str_1_1&& !str_1_1.done&& (_a=str_1.return))_a.call(str_1);}finally{if(e_1)throwe_1.error; }}Try"
                },
                {
                    "type": "p",
                    "text": "Note:enablingdownlevelIterationdoes not improve compliance ifSymbol.iteratoris not present in the runtime."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example: Effects on Array Spreads"
                },
                {
                    "type": "p",
                    "text": "This is an array spread:"
                },
                {
                    "type": "code",
                    "code": "js// Make a new array whose elements are 1 followed by the elements of arr2constarr= [1, ...arr2];"
                },
                {
                    "type": "p",
                    "text": "Based on the description, it sounds easy to downlevel to ES5:"
                },
                {
                    "type": "code",
                    "code": "js// The same, right?constarr= [1].concat(arr2);"
                },
                {
                    "type": "p",
                    "text": "However, this is observably different in certain rare cases."
                },
                {
                    "type": "p",
                    "text": "For example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item withundefined, whereas.concatwill leave them intact."
                },
                {
                    "type": "code",
                    "code": "js// Make an array where the element at index 1 is missingletarrayWithHole= [\"a\", ,\"c\"];letspread= [...arrayWithHole];letconcatenated= [].concat(arrayWithHole);console.log(arrayWithHole);// [ 'a', <1 empty item>, 'c' ]console.log(spread);// [ 'a', undefined, 'c' ]console.log(concatenated);// [ 'a', <1 empty item>, 'c' ]"
                },
                {
                    "type": "p",
                    "text": "Just as withfor / of,downlevelIterationwill useSymbol.iterator(if present) to more accurately emulate ES 6 behavior."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:importHelpers",
                        "importHelpers",
                        "Released:2.3"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "importHelpers"
                    ]
                },
                {
                    "type": "p",
                    "text": "importHelpers"
                },
                {
                    "type": "p",
                    "text": "2.3"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Emit BOM -emitBOM"
                },
                {
                    "type": "p",
                    "text": "Controls whether TypeScript will emit abyte order mark (BOM)when writing output files.\nSome runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present.\nThe default value offalseis generally best unless you have a reason to change it."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Emit Declaration Only -emitDeclarationOnly"
                },
                {
                    "type": "p",
                    "text": "Onlyemit.d.tsfiles; do not emit.jsfiles."
                },
                {
                    "type": "p",
                    "text": "This setting is useful in two cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "You are using a transpiler other than TypeScript to generate your JavaScript.",
                        "You are using TypeScript to only generated.tsfiles for your consumers."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Related:declaration",
                        "declaration",
                        "Released:2.8"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "declaration"
                    ]
                },
                {
                    "type": "p",
                    "text": "declaration"
                },
                {
                    "type": "p",
                    "text": "2.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Import Helpers -importHelpers"
                },
                {
                    "type": "p",
                    "text": "For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations.\nBy default, these helpers are inserted into files which use them.\nThis can result in code duplication if the same helper is used in many different modules."
                },
                {
                    "type": "p",
                    "text": "If theimportHelpersflag is on, these helper functions are instead imported from thetslibmodule.\nYou will need to ensure that thetslibmodule is able to be imported at runtime.\nThis only affects modules; global script files will not attempt to import modules."
                },
                {
                    "type": "p",
                    "text": "For example, with this TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsexportfunctionfn(arr:number[]) {constarr2= [1, ...arr];}"
                },
                {
                    "type": "p",
                    "text": "Turning ondownlevelIterationandimportHelpersis still false:"
                },
                {
                    "type": "code",
                    "code": "tsvar__read= (this&&this.__read) ||function(o,n) {varm=typeofSymbol===\"function\"&&o[Symbol.iterator];if(!m)returno;vari=m.call(o),r,ar= [],e;try{while((n===void0||n-- >0) && !(r=i.next()).done)ar.push(r.value);}catch(error) {e= {error:error}; }finally{try{if(r&& !r.done&& (m=i[\"return\"]))m.call(i);}finally{if(e)throwe.error; }}returnar;};var__spreadArray= (this&&this.__spreadArray) ||function(to,from,pack) {if(pack||arguments.length===2)for(vari=0,l=from.length,ar;i<l;i++) {if(ar|| !(iinfrom)) {if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i] =from[i];}}returnto.concat(ar||Array.prototype.slice.call(from));};exportfunctionfn(arr) {vararr2=__spreadArray([1],__read(arr),false);}Try"
                },
                {
                    "type": "p",
                    "text": "Then turning on bothdownlevelIterationandimportHelpers:"
                },
                {
                    "type": "code",
                    "code": "tsimport{__read,__spreadArray}from\"tslib\";exportfunctionfn(arr) {vararr2=__spreadArray([1],__read(arr),false);}Try"
                },
                {
                    "type": "p",
                    "text": "You can usenoEmitHelperswhen you provide your own implementations of these functions."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:noEmitHelpersdownlevelIteration",
                        "noEmitHelpers",
                        "downlevelIteration"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "noEmitHelpers",
                        "downlevelIteration"
                    ]
                },
                {
                    "type": "p",
                    "text": "noEmitHelpers"
                },
                {
                    "type": "p",
                    "text": "downlevelIteration"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Inline Source Map -inlineSourceMap"
                },
                {
                    "type": "p",
                    "text": "When set, instead of writing out a.js.mapfile to provide source maps, TypeScript will embed the source map content in the.jsfiles.\nAlthough this results in larger JS files, it can be convenient in some scenarios.\nFor example, you might want to debug JS files on a webserver that doesn’t allow.mapfiles to be served."
                },
                {
                    "type": "p",
                    "text": "Mutually exclusive withsourceMap."
                },
                {
                    "type": "p",
                    "text": "For example, with this TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsconsthelloWorld=\"hi\";console.log(helloWorld);"
                },
                {
                    "type": "p",
                    "text": "Converts to this JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";consthelloWorld=\"hi\";console.log(helloWorld);Try"
                },
                {
                    "type": "p",
                    "text": "Then enable building it withinlineSourceMapenabled there is a comment at the bottom of the file which includes\na source-map for the file."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";consthelloWorld=\"hi\";console.log(helloWorld);//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.5"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Inline Sources -inlineSources"
                },
                {
                    "type": "p",
                    "text": "When set, TypeScript will include the original content of the.tsfile as an embedded string in the source map (using the source map’ssourcesContentproperty).\nThis is often useful in the same cases asinlineSourceMap."
                },
                {
                    "type": "p",
                    "text": "Requires eithersourceMaporinlineSourceMapto be set."
                },
                {
                    "type": "p",
                    "text": "For example, with this TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsconsthelloWorld=\"hi\";console.log(helloWorld);Try"
                },
                {
                    "type": "p",
                    "text": "By default converts to this JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";consthelloWorld=\"hi\";console.log(helloWorld);Try"
                },
                {
                    "type": "p",
                    "text": "Then enable building it withinlineSourcesandinlineSourceMapenabled there is a comment at the bottom of the file which includes\na source-map for the file.\nNote that the end is different from the example ininlineSourceMapbecause the source-map now contains the original source code also."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";consthelloWorld=\"hi\";console.log(helloWorld);//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.5"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Map Root -mapRoot"
                },
                {
                    "type": "p",
                    "text": "Specify the location where debugger should locate map files instead of generated locations.\nThis string is treated verbatim inside the source-map, for example:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"sourceMap\":true,\"mapRoot\":\"https://my-website.com/debug/sourcemaps/\"}}"
                },
                {
                    "type": "p",
                    "text": "Would declare thatindex.jswill have sourcemaps athttps://my-website.com/debug/sourcemaps/index.js.map."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#New Line -newLine"
                },
                {
                    "type": "p",
                    "text": "Specify the end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix)."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:lf",
                        "Allowed:crlflf",
                        "crlf",
                        "lf",
                        "Released:1.5"
                    ]
                },
                {
                    "type": "p",
                    "text": "lf"
                },
                {
                    "type": "list",
                    "items": [
                        "crlf",
                        "lf"
                    ]
                },
                {
                    "type": "p",
                    "text": "crlf"
                },
                {
                    "type": "p",
                    "text": "lf"
                },
                {
                    "type": "p",
                    "text": "1.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Emit -noEmit"
                },
                {
                    "type": "p",
                    "text": "Do not emit compiler output files like JavaScript source code, source-maps or declarations."
                },
                {
                    "type": "p",
                    "text": "This makes room for another tool likeBabel, orswcto handle converting the TypeScript file to a file which can run inside a JavaScript environment."
                },
                {
                    "type": "p",
                    "text": "You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Emit Helpers -noEmitHelpers"
                },
                {
                    "type": "p",
                    "text": "Instead of importing helpers withimportHelpers, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions."
                },
                {
                    "type": "p",
                    "text": "For example, using thisasyncfunction in ES5 requires aawait-like function andgenerator-like function to run:"
                },
                {
                    "type": "code",
                    "code": "tsconstgetAPI=async(url:string)=>{// Get APIreturn{};};Try"
                },
                {
                    "type": "p",
                    "text": "Which creates quite a lot of JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__awaiter= (this&&this.__awaiter) ||function(thisArg,_arguments,P,generator) {functionadopt(value) {returnvalueinstanceofP?value:newP(function(resolve) {resolve(value); }); }returnnew(P|| (P=Promise))(function(resolve,reject) {functionfulfilled(value) {try{step(generator.next(value)); }catch(e) {reject(e); } }functionrejected(value) {try{step(generator[\"throw\"](value)); }catch(e) {reject(e); } }functionstep(result) {result.done?resolve(result.value) :adopt(result.value).then(fulfilled,rejected); }step((generator=generator.apply(thisArg,_arguments|| [])).next());});};var__generator= (this&&this.__generator) ||function(thisArg,body) {var_= {label:0,sent:function() {if(t[0] &1)throwt[1];returnt[1]; },trys:[],ops:[] },f,y,t,g=Object.create((typeofIterator===\"function\"?Iterator:Object).prototype);returng.next=verb(0),g[\"throw\"] =verb(1),g[\"return\"] =verb(2),typeofSymbol===\"function\"&& (g[Symbol.iterator] =function() {returnthis; }),g;functionverb(n) {returnfunction(v) {returnstep([n,v]); }; }functionstep(op) {if(f)thrownewTypeError(\"Generator is already executing.\");while(g&& (g=0,op[0] && (_=0)),_)try{if(f=1,y&& (t=op[0] &2?y[\"return\"] :op[0] ?y[\"throw\"] || ((t=y[\"return\"]) &&t.call(y),0) :y.next) && !(t=t.call(y,op[1])).done)returnt;if(y=0,t)op= [op[0] &2,t.value];switch(op[0]) {case0:case1:t=op;break;case4:_.label++;return{value:op[1],done:false};case5:_.label++;y=op[1];op= [0];continue;case7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1]) && (op[0] ===6||op[0] ===2)) {_=0;continue; }if(op[0] ===3&& (!t|| (op[1] >t[0] &&op[1] <t[3]))) {_.label=op[1];break; }if(op[0] ===6&&_.label<t[1]) {_.label=t[1];t=op;break; }if(t&&_.label<t[2]) {_.label=t[2];_.ops.push(op);break; }if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e) {op= [6,e];y=0; }finally{f=t=0; }if(op[0] &5)throwop[1];return{value:op[0] ?op[1] :void0,done:true};}};vargetAPI=function(url) {return__awaiter(void0,void0,void0,function() {return__generator(this,function(_a) {// Get APIreturn[2/*return*/, {}];});}); };Try"
                },
                {
                    "type": "p",
                    "text": "Which can be switched out with your own globals via this flag:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";vargetAPI=function(url) {return__awaiter(void0,void0,void0,function() {return__generator(this,function(_a) {// Get APIreturn[2/*return*/, {}];});}); };Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:importHelpers",
                        "importHelpers",
                        "Released:1.5"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "importHelpers"
                    ]
                },
                {
                    "type": "p",
                    "text": "importHelpers"
                },
                {
                    "type": "p",
                    "text": "1.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Emit On Error -noEmitOnError"
                },
                {
                    "type": "p",
                    "text": "Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported."
                },
                {
                    "type": "p",
                    "text": "This defaults tofalse, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:1.4"
                    ]
                },
                {
                    "type": "p",
                    "text": "1.4"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Out Dir -outDir"
                },
                {
                    "type": "p",
                    "text": "If specified,.js(as well as.d.ts,.js.map, etc.) files will be emitted into this directory.\nThe directory structure of the original source files is preserved; seerootDirif the computed root is not what you intended."
                },
                {
                    "type": "p",
                    "text": "If not specified,.jsfiles will be emitted in the same directory as the.tsfiles they were generated from:"
                },
                {
                    "type": "code",
                    "code": "sh$ tscexample├── index.js└── index.ts"
                },
                {
                    "type": "p",
                    "text": "With atsconfig.jsonlike this:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"outDir\":\"dist\"}}"
                },
                {
                    "type": "p",
                    "text": "Runningtscwith these settings moves the files into the specifieddistfolder:"
                },
                {
                    "type": "code",
                    "code": "sh$ tscexample├── dist│   └── index.js├── index.ts└── tsconfig.json"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:outoutFile",
                        "out",
                        "outFile"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "out",
                        "outFile"
                    ]
                },
                {
                    "type": "p",
                    "text": "out"
                },
                {
                    "type": "p",
                    "text": "outFile"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Out File -outFile"
                },
                {
                    "type": "p",
                    "text": "If specified, allglobal(non-module) files will be concatenated into the single output file specified."
                },
                {
                    "type": "p",
                    "text": "Ifmoduleissystemoramd, all module files will also be concatenated into this file after all global content."
                },
                {
                    "type": "p",
                    "text": "Note:outFilecannot be used unlessmoduleisNone,System, orAMD.\nThis optioncannotbe used to bundle CommonJS or ES6 modules."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:outoutDir",
                        "out",
                        "outDir",
                        "Released:1.0"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "out",
                        "outDir"
                    ]
                },
                {
                    "type": "p",
                    "text": "out"
                },
                {
                    "type": "p",
                    "text": "outDir"
                },
                {
                    "type": "p",
                    "text": "1.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Preserve Const Enums -preserveConstEnums"
                },
                {
                    "type": "p",
                    "text": "Do not eraseconst enumdeclarations in generated code.const enums provide a way to reduce the overall memory footprint\nof your application at runtime by emitting the enum value instead of a reference."
                },
                {
                    "type": "p",
                    "text": "For example with this TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsconstenumAlbum{JimmyEatWorldFutures=1,TubRingZooHypothesis=2,DogFashionDiscoAdultery=3,}constselectedAlbum=Album.JimmyEatWorldFutures;if(selectedAlbum===Album.JimmyEatWorldFutures) {console.log(\"That is a great choice.\");}Try"
                },
                {
                    "type": "p",
                    "text": "The defaultconst enumbehavior is to convert anyAlbum.Somethingto the corresponding number literal, and to remove a reference\nto the enum from the JavaScript completely."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";constselectedAlbum=1/* Album.JimmyEatWorldFutures */;if(selectedAlbum===1/* Album.JimmyEatWorldFutures */) {console.log(\"That is a great choice.\");}Try"
                },
                {
                    "type": "p",
                    "text": "WithpreserveConstEnumsset totrue, theenumexists at runtime and the numbers are still emitted."
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";varAlbum;(function(Album) {Album[Album[\"JimmyEatWorldFutures\"] =1] =\"JimmyEatWorldFutures\";Album[Album[\"TubRingZooHypothesis\"] =2] =\"TubRingZooHypothesis\";Album[Album[\"DogFashionDiscoAdultery\"] =3] =\"DogFashionDiscoAdultery\";})(Album|| (Album= {}));constselectedAlbum=1/* Album.JimmyEatWorldFutures */;if(selectedAlbum===1/* Album.JimmyEatWorldFutures */) {console.log(\"That is a great choice.\");}Try"
                },
                {
                    "type": "p",
                    "text": "This essentially makes suchconst enumsa source-code feature only, with no runtime traces."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueifisolatedModules;falseotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifisolatedModules;falseotherwise."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Remove Comments -removeComments"
                },
                {
                    "type": "p",
                    "text": "Strips all comments from TypeScript files when converting into JavaScript. Defaults tofalse."
                },
                {
                    "type": "p",
                    "text": "For example, this is a TypeScript file which has a JSDoc comment:"
                },
                {
                    "type": "code",
                    "code": "ts/** The translation of 'Hello world' into Portuguese */exportconsthelloWorldPTBR=\"Olá Mundo\";"
                },
                {
                    "type": "p",
                    "text": "WhenremoveCommentsis set totrue:"
                },
                {
                    "type": "code",
                    "code": "tsexportconsthelloWorldPTBR=\"Olá Mundo\";Try"
                },
                {
                    "type": "p",
                    "text": "Without settingremoveCommentsor having it asfalse:"
                },
                {
                    "type": "code",
                    "code": "ts/** The translation of 'Hello world' into Portuguese */exportconsthelloWorldPTBR=\"Olá Mundo\";Try"
                },
                {
                    "type": "p",
                    "text": "This means that your comments will show up in the JavaScript code."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Source Map -sourceMap"
                },
                {
                    "type": "p",
                    "text": "Enables the generation ofsourcemap files.\nThese files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files.\nSource map files are emitted as.js.map(or.jsx.map) files next to the corresponding.jsoutput file."
                },
                {
                    "type": "p",
                    "text": "The.jsfiles will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:"
                },
                {
                    "type": "code",
                    "code": "ts// helloWorld.tsexportdeclareconsthelloWorld=\"hi\";"
                },
                {
                    "type": "p",
                    "text": "Compiling withsourceMapset totruecreates the following JavaScript file:"
                },
                {
                    "type": "code",
                    "code": "js// helloWorld.js\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});exports.helloWorld=\"hi\";//# sourceMappingURL=// helloWorld.js.map"
                },
                {
                    "type": "p",
                    "text": "And this also generates this json map:"
                },
                {
                    "type": "code",
                    "code": "json// helloWorld.js.map{\"version\":3,\"file\":\"ex.js\",\"sourceRoot\":\"\",\"sources\": [\"../ex.ts\"],\"names\": [],\"mappings\":\";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA\"}"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Source Root -sourceRoot"
                },
                {
                    "type": "p",
                    "text": "Specify the location where a debugger should locate TypeScript files instead of relative source locations.\nThis string is treated verbatim inside the source-map where you can use a path or a URL:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"sourceMap\":true,\"sourceRoot\":\"https://my-website.com/debug/source/\"}}"
                },
                {
                    "type": "p",
                    "text": "Would declare thatindex.jswill have a source file athttps://my-website.com/debug/source/index.ts."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Strip Internal -stripInternal"
                },
                {
                    "type": "p",
                    "text": "Do not emit declarations for code that has an@internalannotation in its JSDoc comment.\nThis is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid.\nIf you are searching for a tool to handle additional levels of visibility within yourd.tsfiles, look atapi-extractor."
                },
                {
                    "type": "code",
                    "code": "ts/*** Days available in a week*@internal*/exportconstdaysInAWeek=7;/** Calculate how much someone earns in a week */exportfunctionweeklySalary(dayRate:number) {returndaysInAWeek*dayRate;}Try"
                },
                {
                    "type": "p",
                    "text": "With the flag set tofalse(default):"
                },
                {
                    "type": "code",
                    "code": "ts/*** Days available in a week*@internal*/exportdeclareconstdaysInAWeek=7;/** Calculate how much someone earns in a week */exportdeclarefunctionweeklySalary(dayRate:number):number;Try"
                },
                {
                    "type": "p",
                    "text": "WithstripInternalset totruethed.tsemitted will be redacted."
                },
                {
                    "type": "code",
                    "code": "ts/** Calculate how much someone earns in a week */exportdeclarefunctionweeklySalary(dayRate:number):number;Try"
                },
                {
                    "type": "p",
                    "text": "The JavaScript output is still the same."
                },
                {
                    "type": "list",
                    "items": [
                        "Internal"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#JavaScript Support"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow JS -allowJs"
                },
                {
                    "type": "p",
                    "text": "Allow JavaScript files to be imported inside your project, instead of just.tsand.tsxfiles. For example, this JS file:"
                },
                {
                    "type": "code",
                    "code": "js// @filename: card.jsexportconstdefaultCardDeck=\"Heart\";Try"
                },
                {
                    "type": "p",
                    "text": "When imported into a TypeScript file will raise an error:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: index.tsimport{defaultCardDeck}from\"./card\";console.log(defaultCardDeck);Try"
                },
                {
                    "type": "p",
                    "text": "Imports fine withallowJsenabled:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: index.tsimport{defaultCardDeck}from\"./card\";console.log(defaultCardDeck);Try"
                },
                {
                    "type": "p",
                    "text": "This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the.tsand.tsxfiles to live along-side existing JavaScript files."
                },
                {
                    "type": "p",
                    "text": "It can also be used along-sidedeclarationandemitDeclarationOnlytocreate declarations for JS files."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:checkJsemitDeclarationOnly",
                        "checkJs",
                        "emitDeclarationOnly",
                        "Released:1.8"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "checkJs",
                        "emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "checkJs"
                },
                {
                    "type": "p",
                    "text": "emitDeclarationOnly"
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Check JS -checkJs"
                },
                {
                    "type": "p",
                    "text": "Works in tandem withallowJs. WhencheckJsis enabled then errors are reported in JavaScript files. This is\nthe equivalent of including// @ts-checkat the top of all JavaScript files which are included in your project."
                },
                {
                    "type": "p",
                    "text": "For example, this is incorrect JavaScript according to theparseFloattype definition which comes with TypeScript:"
                },
                {
                    "type": "code",
                    "code": "js// parseFloat only takes a stringmodule.exports.pi=parseFloat(3.142);"
                },
                {
                    "type": "p",
                    "text": "When imported into a TypeScript module:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: constants.jsmodule.exports.pi=parseFloat(3.142);// @filename: index.tsimport{pi}from\"./constants\";console.log(pi);Try"
                },
                {
                    "type": "p",
                    "text": "You will not get any errors. However, if you turn oncheckJsthen you will get error messages from the JavaScript file."
                },
                {
                    "type": "code",
                    "code": "ts// @filename: constants.jsmodule.exports.pi=parseFloat(3.142);Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.// @filename: index.tsimport{pi}from\"./constants\";console.log(pi);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:allowJsemitDeclarationOnly",
                        "allowJs",
                        "emitDeclarationOnly",
                        "Released:2.3"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "allowJs",
                        "emitDeclarationOnly"
                    ]
                },
                {
                    "type": "p",
                    "text": "allowJs"
                },
                {
                    "type": "p",
                    "text": "emitDeclarationOnly"
                },
                {
                    "type": "p",
                    "text": "2.3"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Max Node Module JS Depth -maxNodeModuleJsDepth"
                },
                {
                    "type": "p",
                    "text": "The maximum dependency depth to search undernode_modulesand load JavaScript files."
                },
                {
                    "type": "p",
                    "text": "This flag can only be used whenallowJsis enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside yournode_modules."
                },
                {
                    "type": "p",
                    "text": "Ideally this should stay at 0 (the default), andd.tsfiles should be used to explicitly define the shape of modules.\nHowever, there are cases where you may want to turn this on at the expense of speed and potential accuracy."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Editor Support"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Disable Size Limit -disableSizeLimit"
                },
                {
                    "type": "p",
                    "text": "To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Plugins -plugins"
                },
                {
                    "type": "p",
                    "text": "List of language service plugins to run inside the editor."
                },
                {
                    "type": "p",
                    "text": "Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages."
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "list",
                    "items": [
                        "ts-sql-plugin— Adds SQL linting with a template strings SQL builder.",
                        "typescript-styled-plugin— Provides CSS linting inside template strings .",
                        "typescript-eslint-language-service— Provides eslint error messaging and fix-its inside the compiler’s output.",
                        "ts-graphql-plugin— Provides validation and auto-completion inside GraphQL query template strings."
                    ]
                },
                {
                    "type": "p",
                    "text": "VS Code has the ability for a extension toautomatically include language service plugins, and so you may have some running in your editor without needing to define them in yourtsconfig.json."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Interop Constraints"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Allow Synthetic Default Imports -allowSyntheticDefaultImports"
                },
                {
                    "type": "p",
                    "text": "When set to true,allowSyntheticDefaultImportsallows you to write an import like:"
                },
                {
                    "type": "code",
                    "code": "tsimportReactfrom\"react\";"
                },
                {
                    "type": "p",
                    "text": "instead of:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asReactfrom\"react\";"
                },
                {
                    "type": "p",
                    "text": "When the moduledoes notexplicitly specify a default export."
                },
                {
                    "type": "p",
                    "text": "For example, withoutallowSyntheticDefaultImportsas true:"
                },
                {
                    "type": "code",
                    "code": "ts// @filename: utilFunctions.jsconstgetStringLength= (str)=>str.length;module.exports= {getStringLength,};// @filename: index.tsimportutilsfrom\"./utilFunctions\";Module '\"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions\"' has no default export.1192Module '\"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/utilFunctions\"' has no default export.constcount=utils.getStringLength(\"Check JS\");Try"
                },
                {
                    "type": "p",
                    "text": "This code raises an error because there isn’t adefaultobject which you can import. Even though it feels like it should.\nFor convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:"
                },
                {
                    "type": "code",
                    "code": "js// @filename: utilFunctions.jsconstgetStringLength= (str)=>str.length;constallFunctions= {getStringLength,};module.exports=allFunctions;module.exports.default=allFunctions;"
                },
                {
                    "type": "p",
                    "text": "This flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking.\nThis option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueifesModuleInteropis enabled,moduleissystem, ormoduleResolutionisbundler;falseotherwise.",
                        "Related:esModuleInterop",
                        "esModuleInterop",
                        "Released:1.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifesModuleInteropis enabled,moduleissystem, ormoduleResolutionisbundler;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "esModuleInterop"
                    ]
                },
                {
                    "type": "p",
                    "text": "esModuleInterop"
                },
                {
                    "type": "p",
                    "text": "1.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#ES Module Interop -esModuleInterop"
                },
                {
                    "type": "p",
                    "text": "By default (withesModuleInteropfalse or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:"
                },
                {
                    "type": "list",
                    "items": [
                        "a namespace import likeimport * as moment from \"moment\"acts the same asconst moment = require(\"moment\")",
                        "a default import likeimport moment from \"moment\"acts the same asconst moment = require(\"moment\").default"
                    ]
                },
                {
                    "type": "p",
                    "text": "a namespace import likeimport * as moment from \"moment\"acts the same asconst moment = require(\"moment\")"
                },
                {
                    "type": "p",
                    "text": "a default import likeimport moment from \"moment\"acts the same asconst moment = require(\"moment\").default"
                },
                {
                    "type": "p",
                    "text": "This mis-match causes these two issues:"
                },
                {
                    "type": "list",
                    "items": [
                        "the ES6 modules spec states that a namespace import (import * as x) can only be an object, by having TypeScript\ntreating it the same as= require(\"x\")then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.",
                        "while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation."
                    ]
                },
                {
                    "type": "p",
                    "text": "the ES6 modules spec states that a namespace import (import * as x) can only be an object, by having TypeScript\ntreating it the same as= require(\"x\")then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec."
                },
                {
                    "type": "p",
                    "text": "while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation."
                },
                {
                    "type": "p",
                    "text": "Turning onesModuleInteropwill fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:"
                },
                {
                    "type": "code",
                    "code": "tsimport*asfsfrom\"fs\";import_from\"lodash\";fs.readFileSync(\"file.txt\",\"utf8\");_.chunk([\"a\",\"b\",\"c\",\"d\"],2);"
                },
                {
                    "type": "p",
                    "text": "WithesModuleInteropdisabled:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});constfs=require(\"fs\");constlodash_1=require(\"lodash\");fs.readFileSync(\"file.txt\",\"utf8\");lodash_1.default.chunk([\"a\",\"b\",\"c\",\"d\"],2);Try"
                },
                {
                    "type": "p",
                    "text": "WithesModuleInteropset totrue:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__createBinding= (this&&this.__createBinding) || (Object.create? (function(o,m,k,k2) {if(k2===undefined)k2=k;vardesc=Object.getOwnPropertyDescriptor(m,k);if(!desc|| (\"get\"indesc? !m.__esModule:desc.writable||desc.configurable)) {desc= {enumerable:true,get:function() {returnm[k]; } };}Object.defineProperty(o,k2,desc);}) : (function(o,m,k,k2) {if(k2===undefined)k2=k;o[k2] =m[k];}));var__setModuleDefault= (this&&this.__setModuleDefault) || (Object.create? (function(o,v) {Object.defineProperty(o,\"default\", {enumerable:true,value:v});}) :function(o,v) {o[\"default\"] =v;});var__importStar= (this&&this.__importStar) ||function(mod) {if(mod&&mod.__esModule)returnmod;varresult= {};if(mod!=null)for(varkinmod)if(k!==\"default\"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);returnresult;};var__importDefault= (this&&this.__importDefault) ||function(mod) {return(mod&&mod.__esModule) ?mod: {\"default\":mod};};Object.defineProperty(exports,\"__esModule\", {value:true});constfs=__importStar(require(\"fs\"));constlodash_1=__importDefault(require(\"lodash\"));fs.readFileSync(\"file.txt\",\"utf8\");lodash_1.default.chunk([\"a\",\"b\",\"c\",\"d\"],2);Try"
                },
                {
                    "type": "p",
                    "text": "Note: The namespace importimport * as fs from \"fs\"only accounts for properties whichare owned(basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (import fs from \"fs\"), or disableesModuleInterop."
                },
                {
                    "type": "p",
                    "text": "Note: You can make JS emit terser by enablingimportHelpers:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});consttslib_1=require(\"tslib\");constfs=tslib_1.__importStar(require(\"fs\"));constlodash_1=tslib_1.__importDefault(require(\"lodash\"));fs.readFileSync(\"file.txt\",\"utf8\");lodash_1.default.chunk([\"a\",\"b\",\"c\",\"d\"],2);Try"
                },
                {
                    "type": "p",
                    "text": "EnablingesModuleInteropwill also enableallowSyntheticDefaultImports."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:trueifmoduleisnode16ornodenext;falseotherwise.",
                        "Related:allowSyntheticDefaultImports",
                        "allowSyntheticDefaultImports",
                        "Released:2.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifmoduleisnode16ornodenext;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "allowSyntheticDefaultImports"
                    ]
                },
                {
                    "type": "p",
                    "text": "allowSyntheticDefaultImports"
                },
                {
                    "type": "p",
                    "text": "2.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Force Consistent Casing In File Names -forceConsistentCasingInFileNames"
                },
                {
                    "type": "p",
                    "text": "TypeScript follows the case sensitivity rules of the file system it’s running on.\nThis can be problematic if some developers are working in a case-sensitive file system and others aren’t.\nIf a file attempts to importfileManager.tsby specifying./FileManager.tsthe file will be found in a case-insensitive file system, but not on a case-sensitive file system."
                },
                {
                    "type": "p",
                    "text": "When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Default:true"
                    ]
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#isolatedDeclarations -isolatedDeclarations"
                },
                {
                    "type": "p",
                    "text": "For more information, see the5.5 release notes"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Isolated Modules -isolatedModules"
                },
                {
                    "type": "p",
                    "text": "While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such asBabelto do this.\nHowever, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system.\nThis restriction also applies to TypeScript’sts.transpileModuleAPI which is used by some build tools."
                },
                {
                    "type": "p",
                    "text": "These limitations can cause runtime problems with some TypeScript features likeconst enums andnamespaces.\nSetting theisolatedModulesflag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process."
                },
                {
                    "type": "p",
                    "text": "It does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process."
                },
                {
                    "type": "p",
                    "text": "Some examples of code which does not work whenisolatedModulesis enabled."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Exports of Non-Value Identifiers"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, you can import atypeand then subsequently export it:"
                },
                {
                    "type": "code",
                    "code": "tsimport{someType,someFunction}from\"someModule\";someFunction();export{someType,someFunction};Try"
                },
                {
                    "type": "p",
                    "text": "Because there’s no value forsomeType, the emittedexportwill not try to export it (this would be a runtime error in JavaScript):"
                },
                {
                    "type": "code",
                    "code": "jsexport{someFunction};"
                },
                {
                    "type": "p",
                    "text": "Single-file transpilers don’t know whethersomeTypeproduces a value or not, so it’s an error to export a name that only refers to a type."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Non-Module Files"
                },
                {
                    "type": "p",
                    "text": "IfisolatedModulesis set, namespaces are only allowed inmodules(which means it has some form ofimport/export). An error occurs if a namespace is found in a non-module file:"
                },
                {
                    "type": "code",
                    "code": "tsnamespaceInstantiated{Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.1280Namespaces are not allowed in global script files when 'isolatedModules' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.exportconstx=1;}Try"
                },
                {
                    "type": "p",
                    "text": "This restriction doesn’t apply to.d.tsfiles."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "References toconst enummembers"
                },
                {
                    "type": "p",
                    "text": "In TypeScript, when you reference aconst enummember, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:"
                },
                {
                    "type": "code",
                    "code": "tsdeclareconstenumNumbers{Zero=0,One=1,}console.log(Numbers.Zero+Numbers.One);Try"
                },
                {
                    "type": "p",
                    "text": "To this JavaScript:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";console.log(0+1);Try"
                },
                {
                    "type": "p",
                    "text": "Without knowledge of the values of these members, other transpilers can’t replace the references toNumbers, which would be a runtime error if left alone (since there are noNumbersobject at runtime).\nBecause of this, whenisolatedModulesis set, it is an error to reference an ambientconst enummember."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueifverbatimModuleSyntax;falseotherwise."
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifverbatimModuleSyntax;falseotherwise."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Preserve Symlinks -preserveSymlinks"
                },
                {
                    "type": "p",
                    "text": "This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks."
                },
                {
                    "type": "p",
                    "text": "This flag also exhibits the opposite behavior to Webpack’sresolve.symlinksoption (i.e. setting TypeScript’spreserveSymlinksto true parallels setting Webpack’sresolve.symlinksto false, and vice-versa)."
                },
                {
                    "type": "p",
                    "text": "With this enabled, references to modules and packages (e.g.imports and/// <reference type=\"...\" />directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Verbatim Module Syntax -verbatimModuleSyntax"
                },
                {
                    "type": "p",
                    "text": "By default, TypeScript does something calledimport elision.\nBasically, if you write something like"
                },
                {
                    "type": "code",
                    "code": "tsimport{Car}from\"./car\";exportfunctiondrive(car:Car) {// ...}"
                },
                {
                    "type": "p",
                    "text": "TypeScript detects that you’re only using an import for types and drops the import entirely.\nYour output JavaScript might look something like this:"
                },
                {
                    "type": "code",
                    "code": "jsexportfunctiondrive(car) {// ...}"
                },
                {
                    "type": "p",
                    "text": "Most of the time this is good, because ifCarisn’t a value that’s exported from./car, we’ll get a runtime error."
                },
                {
                    "type": "p",
                    "text": "But it does add a layer of complexity for certain edge cases.\nFor example, notice there’s no statement likeimport \"./car\";- the import was dropped entirely.\nThat actually makes a difference for modules that have side-effects or not."
                },
                {
                    "type": "p",
                    "text": "TypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well.\nSo it’s not always clear whether code like the following"
                },
                {
                    "type": "code",
                    "code": "tsexport{Car}from\"./car\";"
                },
                {
                    "type": "p",
                    "text": "should be preserved or dropped.\nIfCaris declared with something like aclass, then it can be preserved in the resulting JavaScript file.\nBut ifCaris only declared as atypealias orinterface, then the JavaScript file shouldn’t exportCarat all."
                },
                {
                    "type": "p",
                    "text": "While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can."
                },
                {
                    "type": "p",
                    "text": "Thetypemodifier on imports and exports helps with these situations a bit.\nWe can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using thetypemodifier."
                },
                {
                    "type": "code",
                    "code": "ts// This statement can be dropped entirely in JS outputimporttype*ascarfrom\"./car\";// The named import/export 'Car' can be dropped in JS outputimport{typeCar}from\"./car\";export{typeCar}from\"./car\";"
                },
                {
                    "type": "p",
                    "text": "typemodifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction betweentypeand plain imports and exports.\nSo TypeScript has the flag--importsNotUsedAsValuesto make sure you use thetypemodifier,--preserveValueImportsto preventsomemodule elision behavior, and--isolatedModulesto make sure that your TypeScript code works across different compilers.\nUnfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior."
                },
                {
                    "type": "p",
                    "text": "TypeScript 5.0 introduces a new option called--verbatimModuleSyntaxto simplify the situation.\nThe rules are much simpler - any imports or exports without atypemodifier are left around.\nAnything that uses thetypemodifier is dropped entirely."
                },
                {
                    "type": "code",
                    "code": "ts// Erased away entirely.importtype{A}from\"a\";// Rewritten to 'import { b } from \"bcd\";'import{b,typec,typed}from\"bcd\";// Rewritten to 'import {} from \"xyz\";'import{typexyz}from\"xyz\";"
                },
                {
                    "type": "p",
                    "text": "With this new option, what you see is what you get."
                },
                {
                    "type": "p",
                    "text": "That does have some implications when it comes to module interop though.\nUnder this flag, ECMAScriptimports andexports won’t be rewritten torequirecalls when your settings or file extension implied a different module system.\nInstead, you’ll get an error.\nIf you need to emit code that usesrequireandmodule.exports, you’ll have to use TypeScript’s module syntax that predates ES2015:"
                },
                {
                    "type": "code",
                    "code": "tsimportfoo=require(\"foo\");"
                },
                {
                    "type": "code",
                    "code": "jsconstfoo=require(\"foo\");"
                },
                {
                    "type": "code",
                    "code": "tsfunctionfoo() {}functionbar() {}functionbaz() {}export= {foo,bar,baz,};"
                },
                {
                    "type": "code",
                    "code": "jsfunctionfoo() {}functionbar() {}functionbaz() {}module.exports= {foo,bar,baz,};"
                },
                {
                    "type": "p",
                    "text": "While this is a limitation, it does help make some issues more obvious.\nFor example, it’s very common to forget to set thetypefield inpackage.jsonunder--module node16.\nAs a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output.\nThis new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different."
                },
                {
                    "type": "p",
                    "text": "Because--verbatimModuleSyntaxprovides a more consistent story than--importsNotUsedAsValuesand--preserveValueImports, those two existing flags are being deprecated in its favor."
                },
                {
                    "type": "p",
                    "text": "For more details, read up onthe original pull requestandits proposal issue."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Backwards Compatibility"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Charset -charset"
                },
                {
                    "type": "p",
                    "text": "In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk.\nToday, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs."
                },
                {
                    "type": "list",
                    "items": [
                        "Deprecated",
                        "Default:utf8"
                    ]
                },
                {
                    "type": "p",
                    "text": "utf8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Imports Not Used As Values -importsNotUsedAsValues"
                },
                {
                    "type": "p",
                    "text": "Deprecated in favor ofverbatimModuleSyntax."
                },
                {
                    "type": "p",
                    "text": "This flag controls howimportworks, there are 3 different options:"
                },
                {
                    "type": "list",
                    "items": [
                        "remove: The default behavior of droppingimportstatements which only reference types.",
                        "preserve: Preserves allimportstatements whose values or types are never used. This can cause imports/side-effects to be preserved.",
                        "error: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit."
                    ]
                },
                {
                    "type": "p",
                    "text": "remove: The default behavior of droppingimportstatements which only reference types."
                },
                {
                    "type": "p",
                    "text": "preserve: Preserves allimportstatements whose values or types are never used. This can cause imports/side-effects to be preserved."
                },
                {
                    "type": "p",
                    "text": "error: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit."
                },
                {
                    "type": "p",
                    "text": "This flag works because you can useimport typeto explicitly create animportstatement which should never be emitted into JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:remove",
                        "Allowed:removepreserveerror",
                        "remove",
                        "preserve",
                        "error",
                        "Related:preserveValueImportsverbatimModuleSyntax",
                        "preserveValueImports",
                        "verbatimModuleSyntax",
                        "Released:3.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "remove"
                },
                {
                    "type": "list",
                    "items": [
                        "remove",
                        "preserve",
                        "error"
                    ]
                },
                {
                    "type": "p",
                    "text": "remove"
                },
                {
                    "type": "p",
                    "text": "preserve"
                },
                {
                    "type": "p",
                    "text": "error"
                },
                {
                    "type": "list",
                    "items": [
                        "preserveValueImports",
                        "verbatimModuleSyntax"
                    ]
                },
                {
                    "type": "p",
                    "text": "preserveValueImports"
                },
                {
                    "type": "p",
                    "text": "verbatimModuleSyntax"
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Keyof Strings Only -keyofStringsOnly"
                },
                {
                    "type": "p",
                    "text": "This flag changes thekeyoftype operator to returnstringinstead ofstring | numberwhen applied to a type with a string index signature."
                },
                {
                    "type": "p",
                    "text": "This flag is used to help people keep this behavior frombefore TypeScript 2.9’s release."
                },
                {
                    "type": "list",
                    "items": [
                        "Deprecated",
                        "Released:2.9"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.9"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Implicit Use Strict -noImplicitUseStrict"
                },
                {
                    "type": "p",
                    "text": "You shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a\"use strict\";prologue at the top of the file.\nThis setting disables the prologue."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Strict Generic Checks -noStrictGenericChecks"
                },
                {
                    "type": "p",
                    "text": "TypeScript will unify type parameters when comparing two generic functions."
                },
                {
                    "type": "code",
                    "code": "tstypeA= <T,U>(x:T,y:U)=>[T,U];typeB= <S>(x:S,y:S)=>[S,S];functionf(a:A,b:B) {b=a;// Oka=b;// ErrorType 'B' is not assignable to type 'A'.\n  Types of parameters 'y' and 'y' are incompatible.\n    Type 'U' is not assignable to type 'T'.\n      'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.2322Type 'B' is not assignable to type 'A'.\n  Types of parameters 'y' and 'y' are incompatible.\n    Type 'U' is not assignable to type 'T'.\n      'T' could be instantiated with an arbitrary type which could be unrelated to 'U'.}Try"
                },
                {
                    "type": "p",
                    "text": "This flag can be used to remove that check."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:2.4"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.4"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Out -out"
                },
                {
                    "type": "p",
                    "text": "UseoutFileinstead."
                },
                {
                    "type": "p",
                    "text": "Theoutoption computes the final file location in a way that is not predictable or consistent.\nThis option is retained for backward compatibility only and is deprecated."
                },
                {
                    "type": "list",
                    "items": [
                        "Deprecated",
                        "Related:outDiroutFile",
                        "outDir",
                        "outFile"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "outDir",
                        "outFile"
                    ]
                },
                {
                    "type": "p",
                    "text": "outDir"
                },
                {
                    "type": "p",
                    "text": "outFile"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Preserve Value Imports -preserveValueImports"
                },
                {
                    "type": "p",
                    "text": "Deprecated in favor ofverbatimModuleSyntax."
                },
                {
                    "type": "p",
                    "text": "There are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:"
                },
                {
                    "type": "code",
                    "code": "tsimport{Animal}from\"./animal.js\";eval(\"console.log(new Animal().isDangerous())\");"
                },
                {
                    "type": "p",
                    "text": "or code using ‘Compiles to HTML’ languages like Svelte or Vue.preserveValueImportswill prevent TypeScript from removing the import, even if it appears unused."
                },
                {
                    "type": "p",
                    "text": "When combined withisolatedModules: imported typesmustbe marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:isolatedModulesimportsNotUsedAsValuesverbatimModuleSyntax",
                        "isolatedModules",
                        "importsNotUsedAsValues",
                        "verbatimModuleSyntax",
                        "Released:4.5"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "isolatedModules",
                        "importsNotUsedAsValues",
                        "verbatimModuleSyntax"
                    ]
                },
                {
                    "type": "p",
                    "text": "isolatedModules"
                },
                {
                    "type": "p",
                    "text": "importsNotUsedAsValues"
                },
                {
                    "type": "p",
                    "text": "verbatimModuleSyntax"
                },
                {
                    "type": "p",
                    "text": "4.5"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Suppress Excess Property Errors -suppressExcessPropertyErrors"
                },
                {
                    "type": "p",
                    "text": "This disables reporting of excess property errors, such as the one shown in the following example:"
                },
                {
                    "type": "code",
                    "code": "tstypePoint= {x:number;y:number};constp:Point= {x:1,y:3,m:10};Object literal may only specify known properties, and 'm' does not exist in type 'Point'.2353Object literal may only specify known properties, and 'm' does not exist in type 'Point'.Try"
                },
                {
                    "type": "p",
                    "text": "This flag was added to help people migrate to the stricter checking of new object literals inTypeScript 1.6."
                },
                {
                    "type": "p",
                    "text": "We don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using// @ts-ignore."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Suppress Implicit Any Index Errors -suppressImplicitAnyIndexErrors"
                },
                {
                    "type": "p",
                    "text": "TurningsuppressImplicitAnyIndexErrorson suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:"
                },
                {
                    "type": "code",
                    "code": "tsconstobj= {x:10};console.log(obj[\"foo\"]);Element implicitly has an 'any' type because expression of type '\"foo\"' can't be used to index type '{ x: number; }'.\n  Property 'foo' does not exist on type '{ x: number; }'.7053Element implicitly has an 'any' type because expression of type '\"foo\"' can't be used to index type '{ x: number; }'.\n  Property 'foo' does not exist on type '{ x: number; }'.Try"
                },
                {
                    "type": "p",
                    "text": "UsingsuppressImplicitAnyIndexErrorsis quite a drastic approach. It is recommended to use a@ts-ignorecomment instead:"
                },
                {
                    "type": "code",
                    "code": "tsconstobj= {x:10};// @ts-ignoreconsole.log(obj[\"foo\"]);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:noImplicitAny",
                        "noImplicitAny"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "noImplicitAny"
                    ]
                },
                {
                    "type": "p",
                    "text": "noImplicitAny"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Language and Environment"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Emit Decorator Metadata -emitDecoratorMetadata"
                },
                {
                    "type": "p",
                    "text": "Enables experimental support for emitting type metadata for decorators which works with the modulereflect-metadata."
                },
                {
                    "type": "p",
                    "text": "For example, here is the TypeScript"
                },
                {
                    "type": "code",
                    "code": "tsfunctionLogMethod(target:any,propertyKey:string|symbol,descriptor:PropertyDescriptor) {console.log(target);console.log(propertyKey);console.log(descriptor);}classDemo{@LogMethodpublicfoo(bar:number) {// do nothing}}constdemo=newDemo();Try"
                },
                {
                    "type": "p",
                    "text": "WithemitDecoratorMetadatanot set to true (default) the emitted JavaScript is:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__decorate= (this&&this.__decorate) ||function(decorators,target,key,desc) {varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key) :desc,d;if(typeofReflect===\"object\"&&typeofReflect.decorate===\"function\")r=Reflect.decorate(decorators,target,key,desc);elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r= (c<3?d(r) :c>3?d(target,key,r) :d(target,key)) ||r;returnc>3&&r&&Object.defineProperty(target,key,r),r;};functionLogMethod(target,propertyKey,descriptor) {console.log(target);console.log(propertyKey);console.log(descriptor);}classDemo{foo(bar) {// do nothing}}__decorate([LogMethod],Demo.prototype,\"foo\",null);constdemo=newDemo();Try"
                },
                {
                    "type": "p",
                    "text": "WithemitDecoratorMetadataset to true the emitted JavaScript is:"
                },
                {
                    "type": "code",
                    "code": "ts\"use strict\";var__decorate= (this&&this.__decorate) ||function(decorators,target,key,desc) {varc=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key) :desc,d;if(typeofReflect===\"object\"&&typeofReflect.decorate===\"function\")r=Reflect.decorate(decorators,target,key,desc);elsefor(vari=decorators.length-1;i>=0;i--)if(d=decorators[i])r= (c<3?d(r) :c>3?d(target,key,r) :d(target,key)) ||r;returnc>3&&r&&Object.defineProperty(target,key,r),r;};var__metadata= (this&&this.__metadata) ||function(k,v) {if(typeofReflect===\"object\"&&typeofReflect.metadata===\"function\")returnReflect.metadata(k,v);};functionLogMethod(target,propertyKey,descriptor) {console.log(target);console.log(propertyKey);console.log(descriptor);}classDemo{foo(bar) {// do nothing}}__decorate([LogMethod,__metadata(\"design:type\",Function),__metadata(\"design:paramtypes\", [Number]),__metadata(\"design:returntype\",void0)],Demo.prototype,\"foo\",null);constdemo=newDemo();Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Related:experimentalDecorators",
                        "experimentalDecorators"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "experimentalDecorators"
                    ]
                },
                {
                    "type": "p",
                    "text": "experimentalDecorators"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Experimental Decorators -experimentalDecorators"
                },
                {
                    "type": "p",
                    "text": "Enablesexperimental support for decorators, which is a version of decorators that predates the TC39 standardization process."
                },
                {
                    "type": "p",
                    "text": "Decorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification.\nThis means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39."
                },
                {
                    "type": "p",
                    "text": "You can find out more about decorator support in TypeScript inthe handbook."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:emitDecoratorMetadata",
                        "emitDecoratorMetadata"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "emitDecoratorMetadata"
                    ]
                },
                {
                    "type": "p",
                    "text": "emitDecoratorMetadata"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#JSX -jsx"
                },
                {
                    "type": "p",
                    "text": "Controls how JSX constructs are emitted in JavaScript files.\nThis only affects output of JS files that started in.tsxfiles."
                },
                {
                    "type": "list",
                    "items": [
                        "react-jsx: Emit.jsfiles with the JSX changed to_jsxcalls optimized for production",
                        "react-jsxdev: Emit.jsfiles with the JSX changed to_jsxcalls for development only",
                        "preserve: Emit.jsxfiles with the JSX unchanged",
                        "react-native: Emit.jsfiles with the JSX unchanged",
                        "react: Emit.jsfiles with JSX changed to the equivalentReact.createElementcalls"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "For example"
                },
                {
                    "type": "p",
                    "text": "This sample code:"
                },
                {
                    "type": "code",
                    "code": "tsxexportconstHelloWorld= ()=><h1>Hello world</h1>;"
                },
                {
                    "type": "p",
                    "text": "React:\"react-jsx\"[1]"
                },
                {
                    "type": "code",
                    "code": "tsximport{jsxas_jsx}from\"react/jsx-runtime\";exportconstHelloWorld= ()=>_jsx(\"h1\", {children:\"Hello world\"});Try"
                },
                {
                    "type": "p",
                    "text": "React dev transform:\"react-jsxdev\"[1]"
                },
                {
                    "type": "code",
                    "code": "tsximport{jsxDEVas_jsxDEV}from\"react/jsx-dev-runtime\";const_jsxFileName=\"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx\";exportconstHelloWorld= ()=>_jsxDEV(\"h1\", {children:\"Hello world\"},void0,false, {fileName:_jsxFileName,lineNumber:9,columnNumber:32},this);Try"
                },
                {
                    "type": "p",
                    "text": "Preserve:\"preserve\""
                },
                {
                    "type": "code",
                    "code": "tsximportReactfrom'react';exportconstHelloWorld= ()=><h1>Hello world</h1>;Try"
                },
                {
                    "type": "p",
                    "text": "React Native:\"react-native\""
                },
                {
                    "type": "code",
                    "code": "tsximportReactfrom'react';exportconstHelloWorld= ()=><h1>Hello world</h1>;Try"
                },
                {
                    "type": "p",
                    "text": "Legacy React runtime:\"react\""
                },
                {
                    "type": "code",
                    "code": "tsximportReactfrom'react';exportconstHelloWorld= ()=>React.createElement(\"h1\",null,\"Hello world\");Try"
                },
                {
                    "type": "p",
                    "text": "This option can be used on a per-file basis too using an@jsxRuntimecomment."
                },
                {
                    "type": "p",
                    "text": "Always use the classic runtime (\"react\") for this file:"
                },
                {
                    "type": "code",
                    "code": "tsx/* @jsxRuntime classic */exportconstHelloWorld= ()=><h1>Hello world</h1>;"
                },
                {
                    "type": "p",
                    "text": "Always use the automatic runtime (\"react-jsx\") for this file:"
                },
                {
                    "type": "code",
                    "code": "tsx/* @jsxRuntime automatic */exportconstHelloWorld= ()=><h1>Hello world</h1>;"
                },
                {
                    "type": "list",
                    "items": [
                        "Allowed:preservereactreact-nativereact-jsxreact-jsxdev",
                        "preserve",
                        "react",
                        "react-native",
                        "react-jsx",
                        "react-jsxdev",
                        "Related:jsxFactoryjsxFragmentFactoryjsxImportSource",
                        "jsxFactory",
                        "jsxFragmentFactory",
                        "jsxImportSource",
                        "Released:2.2"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preserve",
                        "react",
                        "react-native",
                        "react-jsx",
                        "react-jsxdev"
                    ]
                },
                {
                    "type": "p",
                    "text": "preserve"
                },
                {
                    "type": "p",
                    "text": "react"
                },
                {
                    "type": "p",
                    "text": "react-native"
                },
                {
                    "type": "p",
                    "text": "react-jsx"
                },
                {
                    "type": "p",
                    "text": "react-jsxdev"
                },
                {
                    "type": "list",
                    "items": [
                        "jsxFactory",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "jsxFactory"
                },
                {
                    "type": "p",
                    "text": "jsxFragmentFactory"
                },
                {
                    "type": "p",
                    "text": "jsxImportSource"
                },
                {
                    "type": "p",
                    "text": "2.2"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#JSX Factory -jsxFactory"
                },
                {
                    "type": "p",
                    "text": "Changes the function called in.jsfiles when compiling JSX Elements using the classic JSX runtime.\nThe most common change is to use\"h\"or\"preact.h\"instead of the default\"React.createElement\"if usingpreact."
                },
                {
                    "type": "p",
                    "text": "For example, this TSX file:"
                },
                {
                    "type": "code",
                    "code": "tsximport{h}from\"preact\";constHelloWorld= ()=><div>Hello</div>;"
                },
                {
                    "type": "p",
                    "text": "WithjsxFactory: \"h\"looks like:"
                },
                {
                    "type": "code",
                    "code": "tsxconstpreact_1=require(\"preact\");constHelloWorld= ()=>(0,preact_1.h)(\"div\",null,\"Hello\");Try"
                },
                {
                    "type": "p",
                    "text": "This option can be used on a per-file basis too similar toBabel’s/** @jsx h */directive."
                },
                {
                    "type": "code",
                    "code": "tsx/**@jsxh */import{h}from\"preact\";Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.constHelloWorld= ()=><div>Hello</div>;Try"
                },
                {
                    "type": "p",
                    "text": "The factory chosen will also affect where theJSXnamespace is looked up (for type checking information) before falling back to the global one."
                },
                {
                    "type": "p",
                    "text": "If the factory is defined asReact.createElement(the default), the compiler will check forReact.JSXbefore checking for a globalJSX. If the factory is defined ash, it will check forh.JSXbefore a globalJSX."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:React.createElement",
                        "Allowed:Any identifier or dotted identifier.",
                        "Any identifier or dotted identifier.",
                        "Related:jsxjsxFragmentFactoryjsxImportSource",
                        "jsx",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "React.createElement"
                },
                {
                    "type": "list",
                    "items": [
                        "Any identifier or dotted identifier."
                    ]
                },
                {
                    "type": "p",
                    "text": "Any identifier or dotted identifier."
                },
                {
                    "type": "list",
                    "items": [
                        "jsx",
                        "jsxFragmentFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "jsx"
                },
                {
                    "type": "p",
                    "text": "jsxFragmentFactory"
                },
                {
                    "type": "p",
                    "text": "jsxImportSource"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#JSX Fragment Factory -jsxFragmentFactory"
                },
                {
                    "type": "p",
                    "text": "Specify the JSX fragment factory function to use when targeting react JSX emit withjsxFactorycompiler option is specified, e.g.Fragment."
                },
                {
                    "type": "p",
                    "text": "For example with this TSConfig:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"esnext\",\"module\":\"commonjs\",\"jsx\":\"react\",\"jsxFactory\":\"h\",\"jsxFragmentFactory\":\"Fragment\"}}"
                },
                {
                    "type": "p",
                    "text": "This TSX file:"
                },
                {
                    "type": "code",
                    "code": "tsximport{h,Fragment}from\"preact\";constHelloWorld= ()=>(<><div>Hello</div></>);"
                },
                {
                    "type": "p",
                    "text": "Would look like:"
                },
                {
                    "type": "code",
                    "code": "tsxconstpreact_1=require(\"preact\");constHelloWorld= ()=>((0,preact_1.h)(preact_1.Fragment,null,(0,preact_1.h)(\"div\",null,\"Hello\")));Try"
                },
                {
                    "type": "p",
                    "text": "This option can be used on a per-file basis too similar toBabel’s/* @jsxFrag h */directive."
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "code",
                    "code": "tsx/**@jsxh *//**@jsxFragFragment */import{h,Fragment}from\"preact\";Cannot find module 'preact' or its corresponding type declarations.2307Cannot find module 'preact' or its corresponding type declarations.constHelloWorld= ()=>(<><div>Hello</div></>);Try"
                },
                {
                    "type": "list",
                    "items": [
                        "Default:React.Fragment",
                        "Related:jsxjsxFactoryjsxImportSource",
                        "jsx",
                        "jsxFactory",
                        "jsxImportSource",
                        "Released:4.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "React.Fragment"
                },
                {
                    "type": "list",
                    "items": [
                        "jsx",
                        "jsxFactory",
                        "jsxImportSource"
                    ]
                },
                {
                    "type": "p",
                    "text": "jsx"
                },
                {
                    "type": "p",
                    "text": "jsxFactory"
                },
                {
                    "type": "p",
                    "text": "jsxImportSource"
                },
                {
                    "type": "p",
                    "text": "4.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#JSX Import Source -jsxImportSource"
                },
                {
                    "type": "p",
                    "text": "Declares the module specifier to be used for importing thejsxandjsxsfactory functions when usingjsxas\"react-jsx\"or\"react-jsxdev\"which were introduced in TypeScript 4.1."
                },
                {
                    "type": "p",
                    "text": "WithReact 17the library supports a new form of JSX transformation via a separate import."
                },
                {
                    "type": "p",
                    "text": "For example with this code:"
                },
                {
                    "type": "code",
                    "code": "tsximportReactfrom\"react\";functionApp() {return<h1>Hello World</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Using this TSConfig:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"esnext\",\"module\":\"commonjs\",\"jsx\":\"react-jsx\"}}"
                },
                {
                    "type": "p",
                    "text": "The emitted JavaScript from TypeScript is:"
                },
                {
                    "type": "code",
                    "code": "tsx\"use strict\";Object.defineProperty(exports,\"__esModule\", {value:true});constjsx_runtime_1=require(\"react/jsx-runtime\");functionApp() {return(0,jsx_runtime_1.jsx)(\"h1\", {children:\"Hello World\"});}Try"
                },
                {
                    "type": "p",
                    "text": "For example if you wanted to use\"jsxImportSource\": \"preact\", you need a tsconfig like:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"target\":\"esnext\",\"module\":\"commonjs\",\"jsx\":\"react-jsx\",\"jsxImportSource\":\"preact\",\"types\": [\"preact\"]}}"
                },
                {
                    "type": "p",
                    "text": "Which generates code like:"
                },
                {
                    "type": "code",
                    "code": "tsxfunctionApp() {return(0,jsx_runtime_1.jsx)(\"h1\", {children:\"Hello World\"});}Try"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can use a per-file pragma to set this option, for example:"
                },
                {
                    "type": "code",
                    "code": "tsx/**@jsxImportSourcepreact */exportfunctionApp() {return<h1>Hello World</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Would addpreact/jsx-runtimeas an import for the_jsxfactory."
                },
                {
                    "type": "p",
                    "text": "Note:In order for this to work like you would expect, yourtsxfile must include anexportorimportso that it is considered a module."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:react",
                        "Related:jsxjsxFactory",
                        "jsx",
                        "jsxFactory",
                        "Released:4.1"
                    ]
                },
                {
                    "type": "p",
                    "text": "react"
                },
                {
                    "type": "list",
                    "items": [
                        "jsx",
                        "jsxFactory"
                    ]
                },
                {
                    "type": "p",
                    "text": "jsx"
                },
                {
                    "type": "p",
                    "text": "jsxFactory"
                },
                {
                    "type": "p",
                    "text": "4.1"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Lib -lib"
                },
                {
                    "type": "p",
                    "text": "TypeScript includes a default set of type definitions for built-in JS APIs (likeMath), as well as type definitions for things found in browser environments (likedocument).\nTypeScript also includes APIs for newer JS features matching thetargetyou specify; for example the definition forMapis available iftargetisES6or newer."
                },
                {
                    "type": "p",
                    "text": "You may want to change these for a few reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your program doesn’t run in a browser, so you don’t want the\"dom\"type definitions",
                        "Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn’t yet support the full syntax of a given ECMAScript version",
                        "You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version"
                    ]
                },
                {
                    "type": "p",
                    "text": "In TypeScript 4.5, lib files can be overridden by npm modules, find out morein the blog."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "High Level libraries"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Individual library components"
                },
                {
                    "type": "p",
                    "text": "This list may be out of date, you can see the full list in theTypeScript source code."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:noLib",
                        "noLib",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "noLib"
                    ]
                },
                {
                    "type": "p",
                    "text": "noLib"
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Module Detection -moduleDetection"
                },
                {
                    "type": "p",
                    "text": "This setting controls how TypeScript determines whether a file is ascript or a module."
                },
                {
                    "type": "p",
                    "text": "There are three choices:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"auto\"(default) - TypeScript will not only look for import and export statements, but it will also check whether the\"type\"field in apackage.jsonis set to\"module\"when running withmodule:nodenextornode16, and check whether the current file is a JSX file when running underjsx:react-jsx.",
                        "\"legacy\"- The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.",
                        "\"force\"- Ensures that every non-declaration file is treated as a module."
                    ]
                },
                {
                    "type": "p",
                    "text": "\"auto\"(default) - TypeScript will not only look for import and export statements, but it will also check whether the\"type\"field in apackage.jsonis set to\"module\"when running withmodule:nodenextornode16, and check whether the current file is a JSX file when running underjsx:react-jsx."
                },
                {
                    "type": "p",
                    "text": "\"legacy\"- The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module."
                },
                {
                    "type": "p",
                    "text": "\"force\"- Ensures that every non-declaration file is treated as a module."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.",
                        "Allowed:legacyautoforce",
                        "legacy",
                        "auto",
                        "force",
                        "Released:4.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."
                },
                {
                    "type": "list",
                    "items": [
                        "legacy",
                        "auto",
                        "force"
                    ]
                },
                {
                    "type": "p",
                    "text": "legacy"
                },
                {
                    "type": "p",
                    "text": "auto"
                },
                {
                    "type": "p",
                    "text": "force"
                },
                {
                    "type": "p",
                    "text": "4.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Lib -noLib"
                },
                {
                    "type": "p",
                    "text": "Disables the automatic inclusion of any library files.\nIf this option is set,libis ignored."
                },
                {
                    "type": "p",
                    "text": "TypeScriptcannotcompile anything without a set of interfaces for key primitives like:Array,Boolean,Function,IArguments,Number,Object,RegExp, andString. It is expected that if you usenoLibyou will be including your own type definitions for these."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:lib",
                        "lib"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "lib"
                    ]
                },
                {
                    "type": "p",
                    "text": "lib"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#React Namespace -reactNamespace"
                },
                {
                    "type": "p",
                    "text": "UsejsxFactoryinstead. Specify the object invoked forcreateElementwhen targetingreactfor TSX files."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:React"
                    ]
                },
                {
                    "type": "p",
                    "text": "React"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Target -target"
                },
                {
                    "type": "p",
                    "text": "Modern browsers support all ES6 features, soES6is a good choice.\nYou might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments."
                },
                {
                    "type": "p",
                    "text": "Thetargetsetting changes which JS features are downleveled and which are left intact.\nFor example, an arrow function() => thiswill be turned into an equivalentfunctionexpression iftargetis ES5 or lower."
                },
                {
                    "type": "p",
                    "text": "Changingtargetalso changes the default value oflib.\nYou may “mix and match”targetandlibsettings as desired, but you could just settargetfor convenience."
                },
                {
                    "type": "p",
                    "text": "For developer platforms like Node there are baselines for thetarget, depending on the type of platform and its version. You can find a set of community organized TSConfigs attsconfig/bases, which has configurations for common platforms and their versions."
                },
                {
                    "type": "p",
                    "text": "The specialESNextvalue refers to the highest version your version of TypeScript supports.\nThis setting should be used with caution, since it doesn’t mean the same thing between different TypeScript versions and can make upgrades less predictable."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:ES5",
                        "Allowed:es3es5es6/es2015es2016es2017es2018es2019es2020es2021es2022es2023esnext",
                        "es3",
                        "es5",
                        "es6/es2015",
                        "es2016",
                        "es2017",
                        "es2018",
                        "es2019",
                        "es2020",
                        "es2021",
                        "es2022",
                        "es2023",
                        "esnext",
                        "Released:1.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "ES5"
                },
                {
                    "type": "list",
                    "items": [
                        "es3",
                        "es5",
                        "es6/es2015",
                        "es2016",
                        "es2017",
                        "es2018",
                        "es2019",
                        "es2020",
                        "es2021",
                        "es2022",
                        "es2023",
                        "esnext"
                    ]
                },
                {
                    "type": "p",
                    "text": "es3"
                },
                {
                    "type": "p",
                    "text": "es5"
                },
                {
                    "type": "p",
                    "text": "es6/es2015"
                },
                {
                    "type": "p",
                    "text": "es2016"
                },
                {
                    "type": "p",
                    "text": "es2017"
                },
                {
                    "type": "p",
                    "text": "es2018"
                },
                {
                    "type": "p",
                    "text": "es2019"
                },
                {
                    "type": "p",
                    "text": "es2020"
                },
                {
                    "type": "p",
                    "text": "es2021"
                },
                {
                    "type": "p",
                    "text": "es2022"
                },
                {
                    "type": "p",
                    "text": "es2023"
                },
                {
                    "type": "p",
                    "text": "esnext"
                },
                {
                    "type": "p",
                    "text": "1.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Use Define For Class Fields -useDefineForClassFields"
                },
                {
                    "type": "p",
                    "text": "This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax."
                },
                {
                    "type": "p",
                    "text": "This flag switches to the upcoming ECMA runtime behavior."
                },
                {
                    "type": "p",
                    "text": "You can read more about the transition inthe 3.7 release notes."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueiftargetisES2022or higher, includingESNext;falseotherwise.",
                        "Released:3.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueiftargetisES2022or higher, includingESNext;falseotherwise."
                },
                {
                    "type": "p",
                    "text": "3.7"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Compiler Diagnostics"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Diagnostics -diagnostics"
                },
                {
                    "type": "p",
                    "text": "Used to output diagnostic information for debugging. This command is a subset ofextendedDiagnosticswhich are more user-facing results, and easier to interpret."
                },
                {
                    "type": "p",
                    "text": "If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in usingextendedDiagnosticsinstead."
                },
                {
                    "type": "list",
                    "items": [
                        "Deprecated",
                        "Related:extendedDiagnostics",
                        "extendedDiagnostics"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "extendedDiagnostics"
                    ]
                },
                {
                    "type": "p",
                    "text": "extendedDiagnostics"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Explain Files -explainFiles"
                },
                {
                    "type": "p",
                    "text": "Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation."
                },
                {
                    "type": "p",
                    "text": "For example, with this project of just a singleindex.tsfile"
                },
                {
                    "type": "code",
                    "code": "shexample├── index.ts├── package.json└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "Using atsconfig.jsonwhich hasexplainFilesset to true:"
                },
                {
                    "type": "code",
                    "code": "json{\"compilerOptions\": {\"target\":\"es5\",\"module\":\"commonjs\",\"explainFiles\":true}}"
                },
                {
                    "type": "p",
                    "text": "Running TypeScript against this folder would have output like this:"
                },
                {
                    "type": "code",
                    "code": "❯ tscnode_modules/typescript/lib/lib.d.tsDefault library for target 'es5'node_modules/typescript/lib/lib.es5.d.tsLibrary referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'node_modules/typescript/lib/lib.dom.d.tsLibrary referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'node_modules/typescript/lib/lib.webworker.importscripts.d.tsLibrary referenced via 'webworker.importscripts' fromfile 'node_modules/typescript/lib/lib.d.ts'node_modules/typescript/lib/lib.scripthost.d.tsLibrary referenced via 'scripthost'from file 'node_modules/typescript/lib/lib.d.ts'index.tsMatched by include pattern '**/*' in 'tsconfig.json'"
                },
                {
                    "type": "p",
                    "text": "The output above show:"
                },
                {
                    "type": "list",
                    "items": [
                        "The initial lib.d.ts lookup based ontarget, and the chain of.d.tsfiles which are referenced",
                        "Theindex.tsfile located via the default pattern ofinclude"
                    ]
                },
                {
                    "type": "p",
                    "text": "This option is intended for debugging how a file has become a part of your compile."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.2"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.2"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Extended Diagnostics -extendedDiagnostics"
                },
                {
                    "type": "p",
                    "text": "You can use this flag to discover where TypeScript is spending its time when compiling.\nThis is a tool used for understanding the performance characteristics of your codebase overall."
                },
                {
                    "type": "p",
                    "text": "You can learn more about how to measure and understand the output in the performancesection of the wiki."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:diagnostics",
                        "diagnostics"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "diagnostics"
                    ]
                },
                {
                    "type": "p",
                    "text": "diagnostics"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Generate CPU Profile -generateCpuProfile"
                },
                {
                    "type": "p",
                    "text": "This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow."
                },
                {
                    "type": "p",
                    "text": "This option can only be used from the CLI via:--generateCpuProfile tsc-output.cpuprofile."
                },
                {
                    "type": "code",
                    "code": "shnpm run tsc --generateCpuProfile tsc-output.cpuprofile"
                },
                {
                    "type": "p",
                    "text": "This file can be opened in a chromium based browser like Chrome or Edge Developer inthe CPU profilersection.\nYou can learn more about understanding the compilers performance in theTypeScript wiki section on performance."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:profile.cpuprofile",
                        "Released:3.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "profile.cpuprofile"
                },
                {
                    "type": "p",
                    "text": "3.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#generateTrace -generateTrace"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#List Emitted Files -listEmittedFiles"
                },
                {
                    "type": "p",
                    "text": "Print names of generated files part of the compilation to the terminal."
                },
                {
                    "type": "p",
                    "text": "This flag is useful in two cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.",
                        "You are not sure that TypeScript has included a file you expected, as a part of debugging thefile inclusion settings."
                    ]
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "code",
                    "code": "example├── index.ts├── package.json└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "With:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"declaration\":true,\"listEmittedFiles\":true}}"
                },
                {
                    "type": "p",
                    "text": "Would echo paths like:"
                },
                {
                    "type": "code",
                    "code": "$ npm run tscpath/to/example/index.jspath/to/example/index.d.ts"
                },
                {
                    "type": "p",
                    "text": "Normally, TypeScript would return silently on success."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#List Files -listFiles"
                },
                {
                    "type": "p",
                    "text": "Print names of files part of the compilation. This is useful when you are not sure that TypeScript has\nincluded a file you expected."
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "code",
                    "code": "example├── index.ts├── package.json└── tsconfig.json"
                },
                {
                    "type": "p",
                    "text": "With:"
                },
                {
                    "type": "code",
                    "code": "{\"compilerOptions\": {\"listFiles\":true}}"
                },
                {
                    "type": "p",
                    "text": "Would echo paths like:"
                },
                {
                    "type": "code",
                    "code": "$ npm run tscpath/to/example/node_modules/typescript/lib/lib.d.tspath/to/example/node_modules/typescript/lib/lib.es5.d.tspath/to/example/node_modules/typescript/lib/lib.dom.d.tspath/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.tspath/to/example/node_modules/typescript/lib/lib.scripthost.d.tspath/to/example/index.ts"
                },
                {
                    "type": "p",
                    "text": "Note if using TypeScript 4.2, preferexplainFileswhich offers an explanation of why a file was added too."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:explainFiles",
                        "explainFiles"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "explainFiles"
                    ]
                },
                {
                    "type": "p",
                    "text": "explainFiles"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#noCheck -noCheck"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Trace Resolution -traceResolution"
                },
                {
                    "type": "p",
                    "text": "When you are trying to debug why a module isn’t being included.\nYou can settraceResolutiontotrueto have TypeScript print information about its resolution process for each processed file."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Projects"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Composite -composite"
                },
                {
                    "type": "p",
                    "text": "Thecompositeoption enforces certain constraints which make it possible for build tools (including TypeScript\nitself, under--buildmode) to quickly determine if a project has been built yet."
                },
                {
                    "type": "p",
                    "text": "When this setting is on:"
                },
                {
                    "type": "list",
                    "items": [
                        "TherootDirsetting, if not explicitly set, defaults to the directory containing thetsconfig.jsonfile.",
                        "All implementation files must be matched by anincludepattern or listed in thefilesarray. If this constraint is violated,tscwill inform you which files weren’t specified.",
                        "declarationdefaults totrue"
                    ]
                },
                {
                    "type": "p",
                    "text": "TherootDirsetting, if not explicitly set, defaults to the directory containing thetsconfig.jsonfile."
                },
                {
                    "type": "p",
                    "text": "All implementation files must be matched by anincludepattern or listed in thefilesarray. If this constraint is violated,tscwill inform you which files weren’t specified."
                },
                {
                    "type": "p",
                    "text": "declarationdefaults totrue"
                },
                {
                    "type": "p",
                    "text": "You can find documentation on TypeScript projects inthe handbook."
                },
                {
                    "type": "list",
                    "items": [
                        "Related:incrementaltsBuildInfoFile",
                        "incremental",
                        "tsBuildInfoFile",
                        "Released:3.0"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "incremental",
                        "tsBuildInfoFile"
                    ]
                },
                {
                    "type": "p",
                    "text": "incremental"
                },
                {
                    "type": "p",
                    "text": "tsBuildInfoFile"
                },
                {
                    "type": "p",
                    "text": "3.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Disable Referenced Project Load -disableReferencedProjectLoad"
                },
                {
                    "type": "p",
                    "text": "In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’."
                },
                {
                    "type": "p",
                    "text": "If your project is large, you can use the flagdisableReferencedProjectLoadto disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.0"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Disable Solution Searching -disableSolutionSearching"
                },
                {
                    "type": "p",
                    "text": "When working withcomposite TypeScript projects, this option provides a way to declare that you do not want a project to be included when using features likefind all referencesorjump to definitionin an editor."
                },
                {
                    "type": "p",
                    "text": "This flag is something you can use to increase responsiveness in large composite projects."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:3.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Disable Source Project Reference Redirect -disableSourceOfProjectReferenceRedirect"
                },
                {
                    "type": "p",
                    "text": "When working withcomposite TypeScript projects, this option provides a way to goback to the pre-3.7behavior where d.ts files were used to as the boundaries between modules.\nIn 3.7 the source of truth is now your TypeScript files."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:3.7"
                    ]
                },
                {
                    "type": "p",
                    "text": "3.7"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Incremental -incremental"
                },
                {
                    "type": "p",
                    "text": "Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This\ncreates a series of.tsbuildinfofiles in the same folder as your compilation output. They are not used by your\nJavaScript at runtime and can be safely deleted. You can read more about the flag in the3.4 release notes."
                },
                {
                    "type": "p",
                    "text": "To control which folders you want to the files to be built to, use the config optiontsBuildInfoFile."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:trueifcomposite;falseotherwise.",
                        "Related:compositetsBuildInfoFile",
                        "composite",
                        "tsBuildInfoFile",
                        "Released:3.4"
                    ]
                },
                {
                    "type": "p",
                    "text": "trueifcomposite;falseotherwise."
                },
                {
                    "type": "list",
                    "items": [
                        "composite",
                        "tsBuildInfoFile"
                    ]
                },
                {
                    "type": "p",
                    "text": "composite"
                },
                {
                    "type": "p",
                    "text": "tsBuildInfoFile"
                },
                {
                    "type": "p",
                    "text": "3.4"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#TS Build Info File -tsBuildInfoFile"
                },
                {
                    "type": "p",
                    "text": "This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster\nbuilding of larger TypeScript codebases. You can read more about composite projectsin the handbook."
                },
                {
                    "type": "p",
                    "text": "The default depends on a combination of other settings:"
                },
                {
                    "type": "list",
                    "items": [
                        "IfoutFileis set, the default is<outFile>.tsbuildinfo.",
                        "IfrootDirandoutDirare set, then the file is<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfoFor example, ifrootDirissrc,outDirisdest, and the config is./tsconfig.json, then the default is./tsconfig.tsbuildinfoas the relative path fromsrc/to./tsconfig.jsonis../.",
                        "IfoutDiris set, then the default is<outDir>/<config name>.tsbuildInfo",
                        "Otherwise, the default is<config name>.tsbuildInfo"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Default:.tsbuildinfo",
                        "Related:incrementalcomposite",
                        "incremental",
                        "composite",
                        "Released:3.4"
                    ]
                },
                {
                    "type": "p",
                    "text": ".tsbuildinfo"
                },
                {
                    "type": "list",
                    "items": [
                        "incremental",
                        "composite"
                    ]
                },
                {
                    "type": "p",
                    "text": "incremental"
                },
                {
                    "type": "p",
                    "text": "composite"
                },
                {
                    "type": "p",
                    "text": "3.4"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Output Formatting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#No Error Truncation -noErrorTruncation"
                },
                {
                    "type": "p",
                    "text": "Do not truncate error messages."
                },
                {
                    "type": "p",
                    "text": "Withfalse, the default."
                },
                {
                    "type": "code",
                    "code": "tsvarx: {propertyWithAnExceedinglyLongName1:string;propertyWithAnExceedinglyLongName2:string;propertyWithAnExceedinglyLongName3:string;propertyWithAnExceedinglyLongName4:string;propertyWithAnExceedinglyLongName5:string;propertyWithAnExceedinglyLongName6:string;propertyWithAnExceedinglyLongName7:string;propertyWithAnExceedinglyLongName8:string;};// String representation of type of 'x' should be truncated in error messagevars:string=x;Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.23222454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propert...' is not assignable to type 'string'.Variable 'x' is used before being assigned.Try"
                },
                {
                    "type": "p",
                    "text": "Withtrue"
                },
                {
                    "type": "code",
                    "code": "tsvarx: {propertyWithAnExceedinglyLongName1:string;propertyWithAnExceedinglyLongName2:string;propertyWithAnExceedinglyLongName3:string;propertyWithAnExceedinglyLongName4:string;propertyWithAnExceedinglyLongName5:string;propertyWithAnExceedinglyLongName6:string;propertyWithAnExceedinglyLongName7:string;propertyWithAnExceedinglyLongName8:string;};// String representation of type of 'x' should be truncated in error messagevars:string=x;Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.23222454Type '{ propertyWithAnExceedinglyLongName1: string; propertyWithAnExceedinglyLongName2: string; propertyWithAnExceedinglyLongName3: string; propertyWithAnExceedinglyLongName4: string; propertyWithAnExceedinglyLongName5: string; propertyWithAnExceedinglyLongName6: string; propertyWithAnExceedinglyLongName7: string; propertyWithAnExceedinglyLongName8: string; }' is not assignable to type 'string'.Variable 'x' is used before being assigned.Try"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Preserve Watch Output -preserveWatchOutput"
                },
                {
                    "type": "p",
                    "text": "Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened."
                },
                {
                    "type": "list",
                    "items": [
                        "Internal"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Pretty -pretty"
                },
                {
                    "type": "p",
                    "text": "Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse,\nsingle colored messages from the compiler."
                },
                {
                    "type": "list",
                    "items": [
                        "Default:true"
                    ]
                },
                {
                    "type": "p",
                    "text": "true"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Completeness"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Skip Default Lib Check -skipDefaultLibCheck"
                },
                {
                    "type": "p",
                    "text": "UseskipLibCheckinstead. Skip type checking of default library declaration files."
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Skip Lib Check -skipLibCheck"
                },
                {
                    "type": "p",
                    "text": "Skip type checking of declaration files."
                },
                {
                    "type": "p",
                    "text": "This can save time during compilation at the expense of type-system accuracy. For example, two libraries could\ndefine two copies of the sametypein an inconsistent way. Rather than doing a full check of alld.tsfiles, TypeScript\nwill type check the code you specifically refer to in your app’s source code."
                },
                {
                    "type": "p",
                    "text": "A common case where you might think to useskipLibCheckis when there are two copies of a library’s types in\nyournode_modules. In these cases, you should consider using a feature likeyarn’s resolutionsto ensure there is only one copy of that dependency in your tree or investigate how to ensure there is\nonly one copy by understanding the dependency resolution to fix the issue without additional tooling."
                },
                {
                    "type": "p",
                    "text": "Another possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update."
                },
                {
                    "type": "p",
                    "text": "Note, that if these issues come from the TypeScript standard library you can replace the library usingTypeScript 4.5’s lib replacementtechnique."
                },
                {
                    "type": "list",
                    "items": [
                        "Recommended",
                        "Released:2.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "2.0"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Command Line"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "#Watch Options"
                },
                {
                    "type": "p",
                    "text": "TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes tonode_modules."
                },
                {
                    "type": "p",
                    "text": "On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) onnode_modulesand many of its subdirectories to detect changes in dependencies.\nThis is because the number of available file watchers is often eclipsed by the number of files innode_modules, whereas there are way fewer directories to track."
                },
                {
                    "type": "p",
                    "text": "Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a newwatchOptionsfield which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Assume Changes Only Affect Direct Dependencies -assumeChangesOnlyAffectDirectDependencies"
                },
                {
                    "type": "p",
                    "text": "When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them."
                },
                {
                    "type": "p",
                    "text": "This can be considered a ‘fast & loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages."
                },
                {
                    "type": "list",
                    "items": [
                        "Released:3.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Watch Options"
                },
                {
                    "type": "p",
                    "text": "You can configure the how TypeScript--watchworks. This section is mainly for handling case wherefs.watchandfs.watchFilehave additional constraints like on Linux. You can read more atConfiguring Watch."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Watch File -watchFile"
                },
                {
                    "type": "p",
                    "text": "The strategy for how individual files are watched."
                },
                {
                    "type": "list",
                    "items": [
                        "fixedPollingInterval: Check every file for changes several times a second at a fixed interval.",
                        "priorityPollingInterval: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.",
                        "dynamicPriorityPolling: Use a dynamic queue where less-frequently modified files will be checked less often.",
                        "useFsEvents(the default): Attempt to use the operating system/file system’s native events for file changes.",
                        "useFsEventsOnParentDirectory: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Allowed:fixedpollingintervalprioritypollingintervaldynamicprioritypollingfixedchunksizepollingusefseventsusefseventsonparentdirectory",
                        "fixedpollinginterval",
                        "prioritypollinginterval",
                        "dynamicprioritypolling",
                        "fixedchunksizepolling",
                        "usefsevents",
                        "usefseventsonparentdirectory",
                        "Released:3.8"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "fixedpollinginterval",
                        "prioritypollinginterval",
                        "dynamicprioritypolling",
                        "fixedchunksizepolling",
                        "usefsevents",
                        "usefseventsonparentdirectory"
                    ]
                },
                {
                    "type": "p",
                    "text": "fixedpollinginterval"
                },
                {
                    "type": "p",
                    "text": "prioritypollinginterval"
                },
                {
                    "type": "p",
                    "text": "dynamicprioritypolling"
                },
                {
                    "type": "p",
                    "text": "fixedchunksizepolling"
                },
                {
                    "type": "p",
                    "text": "usefsevents"
                },
                {
                    "type": "p",
                    "text": "usefseventsonparentdirectory"
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Watch Directory -watchDirectory"
                },
                {
                    "type": "p",
                    "text": "The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality."
                },
                {
                    "type": "list",
                    "items": [
                        "fixedPollingInterval: Check every directory for changes several times a second at a fixed interval.",
                        "dynamicPriorityPolling: Use a dynamic queue where less-frequently modified directories will be checked less often.",
                        "useFsEvents(the default): Attempt to use the operating system/file system’s native events for directory changes."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Allowed:usefseventsfixedpollingintervaldynamicprioritypollingfixedchunksizepolling",
                        "usefsevents",
                        "fixedpollinginterval",
                        "dynamicprioritypolling",
                        "fixedchunksizepolling",
                        "Released:3.8"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "usefsevents",
                        "fixedpollinginterval",
                        "dynamicprioritypolling",
                        "fixedchunksizepolling"
                    ]
                },
                {
                    "type": "p",
                    "text": "usefsevents"
                },
                {
                    "type": "p",
                    "text": "fixedpollinginterval"
                },
                {
                    "type": "p",
                    "text": "dynamicprioritypolling"
                },
                {
                    "type": "p",
                    "text": "fixedchunksizepolling"
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Fallback Polling -fallbackPolling"
                },
                {
                    "type": "p",
                    "text": "When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers."
                },
                {
                    "type": "list",
                    "items": [
                        "fixedPollingInterval: Check every file for changes several times a second at a fixed interval.",
                        "priorityPollingInterval: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.",
                        "dynamicPriorityPolling: Use a dynamic queue where less-frequently modified files will be checked less often.",
                        "synchronousWatchDirectory: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change innode_modulesfrom runningnpm install), but you might want to disable it with this flag for some less-common setups."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Allowed:fixedintervalpriorityintervaldynamicpriorityfixedchunksize",
                        "fixedinterval",
                        "priorityinterval",
                        "dynamicpriority",
                        "fixedchunksize",
                        "Released:3.8"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "fixedinterval",
                        "priorityinterval",
                        "dynamicpriority",
                        "fixedchunksize"
                    ]
                },
                {
                    "type": "p",
                    "text": "fixedinterval"
                },
                {
                    "type": "p",
                    "text": "priorityinterval"
                },
                {
                    "type": "p",
                    "text": "dynamicpriority"
                },
                {
                    "type": "p",
                    "text": "fixedchunksize"
                },
                {
                    "type": "p",
                    "text": "3.8"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Synchronous Watch Directory -synchronousWatchDirectory"
                },
                {
                    "type": "p",
                    "text": "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file."
                },
                {
                    "type": "code",
                    "code": "{\"watchOptions\": {\"synchronousWatchDirectory\":true}}"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Exclude Directories -excludeDirectories"
                },
                {
                    "type": "p",
                    "text": "You can useexcludeFilesto drastically reduce the number of files which are watched during--watch. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux."
                },
                {
                    "type": "code",
                    "code": "{\"watchOptions\": {\"excludeDirectories\": [\"**/node_modules\",\"_build\",\"temp/*\"]}}"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Exclude Files -excludeFiles"
                },
                {
                    "type": "p",
                    "text": "You can useexcludeFilesto remove a set of specific files from the files which are watched."
                },
                {
                    "type": "code",
                    "code": "{\"watchOptions\": {\"excludeFiles\": [\"temp/file.ts\"]}}"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Type Acquisition"
                },
                {
                    "type": "p",
                    "text": "Type Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Enable -enable"
                },
                {
                    "type": "p",
                    "text": "Disables automatic type acquisition in JavaScript projects:"
                },
                {
                    "type": "code",
                    "code": "json{\"typeAcquisition\": {\"enable\":false}}"
                },
                {
                    "type": "list",
                    "items": []
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Include -include"
                },
                {
                    "type": "p",
                    "text": "If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference viadisableFilenameBasedTypeAcquisition."
                },
                {
                    "type": "p",
                    "text": "You can useincludeto specify which types should be used from DefinitelyTyped:"
                },
                {
                    "type": "code",
                    "code": "json{\"typeAcquisition\": {\"include\": [\"jquery\"]}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Exclude -exclude"
                },
                {
                    "type": "p",
                    "text": "Offers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application."
                },
                {
                    "type": "code",
                    "code": "json{\"typeAcquisition\": {\"exclude\": [\"jest\",\"mocha\"]}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "#Disable Filename Based Type Acquisition -disableFilenameBasedTypeAcquisition"
                },
                {
                    "type": "p",
                    "text": "TypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file likejquery.jsin your project would automatically download the types for JQuery from DefinitelyTyped."
                },
                {
                    "type": "p",
                    "text": "You can disable this viadisableFilenameBasedTypeAcquisition."
                },
                {
                    "type": "code",
                    "code": "json{\"typeAcquisition\": {\"disableFilenameBasedTypeAcquisition\":true}}"
                },
                {
                    "type": "list",
                    "items": [
                        "Released:4.1"
                    ]
                },
                {
                    "type": "p",
                    "text": "4.1"
                }
            ]
        },
        {
            "url": "https://www.typescriptlang.org/why-create-typescript",
            "title": "TypeScript: Why does TypeScript exist?",
            "content": [
                {
                    "type": "p",
                    "text": "TypeScript is a language from Microsoft which builds on JavaScript.This post is a non-technical overview of what JavaScript is, how TypeScript extends JavaScript and what problems it solves."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What is JavaScript?"
                },
                {
                    "type": "p",
                    "text": "Because TypeScript extends JavaScript, this makes it a good starting point. JavaScript is commonly used to create websites. When building a website, you work with three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the content which will appear on the page, CSS defines the visual style of the page, and JS defines the interactive behaviors of the page."
                },
                {
                    "type": "p",
                    "text": "We describe having these sets of skills as being a \"front-end\" developer. You use three languages to create pages inside a web browser like Safari, Firefox, Edge or Chrome. Given how popular the web is for commerce and information sharing, there is a massive demand for people who are good at using these three languages."
                },
                {
                    "type": "p",
                    "text": "Related to the role of being a \"front-end\" developer is the set of skills for the \"back-end\" developers, which are to create computer services that communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending data more directly.) You don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work because it is likely to be presented in a web browser."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What do Programming Languages do?"
                },
                {
                    "type": "p",
                    "text": "Programming languages are a way for humans and computers to communicate. People read code many, many multiples of times more than they write it - so developers create programming languages which are good at solving particular problems with a small amount of code. Here's an example using JavaScript:"
                },
                {
                    "type": "code",
                    "code": "var name = \"Danger\"\nconsole.log(\"Hello, \" + name)"
                },
                {
                    "type": "p",
                    "text": "The first line makes a variable (effectively a box you can store other things in) and then the second line outputs text to the console (for example DOS, or the terminal)\"Hello, Danger\"."
                },
                {
                    "type": "p",
                    "text": "JavaScript is designed to work as a scripting language, which means the code starts at the top of the file and then goes through line by line downwards running that code. To provide some contrast, here is the same behavior in Java, which is built with different language constraints:"
                },
                {
                    "type": "code",
                    "code": "class Main {\n  public static void main(String[] args) {\n    String name = \"Danger\";\n    System.out.println(\"Hello, \" + name);\n  }\n}"
                },
                {
                    "type": "p",
                    "text": "These two code samples do the same thing, however the Java version comes with a lot of words that aren't necessarily about telling the computer exactly what to do, e.g.class Main {,public static void main(String[] args) {, and two extra}s. It also has semi-colons at the end of some lines. Neither of these programming languages are wrong, Java however, is aimed at building different things from JavaScript, and these extra bits of code make sense within the constraints of building a Java app."
                },
                {
                    "type": "p",
                    "text": "To get to the key point though, there is one standout line I'd like us to compare:"
                },
                {
                    "type": "code",
                    "code": "// JavaScript\nvar name = \"Danger\"\n\n// Java\nString name = \"Danger\";"
                },
                {
                    "type": "p",
                    "text": "Both of these lines declare variables callednamewhich contain the value\"Danger\"."
                },
                {
                    "type": "p",
                    "text": "In JavaScript you use the abbreviationvarto declare a variable. Meanwhile, in Java you need to saywhat kind of datathe variable contains. In this case the variable contains aString. (A string is a programming term for a collection of characters. They\"look like this\". This5m videois a good primer if you want to learn more.)"
                },
                {
                    "type": "p",
                    "text": "Both of these variables contain a string, but the difference is that in Java the variable canonlyever contain astring, because that's what we said when we created the variable. In JS, the variable can change to beanything, like a number, or a list of dates."
                },
                {
                    "type": "p",
                    "text": "To illustrate:"
                },
                {
                    "type": "code",
                    "code": "// Before in JS\nvar name = \"Danger\"\n// Also OK\nvar name = 1\nvar name = false\nvar name = [\"2018-02-03\", \"2019-01-12\"]\n\n// Before in Java\nString name = \"Danger\";\n// Not OK, the code wouldn't be accepted by Java\nString name = 1;\nString name = false\nString name = new String[]{\"2018-02-03\", \"2019-01-12\"};"
                },
                {
                    "type": "p",
                    "text": "These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was originally designed to be a small programming language which handled simple interactions on websites. Java on the other hand was built specifically to make complex apps which could run on any computer. They expected to be used to build codebases of different scales, so the language required programmers write different types of code."
                },
                {
                    "type": "p",
                    "text": "Java required programmers to be more explicit with the values of their variables because the programs they expected people to build were more complex. While JavaScript opted for ease of reading by omitting information about the specifics, and expected codebases to be significantly smaller."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What is TypeScript?"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above, let's compare the scripts for \"Hello, Danger\" in JavaScript vs TypeScript:"
                },
                {
                    "type": "code",
                    "code": "// JavaScript\nvar name = \"Danger\"\nconsole.log(\"Hello, \" + name)\n\n// TypeScript\nvar name = \"Danger\"\nconsole.log(\"Hello, \" + name)\n\n// Yep, you're not missing something, there's no difference"
                },
                {
                    "type": "p",
                    "text": "Due to TypeScript's goal of onlyextendingJavaScript, the existing JavaScript code we saw works as TypeScript. The extensions which TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are used in your code, a bit like Java."
                },
                {
                    "type": "p",
                    "text": "Here is the same sample, but using TypeScript to be more explicit about what the variable is:"
                },
                {
                    "type": "code",
                    "code": "var name: string = \"Danger\"\nconsole.log(\"Hello, \" + name)"
                },
                {
                    "type": "p",
                    "text": "This extra: stringallow the reader to be certain thatnamewill only be a string. Annotating your variables in this way also gives TypeScript the chance to verify that these match. This isveryuseful, because keeping track of changes like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds, that's a lot to keep track of. Writing types help programmers be more confident about their code because types catch mistakes."
                },
                {
                    "type": "p",
                    "text": "Simply speaking, we call these annotations \"Types\". Hence the nameTypeScript. One of the tag-lines for TypeScript is \"JavaScript which scales\" which is a statement that these extra type annotations allows you to work on bigger projects. This is because you can verify up-front how correct your code is. This means you have less need to understand how every change affects the rest of the program."
                },
                {
                    "type": "p",
                    "text": "In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was fine because the size and complexities of the programs being built were constrained to just the front-end of websites. Today though, JavaScript is being used almost everywhere, to build almost anything which runs on a computer. A large amount of mobile and desktop apps use JavaScript and web technology under the hood."
                },
                {
                    "type": "p",
                    "text": "These are all considerably more complicated to build and understand, adding types drastically reduces the complexity of making improvements to those programs."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What Problems Can TypeScript Solve?"
                },
                {
                    "type": "p",
                    "text": "Typically, the need to ensure there are no bugs in your code can be handled by writing automated tests, then by manually verifying that the code works as you expect and finally having another person validate that it seems correct."
                },
                {
                    "type": "p",
                    "text": "Not many companies are the size of Microsoft, however a lot of all problems writing JavaScript in large codebases are the same. Many JavaScript apps are made up of hundreds of thousands of files. A single change to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond and causing ripples to spread out to the bank."
                },
                {
                    "type": "p",
                    "text": "Validating the connections between every part of your project can get time consuming quickly, using a type-checked language like TypeScript can handle that automatically and provide instant feedback during development."
                },
                {
                    "type": "p",
                    "text": "These features allows TypeScript to help developers feel more confident in their code, and save considerable amounts time in validating that they have not accidentally broken the project."
                }
            ]
        }
    ]
}