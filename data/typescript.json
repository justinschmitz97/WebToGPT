[{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html", "title": "Documentation - TypeScript 5.0", "text": "Decorators Decorators upcoming ECMAScript feature allow us customize classes members reusable way. Let\u2019s consider following code: ts class Person {name: string;constructor(name: string) {this.name = name;}greet() {console.log(`Hello, name ${this.name}.`);}}const p = new Person(\"Ray\");p.greet(); greet pretty simple here, let\u2019s imagine it\u2019s something way complicated - maybe async logic, it\u2019s recursive, side effects, etc. Regardless kind ball-of-mud you\u2019re imagining, let\u2019s say throw console.log calls help debug greet . ts class Person {name: string;constructor(name: string) {this.name = name;}greet() {console.log(\"LOG: Entering method.\");console.log(`Hello, name ${this.name}.`);console.log(\"LOG: Exiting method.\")}} pattern fairly common. sure would nice way could every method! decorators come in. write function called loggedMethod looks like following: ts function loggedMethod(originalMethod: any, _context: any) {function replacementMethod(this: any, ...args: any[]) {console.log(\"LOG: Entering method.\")const result = originalMethod.call(this, ...args);console.log(\"LOG: Exiting method.\")return result;}return replacementMethod;} \u201cWhat\u2019s deal s? this, Script!?\u201d patient - we\u2019re keeping things simple focus function doing. Notice loggedMethod takes original method (originalMethod ) returns function - logs \u201cEntering\u2026\u201d message - passes along arguments original method - logs \u201cExiting\u2026\u201d message, - returns whatever original method returned. use loggedMethod decorate method greet : ts class Person {name: string;constructor(name: string) {this.name = name;}@loggedMethodgreet() {console.log(`Hello, name ${this.name}.`);}}const p = new Person(\"Ray\");p.greet();// Output://// LOG: Entering method.// Hello, name Ray.// LOG: Exiting method. used loggedMethod decorator greet - notice wrote @loggedMethod . that, got called method target context object. loggedMethod returned new function, function replaced original definition greet . didn\u2019t mention yet, loggedMethod defined second parameter. It\u2019s called \u201ccontext object\u201d, useful information decorated method declared - like whether #private member, static , name method was. Let\u2019s rewrite loggedMethod take advantage print name method decorated. ts function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = String(context.name);function replacementMethod(this: any, ...args: any[]) {console.log(`LOG: Entering method '${methodName}'.`)const result = originalMethod.call(this, ...args);console.log(`LOG: Exiting method '${methodName}'.`)return result;}return replacementMethod;} We\u2019re using context parameter - it\u2019s first thing loggedMethod type stricter any[] . TypeScript provides type called ClassMethodDecoratorContext models context object method decorators take. Apart metadata, context object methods also useful function called addInitializer . It\u2019s way hook beginning constructor (or initialization class we\u2019re working static s). example - JavaScript, it\u2019s common write something like following pattern: ts class Person {name: string;constructor(name: string) {this.name = name;this.greet = this.greet.bind(this);}greet() {console.log(`Hello, name ${this.name}.`);}} Alternatively, greet might declared property initialized arrow function. ts class Person {name: string;constructor(name: string) {this.name = name;}greet = () => {console.log(`Hello, name ${this.name}.`);};} code written ensure isn\u2019t re-bound greet called stand-alone function passed callback. ts const greet = new Person(\"Ray\").greet;// want fail!greet(); write decorator uses addInitializer call bind constructor us. ts function bound(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = context.name;if (context.private) {throw new Error(`'bound' cannot decorate private properties like ${methodName string}.`);}context.addInitializer(function () {this[methodName] = this[methodName].bind(this);});} bound isn\u2019t returning anything - decorates method, leaves original alone. Instead, add logic fields initialized. ts class Person {name: string;constructor(name: string) {this.name = name;}@bound@loggedMethodgreet() {console.log(`Hello, name ${this.name}.`);}}const p = new Person(\"Ray\");const greet = p.greet;// Works!greet(); Notice stacked two decorators - @bound @loggedMethod . decorations run \u201creverse order\u201d. is, @loggedMethod decorates original method greet , @bound decorates result @loggedMethod . example, doesn\u2019t matter - could decorators side-effects expect certain order. Also worth noting - you\u2019d prefer stylistically, put decorators line. ts @bound @loggedMethod greet() {console.log(`Hello, name ${this.name}.`);} Something might obvious even make functions return decorator functions. makes possible customize final decorator little. wanted, could made loggedMethod return decorator customize logs messages. ts function loggedMethod(headMessage = \"LOG:\") {return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {const methodName = String(context.name);function replacementMethod(this: any, ...args: any[]) {console.log(`${headMessage} Entering method '${methodName}'.`)const result = originalMethod.call(this, ...args);console.log(`${headMessage} Exiting method '${methodName}'.`)return result;}return replacementMethod;}} that, we\u2019d call loggedMethod using decorator. could pass string prefix messages get logged console. ts class Person {name: string;constructor(name: string) {this.name = name;}@loggedMethod(\"\u26a0\ufe0f\")greet() {console.log(`Hello, name ${this.name}.`);}}const p = new Person(\"Ray\");p.greet();// Output://// \u26a0\ufe0f Entering method 'greet'.// Hello, name Ray.// \u26a0\ufe0f Exiting method 'greet'. Decorators used methods! used properties/fields, getters, setters, auto-accessors. Even classes decorated things like subclassing registration. learn decorators in-depth, read Axel Rauschmayer\u2019s extensive summary. information changes involved, view original pull request. Differences Experimental Legacy Decorators you\u2019ve using TypeScript while, might aware fact it\u2019s support \u201cexperimental\u201d decorators years. experimental decorators incredibly useful, modeled much older version decorators proposal, always required opt-in compiler flag called --experimentalDecorators . attempt use decorators TypeScript without flag used prompt error message. --experimentalDecorators continue exist foreseeable future; however, without flag, decorators valid syntax new code. Outside --experimentalDecorators , type-checked emitted differently. type-checking rules emit sufficiently different decorators written support old new decorators behavior, existing decorator functions likely so. new decorators proposal compatible --emitDecoratorMetadata , allow decorating parameters. Future ECMAScript proposals may able help bridge gap. final note: addition allowing decorators placed export keyword, proposal decorators provides option placing decorators export export default . exception mixing two styles allowed. js // \u2705 allowed@register export default class Foo {// ...}// \u2705 also allowedexport default @register class Bar {// ...}// \u274c error - *and* allowed@before export @after class Bar {// ...} Writing Well-Typed Decorators loggedMethod bound decorator examples intentionally simple omit lots details types. Typing decorators fairly complex. example, well-typed version loggedMethod might look something like this: ts function loggedMethod<This, Args extends any[], Return>(target: (this: This, ...args: Args) => Return,context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>) {const methodName = String(context.name);function replacementMethod(this: This, ...args: Args): Return {console.log(`LOG: Entering method '${methodName}'.`)const result = target.call(this, ...args);console.log(`LOG: Exiting method '${methodName}'.`)return result;}return replacementMethod;} separately model type , parameters, return type original method, using type parameters , Args , Return . Exactly complex decorators functions defined depends want guarantee. keep mind, decorators used they\u2019re written, well-typed version usually preferable - there\u2019s clearly trade-off readability, try keep things simple. documentation writing decorators available future - post good amount detail mechanics decorators. const Type Parameters inferring type object, TypeScript usually choose type that\u2019s meant general. example, case, inferred type names string[] : ts type HasNames = { names: readonly string[] };function getNamesExactly<T extends HasNames>(arg: T): T[\"names\"] {return arg.names;}// Inferred type: string[]const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]}); Usually intent enable mutation line. However, depending exactly getNamesExactly it\u2019s intended used, often case more-specific type desired. now, API authors typically recommend adding const certain places achieve desired inference: ts // type wanted:// readonly [\"Alice\", \"Bob\", \"Eve\"]// type got:// string[]const names1 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});// Correctly gets wanted:// readonly [\"Alice\", \"Bob\", \"Eve\"]const names2 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]} const); cumbersome easy forget. TypeScript 5.0, add const modifier type parameter declaration cause const -like inference default: ts type HasNames = { names: readonly string[] };function getNamesExactly<const extends HasNames>(arg: T): T[\"names\"] {// ^^^^^return arg.names;}// Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"]// Note: need write 'as const' hereconst names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"] }); Note const modifier doesn\u2019t reject mutable values, doesn\u2019t require immutable constraints. Using mutable type constraint might give surprising results. example: ts declare function fnBad<const extends string[]>(args: T): void;// 'T' still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' assignable 'string[]'fnBad([\"a\", \"b\" ,\"c\"]); Here, inferred candidate readonly [\"a\", \"b\", \"c\"] , readonly array can\u2019t used mutable one needed. case, inference falls back constraint, array treated string[] , call still proceeds successfully. better definition function use readonly string[] : ts declare function fnGood<const extends readonly string[]>(args: T): void;// readonly [\"a\", \"b\", \"c\"]fnGood([\"a\", \"b\" ,\"c\"]); Similarly, remember keep mind const modifier affects inference object, array primitive expressions written within call, arguments wouldn\u2019t (or couldn\u2019t) modified const won\u2019t see change behavior: ts declare function fnGood<const extends readonly string[]>(args: T): void;const arr = [\"a\", \"b\" ,\"c\"];// 'T' still 'string[]'-- 'const' modifier effect herefnGood(arr); See pull request (first second second) motivating issues details. Supporting Multiple Configuration Files extends managing multiple projects, helpful \u201cbase\u201d configuration file tsconfig.json files extend from. That\u2019s TypeScript supports extends field copying fields compilerOptions . jsonc // packages/front-end/src/tsconfig.json{\"extends\": \"../../../tsconfig.base.json\",\"compilerOptions\": {\"outDir\": \"../lib\",// ...}} However, scenarios might want extend multiple configuration files. example, imagine using TypeScript base configuration file shipped npm. want projects also use options @tsconfig/strictest package npm, there\u2019s simple solution: tsconfig.base.json extend @tsconfig/strictest : jsonc // tsconfig.base.json{\"extends\": \"@tsconfig/strictest/tsconfig.json\",\"compilerOptions\": {// ...}} works point. projects don\u2019t want use @tsconfig/strictest , either manually disable options, create separate version tsconfig.base.json doesn\u2019t extend @tsconfig/strictest . give flexibility here, Typescript 5.0 allows extends field take multiple entries. example, configuration file: jsonc {\"extends\": [\"a\", \"b\", \"c\"],\"compilerOptions\": {// ...}} Writing kind like extending c directly, c extends b , b extends . fields \u201cconflict\u201d, latter entry wins. following example, strictNullChecks noImplicitAny enabled final tsconfig.json . jsonc // tsconfig1.json{\"compilerOptions\": {\"strictNullChecks\": true}}// tsconfig2.json{\"compilerOptions\": {\"noImplicitAny\": true}}// tsconfig.json{\"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"],\"files\": [\"./index.ts\"]} another example, rewrite original example following way. jsonc // packages/front-end/src/tsconfig.json{\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"../../../tsconfig.base.json\"],\"compilerOptions\": {\"outDir\": \"../lib\",// ...}} details, read original pull request. enum Union enum TypeScript originally introduced enums, nothing set numeric constants type. ts enum E {Foo = 10,Bar = 20,} thing special E.Foo E.Bar assignable anything expecting type E . that, pretty much number s. ts function takeValue(e: E) {}takeValue(E.Foo); // workstakeValue(123); // error! wasn\u2019t TypeScript 2.0 introduced enum literal types enums got bit special. Enum literal types gave enum member type, turned enum union member type. also allowed us refer subset types enum, narrow away types. ts // Color like union Red | Orange | Yellow | Green | Blue | Violetenum Color {Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet}// enum member type refer to!type PrimaryColor = Color.Red | Color.Green | Color.Blue;function isPrimaryColor(c: Color): c PrimaryColor {// Narrowing literal types catch bugs.// TypeScript error because// we'll end comparing 'Color.Red' 'Color.Green'.// meant use ||, accidentally wrote &&.return c === Color.Red && c === Color.Green && c === Color.Blue;} One issue giving enum member type types part associated actual value member. cases it\u2019s possible compute value - instance, enum member could initialized function call. ts enum E {Blah = Math.random()} Whenever TypeScript ran issues, would quietly back use old enum strategy. meant giving advantages unions literal types. TypeScript 5.0 manages make enums union enums creating unique type computed member. means enums narrowed members referenced types well. details change, read specifics GitHub. --moduleResolution bundler TypeScript 4.7 introduced node16 nodenext options --module --moduleResolution settings. intent options better model precise lookup rules ECMAScript modules Node.js; however, mode many restrictions tools don\u2019t really enforce. example, ECMAScript module Node.js, relative import needs include file extension. js // entry.mjsimport * utils \"./utils\"; // \u274c wrong - need include file extension.import * utils \"./utils.mjs\"; // \u2705 works certain reasons Node.js browser - makes file lookups faster works better naive file servers. many developers using tools like bundlers, node16 /nodenext settings cumbersome bundlers don\u2019t restrictions. ways, node resolution mode better anyone using bundler. ways, original node resolution mode already date. modern bundlers use fusion ECMAScript module CommonJS lookup rules Node.js. example, extensionless imports work fine like CommonJS, looking export conditions package, they\u2019ll prefer import condition like ECMAScript file. model bundlers work, TypeScript introduces new strategy: --moduleResolution bundler . jsonc {\"compilerOptions\": {\"target\": \"esnext\",\"moduleResolution\": \"bundler\"}} using modern bundler like Vite, esbuild, swc, Webpack, Parcel, others implement hybrid lookup strategy, new bundler option good fit you. hand, you\u2019re writing library that\u2019s meant published npm, using bundler option hide compatibility issues may arise users aren\u2019t using bundler. cases, using node16 nodenext resolution options likely better path. read --moduleResolution bundler , take look implementing pull request. Resolution Customization Flags JavaScript tooling may model \u201chybrid\u201d resolution rules, like bundler mode described above. tools may differ support slightly, TypeScript 5.0 provides ways enable disable features may may work configuration. allowImportingTsExtensions --allowImportingTsExtensions allows TypeScript files import TypeScript-specific extension like .ts , .mts , .tsx . flag allowed --noEmit --emitDeclarationOnly enabled, since import paths would resolvable runtime JavaScript output files. expectation resolver (e.g. bundler, runtime, tool) going make imports .ts files work. resolvePackageJsonExports --resolvePackageJsonExports forces TypeScript consult exports field package.json files ever reads package node_modules . option defaults true node16 , nodenext , bundler options --moduleResolution . resolvePackageJsonImports --resolvePackageJsonImports forces TypeScript consult imports field package.json files performing lookup starts # file whose ancestor directory contains package.json . option defaults true node16 , nodenext , bundler options --moduleResolution . allowArbitraryExtensions TypeScript 5.0, import path ends extension isn\u2019t known JavaScript TypeScript file extension, compiler look declaration file path form {file basename}.d.{extension}.ts . example, using CSS loader bundler project, might want write (or generate) declaration files stylesheets: css /* app.css */.cookie-banner {display: none;} ts // app.d.css.tsdeclare const css: {cookieBanner: string;};export default css; ts // App.tsximport styles \"./app.css\";styles.cookieBanner; // string default, import raise error let know TypeScript doesn\u2019t understand file type runtime might support importing it. you\u2019ve configured runtime bundler handle it, suppress error new --allowArbitraryExtensions compiler option. Note historically, similar effect often achievable adding declaration file named app.css.d.ts instead app.d.css.ts - however, worked Node\u2019s require resolution rules CommonJS. Strictly speaking, former interpreted declaration file JavaScript file named app.css.js . relative files imports need include extensions Node\u2019s ESM support, TypeScript would error example ESM file --moduleResolution node16 nodenext . information, read proposal feature corresponding pull request. customConditions --customConditions takes list additional conditions succeed TypeScript resolves exports imports field package.json . conditions added whatever existing conditions resolver use default. example, field set tsconfig.json so: jsonc {\"compilerOptions\": {\"target\": \"es2022\",\"moduleResolution\": \"bundler\",\"customConditions\": [\"my-condition\"]}} time exports imports field referenced package.json , TypeScript consider conditions called my-condition . importing package following package.json jsonc {// ...\"exports\": {\".\": {\"my-condition\": \"./foo.mjs\",\"node\": \"./bar.mjs\",\"import\": \"./baz.mjs\",\"require\": \"./biz.mjs\"}}} TypeScript try look files corresponding foo.mjs . field valid node16 , nodenext , bundler options --moduleResolution --verbatimModuleSyntax default, TypeScript something called import elision. Basically, write something like ts import { Car } \"./car\";export function drive(car: Car) {// ...} TypeScript detects you\u2019re using import types drops import entirely. output JavaScript might look something like this: js export function drive(car) {// ...} time good, Car isn\u2019t value that\u2019s exported ./car , we\u2019ll get runtime error. add layer complexity certain edge cases. example, notice there\u2019s statement like import \"./car\"; - import dropped entirely. actually makes difference modules side-effects not. TypeScript\u2019s emit strategy JavaScript also another layers complexity - import elision isn\u2019t always driven import used - often consults value declared well. it\u2019s always clear whether code like following ts export { Car } \"./car\"; preserved dropped. Car declared something like class , preserved resulting JavaScript file. Car declared type alias interface , JavaScript file shouldn\u2019t export Car all. TypeScript might able make emit decisions based information across files, every compiler can. type modifier imports exports helps situations bit. make explicit whether import export used type analysis, dropped entirely JavaScript files using type modifier. ts // statement dropped entirely JS outputimport type * car \"./car\";// named import/export 'Car' dropped JS outputimport { type Car } \"./car\";export { type Car } \"./car\"; type modifiers quite useful - default, module elision still drop imports, nothing forces make distinction type plain imports exports. TypeScript flag --importsNotUsedAsValues make sure use type modifier, --preserveValueImports prevent module elision behavior, --isolatedModules make sure TypeScript code works across different compilers. Unfortunately, understanding fine details 3 flags hard, still edge cases unexpected behavior. TypeScript 5.0 introduces new option called --verbatimModuleSyntax simplify situation. rules much simpler - imports exports without type modifier left around. Anything uses type modifier dropped entirely. ts // Erased away entirely.import type { } \"a\";// Rewritten 'import { b } \"bcd\";'import { b, type c, type } \"bcd\";// Rewritten 'import {} \"xyz\";'import { type xyz } \"xyz\"; new option, see get. implications comes module interop though. flag, ECMAScript import export won\u2019t rewritten require calls settings file extension implied different module system. Instead, you\u2019ll get error. need emit code uses require module.exports , you\u2019ll use TypeScript\u2019s module syntax predates ES2015: | Input TypeScript | Output JavaScript | |---|---| | | | | limitation, help make issues obvious. example, it\u2019s common forget set type field package.json --module node16 . result, developers would start writing CommonJS modules instead ES modules without realizing it, giving surprising lookup rules JavaScript output. new flag ensures you\u2019re intentional file type you\u2019re using syntax intentionally different. --verbatimModuleSyntax provides consistent story --importsNotUsedAsValues --preserveValueImports , two existing flags deprecated favor. details, read [the original pull request]https://github.com/microsoft/TypeScript/pull/52203 proposal issue. Support export type * TypeScript 3.8 introduced type-only imports, new syntax wasn\u2019t allowed export * \"module\" export * ns \"module\" re-exports. TypeScript 5.0 adds support forms: ts // models/vehicles.tsexport class Spaceship {// ...}// models/index.tsexport type * vehicles \"./vehicles\";// main.tsimport { vehicles } \"./models\";function takeASpaceship(s: vehicles.Spaceship) {// \u2705 ok - `vehicles` used type position}function makeASpaceship() {return new vehicles.Spaceship();// ^^^^^^^^// 'vehicles' cannot used value exported using 'export type'.} read implementation here. @satisfies Support JSDoc TypeScript 4.9 introduced satisfies operator. made sure type expression compatible, without affecting type itself. example, let\u2019s take following code: ts interface CompilerOptions {strict?: boolean;outDir?: string;// ...}interface ConfigSettings {compilerOptions?: CompilerOptions;extends?: string | string[];// ...}let myConfigSettings = {compilerOptions: {strict: true,outDir: \"../lib\",// ...},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],} satisfies ConfigSettings; Here, TypeScript knows myConfigSettings.extends declared array - satisfies validated type object, didn\u2019t bluntly change CompilerOptions lose information. want map extends , that\u2019s fine. ts declare function resolveConfig(configPath: string): CompilerOptions;let inheritedConfigs = myConfigSettings.extends.map(resolveConfig); helpful TypeScript users, plenty people use TypeScript type-check JavaScript code using JSDoc annotations. That\u2019s TypeScript 5.0 supporting new JSDoc tag called @satisfies exactly thing. /** @satisfies */ catch type mismatches: js // @ts-check/*** @typedef CompilerOptions* @prop {boolean} [strict]* @prop {string} [outDir]*//*** @satisfies {CompilerOptions}*/let myCompilerOptions = {outdir: \"../lib\",// ~~~~~~ oops! meant outDir}; preserve original type expressions, allowing us use values precisely later code. js // @ts-check/*** @typedef CompilerOptions* @prop {boolean} [strict]* @prop {string} [outDir]*//*** @typedef ConfigSettings* @prop {CompilerOptions} [compilerOptions]* @prop {string | string[]} [extends]*//*** @satisfies {ConfigSettings}*/let myConfigSettings = {compilerOptions: {strict: true,outDir: \"../lib\",},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],};let inheritedConfigs = myConfigSettings.extends.map(resolveConfig); /** @satisfies */ also used inline parenthesized expression. could written myCompilerOptions like this: ts let myConfigSettings = /** @satisfies {ConfigSettings} */ ({compilerOptions: {strict: true,outDir: \"../lib\",},extends: [\"@tsconfig/strictest/tsconfig.json\",\"../../../tsconfig.base.json\"],}); Why? Well, usually makes sense you\u2019re deeper code, like function call. js compileCode(/** @satisfies {CompilerOptions} */ ({// ...})); feature provided thanks Oleksandr Tarasiuk! @overload Support JSDoc TypeScript, specify overloads function. Overloads give us way say function called different arguments, possibly return different results. restrict callers actually use functions, refine results they\u2019ll get back. ts // overloads:function printValue(str: string): void;function printValue(num: number, maxFractionDigits?: number): void;// implementation:function printValue(value: string | number, maximumFractionDigits?: number) {if (typeof value === \"number\") {const formatter = Intl.NumberFormat(\"en-US\", {maximumFractionDigits,});value = formatter.format(value);}console.log(value);} Here, we\u2019ve said printValue takes either string number first argument. takes number , take second argument determine many fractional digits print. TypeScript 5.0 allows JSDoc declare overloads new @overload tag. JSDoc comment @overload tag treated distinct overload following function declaration. js // @ts-check/*** @overload* @param {string} value* @return {void}*//*** @overload* @param {number} value* @param {number} [maximumFractionDigits]* @return {void}*//*** @param {string | number} value* @param {number} [maximumFractionDigits]*/function printValue(value, maximumFractionDigits) {if (typeof value === \"number\") {const formatter = Intl.NumberFormat(\"en-US\", {maximumFractionDigits,});value = formatter.format(value);}console.log(value);} regardless whether we\u2019re writing TypeScript JavaScript file, TypeScript let us know we\u2019ve called functions incorrectly. ts // allowedprintValue(\"hello!\");printValue(123.45);printValue(123.45, 2);printValue(\"hello!\", 123); // error! new tag implemented thanks Tomasz Lenarcik. Passing Emit-Specific Flags --build TypeScript allows following flags passed --build mode --declaration --emitDeclarationOnly --declarationMap --sourceMap --inlineSourceMap makes way easier customize certain parts build might different development production builds. example, development build library might need produce declaration files, production build would. project configure declaration emit default simply built sh tsc --build -p ./my-project-dir you\u2019re done iterating inner loop, \u201cproduction\u201d build pass --declaration flag. sh tsc --build -p ./my-project-dir --declaration information change available here. Case-Insensitive Import Sorting Editors editors like Visual Studio VS Code, TypeScript powers experience organizing sorting imports exports. Often though, different interpretations list \u201csorted\u201d. example, following import list sorted? ts import {Toggle,freeze,toBoolean,} \"./utils\"; answer might surprisingly \u201cit depends\u201d. don\u2019t care case-sensitivity, list clearly sorted. letter f comes . programming languages, sorting defaults comparing byte values strings. way JavaScript compares strings means \"Toggle\" always comes \"freeze\" according ASCII character encoding, uppercase letters come lowercase. perspective, import list sorted. TypeScript previously considered import list sorted basic case-sensitive sort. could point frustration developers preferred case-insensitive ordering, used tools like ESLint require case-insensitive ordering default. TypeScript detects case sensitivity default. means TypeScript tools like ESLint typically won\u2019t \u201cfight\u201d best sort imports. team also experimenting sorting strategies read here. options may eventually configurable editors. now, still unstable experimental, opt VS Code today using typescript.unstable entry JSON options. options try (set defaults): jsonc {\"typescript.unstable\": {// sorting case-sensitive? be:// - true// - false// - \"auto\" (auto-detect)\"organizeImportsIgnoreCase\": \"auto\",// sorting \"ordinal\" use code points consider Unicode rules? be:// - \"ordinal\"// - \"unicode\"\"organizeImportsCollation\": \"ordinal\",// `\"organizeImportsCollation\": \"unicode\"`,// current locale? be:// - [any locale code]// - \"auto\" (use editor's locale)\"organizeImportsLocale\": \"en\",// `\"organizeImportsCollation\": \"unicode\"`,// upper-case letters lower-case letters come first? be:// - false (locale-specific)// - \"upper\"// - \"lower\"\"organizeImportsCaseFirst\": false,// `\"organizeImportsCollation\": \"unicode\"`,// runs numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? be:// - true// - false\"organizeImportsNumericCollation\": true,// `\"organizeImportsCollation\": \"unicode\"`,// letters accent marks/diacritics get sorted distinctly// \"base\" letter (i.e. \u00e9 different e)? be// - true// - false\"organizeImportsAccentCollation\": true},\"javascript.unstable\": {// options valid here...},} read details original work auto-detecting specifying case-insensitivity, followed broader set options. Exhaustive switch /case Completions writing switch statement, TypeScript detects value checked literal type. so, offer completion scaffolds uncovered case . see specifics implementation GitHub. Speed, Memory, Package Size Optimizations TypeScript 5.0 contains lots powerful changes across code structure, data structures, algorithmic implementations. mean entire experience faster - running TypeScript, even installing it. interesting wins speed size we\u2019ve able capture relative TypeScript 4.9. | Scenario | Time Size Relative TS 4.9 | |---|---| | material-ui build time | 89% | | TypeScript Compiler startup time | 89% | | Playwright build time | 88% | | TypeScript Compiler self-build time | 87% | | Outlook Web build time | 82% | | VS Code build time | 80% | | typescript npm Package Size | 59% | How? notable improvements we\u2019d like give details future. won\u2019t make wait blog post. First off, recently migrated TypeScript namespaces modules, allowing us leverage modern build tooling perform optimizations like scope hoisting. Using tooling, revisiting packaging strategy, removing deprecated code shaved 26.4 MB TypeScript 4.9\u2019s 63.8 MB package size. also brought us notable speed-up direct function calls. TypeScript also added uniformity internal object types within compiler, also slimmed data stored object types well. reduced polymorphic megamorphic use sites, offsetting necessary memory consumption necessary uniform shapes. We\u2019ve also performed caching serializing information strings. Type display, happen part error reporting, declaration emit, code completions, more, end fairly expensive. TypeScript caches commonly used machinery reuse across operations. Another notable change made improved parser leveraging var occasionally side-step cost using let const across closures. improved parsing performance. Overall, expect codebases see speed improvements TypeScript 5.0, consistently able reproduce wins 10% 20%. course depend hardware codebase characteristics, encourage try codebase today! information, see notable optimizations: - Migrate Modules Node MonomorphizationSymbol MonomorphizationIdentifier Size ReductionPrinter Caching- Limited Usage var Breaking Changes Deprecations Runtime Requirements TypeScript targets ECMAScript 2018. Node users, means minimum version requirement least Node.js 10 later. lib.d.ts Changes Changes types DOM generated might impact existing code. Notably, certain properties converted number numeric literal types, properties methods cut, copy, paste event handling moved across interfaces. API Breaking Changes TypeScript 5.0, moved modules, removed unnecessary interfaces, made correctness improvements. details what\u2019s changed, see API Breaking Changes page. Forbidden Implicit Coercions Relational Operators Certain operations TypeScript already warn write code may cause implicit string-to-number coercion: ts function func(ns: number | string) {return ns * 4; // Error, possible implicit coercion} 5.0, also applied relational operators > , < , <= , >= : ts function func(ns: number | string) {return ns > 4; // also error} allow desired, explicitly coerce operand number using + : ts function func(ns: number | string) {return +ns > 4; // OK} correctness improvement contributed courtesy Mateusz Burzy\u0144ski. Enum Overhaul TypeScript long-standing oddities around enum ever since first release. 5.0, we\u2019re cleaning problems, well reducing concept count needed understand various kinds enum declare. two main new errors might see part this. first assigning out-of-domain literal enum type error one might expect: ts enum SomeEvenDigit {Zero = 0,Two = 2,Four = 4}// correctly errorlet m: SomeEvenDigit = 1; declaration certain kinds indirected mixed string/number enum forms would, incorrectly, create all-number enum : ts enum Letters {A = \"a\"}enum Numbers {one = 1,two = Letters.A}// correctly errorconst t: number = Numbers.two; see details relevant change. Accurate Type-Checking Parameter Decorators Constructors --experimentalDecorators TypeScript 5.0 makes type-checking accurate decorators --experimentalDecorators . One place becomes apparent using decorator constructor parameter. ts export declare const inject:(entity: any) =>(target: object, key: string | symbol, index?: number) => void;export class Foo {}export class C {constructor(@inject(Foo) private x: any) {}} call fail key expects string | symbol , constructor parameters receive key undefined . correct fix change type key within inject . reasonable workaround you\u2019re using library can\u2019t upgraded wrap inject type-safe decorator function, use type-assertion key . details, see issue. Deprecations Default Changes TypeScript 5.0, we\u2019ve deprecated following settings setting values: --target: ES3 --out --noImplicitUseStrict --keyofStringsOnly --suppressExcessPropertyErrors --suppressImplicitAnyIndexErrors --noStrictGenericChecks --charset --importsNotUsedAsValues --preserveValueImports prepend project references configurations continue allowed TypeScript 5.5, point removed entirely, however, receive warning using settings. TypeScript 5.0, well future releases 5.1, 5.2, 5.3, 5.4, specify \"ignoreDeprecations\": \"5.0\" silence warnings. We\u2019ll also shortly releasing 4.9 patch allow specifying ignoreDeprecations allow smoother upgrades. Aside deprecations, we\u2019ve changed settings better improve cross-platform behavior TypeScript. --newLine , controls line endings emitted JavaScript files, used inferred based current operating system specified. think builds deterministic possible, Windows Notepad supports line-feed line endings now, new default setting LF . old OS-specific inference behavior longer available. --forceConsistentCasingInFileNames , ensured references file name project agreed casing, defaults true . help catch differences issues code written case-insensitive file systems. leave feedback view information tracking issue 5.0 deprecations"},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html", "title": "Documentation - TypeScript 5.1", "text": "Easier Implicit Returns undefined -Returning Functions JavaScript, function finishes running without hitting return , returns value undefined . ts function foo() {// return}// x = undefinedlet x = foo(); However, previous versions TypeScript, functions could absolutely return statements void - -returning functions. meant even explicitly said \u201cthis function returns undefined \u201d forced least one return statement. ts // \u2705 fine - inferred 'f1' returns 'void'function f1() {// returns}// \u2705 fine - 'void' need return statementfunction f2(): void {// returns}// \u2705 fine - 'any' need return statementfunction f3(): {// returns}// \u274c error!// function whose declared type neither 'void' 'any' must return value.function f4(): undefined {// returns} could pain API expected function returning undefined - would need either least one explicit return undefined return statement explicit annotation. ts declare function takesFunction(f: () => undefined): undefined;// \u274c error!// Argument type '() => void' assignable parameter type '() => undefined'.takesFunction(() => {// returns});// \u274c error!// function whose declared type neither 'void' 'any' must return value.takesFunction((): undefined => {// returns});// \u274c error!// Argument type '() => void' assignable parameter type '() => undefined'.takesFunction(() => {return;});// \u2705 workstakesFunction(() => {return undefined;});// \u2705 workstakesFunction((): undefined => {return;}); behavior frustrating confusing, especially calling functions outside one\u2019s control. Understanding interplay inferring void undefined , whether undefined -returning function needs return statement, etc. seems like distraction. First, TypeScript 5.1 allows undefined -returning functions return statement. ts // \u2705 Works TypeScript 5.1!function f4(): undefined {// returns}// \u2705 Works TypeScript 5.1!takesFunction((): undefined => {// returns}); Second, function return expressions passed something expecting function returns undefined , TypeScript infers undefined function\u2019s return type. ts // \u2705 Works TypeScript 5.1!takesFunction(function f() {// ^ return type undefined// returns});// \u2705 Works TypeScript 5.1!takesFunction(function f() {// ^ return type undefinedreturn;}); address another similar pain-point, TypeScript\u2019s --noImplicitReturns option, functions returning undefined similar exception void , every single code path must end explicit return . ts // \u2705 Works TypeScript 5.1 '--noImplicitReturns'!function f(): undefined {if (Math.random()) {// stuff...return;}} information, read original issue implementing pull request. Unrelated Types Getters Setters TypeScript 4.3 made possible say get set accessor pair might specify two different types. ts interface Serializer {set value(v: string | number | boolean);get value(): string;}declare let box: Serializer;// Allows writing 'boolean'box.value = true;// Comes 'string'console.log(box.value.toUpperCase()); Initially required get type subtype set type. meant writing ts box.value = box.value; would always valid. However, plenty existing proposed APIs completely unrelated types getters setters. example, consider one common examples - style property DOM CSSStyleRule API. Every style rule style property CSSStyleDeclaration ; however, try write property, work correctly string! TypeScript 5.1 allows completely unrelated types get set accessor properties, provided explicit type annotations. version TypeScript yet change types built-in interfaces, CSSStyleRule defined following way: ts interface CSSStyleRule {// .../** Always reads `CSSStyleDeclaration` */get style(): CSSStyleDeclaration;/** write `string` here. */set style(newValue: string);// ...} also allows patterns like requiring set accessors accept \u201cvalid\u201d data, specifying get accessors may return undefined underlying state hasn\u2019t initialized yet. ts class SafeBox {#value: string | undefined;// accepts strings!set value(newValue: string) {}// Must check 'undefined'!get value(): string | undefined {return this.#value;}} fact, similar optional properties checked --exactOptionalProperties . read implementing pull request. Decoupled Type-Checking JSX Elements JSX Tag Types One pain point TypeScript JSX requirements type every JSX element\u2019s tag. context, JSX element either following: tsx // self-closing JSX tag<Foo />// regular element opening/closing tag<Bar></Bar> type-checking <Foo /> <Bar></Bar> , TypeScript always looks namespace called JSX fetches type called Element - directly, looks JSX.Element . check whether Foo Bar valid use tag names, TypeScript would roughly grab types returned constructed Foo Bar check compatibility JSX.Element (or another type called JSX.ElementClass type constructable). limitations meant components could used returned \u201crendered\u201d broad type JSX.Element . example, JSX library might fine component returning string Promise s. concrete example, React considering adding limited support components return Promise s, existing versions TypeScript cannot express without someone drastically loosening type JSX.Element . tsx import * React \"react\";async function Foo() {return <div></div>;}let element = <Foo />;// ~~~// 'Foo' cannot used JSX component.// return type 'Promise<Element>' valid JSX element. provide libraries way express this, TypeScript 5.1 looks type called JSX.ElementType . ElementType specifies precisely valid use tag JSX element. might typed today something like tsx namespace JSX {export type ElementType =// valid lowercase tagskeyof IntrinsicAttributes// Function components(props: any) => Element// Class componentsnew (props: any) => ElementClass;export interface IntrinsicAttributes extends /*...*/ {}export type Element = /*...*/;export type ElementClass = /*...*/;} We\u2019d like extend thanks Sebastian Silbermann contributed change! Namespaced JSX Attributes TypeScript supports namespaced attribute names using JSX. tsx import * React \"react\";// equivalent:const x = <Foo a:b=\"hello\" />;const = <Foo : b=\"hello\" />;interface FooProps {\"a:b\": string;}function Foo(props: FooProps) {return <div>{props[\"a:b\"]}</div>;} Namespaced tag names looked similar way JSX.IntrinsicAttributes first segment name lowercase name. tsx // library's code augmentation library:namespace JSX {interface IntrinsicElements {[\"a:b\"]: { prop: string };}}// code:let x = <a:b prop=\"hello!\" />; contribution provided thanks Oleksandr Tarasiuk. typeRoots Consulted Module Resolution TypeScript\u2019s specified module lookup strategy unable resolve path, resolve packages relative specified typeRoots . See pull request details. Move Declarations Existing Files addition moving declarations new files, TypeScript ships preview feature moving declarations existing files well. try functionality recent version Visual Studio Code. Keep mind feature currently preview, seeking feedback it. https://github.com/microsoft/TypeScript/pull/53542 Linked Cursors JSX Tags TypeScript supports linked editing JSX tag names. Linked editing (occasionally called \u201cmirrored cursors\u201d) allows editor edit multiple locations time automatically. new feature work TypeScript JavaScript files, enabled Visual Studio Code Insiders. Visual Studio Code, either edit Editor: Linked Editing option Settings UI: configure editor.linkedEditing JSON settings file: jsonc {// ...\"editor.linkedEditing\": true,} feature also supported Visual Studio 17.7 Preview 1. take look implementation linked editing here! Snippet Completions @param JSDoc Tags TypeScript provides snippet completions typing @param tag TypeScript JavaScript files. help cut typing jumping around text document code add JSDoc types JavaScript. check new feature implemented GitHub. Optimizations Avoiding Unnecessary Type Instantiation TypeScript 5.1 avoids performing type instantiation within object types known contain references outer type parameters. potential cut many unnecessary computations, reduced type-checking time material-ui\u2019s docs directory 50%. see changes involved change GitHub. Negative Case Checks Union Literals checking source type part union type, TypeScript first fast look-up using internal type identifier source. look-up fails, TypeScript checks compatibility every type within union. relating literal type union purely literal types, TypeScript avoid full walk every type union. assumption safe TypeScript always interns/caches literal types - though edge cases handle relating \u201cfresh\u201d literal types. optimization able reduce type-checking time code issue 45 seconds 0.4 seconds. Reduced Calls Scanner JSDoc Parsing older versions TypeScript parsed JSDoc comment, would use scanner/tokenizer break comment fine-grained tokens piece contents back together. could helpful normalizing comment text, multiple spaces would collapse one; extremely \u201cchatty\u201d meant parser scanner would jump back forth often, adding overhead JSDoc parsing. TypeScript 5.1 moved logic around breaking JSDoc comments scanner/tokenizer. scanner returns larger chunks content directly parser needs. changes brought parse time several 10Mb mostly-prose-comment JavaScript files half. realistic example, performance suite\u2019s snapshot xstate dropped 300ms parse time, making faster load analyze. Breaking Changes ES2020 Node.js 14.17 Minimum Runtime Requirements TypeScript 5.1 ships JavaScript functionality introduced ECMAScript 2020. result, minimum TypeScript must run reasonably modern runtime. users, means TypeScript runs Node.js 14.17 later. try running TypeScript 5.1 older version Node.js Node 10 12, may see error like following running either tsc.js tsserver.js : node_modules/typescript/lib/tsserver.js:2406for (let = startIndex ?? 0; < array.length; i++) {^SyntaxError: Unexpected token '?'at wrapSafe (internal/modules/cjs/loader.js:915:16)at Module._compile (internal/modules/cjs/loader.js:963:27)at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)at Module.load (internal/modules/cjs/loader.js:863:32)at Function.Module._load (internal/modules/cjs/loader.js:708:14)at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)at internal/main/run_main_module.js:17:47 Additionally, try installing TypeScript you\u2019ll get something like following error messages npm: npm WARN EBADENGINE Unsupported engine {npm WARN EBADENGINE package: 'typescript@5.1.1-rc',npm WARN EBADENGINE required: { node: '>=14.17' },npm WARN EBADENGINE current: { node: 'v12.22.12', npm: '8.19.2' }npm WARN EBADENGINE } Yarn: error typescript@5.1.1-rc: engine \"node\" incompatible module. Expected version \">=14.17\". Got \"12.22.12\"error Found incompatible module. See information around change here. Explicit typeRoots Disables Upward Walks node_modules/@types Previously, typeRoots option specified tsconfig.json resolution typeRoots directories failed, TypeScript would still continue walking parent directories, trying resolve packages within parent\u2019s node_modules/@types folder. behavior could prompt excessive look-ups disabled TypeScript 5.1. result, may begin see errors like following based entries tsconfig.json \u2019s types option /// <reference > directives error TS2688: Cannot find type definition file 'node'.error TS2688: Cannot find type definition file 'mocha'.error TS2688: Cannot find type definition file 'jasmine'.error TS2688: Cannot find type definition file 'chai-http'.error TS2688: Cannot find type definition file 'webpack-env\"'. solution typically add specific entries node_modules/@types typeRoots : jsonc {\"compilerOptions\": {\"types\": [\"node\",\"mocha\"],\"typeRoots\": [// Keep whatever around before.\"./some-custom-types/\",// might need local 'node_modules/@types'.\"./node_modules/@types\",// might also need specify shared 'node_modules/@types'// using \"monorepo\" layout.\"../../node_modules/@types\",]}} information available original change issue tracker."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html", "title": "Documentation - TypeScript 5.2", "text": "using Declarations Explicit Resource Management TypeScript 5.2 adds support upcoming Explicit Resource Management feature ECMAScript. Let\u2019s explore motivations understand feature brings us. It\u2019s common need sort \u201cclean-up\u201d creating object. example, might need close network connections, delete temporary files, free memory. Let\u2019s imagine function creates temporary file, reads writes various operations, closes deletes it. ts import * fs \"fs\";export function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");// use file...// Close file delete it.fs.closeSync(file);fs.unlinkSync(path);} fine, happens need perform early exit? ts export function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");// use file...if (someCondition()) {// work...// Close file delete it.fs.closeSync(file);fs.unlinkSync(path);return;}// Close file delete it.fs.closeSync(file);fs.unlinkSync(path);} We\u2019re starting see duplication clean-up easy forget. We\u2019re also guaranteed close delete file error gets thrown. could solved wrapping try /finally block. ts export function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");try {// use file...if (someCondition()) {// work...return;}}finally {// Close file delete it.fs.closeSync(file);fs.unlinkSync(path);}} robust, it\u2019s added quite bit \u201cnoise\u201d code. also foot-guns run start adding clean-up logic finally block \u2014 example, exceptions preventing resources disposed. explicit resource management proposal aims solve. key idea proposal support resource disposal \u2014 clean-up work we\u2019re trying deal \u2014 first class idea JavaScript. starts adding new built-in symbol called Symbol.dispose , create objects methods named Symbol.dispose . convenience, TypeScript defines new global type called Disposable describes these. ts class TempFile implements Disposable {#path: string;#handle: number;constructor(path: string) {this.#path = path;this.#handle = fs.openSync(path, \"w+\");}// methods[Symbol.dispose]() {// Close file delete it.fs.closeSync(this.#handle);fs.unlinkSync(this.#path);}} Later call methods. ts export function doSomeWork() {const file = new TempFile(\".some_temp_file\");try {// ...}finally {file[Symbol.dispose]();}} Moving clean-up logic TempFile doesn\u2019t buy us much; we\u2019ve basically moved clean-up work finally block method, that\u2019s always possible. well-known \u201cname\u201d method means JavaScript build features top it. brings us first star feature: using declarations! using new keyword lets us declare new fixed bindings, kind like const . key difference variables declared using get Symbol.dispose method called end scope! could simply written code like this: ts export function doSomeWork() {using file = new TempFile(\".some_temp_file\");// use file...if (someCondition()) {// work...return;}} Check \u2014 try /finally blocks! least, none see. Functionally, that\u2019s exactly using declarations us, don\u2019t deal that. might familiar using declarations C#, statements Python, try -with-resource declarations Java. similar JavaScript\u2019s new using keyword, provide similar explicit way perform \u201ctear-down\u201d object end scope. using declarations clean-up end containing scope right \u201cearly return\u201d like return throw n error. also dispose first-in-last-out order like stack. ts function loggy(id: string): Disposable {console.log(`Creating ${id}`);return {[Symbol.dispose]() {console.log(`Disposing ${id}`);}}}function func() {using = loggy(\"a\");using b = loggy(\"b\");{using c = loggy(\"c\");using = loggy(\"d\");}using e = loggy(\"e\");return;// Unreachable.// Never created, never disposed.using f = loggy(\"f\");}func();// Creating a// Creating b// Creating c// Creating d// Disposing d// Disposing c// Creating e// Disposing e// Disposing b// Disposing using declarations supposed resilient exceptions; error thrown, it\u2019s rethrown disposal. hand, body function might execute expected, Symbol.dispose might throw. case, exception rethrown well. happens logic disposal throws error? cases, SuppressedError introduced new subtype Error . features suppressed property holds last-thrown error, error property most-recently thrown error. ts class ErrorA extends Error {name = \"ErrorA\";}class ErrorB extends Error {name = \"ErrorB\";}function throwy(id: string) {return {[Symbol.dispose]() {throw new ErrorA(`Error ${id}`);}};}function func() {using = throwy(\"a\");throw new ErrorB(\"oops!\")}try {func();}catch (e: any) {console.log(e.name); // SuppressedErrorconsole.log(e.message); // error suppressed disposal.console.log(e.error.name); // ErrorAconsole.log(e.error.message); // Error aconsole.log(e.suppressed.name); // ErrorBconsole.log(e.suppressed.message); // oops!} might noticed we\u2019re using synchronous methods examples. However, lots resource disposal involves asynchronous operations, need wait complete continue running code. That\u2019s also new Symbol.asyncDispose , brings us next star show \u2014 await using declarations. similar using declarations, key look whose disposal must await ed. use different method named Symbol.asyncDispose , though operate anything Symbol.dispose well. convenience, TypeScript also introduces global type called AsyncDisposable describes object asynchronous dispose method. ts async function doWork() {// fake work half second.await new Promise(resolve => setTimeout(resolve, 500));}function loggy(id: string): AsyncDisposable {console.log(`Constructing ${id}`);return {async [Symbol.asyncDispose]() {console.log(`Disposing (async) ${id}`);await doWork();},}}async function func() {await using = loggy(\"a\");await using b = loggy(\"b\");{await using c = loggy(\"c\");await using = loggy(\"d\");}await using e = loggy(\"e\");return;// Unreachable.// Never created, never disposed.await using f = loggy(\"f\");}func();// Constructing a// Constructing b// Constructing c// Constructing d// Disposing (async) d// Disposing (async) c// Constructing e// Disposing (async) e// Disposing (async) b// Disposing (async) Defining types terms Disposable AsyncDisposable make code much easier work expect others tear-down logic consistently. fact, lots existing types exist wild dispose() close() method. example, Visual Studio Code APIs even define Disposable interface. APIs browser runtimes like Node.js, Deno, Bun might also choose use Symbol.dispose Symbol.asyncDispose objects already clean-up methods, like file handles, connections, more. maybe sounds great libraries, little bit heavy-weight scenarios. you\u2019re lot ad-hoc clean-up, creating new type might introduce lot over-abstraction questions best-practices. example, take TempFile example again. ts class TempFile implements Disposable {#path: string;#handle: number;constructor(path: string) {this.#path = path;this.#handle = fs.openSync(path, \"w+\");}// methods[Symbol.dispose]() {// Close file delete it.fs.closeSync(this.#handle);fs.unlinkSync(this.#path);}}export function doSomeWork() {using file = new TempFile(\".some_temp_file\");// use file...if (someCondition()) {// work...return;}} wanted remember call two functions \u2014 best way write it? calling openSync constructor, create open() method, pass handle ourselves? expose method every possible operation need perform, make properties public? brings us final stars feature: DisposableStack AsyncDisposableStack . objects useful one-off clean-up, along arbitrary amounts cleanup. DisposableStack object several methods keeping track Disposable objects, given functions arbitrary clean-up work. also assign using variables \u2014 get \u2014 they\u2019re also Disposable ! here\u2019s could\u2019ve written original example. ts function doSomeWork() {const path = \".some_temp_file\";const file = fs.openSync(path, \"w+\");using cleanup = new DisposableStack();cleanup.defer(() => {fs.closeSync(file);fs.unlinkSync(path);});// use file...if (someCondition()) {// work...return;}// ...} Here, defer() method takes callback, callback run cleanup disposed of. Typically, defer (and DisposableStack methods like use adopt ) called immediately creating resource. name suggests, DisposableStack disposes everything keeps track like stack, first-in-last-out order, defer ing immediately creating value helps avoid odd dependency issues. AsyncDisposableStack works similarly, keep track async functions AsyncDisposable s, AsyncDisposable. defer method similar many ways defer keyword Go, Swift, Zig, Odin, others, conventions similar. feature recent, runtimes support natively. use it, need runtime polyfills following: Symbol.dispose Symbol.asyncDispose DisposableStack AsyncDisposableStack SuppressedError However, you\u2019re interested using await using , able get away polyfilling built-in symbol s. Something simple following work cases: ts Symbol.dispose ??= Symbol(\"Symbol.dispose\");Symbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\"); also need set compilation target es2022 below, configure lib setting either include \"esnext\" \"esnext.disposable\" . json {\"compilerOptions\": {\"target\": \"es2022\",\"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]}} information feature, take look work GitHub! Decorator Metadata TypeScript 5.2 implements upcoming ECMAScript feature called decorator metadata. key idea feature make easy decorators create consume metadata class they\u2019re used within. Whenever decorator functions used, access new metadata property context object. metadata property holds simple object. Since JavaScript lets us add properties arbitrarily, used dictionary updated decorator. Alternatively, since every metadata object identical decorated portion class, used key Map . decorators class get run, object accessed class via Symbol.metadata . ts interface Context {name: string;metadata: Record<PropertyKey, unknown>;}function setMetadata(_target: any, context: Context) {context.metadata[context.name] = true;}class SomeClass {@setMetadatafoo = 123;@setMetadataaccessor bar = \"hello!\";@setMetadatabaz() { }}const ourMetadata = SomeClass[Symbol.metadata];console.log(JSON.stringify(ourMetadata));// { \"bar\": true, \"baz\": true, \"foo\": true } useful number different scenarios. Metadata could possibly attached lots uses like debugging, serialization, performing dependency injection decorators. Since metadata objects created per decorated class, frameworks either privately use keys Map WeakMap , tack properties necessary. example, let\u2019s say wanted use decorators keep track properties accessors serializable using JSON.stringify like so: ts import { serialize, jsonify } \"./serializer\";class Person {firstName: string;lastName: string;@serializeage: number@serializeget fullName() {return `${this.firstName} ${this.lastName}`;}toJSON() {return jsonify(this)}constructor(firstName: string, lastName: string, age: number) {// ...}} Here, intent age fullName serialized marked @serialize decorator. define toJSON method purpose, calls jsonify uses metadata @serialize created. Here\u2019s example module ./serialize.ts might defined: ts const serializables = Symbol();type Context =| ClassAccessorDecoratorContext| ClassGetterDecoratorContext| ClassFieldDecoratorContext;export function serialize(_target: any, context: Context): void {if (context.static || context.private) {throw new Error(\"Can serialize public instance members.\")}if (typeof context.name === \"symbol\") {throw new Error(\"Cannot serialize symbol-named properties.\");}const propNames =(context.metadata[serializables] string[] | undefined) ??= [];propNames.push(context.name);}export function jsonify(instance: object): string {const metadata = instance.constructor[Symbol.metadata];const propNames = metadata?.[serializables] string[] | undefined;if (!propNames) {throw new Error(\"No members marked @serialize.\");}const pairStrings = propNames.map(key => {const strKey = JSON.stringify(key);const strValue = JSON.stringify((instance any)[key]);return `${strKey}: ${strValue}`;});return `{ ${pairStrings.join(\", \")} }`;} module local symbol called serializables store retrieve names properties marked @serializable . stores list property names metadata invocation @serializable . jsonify called, list properties fetched metadata used retrieve actual values instance, eventually serializing names values. Using symbol technically makes data accessible others. alternative might use WeakMap using metadata object key. keeps data private happens use fewer type assertions case, otherwise similar. ts const serializables = new WeakMap<object, string[]>();type Context =| ClassAccessorDecoratorContext| ClassGetterDecoratorContext| ClassFieldDecoratorContext;export function serialize(_target: any, context: Context): void {if (context.static || context.private) {throw new Error(\"Can serialize public instance members.\")}if (typeof context.name !== \"string\") {throw new Error(\"Can serialize string properties.\");}let propNames = serializables.get(context.metadata);if (propNames === undefined) {serializables.set(context.metadata, propNames = []);}propNames.push(context.name);}export function jsonify(instance: object): string {const metadata = instance.constructor[Symbol.metadata];const propNames = metadata && serializables.get(metadata);if (!propNames) {throw new Error(\"No members marked @serialize.\");}const pairStrings = propNames.map(key => {const strKey = JSON.stringify(key);const strValue = JSON.stringify((instance any)[key]);return `${strKey}: ${strValue}`;});return `{ ${pairStrings.join(\", \")} }`;} note, implementations don\u2019t handle subclassing inheritance. That\u2019s left exercise (and might find easier one version file other!). feature still fresh, runtimes support natively. use it, need polyfill Symbol.metadata . Something simple following work cases: ts Symbol.metadata ??= Symbol(\"Symbol.metadata\"); also need set compilation target es2022 below, configure lib setting either include \"esnext\" \"esnext.decorators\" . json {\"compilerOptions\": {\"target\": \"es2022\",\"lib\": [\"es2022\", \"esnext.decorators\", \"dom\"]}} We\u2019d like thank Oleksandr Tarasiuk contributing implementation decorator metadata TypeScript 5.2! Named Anonymous Tuple Elements Tuple types supported optional labels names element. ts type Pair<T> = [first: T, second: T]; labels don\u2019t change you\u2019re allowed \u2014 they\u2019re solely help readability tooling. However, TypeScript previously rule tuples could mix match labeled unlabeled elements. words, either element could label tuple, elements needed one. ts // \u2705 fine - labelstype Pair1<T> = [T, T];// \u2705 fine - fully labeledtype Pair2<T> = [first: T, second: T];// \u274c previously errortype Pair3<T> = [first: T, T];// ~// Tuple members must names// names. could annoying rest elements we\u2019d forced add label like rest tail . ts // \u274c previously errortype TwoOrMore_A<T> = [first: T, second: T, ...T[]];// ~~~~~~// Tuple members must names// names.// \u2705type TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]]; also meant restriction enforced internally type system, meaning TypeScript would lose labels. ts type HasLabels = [a: string, b: string];type HasNoLabels = [number, number];type Merged = [...HasNoLabels, ...HasLabels];// ^ [number, number, string, string]//// 'a' 'b' lost 'Merged' TypeScript 5.2, all-or-nothing restriction tuple labels lifted. language also preserve labels spreading unlabeled tuple. We\u2019d like extend thanks Josh Goldberg Mateusz Burzy\u0144ski collaborated lift restriction. Easier Method Usage Unions Arrays previous versions TypeScript, calling method union arrays could end pain. ts declare let array: string[] | number[];array.filter(x => !!x);// ~~~~~~ error!// expression callable.// member union type '...' signatures,// none signatures compatible// other. example, TypeScript would try see version filter compatible across string[] number[] . Without coherent strategy, TypeScript threw hands air said \u201cI can\u2019t make work\u201d. TypeScript 5.2, giving cases, unions arrays treated special case. new array type constructed member\u2019s element type, method invoked that. Taking example, string[] | number[] transformed (string | number)[] (or Array<string | number> ), filter invoked type. slight caveat filter produce Array<string | number> instead string[] | number[] ; freshly produced value less risk something \u201cgoing wrong\u201d. means lots methods like filter , find , , every , reduce invokable unions arrays cases previously. read details implementing pull request. Type-Only Import Paths TypeScript Implementation File Extensions TypeScript allows declaration implementation file extensions included type-only import paths, regardless whether allowImportingTsExtensions enabled. means write import type statements use .ts , .mts , .cts , .tsx file extensions. ts import type { JustAType } \"./justTypes.ts\";export function f(param: JustAType) {// ...} also means import() types, used TypeScript JavaScript JSDoc, use file extensions. js /*** @param {import(\"./justTypes.ts\").JustAType} param*/export function f(param) {// ...} information, see change here. Comma Completions Object Members easy forget add comma adding new property object. Previously, forgot comma requested auto-completion, TypeScript would confusingly give poor unrelated completion results. TypeScript 5.2 gracefully provides object member completions you\u2019re missing comma. skip past hitting syntax error, also auto-insert missing comma. information, see implementation here. Inline Variable Refactoring TypeScript 5.2 refactoring inline contents variable usage sites. . Using \u201cinline variable\u201d refactoring eliminate variable replace variable\u2019s usages initializer. Note may cause initializer\u2019s side-effects run different time, many times variable used. details, see implementing pull request. Optimized Checks Ongoing Type Compatibility TypeScript structural type system, types occasionally need compared member-wise fashion; however, recursive types add issues here. example: ts interface {value: A;other: string;}interface B {value: B;other: number;} checking whether type compatible type B , TypeScript end checking whether types value B respectively compatible. point, type system needs stop checking proceed check members. this, type system track two types already related. Previously TypeScript already kept stack type pairs, iterated determine whether types related. stack shallow that\u2019s problem; stack isn\u2019t shallow, that, uh, problem. TypeScript 5.3, simple Set helps track information. reduced time spent reported test case used drizzle library 33%! Benchmark 1: oldTime (mean \u00b1 \u03c3): 3.115 \u00b1 0.067 [User: 4.403 s, System: 0.124 s]Range (min \u2026 max): 3.018 \u2026 3.196 10 runsBenchmark 2: newTime (mean \u00b1 \u03c3): 2.072 \u00b1 0.050 [User: 3.355 s, System: 0.135 s]Range (min \u2026 max): 1.985 \u2026 2.150 10 runsSummary'new' ran1.50 \u00b1 0.05 times faster 'old' Breaking Changes Correctness Fixes TypeScript strives unnecessarily introduce breaks; however, occasionally must make corrections improvements code better-analyzed. lib.d.ts Changes Types generated DOM may impact codebase. information, see DOM updates TypeScript 5.2. labeledElementDeclarations May Hold undefined Elements order support mixture labeled unlabeled elements, TypeScript\u2019s API changed slightly. labeledElementDeclarations property TupleType may hold undefined position element unlabeled. diff interface TupleType {- labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];+ labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];} module moduleResolution Must Match Recent Node.js settings --module --moduleResolution options support node16 nodenext setting. effectively \u201cmodern Node.js\u201d settings used recent Node.js project. we\u2019ve found two options don\u2019t agree whether using Node.js-related settings, projects effectively misconfigured. TypeScript 5.2, using node16 nodenext either --module --moduleResolution options, TypeScript requires similar Node.js-related setting. cases settings diverge, you\u2019ll likely get error message like either Option 'moduleResolution' must set 'NodeNext' (or left unspecified) option 'module' set 'NodeNext'. Option 'module' must set 'Node16' option 'moduleResolution' set 'Node16'. example --module esnext --moduleResolution node16 rejected \u2014 may better using --module nodenext alone, --module esnext --moduleResolution bundler . information, see change here. Consistent Export Checking Merged Symbols two declarations merge, must agree whether exported. Due bug, TypeScript missed specific cases ambient contexts, like declaration files declare module blocks. example, would issue error case like following, replaceInFile declared exported function, one un-exported namespace. ts declare module 'replace-in-file' {export function replaceInFile(config: unknown): Promise<unknown[]>;export {};namespace replaceInFile {export function sync(config: unknown): unknown[];}} ambient module, adding export { ... } similar construct like export default ... implicitly changes whether declarations automatically exported. TypeScript recognizes unfortunately confusing semantics consistently, issues error fact declarations replaceInFile need agree modifiers, issue following error: Individual declarations merged declaration 'replaceInFile' must exported local. information, see change here."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html", "title": "Documentation - TypeScript 5.3", "text": "Import Attributes TypeScript 5.3 supports latest updates import attributes proposal. One use-case import attributes provide information expected format module runtime. ts // want interpreted JSON,// runnable/malicious JavaScript file `.json` extension.import obj \"./something.json\" { type: \"json\" }; contents attributes checked TypeScript since they\u2019re host-specific, simply left alone browsers runtimes handle (and possibly error). ts // TypeScript fine this.// browser? Probably not.import * foo \"./foo.js\" { type: \"fluffy bunny\" }; Dynamic import() calls also use import attributes second argument. ts const obj = await import(\"./something.json\", {with: { type: \"json\" }}); expected type second argument defined type called ImportCallOptions , default expects property called . Note import attributes evolution earlier proposal called \u201cimport assertions\u201d, implemented TypeScript 4.5. obvious difference use keyword assert keyword. less-visible difference runtimes free use attributes guide resolution interpretation import paths, whereas import assertions could assert characteristics loading module. time, TypeScript deprecating old syntax import assertions favor proposed syntax import attributes. Existing code using assert migrate towards keyword. New code needs import attribute use exclusively. We\u2019d like thank Oleksandr Tarasiuk implementing proposal! we\u2019d also like call Wenlu Wang implementation import assertions! Stable Support resolution-mode Import Types TypeScript 4.7, TypeScript added support resolution-mode attribute /// <reference types=\"...\" /> control whether specifier resolved via import require semantics. ts /// <reference types=\"pkg\" resolution-mode=\"require\" />// or/// <reference types=\"pkg\" resolution-mode=\"import\" /> corresponding field added import assertions type-only imports well; however, supported nightly versions TypeScript. rationale spirit, import assertions intended guide module resolution. feature shipped experimentally nightly-only mode get feedback. given import attributes guide resolution, we\u2019ve seen reasonable use-cases, TypeScript 5.3 supports resolution-mode attribute import type . ts // Resolve `pkg` importing `require()`import type { TypeFromRequire } \"pkg\" {\"resolution-mode\": \"require\"};// Resolve `pkg` importing `import`import type { TypeFromImport } \"pkg\" {\"resolution-mode\": \"import\"};export interface MergedType extends TypeFromRequire, TypeFromImport {} import attributes also used import() types. ts export type TypeFromRequire =import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;export type TypeFromImport =import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;export interface MergedType extends TypeFromRequire, TypeFromImport {} information, check change resolution-mode Supported Module Modes Previously, using resolution-mode allowed moduleResolution options node16 nodenext . make easier look modules specifically type purposes, resolution-mode works appropriately moduleResolution options like bundler , node10 , simply doesn\u2019t error classic . information, see implementing pull request. switch (true) Narrowing TypeScript 5.3 perform narrowing based conditions case clause within switch (true) . ts function f(x: unknown) {switch (true) {case typeof x === \"string\":// 'x' 'string' hereconsole.log(x.toUpperCase());// falls through...case Array.isArray(x):// 'x' 'string | any[]' here.console.log(x.length);// falls through...default:// 'x' 'unknown' here.// ...}} feature spearheaded initial work Mateusz Burzy\u0144ski We\u2019d like extend \u201cthank you!\u201d contribution. Narrowing Comparisons Booleans Occasionally may find performing direct comparison true false condition. Usually unnecessary comparisons, might prefer point style, avoid certain issues around JavaScript truthiness. Regardless, previously TypeScript didn\u2019t recognize forms performing narrowing. TypeScript 5.3 keeps understands expressions narrowing variables. ts interface {a: string;}interface B {b: string;}type MyType = | B;function isA(x: MyType): x {return \"a\" x;}function someFn(x: MyType) {if (isA(x) === true) {console.log(x.a); // works!}} We\u2019d like thank Mateusz Burzy\u0144ski pull request implemented this. instanceof Narrowing Symbol.hasInstance slightly esoteric feature JavaScript possible override behavior instanceof operator. so, value right side instanceof operator needs specific method named Symbol.hasInstance . js class Weirdo {static [Symbol.hasInstance](testedValue) {// wait, what?return testedValue === undefined;}}// falseconsole.log(new Thing() instanceof Weirdo);// trueconsole.log(undefined instanceof Weirdo); better model behavior instanceof , TypeScript checks [Symbol.hasInstance] method exists declared type predicate function. does, tested value left side instanceof operator narrowed appropriately type predicate. ts interface PointLike {x: number;y: number;}class Point implements PointLike {x: number;y: number;constructor(x: number, y: number) {this.x = x;this.y = y;}distanceFromOrigin() {return Math.sqrt(this.x ** 2 + this.y ** 2);}static [Symbol.hasInstance](val: unknown): val PointLike {return !!val && typeof val === \"object\" &&\"x\" val && \"y\" val &&typeof val.x === \"number\" &&typeof val.y === \"number\";}}function f(value: unknown) {if (value instanceof Point) {// access - correct!value.x;value.y;// Can't access - 'PointLike',// *actually* 'Point'.value.distanceFromOrigin();}} see example, Point defines [Symbol.hasInstance] method. actually acts custom type guard separate type called PointLike . function f , able narrow value PointLike instanceof , Point . means access properties x , method distanceFromOrigin . information, read change here. Checks super Property Accesses Instance Fields JavaScript, it\u2019s possible access declaration base class super keyword. js class Base {someMethod() {console.log(\"Base method called!\");}}class Derived extends Base {someMethod() {console.log(\"Derived method called!\");super.someMethod();}}new Derived().someMethod();// Prints:// Derived method called!// Base method called! different writing something like this.someMethod() , since could invoke overridden method. subtle distinction, made subtle fact often two interchangeable declaration never overridden all. js class Base {someMethod() {console.log(\"someMethod called!\");}}class Derived extends Base {someOtherMethod() {// act identically.this.someMethod();super.someMethod();}}new Derived().someOtherMethod();// Prints:// someMethod called!// someMethod called! problem using interchangeably super works members declared prototype \u2014 instance properties. means wrote super.someMethod() , someMethod defined field, you\u2019d get runtime error! ts class Base {someMethod = () => {console.log(\"someMethod called!\");}}class Derived extends Base {someOtherMethod() {super.someMethod();}}new Derived().someOtherMethod();// \ud83d\udca5// work 'super.someMethod' 'undefined'. TypeScript 5.3 more-closely inspects super property accesses/method calls see correspond class fields. do, we\u2019ll get type-checking error. check contributed thanks Jack Works! Interactive Inlay Hints Types TypeScript\u2019s inlay hints support jumping definition types! makes easier casually navigate code. See implementation here. Settings Prefer type Auto-Imports Previously TypeScript generated auto-imports something type position, would add type modifier based settings. example, getting auto-import Person following: ts export let p: Person TypeScript\u2019s editing experience would usually add import Person as: ts import { Person } \"./types\";export let p: Person certain settings like verbatimModuleSyntax , would add type modifier: ts import { type Person } \"./types\";export let p: Person However, maybe codebase isn\u2019t able use options; preference explicit type imports possible. recent change, TypeScript enables editor-specific option. Visual Studio Code, enable UI \u201cTypeScript \u203a Preferences: Prefer Type Auto Imports\u201d, JSON configuration option typescript.preferences.preferTypeOnlyAutoImports Optimizations Skipping JSDoc Parsing running TypeScript via tsc , compiler avoid parsing JSDoc. drops parsing time own, also reduces memory usage store comments along time spent garbage collection. All-in-all, see slightly faster compiles quicker feedback --watch mode. specific changes viewed here. every tool using TypeScript need store JSDoc (e.g. typescript-eslint Prettier), parsing strategy surfaced part API itself. enable tools gain memory speed improvements we\u2019ve brought TypeScript compiler. new options comment parsing strategy described JSDocParsingMode . information available pull request. Optimizations Comparing Non-Normalized Intersections TypeScript, unions intersections always follow specific form, intersections can\u2019t contain union types. means create intersection union like & (B | C) , intersection normalized (A & B) | (A & C) . Still, cases type system maintain original form display purposes. turns original form used clever fast-path comparisons types. example, let\u2019s say SomeType & (Type1 | Type2 | ... | Type99999NINE) want see that\u2019s assignable SomeType . Recall don\u2019t really intersection source type \u2014 union looks like (SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE) . checking union assignable target type, check every member union assignable target type, slow. TypeScript 5.3, peek original intersection form able tuck away. compare types, quick check see target exists constituent source intersection. information, see pull request. Consolidation tsserverlibrary.js typescript.js TypeScript ships two library files: tsserverlibrary.js typescript.js . certain APIs available tsserverlibrary.js (like ProjectService API), may useful importers. Still, two distinct bundles lot overlap, duplicating code package. What\u2019s more, challenging consistently use one due auto-imports muscle memory. Accidentally loading modules far easy, code may work properly different instance API. Even work, loading second bundle increases resource usage. Given this, we\u2019ve decided consolidate two. typescript.js contains tsserverlibrary.js used contain, tsserverlibrary.js simply re-exports typescript.js . Comparing before/after consolidation, saw following reduction package size: | | | Diff | Diff (percent) | | |---|---|---|---|---| | Packed | 6.90 MiB | 5.48 MiB | -1.42 MiB | -20.61% | | Unpacked | 38.74 MiB | 30.41 MiB | -8.33 MiB | -21.50% | | | | Diff | Diff (percent) | | |---|---|---|---|---| lib/tsserverlibrary.d.ts | 570.95 KiB | 865.00 B | -570.10 KiB | -99.85% | lib/tsserverlibrary.js | 8.57 MiB | 1012.00 B | -8.57 MiB | -99.99% | lib/typescript.d.ts | 396.27 KiB | 570.95 KiB | +174.68 KiB | +44.08% | lib/typescript.js | 7.95 MiB | 8.57 MiB | +637.53 KiB | +7.84% | words, 20.5% reduction package size. information, see work involved here. Breaking Changes Correctness Improvements lib.d.ts Changes Types generated DOM may impact codebase. information, see DOM updates TypeScript 5.3. Checks super Accesses Instance Properties TypeScript 5.3 detects declaration referenced super. property access class field issues error. prevents errors might occur runtime."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html", "title": "Documentation - TypeScript 5.4", "text": "Preserved Narrowing Closures Following Last Assignments TypeScript usually figure specific type variable based checks might perform. process called narrowing. ts function uppercaseStrings(x: string | number) {if (typeof x === \"string\") {// TypeScript knows 'x' 'string' here.return x.toUpperCase();}} One common pain point narrowed types weren\u2019t always preserved within function closures. ts function getUrls(url: string | URL, names: string[]) {if (typeof url === \"string\") {url = new URL(url);}return names.map(name => {url.searchParams.set(\"name\", name)// ~~~~~~~~~~~~// error!// Property 'searchParams' exist type 'string | URL'.return url.toString();});} Here, TypeScript decided wasn\u2019t \u201csafe\u201d assume url actually URL object callback function mutated elsewhere; however, instance, arrow function always created assignment url , it\u2019s also last assignment url . TypeScript 5.4 takes advantage make narrowing little smarter. parameters let variables used non-hoisted functions, type-checker look last assignment point. one found, TypeScript safely narrow outside containing function. means example works now. Note narrowing analysis doesn\u2019t kick variable assigned anywhere nested function. there\u2019s way know sure whether function called later. ts function printValueLater(value: string | undefined) {if (value === undefined) {value = \"missing!\";}setTimeout(() => {// Modifying 'value', even way affect// type, invalidate type refinements closures.value = value;}, 500);setTimeout(() => {console.log(value.toUpperCase());// ~~~~~// error! 'value' possibly 'undefined'.}, 1000);} make lots typical JavaScript code easier express. read change GitHub. NoInfer Utility Type calling generic functions, TypeScript able infer type arguments whatever pass in. ts function doSomething<T>(arg: T) {// ...}// explicitly say 'T' 'string'.doSomething<string>(\"hello!\");// also let type 'T' get inferred.doSomething(\"hello!\"); One challenge, however, always clear \u201cbest\u201d type infer. might lead TypeScript rejecting valid calls, accepting questionable calls, reporting worse error messages catches bug. example, let\u2019s imagine createStreetLight function takes list color names, along optional default color. ts function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {// ...}createStreetLight([\"red\", \"yellow\", \"green\"], \"red\"); happens pass defaultColor wasn\u2019t original colors array? function, colors supposed \u201csource truth\u201d describe passed defaultColor . ts // Oops! undesirable, allowed!createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\"); call, type inference decided \"blue\" valid type \"red\" \"yellow\" \"green\" . instead rejecting call, TypeScript infers type C \"red\" | \"yellow\" | \"green\" | \"blue\" . might say inference blue faces! One way people currently deal add separate type parameter that\u2019s bounded existing type parameter. ts function createStreetLight<C extends string, extends C>(colors: C[], defaultColor?: D) {}createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");// ~~~~~~// error!// Argument type '\"blue\"' assignable parameter type '\"red\" | \"yellow\" | \"green\" | undefined'. works, little bit awkward probably won\u2019t used anywhere else signature createStreetLight . bad case, using type parameter signature often code smell. That\u2019s TypeScript 5.4 introduces new NoInfer<T> utility type. Surrounding type NoInfer<...> gives signal TypeScript dig match inner types find candidates type inference. Using NoInfer , rewrite createStreetLight something like this: ts function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {// ...}createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");// ~~~~~~// error!// Argument type '\"blue\"' assignable parameter type '\"red\" | \"yellow\" | \"green\" | undefined'. Excluding type defaultColor explored inference means \"blue\" never ends inference candidate, type-checker reject it. see specific changes implementing pull request, along initial implementation provided thanks Mateusz Burzy\u0144ski! Object.groupBy Map.groupBy TypeScript 5.4 adds declarations JavaScript\u2019s new Object.groupBy Map.groupBy static methods. Object.groupBy takes iterable, function decides \u201cgroup\u201d element placed in. function needs make \u201ckey\u201d distinct group, Object.groupBy uses key make object every key maps array original element it. following JavaScript: js const array = [0, 1, 2, 3, 4, 5];const myObj = Object.groupBy(array, (num, index) => {return num % 2 === 0 ? \"even\": \"odd\";}); basically equivalent writing this: js const myObj = {even: [0, 2, 4],odd: [1, 3, 5],}; Map.groupBy similar, produces Map instead plain object. might desirable need guarantees Map s, you\u2019re dealing APIs expect Map s, need use kind key grouping - keys used property names JavaScript. js const myObj = Map.groupBy(array, (num, index) => {return num % 2 === 0 ? \"even\" : \"odd\";}); before, could created myObj equivalent way: js const myObj = new Map();myObj.set(\"even\", [0, 2, 4]);myObj.set(\"odd\", [1, 3, 5]); Note example Object.groupBy , object produced uses optional properties. ts interface EvenOdds {even?: number[];odd?: number[];}const myObj: EvenOdds = Object.groupBy(...);myObj.even;// ~~~~// Error access 'strictNullChecks'. there\u2019s way guarantee general way keys produced groupBy . Note also methods accessible configuring target esnext adjusting lib settings. expect eventually available stable es2024 target. We\u2019d like extend thanks Kevin Gibbons adding declarations groupBy methods. Support require() calls --moduleResolution bundler --module preserve TypeScript moduleResolution option called bundler meant model way modern bundlers figure file import path refers to. One limitations option paired --module esnext , making impossible use import ... = require(...) syntax. ts // previously erroredimport myModule = require(\"module/path\"); might seem like big deal you\u2019re planning writing standard ECMAScript import s, there\u2019s difference using package conditional exports. TypeScript 5.4, require() used setting module setting new option called preserve . --module preserve --moduleResolution bundler , two accurately model bundlers runtimes like Bun allow, they\u2019ll perform module lookups. fact, using --module preserve , bundler option implicitly set --moduleResolution (along --esModuleInterop --resolveJsonModule ) json {\"compilerOptions\": {\"module\": \"preserve\",// ^ also implies:// \"moduleResolution\": \"bundler\",// \"esModuleInterop\": true,// \"resolveJsonModule\": true,// ...}} --module preserve , ECMAScript import always emitted as-is, import ... = require(...) emitted require() call (though practice may even use TypeScript emit, since it\u2019s likely you\u2019ll using bundler code). holds true regardless file extension containing file. output code: ts import * foo \"some-package/foo\";import bar = require(\"some-package/bar\"); look something like this: js import * foo \"some-package/foo\";var bar = require(\"some-package/bar\"); also means syntax choose directs conditional exports matched. example, package.json some-package looks like this: json {\"name\": \"some-package\",\"version\": \"0.0.1\",\"exports\": {\"./foo\": {\"import\": \"./esm/foo-from-import.mjs\",\"require\": \"./cjs/foo-from-require.cjs\"},\"./bar\": {\"import\": \"./esm/bar-from-import.mjs\",\"require\": \"./cjs/bar-from-require.cjs\"}}} TypeScript resolve paths [...]/some-package/esm/foo-from-import.mjs [...]/some-package/cjs/bar-from-require.cjs . information, read new settings here. Checked Import Attributes Assertions Import attributes assertions checked global ImportAttributes type. means runtimes accurately describe import attributes ts // global file.interface ImportAttributes {type: \"json\";}// moduleimport * ns \"foo\" { type: \"not-json\" };// ~~~~~~~~~~// error!//// Type '{ type: \"not-json\"; }' assignable type 'ImportAttributes'.// Types property 'type' incompatible.// Type '\"not-json\"' assignable type '\"json\"'. change provided thanks Oleksandr Tarasiuk. Quick Fix Adding Missing Parameters TypeScript quick fix add new parameter functions called many arguments. useful threading new argument several existing functions, cumbersome today. quick fix provided courtsey Oleksandr Tarasiuk. Upcoming Changes TypeScript 5.0 Deprecations TypeScript 5.0 deprecated following options behaviors: charset target: ES3 importsNotUsedAsValues noImplicitUseStrict noStrictGenericChecks keyofStringsOnly suppressExcessPropertyErrors suppressImplicitAnyIndexErrors preserveValueImports prepend project references- implicitly OS-specific newLine continue using them, developers using TypeScript 5.0 recent versions specify new option called ignoreDeprecations value \"5.0\" . However, TypScript 5.4 last version continue function normal. TypeScript 5.5 (likely June 2024), become hard errors, code using need migrated away. information, read plan GitHub, contains suggestions best adapt codebase. Notable Behavioral Changes section highlights set noteworthy changes acknowledged understood part upgrade. Sometimes highlight deprecations, removals, new restrictions. also contain bug fixes functionally improvements, also affect existing build introducing new errors. lib.d.ts Changes Types generated DOM may impact type-checking codebase. information, see DOM updates TypeScript 5.4. Accurate Conditional Type Constraints following code longer allows second variable declaration function foo . ts type IsArray<T> = extends any[] ? true : false;function foo<U extends object>(x: IsArray<U>) {let first: true = x; // Errorlet second: false = x; // Error, previously wasn't} Previously, TypeScript checked initializer second , needed determine whether IsArray<U> assignable unit type false . IsArray<U> isn\u2019t compatible obvious way, TypeScript looks constraint type well. conditional type like extends Foo ? TrueBranch : FalseBranch , generic, type system would look constraint , substitute itself, decide either true false branch. behavior inaccurate overly eager. Even constraint isn\u2019t assignable Foo , doesn\u2019t mean won\u2019t instantiated something is. correct behavior produce union type constraint conditional type cases can\u2019t proven never always extends Foo. TypeScript 5.4 adopts accurate behavior. means practice may begin find conditional type instances longer compatible branches. read specific changes here. Aggressive Reduction Intersections Type Variables Primitive Types TypeScript reduces intersections type variables primitives aggressively, depending type variable\u2019s constraint overlaps primitives. ts declare function intersect<T, U>(x: T, y: U): & U;function foo<T extends \"abc\" | \"def\">(x: T, str: string, num: number) {// 'T & string', 'T'let = intersect(x, str);// 'T & number', 'never'let b = intersect(x, num)// '(T & \"abc\") | (T & \"def\")', 'T'let c = Math.random() < 0.5 ?intersect(x, \"abc\") :intersect(x, \"def\");} information, see change here. Improved Checking Template Strings Interpolations TypeScript accurately checks whether strings assignable placeholder slots template string type. ts function a<T extends {id: string}>() {let x: `-${keyof & string}`;// Used error, doesn't.x = \"-id\";} behavior desirable, may cause breaks code using constructs like conditional types, rule changes easy witness. See change details. Errors Type-Only Imports Conflict Local Values Previously, TypeScript would permit following code isolatedModules import Something referred type. ts import { Something } \"./some/path\";let Something = 123; However, it\u2019s safe single-file compilers assume whether it\u2019s \u201csafe\u201d drop import , even code guaranteed fail runtime. TypeScript 5.4, code trigger error like following: Import 'Something' conflicts local value, must declared type-only import 'isolatedModules' enabled. fix either make local rename, or, error states, add type modifier import: ts import type { Something } \"./some/path\";// orimport { type Something } \"./some/path\"; See information change itself. New Enum Assignability Restrictions two enums declared names enum member names, previously always considered compatible; however, values known, TypeScript would silently allow differing values. TypeScript 5.4 tightens restriction requiring values identical known. ts namespace First {export enum SomeEnum {A = 0,B = 1,}}namespace Second {export enum SomeEnum {A = 0,B = 2,}}function foo(x: First.SomeEnum, y: Second.SomeEnum) {// used compatible - longer case,// TypeScript errors something like://// declaration 'SomeEnum.B' differs value, '1' expected '2' given.x = y;y = x;} Additionally, new restrictions one enum members statically known value. cases, enum must least implicitly numeric (e.g. statically resolved initializer), explicitly numeric (meaning TypeScript could resolve value something numeric). Practically speaking, means string enum members ever compatible string enums value. ts namespace First {export declare enum SomeEnum {A,B,}}namespace Second {export declare enum SomeEnum {A,B = \"some known string\",}}function foo(x: First.SomeEnum, y: Second.SomeEnum) {// used compatible - longer case,// TypeScript errors something like://// One value 'SomeEnum.B' string '\"some known string\"', assumed unknown numeric value.x = y;y = x;} information, see pull request introduced change. Name Restrictions Enum Members TypeScript longer allows enum members use names Infinity , -Infinity , NaN . ts // Errors these://// enum member cannot numeric name.enum E {Infinity = 0,\"-Infinity\" = 1,NaN = 2,} Better Mapped Type Preservation Tuples Rest Elements Previously, applying mapped type tuple would create element type. undesirable fixed. ts Promise.all([\"\", ...([] any)]).then((result) => {const head = result[0]; // 5.3: any, 5.4: stringconst tail = result.slice(1); // 5.3 any, 5.4: any[]}); information, see fix along follow-on discussion around behavioral changes tweaks. Emit Changes breaking change per se, developers may implicitly taken dependencies TypeScript\u2019s JavaScript declaration emit outputs. following notable changes."},
{"source": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html", "title": "Documentation - TypeScript 5.5", "text": "Inferred Type Predicates section written Dan Vanderkam, implemented feature TypeScript 5.5. Thanks Dan! TypeScript\u2019s control flow analysis great job tracking type variable changes moves code: tsx interface Bird {commonName: string;scientificName: string;sing(): void;}// Maps country names -> national bird.// nations official birds (looking you, Canada!)declare const nationalBirds: Map<string, Bird>;function makeNationalBirdCall(country: string) {const bird = nationalBirds.get(country); // bird declared type Bird | undefinedif (bird) {bird.sing(); // bird type Bird inside statement} else {// bird type undefined here.}} making handle undefined case, TypeScript pushes write robust code. past, sort type refinement difficult apply arrays. would error previous versions TypeScript: tsx function makeBirdCalls(countries: string[]) {// birds: (Bird | undefined)[]const birds = countries.map(country => nationalBirds.get(country)).filter(bird => bird !== undefined);for (const bird birds) {bird.sing(); // error: 'bird' possibly 'undefined'.}} code perfectly fine: we\u2019ve filtered undefined values list. TypeScript hasn\u2019t able follow along. TypeScript 5.5, type checker fine code: tsx function makeBirdCalls(countries: string[]) {// birds: Bird[]const birds = countries.map(country => nationalBirds.get(country)).filter(bird => bird !== undefined);for (const bird birds) {bird.sing(); // ok!}} Note precise type birds . works TypeScript infers type predicate filter function. see what\u2019s going clearly pulling standalone function: tsx // function isBirdReal(bird: Bird | undefined): bird Birdfunction isBirdReal(bird: Bird | undefined) {return bird !== undefined;} bird Bird type predicate. means that, function returns true , it\u2019s Bird (if function returns false it\u2019s undefined ). type declarations Array.prototype.filter know type predicates, net result get precise type code passes type checker. TypeScript infer function returns type predicate conditions hold: - function explicit return type type predicate annotation. - function single return statement implicit returns. - function mutate parameter. - function returns boolean expression that\u2019s tied refinement parameter. Generally works you\u2019d expect. Here\u2019s examples inferred type predicates: tsx // const isNumber: (x: unknown) => x numberconst isNumber = (x: unknown) => typeof x === 'number';// const isNonNullish: <T>(x: T) => x NonNullable<T>const isNonNullish = <T,>(x: T) => x != null; Previously, TypeScript would inferred functions return boolean . infers signatures type predicates like x number x NonNullable<T> . Type predicates \u201cif if\u201d semantics. function returns x , means that: - function returns true thenx typeT . - function returns false thenx typeT . you\u2019re expecting type predicate inferred it\u2019s not, may running afoul second rule. often comes \u201ctruthiness\u201d checks: tsx function getClassroomAverage(students: string[], allScores: Map<string, number>) {const studentScores = students.map(student => allScores.get(student)).filter(score => !!score);return studentScores.reduce((a, b) => + b) / studentScores.length;// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// error: Object possibly 'undefined'.} TypeScript infer type predicate score => !!score , rightly so: returns true score number . returns false , score could either undefined number (specifically, 0 ). real bug: student got zero test, filtering score skew average upwards. Fewer average sad! first example, it\u2019s better explicitly filter undefined values: tsx function getClassroomAverage(students: string[], allScores: Map<string, number>) {const studentScores = students.map(student => allScores.get(student)).filter(score => score !== undefined);return studentScores.reduce((a, b) => + b) / studentScores.length; // ok!} truthiness check infer type predicate object types, there\u2019s ambiguity. Remember functions must return boolean candidate inferred type predicate: x => !!x might infer type predicate, x => x definitely won\u2019t. Explicit type predicates continue work exactly before. TypeScript check whether would infer type predicate. Explicit type predicates (\u201cis\u201d) safer type assertion (\u201cas\u201d). It\u2019s possible feature break existing code TypeScript infers precise type want. example: tsx // Previously, nums: (number | null)[]// Now, nums: number[]const nums = [1, 2, 3, null, 5].filter(x => x !== null);nums.push(null); // ok TS 5.4, error TS 5.5 fix tell TypeScript type want using explicit type annotation: tsx const nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null);nums.push(null); // ok versions information, check implementing pull request Dan\u2019s blog post implementing feature. Control Flow Narrowing Constant Indexed Accesses TypeScript able narrow expressions form obj[key] obj key effectively constant. ts function f1(obj: Record<string, unknown>, key: string) {if (typeof obj[key] === \"string\") {// okay, previously errorobj[key].toUpperCase();}} above, neither obj key ever mutated, TypeScript narrow type obj[key] string typeof check. information, see implementing pull request here. JSDoc @import Tag Today, want import something type-checking JavaScript file, cumbersome. JavaScript developers can\u2019t simply import type named SomeType it\u2019s runtime. js // ./some-module.d.tsexport interface SomeType {// ...}// ./index.jsimport { SomeType } \"./some-module\"; // \u274c runtime error!/*** @param {SomeType} myValue*/function doSomething(myValue) {// ...} SomeType won\u2019t exist runtime, import fail. Developers instead use namespace import instead. js import * someModule \"./some-module\";/*** @param {someModule.SomeType} myValue*/function doSomething(myValue) {// ...} ./some-module still imported runtime - might also desirable. avoid this, developers typically use import(...) types JSDoc comments. js /*** @param {import(\"./some-module\").SomeType} myValue*/function doSomething(myValue) {// ...} wanted reuse type multiple places, could use typedef avoid repeating import. js /*** @typedef {import(\"./some-module\").SomeType} SomeType*//*** @param {SomeType} myValue*/function doSomething(myValue) {// ...} helps local uses SomeType , gets repetitive many imports bit verbose. That\u2019s TypeScript supports new @import comment tag syntax ECMAScript imports. js /** @import { SomeType } \"some-module\" *//*** @param {SomeType} myValue*/function doSomething(myValue) {// ...} Here, used named imports. could also written import namespace import. js /** @import * someModule \"some-module\" *//*** @param {someModule.SomeType} myValue*/function doSomething(myValue) {// ...} JSDoc comments, don\u2019t affect runtime behavior all. would like extend big thanks Oleksandr Tarasiuk contributed change! Regular Expression Syntax Checking now, TypeScript typically skipped regular expressions code. regular expressions technically extensible grammar TypeScript never made effort compile regular expressions earlier versions JavaScript. Still, meant lots common problems would go undiscovered regular expressions, would either turn errors runtime, silently fail. TypeScript basic syntax checking regular expressions! ts let myRegex = /@robot(\\s+(please|immediately)))? task/;// ~// error!// Unexpected ')'. mean escape backslash? simple example, checking catch lot common mistakes. fact, TypeScript\u2019s checking goes slightly beyond syntactic checks. instance, TypeScript catch issues around backreferences don\u2019t exist. ts let myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;// ~// error!// backreference refers group exist.// 2 capturing groups regular expression. applies named capturing groups. ts let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<namedImport>/;// ~~~~~~~~~~~// error!// capturing group named 'namedImport' regular expression. TypeScript\u2019s checking also aware certain RegExp features used newer target version ECMAScript. example, use named capturing groups like ES5 target, we\u2019ll get error. ts let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<importedEntity>/;// ~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~// error!// Named capturing groups available targeting 'ES2018' later. true certain regular expression flags well. Note TypeScript\u2019s regular expression support limited regular expression literals. try calling new RegExp string literal, TypeScript check provided string. would like thank GitHub user graphemecluster iterated ton us get feature TypeScript. Support New ECMAScript Set Methods TypeScript 5.5 declares new proposed methods ECMAScript Set type. methods, like union , intersection , difference , symmetricDifference , take another Set return new Set result. methods, isSubsetOf , isSupersetOf , isDisjointFrom , take another Set return boolean . None methods mutate original Set s. Here\u2019s quick example might use methods behave: ts let fruits = new Set([\"apples\", \"bananas\", \"pears\", \"oranges\"]);let applesAndBananas = new Set([\"apples\", \"bananas\"]);let applesAndOranges = new Set([\"apples\", \"oranges\"]);let oranges = new Set([\"oranges\"]);let emptySet = new Set();////// union////// Set(4) {'apples', 'bananas', 'pears', 'oranges'}console.log(fruits.union(oranges));// Set(3) {'apples', 'bananas', 'oranges'}console.log(applesAndBananas.union(oranges));////// intersection////// Set(2) {'apples', 'bananas'}console.log(fruits.intersection(applesAndBananas));// Set(0) {}console.log(applesAndBananas.intersection(oranges));// Set(1) {'apples'}console.log(applesAndBananas.intersection(applesAndOranges));////// difference////// Set(3) {'apples', 'bananas', 'pears'}console.log(fruits.difference(oranges));// Set(2) {'pears', 'oranges'}console.log(fruits.difference(applesAndBananas));// Set(1) {'bananas'}console.log(applesAndBananas.difference(applesAndOranges));////// symmetricDifference////// Set(2) {'bananas', 'oranges'}console.log(applesAndBananas.symmetricDifference(applesAndOranges)); // apples////// isDisjointFrom////// trueconsole.log(applesAndBananas.isDisjointFrom(oranges));// falseconsole.log(applesAndBananas.isDisjointFrom(applesAndOranges));// trueconsole.log(fruits.isDisjointFrom(emptySet));// trueconsole.log(emptySet.isDisjointFrom(emptySet));////// isSubsetOf////// trueconsole.log(applesAndBananas.isSubsetOf(fruits));// falseconsole.log(fruits.isSubsetOf(applesAndBananas));// falseconsole.log(applesAndBananas.isSubsetOf(oranges));// trueconsole.log(fruits.isSubsetOf(fruits));// trueconsole.log(emptySet.isSubsetOf(fruits));////// isSupersetOf////// trueconsole.log(fruits.isSupersetOf(applesAndBananas));// falseconsole.log(applesAndBananas.isSupersetOf(fruits));// falseconsole.log(applesAndBananas.isSupersetOf(oranges));// trueconsole.log(fruits.isSupersetOf(fruits));// falseconsole.log(emptySet.isSupersetOf(fruits)); We\u2019d like thank Kevin Gibbons co-championed feature ECMAScript, also provided declarations Set , ReadonlySet , ReadonlySetLike TypeScript! Isolated Declarations section co-authored Rob Palmer supported design isolated declarations. Declaration files (a.k.a. .d.ts files) describe shape existing libraries modules TypeScript. lightweight description includes library\u2019s type signatures excludes implementation details function bodies. published TypeScript efficiently check usage library without needing analyse library itself. Whilst possible handwrite declaration files, authoring typed code, it\u2019s much safer simpler let TypeScript generate automatically source files using --declaration . TypeScript compiler APIs always job generating declaration files; however, use-cases might want use tools, traditional build process doesn\u2019t scale. Use-case: Faster Declaration Emit Tools Imagine wanted create faster tool generate declaration files, perhaps part publishing service new bundler. Whilst thriving ecosystem blazing fast tools turn TypeScript JavaScript, true turning TypeScript declaration files. reason TypeScript\u2019s inference allows us write code without explicitly declaring types, meaning declaration emit complex. Let\u2019s consider simple example function adds two imported variables. ts // util.tsexport let one = \"1\";export let two = \"2\";// add.tsimport { one, two } \"./util\";export function add() { return one + two; } Even thing want generate add.d.ts , TypeScript needs crawl another imported file (util.ts ), infer type one two strings, calculate + operator two strings lead string return type. ts // add.d.tsexport declare function add(): string; inference important developer experience, means tools want generate declaration files would need replicate parts type-checker including inference ability resolve module specifiers follow imports. Use-case: Parallel Declaration Emit Parallel Checking Imagine monorepo containing many projects multi-core CPU wished could help check code faster. Wouldn\u2019t great could check projects time running project different core? Unfortunately don\u2019t freedom work parallel. reason build projects dependency order, project checking declaration files dependencies. must build dependency first generate declaration files. TypeScript\u2019s project references feature works way, building set projects \u201ctopological\u201d dependency order. example, two projects called backend frontend , depend project called core , TypeScript can\u2019t start type-checking either frontend backend core built declaration files generated. graph, see bottleneck. Whilst build frontend backend parallel, need first wait core finish building either start. could improve upon this? Well, fast tool could generate declaration files core parallel, TypeScript could immediately follow type-checking core , frontend , backend also parallel. Solution: Explicit Types! common requirement use-cases need cross-file type-checker generate declaration files. lot ask tooling community. complex example, want declaration file following code\u2026 ts import { add } \"./add\";const x = add();export function foo() {return x;} \u2026we would need generate signature foo . Well requires looking implementation foo . foo returns x , getting type x requires looking implementation add . might require looking implementation add \u2019s dependencies, on. we\u2019re seeing generating declaration files requires whole lot logic figure types different places might even local current file. Still, developers looking fast iteration time fully parallel builds, another way thinking problem. declaration file requires types public API module - words, types things exported. If, controversially, developers willing explicitly write types things export, tools could generate declaration files without needing look implementation module - without reimplementing full type-checker. new --isolatedDeclarations option comes in. --isolatedDeclarations reports errors module can\u2019t reliably transformed without type-checker. plainly, makes TypeScript report errors file isn\u2019t sufficiently annotated exports. means example, would see error like following: ts export function foo() {// ~~~// error! Function must explicit// return type annotation --isolatedDeclarations.return x;} errors desirable? means TypeScript - Tell us up-front whether tools issues generating declaration files - Provide quick fix help add missing annotations. mode doesn\u2019t require annotations everywhere though. locals, ignored, since don\u2019t affect public API. example, following code would produce error: ts import { add } \"./add\";const x = add(\"1\", \"2\"); // error 'x', exported.export function foo(): string {return x;} also certain expressions type \u201ctrivial\u201d calculate. ts // error 'x'.// trivial calculate type 'number'export let x = 10;// error 'y'.// get type return expression.export function y() {return 20;}// error 'z'.// type assertion makes clear type is.export function z() {return Math.max(x, y()) number;} Using isolatedDeclarations isolatedDeclarations requires either declaration composite flags also set. Note isolatedDeclarations change TypeScript performs emit - reports errors. Importantly, similar isolatedModules , enabling feature TypeScript won\u2019t immediately bring potential benefits discussed here. please patient look forward future developments space. Keeping tool authors mind, also recognize today, TypeScript\u2019s declaration emit easily replicated tools wanting use guide. That\u2019s something we\u2019re actively working improving. top this, isolated declarations still new feature, we\u2019re actively working improving experience. scenarios, like using computed property declarations classes object literals, yet supported isolatedDeclarations . Keep eye space, feel free provide us feedback. also feel worth calling isolatedDeclarations adopted case-by-case basis. developer ergonomics lost using isolatedDeclarations , thus may right choice setup leveraging two scenarios mentioned earlier. others, work isolatedDeclarations already uncovered many optimizations opportunities unlock different parallel build strategies. meantime, you\u2019re willing make trade-offs, believe isolatedDeclarations powerful tool speed build process external tooling becomes widely available. information, read Isolated Declarations: State Feature discussion TypeScript issue tracker. Credit Work isolatedDeclarations long-time collaborative effort TypeScript team infrastructure tooling teams within Bloomberg Google. Individuals like Hana Joo Google implemented quick fix isolated declaration errors (more soon), well Ashley Claymore, Jan K\u00fchle, Lisa Velden, Rob Palmer, Thomas Chetwin involved discussion, specification, implementation many months. feel specifically worth calling tremendous amount work provided Titian Cernicova-Dragomir Bloomberg. Titian instrumental driving implementation isolatedDeclarations contributor TypeScript project years prior. feature involved many changes, see core work Isolated Declarations here. ${configDir} Template Variable Configuration Files It\u2019s common many codebases reuse shared tsconfig.json file acts \u201cbase\u201d configuration files. done using extends field tsconfig.json file. json {\"extends\": \"../../tsconfig.base.json\",\"compilerOptions\": {\"outDir\": \"./dist\"}} One issues paths tsconfig.json file relative location file itself. means shared tsconfig.base.json file used multiple projects, relative paths often won\u2019t useful derived projects. example, imagine following tsconfig.base.json : json {\"compilerOptions\": {\"typeRoots\": [\"./node_modules/@types\"\"./custom-types\"],\"outDir\": \"dist\"}} author\u2019s intent every tsconfig.json extends file - output dist directory relative derivedtsconfig.json , - custom-types directory relative derivedtsconfig.json , would work. typeRoots paths would relative location shared tsconfig.base.json file, project extends it. project extends shared file would need declare outDir typeRoots identical contents. could frustrating hard keep sync projects, example using typeRoots , common problem paths options. solve this, TypeScript 5.5 introduces new template variable ${configDir} . ${configDir} written certain path fields tsconfig.json jsconfig.json files, variable substituted containing directory configuration file given compilation. means tsconfig.base.json could rewritten as: json {\"compilerOptions\": {\"typeRoots\": [\"${configDir}/node_modules/@types\"\"${configDir}/custom-types\"],\"outDir\": \"${configDir}/dist\"}} Now, project extends file, paths relative derived tsconfig.json , shared tsconfig.base.json file. makes easier share configuration files across projects ensures configuration files portable. intend make tsconfig.json file extendable, consider ./ instead written ${configDir} . information, see proposal issue implementing pull request. Consulting package.json Dependencies Declaration File Generation Previously, TypeScript would often issue error message like inferred type \"X\" cannot named without reference \"Y\". likely portable. type annotation necessary. often due TypeScript\u2019s declaration file generation finding contents files never explicitly imported program. Generating import file could risky path ended relative. Still, codebases explicit dependencies dependencies (or peerDependencies optionalDependencies ) package.json , generating import safe certain resolution modes. TypeScript 5.5, we\u2019re lenient that\u2019s case, many occurrences error disappear. See pull request details change. Editor Watch-Mode Reliability Improvements TypeScript either added new functionality fixed existing logic makes --watch mode TypeScript\u2019s editor integration feel reliable. hopefully translate fewer TSServer/editor restarts. Correctly Refresh Editor Errors Configuration Files TypeScript generate errors tsconfig.json files; however, errors actually generated loading project, editors typically don\u2019t directly request errors tsconfig.json files. sounds like technical detail, means errors issued tsconfig.json fixed, TypeScript doesn\u2019t issue new fresh empty set errors, users left stale errors unless reload editor. TypeScript 5.5 intentionally issues event clear out. See here. Better Handling Deletes Followed Immediate Writes Instead overwriting files, tools opt delete create new files scratch. case running npm ci , instance. efficient tools, problematic TypeScript\u2019s editor scenarios deleting watched might dispose transitive dependencies. Deleting creating file quick succession could lead TypeScript tearing entire project rebuilding scratch. TypeScript 5.5 nuanced approach keeping parts deleted project around picks new creation event. make operations like npm ci work lot better TypeScript. See information approach here. Symlinks Tracked Failed Resolutions TypeScript fails resolve module, still need watch failed lookup paths case module added later. Previously done symlinked directories, could cause reliability issues monorepo-like scenarios build occurred one project witnessed other. fixed TypeScript 5.5, means won\u2019t need restart editor often. Project References Contribute Auto-Imports Auto-imports longer requires least one explicit import dependent projects project reference setup. Instead, auto-import completions work across anything you\u2019ve listed references field tsconfig.json . See implementing pull request. Performance Size Optimizations Monomorphized Objects Language Service Public API TypeScript 5.0, ensured Node Symbol objects consistent set properties consistent initialization order. helps reduce polymorphism different operations, allows runtimes fetch properties quickly. making change, witnessed impressive speed wins compiler; however, changes performed internal allocators data structures. language service, along TypeScript\u2019s public API, uses different set allocators certain objects. allowed TypeScript compiler bit leaner, data used language service would never used compiler. TypeScript 5.5, monomorphization work done language service public API. means editor experience, build tools use TypeScript API, get decent amount faster. fact, benchmarks, we\u2019ve seen 5-8% speedup build times using public TypeScript API\u2019s allocators, language service operations getting 10-20% faster. imply increase memory, believe tradeoff worth hope find ways reduce memory overhead. Things feel lot snappier now. information, see change here. Monomorphized Control Flow Nodes TypeScript 5.5, nodes control flow graph monomorphized always hold consistent shape. so, check times often reduced 1%. Optimizations Control Flow Graph many cases, control flow analysis traverse nodes don\u2019t provide new information. observed absence early termination effects antecedents (or \u201cdominators\u201d) certain nodes meant nodes could always skipped over. such, TypeScript constructs control flow graphs take advantage linking earlier node provide interesting information control flow analysis. yields flatter control flow graph, efficient traverse. optimization yielded modest gains, 2% reductions build time certain codebases. read here. Skipped Checking transpileModule transpileDeclaration TypeScript\u2019s transpileModule API used compiling single TypeScript file\u2019s contents JavaScript. Similarly, transpileDeclaration API (see below) used generate declaration file single TypeScript file. One issues APIs TypeScript internally would perform full type-checking pass entire contents file emitting output. necessary collect certain information would later used emit phase. TypeScript 5.5, we\u2019ve found way avoid performing full check, lazily collecting information necessary, transpileModule transpileDeclaration enable functionality default. result, tools integrate APIs, like ts-loader transpileOnly ts-jest, see noticeable speedup. testing, generally witness around 2x speed-up build time using transpileModule . TypeScript Package Size Reduction leveraging transition modules 5.0, we\u2019ve significantly reduced TypeScript\u2019s overall package size making tsserver.js typingsInstaller.js import common API library instead produce standalone bundles. reduces TypeScript\u2019s size disk 30.2 MB 20.4 MB, reduces packed size 5.5 MB 3.7 MB! Node Reuse Declaration Emit part work enable isolatedDeclarations , we\u2019ve substantially improved often TypeScript directly copy input source code producing declaration files. example, let\u2019s say wrote ts export const strBool: string | boolean = \"hello\";export const boolStr: boolean | string = \"world\"; Note union types equivalent, order union different. emitting declaration file, TypeScript two equivalent output possibilities. first use consistent canonical representation type: ts export const strBool: string | boolean;export const boolStr: string | boolean; second re-use type annotations exactly written: ts export const strBool: string | boolean;export const boolStr: boolean | string; second approach generally preferable reasons: - Many equivalent representations still encode level intent better preserve declaration file - Producing fresh representation type somewhat expensive, avoiding better - User-written types usually shorter generated type representations 5.5, we\u2019ve greatly improved number places TypeScript correctly identify places it\u2019s safe correct print back types exactly written input file. Many cases invisible performance improvements - TypeScript would generate fresh sets syntax nodes serialize string. Instead, TypeScript operate original syntax nodes directly, much cheaper faster. Caching Contextual Types Discriminated Unions TypeScript asks contextual type expression like object literal, often encounter union type. cases, TypeScript tries filter members union based known properties well known values (i.e. discriminant properties). work fairly expensive, especially end object consisting many many properties. TypeScript 5.5, much computation cached TypeScript doesn\u2019t need recompute every property object literal. Performing optimization shaved 250ms compiling TypeScript compiler itself. Easier API Consumption ECMAScript Modules Previously, writing ECMAScript module Node.js, named imports available typescript package. ts import { createSourceFile } \"typescript\"; // \u274c errorimport * ts \"typescript\";ts.createSourceFile // \u274c undefined???ts.default.createSourceFile // \u2705 works - ugh! cjs-module-lexer recognize pattern TypeScript\u2019s generated CommonJS code. fixed, users use named imports TypeScript npm package ECMAScript modules Node.js. ts import { createSourceFile } \"typescript\"; // \u2705 works now!import * ts \"typescript\";ts.createSourceFile // \u2705 works now! information, see change here. transpileDeclaration API TypeScript\u2019s API exposes function called transpileModule . It\u2019s intended make easy compile single file TypeScript code. doesn\u2019t access entire program, caveat may produce right output code violates errors isolatedModules option. TypeScript 5.5, we\u2019ve added new similar API called transpileDeclaration . API similar transpileModule , it\u2019s specifically designed generate single declaration file based input source text. like transpileModule , doesn\u2019t access full program, similar caveat applies: generates accurate declaration file input code free errors new isolatedDeclarations option. desired, function used parallelize declaration emit across files isolatedDeclarations mode. information, see implementation here. Notable Behavioral Changes section highlights set noteworthy changes acknowledged understood part upgrade. Sometimes highlight deprecations, removals, new restrictions. also contain bug fixes functionally improvements, also affect existing build introducing new errors. Disabling Features Deprecated TypeScript 5.0 TypeScript 5.0 deprecated following options behaviors: charset target: ES3 importsNotUsedAsValues noImplicitUseStrict noStrictGenericChecks keyofStringsOnly suppressExcessPropertyErrors suppressImplicitAnyIndexErrors preserveValueImports prepend project references- implicitly OS-specific newLine continue using deprecated options above, developers using TypeScript 5.0 recent versions specify new option called ignoreDeprecations value \"5.0\" . TypeScript 5.5, options longer effect. help smooth upgrade path, may still specify tsconfig, error specify TypeScript 6.0. See also Flag Deprecation Plan outlines deprecation strategy. information around deprecation plans available GitHub, contains suggestions best adapt codebase. lib.d.ts Changes Types generated DOM may impact type-checking codebase. information, see DOM updates TypeScript 5.5. Stricter Parsing Decorators Since TypeScript originally introduced support decorators, specified grammar proposal tightened up. TypeScript stricter forms allows. rare, existing decorators may need parenthesized avoid errors. ts class DecoratorProvider {decorate(...args: any[]) { }}class extends DecoratorProvider {m() {class C {@super.decorate // \u274c errormethod1() { }@(super.decorate) // \u2705 okaymethod2() { }}}} See information change here. undefined Longer Definable Type Name TypeScript always disallowed type alias names conflict built-in types: ts // Illegaltype null = any;// Illegaltype number = any;// Illegaltype object = any;// Illegaltype = any; Due bug, logic didn\u2019t also apply built-in type undefined . 5.5, correctly identified error: ts // also illegaltype undefined = any; Bare references type aliases named undefined never actually worked first place. could define them, couldn\u2019t use unqualified type name. ts export type undefined = string;export const m: undefined = \"\";// ^// Errors 5.4 earlier - local definition 'undefined' even consulted. information, see change here. Simplified Reference Directive Declaration Emit producing declaration file, TypeScript would synthesize reference directive believed one required. example, Node.js modules declared ambiently, cannot loaded module resolution alone. file like: tsx import path \"path\";export const myPath = path.parse(__filename); Would emit declaration file like: tsx /// <reference types=\"node\" />import path \"path\";export declare const myPath: path.ParsedPath; Even though reference directive never appeared original source. Similarly, TypeScript also removed reference directives believe needed part output. example, let\u2019s imagine reference directive jest ; however, imagine reference directive isn\u2019t necessary generate declaration file. TypeScript would simply drop it. following example: tsx /// <reference types=\"jest\" />import path \"path\";export const myPath = path.parse(__filename); TypeScript would still emit: tsx /// <reference types=\"node\" />import path \"path\";export declare const myPath: path.ParsedPath; course working isolatedDeclarations , realized logic untenable anyone attempting implement declaration emitter without type checking using single file\u2019s context. behavior also hard understand user\u2019s perspective; whether reference directive appeared emitted file seems inconsistent difficult predict unless understand exactly what\u2019s going typechecking. prevent declaration emit different isolatedDeclarations enabled, knew emit needed change. experimentation, found nearly cases TypeScript synthesized reference directives pull node react . cases expectation downstream user already references types tsconfig.json \"types\" library imports, longer synthesizing reference directives would unlikely break anyone. It\u2019s worth noting already works lib.d.ts ; TypeScript doesn\u2019t synthesize reference lib=\"es2015\" module exports WeakMap , instead assuming downstream user included part environment. reference directives written library authors (not synthesized), experimentation showed nearly removed, never showing output. reference directives preserved broken likely intended preserved. Given results, decided greatly simplfy reference directives declaration emit TypeScript 5.5. consistent strategy help library authors consumers better control declaration files. Reference directives longer synthesized. User-written reference directives longer preserved, unless annotated new preserve=\"true\" attribute. Concretely, input file like: tsx /// <reference types=\"some-lib\" preserve=\"true\" />/// <reference types=\"jest\" />import path \"path\";export const myPath = path.parse(__filename); emit: tsx /// <reference types=\"some-lib\" preserve=\"true\" />import path \"path\";export declare const myPath: path.ParsedPath; Adding preserve=\"true\" backwards compatible older versions TypeScript unknown attributes ignored. change also improved performance; benchmarks, emit stage saw 1-4% improvement projects declaration emit enabled."}]